(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/assert/assert.js","/../node_modules/assert")
},{"buffer":11,"pBGvAp":74,"util/":99}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// base-x encoding
// Forked from https://github.com/cryptocoinjs/bs58
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

module.exports = function base (ALPHABET) {
  var ALPHABET_MAP = {}
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)

  // pre-compute lookup table
  for (var i = 0; i < ALPHABET.length; i++) {
    ALPHABET_MAP[ALPHABET.charAt(i)] = i
  }

  function encode (source) {
    if (source.length === 0) return ''

    var digits = [0]
    for (var i = 0; i < source.length; ++i) {
      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
        carry += digits[j] << 8
        digits[j] = carry % BASE
        carry = (carry / BASE) | 0
      }

      while (carry > 0) {
        digits.push(carry % BASE)
        carry = (carry / BASE) | 0
      }
    }

    // deal with leading zeros
    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      digits.push(0)
    }

    // convert digits to a string
    for (var ii = 0, jj = digits.length - 1; ii <= jj; ++ii, --jj) {
      var tmp = ALPHABET[digits[ii]]
      digits[ii] = ALPHABET[digits[jj]]
      digits[jj] = tmp
    }

    return digits.join('')
  }

  function decode (string) {
    if (string.length === 0) return []

    var bytes = [0]
    for (var i = 0; i < string.length; i++) {
      var value = ALPHABET_MAP[string[i]]
      if (value === undefined) throw new Error('Non-base' + BASE + ' character')

      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * BASE
        bytes[j] = carry & 0xff
        carry >>= 8
      }

      while (carry > 0) {
        bytes.push(carry & 0xff)
        carry >>= 8
      }
    }

    // deal with leading zeros
    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
      bytes.push(0)
    }

    return bytes.reverse()
  }

  return {
    encode: encode,
    decode: decode
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base-x/index.js","/../node_modules/base-x")
},{"buffer":11,"pBGvAp":74}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base64-js/lib/b64.js","/../node_modules/base64-js/lib")
},{"buffer":11,"pBGvAp":74}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// (public) Constructor
function BigInteger(a, b, c) {
  if (!(this instanceof BigInteger))
    return new BigInteger(a, b, c)

  if (a != null) {
    if ("number" == typeof a) this.fromNumber(a, b, c)
    else if (b == null && "string" != typeof a) this.fromString(a, 256)
    else this.fromString(a, b)
  }
}

var proto = BigInteger.prototype

// duck-typed isBigInteger
proto.__bigi = require('../package.json').version
BigInteger.isBigInteger = function (obj, check_ver) {
  return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
}

// Bits per digit
var dbits

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c
    c = Math.floor(v / 0x4000000)
    w[j++] = v & 0x3ffffff
  }
  return c
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
    xh = x >> 15
  while (--n >= 0) {
    var l = this[i] & 0x7fff
    var h = this[i++] >> 15
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30)
    w[j++] = l & 0x3fffffff
  }
  return c
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
    xh = x >> 14
  while (--n >= 0) {
    var l = this[i] & 0x3fff
    var h = this[i++] >> 14
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c
    c = (l >> 28) + (m >> 14) + xh * h
    w[j++] = l & 0xfffffff
  }
  return c
}

// wtf?
BigInteger.prototype.am = am1
dbits = 26

BigInteger.prototype.DB = dbits
BigInteger.prototype.DM = ((1 << dbits) - 1)
var DV = BigInteger.prototype.DV = (1 << dbits)

var BI_FP = 52
BigInteger.prototype.FV = Math.pow(2, BI_FP)
BigInteger.prototype.F1 = BI_FP - dbits
BigInteger.prototype.F2 = 2 * dbits - BI_FP

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
var BI_RC = new Array()
var rr, vv
rr = "0".charCodeAt(0)
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv
rr = "a".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv
rr = "A".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv

function int2char(n) {
  return BI_RM.charAt(n)
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)]
  return (c == null) ? -1 : c
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i]
  r.t = this.t
  r.s = this.s
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1
  this.s = (x < 0) ? -1 : 0
  if (x > 0) this[0] = x
  else if (x < -1) this[0] = x + DV
  else this.t = 0
}

// return bigint initialized to value
function nbv(i) {
  var r = new BigInteger()
  r.fromInt(i)
  return r
}

// (protected) set from string and radix
function bnpFromString(s, b) {
  var self = this

  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else {
    self.fromRadix(s, b)
    return
  }
  self.t = 0
  self.s = 0
  var i = s.length,
    mi = false,
    sh = 0
  while (--i >= 0) {
    var x = (k == 8) ? s[i] & 0xff : intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true
      continue
    }
    mi = false
    if (sh == 0)
      self[self.t++] = x
    else if (sh + k > self.DB) {
      self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh
      self[self.t++] = (x >> (self.DB - sh))
    } else
      self[self.t - 1] |= x << sh
    sh += k
    if (sh >= self.DB) sh -= self.DB
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    self.s = -1
    if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh
  }
  self.clamp()
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s & this.DM
  while (this.t > 0 && this[this.t - 1] == c)--this.t
}

// (public) return string representation in given radix
function bnToString(b) {
  var self = this
  if (self.s < 0) return "-" + self.negate()
    .toString(b)
  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else return self.toRadix(b)
  var km = (1 << k) - 1,
    d, m = false,
    r = "",
    i = self.t
  var p = self.DB - (i * self.DB) % k
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) > 0) {
      m = true
      r = int2char(d)
    }
    while (i >= 0) {
      if (p < k) {
        d = (self[i] & ((1 << p) - 1)) << (k - p)
        d |= self[--i] >> (p += self.DB - k)
      } else {
        d = (self[i] >> (p -= k)) & km
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if (d > 0) m = true
      if (m) r += int2char(d)
    }
  }
  return m ? r : "0"
}

// (public) -this
function bnNegate() {
  var r = new BigInteger()
  BigInteger.ZERO.subTo(this, r)
  return r
}

// (public) |this|
function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s - a.s
  if (r != 0) return r
  var i = this.t
  r = i - a.t
  if (r != 0) return (this.s < 0) ? -r : r
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0) return r
  return 0
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1,
    t
  if ((t = x >>> 16) != 0) {
    x = t
    r += 16
  }
  if ((t = x >> 8) != 0) {
    x = t
    r += 8
  }
  if ((t = x >> 4) != 0) {
    x = t
    r += 4
  }
  if ((t = x >> 2) != 0) {
    x = t
    r += 2
  }
  if ((t = x >> 1) != 0) {
    x = t
    r += 1
  }
  return r
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if (this.t <= 0) return 0
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

// (public) return the number of bytes in "this"
function bnByteLength() {
  return this.bitLength() >> 3
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
  var i
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i]
  for (i = n - 1; i >= 0; --i) r[i] = 0
  r.t = this.t + n
  r.s = this.s
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i]
  r.t = Math.max(this.t - n, 0)
  r.s = this.s
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
  var self = this
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << cbs) - 1
  var ds = Math.floor(n / self.DB),
    c = (self.s << bs) & self.DM,
    i
  for (i = self.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (self[i] >> cbs) | c
    c = (self[i] & bm) << bs
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0
  r[ds] = c
  r.t = self.t + ds + 1
  r.s = self.s
  r.clamp()
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
  var self = this
  r.s = self.s
  var ds = Math.floor(n / self.DB)
  if (ds >= self.t) {
    r.t = 0
    return
  }
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << bs) - 1
  r[0] = self[ds] >> bs
  for (var i = ds + 1; i < self.t; ++i) {
    r[i - ds - 1] |= (self[i] & bm) << cbs
    r[i - ds] = self[i] >> bs
  }
  if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs
  r.t = self.t - ds
  r.clamp()
}

// (protected) r = this - a
function bnpSubTo(a, r) {
  var self = this
  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] - a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c -= a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c -= a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c -= a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c < -1) r[i++] = self.DV + c
  else if (c > 0) r[i++] = c
  r.t = i
  r.clamp()
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
  var x = this.abs(),
    y = a.abs()
  var i = x.t
  r.t = i + y.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)
  r.s = 0
  r.clamp()
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs()
  var i = r.t = 2 * x.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1)
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV
      r[i + x.t + 1] = 1
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)
  r.s = 0
  r.clamp()
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
  var self = this
  var pm = m.abs()
  if (pm.t <= 0) return
  var pt = self.abs()
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0)
    if (r != null) self.copyTo(r)
    return
  }
  if (r == null) r = new BigInteger()
  var y = new BigInteger(),
    ts = self.s,
    ms = m.s
  var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
  if (nsh > 0) {
    pm.lShiftTo(nsh, y)
    pt.lShiftTo(nsh, r)
  } else {
    pm.copyTo(y)
    pt.copyTo(r)
  }
  var ys = y.t
  var y0 = y[ys - 1]
  if (y0 == 0) return
  var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0)
  var d1 = self.FV / yt,
    d2 = (1 << self.F1) / yt,
    e = 1 << self.F2
  var i = r.t,
    j = i - ys,
    t = (q == null) ? new BigInteger() : q
  y.dlShiftTo(j, t)
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1
    r.subTo(t, r)
  }
  BigInteger.ONE.dlShiftTo(ys, t)
  t.subTo(y, y); // "negative" y so we can replace sub with am later
  while (y.t < ys) y[y.t++] = 0
  while (--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2)
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
      y.dlShiftTo(j, t)
      r.subTo(t, r)
      while (r[i] < --qd) r.subTo(t, r)
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q)
    if (ts != ms) BigInteger.ZERO.subTo(q, q)
  }
  r.t = ys
  r.clamp()
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
  if (ts < 0) BigInteger.ZERO.subTo(r, r)
}

// (public) this mod a
function bnMod(a) {
  var r = new BigInteger()
  this.abs()
    .divRemTo(a, null, r)
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r)
  return r
}

// Modular reduction using "classic" algorithm
function Classic(m) {
  this.m = m
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m)
  else return x
}

function cRevert(x) {
  return x
}

function cReduce(x) {
  x.divRemTo(this.m, null, x)
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

function cSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

Classic.prototype.convert = cConvert
Classic.prototype.revert = cRevert
Classic.prototype.reduce = cReduce
Classic.prototype.mulTo = cMulTo
Classic.prototype.sqrTo = cSqrTo

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if (this.t < 1) return 0
  var x = this[0]
  if ((x & 1) == 0) return 0
  var y = x & 3; // y == 1/x mod 2^2
  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y > 0) ? this.DV - y : -y
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m
  this.mp = m.invDigit()
  this.mpl = this.mp & 0x7fff
  this.mph = this.mp >> 15
  this.um = (1 << (m.DB - 15)) - 1
  this.mt2 = 2 * m.t
}

// xR mod m
function montConvert(x) {
  var r = new BigInteger()
  x.abs()
    .dlShiftTo(this.m.t, r)
  r.divRemTo(this.m, null, r)
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)
  return r
}

// x/R mod m
function montRevert(x) {
  var r = new BigInteger()
  x.copyTo(r)
  this.reduce(r)
  return r
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0
  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i] & 0x7fff
    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM
    // use am to combine the multiply-shift-add into one call
    j = i + this.m.t
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t)
    // propagate carry
    while (x[j] >= x.DV) {
      x[j] -= x.DV
      x[++j]++
    }
  }
  x.clamp()
  x.drShiftTo(this.m.t, x)
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x)
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Montgomery.prototype.convert = montConvert
Montgomery.prototype.revert = montRevert
Montgomery.prototype.reduce = montReduce
Montgomery.prototype.mulTo = montMulTo
Montgomery.prototype.sqrTo = montSqrTo

// (protected) true iff this is even
function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE
  var r = new BigInteger(),
    r2 = new BigInteger(),
    g = z.convert(this),
    i = nbits(e) - 1
  g.copyTo(r)
  while (--i >= 0) {
    z.sqrTo(r, r2)
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r)
    else {
      var t = r
      r = r2
      r2 = t
    }
  }
  return z.revert(r)
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
  var z
  if (e < 256 || m.isEven()) z = new Classic(m)
  else z = new Montgomery(m)
  return this.exp(e, z)
}

// protected
proto.copyTo = bnpCopyTo
proto.fromInt = bnpFromInt
proto.fromString = bnpFromString
proto.clamp = bnpClamp
proto.dlShiftTo = bnpDLShiftTo
proto.drShiftTo = bnpDRShiftTo
proto.lShiftTo = bnpLShiftTo
proto.rShiftTo = bnpRShiftTo
proto.subTo = bnpSubTo
proto.multiplyTo = bnpMultiplyTo
proto.squareTo = bnpSquareTo
proto.divRemTo = bnpDivRemTo
proto.invDigit = bnpInvDigit
proto.isEven = bnpIsEven
proto.exp = bnpExp

// public
proto.toString = bnToString
proto.negate = bnNegate
proto.abs = bnAbs
proto.compareTo = bnCompareTo
proto.bitLength = bnBitLength
proto.byteLength = bnByteLength
proto.mod = bnMod
proto.modPowInt = bnModPowInt

// (public)
function bnClone() {
  var r = new BigInteger()
  this.copyTo(r)
  return r
}

// (public) return value as integer
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV
    else if (this.t == 0) return -1
  } else if (this.t == 1) return this[0]
  else if (this.t == 0) return 0
  // assumes 16 < DB < 32
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

// (public) return value as byte
function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r))
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if (this.s < 0) return -1
  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0
  else return 1
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if (b == null) b = 10
  if (this.signum() == 0 || b < 2 || b > 36) return "0"
  var cs = this.chunkSize(b)
  var a = Math.pow(b, cs)
  var d = nbv(a),
    y = new BigInteger(),
    z = new BigInteger(),
    r = ""
  this.divRemTo(d, y, z)
  while (y.signum() > 0) {
    r = (a + z.intValue())
      .toString(b)
      .substr(1) + r
    y.divRemTo(d, y, z)
  }
  return z.intValue()
    .toString(b) + r
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
  var self = this
  self.fromInt(0)
  if (b == null) b = 10
  var cs = self.chunkSize(b)
  var d = Math.pow(b, cs),
    mi = false,
    j = 0,
    w = 0
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-" && self.signum() == 0) mi = true
      continue
    }
    w = b * w + x
    if (++j >= cs) {
      self.dMultiply(d)
      self.dAddOffset(w, 0)
      j = 0
      w = 0
    }
  }
  if (j > 0) {
    self.dMultiply(Math.pow(b, j))
    self.dAddOffset(w, 0)
  }
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
  var self = this
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) self.fromInt(1)
    else {
      self.fromNumber(a, c)
      if (!self.testBit(a - 1)) // force MSB set
        self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self)
      if (self.isEven()) self.dAddOffset(1, 0); // force odd
      while (!self.isProbablePrime(b)) {
        self.dAddOffset(2, 0)
        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
      t = a & 7
    x.length = (a >> 3) + 1
    b.nextBytes(x)
    if (t > 0) x[0] &= ((1 << t) - 1)
    else x[0] = 0
    self.fromString(x, 256)
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var self = this
  var i = self.t,
    r = new Array()
  r[0] = self.s
  var p = self.DB - (i * self.DB) % 8,
    d, k = 0
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
      r[k++] = d | (self.s << (self.DB - p))
    while (i >= 0) {
      if (p < 8) {
        d = (self[i] & ((1 << p) - 1)) << (8 - p)
        d |= self[--i] >> (p += self.DB - 8)
      } else {
        d = (self[i] >> (p -= 8)) & 0xff
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if ((d & 0x80) != 0) d |= -256
      if (k === 0 && (self.s & 0x80) != (d & 0x80))++k
      if (k > 0 || d != self.s) r[k++] = d
    }
  }
  return r
}

function bnEquals(a) {
  return (this.compareTo(a) == 0)
}

function bnMin(a) {
  return (this.compareTo(a) < 0) ? this : a
}

function bnMax(a) {
  return (this.compareTo(a) > 0) ? this : a
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
  var self = this
  var i, f, m = Math.min(a.t, self.t)
  for (i = 0; i < m; ++i) r[i] = op(self[i], a[i])
  if (a.t < self.t) {
    f = a.s & self.DM
    for (i = m; i < self.t; ++i) r[i] = op(self[i], f)
    r.t = self.t
  } else {
    f = self.s & self.DM
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i])
    r.t = a.t
  }
  r.s = op(self.s, a.s)
  r.clamp()
}

// (public) this & a
function op_and(x, y) {
  return x & y
}

function bnAnd(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_and, r)
  return r
}

// (public) this | a
function op_or(x, y) {
  return x | y
}

function bnOr(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_or, r)
  return r
}

// (public) this ^ a
function op_xor(x, y) {
  return x ^ y
}

function bnXor(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_xor, r)
  return r
}

// (public) this & ~a
function op_andnot(x, y) {
  return x & ~y
}

function bnAndNot(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_andnot, r)
  return r
}

// (public) ~this
function bnNot() {
  var r = new BigInteger()
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i]
  r.t = this.t
  r.s = ~this.s
  return r
}

// (public) this << n
function bnShiftLeft(n) {
  var r = new BigInteger()
  if (n < 0) this.rShiftTo(-n, r)
  else this.lShiftTo(n, r)
  return r
}

// (public) this >> n
function bnShiftRight(n) {
  var r = new BigInteger()
  if (n < 0) this.lShiftTo(-n, r)
  else this.rShiftTo(n, r)
  return r
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if (x == 0) return -1
  var r = 0
  if ((x & 0xffff) == 0) {
    x >>= 16
    r += 16
  }
  if ((x & 0xff) == 0) {
    x >>= 8
    r += 8
  }
  if ((x & 0xf) == 0) {
    x >>= 4
    r += 4
  }
  if ((x & 3) == 0) {
    x >>= 2
    r += 2
  }
  if ((x & 1) == 0)++r
  return r
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i])
  if (this.s < 0) return this.t * this.DB
  return -1
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0
  while (x != 0) {
    x &= x - 1
    ++r
  }
  return r
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0,
    x = this.s & this.DM
  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x)
  return r
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n / this.DB)
  if (j >= this.t) return (this.s != 0)
  return ((this[j] & (1 << (n % this.DB))) != 0)
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n)
  this.bitwiseTo(r, op, r)
  return r
}

// (public) this | (1<<n)
function bnSetBit(n) {
  return this.changeBit(n, op_or)
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
  return this.changeBit(n, op_andnot)
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
  return this.changeBit(n, op_xor)
}

// (protected) r = this + a
function bnpAddTo(a, r) {
  var self = this

  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] + a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c += a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c += a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c > 0) r[i++] = c
  else if (c < -1) r[i++] = self.DV + c
  r.t = i
  r.clamp()
}

// (public) this + a
function bnAdd(a) {
  var r = new BigInteger()
  this.addTo(a, r)
  return r
}

// (public) this - a
function bnSubtract(a) {
  var r = new BigInteger()
  this.subTo(a, r)
  return r
}

// (public) this * a
function bnMultiply(a) {
  var r = new BigInteger()
  this.multiplyTo(a, r)
  return r
}

// (public) this^2
function bnSquare() {
  var r = new BigInteger()
  this.squareTo(r)
  return r
}

// (public) this / a
function bnDivide(a) {
  var r = new BigInteger()
  this.divRemTo(a, r, null)
  return r
}

// (public) this % a
function bnRemainder(a) {
  var r = new BigInteger()
  this.divRemTo(a, null, r)
  return r
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = new BigInteger(),
    r = new BigInteger()
  this.divRemTo(a, q, r)
  return new Array(q, r)
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t)
  ++this.t
  this.clamp()
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
  if (n == 0) return
  while (this.t <= w) this[this.t++] = 0
  this[w] += n
  while (this[w] >= this.DV) {
    this[w] -= this.DV
    if (++w >= this.t) this[this.t++] = 0
    ++this[w]
  }
}

// A "null" reducer
function NullExp() {}

function nNop(x) {
  return x
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r)
}

function nSqrTo(x, r) {
  x.squareTo(r)
}

NullExp.prototype.convert = nNop
NullExp.prototype.revert = nNop
NullExp.prototype.mulTo = nMulTo
NullExp.prototype.sqrTo = nSqrTo

// (public) this^e
function bnPow(e) {
  return this.exp(e, new NullExp())
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n)
  r.s = 0; // assumes a,this >= 0
  r.t = i
  while (i > 0) r[--i] = 0
  var j
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t)
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i)
  r.clamp()
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
  --n
  var i = r.t = this.t + a.t - n
  r.s = 0; // assumes a,this >= 0
  while (--i >= 0) r[i] = 0
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n)
  r.clamp()
  r.drShiftTo(1, r)
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = new BigInteger()
  this.q3 = new BigInteger()
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2)
  this.mu = this.r2.divide(m)
  this.m = m
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m)
  else if (x.compareTo(this.m) < 0) return x
  else {
    var r = new BigInteger()
    x.copyTo(r)
    this.reduce(r)
    return r
  }
}

function barrettRevert(x) {
  return x
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  var self = this
  x.drShiftTo(self.m.t - 1, self.r2)
  if (x.t > self.m.t + 1) {
    x.t = self.m.t + 1
    x.clamp()
  }
  self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3)
  self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2)
  while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1)
  x.subTo(self.r2, x)
  while (x.compareTo(self.m) >= 0) x.subTo(self.m, x)
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Barrett.prototype.convert = barrettConvert
Barrett.prototype.revert = barrettRevert
Barrett.prototype.reduce = barrettReduce
Barrett.prototype.mulTo = barrettMulTo
Barrett.prototype.sqrTo = barrettSqrTo

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
  var i = e.bitLength(),
    k, r = nbv(1),
    z
  if (i <= 0) return r
  else if (i < 18) k = 1
  else if (i < 48) k = 3
  else if (i < 144) k = 4
  else if (i < 768) k = 5
  else k = 6
  if (i < 8)
    z = new Classic(m)
  else if (m.isEven())
    z = new Barrett(m)
  else
    z = new Montgomery(m)

  // precomputation
  var g = new Array(),
    n = 3,
    k1 = k - 1,
    km = (1 << k) - 1
  g[1] = z.convert(this)
  if (k > 1) {
    var g2 = new BigInteger()
    z.sqrTo(g[1], g2)
    while (n <= km) {
      g[n] = new BigInteger()
      z.mulTo(g2, g[n - 2], g[n])
      n += 2
    }
  }

  var j = e.t - 1,
    w, is1 = true,
    r2 = new BigInteger(),
    t
  i = nbits(e[j]) - 1
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i)
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1)
    }

    n = k
    while ((w & 1) == 0) {
      w >>= 1
      --n
    }
    if ((i -= n) < 0) {
      i += this.DB
      --j
    }
    if (is1) { // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r)
      is1 = false
    } else {
      while (n > 1) {
        z.sqrTo(r, r2)
        z.sqrTo(r2, r)
        n -= 2
      }
      if (n > 0) z.sqrTo(r, r2)
      else {
        t = r
        r = r2
        r2 = t
      }
      z.mulTo(r2, g[w], r)
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2)
      t = r
      r = r2
      r2 = t
      if (--i < 0) {
        i = this.DB - 1
        --j
      }
    }
  }
  return z.revert(r)
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s < 0) ? this.negate() : this.clone()
  var y = (a.s < 0) ? a.negate() : a.clone()
  if (x.compareTo(y) < 0) {
    var t = x
    x = y
    y = t
  }
  var i = x.getLowestSetBit(),
    g = y.getLowestSetBit()
  if (g < 0) return x
  if (i < g) g = i
  if (g > 0) {
    x.rShiftTo(g, x)
    y.rShiftTo(g, y)
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x)
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y)
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x)
      x.rShiftTo(1, x)
    } else {
      y.subTo(x, y)
      y.rShiftTo(1, y)
    }
  }
  if (g > 0) y.lShiftTo(g, y)
  return y
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if (n <= 0) return 0
  var d = this.DV % n,
    r = (this.s < 0) ? n - 1 : 0
  if (this.t > 0)
    if (d == 0) r = this[0] % n
    else
      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n
  return r
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven()
  if (this.signum() === 0) throw new Error('division by zero')
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO
  var u = m.clone(),
    v = this.clone()
  var a = nbv(1),
    b = nbv(0),
    c = nbv(0),
    d = nbv(1)
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u)
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a)
          b.subTo(m, b)
        }
        a.rShiftTo(1, a)
      } else if (!b.isEven()) b.subTo(m, b)
      b.rShiftTo(1, b)
    }
    while (v.isEven()) {
      v.rShiftTo(1, v)
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c)
          d.subTo(m, d)
        }
        c.rShiftTo(1, c)
      } else if (!d.isEven()) d.subTo(m, d)
      d.rShiftTo(1, d)
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u)
      if (ac) a.subTo(c, a)
      b.subTo(d, b)
    } else {
      v.subTo(u, v)
      if (ac) c.subTo(a, c)
      d.subTo(b, d)
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO
  while (d.compareTo(m) >= 0) d.subTo(m, d)
  while (d.signum() < 0) d.addTo(m, d)
  return d
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
  157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
  331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
  509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
  709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
  919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
]

var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs()
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true
    return false
  }
  if (x.isEven()) return false
  i = 1
  while (i < lowprimes.length) {
    var m = lowprimes[i],
      j = i + 1
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]
    m = x.modInt(m)
    while (i < j) if (m % lowprimes[i++] == 0) return false
  }
  return x.millerRabin(t)
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE)
  var k = n1.getLowestSetBit()
  if (k <= 0) return false
  var r = n1.shiftRight(k)
  t = (t + 1) >> 1
  if (t > lowprimes.length) t = lowprimes.length
  var a = new BigInteger(null)
  var j, bases = []
  for (var i = 0; i < t; ++i) {
    for (;;) {
      j = lowprimes[Math.floor(Math.random() * lowprimes.length)]
      if (bases.indexOf(j) == -1) break
    }
    bases.push(j)
    a.fromInt(j)
    var y = a.modPow(r, this)
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this)
        if (y.compareTo(BigInteger.ONE) == 0) return false
      }
      if (y.compareTo(n1) != 0) return false
    }
  }
  return true
}

// protected
proto.chunkSize = bnpChunkSize
proto.toRadix = bnpToRadix
proto.fromRadix = bnpFromRadix
proto.fromNumber = bnpFromNumber
proto.bitwiseTo = bnpBitwiseTo
proto.changeBit = bnpChangeBit
proto.addTo = bnpAddTo
proto.dMultiply = bnpDMultiply
proto.dAddOffset = bnpDAddOffset
proto.multiplyLowerTo = bnpMultiplyLowerTo
proto.multiplyUpperTo = bnpMultiplyUpperTo
proto.modInt = bnpModInt
proto.millerRabin = bnpMillerRabin

// public
proto.clone = bnClone
proto.intValue = bnIntValue
proto.byteValue = bnByteValue
proto.shortValue = bnShortValue
proto.signum = bnSigNum
proto.toByteArray = bnToByteArray
proto.equals = bnEquals
proto.min = bnMin
proto.max = bnMax
proto.and = bnAnd
proto.or = bnOr
proto.xor = bnXor
proto.andNot = bnAndNot
proto.not = bnNot
proto.shiftLeft = bnShiftLeft
proto.shiftRight = bnShiftRight
proto.getLowestSetBit = bnGetLowestSetBit
proto.bitCount = bnBitCount
proto.testBit = bnTestBit
proto.setBit = bnSetBit
proto.clearBit = bnClearBit
proto.flipBit = bnFlipBit
proto.add = bnAdd
proto.subtract = bnSubtract
proto.multiply = bnMultiply
proto.divide = bnDivide
proto.remainder = bnRemainder
proto.divideAndRemainder = bnDivideAndRemainder
proto.modPow = bnModPow
proto.modInverse = bnModInverse
proto.pow = bnPow
proto.gcd = bnGCD
proto.isProbablePrime = bnIsProbablePrime

// JSBN-specific extension
proto.square = bnSquare

// constants
BigInteger.ZERO = nbv(0)
BigInteger.ONE = nbv(1)
BigInteger.valueOf = nbv

module.exports = BigInteger

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/bigi.js","/../node_modules/bigi/lib")
},{"../package.json":7,"buffer":11,"pBGvAp":74}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// FIXME: Kind of a weird way to throw exceptions, consider removing
var assert = require('assert')
var BigInteger = require('./bigi')

/**
 * Turns a byte array into a big integer.
 *
 * This function will interpret a byte array as a big integer in big
 * endian notation.
 */
BigInteger.fromByteArrayUnsigned = function(byteArray) {
  // BigInteger expects a DER integer conformant byte array
  if (byteArray[0] & 0x80) {
    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(byteArray)
}

/**
 * Returns a byte array representation of the big integer.
 *
 * This returns the absolute of the contained value in big endian
 * form. A value of zero results in an empty array.
 */
BigInteger.prototype.toByteArrayUnsigned = function() {
  var byteArray = this.toByteArray()
  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray
}

BigInteger.fromDERInteger = function(byteArray) {
  return new BigInteger(byteArray)
}

/*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray

BigInteger.fromBuffer = function(buffer) {
  // BigInteger expects a DER integer conformant byte array
  if (buffer[0] & 0x80) {
    var byteArray = Array.prototype.slice.call(buffer)

    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(buffer)
}

BigInteger.fromHex = function(hex) {
  if (hex === '') return BigInteger.ZERO

  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')
  assert.equal(hex.length % 2, 0, 'Incomplete hex')
  return new BigInteger(hex, 16)
}

BigInteger.prototype.toBuffer = function(size) {
  var byteArray = this.toByteArrayUnsigned()
  var zeros = []

  var padding = size - byteArray.length
  while (zeros.length < padding) zeros.push(0)

  return new Buffer(zeros.concat(byteArray))
}

BigInteger.prototype.toHex = function(size) {
  return this.toBuffer(size).toString('hex')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/convert.js","/../node_modules/bigi/lib")
},{"./bigi":4,"assert":1,"buffer":11,"pBGvAp":74}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('./bigi')

//addons
require('./convert')

module.exports = BigInteger
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/index.js","/../node_modules/bigi/lib")
},{"./bigi":4,"./convert":5,"buffer":11,"pBGvAp":74}],7:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "bigi@^1.4.2",
        "scope": null,
        "escapedName": "bigi",
        "name": "bigi",
        "rawSpec": "^1.4.2",
        "spec": ">=1.4.2 <2.0.0",
        "type": "range"
      },
      "/Users/m/p/esteem/node_modules/steemauth"
    ]
  ],
  "_from": "bigi@>=1.4.2 <2.0.0",
  "_id": "bigi@1.4.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/bigi",
  "_nodeVersion": "6.1.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/bigi-1.4.2.tgz_1469584192413_0.6801238611806184"
  },
  "_npmUser": {
    "name": "jprichardson",
    "email": "jprichardson@gmail.com"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bigi@^1.4.2",
    "scope": null,
    "escapedName": "bigi",
    "name": "bigi",
    "rawSpec": "^1.4.2",
    "spec": ">=1.4.2 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ecurve",
    "/steemauth"
  ],
  "_resolved": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz",
  "_shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
  "_shrinkwrap": null,
  "_spec": "bigi@^1.4.2",
  "_where": "/Users/m/p/esteem/node_modules/steemauth",
  "bugs": {
    "url": "https://github.com/cryptocoinjs/bigi/issues"
  },
  "dependencies": {},
  "description": "Big integers.",
  "devDependencies": {
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.5",
    "jshint": "^2.5.1",
    "mocha": "^2.1.0",
    "mochify": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
    "tarball": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz"
  },
  "gitHead": "c25308081c896ff84702303722bf5ecd8b3f78e3",
  "homepage": "https://github.com/cryptocoinjs/bigi#readme",
  "keywords": [
    "cryptography",
    "math",
    "bitcoin",
    "arbitrary",
    "precision",
    "arithmetic",
    "big",
    "integer",
    "int",
    "number",
    "biginteger",
    "bigint",
    "bignumber",
    "decimal",
    "float"
  ],
  "main": "./lib/index.js",
  "maintainers": [
    {
      "name": "midnightlightning",
      "email": "boydb@midnightdesign.ws"
    },
    {
      "name": "sidazhang",
      "email": "sidazhang89@gmail.com"
    },
    {
      "name": "nadav",
      "email": "npm@shesek.info"
    },
    {
      "name": "jprichardson",
      "email": "jprichardson@gmail.com"
    }
  ],
  "name": "bigi",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "url": "git+https://github.com/cryptocoinjs/bigi.git",
    "type": "git"
  },
  "scripts": {
    "browser-test": "mochify --wd -R spec",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
    "coveralls": "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info",
    "jshint": "jshint --config jshint.json lib/*.js ; true",
    "test": "_mocha -- test/*.js",
    "unit": "mocha"
  },
  "testling": {
    "files": "test/*.js",
    "harness": "mocha",
    "browsers": [
      "ie/9..latest",
      "firefox/latest",
      "chrome/latest",
      "safari/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "version": "1.4.2"
}

},{}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browser-resolve/empty.js","/../node_modules/browser-resolve")
},{"buffer":11,"pBGvAp":74}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browserify/node_modules/string_decoder/index.js","/../node_modules/browserify/node_modules/string_decoder")
},{"buffer":11,"pBGvAp":74}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var base58 = basex(ALPHABET)

module.exports = {
  encode: base58.encode,
  decode: base58.decode
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bs58/index.js","/../node_modules/bs58")
},{"base-x":2,"buffer":11,"pBGvAp":74}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/buffer/index.js","/../node_modules/buffer")
},{"base64-js":3,"buffer":11,"ieee754":70,"pBGvAp":74}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define(["long"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module['exports'] = (function() {
            var Long; try { Long = require("long"); } catch (e) {}
            return factory(Long);
        })();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bytebuffer/dist/bytebuffer.js","/../node_modules/bytebuffer/dist")
},{"buffer":11,"long":72,"pBGvAp":74}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/cipher-base/index.js","/../node_modules/cipher-base")
},{"buffer":11,"inherits":71,"pBGvAp":74,"stream":91,"string_decoder":9}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Base = require('cipher-base')

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/browser.js","/../node_modules/create-hash")
},{"./md5":16,"buffer":11,"cipher-base":13,"inherits":71,"pBGvAp":74,"ripemd160":75,"sha.js":78}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/helpers.js","/../node_modules/create-hash")
},{"buffer":11,"pBGvAp":74}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/md5.js","/../node_modules/create-hash")
},{"./helpers":15,"buffer":11,"pBGvAp":74}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hmac/browser.js","/../node_modules/create-hmac")
},{"buffer":11,"create-hash/browser":14,"inherits":71,"pBGvAp":74,"stream":91}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/aes.js","/../node_modules/crypto-js")
},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":25,"buffer":11,"pBGvAp":74}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/cipher-core.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/core.js","/../node_modules/crypto-js")
},{"buffer":11,"pBGvAp":74}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-base64.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-hex.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/evpkdf.js","/../node_modules/crypto-js")
},{"./core":20,"./hmac":24,"./sha1":26,"buffer":11,"pBGvAp":74}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/hmac.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/md5.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/sha1.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var currencySymbolMap = require('./map');

var symbolCurrencyMap = {};
Object.keys(currencySymbolMap).forEach(function (key) {
  symbolCurrencyMap[currencySymbolMap[key]] = key
})

function getSymbolFromCurrency(currencyCode) {
  if (typeof currencyCode !== 'string') return undefined
  var code = currencyCode.toUpperCase();
  if (!currencySymbolMap.hasOwnProperty(code)) return undefined
  return currencySymbolMap[code];
}

function getCurrencyFromSymbol(symbol) {
  if (!symbolCurrencyMap.hasOwnProperty(symbol)) return undefined
  return symbolCurrencyMap[symbol]
}

function getSymbol(currencyCode) {
  if (typeof currencyCode !== 'string') return '?'
  var symbol = getSymbolFromCurrency(currencyCode.toUpperCase())
  return symbol !== undefined ? symbol : '?'
}

module.exports = getSymbol
module.exports.getSymbolFromCurrency = getSymbolFromCurrency
module.exports.getCurrencyFromSymbol = getCurrencyFromSymbol
module.exports.symbolCurrencyMap = symbolCurrencyMap
module.exports.currencySymbolMap = currencySymbolMap

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/currency-symbol-map.js","/../node_modules/currency-symbol-map")
},{"./map":28,"buffer":11,"pBGvAp":74}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports =
{ "ALL": "L"
, "AFN": ""
, "ARS": "$"
, "AWG": ""
, "AUD": "$"
, "AZN": ""
, "BSD": "$"
, "BBD": "$"
, "BYR": "p."
, "BZD": "BZ$"
, "BMD": "$"
, "BOB": "Bs."
, "BAM": "KM"
, "BWP": "P"
, "BGN": ""
, "BRL": "R$"
, "BND": "$"
, "BTC": ""
, "KHR": ""
, "CAD": "$"
, "KYD": "$"
, "CLP": "$"
, "CNY": ""
, "COP": "$"
, "CRC": ""
, "HRK": "kn"
, "CUP": ""
, "CZK": "K"
, "DKK": "kr"
, "DOP": "RD$"
, "XCD": "$"
, "EGP": ""
, "SVC": "$"
, "EEK": "kr"
, "EUR": ""
, "FKP": ""
, "FJD": "$"
, "GHC": ""
, "GIP": ""
, "GTQ": "Q"
, "GGP": ""
, "GYD": "$"
, "HNL": "L"
, "HKD": "$"
, "HUF": "Ft"
, "ISK": "kr"
, "INR": ""
, "IDR": "Rp"
, "IRR": ""
, "IMP": ""
, "ILS": ""
, "JMD": "J$"
, "JPY": ""
, "JEP": ""
, "KES": "KSh"
, "KZT": ""
, "KPW": ""
, "KRW": ""
, "KGS": ""
, "LAK": ""
, "LVL": "Ls"
, "LBP": ""
, "LRD": "$"
, "LTL": "Lt"
, "MKD": ""
, "MYR": "RM"
, "MUR": ""
, "MXN": "$"
, "MNT": ""
, "MZN": "MT"
, "NAD": "$"
, "NPR": ""
, "ANG": ""
, "NZD": "$"
, "NIO": "C$"
, "NGN": ""
, "NOK": "kr"
, "OMR": ""
, "PKR": ""
, "PAB": "B/."
, "PYG": "Gs"
, "PEN": "S/."
, "PHP": ""
, "PLN": "z"
, "QAR": ""
, "RON": "lei"
, "RUB": ""
, "RMB": ""
, "SHP": ""
, "SAR": ""
, "RSD": "."
, "SCR": ""
, "SGD": "$"
, "SBD": "$"
, "SOS": "S"
, "ZAR": "R"
, "LKR": ""
, "SEK": "kr"
, "CHF": "CHF"
, "SRD": "$"
, "SYP": ""
, "TZS": "TSh"
, "TWD": "NT$"
, "THB": ""
, "TTD": "TT$"
, "TRY": ""
, "TRL": ""
, "TVD": "$"
, "UGX": "USh"
, "UAH": ""
, "GBP": ""
, "USD": "$"
, "UYU": "$U"
, "UZS": ""
, "VEF": "Bs"
, "VND": ""
, "YER": ""
, "ZWD": "Z$"
, "GEL": ""
, "KZT": ""
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/map.js","/../node_modules/currency-symbol-map")
},{"buffer":11,"pBGvAp":74}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/diff-match-patch/index.js","/../node_modules/diff-match-patch")
},{"buffer":11,"pBGvAp":74}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var Point = require('./point')

function Curve (p, a, b, Gx, Gy, n, h) {
  this.p = p
  this.a = a
  this.b = b
  this.G = Point.fromAffine(this, Gx, Gy)
  this.n = n
  this.h = h

  this.infinity = new Point(this, null, null, BigInteger.ZERO)

  // result caching
  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)
}

Curve.prototype.pointFromX = function (isOdd, x) {
  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)
  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves

  var y = beta
  if (beta.isEven() ^ !isOdd) {
    y = this.p.subtract(y) // -y % p
  }

  return Point.fromAffine(this, x, y)
}

Curve.prototype.isInfinity = function (Q) {
  if (Q === this.infinity) return true

  return Q.z.signum() === 0 && Q.y.signum() !== 0
}

Curve.prototype.isOnCurve = function (Q) {
  if (this.isInfinity(Q)) return true

  var x = Q.affineX
  var y = Q.affineY
  var a = this.a
  var b = this.b
  var p = this.p

  // Check that xQ and yQ are integers in the interval [0, p - 1]
  if (x.signum() < 0 || x.compareTo(p) >= 0) return false
  if (y.signum() < 0 || y.compareTo(p) >= 0) return false

  // and check that y^2 = x^3 + ax + b (mod p)
  var lhs = y.square().mod(p)
  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)
  return lhs.equals(rhs)
}

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
Curve.prototype.validate = function (Q) {
  // Check Q != O
  assert(!this.isInfinity(Q), 'Point is at infinity')
  assert(this.isOnCurve(Q), 'Point is not on the curve')

  // Check nQ = O (where Q is a scalar multiple of G)
  var nQ = Q.multiply(this.n)
  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')

  return true
}

module.exports = Curve

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/curve.js","/../node_modules/ecurve/lib")
},{"./point":34,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],31:[function(require,module,exports){
module.exports={
  "secp128r1": {
    "p": "fffffffdffffffffffffffffffffffff",
    "a": "fffffffdfffffffffffffffffffffffc",
    "b": "e87579c11079f43dd824993c2cee5ed3",
    "n": "fffffffe0000000075a30d1b9038a115",
    "h": "01",
    "Gx": "161ff7528b899b2d0c28607ca52c5b86",
    "Gy": "cf5ac8395bafeb13c02da292dded7a83"
  },
  "secp160k1": {
    "p": "fffffffffffffffffffffffffffffffeffffac73",
    "a": "00",
    "b": "07",
    "n": "0100000000000000000001b8fa16dfab9aca16b6b3",
    "h": "01",
    "Gx": "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
    "Gy": "938cf935318fdced6bc28286531733c3f03c4fee"
  },
  "secp160r1": {
    "p": "ffffffffffffffffffffffffffffffff7fffffff",
    "a": "ffffffffffffffffffffffffffffffff7ffffffc",
    "b": "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
    "n": "0100000000000000000001f4c8f927aed3ca752257",
    "h": "01",
    "Gx": "4a96b5688ef573284664698968c38bb913cbfc82",
    "Gy": "23a628553168947d59dcc912042351377ac5fb32"
  },
  "secp192k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffeffffee37",
    "a": "00",
    "b": "03",
    "n": "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
    "h": "01",
    "Gx": "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
    "Gy": "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
  },
  "secp192r1": {
    "p": "fffffffffffffffffffffffffffffffeffffffffffffffff",
    "a": "fffffffffffffffffffffffffffffffefffffffffffffffc",
    "b": "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    "n": "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
    "h": "01",
    "Gx": "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    "Gy": "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
  },
  "secp256k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "a": "00",
    "b": "07",
    "n": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "h": "01",
    "Gx": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    "Gy": "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
  },
  "secp256r1": {
    "p": "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
    "a": "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
    "b": "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    "n": "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
    "h": "01",
    "Gx": "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    "Gy": "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
  }
}

},{}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Point = require('./point')
var Curve = require('./curve')

var getCurveByName = require('./names')

module.exports = {
  Curve: Curve,
  Point: Point,
  getCurveByName: getCurveByName
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/index.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./names":33,"./point":34,"buffer":11,"pBGvAp":74}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('bigi')

var curves = require('./curves.json')
var Curve = require('./curve')

function getCurveByName (name) {
  var curve = curves[name]
  if (!curve) return null

  var p = new BigInteger(curve.p, 16)
  var a = new BigInteger(curve.a, 16)
  var b = new BigInteger(curve.b, 16)
  var n = new BigInteger(curve.n, 16)
  var h = new BigInteger(curve.h, 16)
  var Gx = new BigInteger(curve.Gx, 16)
  var Gy = new BigInteger(curve.Gy, 16)

  return new Curve(p, a, b, Gx, Gy, n, h)
}

module.exports = getCurveByName

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/names.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./curves.json":31,"bigi":6,"buffer":11,"pBGvAp":74}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var THREE = BigInteger.valueOf(3)

function Point (curve, x, y, z) {
  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')

  this.curve = curve
  this.x = x
  this.y = y
  this.z = z
  this._zInv = null

  this.compressed = true
}

Object.defineProperty(Point.prototype, 'zInv', {
  get: function () {
    if (this._zInv === null) {
      this._zInv = this.z.modInverse(this.curve.p)
    }

    return this._zInv
  }
})

Object.defineProperty(Point.prototype, 'affineX', {
  get: function () {
    return this.x.multiply(this.zInv).mod(this.curve.p)
  }
})

Object.defineProperty(Point.prototype, 'affineY', {
  get: function () {
    return this.y.multiply(this.zInv).mod(this.curve.p)
  }
})

Point.fromAffine = function (curve, x, y) {
  return new Point(curve, x, y, BigInteger.ONE)
}

Point.prototype.equals = function (other) {
  if (other === this) return true
  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)
  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)

  // u = Y2 * Z1 - Y1 * Z2
  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)

  if (u.signum() !== 0) return false

  // v = X2 * Z1 - X1 * Z2
  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)

  return v.signum() === 0
}

Point.prototype.negate = function () {
  var y = this.curve.p.subtract(this.y)

  return new Point(this.curve, this.x, y, this.z)
}

Point.prototype.add = function (b) {
  if (this.curve.isInfinity(this)) return b
  if (this.curve.isInfinity(b)) return this

  var x1 = this.x
  var y1 = this.y
  var x2 = b.x
  var y2 = b.y

  // u = Y2 * Z1 - Y1 * Z2
  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)
  // v = X2 * Z1 - X1 * Z2
  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)

  if (v.signum() === 0) {
    if (u.signum() === 0) {
      return this.twice() // this == b, so double
    }

    return this.curve.infinity // this = -b, so infinity
  }

  var v2 = v.square()
  var v3 = v2.multiply(v)
  var x1v2 = x1.multiply(v2)
  var zu2 = u.square().multiply(this.z)

  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)
  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)
  // z3 = v^3 * z1 * z2
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

Point.prototype.twice = function () {
  if (this.curve.isInfinity(this)) return this
  if (this.y.signum() === 0) return this.curve.infinity

  var x1 = this.x
  var y1 = this.y

  var y1z1 = y1.multiply(this.z)
  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)
  var a = this.curve.a

  // w = 3 * x1^2 + a * z1^2
  var w = x1.square().multiply(THREE)

  if (a.signum() !== 0) {
    w = w.add(this.z.square().multiply(a))
  }

  w = w.mod(this.curve.p)
  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)
  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)
  // z3 = 8 * (y1 * z1)^3
  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
Point.prototype.multiply = function (k) {
  if (this.curve.isInfinity(this)) return this
  if (k.signum() === 0) return this.curve.infinity

  var e = k
  var h = e.multiply(THREE)

  var neg = this.negate()
  var R = this

  for (var i = h.bitLength() - 2; i > 0; --i) {
    var hBit = h.testBit(i)
    var eBit = e.testBit(i)

    R = R.twice()

    if (hBit !== eBit) {
      R = R.add(hBit ? this : neg)
    }
  }

  return R
}

// Compute this*j + x*k (simultaneous multiplication)
Point.prototype.multiplyTwo = function (j, x, k) {
  var i = Math.max(j.bitLength(), k.bitLength()) - 1
  var R = this.curve.infinity
  var both = this.add(x)

  while (i >= 0) {
    var jBit = j.testBit(i)
    var kBit = k.testBit(i)

    R = R.twice()

    if (jBit) {
      if (kBit) {
        R = R.add(both)
      } else {
        R = R.add(this)
      }
    } else if (kBit) {
      R = R.add(x)
    }
    --i
  }

  return R
}

Point.prototype.getEncoded = function (compressed) {
  if (compressed == null) compressed = this.compressed
  if (this.curve.isInfinity(this)) return new Buffer('00', 'hex') // Infinity point encoded is simply '00'

  var x = this.affineX
  var y = this.affineY

  var buffer

  // Determine size of q in bytes
  var byteLength = Math.floor((this.curve.p.bitLength() + 7) / 8)

  // 0x02/0x03 | X
  if (compressed) {
    buffer = new Buffer(1 + byteLength)
    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)

  // 0x04 | X | Y
  } else {
    buffer = new Buffer(1 + byteLength + byteLength)
    buffer.writeUInt8(0x04, 0)

    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
  }

  x.toBuffer(byteLength).copy(buffer, 1)

  return buffer
}

Point.decodeFrom = function (curve, buffer) {
  var type = buffer.readUInt8(0)
  var compressed = (type !== 4)

  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)
  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))

  var Q
  if (compressed) {
    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')
    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')

    var isOdd = (type === 0x03)
    Q = curve.pointFromX(isOdd, x)
  } else {
    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')

    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))
    Q = Point.fromAffine(curve, x, y)
  }

  Q.compressed = compressed
  return Q
}

Point.prototype.toString = function () {
  if (this.curve.isInfinity(this)) return '(INFINITY)'

  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'
}

module.exports = Point

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/point.js","/../node_modules/ecurve/lib")
},{"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var TransactionBuilder = require("./src/TransactionBuilder");

module.exports = {
    TransactionBuilder: TransactionBuilder,
    ChainConfig: require("./src/ChainConfig"),
    ChainTypes: require("./src/ChainTypes"),
    ObjectId: require("./src/ObjectId"),
    NumberUtils: require("./src/NumberUtils"),
    TransactionHelper: require("./src/TransactionHelper"),
    ChainValidation: require("./src/ChainValidation"),
    Login: require("./src/AccountLogin")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/index.js","/../node_modules/esteem-lib/dist/chain")
},{"./src/AccountLogin":36,"./src/ChainConfig":37,"./src/ChainTypes":38,"./src/ChainValidation":39,"./src/NumberUtils":40,"./src/ObjectId":41,"./src/TransactionBuilder":42,"./src/TransactionHelper":43,"buffer":11,"pBGvAp":74}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrivateKey = require("../../ecc/src/PrivateKey");
var key = require("../../ecc/src/KeyUtils");

var KeyCache = function () {
    function KeyCache() {
        _classCallCheck(this, KeyCache);

        this._keyCachePriv = new Map();
        this._keyCachePub = new Map();
        this._myKeys = new Map();
    }

    _createClass(KeyCache, [{
        key: "setPrivKey",
        value: function setPrivKey(key, privKey) {
            this._keyCachePriv.set(key, privKey);
        }
    }, {
        key: "hasPrivKey",
        value: function hasPrivKey(key) {
            return this._keyCachePriv.has(key);
        }
    }, {
        key: "getPrivKey",
        value: function getPrivKey(key) {
            return this._keyCachePriv.get(key);
        }
    }, {
        key: "setPubKey",
        value: function setPubKey(key, pubKey) {
            this._keyCachePub.set(key, pubKey);
        }
    }, {
        key: "hasPubKey",
        value: function hasPubKey(key) {
            return this._keyCachePub.has(key);
        }
    }, {
        key: "getPubKey",
        value: function getPubKey(key) {
            return this._keyCachePub.get(key);;
        }
    }, {
        key: "setMyKey",
        value: function setMyKey(key, privKey) {
            this._myKeys.set(key, privKey);
        }
    }, {
        key: "getMyKey",
        value: function getMyKey(key) {
            return this._myKeys.get(key);
        }
    }]);

    return KeyCache;
}();

var AccountLogin = function () {
    function AccountLogin() {
        _classCallCheck(this, AccountLogin);

        this.reset();
        this.keyCache = new KeyCache();
    }

    _createClass(AccountLogin, [{
        key: "reset",
        value: function reset() {
            this.state = { loggedIn: false, roles: ["active", "owner", "posting", "memo"] };

            this.subs = {};
        }
    }, {
        key: "addSubscription",
        value: function addSubscription(cb) {
            this.subs[cb] = cb;
        }
    }, {
        key: "setRoles",
        value: function setRoles(roles) {
            this.state.roles = roles;
        }
    }, {
        key: "getRoles",
        value: function getRoles() {
            return this.state.roles;
        }
    }, {
        key: "generateKeys",
        value: function generateKeys(accountName, password, roles, prefix) {
            var _this = this;

            if (!accountName || !password) {
                throw new Error("Account name or password required");
            }
            if (password.length < 12) {
                throw new Error("Password must have at least 12 characters");
            }

            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {
                var seed = accountName + role + password;
                var pkey = _this.keyCache.hasPrivKey(role) ? _this.keyCache.getPrivKey(role) : PrivateKey.fromSeed(key.normalize_brainKey(seed));
                _this.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this.keyCache.getPubKey(role) ? _this.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "fromPrivKey",
        value: function fromPrivKey(accountName, privateKey, roles, prefix) {
            var _this2 = this;

            if (!privateKey) {
                return null;
            }
            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {

                var pkey = _this2.keyCache.hasPrivKey(role) ? _this2.keyCache.getPrivKey(role) : PrivateKey.fromWif(privateKey);
                _this2.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this2.keyCache.getPubKey(role) ? _this2.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this2.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "getPubKeys",
        value: function getPubKeys() {
            var _this3 = this;

            return this.state.roles.map(function (role) {
                return _this3.keyCache.getPubKey(role);
            });
        }
    }, {
        key: "checkKeys",
        value: function checkKeys(_ref) {
            var _this4 = this;

            var accountName = _ref.accountName,
                password = _ref.password,
                auths = _ref.auths,
                _ref$privateKey = _ref.privateKey,
                privateKey = _ref$privateKey === undefined ? null : _ref$privateKey;

            if (!accountName || !password && !privateKey || !auths) {
                throw new Error("checkKeys: Missing inputs");
            }
            var hasKey = false;

            var _loop = function _loop(role) {
                var keys = void 0;
                if (password) {
                    keys = _this4.generateKeys(accountName, password, [role]);
                } else if (privateKey) {
                    keys = _this4.fromPrivKey(accountName, privateKey, [role]);
                }

                if (keys && Object.keys(keys).length) {
                    var _keys = keys,
                        privKeys = _keys.privKeys,
                        pubKeys = _keys.pubKeys;

                    auths[role].forEach(function (key) {
                        if (key[0] === pubKeys[role]) {
                            hasKey = true;
                            _this4.keyCache.setMyKey(role, { priv: privKeys[role], pub: pubKeys[role] });
                        }
                    });
                }
            };

            for (var role in auths) {
                _loop(role);
            };

            if (hasKey) {
                this.name = accountName;
            }

            this.state.loggedIn = hasKey;

            return hasKey;
        }
    }, {
        key: "signTransaction",
        value: function signTransaction(tr) {
            var _this5 = this;

            var signerPubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var requiredPubkeys = arguments[2];


            var myKeys = {};
            var hasKey = false;

            this.state.roles.forEach(function (role) {
                var myKey = _this5.keyCache.getMyKey(role);
                if (myKey) {
                    if (signerPubkeys[myKey.pub]) {
                        hasKey = true;
                        return;
                    }
                    hasKey = true;
                    signerPubkeys[myKey.pub] = true;
                    if (requiredPubkeys && requiredPubkeys.indexOf(myKey.pub) !== -1) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    } else if (!requiredPubkeys) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    }
                }
            });

            if (!hasKey) {
                console.error("You do not have any private keys to sign this transaction");
                throw new Error("You do not have any private keys to sign this transaction");
            }
        }
    }]);

    return AccountLogin;
}();

module.exports = AccountLogin;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/AccountLogin.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../ecc/src/KeyUtils":46,"../../ecc/src/PrivateKey":47,"buffer":11,"pBGvAp":74}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

//var _this;

var ecc_config = {
    address_prefix: "STM"
};

var _this = {
    core_asset: "STEEM",
    vest_asset: "VESTS",
    dollar_asset: "SBD",
    address_prefix: "STM",
    expire_in_secs: 15,
    expire_in_secs_proposal: 24 * 60 * 60,
    chain_id: "0000000000000000000000000000000000000000000000000000000000000000",
    networks: {
        Steem: {
            core_asset: "STEEM",
            vest_asset: "VESTS",
            dollar_asset: "SBD",
            address_prefix: "STM",
            chain_id: "0000000000000000000000000000000000000000000000000000000000000000"
        },
        Golos: {
            core_asset: "GOLOS",
            vest_asset: "GESTS",
            dollar_asset: "GBG",
            address_prefix: "GLS",
            chain_id: "782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12"
        }
    },
    /** Set a few properties for known chain IDs. */
    setChainId: function setChainId(chain_id) {

        var i, len, network, network_name, ref;
        ref = Object.keys(_this.networks);

        for (i = 0, len = ref.length; i < len; i++) {

            network_name = ref[i];
            network = _this.networks[network_name];

            if (network.chain_id === chain_id) {

                _this.network_name = network_name;

                if (network.address_prefix) {
                    _this.address_prefix = network.address_prefix;
                    _this.dollar_asset = network.dollar_asset;
                    _this.vest_asset = network.vest_asset;
                    _this.core_asset = network.core_asset;

                    ecc_config.address_prefix = network.address_prefix;
                    _this.chain_id = chain_id;
                }

                console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");

                return {
                    network_name: network_name,
                    network: network
                };
            }
        }

        if (!_this.network_name) {
            console.log("Unknown chain id (this may be a testnet)", chain_id);
        }
    },

    reset: function reset() {
        _this.core_asset = "STEEM";
        _this.address_prefix = "STM";
        ecc_config.address_prefix = "STM";
        _this.expire_in_secs = 15;
        _this.expire_in_secs_proposal = 24 * 60 * 60;

        console.log("Chain config reset");
    },

    setPrefix: function setPrefix() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "STM";

        _this.address_prefix = prefix;
        ecc_config.address_prefix = prefix;
    }
};
module.exports = _this;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainConfig.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ChainTypes = {};

ChainTypes.operations = {
    vote: 0,
    comment: 1,
    transfer: 2,
    transfer_to_vesting: 3,
    withdraw_vesting: 4,
    limit_order_create: 5,
    limit_order_cancel: 6,
    feed_publish: 7,
    convert: 8,
    account_create: 9,
    account_update: 10,
    witness_update: 11,
    account_witness_vote: 12,
    account_witness_proxy: 13,
    pow: 14,
    custom: 15,
    report_over_production: 16,
    delete_comment: 17,
    custom_json: 18,
    comment_options: 19,
    set_withdraw_vesting_route: 20,
    limit_order_create2: 21,
    challenge_authority: 22,
    prove_authority: 23,
    request_account_recovery: 24,
    recover_account: 25,
    change_recovery_account: 26,
    escrow_transfer: 27,
    escrow_dispute: 28,
    escrow_release: 29,
    pow2: 30,
    escrow_approve: 31,
    transfer_to_savings: 32,
    transfer_from_savings: 33,
    cancel_transfer_from_savings: 34,
    custom_binary: 35,
    decline_voting_rights: 36,
    reset_account: 37,
    set_reset_account: 38,
    claim_reward_balance: 39,
    delegate_vesting_shares: 40,
    account_create_with_delegation: 41,
    fill_convert_request: 42,
    author_reward: 43,
    curation_reward: 44,
    comment_reward: 45,
    liquidity_reward: 46,
    interest: 47,
    fill_vesting_withdraw: 48,
    fill_order: 49,
    shutdown_witness: 50,
    fill_transfer_from_savings: 51,
    hardfork: 52,
    comment_payout_update: 53,
    return_vesting_delegation: 54,
    comment_benefactor_reward: 55
};

module.exports = ChainTypes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainTypes.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
    Account names may contain one or more names separated by a dot.
    Each name needs to start with a letter and may contain
    numbers, or well placed dashes.
    @see is_valid_name graphene/libraries/chain/protocol/account.cpp
*/
var id_regex = /\b\d+\.\d+\.(\d+)\b/;

var chainValidation = {
    is_account_name: function is_account_name(value) {
        var allow_too_short = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var i, label, len, length, ref;

        if (this.is_empty(value)) {
            return false;
        }

        length = value.length;

        if (!allow_too_short && length < 3 || length > 63) {
            return false;
        }

        ref = value.split('.');

        for (i = 0, len = ref.length; i < len; i++) {

            label = ref[i];

            if (!(/^[a-z][a-z0-9-]*$/.test(label) && !/--/.test(label) && /[a-z0-9]$/.test(label))) {
                return false;
            }
        }
        return true;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;

        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_empty: function is_empty(value) {
        return value == null || value.length === 0;
    },

    is_account_name_error: function is_account_name_error(value, allow_too_short) {
        var i, label, len, length, ref, suffix;
        if (allow_too_short == null) {
            allow_too_short = false;
        }
        suffix = "Account name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        length = value.length;
        if (!allow_too_short && length < 3) {
            return suffix + "be longer.";
        }
        if (length > 63) {
            return suffix + "be shorter.";
        }
        if (/\./.test(value)) {
            suffix = "Each account segment should ";
        }
        ref = value.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
            label = ref[i];
            if (!/^[~a-z]/.test(label)) {
                return suffix + "start with a letter.";
            }
            if (!/^[~a-z0-9-]*$/.test(label)) {
                return suffix + "have only letters, digits, or dashes.";
            }
            if (/--/.test(label)) {
                return suffix + "have only one dash in a row.";
            }
            if (!/[a-z0-9]$/.test(label)) {
                return suffix + "end with a letter or digit.";
            }
            if (!(label.length >= 3)) {
                return suffix + "be longer";
            }
        }
        return null;
    },

    is_cheap_name: function is_cheap_name(account_name) {
        return (/[0-9-]/.test(account_name) || !/[aeiouy]/.test(account_name)
        );
    },

    is_empty_user_input: function is_empty_user_input(value) {
        if (this.is_empty(value)) {
            return true;
        }
        if ((value + "").trim() === "") {
            return true;
        }
        return false;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            throw new Error("value required for " + field_name + ": " + value);
        }
        return value;
    },

    /** @see is_valid_symbol graphene/libraries/chain/protocol/asset_ops.cpp */
    is_valid_symbol_error: function is_valid_symbol_error(value) {
        var suffix = "Asset name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        if (value.split('.').length > 2) {
            return suffix + "have only one dot.";
        }
        if (value.length < 3) {
            return suffix + "be longer.";
        }
        if (value.length > 16) {
            return suffix + "be shorter.";
        }
        if (!/^[A-Z]/.test(value)) {
            return suffix + "start with a letter";
        }
        if (!/[A-Z]$/.test(value)) {
            return suffix + "end with a letter";
        }
        if (/^[A-Z0-9\.]$/.test(value)) {
            return suffix + "contain only letters numbers and perhaps a dot.";
        }
        return null;
    }
};

module.exports = chainValidation;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainValidation.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340
    
    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split("."),
            _number$split2 = _slicedToArray(_number$split, 2),
            _number$split2$ = _number$split2[0],
            whole = _number$split2$ === undefined ? "" : _number$split2$,
            _number$split2$2 = _number$split2[1],
            decimal = _number$split2$2 === undefined ? "" : _number$split2$2;

        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/NumberUtils.js","/../node_modules/esteem-lib/dist/chain/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('bytebuffer'),
    Long = _require.Long;

var v = require('../../serializer/src/SerializerValidation');

var DB_MAX_INSTANCE_ID = Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = function () {
    function ObjectId(space, type, instance) {
        _classCallCheck(this, ObjectId);

        this.space = space;
        this.type = type;
        this.instance = instance;
        var instance_string = this.instance.toString();
        var _ObjectId = this.space + '.' + this.type + '.' + instance_string;
        if (!v.is_digits(instance_string)) {
            throw new ('Invalid object id ' + _ObjectId)();
        }
    }

    _createClass(ObjectId, [{
        key: 'toLong',
        value: function toLong() {
            return Long.fromNumber(this.space).shiftLeft(56).or(Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b) {
            return b.writeUint64(this.toLong());
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.space + '.' + this.type + '.' + this.instance.toString();
        }
    }], [{
        key: 'fromString',
        value: function fromString(value) {
            if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
                return value;
            }

            var params = v.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, v.required(value, "ObjectId"), "ObjectId");
            return new ObjectId(parseInt(params[1]), parseInt(params[2]), Long.fromString(params[3]));
        }
    }, {
        key: 'fromLong',
        value: function fromLong(long) {
            var space = long.shiftRight(56).toInt();
            var type = long.shiftRight(48).toInt() & 0x00ff;
            var instance = long.and(DB_MAX_INSTANCE_ID);
            return new ObjectId(space, type, instance);
        }
    }, {
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            return ObjectId.fromLong(b.readUint64());
        }
    }]);

    return ObjectId;
}();

module.exports = ObjectId;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ObjectId.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../serializer/src/SerializerValidation":59,"buffer":11,"bytebuffer":12,"pBGvAp":74}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");

var _require = require("../../ecc"),
    Signature = _require.Signature,
    PublicKey = _require.PublicKey,
    hash = _require.hash;

var _require2 = require("../../serializer"),
    ops = _require2.ops;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require3 = require('steem-rpc'),
    Client = _require3.Client;

var Api = Client.get();

var _require4 = require('bytebuffer'),
    Long = _require4.Long;

var ChainTypes = require('./ChainTypes');

var head_block_time_string;

var TransactionBuilder = function () {
    function TransactionBuilder() {
        _classCallCheck(this, TransactionBuilder);

        this.ref_block_num = 0;
        this.ref_block_prefix = 0;
        this.expiration = 0;
        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];

        // semi-private method bindings
        this._broadcast = _broadcast.bind(this);
    }

    /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */


    _createClass(TransactionBuilder, [{
        key: "add_type_operation",
        value: function add_type_operation(name, operation) {
            this.add_operation(this.get_type_operation(name, operation));
            return;
        }

        /**
            This does it all: set fees, finalize, sign, and broadcast (if wanted).
             @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
             @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
             @arg {boolean} [broadcast = false]
        */

    }, {
        key: "process_transaction",
        value: function process_transaction(accountLogin) {
            var _this = this;

            var signer_pubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            // let wallet_object = cwallet.wallet.wallet_object
            // if(Api.chain_id !== wallet_object.get("chain_id"))
            //     return Promise.reject("Mismatched chain_id; expecting " +
            //         wallet_object.get("chain_id") + ", but got " +
            //         Api.chain_id)

            var signer_pubkeys_added = {};
            // if(signer_pubkeys) {
            //
            //     // Balance claims are by address, only the private
            //     // key holder can know about these additional
            //     // potential keys.
            //     var pubkeys = accountLogin.getPubKeys()
            //     if( ! pubkeys.length)
            //         throw new Error("Missing signing key")
            //
            //     for(let pubkey_string of pubkeys) {
            //         var private_key = cwallet.getPrivateKey(pubkey_string)
            //         this.add_signer(private_key, pubkey_string)
            //         signer_pubkeys_added[pubkey_string] = true
            //     }
            // }

            // return this.get_potential_signatures().then( (pubkeys)=> {
            var my_pubkeys = accountLogin.getPubKeys();

            //{//Testing only, don't send All public keys!
            //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
            //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
            //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
            //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
            //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
            //}


            return this.get_required_signatures(my_pubkeys).then(function (required_pubkeys) {
                // console.log("required_pubkeys", required_pubkeys);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = my_pubkeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var pubkey_string = _step.value;

                        // console.log("pubkey_string", pubkey_string);

                        if (signer_pubkeys_added[pubkey_string]) continue;

                        accountLogin.signTransaction(_this, signer_pubkeys_added, required_pubkeys);
                        // var private_key = cwallet.getPrivateKey(pubkey_string)
                        // if( ! private_key)
                        //     // This should not happen, get_required_signatures will only
                        //     // returned keys from my_pubkeys
                        //     throw new Error("Missing signing key for " + pubkey_string)
                        // this.add_signer(private_key, pubkey_string)
                    }

                    // console.log("signer_pubkeys_added", signer_pubkeys_added);
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }).then(function () {
                if (broadcast) {
                    return _this.broadcast();
                } else {
                    return _this.serialize();
                }
            });
        }

        /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */

    }, {
        key: "finalize",
        value: function finalize() {
            var _this2 = this;

            // console.log("Try to finalize", "expiration:", this.expiration);
            return new Promise(function (resolve, reject) {

                if (_this2.tr_buffer) {
                    throw new Error("already finalized");
                }

                resolve(Api.database_api().exec("get_dynamic_global_properties", []).then(function (r) {
                    head_block_time_string = r.time;
                    if (_this2.expiration === 0) _this2.expiration = base_expiration_sec() + ChainConfig.expire_in_secs;
                    // console.log("new expiration:", this.expiration);
                    _this2.ref_block_num = r.head_block_number & 0xFFFF;
                    _this2.ref_block_prefix = new Buffer(r.head_block_id, 'hex').readUInt32LE(4);
                    //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                    var iterable = _this2.operations;
                    for (var i = 0, op; i < iterable.length; i++) {
                        op = iterable[i];
                        if (op[1]["finalize"]) {
                            op[1].finalize();
                        }
                    }
                    _this2.tr_buffer = ops.transaction.toBuffer(_this2);
                }).catch(function (err) {
                    console.log("get_dynamic_global_properties err:", err);
                }));
            });
        }

        /** @return {string} hex transaction ID */

    }, {
        key: "id",
        value: function id() {
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            return hash.sha256(this.tr_buffer).toString('hex').substring(0, 40);
        }

        /**
            Typically one will use {@link this.add_type_operation} instead.
            @arg {array} operation - [operation_id, operation]
        */

    }, {
        key: "add_operation",
        value: function add_operation(operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(operation, "operation");
            if (!Array.isArray(operation)) {
                throw new Error("Expecting array [operation_id, operation]");
            }
            this.operations.push(operation);
            return;
        }
    }, {
        key: "get_type_operation",
        value: function get_type_operation(name, operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(name, "name");
            assert(operation, "operation");
            var _type = ops[name];
            assert(_type, "Unknown operation " + name);
            var operation_id = ChainTypes.operations[_type.operation_name];
            if (operation_id === undefined) {
                throw new Error("unknown operation: " + _type.operation_name);
            }
            if (!operation.fee) {
                operation.fee = { amount: 0, asset_id: 0 };
            }
            if (name === 'proposal_create') {
                operation.expiration_time || (operation.expiration_time = base_expiration_sec() + ChainConfig.expire_in_secs_proposal);
            }
            var operation_instance = _type.fromObject(operation);
            return [operation_id, operation_instance];
        }

        /** optional: there is a deafult expiration */

    }, {
        key: "set_expire_seconds",
        value: function set_expire_seconds(sec) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            return this.expiration = base_expiration_sec() + sec;
        }

        /* Wraps this transaction in a proposal_create transaction */

    }, {
        key: "propose",
        value: function propose(proposal_create_options) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            if (!this.operations.length) {
                throw new Error("add operation first");
            }

            assert(proposal_create_options, "proposal_create_options");
            assert(proposal_create_options.fee_paying_account, "proposal_create_options.fee_paying_account");

            var proposed_ops = this.operations.map(function (op) {
                return { op: op };
            });

            this.operations = [];
            this.signatures = [];
            this.signer_private_keys = [];
            proposal_create_options.proposed_ops = proposed_ops;
            this.add_type_operation("proposal_create", proposal_create_options);
            return this;
        }
    }, {
        key: "has_proposed_operation",
        value: function has_proposed_operation() {
            var hasProposed = false;
            for (var i = 0; i < this.operations.length; i++) {
                if ("proposed_ops" in this.operations[i][1]) {
                    hasProposed = true;
                    break;
                }
            }

            return hasProposed;
        }
    }, {
        key: "get_potential_signatures",
        value: function get_potential_signatures() {
            var tr_object = ops.signed_transaction.toObject(this);
            return Api.database_api().exec("get_potential_signatures", [tr_object]).then(function (pubkeys) {
                return { pubkeys: pubkeys };
            });
        }
    }, {
        key: "get_required_signatures",
        value: function get_required_signatures(available_keys) {

            if (!available_keys.length) {
                return Promise.resolve([]);
            }
            var tr_object = ops.signed_transaction.toObject(this);
            //console.log('... tr_object',tr_object);
            //DEBUG console.log('... tr_object',tr_object)
            return Api.database_api().exec("get_required_signatures", [tr_object, available_keys]).then(function (required_public_keys) {
                // DEBUG console.log('... get_required_signatures',required_public_keys)
                //console.log('... get_required_signatures',required_public_keys);
                return required_public_keys;
            });
        }
    }, {
        key: "add_signer",
        value: function add_signer(private_key) {
            var public_key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : private_key.toPublicKey();


            assert(private_key.d, "required PrivateKey object");

            if (this.signed) {
                throw new Error("already signed");
            }
            if (!public_key.Q) {
                public_key = PublicKey.fromPublicKeyString(public_key);
            }
            // prevent duplicates
            var spHex = private_key.toHex();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.signer_private_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var sp = _step2.value;

                    if (sp[0].toHex() === spHex) return;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.signer_private_keys.push([private_key, public_key]);
        }
    }, {
        key: "sign",
        value: function sign() {
            var chain_id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.chain_id;

            console.log(chain_id);
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            if (this.signed) {
                throw new Error("already signed");
            }
            var end = this.signer_private_keys.length;
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                var _signer_private_keys$ = _slicedToArray(this.signer_private_keys[i], 2),
                    private_key = _signer_private_keys$[0],
                    public_key = _signer_private_keys$[1];

                var sig = Signature.signBuffer(Buffer.concat([new Buffer(chain_id, 'hex'), this.tr_buffer]), private_key, public_key);
                this.signatures.push(sig.toBuffer());
            }
            this.signer_private_keys = [];
            this.signed = true;
            return;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "broadcast",
        value: function broadcast(was_broadcast_callback) {
            var _this3 = this;

            if (this.tr_buffer) {
                return this._broadcast(was_broadcast_callback);
            } else {
                return this.finalize().then(function () {
                    return _this3._broadcast(was_broadcast_callback);
                });
            }
        }
    }]);

    return TransactionBuilder;
}();

var base_expiration_sec = function base_expiration_sec() {
    var head_block_sec = Math.ceil(getHeadBlockDate().getTime() / 1000);
    var now_sec = Math.ceil(Date.now() / 1000);
    // The head block time should be updated every 3 seconds.  If it isn't
    // then help the transaction to expire (use head_block_sec)
    if (now_sec - head_block_sec > 30) {
        return head_block_sec;
    }
    // If the user's clock is very far behind, use the head block time.
    return Math.max(now_sec, head_block_sec);
};

function _broadcast(was_broadcast_callback) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
        if (!_this4.signed) {
            _this4.sign();
        }
        if (!_this4.tr_buffer) {
            reject(new Error("not finalized"));
        }
        if (!_this4.signatures.length) {
            reject(new Error("not signed"));
        }
        if (!_this4.operations.length) {
            reject(new Error("no operations"));
        }

        if (!("network_broadcast_api" in Api)) {
            reject(new Error("Api does not include network_broadcast_api"));
        }
        var tr_object = ops.signed_transaction.toObject(_this4);

        return Api.network_broadcast_api().exec("broadcast_transaction_with_callback", [{ reject: reject, resolve: resolve }, tr_object]).then(function () {
            // console.log('... broadcast success, waiting for callback')
            if (was_broadcast_callback) was_broadcast_callback();
            return;
        }).catch(function (error) {
            // console.log may be redundant for network errors, other errors could occur
            // console.log(error);
            var message = error.message;
            if (!message) {
                message = "";
            }
            reject(new Error(message + "\n" + 'graphene-crypto ' + ' digest ' + hash.sha256(_this4.tr_buffer).toString('hex') + ' transaction ' + _this4.tr_buffer.toString('hex') + ' ' + JSON.stringify(tr_object)));
        });
    });
}

function getHeadBlockDate() {
    return timeStringToDate(head_block_time_string);
}

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string)) //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    return new Date(time_string);
}

module.exports = TransactionBuilder;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/TransactionBuilder.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../chain/src/ChainConfig":37,"../../ecc":44,"../../serializer":57,"./ChainTypes":38,"assert":1,"buffer":11,"bytebuffer":12,"pBGvAp":74,"steem-rpc":88}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var helper;
module.exports = helper = {};

var secureRandom = require('secure-random');

//Promise = require '../common/Promise'

var _require = require('bytebuffer'),
    Long = _require.Long;

var _require2 = require("../../ecc"),
    Signature = _require2.Signature;

var _require3 = require("../../serializer"),
    ops = _require3.ops;

helper.unique_nonce_entropy = null;
helper.unique_nonce_uint64 = function () {
    var entropy = helper.unique_nonce_entropy = function () {

        if (helper.unique_nonce_entropy === null) {
            //console.log('... secureRandom.randomUint8Array(1)[0]',secureRandom.randomUint8Array(1)[0])
            return parseInt(secureRandom.randomUint8Array(1)[0]);
        } else {
            return ++helper.unique_nonce_entropy % 256;
        }
    }();
    var long = Long.fromNumber(Date.now());
    //console.log('unique_nonce_uint64 date\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    //console.log('unique_nonce_uint64 entropy\t',ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))
    long = long.shiftLeft(8).or(Long.fromNumber(entropy));
    //console.log('unique_nonce_uint64 shift8\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    return long.toString();
};

/* Todo, set fees */
helper.to_json = function (tr) {
    var broadcast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return function (tr, broadcast) {
        var tr_object = ops.signed_transaction.toObject(tr);
        if (broadcast) {
            var net = Apis.instance().network_api();
            console.log('... tr_object', JSON.stringify(tr_object));
            return net.exec("broadcast_transaction", [tr_object]);
        } else {
            return tr_object;
        }
    }(tr, broadcast);
};

helper.signed_tr_json = function (tr, private_keys) {
    var tr_buffer = ops.transaction.toBuffer(tr);
    tr = ops.transaction.toObject(tr);
    tr.signatures = function () {
        var result = [];
        for (var i = 0; 0 < private_keys.length ? i < private_keys.length : i > private_keys.length; 0 < private_keys.length ? i++ : i++) {
            var private_key = private_keys[i];
            result.push(Signature.signBuffer(tr_buffer, private_key).toHex());
        }
        return result;
    }();
    return tr;
};

helper.expire_in_min = function (min) {
    return Math.round(Date.now() / 1000) + min * 60;
};

helper.seconds_from_now = function (timeout_sec) {
    return Math.round(Date.now() / 1000) + timeout_sec;
};

/**
    Print to the console a JSON representation of any object in
    @graphene/serializer { types }
*/
helper.template = function (serializer_operation_type_name) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: true, annotate: true };

    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    return so.toObject(undefined, debug);
};

helper.new_operation = function (serializer_operation_type_name) {
    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    var object = so.toObject(undefined, { use_default: true, annotate: true });
    return so.fromObject(object);
};

helper.instance = function (ObjectId) {
    return ObjectId.substring("0.0.".length);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/TransactionHelper.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../ecc":44,"../../serializer":57,"buffer":11,"bytebuffer":12,"pBGvAp":74,"secure-random":76}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = {
    Address: require("./src/address"),
    Aes: require("./src/aes"),
    PrivateKey: require("./src/PrivateKey"),
    PublicKey: require("./src/PublicKey"),
    Signature: require("./src/signature"),
    brainKey: require("./src/BrainKey"),
    hash: require("./src/hash"),
    key: require("./src/KeyUtils")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/index.js","/../node_modules/esteem-lib/dist/ecc")
},{"./src/BrainKey":45,"./src/KeyUtils":46,"./src/PrivateKey":47,"./src/PublicKey":48,"./src/address":49,"./src/aes":50,"./src/hash":54,"./src/signature":55,"buffer":11,"pBGvAp":74}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function normalize(brainKey) {
    if (typeof brainKey !== 'string') {
        throw new Error("string required for brainKey");
    }
    brainKey = brainKey.trim();
    return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/BrainKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var key;
var PrivateKey = require('./PrivateKey');
var PublicKey = require('./PublicKey');
var Address = require('./address');
var Aes = require('./aes');

var hash = require('./hash');
// var dictionary = require('./dictionary_en');
var secureRandom = require('secure-random');
var ChainConfig = require("../../chain/src/ChainConfig");

// hash for .25 second
var HASH_POWER_MILLS = 250;

module.exports = key = {

    /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */
    aes_checksum: function aes_checksum(password) {
        if (!(typeof password === "string")) {
            throw new "password string required"();
        }
        var salt = secureRandom.randomBuffer(4).toString('hex');
        var iterations = 0;
        var secret = salt + password;
        // hash for .1 second
        var start_t = Date.now();
        while (Date.now() - start_t < HASH_POWER_MILLS) {
            secret = hash.sha256(secret);
            iterations += 1;
        }

        var checksum = hash.sha256(secret);
        var checksum_string = [iterations, salt.toString('hex'), checksum.slice(0, 4).toString('hex')].join(',');

        return { aes_private: Aes.fromSeed(secret),
            checksum: checksum_string
        };
    },


    /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
    aes_private: function aes_private(password, key_checksum) {
        var _key_checksum$split = key_checksum.split(','),
            _key_checksum$split2 = _slicedToArray(_key_checksum$split, 3),
            iterations = _key_checksum$split2[0],
            salt = _key_checksum$split2[1],
            checksum = _key_checksum$split2[2];

        var secret = salt + password;
        for (var i = 0; 0 < iterations ? i < iterations : i > iterations; 0 < iterations ? i++ : i++) {
            secret = hash.sha256(secret);
        }
        var new_checksum = hash.sha256(secret);
        if (!(new_checksum.slice(0, 4).toString('hex') === checksum)) {
            throw new Error("wrong password");
        }
        return Aes.fromSeed(secret);
    },


    /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
    random32ByteBuffer: function random32ByteBuffer() {
        var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.browserEntropy();


        if (!(typeof entropy === 'string')) {
            throw new Error("string required for entropy");
        }

        if (entropy.length < 32) {
            throw new Error("expecting at least 32 bytes of entropy");
        }

        var start_t = Date.now();

        while (Date.now() - start_t < HASH_POWER_MILLS) {
            entropy = hash.sha256(entropy);
        }var hash_array = [];
        hash_array.push(entropy);

        // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
        hash_array.push(secureRandom.randomBuffer(32));

        return hash.sha256(Buffer.concat(hash_array));
    },


    suggest_brain_key: function suggest_brain_key() {
        var dictionary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ",";
        var entropy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.browserEntropy();


        var randomBuffer = this.random32ByteBuffer(entropy);

        var word_count = 16;
        var dictionary_lines = dictionary.split(',');

        if (!(dictionary_lines.length === 49744)) {
            throw new Error('expecting ' + 49744 + ' but got ' + dictionary_lines.length + ' dictionary words');
        }

        var brainkey = [];
        var end = word_count * 2;

        for (var i = 0; i < end; i += 2) {

            // randomBuffer has 256 bits / 16 bits per word == 16 words
            var num = (randomBuffer[i] << 8) + randomBuffer[i + 1];

            // convert into a number between 0 and 1 (inclusive)
            var rndMultiplier = num / Math.pow(2, 16);
            var wordIndex = Math.round(dictionary_lines.length * rndMultiplier);

            brainkey.push(dictionary_lines[wordIndex]);
        }
        return this.normalize_brainKey(brainkey.join(' '));
    },

    get_random_key: function get_random_key(entropy) {
        return PrivateKey.fromBuffer(this.random32ByteBuffer(entropy));
    },
    get_brainPrivateKey: function get_brainPrivateKey(brainKey) {
        var sequence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (sequence < 0) {
            throw new Error("invalid sequence");
        }
        brainKey = key.normalize_brainKey(brainKey);
        return PrivateKey.fromBuffer(hash.sha256(hash.sha512(brainKey + " " + sequence)));
    },


    // Turn invisible space like characters into a single space
    normalize_brainKey: function normalize_brainKey(brainKey) {
        if (!(typeof brainKey === 'string')) {
            throw new Error("string required for brainKey");
        }

        brainKey = brainKey.trim();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    },
    browserEntropy: function browserEntropy() {

        var entropyStr = "";
        try {
            entropyStr = new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

            for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
                mimeType = navigator.mimeTypes[i];
                entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
            }
            console.log("INFO\tbrowserEntropy gathered");
        } catch (error) {
            //nodejs:ReferenceError: window is not defined
            entropyStr = hash.sha256(new Date().toString());
        }

        var b = new Buffer(entropyStr);
        entropyStr += b.toString('binary') + " " + new Date().toString();
        return entropyStr;
    },


    // @return array of 5 legacy addresses for a pubkey string parameter.
    addresses: function addresses(pubkey) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

        var public_key = PublicKey.fromPublicKeyString(pubkey, address_prefix);
        // S L O W
        var address_string = [Address.fromPublic(public_key, false, 0).toString(address_prefix), // btc_uncompressed
        Address.fromPublic(public_key, true, 0).toString(address_prefix), // btc_compressed
        Address.fromPublic(public_key, false, 56).toString(address_prefix), // pts_uncompressed
        Address.fromPublic(public_key, true, 56).toString(address_prefix), // pts_compressed
        public_key.toAddressString(address_prefix) // bts_short, most recent format
        ];
        return address_string;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/KeyUtils.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./PrivateKey":47,"./PublicKey":48,"./address":49,"./aes":50,"./hash":54,"buffer":11,"pBGvAp":74,"secure-random":76}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecurve = require('ecurve');

var _require = require('ecurve'),
    Point = _require.Point,
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var BigInteger = require('bigi');

var _require2 = require('bs58'),
    encode = _require2.encode,
    decode = _require2.decode;

var assert = require('assert');
var hash = require('./hash');
var PublicKey = require('./PublicKey');
var deepEqual = require("deep-equal");

var G = secp256k1.G,
    n = secp256k1.n;

var PrivateKey = function () {

    /**
        @private see static functions
        @param {BigInteger}
    */
    function PrivateKey(d) {
        _classCallCheck(this, PrivateKey);

        this.d = d;
    }

    _createClass(PrivateKey, [{
        key: 'toWif',
        value: function toWif() {
            var private_key = this.toBuffer();
            // checksum includes the version
            private_key = Buffer.concat([new Buffer([0x80]), private_key]);
            var checksum = hash.sha256(private_key);
            checksum = hash.sha256(checksum);
            checksum = checksum.slice(0, 4);
            var private_wif = Buffer.concat([private_key, checksum]);
            return encode(private_wif);
        }

        /**
            @return {Point}
        */

    }, {
        key: 'toPublicKeyPoint',
        value: function toPublicKeyPoint() {
            var Q;
            return Q = secp256k1.G.multiply(this.d);
        }
    }, {
        key: 'toPublicKey',
        value: function toPublicKey() {
            if (this.public_key) {
                return this.public_key;
            }
            return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer() {
            return this.d.toBuffer(32);
        }

        /** ECIES */

    }, {
        key: 'get_shared_secret',
        value: function get_shared_secret(public_key) {
            var legacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            public_key = toPublic(public_key);
            var KB = public_key.toUncompressed().toBuffer();
            var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x
            BigInteger.fromBuffer(KB.slice(33, 65)) // y
            );
            var r = this.toBuffer();
            var P = KBP.multiply(BigInteger.fromBuffer(r));
            var S = P.affineX.toBuffer({ size: 32 });
            /*
            the input to sha512 must be exactly 32-bytes, to match the c++ implementation
            of get_shared_secret.  Right now S will be shorter if the most significant
            byte(s) is zero.  Pad it back to the full 32-bytes
            */
            if (!legacy && S.length < 32) {
                pad = new Buffer(32 - S.length).fill(0);
                S = Buffer.concat([pad, S]);
            }

            // SHA512 used in ECIES
            return hash.sha512(S);
        }

        // /** ECIES (does not always match the Point.fromAffine version above) */
        // get_shared_secret(public_key){
        //     public_key = toPublic(public_key)
        //     var P = public_key.Q.multiply( this.d );
        //     var S = P.affineX.toBuffer({size: 32});
        //     // ECIES, adds an extra sha512
        //     return hash.sha512(S);
        // }

        /** @throws {Error} - overflow of the key could not be derived */

    }, {
        key: 'child',
        value: function child(offset) {
            offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
            offset = hash.sha256(offset);
            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var derived = this.d.add(c); //.mod(n)

            if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");

            return new PrivateKey(derived);
        }

        /* <helper_functions> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }

        /* </helper_functions> */

    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            if (!Buffer.isBuffer(buf)) {
                throw new Error("Expecting paramter to be a Buffer type");
            }
            if (32 !== buf.length) {
                console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
            }
            if (buf.length === 0) {
                throw new Error("Empty buffer");
            }
            return new PrivateKey(BigInteger.fromBuffer(buf));
        }

        /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

    }, {
        key: 'fromSeed',
        value: function fromSeed(seed) {
            // generate_private_key
            if (!(typeof seed === 'string')) {
                throw new Error('seed must be of type string');
            }
            return PrivateKey.fromBuffer(hash.sha256(seed));
        }

        /** @return {string} Wallet Import Format (still a secret, Not encrypted) */

    }, {
        key: 'fromWif',
        value: function fromWif(_private_wif) {
            var private_wif = new Buffer(decode(_private_wif));
            var version = private_wif.readUInt8(0);
            assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
            // checksum includes the version
            var private_key = private_wif.slice(0, -4);
            var checksum = private_wif.slice(-4);
            var new_checksum = hash.sha256(private_key);
            new_checksum = hash.sha256(new_checksum);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            private_key = private_key.slice(1);
            return PrivateKey.fromBuffer(private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }]);

    return PrivateKey;
}();

module.exports = PrivateKey;

var toPublic = function toPublic(data) {
    return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/PrivateKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./PublicKey":48,"./hash":54,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":66,"ecurve":32,"pBGvAp":74}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BigInteger = require('bigi');

var _require = require('ecurve'),
    Point = _require.Point,
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');

var _require2 = require('bs58'),
    encode = _require2.encode,
    decode = _require2.decode;

var hash = require('./hash');
var ChainConfig = require("../../chain/src/ChainConfig");
var assert = require('assert');
var deepEqual = require("deep-equal");

var G = secp256k1.G,
    n = secp256k1.n;

var PublicKey = function () {

    /** @param {Point} public key */
    function PublicKey(Q) {
        _classCallCheck(this, PublicKey);

        this.Q = Q;
    }

    _createClass(PublicKey, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;

            if (this.Q === null) return new Buffer('000000000000000000000000000000000000000000000000000000000000000000', 'hex');
            return this.Q.getEncoded(compressed);
        }
    }, {
        key: 'toUncompressed',
        value: function toUncompressed() {
            var buf = this.Q.getEncoded(false);
            var point = Point.decodeFrom(secp256k1, buf);
            return PublicKey.fromPoint(point);
        }

        /** bts::blockchain::address (unique but not a full public key) */

    }, {
        key: 'toBlockchainAddress',
        value: function toBlockchainAddress() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            return hash.ripemd160(pub_sha);
        }

        /** Alias for {@link toPublicKeyString} */

    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            return this.toPublicKeyString(address_prefix);
        }

        /**
            Full public key
            {return} string
        */

    }, {
        key: 'toPublicKeyString',
        value: function toPublicKeyString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var checksum = hash.ripemd160(pub_buf);
            var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @return PublicKey or `null` (if the public_key string is invalid)
        */

    }, {
        key: 'toAddressString',
        value: function toAddressString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            var checksum = hash.ripemd160(addy);
            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }, {
        key: 'toPtsAddy',
        value: function toPtsAddy() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha256(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

            var checksum = hash.sha256(addy);
            checksum = hash.sha256(checksum);

            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return encode(addy);
        }
    }, {
        key: 'child',
        value: function child(offset) {

            assert(Buffer.isBuffer(offset), "Buffer required: offset");
            assert.equal(offset.length, 32, "offset length");

            offset = Buffer.concat([this.toBuffer(), offset]);
            offset = hash.sha256(offset);

            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var cG = G.multiply(c);
            var Qprime = this.Q.add(cG);

            if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");

            return PublicKey.fromPoint(Qprime);
        }

        /* <HEX> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }
    }], [{
        key: 'fromBinary',
        value: function fromBinary(bin) {
            return PublicKey.fromBuffer(new Buffer(bin, 'binary'));
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            if (buffer.toString('hex') === '000000000000000000000000000000000000000000000000000000000000000000') return new PublicKey(null);
            return new PublicKey(Point.decodeFrom(secp256k1, buffer));
        }
    }, {
        key: 'fromPoint',
        value: function fromPoint(point) {
            return new PublicKey(point);
        }
    }, {
        key: 'fromPublicKeyString',
        value: function fromPublicKeyString(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            try {
                return PublicKey.fromStringOrThrow(public_key, address_prefix);
            } catch (e) {
                return null;
            }
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @throws {Error} if public key is invalid
            @return PublicKey
        */

    }, {
        key: 'fromStringOrThrow',
        value: function fromStringOrThrow(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = public_key.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            public_key = public_key.slice(address_prefix.length);

            public_key = new Buffer(decode(public_key), 'binary');
            var checksum = public_key.slice(-4);
            public_key = public_key.slice(0, -4);
            var new_checksum = hash.ripemd160(public_key);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return PublicKey.fromBuffer(public_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PublicKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }, {
        key: 'fromPublicKeyStringHex',
        value: function fromPublicKeyStringHex(hex) {
            return PublicKey.fromPublicKeyString(new Buffer(hex, 'hex'));
        }

        /* </HEX> */

    }]);

    return PublicKey;
}();

module.exports = PublicKey;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/PublicKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./hash":54,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":66,"ecurve":32,"pBGvAp":74}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');
var ChainConfig = require("../../chain/src/ChainConfig");
var hash = require('./hash');

var _require = require('bs58'),
    encode = _require.encode,
    decode = _require.decode;

var deepEqual = require("deep-equal");

/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/

var Address = function () {
    function Address(addy) {
        _classCallCheck(this, Address);

        this.addy = addy;
    }

    _createClass(Address, [{
        key: 'toBuffer',
        value: function toBuffer() {
            return this.addy;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var checksum = hash.ripemd160(this.addy);
            var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var _hash = hash.sha512(buffer);
            var addy = hash.ripemd160(_hash);
            return new Address(addy);
        }
    }, {
        key: 'fromString',
        value: function fromString(string) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = string.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            var addy = string.slice(address_prefix.length);
            addy = new Buffer(decode(addy), 'binary');
            var checksum = addy.slice(-4);
            addy = addy.slice(0, -4);
            var new_checksum = hash.ripemd160(addy);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return new Address(addy);
        }
    }, {
        key: 'fromPublic',


        /** @return Address - Compressed PTS format (by default) */
        value: function fromPublic(public_key) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 56;

            var sha2 = hash.sha256(public_key.toBuffer(compressed));
            var rep = hash.ripemd160(sha2);
            var versionBuffer = new Buffer(1);
            versionBuffer.writeUInt8(0xFF & version, 0);
            var addr = Buffer.concat([versionBuffer, rep]);
            var check = hash.sha256(addr);
            check = hash.sha256(check);
            var buffer = Buffer.concat([addr, check.slice(0, 4)]);
            return new Address(hash.ripemd160(buffer));
        }
    }]);

    return Address;
}();

module.exports = Address;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/address.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./hash":54,"assert":1,"bs58":10,"buffer":11,"deep-equal":66,"pBGvAp":74}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://code.google.com/p/crypto-js
var AES = require("crypto-js/aes");
var encHex = require("crypto-js/enc-hex");
var encBase64 = require("crypto-js/enc-base64");
var assert = require("assert");

var _require = require("bytebuffer"),
    Long = _require.Long;

var hash = require('./hash');

/** Provides symetric encrypt and decrypt via AES. */

var Aes = function () {

    /** @private */
    function Aes(iv, key) {
        _classCallCheck(this, Aes);

        this.iv = iv, this.key = key;
    }

    /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */


    _createClass(Aes, [{
        key: "clear",
        value: function clear() {
            return this.iv = this.key = undefined;
        }

        /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */

    }, {
        key: "_decrypt_word_array",


        /** @private */
        value: function _decrypt_word_array(cipher) {
            // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
            // see wallet_records.cpp master_key::decrypt_key
            return AES.decrypt({ ciphertext: cipher, salt: null }, this.key, { iv: this.iv });
        }

        /** @private */

    }, {
        key: "_encrypt_word_array",
        value: function _encrypt_word_array(plaintext) {
            //https://code.google.com/p/crypto-js/issues/detail?id=85
            var cipher = AES.encrypt(plaintext, this.key, { iv: this.iv });
            return encBase64.parse(cipher.toString());
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} ciphertext
            @return {Buffer} binary
        */

    }, {
        key: "decrypt",
        value: function decrypt(ciphertext) {
            if (typeof ciphertext === "string") {
                ciphertext = new Buffer(ciphertext, 'binary');
            }
            if (!Buffer.isBuffer(ciphertext)) {
                throw new Error("buffer required");
            }
            assert(ciphertext, "Missing cipher text");
            // hex is the only common format
            var hex = this.decryptHex(ciphertext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plaintext
            @return {Buffer} binary
        */

    }, {
        key: "encrypt",
        value: function encrypt(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            var hex = this.encryptHex(plaintext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string|Buffer} plaintext
            @return {string} hex
        */

    }, {
        key: "encryptToHex",
        value: function encryptToHex(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            return this.encryptHex(plaintext.toString('hex'));
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {string} binary (could easily be readable text)
        */

    }, {
        key: "decryptHex",
        value: function decryptHex(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            return encHex.stringify(plainwords);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {Buffer} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToBuffer",
        value: function decryptHexToBuffer(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            var plainhex = encHex.stringify(plainwords);
            return new Buffer(plainhex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @arg {string} [encoding = 'binary'] - a valid Buffer encoding
            @return {String} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToText",
        value: function decryptHexToText(cipher) {
            var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';

            return this.decryptHexToBuffer(cipher).toString(encoding);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plainhex - hex format
            @return {String} hex
        */

    }, {
        key: "encryptHex",
        value: function encryptHex(plainhex) {
            var plain_array = encHex.parse(plainhex);
            var cipher_array = this._encrypt_word_array(plain_array);
            return encHex.stringify(cipher_array);
        }
    }], [{
        key: "fromSeed",
        value: function fromSeed(seed) {
            if (seed === undefined) {
                throw new Error("seed is required");
            }
            var _hash = hash.sha512(seed);
            _hash = _hash.toString('hex');
            // DEBUG console.log('... fromSeed _hash',_hash)
            return Aes.fromSha512(_hash);
        }
    }, {
        key: "fromSha512",


        /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
        value: function fromSha512(hash) {
            assert.equal(hash.length, 128, "A Sha512 in HEX should be 128 characters long, instead got " + hash.length);
            var iv = encHex.parse(hash.substring(64, 96));
            var key = encHex.parse(hash.substring(0, 64));
            return new Aes(iv, key);
        }
    }, {
        key: "fromBuffer",
        value: function fromBuffer(buf) {
            assert(Buffer.isBuffer(buf), "Expecting Buffer");
            assert.equal(buf.length, 64, "A Sha512 Buffer should be 64 characters long, instead got " + buf.length);
            return Aes.fromSha512(buf.toString("hex"));
        }
        /**
            @throws {Error} - "Invalid Key, ..."
            @arg {PrivateKey} private_key - required and used for decryption
            @arg {PublicKey} public_key - required and used to calcualte the shared secret
            @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
            @arg {string|Buffer} message - Encrypted message containing a checksum
            @return {Buffer}
        */

    }, {
        key: "decrypt_with_checksum",
        value: function decrypt_with_checksum(private_key, public_key, nonce, message) {
            var legacy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'hex');
            }

            var S = private_key.get_shared_secret(public_key, legacy);
            // D E B U G
            // console.log('decrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString(),
            //     pub: public_key.toPublicKeyString(),
            //     nonce: nonce,
            //     message: message.length,
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));

            var planebuffer = aes.decrypt(message);
            if (!(planebuffer.length >= 4)) {
                throw new Error("Invalid key, could not decrypt message(1)");
            }

            // DEBUG console.log('... planebuffer',planebuffer)
            var checksum = planebuffer.slice(0, 4);
            var plaintext = planebuffer.slice(4);

            // console.log('... checksum',checksum.toString('hex'))
            // console.log('... plaintext',plaintext.toString())

            var new_checksum = hash.sha256(plaintext);
            new_checksum = new_checksum.slice(0, 4);
            new_checksum = new_checksum.toString('hex');

            if (!(checksum.toString('hex') === new_checksum)) {
                throw new Error("Invalid key, could not decrypt message(2)");
            }

            return plaintext;
        }
    }, {
        key: "encrypt_with_checksum",


        /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
            @return {Buffer} message - Encrypted message which includes a checksum
        */
        value: function encrypt_with_checksum(private_key, public_key, nonce, message) {

            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'binary');
            }

            var S = private_key.get_shared_secret(public_key);

            // D E B U G
            // console.log('encrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString()
            //     pub: public_key.toPublicKeyString()
            //     nonce: nonce
            //     message: message.length
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));
            // DEBUG console.log('... S',S.toString('hex'))
            var checksum = hash.sha256(message).slice(0, 4);
            var payload = Buffer.concat([checksum, message]);
            // DEBUG console.log('... payload',payload.toString())
            return aes.encrypt(payload);
        }
    }]);

    return Aes;
}();

module.exports = Aes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/aes.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./hash":54,"assert":1,"buffer":11,"bytebuffer":12,"crypto-js/aes":18,"crypto-js/enc-base64":21,"crypto-js/enc-hex":22,"pBGvAp":74}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
var crypto = require('./hash');
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');
var ECSignature = require('./ecsignature');

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(curve, hash, d, checkSig, nonce) {

  enforceType('Buffer', hash);
  enforceType(BigInteger, d);

  if (nonce) {
    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));
  }

  // sanity check
  assert.equal(hash.length, 32, 'Hash must be 256 bit');

  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32);

  // Step B
  v.fill(1);

  // Step C
  k.fill(0);

  // Step D
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);

  // Step E
  v = crypto.HmacSHA256(v, k);

  // Step F
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);

  // Step G
  v = crypto.HmacSHA256(v, k);

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = crypto.HmacSHA256(v, k);

  var T = BigInteger.fromBuffer(v);

  // Step H3, repeat until T is within the interval [1, n - 1]
  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);
    v = crypto.HmacSHA256(v, k);

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = crypto.HmacSHA256(v, k);

    T = BigInteger.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {

  var e = BigInteger.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;

  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);

    if (curve.isInfinity(Q)) return false;

    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;

    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;

    return true;
  }, nonce);

  var N_OVER_TWO = n.shiftRight(1);

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new ECSignature(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1]
  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;

  // c = s^-1 mod n
  var c = s.modInverse(n);

  // 1.4.4 Compute u1 = es^1 mod n
  //               u2 = rs^1 mod n
  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n);

  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
  var R = G.multiplyTwo(u1, Q, u2);

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (curve.isInfinity(R)) return false;

  // 1.4.6 Convert the field element R.x to an integer
  var xR = R.affineX;

  // 1.4.7 Set v = xR mod n
  var v = xR.mod(n);

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = BigInteger.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}

/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */
function recoverPubKey(curve, e, signature, i) {
  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');

  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.multiply(n);
  assert(curve.isInfinity(nR), 'nR is not a valid curve point');

  // Compute -e from e
  var eNeg = e.negate().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = r.modInverse(n);

  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);

  return Q;
}

/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */
function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i);

    // 1.6.2 Verify Q
    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

module.exports = {
  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
  deterministicGenerateK: deterministicGenerateK,
  recoverPubKey: recoverPubKey,
  sign: sign,
  verify: verify,
  verifyRaw: verifyRaw
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/ecdsa.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./ecsignature":52,"./enforce_types":53,"./hash":54,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from https://github.com/bitcoinjs/bitcoinjs-lib
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');

function ECSignature(r, s) {
  enforceType(BigInteger, r);
  enforceType(BigInteger, s);

  this.r = r;
  this.s = s;
}

// Import operations
ECSignature.parseCompact = function (buffer) {
  assert.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27;

  // At most 3 bits
  assert.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4);

  // Recovery param only
  i = i & 3;

  var r = BigInteger.fromBuffer(buffer.slice(1, 33));
  var s = BigInteger.fromBuffer(buffer.slice(33));

  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');

  var rLen = buffer.readUInt8(3);
  assert(rLen > 0, 'R length is zero');

  var offset = 4 + rLen;
  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');

  var sLen = buffer.readUInt8(offset + 1);
  assert(sLen > 0, 'S length is zero');

  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  assert.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = BigInteger.fromDERInteger(rB);
  var s = BigInteger.fromDERInteger(sB);

  assert(r.signum() >= 0, 'R value is negative');
  assert(s.signum() >= 0, 'S value is negative');

  return new ECSignature(r, s);
};

// FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;

  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');

  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
};

// Export operations
ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;

  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);

  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);

  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();

  var sequence = [];

  // INTEGER
  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa);

  // INTEGER
  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa);

  // SEQUENCE
  sequence.unshift(0x30, sequence.length);

  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);

  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

module.exports = ECSignature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/ecsignature.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./enforce_types":53,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
};

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/enforce_types.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var createHash = require("create-hash");
var createHmac = require("create-hmac");

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
    return createHash('sha1').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha256(data, encoding) {
    return createHash('sha256').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha512(data, encoding) {
    return createHash('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
    return createHmac('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
    return createHash('rmd160').update(data).digest();
}

// function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
//
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }

//
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }

module.exports = {
    sha1: sha1,
    sha256: sha256,
    sha512: sha512,
    HmacSHA256: HmacSHA256,
    ripemd160: ripemd160
    // hash160: hash160,
    // hash256: hash256,
    // HmacSHA512: HmacSHA512
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/hash.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"create-hash":14,"create-hmac":17,"pBGvAp":74}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecdsa = require('./ecdsa');
var hash = require('./hash');

var _require = require('ecurve'),
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var assert = require('assert');
var BigInteger = require('bigi');
var PublicKey = require('./PublicKey');

var Signature = function () {
    function Signature(r1, s1, i1) {
        _classCallCheck(this, Signature);

        this.r = r1;
        this.s = s1;
        this.i = i1;
        assert.equal(this.r != null, true, 'Missing parameter');
        assert.equal(this.s != null, true, 'Missing parameter');
        assert.equal(this.i != null, true, 'Missing parameter');
    }

    _createClass(Signature, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var buf;
            buf = new Buffer(65);
            buf.writeUInt8(this.i, 0);
            this.r.toBuffer(32).copy(buf, 1);
            this.s.toBuffer(32).copy(buf, 33);
            return buf;
        }
    }, {
        key: 'recoverPublicKeyFromBuffer',
        value: function recoverPublicKeyFromBuffer(buffer) {
            return this.recoverPublicKey(hash.sha256(buffer));
        }
    }, {
        key: 'recoverPublicKey',


        /**
            @return {PublicKey}
        */
        value: function recoverPublicKey(sha256_buffer) {
            var Q = void 0,
                e = void 0,
                i = void 0;
            e = BigInteger.fromBuffer(sha256_buffer);
            i = this.i;
            i -= 27;
            i = i & 3;
            Q = ecdsa.recoverPubKey(secp256k1, e, this, i);
            return PublicKey.fromPoint(Q);
        }
    }, {
        key: 'verifyBuffer',


        /**
            @param {Buffer} un-hashed
            @param {./PublicKey}
            @return {boolean}
        */
        value: function verifyBuffer(buf, public_key) {
            var _hash = hash.sha256(buf);
            return this.verifyHash(_hash, public_key);
        }
    }, {
        key: 'verifyHash',
        value: function verifyHash(hash, public_key) {
            assert.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
            return ecdsa.verify(secp256k1, hash, {
                r: this.r,
                s: this.s
            }, public_key.Q);
        }
    }, {
        key: 'toByteBuffer',


        /* <HEX> */

        value: function toByteBuffer() {
            var b;
            b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString("hex");
        }
    }, {
        key: 'verifyHex',
        value: function verifyHex(hex, public_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return this.verifyBuffer(buf, public_key);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            var i, r, s;
            assert.equal(buf.length, 65, 'Invalid signature length');
            i = buf.readUInt8(0);
            assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
            r = BigInteger.fromBuffer(buf.slice(1, 33));
            s = BigInteger.fromBuffer(buf.slice(33));
            return new Signature(r, s, i);
        }
    }, {
        key: 'signBuffer',


        /**
            @param {Buffer} buf
            @param {PrivateKey} private_key
            @return {Signature}
        */
        value: function signBuffer(buf, private_key) {
            var _hash = hash.sha256(buf);
            return Signature.signBufferSha256(_hash, private_key);
        }

        /** Sign a buffer of exactally 32 bytes in size (sha256(text))
            @param {Buffer} buf - 32 bytes binary
            @param {PrivateKey} private_key
            @return {Signature}
        */

    }, {
        key: 'signBufferSha256',
        value: function signBufferSha256(buf_sha256, private_key) {
            if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
            var der, e, ecsignature, i, lenR, lenS, nonce;
            i = null;
            nonce = 0;
            e = BigInteger.fromBuffer(buf_sha256);
            while (true) {
                ecsignature = ecdsa.sign(secp256k1, buf_sha256, private_key.d, nonce++);
                der = ecsignature.toDER();
                lenR = der[3];
                lenS = der[5 + lenR];
                if (lenR === 32 && lenS === 32) {
                    i = ecdsa.calcPubKeyRecoveryParam(secp256k1, e, ecsignature, private_key.toPublicKey().Q);
                    i += 4; // compressed
                    i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                    break;
                }
                if (nonce % 10 === 0) {
                    console.log("WARN: " + nonce + " attempts to find canonical signature");
                }
            }
            return new Signature(ecsignature.r, ecsignature.s, i);
        }
    }, {
        key: 'sign',
        value: function sign(string, private_key) {
            return Signature.signBuffer(new Buffer(string), private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return Signature.fromBuffer(new Buffer(hex, "hex"));
        }
    }, {
        key: 'signHex',
        value: function signHex(hex, private_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return Signature.signBuffer(buf, private_key);
        }
    }]);

    return Signature;
}();

module.exports = Signature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/signature.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./PublicKey":48,"./ecdsa":51,"./hash":54,"assert":1,"bigi":6,"buffer":11,"ecurve":32,"pBGvAp":74}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = Object.assign(require("./chain"), require("./ecc"), require("./serializer"));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/index.js","/../node_modules/esteem-lib/dist")
},{"./chain":35,"./ecc":44,"./serializer":57,"buffer":11,"pBGvAp":74}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = {

    // Primary class for creating operations
    Serializer: require('./src/serializer'),

    // helper functions for creating operations
    fp: require('./src/FastParser'),

    // Low level types
    types: require('./src/types'),

    // Higher level operations (made out of generic types)
    ops: require('./src/operations'),

    // Utility that generates JSON examples
    template: require('./src/template'),

    // Serializer validation
    SerializerValidation: require('./src/SerializerValidation')
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/index.js","/../node_modules/esteem-lib/dist/serializer")
},{"./src/FastParser":58,"./src/SerializerValidation":59,"./src/operations":62,"./src/serializer":63,"./src/template":64,"./src/types":65,"buffer":11,"pBGvAp":74}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PublicKey = require("../../ecc/src/PublicKey");

var FastParser = function () {
    function FastParser() {
        _classCallCheck(this, FastParser);
    }

    _createClass(FastParser, null, [{
        key: 'fixed_data',
        value: function fixed_data(b, len, buffer) {
            if (!b) {
                return;
            }
            if (buffer) {
                var data = buffer.slice(0, len).toString('binary');
                b.append(data, 'binary');
                while (len-- > data.length) {
                    b.writeUint8(0);
                }
            } else {
                var b_copy = b.copy(b.offset, b.offset + len);
                b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        }
    }, {
        key: 'public_key',
        value: function public_key(b, _public_key) {
            if (!b) {
                return;
            }
            if (_public_key) {
                var buffer = _public_key.toBuffer();
                b.append(buffer.toString('binary'), 'binary');
                return;
            } else {
                buffer = FastParser.fixed_data(b, 33);
                return PublicKey.fromBuffer(buffer);
            }
        }
    }, {
        key: 'ripemd160',
        value: function ripemd160(b, _ripemd) {
            if (!b) {
                return;
            }
            if (_ripemd) {
                FastParser.fixed_data(b, 20, _ripemd);
                return;
            } else {
                return FastParser.fixed_data(b, 20);
            }
        }
    }, {
        key: 'time_point_sec',
        value: function time_point_sec(b, epoch) {
            if (epoch) {
                epoch = Math.ceil(epoch / 1000);
                b.writeInt32(epoch);
                return;
            } else {
                epoch = b.readInt32(); // fc::time_point_sec
                return new Date(epoch * 1000);
            }
        }
    }]);

    return FastParser;
}();

module.exports = FastParser;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/FastParser.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../ecc/src/PublicKey":48,"buffer":11,"pBGvAp":74}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _my;
var is_empty;
var is_digits;
var to_number;
var require_match;
var require_object_id;
var require_object_type;
var get_instance;
var require_relative_type;
var get_relative_instance;
var require_protocol_type;
var get_protocol_instance;
var get_protocol_type;
var require_implementation_type;
var get_implementation_instance;
var Long = require('bytebuffer').Long;
// var BigInteger = require('bigi');

var chain_types = require('../../chain/src/ChainTypes');

var MAX_SAFE_INT = 9007199254740991;
var MIN_SAFE_INT = -9007199254740991;

/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required"). 
    Validations support a string format for dealing with large numbers.
*/
module.exports = _my = {

    is_empty: is_empty = function is_empty(value) {
        return value === null || value === undefined;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            throw new Error('value required ' + field_name + ' ' + value);
        }
        return value;
    },
    require_long: function require_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (!Long.isLong(value)) {
            throw new Error('Long value required ' + field_name + ' ' + value);
        }
        return value;
    },
    string: function string(value) {
        if (is_empty(value)) {
            return value;
        }
        if (typeof value !== "string") {
            throw new Error('string required: ' + value);
        }
        return value;
    },
    number: function number(value) {
        if (is_empty(value)) {
            return value;
        }
        if (typeof value !== "number") {
            throw new Error('number required: ' + value);
        }
        return value;
    },
    whole_number: function whole_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (/\./.test(value)) {
            throw new Error('whole number required ' + field_name + ' ' + value);
        }
        return value;
    },
    unsigned: function unsigned(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (/-/.test(value)) {
            throw new Error('unsigned required ' + field_name + ' ' + value);
        }
        return value;
    },


    is_digits: is_digits = function is_digits(value) {
        if (typeof value === "numeric") {
            return true;
        }
        return (/^[0-9]+$/.test(value)
        );
    },

    to_number: to_number = function to_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        _my.no_overflow53(value, field_name);
        var int_value = function () {
            if (typeof value === "number") {
                return value;
            } else {
                return parseInt(value);
            }
        }();
        return int_value;
    },

    to_long: function to_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (Long.isLong(value)) {
            return value;
        }

        _my.no_overflow64(value, field_name);
        if (typeof value === "number") {
            value = "" + value;
        }
        return Long.fromString(value);
    },
    to_string: function to_string(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value;
        }
        if (typeof value === "number") {
            _my.no_overflow53(value, field_name);
            return "" + value;
        }
        if (Long.isLong(value)) {
            return value.toString();
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },
    require_test: function require_test(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (is_empty(value)) {
            return value;
        }
        if (!regex.test(value)) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_match: require_match = function require_match(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (is_empty(value)) {
            return value;
        }
        var match = value.match(regex);
        if (match === null) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return match;
    },

    // require_object_id: require_object_id=function(value, field_name){
    //     return require_match(
    //         /^([0-9]+)\.([0-9]+)\.([0-9]+)$/,
    //         value,
    //         field_name
    //     );
    // },

    // Does not support over 53 bits
    require_range: function require_range(min, max, value) {
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (is_empty(value)) {
            return value;
        }
        var number = to_number(value);
        if (value < min || value > max) {
            throw new Error('out of range ' + value + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_object_type: require_object_type = function require_object_type() {
        var reserved_spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var type = arguments[1];
        var value = arguments[2];
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (is_empty(value)) {
            return value;
        }
        var object_type = chain_types.object_type[type];
        if (!object_type) {
            throw new Error('Unknown object type: ' + type + ', ' + field_name + ', ' + value);
        }
        var re = new RegExp(reserved_spaces + '.' + object_type + '.[0-9]+$');
        if (!re.test(value)) {
            throw new Error('Expecting ' + type + ' in format ' + (reserved_spaces + '.' + object_type + '.[0-9]+ ') + ('instead of ' + value + ' ' + field_name + ' ' + value));
        }
        return value;
    },

    get_instance: get_instance = function get_instance(reserve_spaces, type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(reserve_spaces, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    require_relative_type: require_relative_type = function require_relative_type(type, value, field_name) {
        require_object_type(0, type, value, field_name);
        return value;
    },

    get_relative_instance: get_relative_instance = function get_relative_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(0, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    require_protocol_type: require_protocol_type = function require_protocol_type(type, value, field_name) {
        require_object_type(1, type, value, field_name);
        return value;
    },

    get_protocol_instance: get_protocol_instance = function get_protocol_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(1, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    get_protocol_type: get_protocol_type = function get_protocol_type(value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_id(value, field_name);
        var values = value.split('.');
        return to_number(values[1]);
    },

    get_protocol_type_name: function get_protocol_type_name(value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        var type_id = get_protocol_type(value, field_name);
        return Object.keys(chain_types.object_type)[type_id];
    },


    require_implementation_type: require_implementation_type = function require_implementation_type(type, value, field_name) {
        require_object_type(2, type, value, field_name);
        return value;
    },

    get_implementation_instance: get_implementation_instance = function get_implementation_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(2, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    // signed / unsigned decimal
    no_overflow53: function no_overflow53(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "string") {
            var int = parseInt(value);
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (Long.isLong(value)) {
            // typeof value.toInt() is 'number'
            _my.no_overflow53(value.toInt(), field_name);
            return;
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },


    // signed / unsigned whole numbers only
    no_overflow64: function no_overflow64(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        // https://github.com/dcodeIO/Long.js/issues/20
        if (Long.isLong(value)) {
            return;
        }

        // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
        if (value.t !== undefined && value.s !== undefined) {
            _my.no_overflow64(value.toString(), field_name);
            return;
        }

        if (typeof value === "string") {
            // remove leading zeros, will cause a false positive
            value = value.replace(/^0+/, '');
            // remove trailing zeros
            while (/0$/.test(value)) {
                value = value.substring(0, value.length - 1);
            }
            if (/\.$/.test(value)) {
                // remove trailing dot
                value = value.substring(0, value.length - 1);
            }
            if (value === "") {
                value = "0";
            }
            var long_string = Long.fromString(value).toString();
            if (long_string !== value.trim()) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }

        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/SerializerValidation.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../chain/src/ChainTypes":38,"buffer":11,"bytebuffer":12,"pBGvAp":74}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Exception nesting.  */
var ErrorWithCause = function () {
    function ErrorWithCause(message, cause) {
        _classCallCheck(this, ErrorWithCause);

        this.message = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            this.message = "cause\t" + cause.message + "\t" + this.message;
        }

        var stack = ""; //(new Error).stack
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            stack = "caused by\n\t" + cause.stack + "\t" + stack;
        }

        this.stack = this.message + "\n" + stack;
    }

    _createClass(ErrorWithCause, null, [{
        key: "throw",
        value: function _throw(message, cause) {
            var msg = message;
            if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
                msg += "\t cause: " + cause.message + " ";
            }
            if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
                msg += "\n stack: " + cause.stack + " ";
            }
            throw new Error(msg);
        }
    }]);

    return ErrorWithCause;
}();

module.exports = ErrorWithCause;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/error_with_cause.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split("."),
            _number$split2 = _slicedToArray(_number$split, 2),
            _number$split2$ = _number$split2[0],
            whole = _number$split2$ === undefined ? "" : _number$split2$,
            _number$split2$2 = _number$split2[1],
            decimal = _number$split2$2 === undefined ? "" : _number$split2$2;

        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    },

    fromImpliedDecimal: function fromImpliedDecimal(number, precision) {
        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        while (number.length < precision + 1) {
            // 0.123
            number = "0" + number;
        } // 44000 => 44.000
        var dec_string = number.substring(number.length - precision);
        return number.substring(0, number.length - precision) + (dec_string ? "." + dec_string : "");
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/numberUtils.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var types = require("./types");
var SerializerImpl = require("./serializer");

var int16 = types.int16,
    uint16 = types.uint16,
    uint32 = types.uint32,
    int64 = types.int64,
    uint64 = types.uint64,
    string = types.string,
    bytes = types.bytes,
    bool = types.bool,
    array = types.array,
    fixed_array = types.fixed_array,
    object_id_type = types.object_id_type,
    vote_id = types.vote_id,
    string_binary = types.string_binary,
    future_extensions = types.future_extensions,
    hardfork_version_vote = types.hardfork_version_vote,
    version = types.version,
    static_variant = types.static_variant,
    map = types.map,
    set = types.set,
    public_key = types.public_key,
    address = types.address,
    time_point_sec = types.time_point_sec,
    optional = types.optional,
    asset = types.asset;

future_extensions = types.void;
hardfork_version_vote = types.void;
version = types.void;

// Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...
var operation = static_variant();
module.exports["operation"] = operation;

// For module.exports
var Serializer = function Serializer(operation_name, serilization_types_object) {
    var s = new SerializerImpl(operation_name, serilization_types_object);
    return module.exports[operation_name] = s;
};

// Custom-types follow Generated code:

// ##  Generated code follows
// # npm i -g decaffeinate
// # programs/js_operation_serializer > ops.coffee && decaffeinate ops.coffee
// # open ops.txt, copy to Chain/ChainTypes and operations.js
// ## -------------------------------

var beneficiaries = new Serializer("beneficiaries", {
    account: string,
    weight: uint16
});

var comment_payout_beneficiaries = new Serializer(0, {
    beneficiaries: set(beneficiaries)
});

var signed_transaction = new Serializer("signed_transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65))
});

var signed_block = new Serializer("signed_block", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
    witness_signature: bytes(65),
    transactions: array(signed_transaction)
});

var block_header = new Serializer("block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote]))
});

var signed_block_header = new Serializer("signed_block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
    witness_signature: bytes(65)
});

var vote = new Serializer("vote", {
    voter: string,
    author: string,
    permlink: string,
    weight: int16
});

var comment = new Serializer("comment", {
    parent_author: string,
    parent_permlink: string,
    author: string,
    permlink: string,
    title: string,
    body: string,
    json_metadata: string
});

var transfer = new Serializer("transfer", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_to_vesting = new Serializer("transfer_to_vesting", {
    from: string,
    to: string,
    amount: asset
});

var withdraw_vesting = new Serializer("withdraw_vesting", {
    account: string,
    vesting_shares: asset
});

var limit_order_create = new Serializer("limit_order_create", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    min_to_receive: asset,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var limit_order_cancel = new Serializer("limit_order_cancel", {
    owner: string,
    orderid: uint32
});

var price = new Serializer("price", {
    base: asset,
    quote: asset
});

var feed_publish = new Serializer("feed_publish", {
    publisher: string,
    exchange_rate: price
});

var convert = new Serializer("convert", {
    owner: string,
    requestid: uint32,
    amount: asset
});

var authority = new Serializer("authority", {
    weight_threshold: uint32,
    account_auths: map(string, uint16),
    key_auths: map(public_key, uint16)
});

var account_create = new Serializer("account_create", {
    fee: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string
});

var account_update = new Serializer("account_update", {
    account: string,
    owner: optional(authority),
    active: optional(authority),
    posting: optional(authority),
    memo_key: public_key,
    json_metadata: string
});

var chain_properties = new Serializer("chain_properties", {
    account_creation_fee: asset,
    maximum_block_size: uint32,
    sbd_interest_rate: uint16
});

var witness_update = new Serializer("witness_update", {
    owner: string,
    url: string,
    block_signing_key: public_key,
    props: chain_properties,
    fee: asset
});

var account_witness_vote = new Serializer("account_witness_vote", {
    account: string,
    witness: string,
    approve: bool
});

var account_witness_proxy = new Serializer("account_witness_proxy", {
    account: string,
    proxy: string
});

var pow = new Serializer("pow", {
    worker: public_key,
    input: bytes(32),
    signature: bytes(65),
    work: bytes(32)
});

var custom = new Serializer("custom", {
    required_auths: set(string),
    id: uint16,
    data: bytes()
});

var report_over_production = new Serializer("report_over_production", {
    reporter: string,
    first_block: signed_block_header,
    second_block: signed_block_header
});

var delete_comment = new Serializer("delete_comment", {
    author: string,
    permlink: string
});

var custom_json = new Serializer("custom_json", {
    required_auths: set(string),
    required_posting_auths: set(string),
    id: string,
    json: string
});

var comment_options = new Serializer("comment_options", {
    author: string,
    permlink: string,
    max_accepted_payout: asset,
    percent_steem_dollars: uint16,
    allow_votes: bool,
    allow_curation_rewards: bool,
    extensions: set(static_variant([comment_payout_beneficiaries]))
});

var set_withdraw_vesting_route = new Serializer("set_withdraw_vesting_route", {
    from_account: string,
    to_account: string,
    percent: uint16,
    auto_vest: bool
});

var limit_order_create2 = new Serializer("limit_order_create2", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    exchange_rate: price,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var challenge_authority = new Serializer("challenge_authority", {
    challenger: string,
    challenged: string,
    require_owner: bool
});

var prove_authority = new Serializer("prove_authority", {
    challenged: string,
    require_owner: bool
});

var request_account_recovery = new Serializer("request_account_recovery", {
    recovery_account: string,
    account_to_recover: string,
    new_owner_authority: authority,
    extensions: set(future_extensions)
});

var recover_account = new Serializer("recover_account", {
    account_to_recover: string,
    new_owner_authority: authority,
    recent_owner_authority: authority,
    extensions: set(future_extensions)
});

var change_recovery_account = new Serializer("change_recovery_account", {
    account_to_recover: string,
    new_recovery_account: string,
    extensions: set(future_extensions)
});

var escrow_transfer = new Serializer("escrow_transfer", {
    from: string,
    to: string,
    sbd_amount: asset,
    steem_amount: asset,
    escrow_id: uint32,
    agent: string,
    fee: asset,
    json_meta: string,
    ratification_deadline: time_point_sec,
    escrow_expiration: time_point_sec
});

var escrow_dispute = new Serializer("escrow_dispute", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32
});

var escrow_release = new Serializer("escrow_release", {
    from: string,
    to: string,
    agent: string,
    who: string,
    receiver: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset
});

var pow2_input = new Serializer("pow2_input", {
    worker_account: string,
    prev_block: bytes(20),
    nonce: uint64
});

var pow2 = new Serializer("pow2", {
    input: pow2_input,
    pow_summary: uint32
});

var equihash_proof = new Serializer("equihash_proof", {
    n: uint32,
    k: uint32,
    seed: bytes(32),
    inputs: array(uint32)
});

var equihash_pow = new Serializer("equihash_pow", {
    input: pow2_input,
    proof: equihash_proof,
    prev_block: bytes(20),
    pow_summary: uint32
});

var escrow_approve = new Serializer("escrow_approve", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32,
    approve: bool
});

var transfer_to_savings = new Serializer("transfer_to_savings", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_from_savings = new Serializer("transfer_from_savings", {
    from: string,
    request_id: uint32,
    to: string,
    amount: asset,
    memo: string
});

var cancel_transfer_from_savings = new Serializer("cancel_transfer_from_savings", {
    from: string,
    request_id: uint32
});

var custom_binary = new Serializer("custom_binary", {
    required_owner_auths: set(string),
    required_active_auths: set(string),
    required_posting_auths: set(string),
    required_auths: array(authority),
    id: string,
    data: bytes()
});

var decline_voting_rights = new Serializer("decline_voting_rights", {
    account: string,
    decline: bool
});

var reset_account = new Serializer("reset_account", {
    reset_account: string,
    account_to_reset: string,
    new_owner_authority: authority
});

var set_reset_account = new Serializer("set_reset_account", {
    account: string,
    current_reset_account: string,
    reset_account: string
});

var claim_reward_balance = new Serializer("claim_reward_balance", {
    account: string,
    reward_steem: asset,
    reward_sbd: asset,
    reward_vests: asset
});

var delegate_vesting_shares = new Serializer("delegate_vesting_shares", {
    delegator: string,
    delegatee: string,
    vesting_shares: asset
});

var account_create_with_delegation = new Serializer("account_create_with_delegation", {
    fee: asset,
    delegation: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string,
    extensions: set(future_extensions)
});

var fill_convert_request = new Serializer("fill_convert_request", {
    owner: string,
    requestid: uint32,
    amount_in: asset,
    amount_out: asset
});

var author_reward = new Serializer("author_reward", {
    author: string,
    permlink: string,
    sbd_payout: asset,
    steem_payout: asset,
    vesting_payout: asset
});

var curation_reward = new Serializer("curation_reward", {
    curator: string,
    reward: asset,
    comment_author: string,
    comment_permlink: string
});

var comment_reward = new Serializer("comment_reward", {
    author: string,
    permlink: string,
    payout: asset
});

var liquidity_reward = new Serializer("liquidity_reward", {
    owner: string,
    payout: asset
});

var interest = new Serializer("interest", {
    owner: string,
    interest: asset
});

var fill_vesting_withdraw = new Serializer("fill_vesting_withdraw", {
    from_account: string,
    to_account: string,
    withdrawn: asset,
    deposited: asset
});

var fill_order = new Serializer("fill_order", {
    current_owner: string,
    current_orderid: uint32,
    current_pays: asset,
    open_owner: string,
    open_orderid: uint32,
    open_pays: asset
});

var shutdown_witness = new Serializer("shutdown_witness", { owner: string });

var fill_transfer_from_savings = new Serializer("fill_transfer_from_savings", {
    from: string,
    to: string,
    amount: asset,
    request_id: uint32,
    memo: string
});

var hardfork = new Serializer("hardfork", { hardfork_id: uint32 });

var comment_payout_update = new Serializer("comment_payout_update", {
    author: string,
    permlink: string
});

var return_vesting_delegation = new Serializer("return_vesting_delegation", {
    account: string,
    vesting_shares: asset
});

var comment_benefactor_reward = new Serializer("comment_benefactor_reward", {
    benefactor: string,
    author: string,
    permlink: string,
    reward: asset
});

operation.st_operations = [vote, comment, transfer, transfer_to_vesting, withdraw_vesting, limit_order_create, limit_order_cancel, feed_publish, convert, account_create, account_update, witness_update, account_witness_vote, account_witness_proxy, pow, custom, report_over_production, delete_comment, custom_json, comment_options, set_withdraw_vesting_route, limit_order_create2, challenge_authority, prove_authority, request_account_recovery, recover_account, change_recovery_account, escrow_transfer, escrow_dispute, escrow_release, pow2, escrow_approve, transfer_to_savings, transfer_from_savings, cancel_transfer_from_savings, custom_binary, decline_voting_rights, reset_account, set_reset_account, claim_reward_balance, delegate_vesting_shares, account_create_with_delegation, fill_convert_request, author_reward, curation_reward, comment_reward, liquidity_reward, interest, fill_vesting_withdraw, fill_order, shutdown_witness, fill_transfer_from_savings, hardfork, comment_payout_update, return_vesting_delegation, comment_benefactor_reward];

var transaction = new Serializer("transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions)
});

//# -------------------------------
//#  Generated code end  S T O P
//# -------------------------------

// Custom Types (do not over-write)

var encrypted_memo = new Serializer("encrypted_memo", { from: public_key,
    to: public_key,
    nonce: uint64,
    check: uint32,
    encrypted: string_binary });
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/operations.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"./serializer":63,"./types":65,"buffer":11,"pBGvAp":74}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ByteBuffer = require('bytebuffer');
var EC = require('./error_with_cause');

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

var Serializer = function () {
    function Serializer(operation_name, types) {
        _classCallCheck(this, Serializer);

        this.operation_name = operation_name;
        this.types = types;
        if (this.types) this.keys = Object.keys(this.types);

        Serializer.printDebug = true;
    }

    _createClass(Serializer, [{
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            var object = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    try {
                        if (HEX_DUMP) {
                            if (type.operation_name) {
                                console.error(type.operation_name);
                            } else {
                                var o1 = b.offset;
                                type.fromByteBuffer(b);
                                var o2 = b.offset;
                                b.offset = o1;
                                //b.reset()
                                var _b = b.copy(o1, o2);
                                console.error(this.operation_name + '.' + field + '\t', _b.toHex());
                            }
                        }
                        object[field] = type.fromByteBuffer(b);
                    } catch (e) {
                        if (Serializer.printDebug) {
                            console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');
                            b.printDebug();
                        }
                        throw e;
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return object;
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b, object) {
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    type.appendByteBuffer(b, object[field]);
                }
            } catch (error) {
                try {
                    EC.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
                } catch (e) {
                    // circular ref
                    EC.throw(this.operation_name + '.' + field + " = " + object[field], error);
                }
            }
            return;
        }
    }, {
        key: 'fromObject',
        value: function fromObject(serialized_object) {
            var result = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var value = serialized_object[field];
                    //DEBUG value = value.resolve if value.resolve
                    //DEBUG console.log('... value',field,value)
                    var object = type.fromObject(value);
                    result[field] = object;
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /**
            @arg {boolean} [debug.use_default = false] - more template friendly
            @arg {boolean} [debug.annotate = false] - add user-friendly information
        */

    }, {
        key: 'toObject',
        value: function toObject() {
            var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: false, annotate: false };

            var result = {};
            var field = null;
            try {
                if (!this.types) return result;

                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);
                    result[field] = object;
                    if (HEX_DUMP) {
                        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
                        var has_value = typeof serialized_object !== "undefined" && serialized_object !== null;
                        if (has_value) {
                            var value = serialized_object[field];
                            if (value) type.appendByteBuffer(b, value);
                        }
                        b = b.copy(0, b.offset);
                        console.error(this.operation_name + '.' + field, b.toHex());
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /** Sort by the first element in a operation */

    }, {
        key: 'compare',
        value: function compare(a, b) {

            var first_key = this.keys[0];
            var first_type = this.types[first_key];

            var valA = a[first_key];
            var valB = b[first_key];

            if (first_type.compare) return first_type.compare(valA, valB);

            if (typeof valA === "number" && typeof valB === "number") return valA - valB;

            var encoding = void 0;
            if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
                // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
                encoding = "hex";
            }

            var strA = valA.toString(encoding);
            var strB = valB.toString(encoding);
            return strA > strB ? 1 : strA < strB ? -1 : 0;
        }

        // <helper_functions>

    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var b = ByteBuffer.fromBinary(buffer.toString("binary"), ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'toHex',
        value: function toHex(object) {
            // return this.toBuffer(object).toString("hex")
            var b = this.toByteBuffer(object);
            return b.toHex();
        }
    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer(object) {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b, object);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer(object) {
            return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
        }
    }]);

    return Serializer;
}();

module.exports = Serializer;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/serializer.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"./error_with_cause":60,"buffer":11,"bytebuffer":12,"pBGvAp":74}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

/** Console print any transaction object with zero default values. */
module.exports = function template(op) {

    var object = op.toObject(void 0, { use_default: true, annotate: true });

    // visual (with descriptions)
    console.error(JSON.stringify(object, null, 4));

    // usable in a copy-paste

    object = op.toObject(void 0, { use_default: true, annotate: false });

    // copy-paste one-lineer
    console.error(JSON.stringify(object));
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/template.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Low-level types that make up operations

var v = require('./SerializerValidation');
var fp = require('./FastParser');

var ChainTypes = require("../../chain/src/ChainTypes");
var ObjectId = require("../../chain/src/ObjectId");

var _require = require("../../ecc"),
    PublicKey = _require.PublicKey,
    Address = _require.Address;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require2 = require("./numberUtils"),
    fromImpliedDecimal = _require2.fromImpliedDecimal;

var Types = {};
module.exports = Types;

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

/**
* Asset symbols contain the following information
*
*  4 bit PRECISION
*  4 bit RESERVED
*  CHAR[6] up to 6 upper case alpha numeric ascii characters,
*  char = \0  null terminated
*
*  It is treated as a uint64_t for all internal operations, but
*  is easily converted to something that can be displayed.
*/
Types.asset = {
    fromByteBuffer: function fromByteBuffer(b) {
        var amount = b.readInt64();
        var precision = b.readUint8();
        var b_copy = b.copy(b.offset, b.offset + 7);
        var symbol = new Buffer(b_copy.toBinary(), "binary").toString().replace(/\x00/g, "");
        b.skip(7);
        // "1.000 STEEM" always written with full precision
        var amount_string = fromImpliedDecimal(amount, precision);
        return amount_string + " " + symbol;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        object = object.trim();
        if (!/^[0-9]+\.?[0-9]* [A-Za-z0-9]+$/.test(object)) throw new Error("Expecting amount like '99.000 SYMBOL', instead got '" + object + "'");

        var _object$split = object.split(" "),
            _object$split2 = _slicedToArray(_object$split, 2),
            amount = _object$split2[0],
            symbol = _object$split2[1];

        if (symbol.length > 6) throw new Error("Symbols are not longer than 6 characters " + symbol + "-" + symbol.length);

        b.writeInt64(v.to_long(amount.replace(".", "")));
        var dot = amount.indexOf("."); // 0.000
        var precision = dot === -1 ? 0 : amount.length - dot - 1;
        b.writeUint8(precision);
        b.append(symbol.toUpperCase(), 'binary');
        for (var i = 0; i < 7 - symbol.length; i++) {
            b.writeUint8(0);
        }return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.000 STEEM";
        }
        return object;
    }
};

Types.uint8 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        b.writeUint8(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return parseInt(object);
    }
};

Types.uint16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        b.writeUint16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        return parseInt(object);
    }
};

Types.uint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

Types.varint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        b.writeVarint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

Types.int16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeInt16(object);
        return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        return parseInt(object);
    }
};

Types.int64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeInt64(v.to_long(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return v.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        v.required(object);
        return v.to_long(object).toString();
    }
};

Types.uint64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeUint64(v.to_long(v.unsigned(object)));
        return;
    },
    fromObject: function fromObject(object) {
        return v.to_long(v.unsigned(object));
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        return v.to_long(object).toString();
    }
};

Types.string = {
    fromByteBuffer: function fromByteBuffer(b) {
        return new Buffer(b.readVString(), 'utf8');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeVString(object.toString());
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object, 'utf8');
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString('utf8');
    }
};

Types.string_binary = {
    fromByteBuffer: function fromByteBuffer(b) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeVarint32(object.length);
        b.append(object.toString('binary'), 'binary');
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString();
    }
};

Types.bytes = function (size) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (size === undefined) {
                var b_copy;
                var len = b.readVarint32();
                b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            } else {
                b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (typeof object === "string") object = new Buffer(object, "hex");

            if (size === undefined) {
                b.writeVarint32(object.length);
            }
            b.append(object.toString('binary'), 'binary');
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (Buffer.isBuffer(object)) return object;

            return new Buffer(object, 'hex');
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                var zeros = function zeros(num) {
                    return new Array(num).join("00");
                };
                return zeros(size);
            }
            v.required(object);
            return object.toString('hex');
        }
    };
};

Types.bool = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8() === 1;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        // supports boolean or integer
        b.writeUint8(JSON.parse(object) ? 1 : 0);
        return;
    },
    fromObject: function fromObject(object) {
        return JSON.parse(object) ? true : false;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return false;
        }
        return JSON.parse(object) ? true : false;
    }
};

Types.void = {
    fromByteBuffer: function fromByteBuffer(b) {
        throw new Error("(void) undefined type");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        throw new Error("(void) undefined type");
    },
    fromObject: function fromObject(object) {
        throw new Error("(void) undefined type");
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return undefined;
        }
        throw new Error("(void) undefined type");
    }
};

Types.array = function (st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            var result = [];
            for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                result.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(result, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o);
            }
        },
        fromObject: function fromObject(object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.fromObject(o));
            }
            return result;
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            v.required(object);
            object = sortOperation(object, st_operation);

            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.toObject(o, debug));
            }
            return result;
        }
    };
};

Types.time_point_sec = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);

        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);

        if (typeof object === "number") return object;

        if (object.getTime) return Math.floor(object.getTime() / 1000);

        if (typeof object !== "string") throw new Error("Unknown date type: " + object);

        if (typeof object === "string" && !/Z$/.test(object)) object = object + "Z";

        return Math.floor(new Date(object).getTime() / 1000);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) return new Date(0).toISOString().split('.')[0];

        v.required(object);

        if (typeof object === "string") return object;

        if (object.getTime) return object.toISOString().split('.')[0];

        var int = parseInt(object);
        v.require_range(0, 0xFFFFFFFF, int, 'uint32 ' + object);
        return new Date(int * 1000).toISOString().split('.')[0];
    }
};

Types.set = function (st_operation) {
    return {
        validate: function validate(array) {
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (ref = typeof o === 'undefined' ? 'undefined' : _typeof(o), ['string', 'number'].indexOf(ref) >= 0) {
                    if (dup_map[o] !== undefined) {
                        throw new Error("duplicate (set)");
                    }
                    dup_map[o] = true;
                }
            }
            return sortOperation(array, st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                    result.push(st_operation.fromByteBuffer(b));
                }
                return result;
            }());
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (!object) {
                object = [];
            }
            b.writeVarint32(object.length);
            var iterable = this.validate(object);
            for (var i = 0, o; i < iterable.length; i++) {
                o = iterable[i];
                st_operation.appendByteBuffer(b, o);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.fromObject(o));
                }
                return result;
            }());
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.toObject(o, debug));
                }
                return result;
            }());
        }
    };
};

// global_parameters_update_operation current_fees
Types.fixed_array = function (count, st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(results, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            var i, j, ref;
            if (count !== 0) {
                v.required(object);
                object = sortOperation(object, st_operation);
            }
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                st_operation.appendByteBuffer(b, object[i]);
            }
        },
        fromObject: function fromObject(object) {
            var i, j, ref, results;
            if (count !== 0) {
                v.required(object);
            }
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromObject(object[i]));
            }
            return results;
        },
        toObject: function toObject(object, debug) {
            var i, j, k, ref, ref1, results, results1;
            if (debug == null) {
                debug = {};
            }
            if (debug.use_default && object === void 0) {
                results = [];
                for (i = j = 0, ref = count; j < ref; i = j += 1) {
                    results.push(st_operation.toObject(void 0, debug));
                }
                return results;
            }
            if (count !== 0) {
                v.required(object);
            }
            results1 = [];
            for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
                results1.push(st_operation.toObject(object[i], debug));
            }
            return results1;
        }
    };
};

/* Supports instance numbers (11) or object types (1.2.11).  Object type
validation is enforced when an object type is used. */
var id_type = function id_type(reserved_spaces, object_type) {
    v.required(reserved_spaces, "reserved_spaces");
    v.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }
            b.writeVarint32(v.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (v.is_digits(object)) {
                return v.to_number(object);
            }
            return v.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var object_type_id = chain_types.object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + '.' + object_type_id + '.0';
            }
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }

            return reserved_spaces + '.' + object_type_id + '.' + object;
        }
    };
};

Types.protocol_id_type = function (name) {
    v.required(name, "name");
    return id_type(chain_types.reserved_spaces.protocol_ids, name);
};

Types.object_id_type = {
    fromByteBuffer: function fromByteBuffer(b) {
        return ObjectId.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        object.appendByteBuffer(b);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return ObjectId.fromString(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.0.0";
        }
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        return object.toString();
    }
};

Types.vote_id = { TYPE: 0x000000FF,
    ID: 0xFFFFFF00,
    fromByteBuffer: function fromByteBuffer(b) {
        var value = b.readUint32();
        return {
            type: value & this.TYPE,
            id: value & this.ID
        };
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object === "string") object = Types.vote_id.fromObject(object);

        var value = object.id << 8 | object.type;
        b.writeUint32(value);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object, "(type vote_id)");
        if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === "object") {
            v.required(object.type, "type");
            v.required(object.id, "id");
            return object;
        }
        v.require_test(/^[0-9]+:[0-9]+$/, object, 'vote_id format ' + object);

        var _object$split3 = object.split(':'),
            _object$split4 = _slicedToArray(_object$split3, 2),
            type = _object$split4[0],
            id = _object$split4[1];

        v.require_range(0, 0xff, type, 'vote type ' + object);
        v.require_range(0, 0xffffff, id, 'vote id ' + object);
        return { type: type, id: id };
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0:0";
        }
        v.required(object);
        if (typeof object === "string") object = Types.vote_id.fromObject(object);

        return object.type + ":" + object.id;
    },
    compare: function compare(a, b) {
        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== "object") a = Types.vote_id.fromObject(a);
        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== "object") b = Types.vote_id.fromObject(b);
        return parseInt(a.id) - parseInt(b.id);
    }
};

Types.optional = function (st_operation) {
    v.required(st_operation, "st_operation");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (!(b.readUint8() === 1)) {
                return undefined;
            }
            return st_operation.fromByteBuffer(b);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (object !== null && object !== undefined) {
                b.writeUint8(1);
                st_operation.appendByteBuffer(b, object);
            } else {
                b.writeUint8(0);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (object === undefined) {
                return undefined;
            }
            return st_operation.fromObject(object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // toObject is only null save if use_default is true
            var result_object = function () {
                if (!debug.use_default && object === undefined) {
                    return undefined;
                } else {
                    return st_operation.toObject(object, debug);
                }
            }();

            if (debug.annotate) {
                if ((typeof result_object === 'undefined' ? 'undefined' : _typeof(result_object)) === "object") {
                    result_object.__optional = "parent is optional";
                } else {
                    result_object = { __optional: result_object };
                }
            }
            return result_object;
        }
    };
};

Types.static_variant = function (_st_operations) {
    return {
        nosort: true,
        st_operations: _st_operations,
        opTypeId: function opTypeId(value) {
            var pos = 0,
                type_id = void 0;
            if (typeof value === "number") type_id = value;else {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.st_operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var op = _step.value;

                        if (op.operation_name === value) {
                            type_id = pos;
                            break;
                        }
                        pos++;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return type_id;
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var type_id = b.readVarint32();
            var st_operation = this.st_operations[type_id];
            if (HEX_DUMP) {
                console.error('static_variant id 0x' + type_id.toString(16) + ' (' + type_id + ')');
            }
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromByteBuffer(b)];
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            b.writeVarint32(type_id);
            st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [this.st_operations[0].operation_name, this.st_operations[0].toObject(undefined, debug)];
            }
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [st_operation.operation_name, st_operation.toObject(object[1], debug)];
        },
        compare: function compare(a, b) {
            return strCmp(this.opTypeId(a[0]), this.opTypeId(b[0]));
        }
    };
};

Types.map = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ['number', 'string'].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                key_st_operation.appendByteBuffer(b, o[0]);
                value_st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            v.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
            }
            return result;
        }
    };
};

Types.public_key = {
    toPublic: function toPublic(object) {
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return object == null ? object : object.Q ? object : PublicKey.fromStringOrThrow(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return fp.public_key(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        fp.public_key(b, Types.public_key.toPublic(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.Q) {
            return object;
        }
        return Types.public_key.toPublic(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
        }
        v.required(object);
        return object.toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

Types.address = {
    _to_address: function _to_address(object) {
        v.required(object);
        if (object.addy) {
            return object;
        }
        return Address.fromString(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return new Address(fp.ripemd160(b));
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        fp.ripemd160(b, Types.address._to_address(object).toBuffer());
        return;
    },
    fromObject: function fromObject(object) {
        return Types.address._to_address(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
        }
        return Types.address._to_address(object).toString();
    },
    compare: function compare(a, b) {
        // sort decending
        return -1 * strCmp(a.toString(), b.toString());
    }
};

var strCmp = function strCmp(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};
var firstEl = function firstEl(el) {
    return Array.isArray(el) ? el[0] : el;
};
var sortOperation = function sortOperation(array, st_operation) {
    return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
        return st_operation.compare(firstEl(a), firstEl(b));
    }) : // custom compare operation
    array.sort(function (a, b) {
        return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) :
        // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
        Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
    });
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/types.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../chain/src/ChainConfig":37,"../../chain/src/ChainTypes":38,"../../chain/src/ObjectId":41,"../../ecc":44,"./FastParser":58,"./SerializerValidation":59,"./numberUtils":61,"buffer":11,"pBGvAp":74}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/index.js","/../node_modules/esteem-lib/node_modules/deep-equal")
},{"./lib/is_arguments.js":67,"./lib/keys.js":68,"buffer":11,"pBGvAp":74}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/lib/is_arguments.js","/../node_modules/esteem-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/lib/keys.js","/../node_modules/esteem-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/events/events.js","/../node_modules/events")
},{"buffer":11,"pBGvAp":74}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ieee754/index.js","/../node_modules/ieee754")
},{"buffer":11,"pBGvAp":74}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/inherits/inherits_browser.js","/../node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/long/dist/long.js","/../node_modules/long/dist")
},{"buffer":11,"pBGvAp":74}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/object-assign/index.js","/../node_modules/object-assign")
},{"buffer":11,"pBGvAp":74}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/process/browser.js","/../node_modules/process")
},{"buffer":11,"pBGvAp":74}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ripemd160/lib/ripemd160.js","/../node_modules/ripemd160/lib")
},{"buffer":11,"pBGvAp":74}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function(globals){
'use strict'

//*** UMD BEGIN
if (typeof define !== 'undefined' && define.amd) { //require.js / AMD
  define([], function() {
    return secureRandom
  })
} else if (typeof module !== 'undefined' && module.exports) { //CommonJS
  module.exports = secureRandom
} else { //script / browser
  globals.secureRandom = secureRandom
}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (typeof process != 'undefined' && typeof process.pid == 'number') {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = require('crypto')
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/secure-random/lib/secure-random.js","/../node_modules/secure-random/lib")
},{"buffer":11,"crypto":8,"pBGvAp":74}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/hash.js","/../node_modules/sha.js")
},{"buffer":11,"pBGvAp":74}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/index.js","/../node_modules/sha.js")
},{"./sha":79,"./sha1":80,"./sha224":81,"./sha256":82,"./sha384":83,"./sha512":84,"buffer":11,"pBGvAp":74}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha1.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha224.js","/../node_modules/sha.js")
},{"./hash":77,"./sha256":82,"buffer":11,"inherits":71,"pBGvAp":74}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha256.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha384.js","/../node_modules/sha.js")
},{"./hash":77,"./sha512":84,"buffer":11,"inherits":71,"pBGvAp":74}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha512.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WsRpc = require("./WebSocketRpc");
var SteemApi = require("./SteemApi");

var defaultOptions = {
    url: "wss://node.steem.ws",
    user: "",
    pass: "",
    debug: false,
    apis: ["database_api", "network_broadcast_api", "follow_api", "market_history_api", "login_api", "private_message_api"]
};

var objectAssign = require('object-assign');

var apiInstance;

module.exports = {

    reset: function reset() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (apiInstance) {
            this.close();
        }
        apiInstance = new ApiInstance(options);
        apiInstance.connect();

        return apiInstance;
    },

    get: function get() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var connect = arguments[1];

        if (!apiInstance) {
            apiInstance = new ApiInstance(options);
        }

        if (connect) {
            apiInstance.setOptions(options);
            apiInstance.connect();
        }

        return apiInstance;
    },


    close: function close() {
        apiInstance.close();apiInstance = null;
    }
};

var ApiInstance = function () {
    function ApiInstance(options) {
        _classCallCheck(this, ApiInstance);

        this.setOptions(options);
        this.statusCallback = options.statusCallback;
    }

    _createClass(ApiInstance, [{
        key: "setOptions",
        value: function setOptions(options) {
            this.options = objectAssign({}, defaultOptions, options);//Object.assign({}, defaultOptions, options);
            if (this.options.apis.indexOf("database_api") === -1) {
                this.options.apis.unshift("database_api");
            }
        }
    }, {
        key: "connect",
        value: function connect() {
            if (this.wsRpc) {
                return;
            }

            try {
                this.wsRpc = new WsRpc(this.options, this.onReconnect.bind(this), this.onStatusChange.bind(this));
                return this.login();
            } catch (err) {
                console.error("wsRpc open error:", err);
            }
        }
    }, {
        key: "login",
        value: function login() {
            var _this = this;

            return this.initPromise = this.wsRpc.login(this.options.user, this.options.pass).then(function () {
                var apiPromises = [];

                _this.options.apis.forEach(function (api) {
                    _this["_" + api] = new SteemApi(_this.wsRpc, api);
                    _this[api] = function () {
                        return this["_" + api];
                    };
                    apiPromises.push(_this["_" + api].init().then(function () {
                        if (api === "database_api") {
                            return _this[api]().exec("get_config", []).then(function (res) {
                                console.log(res.STEEMIT_CHAIN_ID);
                                _this.chainId = res.STEEMIT_CHAIN_ID;
                                return "connected to " + api;
                            });
                        } else {
                            return "connected to " + api;
                        }
                    }));
                });
                return Promise.all(apiPromises);
            }).catch(function (err) {
                // console.error("Unable to connect to", this.options.url);
                throw new Error("Unable to connect to " + _this.options.url);
            });
        }
    }, {
        key: "onReconnect",
        value: function onReconnect() {
            this.login();
        }
    }, {
        key: "onStatusChange",
        value: function onStatusChange(e) {
            if (this.statusCallback) {
                this.statusCallback(e);
            }
        }
    }, {
        key: "close",
        value: function close() {
            if (this.wsRpc) {
                this.wsRpc.close();
                this.wsRpc = null;
            }
        }
    }]);

    return ApiInstance;
}();
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/ApiInstance.js","/../node_modules/steem-rpc/lib")
},{"./SteemApi":86,"./WebSocketRpc":87,"buffer":11,"object-assign":73,"pBGvAp":74}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SteemApi = function () {
	function SteemApi(wsRpc, apiName) {
		_classCallCheck(this, SteemApi);

		this.wsRpc = wsRpc;
		this.apiName = apiName;
	}

	_createClass(SteemApi, [{
		key: "init",
		value: function init() {
			var _this = this;

			return this.wsRpc.getApiByName(this.apiName).then(function (response) {
				_this.apiId = response;
				return _this;
			});
		}
	}, {
		key: "exec",
		value: function exec(method, params) {
			return this.wsRpc.call([this.apiId, method, params]).catch(function (error) {
				console.error("Api error:", method, params, JSON.stringify(error));
				var newErr = new Error("Api error:" + method + params + JSON.stringify(error));
				newErr.original = error;
				localStorage.error = 1;
				localStorage.errormessage = error.message?error.message.split("\n")[1]:'Connection lost, reconnecting...';
				throw newErr;
			});
		}
	}]);

	return SteemApi;
}();

module.exports = SteemApi;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/SteemApi.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RWebSocket = require("./reconnecting-websocket");

var WebSocketRpc = function () {
	function WebSocketRpc(options) {
		var _this = this;

		var rcCallback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
		var statusCallback = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

		_classCallCheck(this, WebSocketRpc);

		this.rcCallback = rcCallback;
		this.statusCallback = statusCallback;

		if (typeof WebSocket !== "undefined") {
			options.WebSocket = WebSocket;
			options.idleTreshold = "idleTreshold" in options ? options.idleTreshold : 60000; // Only use idle threshold in browsers
		} else {
				options.WebSocket = require("ws");
				options.idleTreshold = 0; // Always reconnect in node.js
			}
		options.reconnectInterval = 1000;
		options.reconnectDecay = 1.2;

		this.ws = new RWebSocket(options);
		this.ws.timeoutInterval = 15000;

		var initialConnect = true;

		this.connectPromise = new Promise(function (resolve, reject) {

			_this.ws.onopen = function () {
				if (_this.statusCallback) _this.statusCallback("open");
				if (initialConnect) {
					initialConnect = false;
					resolve();
				} else {
					if (_this.rcCallback) _this.rcCallback();
				}
			};

			_this.ws.onerror = function (err) {
				if (_this.statusCallback) _this.statusCallback("error");
				reject(err);
			};

			_this.ws.onmessage = function (message) {
				var data = {};
				try {
					data = JSON.parse(message.data);
				} catch (e) {
					console.log("Unable to parse API response:", e);
					data.error = "Unable to parse response " + JSON.stringify(message);
				}
				_this.listener(data);
			};

			_this.ws.onclose = function () {
				// web socket may re-connect
				_this.cbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.methodCbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.cbs.clear();
				_this.methodCbs.clear();
				_this.cbId = 0;

				if (_this.statusCallback) _this.statusCallback("closed");
			};
		});

		this.cbId = 0;
		this.cbs = new Map();
		this.methodCbs = new Map();

		if (typeof window !== "undefined") {
			window.onbeforeunload = function () {
				_this.close();
			};
		}
	}

	_createClass(WebSocketRpc, [{
		key: "listener",
		value: function listener(message) {
			var callback = this.cbs.get(message.id);
			var methodCallback = this.methodCbs.get(message.id);

			if (methodCallback) {
				this.methodCbs.delete(message.id);
				if ("error" in message && "reject" in methodCallback) {
					methodCallback.reject(message.error);
				} else if ("resolve" in methodCallback) {
					methodCallback.resolve();
				}
			}

			if (callback) {
				this.cbs.delete(message.id);
				if ("error" in message) {
					callback.reject(message.error);
				} else {
					callback.resolve(message.result);
				}
			}
		}
	}, {
		key: "call",
		value: function call(params) {
			var _this2 = this;

			var request = {
				method: "call",
				params: params,
				id: this.cbId++
			};

			return new Promise(function (resolve, reject) {

				_this2.cbs.set(request.id, {
					time: new Date(),
					resolve: resolve,
					reject: reject
				});

				if (request.params[1] === "broadcast_transaction_with_callback" && request.params[2][0]) {
					_this2.methodCbs.set(request.id, request.params[2][0]);
					request.params[2][0] = request.params[2][0].resolve;
				}

				_this2.ws.onerror = function (error) {
					reject(error);
				};

				_this2.ws.send(JSON.stringify(request));
			});
		}
	}, {
		key: "getApiByName",
		value: function getApiByName(api) {
			return this.call([1, "get_api_by_name", [api]]);
		}
	}, {
		key: "login",
		value: function login(user, password) {
			var _this3 = this;

			return this.connectPromise.then(function () {
				return _this3.call([1, "login", [user, password]]);
			});
		}
	}, {
		key: "close",
		value: function close() {
			console.log('closing ws');
			if (this.ws) {
				this.ws.onclose();
				this.ws.close();
				this.ws = null;
			}
		}
	}]);

	return WebSocketRpc;
}();

module.exports = WebSocketRpc;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/WebSocketRpc.js","/../node_modules/steem-rpc/lib")
},{"./reconnecting-websocket":89,"buffer":11,"pBGvAp":74,"ws":8}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Client = require("./ApiInstance");

module.exports = {
	Client: Client
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/index.js","/../node_modules/steem-rpc/lib")
},{"./ApiInstance":85,"buffer":11,"pBGvAp":74}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

// MIT License:
//
// Copyright (c) 2010-2012, Joe Walnes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * This behaves like a WebSocket in every way, except if it fails to connect,
 * or it gets disconnected, it will repeatedly poll until it successfully connects
 * again.
 *
 * It is API compatible, so when you have:
 *   ws = new WebSocket('ws://....');
 * you can replace with:
 *   ws = new ReconnectingWebSocket('ws://....');
 *
 * The event stream will typically look like:
 *  onconnecting
 *  onopen
 *  onmessage
 *  onmessage
 *  onclose // lost connection
 *  onconnecting
 *  onopen  // sometime later...
 *  onmessage
 *  onmessage
 *  etc...
 *
 * It is API compatible with the standard WebSocket API, apart from the following members:
 *
 * - `bufferedAmount`
 * - `extensions`
 * - `binaryType`
 *
 * Latest version: https://github.com/joewalnes/reconnecting-websocket/
 * - Joe Walnes
 *
 * Syntax
 * ======
 * var socket = new ReconnectingWebSocket(url, protocols, options);
 *
 * Parameters
 * ==========
 * url - The url you are connecting to.
 * protocols - Optional string or array of protocols.
 * options - See below
 *
 * Options
 * =======
 * Options can either be passed upon instantiation or set after instantiation:
 *
 * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });
 *
 * or
 *
 * var socket = new ReconnectingWebSocket(url);
 * socket.debug = true;
 * socket.reconnectInterval = 4000;
 *
 * debug
 * - Whether this instance should log debug messages. Accepts true or false. Default: false.
 *
 * automaticOpen
 * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().
 *
 * reconnectInterval
 * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.
 *
 * maxReconnectInterval
 * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.
 *
 * reconnectDecay
 * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.
 *
 * timeoutInterval
 * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.
 *
 */
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    } else {
        global.ReconnectingWebSocket = factory();
    }
})(undefined, function () {

    //if (!('WebSocket' in window)) {
    //    return;
    //}

    var WebSocket;

    function ReconnectingWebSocket(options) {

        // Default settings
        var settings = {

            /** Whether this instance should log debug messages. */
            debug: false,

            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
            automaticOpen: true,

            /** The number of milliseconds to delay before attempting to reconnect. */
            reconnectInterval: 2000,
            /** The maximum number of milliseconds to delay a reconnection attempt. */
            maxReconnectInterval: 300000,
            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
            reconnectDecay: 1.5,

            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
            timeoutInterval: 2000,

            /** The maximum number of reconnection attempts to make. Unlimited if null. */
            maxReconnectAttempts: 100,

            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
            binaryType: 'arraybuffer',

            /** Don't reconnect if idle (no user activity after idleTreshold), pass 0 to always reconnect **/
            idleTreshold: 0
        };
        if (!options) {
            options = {};
        }

        WebSocket = options.WebSocket;
        ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
        ReconnectingWebSocket.OPEN = WebSocket.OPEN;
        ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
        ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;
        if (!console.debug) console.debug = console.log;

        // Overwrite and define settings with options if they exist.
        for (var key in settings) {
            if (typeof options[key] !== 'undefined') {
                this[key] = options[key];
            } else {
                this[key] = settings[key];
            }
        }

        // These should be treated as read-only properties

        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
        this.url = options.url;

        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
        this.reconnectAttempts = 0;

        /**
         * The current state of the connection.
         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
         * Read only.
         */
        this.readyState = WebSocket.CONNECTING;

        /**
         * A string indicating the name of the sub-protocol the server selected; this will be one of
         * the strings specified in the protocols parameter when creating the WebSocket object.
         * Read only.
         */
        this.protocol = null;

        // Private state variables

        var self = this;
        var ws;
        var forcedClose = false;
        var timedOut = false;
        var handlers = {};
        var eventTarget = {
            addEventListener: function addEventListener(event, handler) {
                handlers[event] = handler;
            },
            removeEventListener: function removeEventListener(event) {
                delete handlers[event];
            },
            dispatchEvent: function dispatchEvent(event) {
                var handler = handlers[event.name];
                if (handler) handler(event);
            }
        }; //document.createElement('div');

        // Wire up "on*" properties as event handlers

        eventTarget.addEventListener('open', function (event) {
            self.onopen(event);
        });
        eventTarget.addEventListener('close', function (event) {
            self.onclose(event);
        });
        eventTarget.addEventListener('connecting', function (event) {
            self.onconnecting(event);
        });
        eventTarget.addEventListener('message', function (event) {
            self.onmessage(event);
        });
        eventTarget.addEventListener('error', function (event) {
            self.onerror(event);
        });

        // Expose the API required by EventTarget

        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

        /**
         * This function generates an event that is compatible with standard
         * compliant browsers and IE9 - IE11
         *
         * This will prevent the error:
         * Object doesn't support this action
         *
         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
         * @param s String The name that the event should use
         * @param args Object an optional object that the event will use
         */
        function generateEvent(s, args) {
            //var evt = document.createEvent("CustomEvent");
            //evt.initCustomEvent(s, false, false, args);
            //return evt;
            return { name: s };
        };

        self.pendingReconnect = false;
        self.idleSince = new Date();

        if (this.idleTreshold) {
            if (typeof document !== 'undefined') {
                document.onkeypress = document.onmousemove = document.onclick = document.onscroll = document.touchstart = function () {
                    self.idleSince = new Date();
                    if (self.pendingReconnect) {
                        self.pendingReconnect = false;
                        self.reconnect();
                    }
                };
            }
        }

        this.reconnect = function () {
            var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
            timeout = timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout;
            if (self.debug) {
                console.debug('WebSocket: will try to reconnect in ' + parseInt(timeout / 1000) + ' sec, attempt #' + (self.reconnectAttempts + 1));
            }
            setTimeout(function () {
                self.reconnectAttempts++;
                self.open(true);
            }, timeout);
        };

        this.open = function (reconnectAttempt) {
            if (reconnectAttempt) {
                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                    return;
                }
            } else {
                eventTarget.dispatchEvent(generateEvent('connecting'));
                this.reconnectAttempts = 0;
            }

            var surl = self.url;
            if (Array.isArray(self.url)) {
                surl = self.url[this.reconnectAttempts % self.url.length];
            }

            if (self.debug) {
                console.debug('connecting to', surl);
            }
            ws = new WebSocket(surl);
            ws.binaryType = this.binaryType;

            if (self.debug || ReconnectingWebSocket.debugAll) {
                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
            }

            var localWs = ws;
            var timeout = setTimeout(function () {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                }
                timedOut = true;
                localWs.close();
                timedOut = false;
            }, self.timeoutInterval);

            ws.onopen = function (event) {
                clearTimeout(timeout);
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket**', 'onopen', self.url);
                }
                self.protocol = ws.protocol;
                self.readyState = WebSocket.OPEN;
                self.reconnectAttempts = 0;
                var e = generateEvent('open');
                e.isReconnect = reconnectAttempt;
                reconnectAttempt = false;
                eventTarget.dispatchEvent(e);
            };

            ws.onclose = function (event) {
                if (event.code !== 1000 && self.debug) console.log('WARNING! ws connection', surl, 'closed');
                clearTimeout(timeout);
                ws = null;
                if (forcedClose) {
                    self.readyState = WebSocket.CLOSED;
                    eventTarget.dispatchEvent(generateEvent('close'));
                } else {
                    self.readyState = WebSocket.CONNECTING;
                    var e = generateEvent('connecting');
                    e.code = event.code;
                    e.reason = event.reason;
                    e.wasClean = event.wasClean;
                    eventTarget.dispatchEvent(e);
                    if (!reconnectAttempt && !timedOut) {
                        if (self.debug || ReconnectingWebSocket.debugAll) {
                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                        }
                        eventTarget.dispatchEvent(generateEvent('close'));
                    }

                    if (!self.idleTreshold || new Date() - self.idleSince < self.idleTreshold) {
                        self.reconnect();
                    } else {
                        if (self.debug) {
                            console.debug('idle - will reconnect later');
                        }
                        self.pendingReconnect = true;
                    }
                }
            };
            ws.onmessage = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onmessage', self.url);
                }
                var e = generateEvent('message');
                e.data = event.data;
                eventTarget.dispatchEvent(e);
            };
            ws.onerror = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                }
                eventTarget.dispatchEvent(generateEvent(event));
            };
        };

        // Whether or not to create a websocket upon instantiation
        if (this.automaticOpen == true) {
            this.open(false);
        }

        /**
         * Transmits data to the server over the WebSocket connection.
         *
         * @param data a text string, ArrayBuffer or Blob to send to the server.
         */
        this.send = function (data) {
            if (ws) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                }
                return ws.send(data);
            } else {
                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
            }
        };

        /**
         * Closes the WebSocket connection or connection attempt, if any.
         * If the connection is already CLOSED, this method does nothing.
         */
        this.close = function (code, reason) {
            // Default CLOSE_NORMAL code
            if (typeof code == 'undefined') {
                code = 1000;
            }
            forcedClose = true;
            if (ws) {
                ws.close(code, reason);
            }
        };

        /**
         * Additional public API method to refresh the connection if still open (close, re-open).
         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
         */
        this.refresh = function () {
            if (ws) {
                ws.close();
            }
        };
    }

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data.
     */
    ReconnectingWebSocket.prototype.onopen = function (event) {};
    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
    ReconnectingWebSocket.prototype.onclose = function (event) {};
    /** An event listener to be called when a connection begins being attempted. */
    ReconnectingWebSocket.prototype.onconnecting = function (event) {};
    /** An event listener to be called when a message is received from the server. */
    ReconnectingWebSocket.prototype.onmessage = function (event) {};
    /** An event listener to be called when an error occurs. */
    ReconnectingWebSocket.prototype.onerror = function (event) {};

    /**
     * Whether all instances of ReconnectingWebSocket should log debug messages.
     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
     */
    ReconnectingWebSocket.debugAll = false;

    return ReconnectingWebSocket;
});
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/reconnecting-websocket.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/duplex.js","/../node_modules/stream-browserify")
},{"./readable.js":94,"./writable.js":96,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":92}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/index.js","/../node_modules/stream-browserify")
},{"./duplex.js":90,"./passthrough.js":93,"./readable.js":94,"./transform.js":95,"./writable.js":96,"buffer":11,"events":69,"inherits":71,"pBGvAp":74}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/node_modules/process/browser.js","/../node_modules/stream-browserify/node_modules/process")
},{"buffer":11,"pBGvAp":74}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/passthrough.js","/../node_modules/stream-browserify")
},{"./transform.js":95,"buffer":11,"inherits":71,"pBGvAp":74}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/readable.js","/../node_modules/stream-browserify")
},{"./index.js":91,"buffer":11,"events":69,"inherits":71,"pBGvAp":74,"process/browser.js":92,"string_decoder":9}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/transform.js","/../node_modules/stream-browserify")
},{"./duplex.js":90,"buffer":11,"inherits":71,"pBGvAp":74}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/writable.js","/../node_modules/stream-browserify")
},{"./index.js":91,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":92}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/node_modules/inherits/inherits_browser.js","/../node_modules/util/node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/support/isBufferBrowser.js","/../node_modules/util/support")
},{"buffer":11,"pBGvAp":74}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/util.js","/../node_modules/util")
},{"./support/isBuffer":98,"buffer":11,"inherits":97,"pBGvAp":74}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./posts')
//require('steemjs-lib')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_8b94960e.js","/")
},{"./posts":103,"buffer":11,"pBGvAp":74}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
	app.constant('API_END_POINT','http://api.esteem.ws:8080');
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/config.js","/posts")
},{"buffer":11,"pBGvAp":74}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
//angular.module('steem.controllers', [])

app.controller('AppCtrl', function($scope, $ionicModal, $timeout, $rootScope, $state, $ionicHistory, $cordovaSocialSharing, ImageUploadService, $cordovaCamera, $ionicSideMenuDelegate, $ionicPlatform, $filter, APIs, $window, $ionicPopover) {

  $scope.loginData = {};

  $ionicModal.fromTemplateUrl('templates/login.html', {
    scope: $scope  }).then(function(modal) {
    $scope.loginModal = modal;
  });

  $ionicPopover.fromTemplateUrl('templates/popover.html', {
    scope: $scope,
  }).then(function(popover) {
    $scope.menupopover = popover;
  });

  $scope.openMenuPopover = function($event) {
    $scope.menupopover.show($event);
  };
  $scope.closeMenuPopover = function() {
    $scope.menupopover.hide();
  };

  $rootScope.$on('close:popover', function(){
    console.log('close:popover');
    $scope.menupopover.hide();

    $ionicHistory.nextViewOptions({
      disableBack: true
    });
    //$scope.closeMenuPopover();
    //$scope.fetchPosts();
  });

  $scope.$on('$destroy', function() {
    $scope.menupopover.remove();
  });

  $scope.changeUsername = function(){
    $scope.loginData.username = angular.lowercase($scope.loginData.username);
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  }
  $scope.open = function(item) {
    item.json_metadata = angular.fromJson(item.json_metadata);
    $rootScope.$storage.sitem = item;
    //console.log(item);

    //$state.go('app.single');*/
    $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});
  };

  $rootScope.$on('openComments', function(e, args) {
    $scope.open(args.data);
  });


  $scope.advancedChange = function() {
    $rootScope.log(angular.toJson($scope.loginData.advanced));
    if ($scope.loginData.advanced) {
      $scope.loginData.password = null;
    }
  }
  $scope.closeLogin = function() {
    $scope.loginModal.hide();
  };
  
  $scope.openSignUP = function() {
    $scope.chainurl = $rootScope.$storage.chain=='steem'?'https://steemit.com/create_account':'https://golos.io/create_account';
    window.open($scope.chainurl, '_blank', 'location=yes');
    return false;  
  }
  $scope.openLogin = function() {
    if ($rootScope.$storage.language == 'ru-RU') {
      $scope.loginData.chain = "golos";
    } else {
      $scope.loginData.chain = "steem";
    }
    setTimeout(function() {
      $scope.loginModal.show();
    }, 1);
  };
  $scope.goProfile = function() {
    $state.go("app.profile", {username:$rootScope.$storage.user.username});
    //$ionicSideMenuDelegate.toggleLeft();
  }
  $scope.share = function() {
    var host = "";
    if ($rootScope.$storage.chain == 'steem') {
      host = "https://steemit.com/";
    } else {
      host = "https://golos.io/";
    }
    var link = host+$rootScope.$storage.sitem.category+"/@"+$rootScope.$storage.sitem.author+"/"+$rootScope.$storage.sitem.permlink;
    var message = "Hey! Checkout blog post on Steem "+link;
    var subject = "Via eSteem Mobile";
    var file = null;
    $cordovaSocialSharing.share(message, subject, file, link) // Share via native share sheet
    .then(function(result) {
      // Success!
      $rootScope.log("shared");
    }, function(err) {
      // An error occured. Show a message to the user
      $rootScope.log("not shared");
    });
  }


  $scope.loginChain = function(x){
    console.log(x);
    $scope.loginData.chain = x;

  }
  
  $scope.doLogin = function() {
    $rootScope.log('Doing login');
    if ($scope.loginData.password || $scope.loginData.privatePostingKey) {
      $rootScope.$broadcast('show:loading');
      $scope.loginData.username = $scope.loginData.username.trim();
      console.log('doLogin'+$scope.loginData.username+$scope.loginData.password);
      
      if ($scope.loginData.chain !== $rootScope.$storage.chain) {
        window.Api.close();
        window.Api = null;
        window.steemRPC.Client.close();
        
        var socketUrl = $rootScope.$storage["socket"+$scope.loginData.chain];
        //console.log(socketUrl);

        window.Api = window.steemRPC.Client.get({url:socketUrl}, true);
      }
      setTimeout(function() {
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_accounts", [[$scope.loginData.username]]).then(function(dd){
            dd = dd[0];
            console.log(dd);
            $scope.loginData.id = dd.id;
            $scope.loginData.owner = dd.owner;
            $scope.loginData.active = dd.active;
            $scope.loginData.reputation = dd.reputation;
            $scope.loginData.posting = dd.posting;
            $scope.loginData.memo_key = dd.memo_key;
            $scope.loginData.post_count = dd.post_count;
            $scope.loginData.voting_power = dd.voting_power;
            $scope.loginData.witness_votes = dd.witness_votes;
            $scope.login = new window.ejs.Login();
            $scope.login.setRoles(["posting"]);
            
            var loginSuccess = $scope.login.checkKeys({
                accountName: $scope.loginData.username,
                password: $scope.loginData.password || null,
                auths: {
                    posting: dd.posting.key_auths
                },
                privateKey: $scope.loginData.privatePostingKey || null
              }
            );

            if (!loginSuccess) {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('PASSWORD_INCORRECT'));
            } else {
              $rootScope.$storage.user = $scope.loginData;
              $scope.loginData = {};
              var found = false;

              if ($rootScope.$storage.users.length>0){
                for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
                  var v = $rootScope.$storage.users[i];
                  if (v.username == $rootScope.$storage.user.username && v.chain == $rootScope.$storage.user.chain){
                    found = true;
                  }
                }
              }
              if (found) {

              } else {
                $rootScope.$storage.users.push($rootScope.$storage.user);  
              }
              $rootScope.$storage.mylogin = $scope.login;
              APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, {device: ionic.Platform.platform(), timestamp: $filter('date')(new Date(), 'medium'), appversion: $rootScope.$storage.appversion}).then(function(res){
                $rootScope.$broadcast('hide:loading');
                
                $scope.loginModal.hide();
                $rootScope.$broadcast('refreshLocalUserData');
                  
                if ($rootScope.$storage.chain !== $rootScope.$storage.user.chain) {
                  $rootScope.$storage.chain = $rootScope.$storage.user.chain;  
                  $rootScope.$broadcast('changedChain');
                  $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
                }

                setTimeout(function() {
                  //$window.location.reload(true);
                  $state.go('app.posts',{renew:true},{reload: true});
                  $rootScope.$broadcast('fetchPosts');
                }, 1000);

              });
            }
            /*if(!$scope.$$phase) {
              $scope.$apply();
            }*/
          });
        });
      }, 500);
      
    } else {
      $scope.loginModal.hide();
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_FAIL'));
    }
  };

  $scope.selectAccount = function(user) {
    $rootScope.$storage.user = user;
    $ionicHistory.nextViewOptions({
      disableBack: true
    });
    if ($rootScope.$storage.chain !== user.chain) {
      $scope.data = {};
      $rootScope.$storage.chain = user.chain;  
      $rootScope.$broadcast('changedChain');
    }
    setTimeout(function() {
      $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
    
      $rootScope.$broadcast('refreshLocalUserData');  
    }, 100);
    
    
    setTimeout(function() {
      //$window.location.reload(true);
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
      $state.go('app.posts',{renew:true},{reload: true});
    }, 500);
  }

  $rootScope.$on('refreshLocalUserData', function() {
    $rootScope.log('refreshLocalUserData');
    if ($rootScope.$storage.user && $rootScope.$storage.user.username && $rootScope.$storage.user.chain == $rootScope.$storage.chain) {
      window.Api.initPromise.then(function(response) {
        if (typeof window.Api.database_api === "function") {
          window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
            dd = dd[0];
            if (dd && dd.json_metadata) {
              dd.json_metadata = angular.fromJson(dd.json_metadata);
            }
            angular.merge($rootScope.$storage.user, dd);

            $scope.mcss = ($rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
            
            if (!$scope.$$phase) {
              $scope.$apply();
            }
            if (!$rootScope.$$phase) {
              $rootScope.$apply();
            }
          });
        }
      });
    }
  })

  $scope.openPostModal = function() {
    $state.go('app.posts');
    $rootScope.$broadcast('openPostModal');
  }

  $scope.changeView = function(view) {
    $rootScope.$storage.view = view;
    $rootScope.$broadcast('changeView');
  }
  $scope.changeLight = function(light) {
    $rootScope.$storage.theme = light;
    $rootScope.$broadcast('changeLight');
  }

  $scope.$on("$ionicView.enter", function(){
    $rootScope.$broadcast('refreshLocalUserData');
    $scope.theme = $rootScope.$storage.theme;
  });

  // get app version
  $ionicPlatform.ready(function(){
    if (window.cordova) {
      cordova.getAppVersion.getVersionNumber(function (version) {
        $rootScope.$storage.appversion = version;
      });
    } else {
      $rootScope.$storage.appversion = '1.4.1';
    }
  });

  $scope.logout = function() {
    for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
      var v = $rootScope.$storage.users[i];
      if (v.chain == $rootScope.$storage.user.chain && v.username == $rootScope.$storage.user.username) {
        $rootScope.$storage.users.splice(i,1);
      }
    };
    if ($rootScope.$storage.users.length>1) {
      $rootScope.$storage.user = $rootScope.$storage.users[0];
    } else {
      $rootScope.$storage.user = undefined;
      $rootScope.$storage.user = null;
      $rootScope.$storage.mylogin = undefined;
      $rootScope.$storage.mylogin = null;
    }
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        //$window.location.reload(true);
        $state.go('app.posts',{renew:true},{reload: true});
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      //$window.location.reload(true);
      $state.go('app.posts',{renew:true},{reload: true});
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
  };
  $scope.data = {};
  $ionicModal.fromTemplateUrl('templates/search.html', {
    scope: $scope,
    animation: 'slide-in-down'
  }).then(function(modal) {
    $scope.smodal = modal;
  });

  // Triggered in the login modal to close it
  $scope.closeSmodal = function() {
    $scope.smodal.hide();
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  // Open the login modal
  $scope.openSmodal = function() {
    //if(!$scope.smodal) return;
    $rootScope.$broadcast('close:popover');
    setTimeout(function() {
      $scope.data.type="tag";
      $scope.data.searchResult = [];
      $scope.smodal.show();
    }, 5);
  };
  $scope.clearSearch = function() {
    if ($rootScope.$storage.tag) {
      $rootScope.$storage.tag = undefined;
      $rootScope.$storage.taglimits = undefined;
      $rootScope.$broadcast('close:popover');
      $rootScope.$broadcast('fetchPosts');
    }
  };
  $scope.showMeExtra = function() {
    if ($scope.showExtra) {
      $scope.showExtra = false;
    } else {
      $scope.showExtra = true;
    }
  }
  $scope.search = function() {
    $rootScope.log('Doing search '+$scope.data.search);
    $scope.data.search = angular.lowercase($scope.data.search);
    setTimeout(function() {
      if ($scope.data.search.length > 1) {
        if ($scope.data.type == "tag"){
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("get_trending_tags", [$scope.data.search, 15]).then(function(result){
              var ee = [];
              //console.log(result);
              /*if (result){
                var ll = result.length;
                for (var i = ll - 1; i >= 0; i--) {
                  if (result[i].name.indexOf($scope.data.search) > -1){
                    ee.push(result[i]);
                  }
                }
                $scope.data.searchResult = ee;
              }*/
              $scope.data.searchResult = result;

              if (!$scope.$$phase) {
                $scope.$apply();
              }
            });
          });
        }
        if ($scope.data.type == "user"){
          var ee = [];
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("lookup_accounts", [$scope.data.search, 15]).then(function(result){
              if (result){
                $scope.data.searchResult = result;
              }

                if (!$scope.$$phase) {
                  $scope.$apply();
                }
            });
          });
        }

      }
    }, 5);

  };
  $scope.typechange = function() {
    $scope.data.searchResult = undefined;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $rootScope.log("changing search type");
  }
  $scope.openTag = function(xx, yy) {
    $rootScope.log("opening tag "+xx);
    $rootScope.$storage.tag = xx;
    $rootScope.$storage.filter = 'created';
    $rootScope.$storage.taglimits = yy;
    if ($scope.smodal.isShown()){
      $scope.closeSmodal();
    }
    $rootScope.$broadcast('close:popover');
    //$rootScope.$broadcast('filter:change');
    $state.go("app.posts", {tags: xx});
  };
  $scope.openUser = function(xy) {
    $rootScope.log("opening user "+xy);
    $scope.closeSmodal();
    $rootScope.$broadcast('close:popover');
    $state.go("app.profile", {username: xy});
  };
  $scope.testfunction = function() {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_account_history", [$rootScope.$storage.user.username, -1, 25]).then(function(response){
        $rootScope.log(angular.toJson(response));
      });
    });
  }

})

app.controller('SendCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $filter, $q, $timeout, $cordovaBarcodeScanner, $ionicPlatform, $ionicModal, APIs) {

  if ($rootScope.$storage.chain == "steem") {
    $scope.data = {types: [{type: "steem", name:"Steem", id:1},{type: "sbd", name:"Steem Dollar", id:2}, {type: "sp", name:"Steem Power", id:3}], type: "steem", amount: 0.001, etypes: [{type: "approve", name: $filter('translate')("APPROVE"), id:1},{type: "dispute", name: $filter('translate')("DISPUTE"), id:2},{type: "release", name: $filter('translate')("RELEASE"), id:3}]};
  } else {
    $scope.data = {types: [{type: "golos", name: "", id:1},{type: "gbg", name:"", id:2}, {type: "golosp", name:" ", id:3}], type: "golos", amount: 0.001, etypes: [{type: "approve", name: $filter('translate')("APPROVE"), id:1},{type: "dispute", name: $filter('translate')("DISPUTE"), id:2},{type: "release", name: $filter('translate')("RELEASE"), id:3}]};
  }
  $scope.ttype = 'transfer';
  $scope.changeTransfer = function(type){
    $scope.ttype = type;
    $scope.data.advanced = false;
  }
  $ionicModal.fromTemplateUrl('my-modal.html', {
    scope: $scope,
    animation: 'slide-in-up'
  }).then(function(modal) {
    $scope.modal = modal;
  });
  $scope.openUModal = function() {
    $scope.modal.show();
  };
  $scope.closeUModal = function() {
    $scope.modal.hide();
  };
  // Cleanup the modal when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.modal.remove();
  });
  // Execute action on hide modal
  $scope.$on('modal.hidden', function() {
    // Execute action
  });
  $scope.showLiquid = function (token) {
    return token.type !== $filter('lowercase')($rootScope.$storage.platformpunit);
  }
  $scope.searchUser = function(query) {
    return window.Api.initPromise.then(function(response) {
      return window.Api.database_api().exec("lookup_accounts", [query, 15]).then(function(response){
        return response;
      });
    });
  }
  $scope.selectAgent = function(agent) {
    $scope.data.agent = agent;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.closeUModal();
  }
  $scope.getUserAgent = function(query){
    query = angular.lowercase(query);
    $scope.res = [];
    if (query) {
      window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("lookup_account_names", [[query]]).then(function(response){
        //console.log(response)
        var dd = response[0];
        if (dd && dd.json_metadata) {
          var vv = angular.fromJson(dd.json_metadata);
          if (vv.escrow) {
            console.log('escrow');
            $scope.res.push({name: query, escrow: vv.escrow});
          } else {
            console.log('noescrow');
            $scope.res.push({name: query, escrow: {terms: "-", fees: {"STEEM": 0.001, "SBD": 0.001, "GBG": 0.001, "GOLOS": 0.001}} });
          }
        }
      });
      });
      setTimeout(function() {
        if (query && $scope.res) {
          $scope.data.searchResult = $scope.res;
        } else {
          $scope.data.searchResult = [];  
        }
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      }, 500);   
    }
  }
  $scope.changeUsername = function(typed) {
    $rootScope.log('searching');
    $scope.data.username = angular.lowercase($scope.data.username);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("lookup_account_names", [[$scope.data.username]]).then(function(response){
        $scope.users = response[0];
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.qrScan = function() {
    $ionicPlatform.ready(function() {
      $cordovaBarcodeScanner.scan({
          "preferFrontCamera" : false, // iOS and Android
          "showFlipCameraButton" : false, // iOS and Android
          "prompt" : $filter('translate')('QR_TEXT'), // supported on Android only
          "formats" : "QR_CODE" // default: all but PDF_417 and RSS_EXPANDED
          //"orientation" : "landscape" // Android only (portrait|landscape), default unset so it rotates with the device
        }).then(function(barcodeData) {
        //alert(barcodeData);
        if (barcodeData.text.indexOf('?amount')>-1) {
          //steem dollar:blocktrades?amount=12.080

          $scope.data.username = barcodeData.text.split(':')[1].split('?')[0].trim();
          $scope.data.amount = Number(barcodeData.text.split('=')[1]);
          if (barcodeData.text.split(':')[0]==='steem dollar') {
            $scope.data.type = 'sbd';
          }
          if (barcodeData.text.split(':')[0]==='steem') {
            $scope.data.type = 'steem';
          }
          if (barcodeData.text.split(':')[0]==='steem power') {
            $scope.data.type = 'sp';
          }

        } else {
          $scope.data.username = barcodeData.text;
        }
        $scope.changeUsername();
      }, function(error) {
        $rootScope.showMessage('Error',angular.toJson(error));
      });
    });
  };
  $scope.advancedEChange = function(){
    console.log('advancedEChange', $scope.data.advanced);
    $scope.data.etype = "";
    $scope.escrow = {};
    if (!$scope.$$phase){
      $scope.$apply();
    }
  }
  $scope.actionEChange = function(){
    console.log('actionEChange', $scope.data.etype);
    if (!$scope.$$phase){
      $scope.$apply();
    }
  }

  $scope.escrowAction = function(){
    console.log($scope.data.etype);
    if ($scope.data.etype && $scope.escrow.escrow_id) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('CONFIRMATION'),
        template: ""
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          $rootScope.$broadcast('show:loading');

          var mylogin = new window.ejs.Login();
          mylogin.setRoles(["active"]);
          var loginSuccesss = mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password,
              auths: {
                active: $rootScope.$storage.user.active.key_auths
              },
              privateKey: $rootScope.$storage.user.privateActiveKey || null
            }
          );
          if (loginSuccesss) {
            var tre = new window.ejs.TransactionBuilder();
            if ($scope.data.etype == "approve") {
              tre.add_type_operation("escrow_approve", { 
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id,
                approve: true
              });
            } else if ($scope.data.etype == "dispute") {
              tre.add_type_operation("escrow_dispute", { 
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id
              });
            } else if ($scope.data.etype == "release") {
              tre.add_type_operation("escrow_release", {
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id,
                receiver: $scope.escrow.receiver,
                sbd_amount: $scope.escrow.sbd_amount+" "+angular.uppercase($rootScope.$storage.platformdunit),
                steem_amount: $scope.escrow.steem_amount+" "+angular.uppercase($rootScope.$storage.platformlunit) 
              });
            }
            
            localStorage.error = 0;
            tre.process_transaction(mylogin, null, true);  

            setTimeout(function() {
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
              } else {
                $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                  $scope.data.type=$rootScope.$storage.chain;
                  $scope.data.amount= 0.001;
                });
              }
            }, 3000);
          }
        }
      });
    } 
  }
  $scope.escrow = {};
  $scope.searchEscrowID = function(id){
    if (id.length>3){
      APIs.searchEscrow(id).then(function(res){
        //console.log(res.data);
        $scope.escrow = res.data[0];
        $scope.escrow.json_meta = angular.fromJson($scope.escrow.json_meta);
      });  
    }
  }
  $scope.transfer = function (type) {
    if ($rootScope.$storage.user) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('ACTIVE_KEY_REQUIRED_TEXT'));
      } else {
        if ($scope.data.type === 'sbd' || $scope.data.type === 'gbg') {
          if ($scope.data.amount > Number($scope.balance.sbd_balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if ($scope.data.type === 'sp' || $scope.data.type === 'steem' || $scope.data.type === 'golos' || $scope.data.type === 'golosp') {
          if ($scope.data.amount > Number($scope.balance.balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if (!$scope.users || $scope.users.name !== $scope.data.username) {
          $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('NONEXIST_USER'));
        } else {
          $scope.okuser = true;
        }
        if ($scope.okbalance && $scope.okuser) {
          var confirmPopup = $ionicPopup.confirm({
            title: $filter('translate')('CONFIRMATION'),
            template: $filter('translate')('TRANSFER_TEXT')
          });

          confirmPopup.then(function(res) {
            if(res) {
              $rootScope.log('You are sure');
              $rootScope.$broadcast('show:loading');
              
              if (type == 'transfer') {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  //transfer
                  if ($scope.data.type !== 'sp' && $scope.data.type !== 'golosp') {
                    var tt = $filter('number')($scope.data.amount, 3) +" "+angular.uppercase($scope.data.type);
                    tr.add_type_operation("transfer", {
                      from: $rootScope.$storage.user.username,
                      to: $scope.data.username,
                      amount: tt,
                      memo: $scope.data.memo || ""
                    });
                    localStorage.error = 0;
                    tr.process_transaction($scope.mylogin, null, true);
                    setTimeout(function() {
                      if (localStorage.error == 1) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                      } else {
                        $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                          $scope.data.type=$rootScope.$storage.chain;
                          $scope.data.amount= 0.001;
                        });
                      }
                    }, 3000);
                  } else {
                    var tt = $filter('number')($scope.data.amount, 3) + " "+$filter('uppercase')($rootScope.$storage.chain);
                    tr.add_type_operation("transfer_to_vesting", {
                      from: $rootScope.$storage.user.username,
                      to: $scope.data.username,
                      amount: tt
                    });
                    localStorage.error = 0;
                    tr.process_transaction($scope.mylogin, null, true);
                    setTimeout(function() {
                      if (localStorage.error == 1) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                      } else {
                        $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                          $scope.data.type=$rootScope.$storage.chain;
                          $scope.data.amount= 0.001;
                        });
                      }
                    }, 3000);
                  }
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              }

              if (type == 'escrow') {
                console.log($rootScope.$storage.user.active.key_auths, $rootScope.$storage.user.password, $rootScope.$storage.user.privateActiveKey);

                var mylogin = new window.ejs.Login();
                mylogin.setRoles(["active"]);
                var loginSuccesss = mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccesss) {
                  var tre = new window.ejs.TransactionBuilder();
                  var escrow_id = (new Date().getTime())>>>0;
                  var tt = $filter('number')($scope.data.amount, 3) +" "+angular.uppercase($scope.data.type);
                  var sbd = ($scope.data.type=='sbd'||$scope.data.type=='gbg')?tt:("0.000 "+angular.uppercase($rootScope.$storage.platformdunit));
                  var stem = ($scope.data.type=='steem'||$scope.data.type=='golos')?tt:("0.000 "+angular.uppercase($rootScope.$storage.platformlunit));
                  var fe = $scope.data.agent.escrow.fees[angular.uppercase($scope.data.type)]+" "+angular.uppercase($scope.data.type);
                  var rt = new Date($scope.data.ratification);
                  var et = new Date($scope.data.expiration);
                  var jn = {
                    terms: $scope.data.agent.escrow.terms, 
                    memo: ($scope.data.memo||"")+" "+escrow_id
                  }
                  tre.add_type_operation("escrow_transfer", { 
                    from: $rootScope.$storage.user.username, 
                    to: $scope.data.username, 
                    agent: $scope.data.agent.name, 
                    escrow_id: escrow_id, 
                    sbd_amount: sbd, 
                    steem_amount: stem, 
                    fee: fe, 
                    ratification_deadline: rt, 
                    escrow_expiration: et, 
                    json_meta: angular.toJson(jn) 
                  });

                  localStorage.error = 0;

                  //tre.process_transaction($scope.mylogin, null, true);
                  //mylogin.signTransaction(tre);
                  
                  tre.process_transaction(mylogin, null, true);  
                  
                  
                  /*tre.finalize().then(function() {
                      tre.sign();
                      console.log('signed');
                      tre.broadcast(true);
                      console.log('broadcasted');
                  });*/


                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
                    } else {
                      $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED') + " "+$filter('translate')('ESCROW')+" "+$filter('translate')('ID')+": "+escrow_id).then(function(){
                        $scope.data.type=$rootScope.$storage.chain;
                        $scope.data.amount= 0.001;
                      });
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              }
              $rootScope.$broadcast('hide:loading');
             } else {
               $rootScope.log('You are not sure');
             }
          });
        }
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  };


  $scope.refresh = function() {
    $rootScope.$broadcast('show:loading');
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        console.log($scope.balance);
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
    $rootScope.$broadcast('hide:loading');
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
  });

});
app.controller('PostsCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $ionicScrollDelegate, $ionicModal, $filter, $stateParams, $ionicSlideBoxDelegate, $ionicActionSheet, $ionicPlatform, $cordovaCamera, ImageUploadService, $filter, $ionicHistory, $timeout, APIs, $translate) {

  var formatToPercentage = function (value) {
    return value + '%';
  };

  $scope.pslider = {
    value: $rootScope.$storage.voteWeight/100,
    options: {
      floor: 1,
      ceil: 100,
      hideLimitLabels: true
      //translate: formatToPercentage,
      //showSelectionBar: true,
    }
  };

  $ionicPopover.fromTemplateUrl('popoverSlider.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSlider.show($event);
  };
  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.votePostS = function() {
    $scope.tooltipSlider.hide();
    $scope.votePost($scope.votingPost);
  }
  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }


  $rootScope.$on('filter:change', function() {
    //$rootScope.$broadcast('show:loading');
    $rootScope.log($rootScope.$storage.filter);
    var type = $rootScope.$storage.filter || "trending";
    var tag = $rootScope.$storage.tag || "";
    console.log(type, $scope.limit, tag);
    $scope.fetchPosts(type, $scope.limit, tag);
  });

  $scope.filterChanged = function(t) {
    var fil = $scope.mymenu[t].custom;
    $rootScope.$storage.filter = fil;
    for (var i = 0, len = $scope.mymenu.length; i < len; i++) {
      var v = $scope.mymenu[i];
      if (v.custom == fil) {
        $rootScope.$storage.filterName = v.text;
      }
    }
    $scope.data = [];
    $scope.error = false;
    $rootScope.$broadcast('filter:change');
  }
  $scope.showFilter = function() {
    var filterSheet = $ionicActionSheet.show({
     buttons: $scope.mymenu,
     titleText: $filter('translate')('SORT_POST_BY'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.filterChanged(index);
        return true;
     }
    });
  }

  $ionicPopover.fromTemplateUrl('popoverT.html', {
      scope: $scope
  }).then(function(popover) {
    $scope.tooltip = popover;
  });

  $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltip.show($event);
  };

  $scope.closeTooltip = function() {
      $scope.tooltip.hide();
  };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
      $scope.tooltipText = undefined;
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $ionicModal.fromTemplateUrl('templates/story.html', { scope: $scope  }).then(function(modal) {
      $scope.modalp = modal;
  });
  $scope.lastFocused;

  $rootScope.$on('openPostModal', function() {

    $rootScope.$broadcast('close:popover');

    $scope.spost = $rootScope.$storage.spost || $scope.spost;

    

    $timeout(function(){
      if (!$scope.spost.operation_type) {
        $scope.spost.operation_type = 'default';
      }
      $scope.tagsChange();

      $scope.modalp.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        //console.log(document);
      });*/
    }, 10);
    //$scope.modalp.show();
  });

  $rootScope.$on('closePostModal', function() {
    $scope.modalp.hide();
  });

  $scope.closePostModal = function() {
    //$scope.$broadcast('close:popover');
    $scope.modalp.hide();
  };


  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    //console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }


  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};

    if (type == 0 || type == 1) {
      options = {
        quality: 50,
        destinationType: Camera.DestinationType.FILE_URI,
        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
        allowEdit: (type===0)?true:false,
        encodingType: Camera.EncodingType.JPEG,
        popoverOptions: CameraPopoverOptions,
        saveToPhotoAlbum: false
        //correctOrientation:true
      };
      $cordovaCamera.getPicture(options).then(function(imageData) {
        setTimeout(function() {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var final = " ![image](" + url + ")";
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, 10);
      }, function(err) {
        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
      });
    } else if (type == 2){
      $ionicPopup.prompt({
        title: $filter('translate')('SET_URL'),
        template: $filter('translate')('DIRECT_LINK_PICTURE'),
        inputType: 'text',
        inputPlaceholder: 'http://example.com/image.jpg'
      }).then(function(res) {
        $rootScope.log('Your url is' + res);
        if (res) {
          var url = res.trim();
          var final = " ![image](" + url + ")";
          /*if ($scope.spost.body) {
            $scope.spost.body += final;
          } else {
            $scope.spost.body = final;
          }*/
          $scope.insertText(final);
        }
      });
    } else {
      $scope.gallery = [];
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        var imgs = res.data;
        if (imgs.length>0){
          $scope.showgallery = true;
          $scope.gallery.images = imgs;
        } else {
          $scope.showgallery = false;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
          console.log('no images available')
        }
      });
    }
  };
  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $rootScope.$broadcast('closePostModal');
    $state.go('app.images');
  }
  function slug(text) {
    return getSlug(text, {truncate: 128});
  };
  function createPermlink(title) {
    var permlink;
    var t = new Date();
    var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
    if (title && title.trim() !== '') {
      var s = slug(title);
      permlink = s.toString()+"-"+timeformat;
      if(permlink.length > 255) {
        // STEEMIT_MAX_PERMLINK_LENGTH
        permlink = permlink.substring(permlink.length - 255, permlink.length)
      }
      // only letters numbers and dashes shall survive
      permlink = permlink.toLowerCase().replace(/[^a-z0-9-]+/g, '')
      return permlink;
    }
  };
  //$scope.operation_type = 'default';
  $scope.spost = {};
  $scope.tagsChange = function() {
    $rootScope.log("tagsChange");
    $scope.spost.tags = $filter('lowercase')($scope.spost.tags);
    $scope.spost.category = $scope.spost.tags?$scope.spost.tags.split(" "):[];
    for (var i = 0, len = $scope.spost.category.length; i < len; i++) {
      var v = $scope.spost.category[i];
      if(/^[-]/.test(v)) {
        v = 'ru--' + $filter('detransliterate')(v, true);
        $scope.spost.category[i] = v;
      }
    }

    //console.log($scope.spost.category);
    if ($scope.spost.category.length > 5) {
      $scope.disableBtn = true;
    } else {
      $scope.disableBtn = false;
    }
  }
  $scope.contentChanged = function (editor, html, text) {
    //console.log($scope.spost.body);
    //console.log('editor: ', editor, 'html: ', html, 'text:', text);
  };

  $scope.submitStory = function() {
    //console.log($scope.spost.body);
    $scope.tagsChange();
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($rootScope.$storage.user) {
      $scope.mylogin = new window.ejs.Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window.ejs.TransactionBuilder();
        var permlink = createPermlink($scope.spost.title);
        var json = $filter("metadata")($scope.spost.body);
        angular.merge(json, {tags: $scope.spost.category, app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });

        if (!$scope.spost.operation_type) {
          $scope.spost.operation_type = 'default';
        }
        if ($scope.spost.operation_type !== 'default') {
          //console.log('NOT Default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            max_accepted_payout: $scope.spost.operation_type==='sp'?"1000000.000 "+$rootScope.$storage.platformdunit:"0.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: $scope.spost.operation_type==='sp'?0:10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
        } else {
          //console.log('default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: 10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
        }

        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();
            $rootScope.$broadcast('closePostModal');

            //$scope.menupopover.hide();
            $rootScope.$broadcast('close:popover');
            $scope.spost = {};
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closeMenuPopover();
            $state.go("app.profile", {username: $rootScope.$storage.user.username});
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.savePost = function() {
    console.log($scope.modalp);
    $rootScope.$storage.spost = $scope.spost;
    //adddraft
    var dr = {title:$scope.spost.title, body: $scope.spost.body, tags: $scope.spost.tags, post_type: $scope.spost.operation_type};
    APIs.addDraft($rootScope.$storage.user.username, dr).then(function(res){
      console.log(res.data);
      //$scope.drafts = res.data;
    });
    $rootScope.$broadcast('closePostModal');
    $rootScope.$broadcast('close:popover');
    $scope.modalp.hide();
    $rootScope.showMessage($filter('translate')('SAVED'), $filter('translate')('POST_LATER'));
  }
  $scope.clearPost = function() {
    $rootScope.$storage.spost = {};
    $scope.spost = {};
    $rootScope.showMessage($filter('translate')('CLEARED'), $filter('translate')('POST'));
  }


  $rootScope.$on('fetchPosts', function(){
    $scope.fetchPosts();
  });

  $rootScope.$on('fetchContent', function(event, args) {
    var post = args.any;
    //console.log(post);
    $scope.fetchContent(post.author, post.permlink);
  });

  $scope.votePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'fetchContent');
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  $scope.downvotePost = function(post) {

    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'fetchContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });

  };

  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'fetchContent');
  };


  $rootScope.$on("user:logout", function(){
    $scope.fetchPosts();
    $rootScope.$broadcast('filter:change');
  });

  $scope.loadMore = function() {
    //$rootScope.$broadcast('show:loading');
    $scope.limit += 5;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    //}
  };
  $scope.refresh = function(){
    $scope.limit = 10;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    $scope.$broadcast('scroll.refreshComplete');
  }

  $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
    console.log('stateChangeSuccess', $stateParams.renew);
    if (from.name == 'app.posts' && to.name == 'app.post') {

    } else {
      if (from.name == 'app.post' && to.name == 'app.posts') {
        $rootScope.$storage.sitem = null;
      }
      if (from.name !== 'app.post') {
        if ($stateParams.renew) {
          $scope.data = null;
          $scope.data = [];
        }
        $scope.loadMore();
      }
    }
  });

  $scope.moreDataCanBeLoaded = function(){
    return !$scope.error;
  }

  $rootScope.$on('changeView', function(){
    //$scope.menupopover.hide();
    //$rootScope.$broadcast('close:popover');
    $scope.menupopover.hide();
    if (!$scope.$$phase){
      $scope.$apply();
    }
    if ($rootScope.$storage.view === 'card') {
      for (var i = 0, len = $scope.data.length; i < len; i++) {
        var v = $scope.data[i];
        v.json_metadata = angular.fromJson(v.json_metadata);
      };
    }
  });

  $rootScope.$on('changeLight', function(){
    $scope.menupopover.hide();
    //$rootScope.$broadcast('close:popover');
    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  function arrayObjectIndexOf(myArray, searchTerm, property) {
    var llen = myArray.length;
    for(var i = 0; i < llen; i++) {
        if (myArray[i][property] === searchTerm) return i;
    }
    return -1;
  }
  $scope.data = [];
  $scope.tempData = [];

  $scope.dataChanged = function(newValue) {
    if (newValue) {
      var lenn = newValue.length;
      var user = $rootScope.$storage.user || null;
      var view = $rootScope.$storage.view;

      if (user){
        for (var i = 0; i < lenn; i++) {
          if (newValue[i] && newValue[i].active_votes) {
            var len = newValue[i].active_votes.length-1;
            for (var j = len; j >= 0; j--) {
              if (newValue[i].active_votes[j].voter === user.username) {
                if (newValue[i].active_votes[j].percent > 0) {
                  newValue[i].upvoted = true;
                } else if (newValue[i].active_votes[j].percent < 0) {
                  newValue[i].downvoted = true;
                } else {
                  newValue[i].downvoted = false;
                  newValue[i].upvoted = false;
                }
              }
            }
          }
          if (view === 'card') {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      } else {
        if (view === 'card') {
          for (var i = 0; i < lenn; i++) {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      }
      return newValue;
    }
  }

  $scope.fetchContent = function(author, permlink) {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        for (var i = 0, len = $scope.data.length; i < len; i++) {
          var v = $scope.data[i];
          if (v.permlink === result.permlink) {
            $scope.data[i] = result;
          }
        }
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.length; i++) {
      if ($scope.data[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.fetchPosts = function(type, limit, tag) {
    type = type || $rootScope.$storage.filter || "trending";
    tag = tag || $rootScope.$storage.tag || "";
    limit = 10;//limit || $scope.limit || 10;

    var params = {};

    if (type === "feed" && $rootScope.$storage.user) {
      params = {tag: $rootScope.$storage.user.username, limit: limit, filter_tags:[]};
    } else {
      if ($rootScope.$storage.filter === "feed") {
        $rootScope.$storage.filter = "trending";
        type = "trending";
      }
      params = {tag: tag, limit: limit, filter_tags:[]};
    }
    if ($scope.data && $scope.data.length>0) {
      params.start_author = $scope.data[$scope.data.length-1].author;
      params.start_permlink = $scope.data[$scope.data.length-1].permlink;
    }
    if ($scope.error) {
      //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
      $scope.$broadcast('scroll.infiniteScrollComplete');
      $rootScope.$broadcast('hide:loading');
    } else {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("fetching..."+type+" "+limit+" "+tag);
        if (typeof window.Api.database_api === "function") {
          /*window.Api.database_api().exec("get_state", ["/"+type]).then(function(response){
            console.log(response);
          });*/
          if ($rootScope.$storage.chain == 'golos' && type == 'feed') {
            params.select_authors = [$rootScope.$storage.user.username]; 
            delete params.tags; 
          }
          window.Api.database_api().exec("get_discussions_by_"+type, [params]).then(function(response){
            $rootScope.log(response);
            if (response.length <= 1) {
              $scope.error = true;
            }
            if (response) {
              for (var i = 0; i < response.length; i++) {
                response[i].json_metadata = response[i].json_metadata?angular.fromJson(response[i].json_metadata):response[i].json_metadata;
                var permlink = response[i].permlink;
                if (!$scope.ifExists(permlink)) {
                  var user = $rootScope.$storage.user || undefined;
                  if (user) {
                    //console.log('exist');
                    if (response[i] && response[i].active_votes) {
                      var len = response[i].active_votes.length-1;
                      for (var j = 0; j < len; j++) {
                        if (response[i].active_votes[j].voter === user.username) {
                          if (response[i].active_votes[j].percent > 0) {
                            response[i].upvoted = true;
                          } else if (response[i].active_votes[j].percent < 0) {
                            response[i].downvoted = true;
                          } else {
                            response[i].downvoted = false;
                            response[i].upvoted = false;
                          }
                        }
                      }
                    }
                  }
                  //if (!/bm.*/.test(response[i].category)) {
                    $scope.data.push(response[i]);
                  //}
                }
              }
            }

            if (!$scope.$$phase) {
              $scope.$apply();
            }
            //console.log($scope.data.length);
            $scope.$broadcast('scroll.infiniteScrollComplete');
            $rootScope.$broadcast('hide:loading');
          });
        }
      });
    }
  };

  $scope.$on('$ionicView.loaded', function(){
    $scope.limit = 10;
    //$rootScope.$broadcast('show:loading');
    if (!$rootScope.$storage["socket"+$rootScope.$storage.chain]) {
      $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    }
    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'card';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (window.Api) {
      /*if (!angular.isDefined($rootScope.timeint)) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          $rootScope.timeint = $interval(function(){
            window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
              $rootScope.log("get_dynamic_global_properties "+ response.head_block_number);
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["posting"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        posting: $rootScope.$storage.user.posting.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privatePostingKey || null
                  }
                );
                $rootScope.log("login "+loginSuccess);
              }
            });
          }, 15000);
          $rootScope.$broadcast('fetchPosts');
        });
      }*/
    }

    /*setTimeout(function() {
      $ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();
    }, 10);*/
  });
  
  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.theme = $rootScope.$storage.theme;
    if ($stateParams.tags) {
      $rootScope.$storage.tag = $stateParams.tags;
    }

    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use((language.value).split("-")[0]).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  $rootScope.$storage.language = language.value.split('-')[0];
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }

    $scope.activeMenu = $rootScope.$storage.filter || "trending";
    $scope.mymenu = $rootScope.$storage.user ? [{text: $filter('translate')('FEED'), custom:'feed'}, {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}] : [ {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}];
    for (var i = 0, len = $scope.mymenu.length; i < len; i++) {
      var v = $scope.mymenu[i];
      if (v.custom === $rootScope.$storage.filter) {
        $rootScope.$storage.filterName = v.text;
      }
    }

  });

})

app.controller('PostCtrl', function($scope, $stateParams, $rootScope, $interval, $ionicScrollDelegate, $ionicModal, $filter, $ionicActionSheet, $cordovaCamera, $ionicPopup, ImageUploadService, $ionicPlatform, $ionicSlideBoxDelegate, $ionicPopover, $filter, $state, APIs, $ionicHistory, $ionicPosition) {
  $scope.post = $rootScope.$storage.sitem;
  $scope.data = {};
  $scope.spost = {};
  $scope.replying = false;

  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSliderr = popover;
  });
  
  $scope.openSliderr = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSliderr.show($event);
  };
  $scope.votePostS = function() {
    $scope.tooltipSliderr.hide();
    $scope.upvotePost($scope.votingPost);
  }
  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  };

  $scope.closeSliderr = function() {
    $scope.tooltipSliderr.hide();
  };

  $scope.isBookmarked = function() {
    var bookm = $rootScope.$storage.bookmark || undefined;
    if (bookm && $rootScope.$storage.sitem) {
      var len = bookm.length;
      for (var i = 0; i < len; i++) {
        if (bookm[i] && bookm[i].permlink === $rootScope.$storage.sitem.permlink) {
          return true;
        }
      }
    } else {
      return false;
    }
  };
  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }
  $scope.bookmark = function() {
    var book = $rootScope.$storage.bookmark;
    if ($scope.isBookmarked()) {
      var len = book.length;
      var id = undefined;
      for (var i = 0; i < len; i++) {
        if (book[i].permlink === $rootScope.$storage.sitem.permlink) {
          id = book[i]._id;
          book.splice(i, 1);
        }
      }
      if (id){
        APIs.removeBookmark(id,$rootScope.$storage.user.username).then(function(res){
          $rootScope.$storage.bookmark = book;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
        });
      }
    } else {
      if (book) {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark.push(oo);
        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      } else {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark = [oo];

        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      }
      //$rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
    }
  };

  $scope.lastFocused;


  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }

  $ionicPopover.fromTemplateUrl('popoverTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });


  $scope.isImages = function() {
    if ($rootScope.$storage.sitem) {
      var len = $rootScope.$storage.sitem.json_metadata.image?$rootScope.$storage.sitem.json_metadata.image.length:0;
      if (len > 0) {
        $scope.images = $rootScope.$storage.sitem.json_metadata.image;
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };
  $scope.zoomMin = 1;
  $scope.showImages = function(index) {
    $scope.activeSlide = index;
    $rootScope.log(angular.toJson($scope.images[index]));
    $scope.showGalleryModal('templates/gallery_images.html');
  };

  $scope.showGalleryModal = function(templateUrl) {
    $ionicModal.fromTemplateUrl(templateUrl, {
      scope: $scope
    }).then(function(modal) {
      $scope.modalg = modal;
      $scope.modalg.show();
    });
  }

  $scope.closeGalleryModal = function() {
    $scope.modalg.hide();
    $scope.modalg.remove()
  };

  $scope.updateSlideStatus = function(slide) {
    var zoomFactor = $ionicScrollDelegate.$getByHandle('scrollHandle' + slide).getScrollPosition().zoom;
    if (zoomFactor == $scope.zoomMin) {
      $ionicSlideBoxDelegate.enableSlide(true);
    } else {
      $ionicSlideBoxDelegate.enableSlide(false);
    }
  };

  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};
    if ($scope.edit) {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.spost.body) {
                $scope.spost.body += final;
              } else {
                $scope.spost.body = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    } else {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.data.comment) {
                $scope.data.comment += final;
              } else {
                $scope.data.comment = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.data.comment) {
              $scope.data.comment += final;
            } else {
              $scope.data.comment = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    }
  };

  $ionicModal.fromTemplateUrl('templates/story.html', {
    scope: $scope  }).then(function(modal) {
    $scope.pmodal = modal;
  });
  $scope.openPostModal = function() {
    //if(!$scope.pmodal) return;
    setTimeout(function() {
      $scope.pmodal.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        console.log(document);
      });*/
    }, 10);
  };

  $rootScope.$on('closePostModal', function(){
    $scope.pmodal.hide();
  });

  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $scope.modal.hide();
    $state.go('app.images');
  }
  var dmp = new window.diff_match_patch();

  function createPatch(text1, text2) {
      if (!text1 && text1 === '') return undefined;
      var patches = dmp.patch_make(text1, text2);
      var patch = dmp.patch_toText(patches);
      return patch;
  }
  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  $scope.deletePost = function(xx) {
    $rootScope.log('delete post '+ angular.toJson(xx));
    var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('DELETE_COMMENT')
    });
    confirmPopup.then(function(res) {
        if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["posting"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();

                tr.add_type_operation("delete_comment", {
                  author: xx.author,
                  permlink: xx.permlink
                });
                //$rootScope.log(my_pubkeys);
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                    $state.go('app.posts');
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.$broadcast('hide:loading');
              }
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
        } else {
          $rootScope.log('You are not sure');
        }
    });
  }
  $scope.edit = false;
  $scope.editPost = function(xx) {
    $scope.edit = true;
    $scope.openPostModal();
    angular.element("textarea").focus(function() {
      $scope.lastFocused = document.activeElement;
      console.log(document);
    });
    setTimeout(function() {
      if (!$scope.spost.body) {
        $scope.spost = xx;
        $scope.patchbody = xx.body;
      }
      $scope.spost.tags = angular.fromJson(xx.json_metadata).tags.join().replace(/\,/g,' ');
    }, 10);
  }

  $scope.submitStory = function() {
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($scope.edit) {
      var patch = createPatch($scope.patchbody, $scope.spost.body)
      // Putting body into buffer will expand Unicode characters into their true length
      if (patch && patch.length < new Buffer($scope.spost.body, 'utf-8').length) {
        $scope.spost.body2 = patch;
      }
      //$rootScope.log(patch);
    } else {
      $scope.spost.body2 = undefined;
    }

    if ($rootScope.$storage.user) {
      $scope.mylogin = new window.ejs.Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window.ejs.TransactionBuilder();
        var permlink = $scope.spost.permlink;
        var jjson = $filter("metadata")($scope.spost.body);
        //console.log(jjson);
        //$scope.spost.tags = $filter('lowercase')($scope.spost.tags);
        var json = angular.merge(jjson, {tags: $scope.spost.tags.split(" "), app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });
        //console.log(json);
        tr.add_type_operation("comment", {
          parent_author: "",
          parent_permlink: $scope.spost.parent_permlink,
          author: $rootScope.$storage.user.username,
          permlink: $scope.spost.permlink,
          title: $scope.spost.title,
          body: $scope.spost.body2 || $scope.spost.body,
          json_metadata: angular.toJson(json)
        });
        tr.add_type_operation("comment_options", {
          allow_curation_rewards: true,
          allow_votes: true,
          author: $rootScope.$storage.user.username,
          permlink: $scope.spost.permlink,
          max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
          percent_steem_dollars: 10000,
          extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
        });
        //$rootScope.log(my_pubkeys);
        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();

            $rootScope.$broadcast('closePostModal');

            setTimeout(function() {
              $scope.spost = {};
              $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closePostPopover();
              $state.go("app.profile", {username: $rootScope.$storage.user.username});
            }, 1);
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.addImage = function(url) {
    $scope.data.comment += ' ![image]('+url+') ';
  }
  $scope.reply = function (xx) {
    //$rootScope.log(xx);
    if (!$scope.$$phase){
      $scope.$apply();
    }
    window.Api.initPromise.then(function(response) {
      $rootScope.$broadcast('show:loading');
      if ($rootScope.$storage.user) {
        $scope.mylogin = new window.ejs.Login();
        $scope.mylogin.setRoles(["posting"]);
        var loginSuccess = $scope.mylogin.checkKeys({
            accountName: $rootScope.$storage.user.username,
            password: $rootScope.$storage.user.password || null,
            auths: {
                posting: $rootScope.$storage.user.posting.key_auths
            },
            privateKey: $rootScope.$storage.user.privatePostingKey || null
          }
        );
        if (loginSuccess) {
          var tr = new window.ejs.TransactionBuilder();
          var t = new Date();
          var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
          var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || ["esteem"] , app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
          tr.add_type_operation("comment", {
            parent_author: $scope.post.author,
            parent_permlink: $scope.post.permlink,
            author: $rootScope.$storage.user.username,
            permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
            title: "",
            body: $scope.data.comment,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,  
            max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: 10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
          localStorage.error = 0;
          tr.process_transaction($scope.mylogin, null, true);
          $scope.replying = false;
          setTimeout(function() {
            $rootScope.$broadcast('hide:loading');
            if (localStorage.error == 1) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
            } else {
              $scope.closeModal();
              $scope.data.comment = "";

              $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
              window.Api.initPromise.then(function(response) {
                window.Api.database_api().exec("get_content_replies", [$rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink]).then(function(result){
                  if (result)
                    $scope.comments = result;
                  if (!$scope.$$phase) {
                    $scope.$apply();
                  }
                });
              });
            }
          }, 3000);
        } else {
          $rootScope.$broadcast('hide:loading');
          $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
        }
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    });
  }
  $rootScope.$on("update:content", function(){
    $rootScope.log("update:content");
    setTimeout(function() {
      $scope.getContent($scope.post.author, $scope.post.permlink);  

    /*window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content_replies", [$scope.post.author, $scope.post.permlink]).then(function(result){
        //todo fix active_votes
        console.log(result);
        if (result) {
          $scope.comments = result;
          console.log(result);
        }
        $rootScope.$broadcast('hide:loading');
      });
    });*/
    $rootScope.$broadcast('hide:loading');



    }, 100);



    $rootScope.$broadcast('hide:loading');
  });
  $ionicModal.fromTemplateUrl('templates/reply.html', {
    scope: $scope  }).then(function(modal) {
    $scope.modal = modal;
  });

  $scope.openModal = function(item) {
    //if(!$scope.modal) return;
    setTimeout(function() {
      $scope.modal.show();
    }, 5);
  };

  $scope.closeModal = function() {
    $scope.replying = false;
    $scope.modal.hide();
  };

  $scope.isreplying = function(cho, xx) {
    $scope.replying = xx;
    angular.merge($scope.post, cho);
    if (xx) {
      $scope.openModal();
    } else {
      $scope.closeModal();
    }
  };
  $scope.accounts = {};
  $scope.getContent = function(author, permlink) {
    //console.time('someFunction1');
    var url = "/"+$stateParams.category+"/@"+author+"/"+permlink;
    //console.log(url);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
        //console.log(result);
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        if ($rootScope.$storage.postAccounts && $rootScope.$storage.postAccounts.indexOf(result.author) == -1) {
          $rootScope.$storage.postAccounts.push(result.author);
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        //$scope.post.body = result.body;
        $rootScope.$storage.sitem = result;
        
        setTimeout(function() {
          $scope.$broadcast('postAccounts');
        }, 10);
      });
      
      
      /*window.Api.database_api().exec("get_state", [url]).then(function(dd){
        //console.log(dd);
        var con = dd.content;
        var acon = dd.accounts;

        angular.forEach(con, function(v,k){
          v.comments = [];
        });
        //setTimeout(function() {
        angular.forEach(con, function(v,k){
          var vparent = v.parent_author==""?v.author:v.parent_author;
          var vperm = v.parent_author==""?v.permlink:v.parent_permlink;
          var keyy = vparent+"/"+vperm;
          if (v.depth > 7) {
            v.showChildren = false;
          }
          if (v.parent_permlink!==v.category) {
            if (con[keyy]) {
              //console.log(v);
              var llen = v.active_votes.length;
              var luser = $rootScope.$storage.user;
              if (luser) {
                for (var jl = llen - 1; jl >= 0; jl--) {
                  if (v.active_votes[jl].voter === luser.username) {
                    if (v.active_votes[jl].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[jl].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.downvoted = false;
                      v.upvoted = false;
                    }
                  }
                }
              }
              
              con[keyy].comments.push(v);  
            }
          }
          if (!$scope.$$phase) {
            $scope.$apply();
          }
        });
        //console.log(acon);  
        //}, 1);
        angular.forEach(acon, function(v,k){
          //console.log(v.json_metadata);
          if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
            if (v.json_metadata) {
              if (v.json_metadata.indexOf("created_at")>-1) {
                v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
              } else {
                v.json_metadata = angular.fromJson(v.json_metadata);
              }
            }
          }
        });
        var result = con[author+"/"+permlink];

        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }

        result.json_metadata = angular.fromJson(result.json_metadata);
        
        //console.log(result);
        $rootScope.$broadcast('hide:loading');
        $scope.post = result;
        $rootScope.$storage.sitem = result;
        $rootScope.$storage.paccounts = acon;

        if (!$scope.$$phase) {
          $scope.$apply();
        }

      });
      if (!$scope.$$phase) {
        $scope.$apply();
      }*/
    });
  //$rootScope.$broadcast('hide:loading');
  //console.timeEnd('someFunction1');

  };
  
  $scope.fetchComments = function(author, permlink){
    $rootScope.fetching = true;
    //console.log(author,permlink);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content_replies", [author, permlink]).then(function(dd){
        /*for (var i = 0; i < dd.length; i++) {
          window.Api.database_api().exec("get_active_votes", [dd[i].author, dd[i].permlink]).then(function(res){
            //console.log(res);
            dd[i].active_votes = res;
          });
        }*/
        $scope.comments = dd;
        $rootScope.$storage.comments = dd;
        //console.log(dd.active_votes);
        $rootScope.fetching = false;
        for (var i = 0, len = dd.length; i < len; i++) {
          var v = dd[i];
          if ($rootScope.$storage.postAccounts && $rootScope.$storage.postAccounts.indexOf(v.author) == -1) {
            $rootScope.$storage.postAccounts.push(v.author);
          }  
        }
        setTimeout(function() {
          var p2 = document.querySelector('.my-handle');
          $scope.quotePosition = $ionicPosition.position(angular.element(p2));
          $ionicScrollDelegate.$getByHandle('mainScroll').scrollTo(0,$scope.quotePosition.top, true);  
          $scope.$broadcast('postAccounts');
          if (!$scope.$$phase){
            $scope.$apply();
          }
        }, 10);
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
      if (!$scope.$$phase){
        $scope.$apply();
      }
    });
  }
  $scope.$on('postAccounts', function(){
    $rootScope.$storage.paccounts = {};
    //console.log(window.Api);
    //window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);

    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [$rootScope.$storage.postAccounts]).then(function(res){
        for (var i = 0, len = res.length; i < len; i++) {
          var v = res[i];
          if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
            if (v.json_metadata) {
              if (v.json_metadata.indexOf("created_at")>-1) {
                v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
              } else {
                v.json_metadata = angular.fromJson(v.json_metadata);
              }
              var key = v.name;
              $rootScope.$storage.paccounts[key] = v.json_metadata;
            }
          }
        }
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
      if (!$scope.$$phase){
        $scope.$apply();
      }
    });
  });
  
  $scope.$on('$ionicView.enter', function(ev){
    //console.log(ev);
    //if(ev.targetScope !== $scope)
    //  return;
    $rootScope.log('enter postctrl');
    $rootScope.$storage.postAccounts = [];
    $rootScope.$storage.paccounts = [];
    //$rootScope.$broadcast('show:loading');
    if ($stateParams.category === '111') {
      var ttemp = $rootScope.$storage.sitem;
      $scope.post = ttemp;
      $rootScope.$broadcast('update:content');
    } else {
      if ($stateParams.author.indexOf('@')>-1){
        $stateParams.author = $stateParams.author.substr(1);
      }
      console.log('someFunction');
      $scope.getContent($stateParams.author, $stateParams.permlink);
    }
  });
  
  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'getContent');
  };
  $rootScope.$on('getContent', function() {
    setTimeout(function() {
      $scope.getContent($rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink);  
    }, 100);
  });
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'getContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'getContent');
  };


})
app.controller('BookmarkCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {

  $scope.removeBookmark = function(index) {
    if ($rootScope.$storage.bookmark) {
      APIs.removeBookmark($rootScope.$storage.bookmark[index]._id,$rootScope.$storage.user.username).then(function(res){
        $rootScope.$storage.bookmark.splice(index,1);
        $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
      });
    }
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getBookmarks($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $rootScope.$storage.bookmark = res.data;
    });
  });
});

app.controller('DraftsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeDraft = function(_id) {
    APIs.removeDraft(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.drafts = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNDRAFT'));
    });
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.drafts = res.data;
    });
  });
});

app.controller('ImagesCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeImage = function(_id) {
    APIs.removeImage(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.images = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('IMAGE_REMOVED'));
    });
  };
  $scope.copyImage = function(url){
    cordova.plugins.clipboard.copy(url);
  };
  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.images = res.data;
    });
  });
});

app.controller('NotificationsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {

  $scope.removeNotification = function(index) {
    if ($rootScope.$storage.notifications) {
      $rootScope.$storage.notifications.splice(index,1);
    }
  };
})
app.controller('FollowCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {
  $scope.searchu = {};

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = "followers";
    $scope.followers = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {ruser:"", duser:""};

    $scope.rfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_followers", [$rootScope.$storage.user.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.ruser = res[res.length-1].follower;
          }
          //console.log(res);
          var ll = res.length;
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.followers.push(res[i]);
          }
          if (res.length < $scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.rfetching, 5);
          }
        });
      });
    };

    $scope.dfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_following", [$rootScope.$storage.user.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.duser = res[res.length-1].following;
          }
          var ll = res.length;

          //console.log(res);
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.following.push(res[i]);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.dfetching, 5);
          }
        });
      });
    };

    $scope.rfetching();
    $scope.dfetching();

  });

  $scope.$on('$ionicView.leave', function(){
    /*if (angular.isDefined($scope.dfetching)){
      $interval.cancel($scope.dfetching);
      $scope.dfetching = undefined;
      $scope.following = undefined;
    }
    if (angular.isDefined($scope.rfetching)){
      $interval.cancel($scope.rfetching);
      $scope.rfetching = undefined;
      $scope.followers = undefined;
    }*/
  });
  $scope.isFollowed = function(x) {
    var len = $scope.following.length;
    for (var i = 0; i < len; i++) {
      if ($scope.following[i].following == x) {
        return true;
      }
    }
    return false;
  };
  $scope.isFollowing = function(x) {
    var len = $scope.followers.length;
    for (var i = 0; i < len; i++) {
      if ($scope.followers[i].follower == x) {
        return true;
      }
    }
    return false;
  };
  $scope.change = function(type){
    $scope.active = type;
    console.log(type);

    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $ionicScrollDelegate.$getByHandle('listScroll').scrollTop();
    //$scope.loadMore(type);
  }

  $scope.$on('current:reload', function(){
    $rootScope.log('current:reload');
    //$state.go($state.current, {}, {reload: true});
    $scope.followers = [];
    $scope.following = [];
    $scope.rfetching();
    $scope.dfetching();
  });

  $scope.unfollowUser = function(xx){
    $rootScope.following(xx, "unfollow");
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.profileView = function(xx){
    $state.go('app.profile', {username: xx});
  };

})

app.controller('ProfileCtrl', function($scope, $stateParams, $rootScope, $ionicActionSheet, $cordovaCamera, ImageUploadService, $ionicPopup, $ionicSideMenuDelegate, $ionicHistory, $state, APIs, $ionicPopover, $filter, $ionicModal) {

  $ionicPopover.fromTemplateUrl('popoverSliderrp.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSlider.show($event);
  };

  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.votePostS = function() {
    $scope.tooltipSlider.hide();
    $scope.upvotePost($scope.votingPost);
  };

  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.translationData = { platformname: $rootScope.$storage.platformname, platformpower: $rootScope.$storage.platformpower, platformsunit:"$1.00" };

  $scope.goBack = function() {
    var viewHistory = $ionicHistory.viewHistory();
    if (!viewHistory.backView) {
      $scope.openMenu();
    } else {
      $ionicHistory.goBack();
    }
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.unfollowUser = function(xx){
    $rootScope.log(xx);
    $rootScope.following(xx, "unfollow");
  };

  $scope.$on('current:reload', function(){
    $state.go($state.current, {}, {reload: true});
  });

  $ionicPopover.fromTemplateUrl('popoverPTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $ionicModal.fromTemplateUrl('my-edit.html', {
    scope: $scope,
    animation: 'slide-in-up'
  }).then(function(modal) {
    $scope.modalEdit = modal;
  });
  $scope.closeEdits = function() {
    $scope.modalEdit.hide();
  };
  // Cleanup the modal when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.modalEdit.remove();
  });
  // Execute action on hide modal
  $scope.$on('modal.hidden', function() {
    // Execute action
  });
  $scope.edit = {};
  $scope.showEdits = function() {
    //showedits
    $scope.edit = {};
    $scope.edit = $rootScope.$storage.user.json_metadata || {};
    $scope.modalEdit.show();
  }
  $scope.saveEdit = function(){
    console.log($scope.edit);
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: ""
    });
    confirmPopup.then(function(res) {
      if(res) {
        if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
          $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
        } else {
          var update = $rootScope.$storage.user.json_metadata;
          angular.merge(update, $scope.edit);
          if (update.profilePicUrl) {delete update.profilePicUrl;}
          $rootScope.log('You are sure');
          if ($rootScope.$storage.user) {
            $scope.mylogin = new window.ejs.Login();
            $scope.mylogin.setRoles(["active"]);
            var loginSuccess = $scope.mylogin.checkKeys({
                accountName: $rootScope.$storage.user.username,
                password: $rootScope.$storage.user.password || null,
                auths: {
                  active: $rootScope.$storage.user.active.key_auths
                },
                privateKey: $rootScope.$storage.user.privateActiveKey || null
              }
            );
            //todo: if json_metadata already exist make sure to keep it.
            if (loginSuccess) {
              var tr = new window.ejs.TransactionBuilder();
              tr.add_type_operation("account_update", {
                account: $rootScope.$storage.user.username,
                memo_key: $rootScope.$storage.user.memo_key,
                json_metadata: JSON.stringify(update)
              });
              localStorage.error = 0;
              tr.process_transaction($scope.mylogin, null, true);
              setTimeout(function() {
                $scope.modalEdit.hide();
                if (localStorage.error == 1) {
                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                } else {
                  $rootScope.$broadcast('refreshLocalUserData');
                }
              }, 3000);
            } else {
              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
            }
            $rootScope.$broadcast('hide:loading');
          } else {
            $rootScope.$broadcast('hide:loading');
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
          }
        }
      }
    });
  }
  $scope.showProfile = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'profile');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {profile_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            if (update.profilePicUrl) {delete update.profilePicUrl;}

            update.profile.profile_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $scope.changeProfileInfo = function(type, which) {
    if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
      $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
    } else {
      var options = {};
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          targetWidth: which==='profile'?500:1000,
          targetHeight: 500,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var update = { profile: { cover_image: "", profile_image: ""} };
            if (which === 'profile') {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = url;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = url;
            }

            setTimeout(function() {
              $rootScope.$broadcast('show:loading');
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });

                  localStorage.error = 0;

                  tr.process_transaction($scope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
                    } else {
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else {
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is'+ res);
          if (res) {
            var update = { profile: { profile_image: "", cover_image:"" } };
            if (which==="profile") {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = res;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = res;
            }

            setTimeout(function() {
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });
                  localStorage.error = 0;
                  tr.process_transaction($scope.mylogin, null, true);
                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshLocalUserData();
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
                $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
          }
        });
      }
    }
  };

  $scope.showCover = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_COVER_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'cover');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_COVER_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {cover_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            update.profile.cover_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $rootScope.$on('profileRefresh', function(){
    $scope.refresh();
  });
  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'profileRefresh');
  };
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'profileRefresh');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'profileRefresh');
  };

  $scope.isAmFollowing = function(xx) {
    if ($scope.following && $scope.following.indexOf(xx)!==-1) {
      return true;
    } else {
      return false;
    }
  };
  /*$scope.$watch('following', function() {
    console.log('hey, myVar has changed!');
  });*/
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.profile.length; i++) {
      if ($scope.data.profile[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.end = false;
  $scope.clen = 20;
  $scope.moreDataCanBeLoaded = function(){
    return ($scope.data.profile && $scope.data.profile.length>0) && !$scope.end;
  }

  $scope.loadmore = function() {
    //console.log('loadmore');
    var params = {tag: $stateParams.username, limit: 20, filter_tags:[]};
    var len = $scope.data.profile?$scope.data.profile.length:0;

    //console.log($scope.data.profile);

    if (len>0) {
      delete params.limit;
      params.start_author = $scope.data.profile[len-1].author;
      params.start_permlink = $scope.data.profile[len-1].permlink;

      if ($scope.end) {
        //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
        $scope.$broadcast('scroll.infiniteScrollComplete');
        $rootScope.$broadcast('hide:loading');
      } else {
        //console.log(params);
        //$rootScope.log("fetching profile...blog 20 ");
        window.Api.initPromise.then(function(response) {
          if (typeof window.Api.database_api === "function") {
            if ($scope.active == 'blog') {
              if ($rootScope.$storage.chain == 'golos') {
                params.select_authors = [$stateParams.username];
                delete params.tags;   
              }
              window.Api.database_api().exec("get_discussions_by_blog", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'posts') {
              window.Api.database_api().exec("get_discussions_by_comments", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'recent-replies') {
              var pp = [$scope.data.profile[$scope.data.profile.length-1].author, $scope.data.profile[$scope.data.profile.length-1].permlink, 20];
              window.Api.database_api().exec("get_replies_by_last_update", [pp]).then(function(response){
                //console.log(response);
                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            //console.log($scope.profile);
          }
        });
      }
    }

  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.user = {username: $stateParams.username};
    $scope.follower = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {duser: "", ruser: ""};

    $scope.refresh = function() {
      if (!$scope.active) {
        $scope.active = "blog";
      }
      if ($scope.active != "blog") {
        $scope.rest = "/"+$scope.active;
      } else {
        $scope.rest = "";
      }

      $scope.nonexist = false;
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
          $scope.data = {profile: []};
          //console.log(res);
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
            if(!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            $scope.nonexist = true;
          }
        });
      });
    };
    $scope.dfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_following", [$rootScope.$storage.user.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.duser = res[res.length-1].following;
          }
          var len = res.length;
          for (var i = 0; i < len; i++) {
            $scope.following.push(res[i].following);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          } else {
            setTimeout($scope.dfetching, 5);
          }
        });
      });
    };
    $scope.rfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_followers", [$rootScope.$storage.user.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.ruser = res[res.length-1].follower;
          }
          var len = res.length;
          for (var i = 0; i < len; i++) {
            $scope.follower.push(res[i].follower);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          } else {
            setTimeout($scope.rfetching, 10);
          }
        });
      });
    };
    $scope.getFollows = function(r,d) {      
      if (r) {
        $rootScope.log("rfetching");
        $scope.rfetching();
      }
      if (d) {
        $rootScope.log("dfetching");
        $scope.dfetching();
      }
    };
    $scope.getOtherUsersData = function() {
      console.log("getOtherUsersData");
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_accounts", [[$stateParams.username]]).then(function(dd){
          dd = dd[0];
          if (dd && dd.json_metadata) {
            dd.json_metadata = angular.fromJson(dd.json_metadata);
          }
          angular.merge($scope.user, dd);
          //console.log(angular.toJson($scope.user));
          //console.log($scope.user.json_metadata.profile.cover_image);

          if ($rootScope.$storage.user) {
            $scope.css = ($rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
          } else {
            $scope.css = null;
          }
          if (!$scope.$$phase){
            $scope.$apply();
          }
        });
        window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
          //console.log(res);
          $scope.followdetails = res;
        });
      });
      $scope.getFollows(null, "d");
      if(!$scope.$$phase){
        $scope.$apply();
      }
    };

    $scope.refresh();
    if ($rootScope.$storage.user) {
      if ($rootScope.$storage.user.username !== $stateParams.username) {
        $scope.getOtherUsersData();
      } else {
          $rootScope.log("get follows counts");
          window.Api.initPromise.then(function(response) {
            window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
              //console.log(res);
              $scope.followdetails = res;
            });
          });
      }
    } else {
      if ($stateParams.username) {
        $scope.getOtherUsersData();
      }
    }

    //setTimeout(function() {
      $scope.css = ($rootScope.$storage.user&& $rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user && $rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
      //console.log($scope.css);
    //}, 1);

  });
  $scope.openMenu = function() {
    $ionicSideMenuDelegate.toggleLeft();
  }
  $scope.change = function(type){
    $scope.data = undefined;
    console.log(type);
    $scope.data = {profile: []};
    $scope.accounts = [];
    $scope.active = type;
    $scope.end = false;
    
    if(!$scope.$$phase){
      $scope.$apply();
    }

    if (type != "blog") {
      $scope.rest = "/"+type;
    } else {
      $scope.rest = "";
    }
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
        //console.log(res);
        if (res.content) {
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
          } else {
            $scope.nonexist = true;
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
        if (type==="transfers" || type==="permissions") {
          for (var property in res.accounts) {
            if (res.accounts.hasOwnProperty(property)) {
              $scope.accounts = res.accounts[property];
              //$rootScope.log(angular.toJson(res.accounts[property].transfer_history));

              $scope.transfers = res.accounts[property].transfer_history;
              //console.log($scope.transfers);
              $scope.nonexist = false;
            }
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
      });
    });
  }

})

app.controller('ExchangeCtrl', function($scope, $stateParams, $rootScope) {
  $scope.username = $stateParams.username;

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = 'buy';
    $scope.orders = [];
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_order_book", [15]).then(function(res){
        $scope.orders = res;
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
    $scope.change = function(type){
      $scope.active = type;
      if (type == "open"){
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_open_orders", [$stateParams.username]).then(function(res){
            $scope.openorders = res;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
      if (type == "history"){
        $scope.history = [];
        window.Api.initPromise.then(function(response) {
          window.Api.market_history_api().exec("get_recent_trades", [15]).then(function(r){
            $scope.recent_trades = r;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
    };
  });

});
app.controller('MarketCtrl', function($scope, $rootScope, $state, $ionicPopover, $ionicPopup, $filter, $translate, $ionicPlatform, $window) {

  $scope.requestApp = function(name) {
    $ionicPlatform.ready(function() {
      if (name == 'New') {
        window.open("mailto:info@esteem.ws?subject=Suggesting%20New%20App%20for%20Market%20Place&body=Hello!%0D%0A%0D%0AAppName:%0D%0AAppAuthor:%0D%0AAppLink:%0D%0A%0D%0A", "_system");
      }
      if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('id1158918690');
          window.open("itms-apps://itunes.apple.com/app/id1158918690", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('id1171371708');
          window.open("itms-apps://itunes.apple.com/app/id1171371708", "_system");
        }
      } else {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('com.netsolutions.esteemwitness');
          window.open("market://details?id=com.netsolutions.esteemwitness", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('com.netsolutions.steemfest');
          window.open("market://details?id=com.netsolutions.steemfest", "_system");
        }
      }
    });
  }

});

app.controller('SettingsCtrl', function($scope, $stateParams, $rootScope, $ionicHistory, $state, $ionicPopover, $ionicPopup, APIs, $filter, $translate, $window, $ionicSideMenuDelegate) {

   $ionicPopover.fromTemplateUrl('popover.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });
   if ($rootScope.$storage.chain == 'steem'){
    $scope.options = ['wss://steemd.steemit.com', 'wss://node.steem.ws']; 
   } else {
    $scope.options = ['wss://ws.golos.io', 'wss://node.golos.ws'];
   }
   

   $scope.openTooltip = function($event, d) {
      var texth = d;
      $scope.tooltipText = texth;
      $scope.tooltip.show($event);
   };

  function getDate(xx) {
    for (var i = 0, len = $rootScope.$storage.currencies.length; i < len; i++) {
      var v = $rootScope.$storage.currencies[i];
      if (v.id == xx) {
        return true;
      }
    }
  }

  function searchObj(nameKey, myArray) {
    for (var i=0; i < myArray.length; i++) {
        if (myArray[i].id === nameKey) {
            return myArray[i];
        }
    }
  }

  $scope.changeCurrency = function(xx, ignore) {
    $rootScope.$broadcast('changedCurrency', {currency: xx, enforce: ignore});
  }
  $scope.changeChain = function() {
    $scope.restart = true;
    if ($rootScope.$storage.chain == 'steem'){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      $scope.socket = "wss://steemd.steemit.com";
    } else {
      $rootScope.$storage.platformname = "";
      $rootScope.$storage.platformpower = " ";
      $rootScope.$storage.platformsunit = "";
      $rootScope.$storage.platformdollar = "";
      $rootScope.$storage.platformdunit = "GBG";
      $rootScope.$storage.platformpunit = "GOLOSP";
      $rootScope.$storage.platformlunit = "GOLOS";
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
      //$scope.socket = "wss://golos.steem.ws";
      $scope.socket = "wss://ws.golos.io/";
    }
    window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);

    $scope.changeCurrency($rootScope.$storage.currency, true);
  }
  $scope.restart = false;
  $scope.closeTooltip = function() {
    $scope.tooltip.hide();
  };

  //Cleanup the popover when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.tooltip.remove();
  });

  $scope.changeLanguage = function(locale){
    setTimeout(function() {
      if (locale == 'ar-SA' || locale == 'he-IL' || locale == 'fa-IR') {
        $rootScope.$storage.dir = 'rtl';
      } else {
        $rootScope.$storage.dir = 'ltr';
      }
      $translate.use(locale);
      if (!$scope.$$phase) {
        $scope.$apply();
      }
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    }, 1);
  }
  $scope.drag = function(v) {
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    $scope.data = {};
    if (!$rootScope.$storage.voteWeight){
      $rootScope.$storage.voteWeight = 10000;
      $scope.vvalue = 100;
    } else {
      $scope.vvalue = $rootScope.$storage.voteWeight/100;
    }
    if(!$scope.$$phase){
      $scope.$apply();
    }
    
    if ($rootScope.$storage.pincode) {
      $scope.data = {pin: true};
    } else {
      $scope.data = {pin: false};
    }

    if ($rootScope.$storage.user && $rootScope.$storage.deviceid) {
      APIs.getSubscriptions($rootScope.$storage.deviceid).then(function(res){
        $rootScope.log(angular.toJson(res.data));
        var d = res.data;
        //angular.forEach(d, function(v,k){
        for (var i = 0, len = d.length; i < len; i++) {
          var v = d[i];
          if (v.username == $rootScope.$storage.user.username) {
            angular.merge($scope.data, {vote: v.subscription.vote, follow: v.subscription.follow, comment: v.subscription.comment, mention: v.subscription.mention, resteem: v.subscription.resteem});    
          }          
        }
        
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    }

    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.notificationChange = function() {
    $rootScope.$storage.subscription = {
      vote: $scope.data.vote,
      comment: $scope.data.comment,
      follow: $scope.data.follow,
      mention: $scope.data.mention,
      resteem: $scope.data.resteem,
      device: ionic.Platform.platform(),
      timestamp: $filter('date')(new Date(), 'medium'),
      appversion: '1.3.9'
    }
    APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, $rootScope.$storage.subscription).then(function(res){
      console.log(angular.toJson(res));
    });

  }

  $scope.pinChange = function() {
    $rootScope.log("pinChange");
    if ($rootScope.$storage.pincode) {
      $rootScope.$broadcast("pin:check");
    } else {
      $rootScope.$broadcast("pin:new");
    }
  }

  $rootScope.$on("pin:correct", function(){
    $rootScope.log("pin:correct " + $scope.data.pin);
    if (!$scope.data.pin) {
        $rootScope.$storage.pincode = undefined;
    }
    if ($rootScope.$storage.pincode) {
      $scope.data.pin = true;
    } else {
      $scope.data.pin = false;
    }
    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $rootScope.$on("pin:failed", function(){
    $rootScope.log("pin:failed");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $scope.data.pin = true;
      } else {
        $scope.data.pin = false;
      }
      if (!$scope.$$phase){
        $scope.$apply();
      }
    }, 10);

  });
  $scope.logouts = function() {
    $rootScope.$storage.user = undefined;
    $rootScope.$storage.user = null;
    $rootScope.$storage.mylogin = undefined;
    $rootScope.$storage.mylogin = null;
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        //$window.location.reload(true);
        $state.go('app.posts',{renew:true},{reload: true});
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      //$window.location.reload(true);
      $state.go('app.posts',{renew:true},{reload: true});
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
    setTimeout(function() {
      ionic.Platform.exitApp(); // stops the app
    }, 100);
  };
  $scope.socket = $rootScope.$storage["socket"+$rootScope.$storage.chain];
  $scope.socketChange = function(xx){
    console.log(xx);
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = xx;
    localStorage.socketUrl = xx;
    $scope.restart = true;
  }
  $scope.save = function(){
    if ($scope.restart) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('UPDATE_REQUIRES_RESTART')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          localStorage.socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
          //$scope.logouts();
          setTimeout(function() {
            window.Api.close();
            window.Api = null;
            window.steemRPC.Client.close();
            var socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
            window.Api = window.steemRPC.Client.get({url:socketUrl}, true);
            if ($rootScope.$storage.user.chain != $rootScope.$storage.chain) {
              for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
                var v = $rootScope.$storage.users[i];
                if (v.chain == $rootScope.$storage.chain){
                  $rootScope.$storage.user = v;
                }
              }
            }
            window.Api.initPromise.then(function(response) {
              $state.go('app.posts',{renew:true},{reload: true});
            });
          }, 500);
        } else {
          $rootScope.log('You are not sure');
        }
      });
    } else {
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('SETTINGS_UPDATED'));
      $ionicHistory.nextViewOptions({
        disableBack: true
      });
      //$window.location.reload(true);  
      $state.go('app.posts',{renew:true},{reload: true});
    }
  };

});
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/controllers.js","/posts")
},{"buffer":11,"pBGvAp":74}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){


var app = angular.module('steem', [
	'ionic',
	'ngStorage',
	'ngCordova',
  'ion-floating-menu',
  'pascalprecht.translate',
  'ja.qr',
  'ion-datetime-picker'
]);

if (localStorage.getItem("socketUrl") === null) {
  localStorage.setItem("socketUrl", "wss://steemd.steemit.com");
} else if (localStorage.getItem("socketUrl") == "wss://steemit.com/wspa") {
  localStorage.socketUrl="wss://steemd.steemit.com";
}

localStorage.golosId = "782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12";
localStorage.steemId = "0000000000000000000000000000000000000000000000000000000000000000";

window.steemRPC = require("steem-rpc");
window.Api = window.steemRPC.Client.get({url:localStorage.socketUrl}, true);
//window.steemJS = require("steemjs-lib");

window.ejs = require("esteem-lib");

//window.golosJS = require("golosjs-lib");
window.diff_match_patch = require('diff-match-patch');
window.getSymbol = require('currency-symbol-map');

require('./config')(app);
require('./services')(app);
require('./controllers')(app);


app.config(function($stateProvider, $urlRouterProvider, $ionicConfigProvider, $sceDelegateProvider, $logProvider, $compileProvider, $animateProvider, $translateProvider) {
  $stateProvider

  .state('app', {
    url: '/app',
    abstract: true,
    template: "<ion-side-menus enable-menu-with-back-views=\"true\" view-cache=\"false\">\n  <ion-side-menu-content drag-content=\"false\">\n    <ion-nav-bar class=\"bar-positive\">\n      <ion-nav-back-button>\n      </ion-nav-back-button>\n      <ion-nav-buttons side=\"left\">\n        <button class=\"button button-icon button-clear ion-navicon\" menu-toggle=\"left\">\n        </button>\n      </ion-nav-buttons>\n    </ion-nav-bar>\n    <ion-nav-view name=\"menuContent\"></ion-nav-view>\n  </ion-side-menu-content>\n  <ion-side-menu side=\"left\">\n    <!--<ion-header-bar class=\"bar-positive\" ng-if=\"!$root.$storage.user\">\n      <h1 class=\"title center\">eSteem</h1>\n    </ion-header-bar>-->\n    <ion-content>\n      <div ng-if=\"!$root.$storage.user\">\n        <center>\n          <p>\n            <img ng-src=\"img/esteem.png\" width=\"150\" />\n          </p>\n        </center>\n      </div>\n      <div ng-if=\"$root.$storage.user\" ng-style=\"$root.$storage.user.json_metadata.profile.cover_image ? mcss : null\">\n      <br>\n        <center>\n          <a menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-myavatar\" ng-if=\"$root.$storage.user\">\n            <span class=\"item-myavatar\" ng-if=\"!$root.$storage.user.json_metadata.user_image && !$root.$storage.user.json_metadata.profile.profile_image\"><img src=\"img/user_profile.png\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" />\n          </a>\n          <div>\n            <div class=\"h4\">@{{$root.$storage.user.username}}&nbsp;<div class=\"reputation\">{{$root.$storage.user.reputation|reputation:true|number:1}}</div></div>\n            <div ng-click=\"showMeExtra()\" class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{$root.$storage.user.post_count}}&nbsp;&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{$root.$storage.user.voting_power/100|number:2}} <i class=\"icon pull-right\" ng-class=\"{'ion-arrow-down-b':!showExtra, 'ion-arrow-up-b':showExtra}\"></i></div>\n          </div>\n        </center>\n      </div>\n      <div ng-if=\"showExtra\">\n        <ion-list>\n          <ion-item menu-close class=\"item-icon-left\" ng-if=\"$root.$storage.users\" ng-repeat=\"user in $root.$storage.users\" ng-click=\"selectAccount(user)\" ng-class=\"{'active': (user.username==$root.$storage.user.username&&user.chain==$root.$storage.user.chain) }\">\n            <img class=\"icon logos\" ng-src=\"{{'img/'+user.chain+'_icon.png'}}\" />\n            {{user.username}}\n            <!--<span class=\"badge badge-assertive\">{{user.chain}}</span>-->\n          </ion-item>\n          <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-plus-round\"></i>\n            {{'ADD_ACCOUNT'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"openPostModal()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-android-create\"></i>\n            {{'SUBMIT_A_STORY'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person\"></i>\n            {{'PROFILE'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/follow\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person-stalker\"></i>\n            {{'FOLLOW'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"logout()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-log-out\"></i>\n            {{'LOGOUT'|translate}}\n          </ion-item>\n        </ion-list>\n      </div>\n      <ion-list>\n        <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"!$root.$storage.user\">\n          <i class=\"icon ion-log-in\"></i>\n          {{'LOGIN'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/posts/\" class=\"item-icon-left\">\n          <i class=\"icon ion-home\"></i>\n          {{'HOME'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/bookmark\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'BOOKMARKS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/drafts\" ng-if=\"$root.$storage.user\" class=\"item-icon-left\">\n          <i class=\"icon ion-compose\"></i>\n          {{'DRAFTS'|translate}}\n        </ion-item>\n        <!--<ion-item menu-close href=\"#/app/notifications\" class=\"item-icon-left\" ng-if=\"$root.$storage.notifications && $root.$storage.notifications.length>0\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'NOTIFICATIONS'|translate}}\n        </ion-item>-->\n        <ion-item menu-close href=\"#/app/send\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-android-send\"></i>\n          {{'TRANSFER'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/exchange/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-arrow-swap\"></i>\n          {{'EXCHANGE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/market\" class=\"item-icon-left\">\n          <i class=\"icon ion-cube\"></i>\n          {{'MARKETPLACE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/settings\" class=\"item-icon-left\">\n          <i class=\"icon ion-android-settings\"></i>\n          {{'SETTINGS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/about\" class=\"item-icon-left\">\n          <i class=\"icon ion-information\"></i>\n          {{'ABOUT'|translate}}\n        </ion-item>\n      </ion-list>\n    </ion-content>\n    <!-- align to the bottom of the page -->\n    <div style=\"position: absolute; bottom: 0px; width: 100%\" ng-if=\"$root.$storage.appversion\">\n        <div style=\"text-align: center; color:#ccc;\">\n          <p>{{$root.$storage.appversion}}</p>\n        </div>\n    </div>\n  </ion-side-menu>\n</ion-side-menus>\n",
    //templateUrl: 'templates/menu.html',
    controller: 'AppCtrl'
  })

  .state('app.settings', {
    url: '/settings',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'SETTINGS'|translate}}\">\n  <ion-content class=\"padding has-header settings\">\n    <br/>\n    <div class=\"item item-divider\">\n      {{'SECURITY'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"PIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'PIN_CODE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.pin\" ng-change=\"pinChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div ng-if=\"$root.$storage.user\">\n    <div class=\"item item-divider\">\n      {{'NOTIFICATIONS'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTE_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'VOTE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.vote\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"COMMENT_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'COMMENT'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.comment\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"FOLLOW_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'FOLLOW'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.follow\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"MENTIONS_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'MENTIONS'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.mention\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"RESTEEM_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'RESTEEM'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.resteem\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    </div>\n    <div class=\"item item-divider\">\n      {{'CONFIGURATIONS'|translate}}\n    </div>\n\n    <div class=\"row\" ng-if=\"$root.$storage.user\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTING_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'VOTING'|translate}} (%)</span>\n      </div>\n      <div class=\"col\">\n        <div class = \"item range range-positive\">\n           {{vvalue}} <input type=\"range\" name=\"range1\" min=\"1\" max=\"100\" ng-model=\"vvalue\" ng-change=\"drag(vvalue)\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"LANGUAGES_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'LANGUAGES'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.language\" ng-change='changeLanguage($root.$storage.language)'>\n          <option ng-repeat=\"option in $root.$storage.languages\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CURRENCY_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'CURRENCY'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.currency\" ng-change='changeCurrency($root.$storage.currency)'>\n          <option ng-repeat=\"option in $root.$storage.currencies\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CHAIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'CHAIN'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.chain\" ng-change='changeChain($root.$storage.chain)'>\n          <option ng-repeat=\"option in $root.$storage.chains\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"<span class=\\\"bold\\\">{{\"SERVER_TEXT\"|translate}}:</span><br><span class=\\\"wrap\\\">[steemit] wss://steemd.steemit.com</span><br/><br/><span class=\\\"wrap\\\">[steem.ws] wss://node.steem.ws</span><br/><br/><span class=\\\"wrap\\\">[piston] wss://this.piston.rocks</span><br/><br/><span class=\\\"wrap\\\">[golos] wss://ws.golos.io</span><br/><br/><span class=\\\"wrap\\\">[golos.ws] wss://node.golos.ws</span>\n        \")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'SERVER'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <!--<input type=\"text\" placeholder=\"Server\" ng-model=\"socket\" style=\"width:100%;\" ng-change=\"socketChange(socket)\">-->\n        <select-input ng-model=\"socket\" select-options=\"options\" ></select-input>\n      </div>\n    </div>\n\n    <!--<div class=\"row\">\n      <div class=\"col\">\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n    <button class=\"button button-positive\" ng-click=\"changeLanguage('ru')\">Change RU</button>-->\n    <br/>\n    <script id = \"popover.html\" type=\"text/ng-template\">\n      <ion-popover-view>\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <div class=\"tcenter\">\n      <button class=\"button button-positive\" ng-click=\"save()\">{{'SAVE_CHANGES'|translate}}</button>\n    </div>\n  </ion-content>\n</ion-view>\n",
        controller: 'SettingsCtrl'
      }
    }
  })

  .state('app.about', {
    url: '/about',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'ABOUT' | translate}} - v{{$root.$storage.appversion}}\">\n  <ion-content class=\"padding\">\n    <center><img src=\"img/about.png\"></center>\n    <p><b>eSteem</b> {{'ABOUT_2'|translate}} <div ng-bind-html=\"'ABOUT_11'|translate\"></div>\n    </p>\n    <p ng-if=\"$root.$storage.user\">{{\"FOUNDER\"|translate}} <a href=\"#app/profile/good-karma\">good-karma</a></p>\n    <div class=\"tcenter\" ng-if=\"$root.$storage.user\"><span ng-if=\"!$root.isWitnessVoted()\"><button class=\"button button-positive\" ng-click=\"$root.voteWitness()\">{{'ABOUT_8'|translate}}</button></span></div>\n    <p>\n    <b><u>{{'ABOUT_9'|translate}}</u></b>\n    <br><a href=\"mailto:info@esteem.ws?Subject=Feedback\">info@esteem.ws</a>\n    <br><a href=\"http://esteem.ws\">http://esteem.ws</a>\n    </p>\n    <p>\n        <b><u>{{'TRANSLATIONS'|translate}}</u></b><br>\n         - <a href=\"#app/profile/testz\">testz</a>, <a href=\"#app/profile/on0tole\">on0tole</a><br>\n        Deutsch - <a href=\"#app/profile/dez1337\">dez1337</a>, <a href=\"#app/profile/homosapiens\">homosapiens</a>, <a href=\"#app/profile/uwelang\">uwelang</a>, <a href=\"#app/profile/alexpfeiffer\">alexpfeiffer</a><br>\n        Franais - <a href=\"#app/profile/pickoum\">pickoum</a><br>\n        Espaol - <a href=\"#app/profile/dresden\">dresden</a>, <a href=\"#app/profile/pgarcgo\">pgarcgo</a><br>\n         - <a href=\"#app/profile/liondani\">liondani</a>, <a href=\"#app/profile/steemychicken1\">steemychicken1</a><br>\n         - <a href=\"#app/profile/rossenpavlov\">rossenpavlov</a><br>\n        Nederlands - <a href=\"#app/profile/maxse\">maxse</a>, <a href=\"#app/profile/edje\">edje</a><br>\n        Magyar - <a href=\"#app/profile/tibonova\">tibonova</a><br>\n        etina - <a href=\"#app/profile/valtr\">valtr</a><br>\n         - <a href=\"#app/profile/bosrad\">bosrad</a><br>\n        Polski - <a href=\"#app/profile/knittybynature\">knittybynature</a>, <a href=\"#app/profile/gtg\">gtg</a><br>\n        Portugus - <a href=\"#app/profile/alamyrjunior\">alamyrjunior</a>, <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Portugus BR - <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Bahasa Indonesia - <a href=\"#app/profile/levycore\">levycore</a>, <a href=\"#app/profile/happyphoenix\">happyphoenix</a><br>\n         - <a href=\"#app/profile/deanliu\">deanliu</a><br>\n         - <a href=\"#app/profile/huangdashuang\">huangdashuang</a>, <a href=\"#app/profile/oflyhigh\">oflyhigh</a>, <a href=\"#app/profile/lucid\">lucid</a><br>\n        Dolan - <a href=\"#app/profile/maxse\">maxse</a><br>\n        Svensk - <a href=\"#app/profile/acidyo\">acidyo</a>, <a href=\"#app/profile/the-ego-you\">the-ego-is-you</a><br>\n         - <a href=\"#app/profile/erikaflynn\">erikaflynn</a>, <a href=\"#app/profile/artem-sokoloff\">artem-sokoloff</a><br>\n        Bahasa Melayu - <a href=\"#app/profile/kevinwong\">kevinwong</a>, <a href=\"#app/profile/killuminatic\">killuminatic</a><br>\n        Hrvatski - <a href=\"#app/profile/fibra59\">fibra59</a><br>\n        Frsi - <a href=\"#app/profile/meysam\">meysam</a><br>\n        Italiano - <a href=\"#app/profile/bhuz\">bhuz</a>, <a href=\"#app/profile/duranzo89\">duranzo89</a>, <a href=\"#app/profile/silviabeneforti\">silviabeneforti</a><br>\n        Wikang Filipino - <a href=\"#app/profile/themanualbot\">themanualbot</a><br>\n         - <a href=\"#app/profile/bbkoopsta\">bbkoopsta</a><br>\n        \n        <!--\n        malay-killuminatic\n        Wikang Filipino - themanualbot\n        -->\n    </p>\n    <p>\n    <b><u>{{'ABOUT_10'|translate}}</u></b>\n    <br><a href=\"https://steem.io\">https://steem.io</a>\n    <br><a href=\"https://golos.io\">https://golos.io</a>\n    </p>\n  </ion-content>\n</ion-view>\n"
      }
    }
  })

	.state('app.market', {
		url: '/market',
		views: {
			'menuContent': {
				//templateUrl: 'templates/settings.html'
				template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKETPLACE' | translate}}\">\n  <ion-content class=\"padding\">\n    <h4>{{'EXTERNAL_APPS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('SteemMonitor')\">\n        <center>\n          <img src=\"img/logo_steemmonitor.png\" alt=\"Steem Monitor\" style=\"width: 100%;\">\n          <b>Steem Monitor</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a></p>\n        </center>\n      </div>\n      <div class=\"col\" ng-click=\"requestApp('SteemFest')\">\n        <center>\n          <img src=\"img/logo_steemfest.png\" alt=\"Steem Fest\" style=\"width: 100%;\">\n          <b>Steem Fest</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a>, <a href=\"#app/profile/roelandp\">Roeland</a> &amp; <a href=\"#app/profile/cass\">Cass</a></p>\n        </center>\n      </div>\n    </div><br/>\n    <h4>{{'PLUGINS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col italic\">\n        <center>\n          {{'COMING_SOON'|translate}}...\n        </center>\n      </div>\n    </div>\n    <br/>\n    <h4>{{'SUGGEST'|translate}}</h4><br/>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('New')\">\n        <center>\n          <img src=\"img/plus.png\" alt=\"Suggest New\" style=\"width: 100%;\">\n          <b>{{'NEW'|translate}}</b>\n        </center>\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n  </ion-content>\n</ion-view>\n",
				controller: 'MarketCtrl'
			}
		}
	})

  .state('app.send', {
    url: '/send',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'TRANSFER'|translate}}\">\n  <div class=\"tabs-striped tabs-top tabs-background-positive tabs-color-light\">\n    <div class=\"tabs\">\n      <a class=\"tab-item\" href ng-click=\"changeTransfer('transfer')\" ng-class=\"{'active': ttype=='transfer'}\">\n        {{\"TRANSFER\"|translate}}\n      </a>\n      <a class=\"tab-item\" href ng-click=\"changeTransfer('escrow')\" ng-class=\"{'active': ttype=='escrow'}\">\n        {{\"ESCROW\"|translate}}\n      </a>\n    </div>\n  </div>\n\n  <ion-content class=\"padding has-tabs-top\">\n\n    <div class=\"list\">\n      <div class=\"item item-input item-icon-right\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'TO'|translate}}</span>\n        <input type=\"text\" ng-model=\"data.username\" placeholder=\"{{'TO_DESC'|translate}}\" ng-change=\"changeUsername()\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n        <i class=\"icon ion-ios-camera-outline\" ng-click=\"qrScan()\" ng-if=\"ttype=='transfer'\"></i>\n      </div>\n      <label class=\"item item-input\" ng-if=\"ttype=='escrow'&&!data.advanced\">\n          <span class=\"input-label\">{{\"ESCROW_AGENT\"|translate}}</span>\n          <input type=\"text\" readonly=\"readonly\" placeholder=\"{{'USERNAME'|translate}}\" ng-model=\"data.agent.name\" ng-click=\"openUModal(data.agent)\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n      </label>\n      <div class=\"item item-input item-icon-right\" ng-if=\"ttype=='escrow'&&data.advanced\">\n        <span class=\"input-label\">{{'ESCROW'|translate}} {{'ID'|translate}}</span>\n        <input type=\"text\" ng-model=\"data.escrow_id\" placeholder=\"{{'SEARCH'|translate}}\" ng-change=\"searchEscrowID(data.escrow_id)\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </div>\n      <label class=\"item item-input item-select\" ng-if=\"data.advanced\">\n        <span class=\"input-label\">{{'OPTIONS'|translate}}</span>\n        <select ng-model=\"data.etype\" ng-if=\"ttype=='escrow'\" ng-options=\"item.type as item.name for item in data.etypes track by item.id\" ng-change=\"actionEChange()\"></select>\n      </label>\n      <label class=\"item item-input item-select\" ng-if=\"data.advanced&&data.etype=='release'\">\n        <span class=\"input-label\">{{'RECEIVER'|translate}}</span>\n        <select ng-model=\"escrow.receiver\">\n          <option value=\"{{escrow.to}}\" ng-if=\"escrow.to!=$root.$storage.user.username\">{{escrow.to}}</option>\n          <option value=\"{{escrow.from}}\" ng-if=\"escrow.from!=$root.$storage.user.username\">{{escrow.from}}</option>\n        </select>\n      </label>\n      <label class=\"item item-input item-select\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'ASSET'|translate}}</span>\n        <select ng-model=\"data.type\" ng-if=\"ttype=='escrow'\" ng-options=\"item.type as item.name for item in data.types | filter:showLiquid track by item.id\"></select>\n        <select ng-model=\"data.type\" ng-if=\"ttype=='transfer'\" ng-options=\"item.type as item.name for item in data.types track by item.id\"></select>\n      </label>\n      <label class=\"item item-input\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'AMOUNT'|translate}}</span>\n        <input type=\"number\" placeholder=\"{{'AMOUNT'|translate}}\" step=\"0.001\" ng-model=\"data.amount\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n      <label class=\"item item-input\" ng-if=\"data.type != 'sp'&&data.type != 'golosp' && !data.advanced\">\n        <span class=\"input-label\">{{'MEMO'|translate}}</span>\n        <textarea ng-model=\"data.memo\" rows=\"3\" placeholder=\"{{'PUBLIC_MEMO'|translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"></textarea>\n      </label>\n      <div class=\"item\" ion-datetime-picker ng-model=\"data.ratification\" only-valid=\"{'after': 'today', 'inclusive': true}\" ng-if=\"ttype=='escrow'&&!data.advanced\">{{'RATIFICATION_DEADLINE'|translate}}: {{data.ratification| date: \"yyyy-MM-dd H:mm:ss\"}}</div>\n      <div class=\"item\" ion-datetime-picker ng-model=\"data.expiration\" only-valid=\"{'after': 'today', 'inclusive': false}\" ng-if=\"ttype=='escrow'&&!data.advanced\">{{'ESCROW_EXPIRATION'|translate}}: {{data.expiration| date: \"yyyy-MM-dd H:mm:ss\"}}</div>\n      <ion-toggle ng-if=\"ttype=='escrow'\" ng-model=\"data.advanced\" toggle-class=\"toggle-calm\" ng-change=\"advancedEChange()\">{{'ADVANCED'|translate}}</ion-toggle>\n      <p class=\"item\" ng-if=\"balance && !data.advanced\">{{'AVAILABLE'|translate}}: {{balance.balance}}, {{balance.sbd_balance}} <i class=\"icon ion-refresh pull-right\" ng-click=\"refresh()\"></i></p>\n      <br>\n      <div ng-if=\"ttype=='escrow' && data.advanced && escrow.escrow_id\">\n        <div class=\"row\"><div class=\"col\">{{\"FROM\"|translate}}:</div><div class=\"col\">{{escrow.from}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"TO\"|translate}}:</div><div class=\"col\">{{escrow.to}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_AGENT\"|translate}}:</div><div class=\"col\">{{escrow.agent}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_FEE\"|translate}}:</div><div class=\"col\">{{escrow.fee}} {{escrow.fee_symbol}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'RATIFICATION_DEADLINE'|translate}}:</div><div class=\"col\">{{escrow.ratification_deadline|date:'short'}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'ESCROW_EXPIRATION'|translate}}:</div><div class=\"col\">{{escrow.escrow_expiration|date:'short'}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_TERMS\"|translate}}:</div><div class=\"col\">{{escrow.json_meta.terms}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'MEMO'|translate}}:</div><div class=\"col\">{{escrow.json_meta.memo}}</div></div>\n      </div>\n      <center ng-if=\"ttype=='transfer'\"><button class=\"button button-positive\" ng-click=\"transfer('transfer')\">\n        {{'SEND'|translate}}\n      </button></center>\n      <center ng-if=\"ttype=='escrow'&&!data.advanced\"><button class=\"button button-positive\" ng-click=\"transfer('escrow')\">\n        {{'SEND'|translate}}\n      </button></center>\n      <center ng-if=\"ttype=='escrow'&&data.advanced\"><button class=\"button button-positive\" ng-click=\"escrowAction()\">\n        {{'SUBMIT'|translate}}\n      </button></center>\n      <br>\n      <center ng-if=\"ttype=='transfer'\"><qr text=\"$root.$storage.user.username\"></qr></center>\n      <center ng-if=\"ttype=='transfer'\"><i class=\"italic\">{{$root.$storage.user.username}}</i></center>\n    </div>\n  </ion-content>\n  <script id=\"my-modal.html\" type=\"text/ng-template\">\n    <ion-modal-view>\n      <div class=\"bar bar-header bar-positive item-input-inset\">\n        <label class=\"item-input-wrapper\">\n          <i class=\"icon ion-ios-search placeholder-icon\"></i>\n          <input type=\"search\" placeholder=\"{{'SEARCH'|translate}}\" ng-change=\"getUserAgent(data.query)\" ng-model=\"data.query\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n        </label>\n        <button class=\"button button-clear button-outline\" ng-click=\"closeUModal()\">\n          {{\"CANCEL\"|translate}}\n        </button>\n      </div>\n      <ion-content class=\"has-header\">\n        <div class=\"list\" ng-if=\"data.searchResult.length>0\">\n          <a class=\"item\" ng-repeat=\"x in data.searchResult\" ng-click=\"selectAgent(x)\">\n            <h2>{{'ESCROW_AGENT'|translate}}: {{x.name}}</h2>\n            <div ng-if=\"x.escrow\" class=\"wrap\">{{'ESCROW_TERMS'|translate}}: {{x.escrow.terms}}</div>\n            <p class=\"wrap\">{{'ESCROW_FEE'|translate}}: {{x.escrow.fees[$root.$storage.platformlunit]}} {{$root.$storage.platformlunit}} / {{x.escrow.fees[$root.$storage.platformdunit]}} {{$root.$storage.platformdunit}}\n            </p>\n          </a>\n        </div>\n        <center class=\"padding\" ng-if=\"data.searchResult.length==0\">\n          {{\"USER_NOTFOUND\"|translate}}\n        </center>\n      </ion-content>\n    </ion-modal-view>\n\n  </script>\n</ion-view>\n",
        controller: 'SendCtrl'
      }
    }
  })

  .state('app.follow', {
    url: '/follow',
    views: {
      'menuContent': {
        //templateUrl: 'templates/follow.html',
        template: "<ion-view view-cache=\"false\" view-title=\"{{'FOLLOW' | translate}}\">\n  <ion-content class=\"padding has-footer\" delegate-handle=\"listScroll\">\n    <div class=\"list list-inset\" ng-if=\"active=='followers'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.follower\" placeholder=\"{{'SEARCH_FOLLOWERS' | translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n    </div>\n    <div class=\"list list-inset\" ng-if=\"active=='following'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.following\" placeholder=\"{{'SEARCH_FOLLOWING' | translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n    </div>\n    <div class=\"list\" ng-if=\"active=='followers' && followers.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in followers | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.follower)\">{{f.follower}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowed(f.follower)\" ng-click=\"followUser(f.follower)\">\n        {{'FOLLOW_BACK' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowed(f.follower)\" ng-click=\"unfollowUser(f.follower)\">\n        {{'FOLLOWED' | translate}}\n        </button>\n      </div>\n    </div>\n    <div class=\"list\" ng-if=\"active=='following' && following.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in following | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.following)\">{{f.following}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowing(f.following)\" ng-click=\"unfollowUser(f.following)\">\n        {{'UNFOLLOW' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowing(f.following)\">\n        {{'FOLLOWING' | translate}}\n        </button>\n      </div>\n    </div>\n    <!--<ion-infinite-scroll on-infinite=\"loadMore()\" ng-if=\"lastd\" distance=\"2%\"></ion-infinite-scroll>-->\n  </ion-content>\n  <div class=\"bar profile bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-ios-people\" ng-class=\"{'active':active=='followers'}\" ng-click=\"change('followers')\"> {{'FOLLOWERS' | translate}} <span ng-if=\"followers.length>0\">({{followers.length}})</span></a>\n      <a class=\"button button-royal icon ion-person-add\" ng-class=\"{'active':active=='following'}\" ng-click=\"change('following')\"> {{'FOLLOWED' | translate}} <span ng-if=\"following.length>0\">({{following.length}})</span></a>\n    </div>\n  </div>\n</ion-view>\n",
        controller: 'FollowCtrl'
      }
    }
  })


  .state('app.exchange', {
    url: '/exchange/:username',
    views: {
      'menuContent': {
      	template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKET_VIEW' | translate}}\">\n  <ion-content class=\"padding has-footer exchange\">\n    <div class=\"\" ng-if=\"active=='buy'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.bids\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='sell'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.asks\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='open'\">\n      <p class=\"padding\" ng-if=\"openorders.length<1\">\n        {{'NOORDERS' | translate}} @{{username}}\n      </p>\n      <div ng-if=\"openorders.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{'AMOUNT' | translate}}</div>\n          <div class=\"col\">{{'TOTAL' | translate}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in openorders\">\n          <div class=\"col\">{{f.real_price|number:4}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.base}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.base}}</div>\n        </div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='history'\">\n      <!--<p class=\"padding\">Nothing here, yet...</p>-->\n      <div ng-if=\"recent_trades.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'DATE' | translate}}</div>\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{$root.$storage.platformsunit}}</div>\n          <div class=\"col\">{{$root.$storage.platformdollar}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in recent_trades\">\n          <div class=\"col\">{{f.date|timeago}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]/f.open_pays.split(\" \")[0]|number:6}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]|number:3}}</div>\n          <div class=\"col\">{{f.open_pays.split(\" \")[0]|number:3}}</div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-arrow-down-a\" ng-class=\"{'active':active=='buy'}\" ng-click=\"change('buy')\"> {{'BUY' | translate}}</a>\n      <a class=\"button button-royal icon ion-arrow-up-a\" ng-class=\"{'active':active=='sell'}\" ng-click=\"change('sell')\"> {{'SELL' | translate}}</a>\n      <a class=\"button button-royal icon ion-flag\" ng-class=\"{'active':active=='open'}\" ng-click=\"change('open')\">{{'OPEN' | translate}}</a>\n      <a class=\"button button-royal icon ion-ios-clock\" ng-class=\"{'active':active=='history'}\"  ng-click=\"change('history')\">{{'HISTORY' | translate}}</a>\n    </div>\n  </div>\n</ion-view>\n",
        //templateUrl: 'templates/exchange.html',
        controller: 'ExchangeCtrl'
      }
    }
  })

  .state('app.profile', {
    url: '/profile/:username',
    views: {
      'menuContent': {
        //templateUrl: 'templates/profile.html',
        template: "<ion-view view-title=\"\" hide-nav-bar=\"true\" view-cache=\"false\"><!--ng-class=\"{'mpb':$root.$storage.user.json_metadata.profile.cover_image}\"-->\n  <ion-content class=\"has-footer\" overflow-scroll=\"true\">\n    <div class=\"bar bar-subheader mysubheader bar-positive\" ng-style=\"$root.$storage.user.username != user.username?css:mcss\">\n      <button class=\"button button-icon button-clear ion-ios-arrow-back profilebtn\" on-tap=\"goBack()\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"followUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && !isAmFollowing(user.username)\"><!--<i class=\"fa fa-user-plus fa-lg\"></i>-->{{'FOLLOW'|translate}}</button>\n      <button class=\"button button-clear profilebtn_edit button-icon ion-ios-compose-outline\" on-tap=\"showEdits()\" ng-if=\"$root.$storage.user && $root.$storage.user.username === user.username\"></button>\n      <button class=\"button button-clear profilebtn_follow button-icon ion-camera\" on-tap=\"showCover()\" ng-if=\"$root.$storage.user && $root.$storage.user.username === user.username\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"unfollowUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && isAmFollowing(user.username)\"><!--button-icon button-clear<i class=\"fa fa-user-times fa-lg\"></i>-->{{'UNFOLLOW'|translate}}</button>&nbsp;\n      <div class=\"center\">\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user && $root.$storage.user.username == user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!($root.$storage.user.json_metadata.profile.profile_image||$root.$storage.user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" on-tap=\"showProfile()\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" on-tap=\"showProfile()\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\">\n                <span class=\"light\">@{{$root.$storage.user.username}}</span>\n                &nbsp;\n                <div class=\"reputation\">{{$root.$storage.user.reputation|reputation}}\n                </div>\n              </h4>\n              <div class=\"about\">{{$root.$storage.user.json_metadata.profile.about}}</div>\n              <div class=\"padding\">\n                <i class=\"icon ion-android-list\"></i>&nbsp;\n                {{$root.$storage.user.post_count}}&nbsp;\n                |&nbsp;\n                <i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;\n                {{$root.$storage.user.voting_power/100|number:2}}&nbsp;\n                |&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n                {{followdetails.follower_count}}&nbsp;\n                |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n                {{followdetails.following_count}}\n              </div>\n              <p><span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{$root.$storage.user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{$root.$storage.user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"$root.$storage.user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{$root.$storage.user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user.username !== user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!(user.json_metadata.profile.profile_image||user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" /></span>\n            <img ng-src=\"{{user.json_metadata.profile.profile_image || user.json_metadata.user_image}}\" ng-if=\"user.json_metadata.profile.profile_image || user.json_metadata.user_image\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\"><span class=\"light\">@{{user.username}}</span>&nbsp;<div class=\"reputation\">{{user.reputation|reputation}}</div></h4>\n              <p>{{user.json_metadata.profile.about}}</p>\n              <div class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{user.post_count}}&nbsp;|&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{user.voting_power/100|number:2}}&nbsp;|&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n              {{followdetails.follower_count}}&nbsp;\n              |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n              {{followdetails.following_count}}</div>\n              <p><span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n      </div>\n    </div>\n    <div class=\"has-mysubheader\">\n        <div class=\"box blue\" ng-if=\"active!='wallet'||active!='permissions'\">\n          <p class=\"padding\" ng-if=\"nonexist\">{{'NOTHING_HERE'|translate}}</p>\n          <ion-list>\n            <!--<div ng-repeat=\"(key, playlist) in profile\" class=\"item wrap\" on-tap=\"open(playlist)\">\n            <h3 class=\"bold\">{{playlist.root_title}}</h3>\n            <span ng-bind-html=\"playlist.body.substring(0,100)|parseUrl\"></span>\n            </div>-->\n            <div class=\"item\" ng-repeat=\"playlist in data.profile | orderBy:'-created' | limitTo:25 track by $index\" ng-class=\"{'item-thumbnail-left': playlist.json_metadata.image}\">\n              <img ng-src=\"{{playlist.json_metadata.image[0]}}\" on-tap=\"open(playlist)\" ng-if=\"playlist.json_metadata.image\" onerror=\"this.src='img/noimage.png'\"/>\n                <div on-tap=\"open(playlist)\">\n                <div class=\"wrap\">\n                  <h2><i class=\"fa fa-money positive\" ng-if=\"playlist.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"playlist.percent_steem_dollars === 0\"></i>{{playlist.root_title}}</h2>\n                </div>\n                <p ng-bind-html=\"playlist.body|limitTo:50|ldots|parseUrl\" ng-if=\"active!='blog'\"></p>\n                <div class=\"postdetails\"><i class=\"icon ion-android-time\"></i>&nbsp;{{playlist.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<i class=\"icon ion-android-person\"></i>&nbsp;{{playlist.author}}&nbsp;<div class=\"reputation\">{{playlist.author_reputation|reputation|number:0}}</div></div>\n                </div>\n                <div class=\"row gray profile\">\n                  <div class=\"col\"><ion-spinner ng-if=\"playlist.invoting\"></ion-spinner>\n                  <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost(playlist)\" ng-if=\"!playlist.upvoted\" on-hold=\"openSlider($event, playlist)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.upvoted\"></i>&nbsp;&nbsp;<span on-tap=\"$root.openInfo(playlist)\">{{playlist.net_votes}}</span>&nbsp;&nbsp;\n                   <!--<i class=\"fa fa-chevron-circle-down fa-lg\" on-tap=\"downvotePost(playlist)\" ng-if=\"!playlist.downvoted\"></i><i class=\"fa fa-chevron-circle-down fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.downvoted\"></i>--></div>\n                  <div class=\"col\" on-tap=\"openTooltip($event,playlist)\">&nbsp; <b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"playlist.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"playlist.max_accepted_payout.split(' ')[0] !== '0.000'\">{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</span></div>\n                  <div class=\"col\">&nbsp; <i class=\"icon ion-chatbubbles\"></i>&nbsp;{{playlist.children}}</div>\n                  <div class=\"col\" ng-if=\"playlist.author!==user.username && active!=='recent-replies'\">&nbsp; <i class=\"icon ion-arrow-return-right\"></i></div>\n                </div>\n            </div>\n          </ion-list>\n          <ion-infinite-scroll on-infinite=\"loadmore()\" ng-if=\"moreDataCanBeLoaded()\" distance=\"15%\"></ion-infinite-scroll>\n        </div>\n\n        <div class=\"padding\" ng-if=\"active=='transfers'\">\n          <p class=\"bold uppercase\">\n            {{'BALANCES'|translate}}\n          </p>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformname}} <br><span class=\"gray wrap\">{{'PROFILE_1'|translate:translationData }}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.balance | st | number}} {{$root.$storage.platformlunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformpower}} <br><span class=\"gray wrap\">{{'PROFILE_2'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.vesting_shares | sp | number}} {{$root.$storage.platformpunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformdollar}} <br><span class=\"gray wrap\">{{'PROFILE_3'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.sbd_balance | sbd | number}} {{$root.$storage.platformdunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{'ESTIMATED_VALUE'|translate}} <br><span class=\"gray wrap\">{{'PROFILE_4'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{$root.$storage.currency|getCurrencySymbol}} {{accounts.vesting_shares | sd:accounts.balance:accounts.sbd_balance | number}}\n            </div>\n          </div>\n          <p class=\"bold\">{{'TRANSACTION_HISTORY'|translate}}</p>\n          <div class=\"list list-inset\">\n            <div class=\"item\" ng-repeat=\"tr in transfers | orderBy:'-[0]' | limitTo:15 track by $index\">\n              <span>{{tr[1].timestamp | timeago}} - {{tr[1].op[0]}}</span>\n              <div ng-if=\"tr[1].op[0]=='comment_reward'\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='author_reward'\" class=\"wrap\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].steem_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='curation_reward'\">{{tr[1].op[1].reward}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='interest'\">{{tr[1].op[1].interest}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer_to_vesting'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].vesting_shares}} | {{tr[1].op[1].memo}}</div>\n              <p ng-if=\"tr[1].op[0]=='comment_reward'\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='author_reward'\" class=\"wrap\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='curation_reward'\" class=\"wrap\">@{{tr[1].op[1].comment_author}}/{{tr[1].op[1].comment_permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer'\">{{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer_to_vesting'\"> {{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].account}}</p>\n\n            </div>\n          </div>\n        </div>\n\n        <div class=\"box pink\" ng-if=\"active=='permissions'\">\n          <div class=\"list card\">\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'POSTING'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.posting.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.posting.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_5'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'OWNER'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.owner.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.owner.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_6'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'ACTIVE'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.active.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.active.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_7'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'MEMO'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.memo_key}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.memo_key}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_8'|translate}}\n              </p>\n            </div>\n          </div>\n        </div>\n    </div>\n    <script id = \"popoverPTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderrp.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          <div class=\"row\">\n              <div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n              <div class=\"col\">\n                <div class = \"item range range-positive\">\n             {{rangeValue}} <input type=\"range\" name=\"range2\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n                </div>\n              </div>\n              <div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSlider()\"></button></div>\n          </div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <!--<a class=\"button button-large button-positive icon ion-ios-heart\" ng-class=\"{'active':active=='feed'}\" on-tap=\"change('feed')\">&nbsp;Feeds</a>-->\n      <a class=\"button button-large button-positive icon ion-compose\" ng-class=\"{'active':active=='blog'}\" on-tap=\"change('blog')\">&nbsp;{{'BLOG'|translate}}</a>\n      <a class=\"button button-positive icon ion-document-text\" ng-class=\"{'active':active=='posts'}\" on-tap=\"change('posts')\">&nbsp;{{'POSTS'|translate}}</a>\n      <a class=\"button button-positive icon ion-chatbubbles\" ng-class=\"{'active':active=='recent-replies'}\" on-tap=\"change('recent-replies')\">&nbsp;{{'REPLIES'|translate}}</a>\n      <a class=\"button button-positive icon ion-card\" ng-class=\"{'active':active=='transfers'}\"  on-tap=\"change('transfers')\">&nbsp;{{'WALLET'|translate}}</a>\n      <!--<a class=\"button button-royal icon ion-lock-combination\" ng-class=\"{'active':active=='permissions'}\" on-tap=\"change('permissions')\">Keys</a>-->\n    </div>\n  </div>\n  <script id=\"my-edit.html\" type=\"text/ng-template\">\n    <ion-modal-view>\n      <ion-header-bar class='bar-positive'>\n         <h1 class=\"title\">{{\"EDIT\"|translate}}</h1>\n         <button class=\"button button-clear button-outline\" ng-click=\"closeEdits()\">\n          {{\"CANCEL\"|translate}}\n        </button>\n      </ion-header-bar>\n      <ion-content class=\"has-header\">\n        <div class=\"list\">\n          <div class=\"item item-divider\">\n            {{\"PROFILE\"|translate}}\n          </div>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ABOUT'|translate}}</span>\n            <textarea placeholder=\"{{'ABOUT'|translate}}\" ng-model=\"edit.profile.about\"></textarea>\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'LOCATION'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'LOCATION'|translate}}\" ng-model=\"edit.profile.location\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'DISPLAY_NAME'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'DISPLAY_NAME'|translate}}\" ng-model=\"edit.profile.name\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'WEBSITE'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'WEBSITE'|translate}}\" ng-model=\"edit.profile.website\">\n          </label>\n          <div class=\"item item-divider\">\n            {{\"ESCROW\"|translate}}\n          </div>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_TERMS'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'ESCROW_TERMS'|translate}}\" ng-model=\"edit.escrow.terms\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_FEE'|translate}} </span>\n            <input type=\"text\" placeholder=\"{{$root.$storage.platformlunit}}\" ng-model=\"edit.escrow.fees[$root.$storage.platformlunit]\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_FEE'|translate}} </span>\n            <input type=\"text\" placeholder=\"{{$root.$storage.platformdunit}}\" ng-model=\"edit.escrow.fees[$root.$storage.platformdunit]\">\n          </label><br>\n          <center>\n            <button class=\"button button-positive\" ng-click=\"saveEdit()\">\n            {{'SAVE_CHANGES'|translate}}\n            </button>\n          </center>\n      </div>\n      </ion-content>\n    </ion-modal-view>\n\n  </script>\n</ion-view>\n",
        controller: "ProfileCtrl"
      }
    }
  })

  .state('app.posts', {
    url: '/posts/:tags/:renew',
    params: {renew: true},
    views: {
      'menuContent': {
        //templateUrl: 'templates/posts.html',
        template: "<ion-view view-cache=\"false\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t<ion-nav-back-button>\n  \t\t</ion-nav-back-button>\n\t    <ion-nav-buttons side=\"left\">\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n\t      <a href class=\"button button-icon button-clear ion-navicon\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n\t    <ion-nav-title on-tap=\"showFilter()\">\n          <div class=\"page-title\">{{$root.$storage.filterName}} {{$root.$storage.tag}} &emsp; <i class=\"icon ion-arrow-down-b\"></i></div>\n        </ion-nav-title>\n\t    <ion-nav-buttons side=\"right\">\n\t      <!--<button class=\"button\" on-tap=\"testfunction()\">Test</button>-->\n\t      <button class=\"button button-icon ion-more\" ng-if=\"!$root.voiceOver\" on-tap=\"openMenuPopover($event)\"></button>\n\t      <a href class=\"button button-icon ion-more\" on-tap=\"openMenuPopover($event)\" ng-if=\"$root.voiceOver\">{{'OPTIONS'|translate}}</a>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-content class=\"has-header\" scroll=\"true\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t<ion-refresher pulling-text=\"{{'PULL_DOWN_TO_REFRESH'|translate}}\" on-refresh=\"refresh()\">\n  \t</ion-refresher>\n  \t\t<div ng-if=\"$root.$storage.view=='compact' && data.length>0\" class=\"masonry-layout\">\n\t    \t<div ng-repeat=\"d in data | regex:'category':'bm.*' track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list masonry-layout__panel-content\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t    \t<div class=\"item\">\n\t\t\t\t    <div on-tap=\"open(d)\">\n\t\t\t\t    <span ng-if=\"d.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{d.reblogged_by}}</span>\n\t\t\t\t    <p><h2 class=\"wrapword\"><i class=\"fa fa-money positive\" ng-if=\"d.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"d.percent_steem_dollars === 0\"></i> {{d.title}}</h2></p>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{d.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{d.author}}</b>&nbsp;<div class=\"reputation\">{{d.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{d.category|detransliterate:false}} &middot; {{d.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t    </div>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t    <div class=\"col\">\n\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event, d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event, d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i>{{'UPVOTE'|translate}}</a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{d | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(d)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{d.net_votes}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{d.children}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(s.author, s.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t      </div>\n\t\t\t\t    </div>\n\t\t\t  \t</div>\n\t\t\t  </div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div ng-if=\"$root.$storage.view=='card' && data.length>0\" class=\"masonry-layout\">\n\t\t\t<div ng-repeat=\"ds in data | regex:'category':'bm.*' track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list card masonry-layout__panel-content\" ng-if=\"ds\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\n\t\t\t\t<div class=\"item\" on-tap=\"open(ds)\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t\t\t\t<span ng-if=\"ds.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{ds.reblogged_by}}</span>\n\t\t\t\t    <h2 class=\"wrapword\"><i class=\"fa fa-money positive\" ng-if=\"ds.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"ds.percent_steem_dollars === 0\"></i> {{ds.title}}</h2>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{ds.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{ds.author}}</b>&nbsp;<div class=\"reputation\">{{ds.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{ds.category|detransliterate:false}} &middot; {{ds.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"item-body\">\n\t\t\t\t    <img class=\"full-image\" ng-src=\"{{ds.json_metadata.image[0]}}\" on-tap=\"open(ds)\" ng-if=\"ds.json_metadata.image[0]\" onerror=\"this.src='img/noimage.png'\"/>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t\t    <div class=\"col\">\n\t\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event, ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event, ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i>{{'UPVOTE'|translate}}</a>\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\">\n\t\t\t\t\t\t\t\t\t<b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(ds)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{ds.net_votes}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{ds.children}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(ds.author, ds.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t\t      </div>\n\t\t\t\t      </div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n    <ion-infinite-scroll ng-if=\"moreDataCanBeLoaded()\" on-infinite=\"loadMore()\" distance=\"15%\"></ion-infinite-scroll>\n    <br>\n    <script id = \"popoverT.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSlider.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          \t<div class=\"row\">\n          \t\t<div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n          \t\t<div class=\"col\">\n          \t\t\t<div class = \"item range range-positive\">\n\t\t\t\t\t   {{rangeValue}} <input type=\"range\" name=\"range1\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n\t\t\t\t\t</div>\n          \t\t</div>\n          \t\t<div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSlider()\"></button></div>\n          \t</div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostsCtrl'
      }
    }
  })

  .state('app.bookmark', {
    url: '/bookmark',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'BOOKMARKS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.bookmark\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.bookmark\" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.author}}</h2></p>\n        <p>{{item.permlink}}</p>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}</div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeBookmark($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'BookmarkCtrl'
      }
    }
  })

	.state('app.drafts', {
    url: '/drafts',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'DRAFTS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"drafts\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in drafts\" ng-click=\"$root.openDraft(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'TAGS' | translate}}:&nbsp;<b>{{item.tags}}</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeDraft(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'DraftsCtrl'
      }
    }
  })

	.state('app.images', {
    url: '/images',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'MANAGE' | translate}} {{'GALLERY' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"images\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in images\" class=\"item-thumbnail-left\">\n        <img ng-src=\"{{item.url}}\"/>\n        <p><h2>{{item.url}}</h2></p>\n\t\t\t  <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;</div></div>\n        <ion-option-button class=\"button-assertive\" ng-click=\"removeImage(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n\t\t    <ion-option-button class=\"button-calm\" ng-click=\"copyImage(item.url)\">{{'COPY' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"images.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"images.length==0\">{{'NOTHING_HERE'|translate}}</p>\n  </ion-content>\n</ion-view>\n",
        controller: 'ImagesCtrl'
      }
    }
  })

  .state('app.notifications', {
    url: '/notifications',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'NOTIFICATIONS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.notifications\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.notifications | orderBy: '-created' \" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t    <span>{{item.message}}</span>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'BY' | translate}}&nbsp;<b>{{item.author}}&nbsp;</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeNotification($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n  </ion-content>\n</ion-view>\n",
        controller: 'NotificationsCtrl'
      }
    }
  })


  .state('app.post', {
    url: '/post/:category/:author/:permlink',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t  <ion-nav-back-button>\n    \t</ion-nav-back-button>\n\t    <ion-nav-buttons side='left'>\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n        <a href class=\"button button-icon ion-more\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n      <ion-nav-title>\n      </ion-nav-title>\n\t    <ion-nav-buttons side='right'>\n      <span ng-if=\"!$root.voiceOver\">\n        <button class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i></button> &nbsp; \n\t      <button class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\"></button>\n      </span>\n      <span ng-if=\"$root.voiceOver\">\n        <a href class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i>{{'BOOKMARK'|translate}}</a> &nbsp; \n        <a href class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\">{{'SHARE'|translate}}</a>\n      </span>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-floating-menu menu-color=\"#387ef5\" menu-open-color=\"#387ef5\" has-footer=\"true\">\n    <ion-floating-item icon=\"ion-chatbubbles\" click=\"isreplying($root.$storage.sitem, true)\" ng-if=\"$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REPLY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-android-arrow-dropup-circle\" click=\"upvotePost($root.$storage.sitem)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'UPVOTE'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-edit\" click=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.author==$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'EDIT'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-image\" click=\"showImages(0)\" ng-if=\"isImages()\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'GALLERY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-arrow-return-right\" ng-if=\"$root.$storage.user.username !== $root.$storage.sitem.author\" click=\"$root.reBlog($root.$storage.sitem.author, $root.$storage.sitem.permlink)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REBLOG'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n  </ion-floating-menu>\n  <ion-content class=\"padding has-header\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\"><!---->\n    <div ng-if='$root.$storage.sitem'>\n      <p class=\"title h3\" ng-if=\"$root.$storage.sitem.root_title && $root.$storage.sitem.title==''\"><a href=\"#/app/post{{$root.$storage.sitem.url.split('#')[0]}}\">{{\"VIEW_CONTEXT\"|translate}}</a></p>\n    \t<p class=\"title h3\">{{$root.$storage.sitem.title}}</p>\n    \t<div class=\"stitle row gray\"><div class=\"col\">\n        <img class=\"round-avatar\" src=\"img/user_profile.png\" ng-src=\"{{$root.$storage.paccounts[$root.$storage.sitem.author].user_image||$root.$storage.paccounts[$root.$storage.sitem.author].profile.profile_image}}\" onerror=\"this.src=\\'img/user_profile.png\\'\" onabort=\"this.src=\\'img/user_profile.png\\'\" /> <b><a href=\"#/app/profile/{{$root.$storage.sitem.author}}\">{{$root.$storage.sitem.author}}</a></b>&nbsp;<div class=\"reputation\">{{$root.$storage.sitem.author_reputation|reputation|number:0}}</div>&middot;{{$root.$storage.sitem.created|timeago}} {{'IN'|translate}}&nbsp;{{$root.$storage.sitem.category|detransliterate:false}}</div><div class=\"pull-right\"><span ng-if=\"$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\">{{'DOWNVOTE'|translate}}</i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\">{{'UNVOTE_DOWNVOTED'|translate}}</i></span><span ng-if=\"!$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\"></i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\"></i></span></div></div>\n    \t<br><!---->\n      <div class=\"bodytext selectable\" ng-bind-html=\"$root.$storage.sitem.body | parseUrl \">\n      </div>\n\n      <div ng-if='$root.$storage.sitem.json_metadata.tags' class=\"tags\">\n        <div ng-repeat='tag in $root.$storage.sitem.json_metadata.tags'>\n          <span><div class=\"tag\" on-tap=\"openTag(tag, 5)\">{{tag|detransliterate:false}}</div></li>\n        </div>\n      </div>\n\n      <div class=\"row gray\">\n        <div class=\"col col-33\" ng-if=\"!$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\" on-hold=\"openSliderr($event, $root.$storage.sitem)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\"></i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n\n        <div class=\"col col-33\" ng-if=\"$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"icon ion-android-arrow-dropup-circle\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted\" on-hold=\"openSliderr($event, $root.$storage.sitem)\">{{'UPVOTE'|translate}}</i><i class=\"icon ion-android-arrow-dropup-circle positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted\">{{'UNVOTE_UPVOTED'|translate}}</i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n        <div class=\"col col-33\" on-tap=\"openTooltip($event,$root.$storage.sitem)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> {{$root.$storage.sitem | sumPostTotal:$root.$storage.currencyRate | number}}</div>\n        <div class=\"col\" on-tap=\"isreplying($root.$storage.sitem, true)\"><i class=\"fa fa-reply\"></i> {{$root.$storage.sitem.children}}</div>\n        <div class=\"col\" on-tap=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa  fa-pencil-square-o\"></i></div>\n        <div class=\"col\" on-tap=\"deletePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.net_votes==0 && $root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa fa-trash-o\"></i></div>\n      </div>\n      <center><button class=\"button button-positive button-outline button-icon ion-refresh icon-right\" on-tap=\"fetchComments($root.$storage.sitem.author, $root.$storage.sitem.permlink)\"><ion-spinner class=\"spinner-positive\" ng-if=\"$root.fetching\"></ion-spinner> {{\"COMMENTS\"|translate}}</button></center>\n      <br>\n      <div class=\"my-handle\"></div>\n      \n      <ion-thread comments=\"comments\"></ion-thread>\n    </div>\n    <script id = \"popoverTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content class=\"padding\">\n          <div class=\"row\">\n              <div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n              <div class=\"col\">\n                <div class = \"item range range-positive\">\n             {{rangeValue}} <input type=\"range\" name=\"range2\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n                </div>\n              </div>\n              <div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSliderr()\"></button></div>\n          </div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostCtrl'
      }
    }
  });
  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/app/posts//true');
  $ionicConfigProvider.navBar.alignTitle('left')
  $ionicConfigProvider.backButton.text('').icon('ion-chevron-left');
  $ionicConfigProvider.views.swipeBackEnabled(false);
  $ionicConfigProvider.views.maxCache(3);

  $animateProvider.classNameFilter( /\banimated\b/ );
  $ionicConfigProvider.scrolling.jsScrolling(false);

  if (window.cordova) {
      $logProvider.debugEnabled(false);
      $compileProvider.debugInfoEnabled(false);
  }

  $translateProvider.translations('en-US', require('./locales/ready/en')); //English
  $translateProvider.translations('ru-RU', require('./locales/ready/ru-RU')); //Russian
  $translateProvider.translations('de-DE', require('./locales/ready/de-DE')); //German
  $translateProvider.translations('fr-FR', require('./locales/ready/fr-FR')); //French
  $translateProvider.translations('es-ES', require('./locales/ready/es-ES')); //Spanish
  $translateProvider.translations('el-GR', require('./locales/ready/el-GR')); //Greek
  $translateProvider.translations('bg-BG', require('./locales/ready/bg-BG')); //Bulgarian
  $translateProvider.translations('nl-NL', require('./locales/ready/nl-NL')); //Dutch
  $translateProvider.translations('hu-HU', require('./locales/ready/hu-HU')); //Hungarian
  $translateProvider.translations('cs-CZ', require('./locales/ready/cs-CZ')); //Czech
  $translateProvider.translations('he-IL', require('./locales/ready/he-IL')); //Hebrew
  $translateProvider.translations('pl-PL', require('./locales/ready/pl-PL')); //Polish
  $translateProvider.translations('pt-PT', require('./locales/ready/pt-PT')); //Portuguese
  $translateProvider.translations('pt-BR', require('./locales/ready/pt-BR')); //Portuguese Brazil
  $translateProvider.translations('id-ID', require('./locales/ready/id-ID')); //Indonesian
  $translateProvider.translations('zh-TW', require('./locales/ready/zh-TW')); //Chinese traditional
  $translateProvider.translations('zh-CN', require('./locales/ready/zh-CN')); //Chinese simplified
  $translateProvider.translations('dolan', require('./locales/ready/dolan')); //Dolan
  $translateProvider.translations('sv-SE', require('./locales/ready/sv-SE')); //Chinese simplified
  $translateProvider.translations('uk-UA', require('./locales/ready/uk-UA')); //Ukrainian
  $translateProvider.translations('ms-MY', require('./locales/ready/ms-MY')); //Malay
  $translateProvider.translations('hr-HR', require('./locales/ready/hr-HR')); //Croatian
  $translateProvider.translations('fa-IR', require('./locales/ready/fa-IR')); //Persian
  $translateProvider.translations('it-IT', require('./locales/ready/it-IT')); //Italian
  $translateProvider.translations('fil-PH', require('./locales/ready/fil-PH')); //Filipino
  $translateProvider.translations('ar-SA', require('./locales/ready/ar-SA')); //Arabic

  $translateProvider.useSanitizeValueStrategy(null);

  $translateProvider.preferredLanguage('en-US');
  $translateProvider.fallbackLanguage('en-US');

});

app.run(function($ionicPlatform, $rootScope, $localStorage, $interval, $ionicPopup, $ionicLoading, $cordovaSplashscreen, $ionicModal, $timeout, $cordovaToast, APIs, $state, $log, $ionicScrollDelegate, $filter, $translate) {
  $rootScope.$storage = $localStorage;
  $rootScope.log = function(message) {
    $log.info(message);
  };

  $ionicPlatform.registerBackButtonAction(function (event) {
  if ( ($state.$current.name=="app.posts") ){
          // H/W BACK button is disabled for these states (these views)
          // Do not go to the previous state (or view) for these states. 
          // Do nothing here to disable H/W back button.
      } else {
          // For all other states, the H/W BACK button is enabled
          navigator.app.backHistory();
      }
  }, 100);
  $ionicPlatform.ready(function() {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
    if (!$rootScope.$storage.users) {
      $rootScope.$storage.users = [];
    }
    
    if (!$rootScope.$storage.theme) {
      $rootScope.$storage.theme = 'day';
    }

    if (!$rootScope.$storage.socketgolos)
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
    if (!$rootScope.$storage.socketsteem)
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";

    window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);

    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use(language.value).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  if (language.value.indexOf("en") == 0) {
                    $rootScope.$storage.language = 'en';            
                  }
                  $rootScope.$storage.language = language.value;
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }
    if (!$rootScope.$storage.chain){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.chain = "steem";
      $rootScope.$storage.currency = "usd";
      $rootScope.$storage.currencyRate = 1;
    }
    $rootScope.$storage.languages = [
      {id:'en', name: 'English'}, 
      {id:'es-ES', name: 'Espaol'}, 
      {id:'el-GR', name: ''}, 
      {id:'fr-FR', name: 'Franais'}, 
      {id:'de-DE', name: 'Deutsch'}, 
      {id:'ru-RU', name: ''}, 
      {id:'bg-BG', name: ''}, 
      {id:'nl-NL', name: 'Nederlands'}, 
      {id:'hu-HU', name: 'Magyar'}, 
      {id:'cs-CZ', name: 'etina'}, 
      {id:'he-IL', name: ''}, 
      {id:'pl-PL', name: 'Polski'}, 
      {id:'pt-PT', name: 'Portugus'}, 
      {id:'pt-BR', name: 'Portugus BR'},
      {id:'sv-SE', name: 'Svensk'},
      {id:'id-ID', name: 'Bahasa Indonesia'}, 
      {id:'zh-CN', name: ''}, 
      {id:'zh-TW', name: ''},
      {id:'dolan', name: 'Dolan'},
      {id:'uk-UA', name: ''},
      {id:'ms-MY', name: 'Bahasa Melayu'},
      {id:'hr-HR', name: 'Hrvatski'},
      {id:'fa-IR', name: 'Frsi'},
      {id:'it-IT', name: 'Italiano'},
      {id:'fil-PH', name: 'Wikang Filipino'},
      {id:'ar-SA', name: ''}
      
    ];
    if (!$rootScope.$storage.dir) {
      $rootScope.$storage.dir = 'ltr';
    }
    $rootScope.$storage.chains = [{id:'steem', name: 'Steem'}, {id:'golos', name: 'Golos'}];

    if (!$rootScope.$storage.currencies) {
      $rootScope.$storage.currencies = [
        {id:'btc', name: 'BTC', rate: 0, date: "1/1/2016"}, 
        {id:'usd', name: 'USD', rate: 0, date: "1/1/2016"}, 
        {id:'eur', name: 'EUR', rate: 0, date: "1/1/2016"}, 
        {id:'rub', name: 'RUB', rate: 0, date: "1/1/2016"}, 
        {id:'gbp', name: 'GBP', rate: 0, date: "1/1/2016"}, 
        {id:'jpy', name: 'JPY', rate: 0, date: "1/1/2016"}, 
        {id:'krw', name: 'KRW', rate: 0, date: "1/1/2016"}, 
        {id:'inr', name: 'INR', rate: 0, date: "1/1/2016"}, 
        {id:'cny', name: 'CNY', rate: 0, date: "1/1/2016"}, 
        {id:'uah', name: 'UAH', rate: 0, date: "1/1/2016"}, 
        {id:'sek', name: 'SEK', rate: 0, date: "1/1/2016"}, 
        {id:'try', name: 'TRY', rate: 0, date: "1/1/2016"},
        {id:'cad', name: 'CAD', rate: 0, date: "1/1/2016"},
        {id:'chf', name: 'CHF', rate: 0, date: "1/1/2016"},
        {id:'aud', name: 'AUD', rate: 0, date: "1/1/2016"},
        {id:'nok', name: 'NOK', rate: 0, date: "1/1/2016"},
        {id:'pln', name: 'PLN', rate: 0, date: "1/1/2016"},
        {id:'php', name: 'PHP', rate: 0, date: "1/1/2016"}
      ];
    } else {
      if (!$rootScope.$storage.addition) {
        $rootScope.$storage.addition = [
          {id:'cad', name: 'CAD', rate: 0, date: "1/1/2016"},
          {id:'chf', name: 'CHF', rate: 0, date: "1/1/2016"},
          {id:'aud', name: 'AUD', rate: 0, date: "1/1/2016"},
          {id:'nok', name: 'NOK', rate: 0, date: "1/1/2016"},
          {id:'pln', name: 'PLN', rate: 0, date: "1/1/2016"},
          {id:'php', name: 'PHP', rate: 0, date: "1/1/2016"}];
        $rootScope.$storage.currencies = $rootScope.$storage.currencies.concat($rootScope.$storage.addition);
      }
    }

    if (window.cordova) {
      if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {
        MobileAccessibility.isVoiceOverRunning(function(bool) {
          if (bool) {
              $rootScope.log("Screen reader: ON");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('center');
          } else {
              $rootScope.log("Screen reader: OFF");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('left');
          }
        });

      } else {
        $rootScope.voiceOver = false;
      }
    } else {
      $rootScope.voiceOver = false;
    }

    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'compact';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (navigator.splashscreen) {
      setTimeout(function() {
        navigator.splashscreen.hide();
      }, 1000);
    }
    $rootScope.log("app start ready");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }
    }, 1000);
    $rootScope.showAlert = function(title, msg) {
      var alertPopup = $ionicPopup.alert({
        title: title,
        template: msg
      });
      if (msg.indexOf("error")>-1) {
        //window.Api.initPromise.then(function(response) {
        $rootScope.log("broadcast error");
        //});
      }
      return alertPopup/*.then(function(res) {
        $rootScope.log('Thank you ...');
      });*/
    };
    $rootScope.showMessage = function(title, msg) {
      if (title) {
        if (window.cordova) {
          $cordovaToast.showLongBottom(title+": "+msg).then(function(success) {
            // success
            $rootScope.log("toast"+success);
          }, function (error) {
            // error
            $rootScope.log("toast"+error);
          });
        } else {
          $rootScope.showAlert(title, msg);
        }
      }
    };
    $rootScope.$on('show:loading', function(event, args){
      $rootScope.log('show:loading');
      $ionicLoading.show({
        noBackdrop : true,
        template: '<ion-spinner icon="ripple" class="spinner-energized"></ion-spinner>'
      });
    });
    $rootScope.$on('hide:loading', function(event, args){
      $rootScope.log('hide:loading');
      setTimeout(function() {
        $ionicLoading.hide();
      }, 1000);
    });

    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams){
      $rootScope.log("from "+fromState.name+" to "+toState.name);
    });

    $ionicPlatform.on('resume', function(){
      $rootScope.log("app resume");
      var steemRPC = require("steem-rpc");
      if (localStorage.getItem("socketUrl") === null) {
        localStorage.setItem("socketUrl", "wss://steemd.steemit.com");
      }
      window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);
      //window.steemJS = require("steemjs-lib");
      //window.golosJS = require("golosjs-lib");

      //if (!angular.isDefined($rootScope.timeint)) {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("Api ready state change: "+angular.toJson(response));
        $rootScope.timeint = $interval(function(){
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
            $rootScope.log("get_dynamic_global_properties " + response.head_block_number);
          });
        }, 15000);
      });
      //}
      /*window.FirebasePlugin.onNotificationOpen(function(data) {
        $rootScope.log(angular.toJson(data));
        if(data.tap){
          //Notification was received on device tray and tapped by the user.
          //console.log(JSON.stringify(data));
          if (data.author && data.permlink) {
            if (!$rootScope.$storage.pincode) {

              var alertPopup = $ionicPopup.confirm({
                title: data.title,
                template: data.body + $filter('translate')('OPENING_POST')
              });

              alertPopup.then(function(res) {
                $rootScope.log('Thank you for seeing alert from tray');
                if (res) {
                  setTimeout(function() {
                    $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                  }, 10);
                } else {
                  $rootScope.log("not sure to open alert");
                }
              });

            } else {
              $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
              $rootScope.pinenabled = true;
            }
          }
        } else{
          //Notification was received in foreground. Maybe the user needs to be notified.
          //alert( JSON.stringify(data) );
          if (data.author && data.permlink) {
            $rootScope.showMessage(data.title, data.body+" "+data.permlink);
          } else {
            $rootScope.showMessage(data.title, data.body);
          }
        }
      }, function(error) {
          console.error(error);
      });*/

      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }

      if (window.cordova) {
        if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {

          MobileAccessibility.isVoiceOverRunning(function(bool) {
            if (bool) {
                $rootScope.log("Screen reader: ON");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('center');
            } else {
                $rootScope.log("Screen reader: OFF");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('left');
            }
          });
        } else {
          $rootScope.voiceOver = false;
        }
      } else {
        $rootScope.voiceOver = false;
      }

    });
    $ionicPlatform.on('pause', function(){
      $rootScope.log("app pause");
      if (angular.isDefined($rootScope.timeint)) {
        $rootScope.log("cancel interval");
        $interval.cancel($rootScope.timeint);
        $rootScope.timeint = undefined;
        window.Api.close();
      }
    });

    $ionicPlatform.on('offline', function(){
      $rootScope.log("app offline");
    });

    $rootScope.init = function() {
      $rootScope.passcode = "";
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    };

    $rootScope.add = function(value) {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length < 4) {
        $rootScope.passcode = $rootScope.passcode + value;
        if($rootScope.passcode.length == 4) {
          $timeout(function() {
            $rootScope.log("PIN "+$rootScope.passcode);
            if ($rootScope.pintype == 3) {
              if ($rootScope.$storage.pincode == $rootScope.passcode) {
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('NOT_MATCH')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.pincode = undefined;
                  $rootScope.pintry = 0;
                  $rootScope.$broadcast("pin:failed");
                  $rootScope.closePin();
                }
              }
            }
            if ($rootScope.pintype == 0) {
              $rootScope.log("type 0: set pin");
              if ($rootScope.$storage.pincode) {
                $rootScope.pincheck = true;
                $rootScope.$broadcast("pin:check");
                $rootScope.closePin();
              } else {
                $rootScope.$storage.pincode = $rootScope.passcode;
                $rootScope.pinsubtitle = $filter('translate')('CONFIRM_PIN');
                $rootScope.passcode = "";
                $rootScope.pintype = 3;
                $rootScope.pintry = 0;
              }
            }
            if ($rootScope.pintype == 1) {
              $rootScope.log("type 1: check pin");
              if ($rootScope.$storage.pincode == $rootScope.passcode){
                $rootScope.$broadcast('pin:correct');
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('INCORRECT')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.$reset();
                  $rootScope.closePin();
                }
              }
            }

          }, 50);
        }
      }
    };

    $rootScope.delete = function() {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length > 0) {
        $rootScope.passcode = $rootScope.passcode.substring(0, $rootScope.passcode.length - 1);
      }
    }

    $ionicModal.fromTemplateUrl('templates/pincode.html', {
      scope: $rootScope
    }).then(function(modal) {
      $rootScope.pinmodal = modal;
    });
    $rootScope.closePin = function() {
      $rootScope.pinmodal.hide();
      if ($rootScope.pinenabled) {
        if ($rootScope.$storage.notifData) {
          var alertPopup = $ionicPopup.confirm({
            title: $rootScope.$storage.notifData.title,
            template: $rootScope.$storage.notifData.body + $filter('translate')('OPENING_POST')
          });
          alertPopup.then(function(res) {
            $rootScope.log('Thank you for seeing alert from tray');
            if (res) {
              $rootScope.getContentAndOpen({author:$rootScope.$storage.notifData.author, permlink:$rootScope.$storage.notifData.permlink});
              $rootScope.$storage.notifData = undefined;
            } else {
              $rootScope.log("not sure to open alert");
              $rootScope.$storage.notifData = undefined;
            }
            $rootScope.pinenabled = false;
          });
        }
      }
    };
    $rootScope.openPin = function(type) {
      $rootScope.passcode = "";
      if (type == 0) {
        $rootScope.pintype = 0;
        $rootScope.pintitle = $filter('translate')('SET_PIN');
        $rootScope.pinsubtitle = $filter('translate')('SET_PIN');
      }
      if (type == 1) {
        $rootScope.pintype = 1;
        $rootScope.pintry = 0;
        $rootScope.pintitle = $filter('translate')('ENTER_PIN');
        $rootScope.pinsubtitle = $filter('translate')('ENTER_PIN');
      }
      $rootScope.pinmodal.show();
    };
    $rootScope.$on("pin:new", function(){
      $rootScope.pincheck = false;
      $rootScope.openPin(0);
    });
    $rootScope.$on("pin:check", function(){
      $rootScope.pincheck = true;
      $rootScope.openPin(1);
    });


    $ionicModal.fromTemplateUrl('templates/info.html', {
      scope: $rootScope
      //animation: "null"
    }).then(function(modal) {
      $rootScope.infomodal = modal;
    });
    $rootScope.openInfo = function(xx) {
      if (xx.active_votes.length==0) {
        window.Api.database_api().exec("get_active_votes", [xx.author, xx.permlink]).then(function(dd){
          xx.active_votes = dd;
        });
      }
      $rootScope.voters = xx;
      $rootScope.infomodal.show();
    };

    $rootScope.closeInfo = function() {
      $rootScope.infomodal.hide();
      //$rootScope.infomodal.remove();
    };

    String.prototype.replaceAt=function(index, character) {
        return this.substr(0, index) + character + this.substr(index+character.length);
    }
		$rootScope.openDraft = function(item){
			item.operation_type = item.post_type;
			$rootScope.$storage.spost = item;
			$state.go('app.posts');
			$rootScope.$broadcast('openPostModal');
		}
    $rootScope.getContentAndOpen = function(item) {

      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_content", [item.author, item.permlink]).then(function(result){
          var _len = result.active_votes.length;
          for (var j = _len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === $rootScope.$storage.user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
          result.json_metadata = angular.fromJson(result.json_metadata);
          var item = result;
          $rootScope.$storage.sitem = item;
          setTimeout(function() {
            //$state.go('app.post');
            $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});

          }, 5);

          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      });
      $rootScope.$broadcast('hide:loading');
    };

    $rootScope.reBlog = function(author, permlink) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('REBLOG_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          $rootScope.$broadcast('show:loading');
          if ($rootScope.$storage.user) {
              $rootScope.mylogin = new window.ejs.Login();
              $rootScope.mylogin.setRoles(["posting"]);
              var loginSuccess = $rootScope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                var json;

                json = ["reblog",{account:$rootScope.$storage.user.username, author:author, permlink:permlink}];

                tr.add_type_operation("custom_json", {
                  id: 'follow',
                  required_posting_auths: [$rootScope.$storage.user.username],
                  json: JSON.stringify(json)
                });
                localStorage.error = 0;
                tr.process_transaction($rootScope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REBLOG_TEXT')+" "+localStorage.errormessage)
                  } else {
                    //$scope.refreshFollowers();
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('REBLOGGED_POST'));
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
            $rootScope.$broadcast('hide:loading');
          } else {
            $rootScope.$broadcast('hide:loading');
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
    };

    $rootScope.votePost = function(post, type, afterward) {
      post.invoting = true;
      var tt = 1;
      if (type === "upvote") {
        tt = 1;
      }
      if (type === "downvote") {
        tt = -1;
      }
      if (type === "unvote") {
        tt = 0;
      }
      $rootScope.log('voting '+tt);
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
      if ($rootScope.$storage.user) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          var mylogin = new window.ejs.Login();
          mylogin.setRoles(["posting"]);
          //console.log($rootScope.$storage.user);
          var loginSuccess = mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window.ejs.TransactionBuilder();
            tr.add_type_operation("vote", {
                voter: $rootScope.$storage.user.username,
                author: post.author,
                permlink: post.permlink,
                weight: $rootScope.$storage.voteWeight*tt || 10000*tt
            });
            localStorage.error = 0;
            tr.process_transaction(mylogin, null, true);  

            setTimeout(function() {
              post.invoting = false;
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
								if (tt>0){
									post.upvoted = true;
								} else if (tt<0) {
									post.downvoted = true;
								} else {
									post.upvoted = false;
									post.downvoted = false;
								}
                if (afterward === 'fetchContent') {
                  $rootScope.$broadcast(afterward, { any: {author: post.author, permlink: post.permlink} });
                } else {
                  $rootScope.$broadcast(afterward);
                }
              }
              $rootScope.$broadcast('hide:loading');

            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
            $rootScope.$broadcast('hide:loading');
            post.invoting = false;
          }
          $rootScope.$broadcast('hide:loading');
          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      } else {
        $rootScope.$broadcast('hide:loading');
        post.invoting = false;
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    $rootScope.isWitnessVoted = function() {
      if ($rootScope.$storage.user && $rootScope.$storage.user.witness_votes.indexOf("good-karma")>-1) {
        return true;
      } else {
        return false;
      }
    };
    $rootScope.voteWitness = function() {
        var confirmPopup = $ionicPopup.confirm({
          title: $filter('translate')('ARE_YOU_SURE'),
          template: $filter('translate')('VOTE_FOR_WITNESS')+" @good-karma"
        });
        confirmPopup.then(function(res) {
          if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              if ($rootScope.$storage.user.password || $rootScope.$storage.user.privateActiveKey) {
                $rootScope.mylogin = new window.ejs.Login();
                $rootScope.mylogin.setRoles(["active"]);
                var loginSuccess = $rootScope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_witness_vote", {
                      account: $rootScope.$storage.user.username,
                      approve: true,
                      witness: "good-karma"
                  });
                  localStorage.error = 0;

                  tr.process_transaction($rootScope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error === 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshFollowers();
                      $rootScope.showMessage($filter('translate')('SUCCESS'),$filter('translate')('VOTED_FOR_WITNESS')+' @good-karma');
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                }
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          } else {
            $rootScope.log('You are not sure');
          }
        });
    };

    $rootScope.following = function(xx, mtype) {
      $rootScope.$broadcast('show:loading');
      $rootScope.log(xx);
      if ($rootScope.$storage.user) {
          $rootScope.mylogin = new window.ejs.Login();
          $rootScope.mylogin.setRoles(["posting"]);
          var loginSuccess = $rootScope.mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window.ejs.TransactionBuilder();
            var json;
            if (mtype === "follow") {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: ["blog"]}];
            } else {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: []}];
            }

            tr.add_type_operation("custom_json", {
              id: 'follow',
              required_posting_auths: [$rootScope.$storage.user.username],
              json: angular.toJson(json)
            });
            localStorage.error = 0;
            tr.process_transaction($rootScope.mylogin, null, true);

            setTimeout(function() {
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
                //$scope.refreshFollowers();
                $rootScope.$broadcast('current:reload');
              }
            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
          }
        $rootScope.$broadcast('hide:loading');
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    setTimeout(function() {
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_feed_history", []).then(function(r){
        //$rootScope.log(r);
          $rootScope.$storage.base = r.current_median_history.base.split(" ")[0];
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(r){
            $rootScope.log(r);
            $rootScope.$storage.steem_per_mvests = (Number(r.total_vesting_fund_steem.substring(0, r.total_vesting_fund_steem.length - 6)) / Number(r.total_vesting_shares.substring(0, r.total_vesting_shares.length - 6))) * 1e6;
          });
        });
      });
    }, 10);
    if (!angular.isDefined($rootScope.$storage.notifications)) {
      $rootScope.$storage.notifications = [];
    }
    $rootScope.$on('changedChain', function(){
      console.log('chain differs');
      localStorage.socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
      window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);
      window.Api.close();
      window.Api = window.steemRPC.Client.get({url: localStorage.socketUrl}, true);
      
      window.Api.initPromise.then(function(response) {  
        angular.forEach($rootScope.$storage.users, function(v,k){
          if (v.chain == $rootScope.$storage.chain){
            $rootScope.$storage.user = v;
          }
        });
        if (!$rootScope.$$phase) {
          $rootScope.$apply();
        }
      });
    
      if ($rootScope.$storage.chain == 'steem'){
        $rootScope.$storage.platformname = "Steem";
        $rootScope.$storage.platformpower = "Steem Power";
        $rootScope.$storage.platformsunit = "Steem";
        $rootScope.$storage.platformdollar = "Steem Dollar";
        $rootScope.$storage.platformdunit = "SBD";
        $rootScope.$storage.platformpunit = "SP";
        $rootScope.$storage.platformlunit = "STEEM";
        $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      } else {
        $rootScope.$storage.platformname = "";
        $rootScope.$storage.platformpower = " ";
        $rootScope.$storage.platformsunit = "";
        $rootScope.$storage.platformdollar = "";
        $rootScope.$storage.platformdunit = "GBG";
        $rootScope.$storage.platformpunit = "GOLOSP";
        $rootScope.$storage.platformlunit = "GOLOS";
        $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
        //$scope.socket = "wss://golos.steem.ws";
      }
      
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    });
    function checkDate(date, ignore) {
      var eold = 86400000; //1 * 24 * 60 * 60 * 1000; //1 day old
      var now = new Date().getTime();
      var old = new Date(date).getTime();
      return ignore||now-old>=eold;
    }
    $rootScope.$on('changedCurrency', function(event, args){
      var xx = args.currency;
      var ignore = args.enforce;
      console.log(xx);
      var resultObject = $rootScope.$storage.currencies.filter(function ( obj ) {
          return obj.id === xx;
      })[0];
      //searchObj(xx, $rootScope.$storage.currencies);
      if (checkDate(resultObject.date, ignore)) {
        if ($rootScope.$storage.chain == 'steem'){
          APIs.getCurrencyRate("USD", xx ).then(function(res){
            $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate);
            $rootScope.$storage.currencies.filter(function(obj){
              if (obj.id == xx) {
                obj.rate = $rootScope.$storage.currencyRate;
                obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
              }
            });
          });
        } else {
          APIs.getCurrencyRate("XAU", xx ).then(function(res){
            //XAU - 31.1034768g
            //GBG rate in mg. so exchangeRate/31103.4768
            $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate)/31103.4768;
            $rootScope.$storage.currencies.filter(function(obj){
              if (obj.id == xx) {
                obj.rate = $rootScope.$storage.currencyRate;
                obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
              }
            });
            //console.log($rootScope.$storage.currencyRate);
          });
        }
      } else {
        $rootScope.$storage.currencyRate = resultObject.rate;
      }
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    });

    if (window.cordova) {
      if (!ionic.Platform.isWindowsPhone()) {
        if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
          //window.FirebasePlugin.grantPermission();
        }

        /*window.FirebasePlugin.getToken(function(token) {
            // save this server-side and use it to push notifications to this device
            $rootScope.log("device "+token);
            $rootScope.$storage.deviceid = token;
            if ($rootScope.$storage.user) {
              APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            } else {
              APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            }
        }, function(error) {
            console.error(error);
        });*/

        FCMPlugin.getToken(function(token){
          // save this server-side and use it to push notifications to this device
          $rootScope.log("device "+token);
          $rootScope.$storage.deviceid = token;
          if ($rootScope.$storage.user) {
            APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          } else {
            APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          }
        });

        /*window.FirebasePlugin.onTokenRefresh(function(token) {
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        }, function(error) {
          console.error(error);
        });*/
        FCMPlugin.onTokenRefresh(function(token){
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        });

        /*window.FirebasePlugin.onNotificationOpen(function(data) {
            $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.tap){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        }, function(error) {
            console.error(error);
        });
        */

        //FCMPlugin.onNotification( onNotificationCallback(data), successCallback(msg), errorCallback(err) )
        //Here you define your application behaviour based on the notification data.
        FCMPlugin.onNotification(function(data){
          $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.wasTapped){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      if (data.chain !== $rootScope.$storage.chain) {
                        $rootScope.$storage.chain = data.chain;
                        $rootScope.$broadcast('changedChain');
                        $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
                      }
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        });
      }

    }

  });
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/index.js","/posts")
},{"./config":101,"./controllers":102,"./locales/ready/ar-SA":104,"./locales/ready/bg-BG":105,"./locales/ready/cs-CZ":106,"./locales/ready/de-DE":107,"./locales/ready/dolan":108,"./locales/ready/el-GR":109,"./locales/ready/en":110,"./locales/ready/es-ES":111,"./locales/ready/fa-IR":112,"./locales/ready/fil-PH":113,"./locales/ready/fr-FR":114,"./locales/ready/he-IL":115,"./locales/ready/hr-HR":116,"./locales/ready/hu-HU":117,"./locales/ready/id-ID":118,"./locales/ready/it-IT":119,"./locales/ready/ms-MY":120,"./locales/ready/nl-NL":121,"./locales/ready/pl-PL":122,"./locales/ready/pt-BR":123,"./locales/ready/pt-PT":124,"./locales/ready/ru-RU":125,"./locales/ready/sv-SE":126,"./locales/ready/uk-UA":127,"./locales/ready/zh-CN":128,"./locales/ready/zh-TW":129,"./services":130,"buffer":11,"currency-symbol-map":27,"diff-match-patch":29,"esteem-lib":56,"pBGvAp":74,"steem-rpc":88}],104:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": " ",
	"LOGOUT": " ",
	"PROFILE": " ",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "          ",
	"ABOUT_2": "  { } . ",
	"ABOUT_3": "        .                  {{platformname}}  {{sitename}}.",
	"ABOUT_4": "",
	"ABOUT_5": "2.                  .",
	"ABOUT_6": "        ",
	"ABOUT_7": "       ",
	"ABOUT_8": "  good-karma ",
	"ABOUT_9": "/ ",
	"ABOUT_10": "  ",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "  ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": " ",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ",
	"POST_2": "     ",
	"OPTIONS": "",
	"RESTEEMED_BY": "  ",
	"NOTHING_HERE": "     ",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}}         .   {{platformname}}  {{platformpower}}     .",
	"PROFILE_2": "{{platformpower}}              .               .",
	"PROFILE_3": "      {{platformsunit}} {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7 ",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "     .         .",
	"OWNER": "",
	"PROFILE_6": "          .              .",
	"ACTIVE": "",
	"PROFILE_7": "          .",
	"MEMO": "",
	"PROFILE_8": "      .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": "  good-karma",
	"PIN_CODE": " ",
	"PIN_TEXT": "  PIN     . <br/> <br/> <b>:</b>      4        pin         .       .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "          ! <br/> </b>:/b>        . (        ).",
	"VOTE": "",
	"COMMENT_TEXT": "             ! <br/> <b>:</b>      <b></b>  .",
	"COMMENT": "",
	"FOLLOW_TEXT": "        !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "       /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "         !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "                 . <br/> <br/> <b>:</b>     /       ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " ",
	"LOGIN_1": "       ",
	"LOGIN_2": "                  .",
	"LOGIN_3": "        .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": "  ",
	"SIGN_UP_NOW": "  ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "  ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": " 50%/50%",
	"POWERUP": "  100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": "  ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": "  ",
	"INCORRECT": " ",
	"OPENING_POST": "  ",
	"SET_PIN": "  ",
	"ENTER_PIN": " ",
	"ARE_YOU_SURE": "  ",
	"REBLOG_TEXT": "      ",
	"BROADCAST_ERROR": "    !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !                        .",
	"LOGIN_FAIL_A": "  !                        .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": " ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": "",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": "  ",
	"SET_CUSTOM_URL": "  ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "   ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": "  ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "     ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": "  ",
	"UPLOAD_COMPLETED": "  ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "       ",
	"INFO": "",
	"QR_TEXT": "       ",
	"BALANCE_TEXT": "        ",
	"NONEXIST_USER": "       !",
	"TRANSFER_TEXT": "     ",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": " ",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": " ",
	"VOTES": "  ",
	"PAYOUT": " ",
	"COMMENTS": "",
	"TRENDING_30": "  ",
	"SORT_POST_BY": "  ",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": "  ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": "   ",
	"POST_LATER": "  !",
	"SAVED": " ",
	"CLEARED": " ",
	"FLAGGING_TEXT": "            . <br><br>     : <ul><li>  </li> <li>   </li> <li>      </li></ul>",
	"REQUEST_LIMIT_TEXT": "    .  / !",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": " ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "           !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "    !",
	"SETTINGS_UPDATED": "  ",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     ",
	"LOGIN_TO_X": "          /.      .",
	"GALLERY": "",
	"TRANSLATIONS": "  ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "    !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": "   ",
	"MANAGE": " ",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    !",
	"PULL_DOWN_TO_REFRESH": "  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .    /  .",
	"ABOUT_11": "<b><br> <br></b>-          .<br>-        .<br>-          .<br>-             .<br>-             .<br>-         .<br>-     .<br>-              <br>-    . <br> -      .<br>-            .<br>-      /   .<br>-   .<br>-    .<b><br><br> <br></b>.        .<br>.                           .<br>.        <br>.         <br><br>     .<br>",
	"FOUNDER": "  ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": " ",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "",
	"DISPLAY_NAME": " "
}
},{}],105:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ",
	"ABOUT_1": "       !",
	"ABOUT_2": "  ,     ,   .",
	"ABOUT_3": "      .       , , , ,       .. ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "1.        .",
	"ABOUT_5": "2.         ,   ,            .",
	"ABOUT_6": "3.       .",
	"ABOUT_7": "4.          .",
	"ABOUT_8": "  good-karma.",
	"ABOUT_9": "   :",
	"ABOUT_10": " ",
	"REMOVE": "",
	"MARKET_VIEW": "  ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "  ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": " ",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": " ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "  ,    ",
	"POST_2": "  ,    -  .",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": "  ...",
	"BALANCES": "  ",
	"PROFILE_1": "{{platformname}}   ,         . {{platformname}}      {{platformpower}}    .",
	"PROFILE_2": "{{platformpower}}   .    ,        .",
	"PROFILE_3": " {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "     7      {{platformname}}.",
	"TRANSACTION_HISTORY": "  ",
	"POSTING": "",
	"PROFILE_5": "        .         .",
	"OWNER": "",
	"PROFILE_6": "              .              .",
	"ACTIVE": "",
	"PROFILE_7": "   ,          .",
	"MEMO": "",
	"PROFILE_8": "          .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "-",
	"PIN_TEXT": "-     . <br/><br/> ,   4     ,     -      ,        .         .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,      . <br/>        .",
	"VOTE": "",
	"COMMENT_TEXT": "  ,       !<br/>        .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,          !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,         !",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,     !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "      .\n <br/><br/>     ,   ,   .",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": ", !",
	"LOGIN_1": "        .",
	"LOGIN_2": "      , ,   .",
	"LOGIN_3": "          .",
	"LOGIN_4": "        .     !",
	"DONT_HAVE": " ?",
	"SIGN_UP_NOW": "  !",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "   ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": "50% / 50%",
	"POWERUP": " 100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  -",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "  ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " -",
	"INCORRECT": "",
	"OPENING_POST": "  .",
	"SET_PIN": " -.",
	"ENTER_PIN": " -.",
	"ARE_YOU_SURE": "  ?",
	"REBLOG_TEXT": "  ,    ?",
	"BROADCAST_ERROR": "  ,  !",
	"SUCCESS": "!",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": " ! ,  ,                ,     .",
	"LOGIN_FAIL_A": " ! ,  ,               ,     .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  witness",
	"VOTED_FOR_WITNESS": "  witness",
	"AGO": "-",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "- .",
	"DOWNVOTE_FLAG": "     .",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": " URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": "   .",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "    ",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": "  ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "     ",
	"INFO": "",
	"QR_TEXT": "  QR     ",
	"BALANCE_TEXT": " ,      !",
	"NONEXIST_USER": " ,        !",
	"TRANSFER_TEXT": "  ,     ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ...",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "   30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": "  ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": "  ",
	"POST_SUBMITTED": "  ",
	"POST_LATER": " -!",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "             .<br><br>        ,  ,  ,      .",
	"REQUEST_LIMIT_TEXT": "    .   /!",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": "",
	"MODIFY_PICTURE": "   ",
	"MODIFY_COVER_PICTURE": "   ",
	"ACTIVE_KEY_REQUIRED_TEXT": ",    ,       !",
	"RESET_PICTURE_TEXT": "    ",
	"RESET_COVER_PICTURE_TEXT": "    ",
	"UPDATE_REQUIRES_RESTART": "    !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "      .",
	"LOGIN_TO_X": "          ,  / . ,    .",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "    !",
	"POST_IS_DRAFT": "    !",
	"SWIPE_LEFT": "   ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "     !",
	"PULL_DOWN_TO_REFRESH": "   ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "\n",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "a",
	"CURRENCY_TEXT": "          .",
	"ABOUT_11": "<br><b>  eSteem</b><br>-      ,   . <br>-       ,      .<br>-  ,    ,    .         .<br>-      o.     .<br>-   .         - .<br>-   \"\",     -.<br>-    .<br>-        , , ,   .<br>-  .<br>-    ,  .<br>-  .     ,  ,   .<br>-   /  . <br> -   . <br>    . <br><br><b></b> <br>1.       . <br>2.         .            .          . <br>3.       . <br>4.        - <br><br>eSteem   Steem  Golos.<br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": "   ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": "Escrow ",
	"RATIFICATION_DEADLINE": "   ",
	"ESCROW_EXPIRATION": "  Escrow",
	"ESCROW_FEE": "Escrow ",
	"ESCROW_TERMS": "Escrow ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "   ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "O",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "",
	"DISPLAY_NAME": ""
}
},{}],106:[function(require,module,exports){
module.exports={
	"HOME": "Dom",
	"LOGIN": "Pihlen",
	"LOGOUT": "Odhlen",
	"PROFILE": "Profil",
	"FOLLOW": "Nsleduj",
	"BOOKMARKS": "Zloky",
	"TRANSFER": "Pevod",
	"MARKET": "Trh",
	"SETTINGS": "Nastaven",
	"ABOUT": "O ns",
	"ABOUT_1": "kde kdokoliv me zskat odmnu za svj obsah!",
	"ABOUT_2": "je postaven na {{platformname}} platform. Aplikaci vytvoil",
	"ABOUT_3": "a je to komunitn, open-source mobiln projekt. Nabz pstup k obsahu pro ten, komentovn, hlasovn, vystavovn pspvk, pevod vdlk atd. poskytovan {{platformname}} blockchainem a {{sitename}}.",
	"ABOUT_4": "1. Aplikace nem pstup k uivatelovm fondm ani je nikdy nevlastn.",
	"ABOUT_5": "2. Aplikace nabz bezpenostn model na stran klienta. Privtn kle jsou dreny lokln a nikdy nejsou poslny dnm serverm.",
	"ABOUT_6": "3. Aplikace nabz jednoduch, atraktivn uivatelsk rozhran a zitky.",
	"ABOUT_7": "4. Aplikace po uivatelch nikdy nepoaduje dn osobn informace.",
	"ABOUT_8": "Hlasujte pro svdka good-karma",
	"ABOUT_9": "Kontakt/Zptn vazba:",
	"ABOUT_10": "Vce informac:",
	"REMOVE": "Odstranit",
	"MARKET_VIEW": "Zobrazen trhu",
	"PRICE": "Cena",
	"AMOUNT": "Suma",
	"TOTAL": "Celkem",
	"NOORDERS": "dn oteven objednvky pro",
	"DATE": "Datum",
	"BUY": "Nkup",
	"SELL": "Prodej",
	"OPEN": "Oteveno",
	"HISTORY": "Historie",
	"FOLLOW_BACK": "Sledovat",
	"FOLLOWED": "Sledovn",
	"UNFOLLOW": "Pestat sledovat",
	"FOLLOWING": "Sledovan",
	"FOLLOWERS": "Sledujc",
	"SEARCH_FOLLOWERS": "Hledej sledujc",
	"SEARCH_FOLLOWING": "Hledej sledovan",
	"BY": "km",
	"IN": "v",
	"MENU": "Menu",
	"BOOKMARK": "Zloka",
	"REBLOG": "Reblog",
	"UPVOTE": "Hlasujte pro",
	"DOWNVOTE": "Hlasujte proti",
	"UNVOTE_DOWNVOTED": "Vrate hlas proti",
	"UNVOTE_UPVOTED": "Vrate hlas pro",
	"REPLY": "Odpovzte",
	"EDIT": "Upravte",
	"POST_1": "Pro zobrazen voleb peje vlevo na komente",
	"POST_2": "Pro zobrazen subkoment klepnte na komente",
	"OPTIONS": "Volby",
	"RESTEEMED_BY": "Resteemovno km",
	"NOTHING_HERE": "Pipravuje se",
	"BALANCES": "Zstatky",
	"PROFILE_1": "{{platformname}}, obchodovateln tokeny, kter mohou bt kdykoliv pevedeny. {{platformname}} mohou bt pevedeny na {{platformpower}} v procesu zvanm powering up.",
	"PROFILE_2": "{{platformpower}}, vlivov tokeny, kter posiluj pi dlouhodobm dren a hlasovn o pspvcch. m vce jich nkdo dr, tm vce me ovlivnit odmny druhch a sm zskat odmnu za sprvn hlasovn.",
	"PROFILE_3": "Tokeny v cen okolo {{platformsunit}} v {{platformname}}.",
	"ESTIMATED_VALUE": "Oekvan cena",
	"PROFILE_4": "Oekvan cena je zaloena na 7 denn prmrn cen {{platformname}}.",
	"TRANSACTION_HISTORY": "Historie transakc",
	"POSTING": "Odesln",
	"PROFILE_5": "Odeslac kl je pouvn pro odesln pspvk a hlasovn. Ml by bt rozdln od aktivnho a vlastnickho kle.",
	"OWNER": "Vlastnk",
	"PROFILE_6": "Vlastnick kl je hlavn kl tu a je poadovn pro zmnu ostatnch t. Privtn kl nebo heslo pro vlastnick kl by mly bt dreny pokud mono co nejvce offline.",
	"ACTIVE": "Aktivn",
	"PROFILE_7": "Aktivn kl se pouv pro pevody a zadn objednvek na vnitnm trhu.",
	"MEMO": "Poznmka",
	"PROFILE_8": "Poznmkov kl se pouv pro tvorbu a ten poznmek.",
	"BLOG": "Blog",
	"POSTS": "Pspvky",
	"REPLIES": "Odpovdi",
	"WALLET": "Penenka",
	"TAG": "ttek",
	"USER": "Uivatel",
	"CLOSE": "Zavt",
	"TO": "do",
	"ASSET": "Aktivum",
	"SEND": "Poslat",
	"SECURITY": "Zabezpeen",
	"AVAILABLE": "Dostupn",
	"PUBLIC_MEMO": "Veejn poznmka",
	"TO_DESC": "Uivatel nap. good-karma",
	"PIN_CODE": "Pin kd",
	"PIN_TEXT": "PIN kd pomh zabezpeit aplikaci a data. <br/><br/><b>Poznmka:</b> Jakmile je aktivn, mte maximln 4 pokusy na odemen. Pokud pin zapomenete nebo neuspjete, aplikace odstran uivatelsk data tohoto pihlen. Mete se opt pihlsit a pokraovat v prci.",
	"NOTIFICATIONS": "Oznmen",
	"VOTE_TEXT": "Pokud nkdo hlasuje pro V pspvek, obdrte upozornn! <br/> <b>Poznmka:</b> Tato oznmen obsahuj vhu hlasu (a u je to hlas pro, proti, nebo odvoln hlasovn).",
	"VOTE": "Hlasujte",
	"COMMENT_TEXT": "Pokud nkdo komentuje V pspvek nebo koment, obdrte oznmen! <br/> <b>Poznmka:</b> Upozornn je zaslno t pokud nkdo <b>edituje</b> svj koment.",
	"COMMENT": "Poznmka",
	"FOLLOW_TEXT": "Obdrte upozornn kdy vs nkdo zane sledovat, nebo sledovn zru!",
	"MENTIONS": "Zmnky",
	"MENTIONS_TEXT": "Pokud vs nkdo zmn v pspvku/komenti, obdrte upozornn!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Pokud nkdo resteemuje v pspvek, dostanete oznmen!",
	"CONFIGURATIONS": "Konfigurace",
	"VOTING": "Hlasovn",
	"VOTING_TEXT": "Vha hlasu nebo procento ovlivuje hlasovac slu aplikace, take mete regulovat vi odmny vaeho hlasovn. <br/><br/><b>Poznmka:</b> To ovlivn vhu hlasu/procento i pi hlasovn proti a je to platn v cel aplikaci.",
	"SERVER": "Server",
	"SERVER_TEXT": "Doporuen",
	"SAVE_CHANGES": "Uloit zmny",
	"VOTERS_INFO": "Informace o volii",
	"WELCOME_BACK": "Vtejte zpt!",
	"LOGIN_1": "Pro pokraovn se pihlate svm uivatelskm jmnem a heslem.",
	"LOGIN_2": "Odeslac kl je uren pro vystavovan pspvk, komente, hlasovn, sledovn.",
	"LOGIN_3": "Aktivn kl je uren pro pevody a aktualizaci profilovho obrzku.",
	"LOGIN_4": "Uivatelovy pihlaovac daje jsou dreny lokln v pstroji. Po odhlen jsou odstranny!",
	"DONT_HAVE": "Nemte et?",
	"SIGN_UP_NOW": "Zite si et",
	"CANCEL": "Zruit",
	"ADVANCED": "Pokroil",
	"ACTIVE_PRIKEY": "Aktivn soukrom kl",
	"POSTING_PRIKEY": "Odeslac soukrom kl",
	"MASTER_PASS": "Hlavn heslo",
	"USERNAME": "Uivatelsk jmno",
	"CARD_VIEW": "Zobrazen karta",
	"COMPACT_VIEW": "Zobrazen kompakt",
	"SEARCH": "Hledat",
	"SUBMIT_A_STORY": "Vlo lnek",
	"REPLYTO": "Odpovzte",
	"POST": "Odeslat",
	"PREVIEW": "Nhled",
	"DEFAULT": "Nastaven 50% / 50%",
	"POWERUP": "100% Steem Power",
	"DECLINE_PAYOUT": "Odmtnou vplatu",
	"SAVE_FOR_LATER": "Uschovat na pozdji",
	"CLEAR": "Vyistit",
	"POST_CONTENT": "Odeslat obsah",
	"COMMENT_CONTENT": "Komentovat obsah",
	"TITLE": "Nadpis",
	"TAGS": "ttky",
	"NOT_MATCH": "Neshoduje se",
	"CONFIRM_PIN": "Potvrte PIN",
	"INCORRECT": "Nesprvn",
	"OPENING_POST": "vodn pspvek",
	"SET_PIN": "Nastavte PIN",
	"ENTER_PIN": "Vlote PIN",
	"ARE_YOU_SURE": "Urit?",
	"REBLOG_TEXT": "Reblog je nevratn, pejete si pokraovat?",
	"BROADCAST_ERROR": "Chyba odesln, zkuste znovu!",
	"SUCCESS": "spch",
	"REBLOGGED_POST": "Reblogovan pspvek!",
	"LOGIN_FAIL": "Pihlen selhalo! Ujistte se, e jste se pihlsili hlavnm heslem, nebo e jste pi pihlen zadali Odeslac kl, pokud jste zvolili Pokroil reim.",
	"LOGIN_FAIL_A": "Pihlen selhalo! Ujistte se, e jste se pihlsili hlavnm heslem, nebo e jste pi pihlen zadali Aktivn kl, pokud jste zvolili Pokroil reim.",
	"WARNING": "Vstraha",
	"VOTE_FOR_WITNESS": "Hlasovn o svdcch",
	"VOTED_FOR_WITNESS": "Hlasoval pro svdka",
	"AGO": "ped",
	"FROM_NOW": "od te",
	"SECS": "vteiny",
	"A_MIN": "minuta",
	"MINS": "minuty",
	"AN_HOUR": "hodina",
	"HOURS": "hodiny",
	"A_DAY": "den",
	"DAYS": "dny",
	"A_MONTH": "msc",
	"MONTHS": "msce",
	"A_YEAR": "rok",
	"YEARS": "roky",
	"MIN_READ": "minut ten",
	"DOWNVOTE_FLAG": "Hlasujte proti nebo oznate jako zvadn",
	"CAPTURE_PICTURE": "Zachyte obrzek",
	"SELECT_PICTURE": "Vyberte obrzek",
	"SET_CUSTOM_URL": "Nastavte zkaznick URL",
	"INSERT_PICTURE": "Vlote obrzek",
	"ERROR": "Chyba",
	"UPLOAD_ERROR": "Nahrajte chybu",
	"CAMERA_CANCELLED": "Fotoapart zruen",
	"SET_URL": "Nastavte URL",
	"DIRECT_LINK_PICTURE": "Pm odkaz na obrzek",
	"COMMENT_SUBMITTED": "Koment vloen!",
	"DELETE_COMMENT": "Mazn komente je nevratn...",
	"DELETED_COMMENT": "Odstrann koment",
	"UPLOADING_PICTURE": "Nahrvn obrzku",
	"UPLOAD_COMPLETED": "Nahrvn hotovo",
	"UPLOAD_FAILED": "Nahrvn selhalo",
	"PASSWORD_INCORRECT": "Heslo nebo jmno tu bylo nesprvn",
	"INFO": "Informace",
	"QR_TEXT": "QR kd umstte do oblasti pro sken",
	"BALANCE_TEXT": "Ujistte se, e mte dostaten zstatek pro transakci!",
	"NONEXIST_USER": "Uivatel, ktermu se snate pevst fondy neexistuje!",
	"TRANSFER_TEXT": "Jste si jisti, e si pejete provst pevod?",
	"CONFIRMATION": "Potvrzen",
	"TX_BROADCASTED": "Transakce je odeslna",
	"FEED": "Zdroj",
	"TRENDING": "V trendu",
	"HOT": "hav",
	"NEW": "Nov",
	"PROMOTED": "Propagovan",
	"VOTES": "Hlasy",
	"PAYOUT": "Vplata",
	"COMMENTS": "Komente",
	"TRENDING_30": "V trendu po 30 dn",
	"SORT_POST_BY": "Roztdit pspvky dle",
	"PAYOUT_CYCLE": "Cyklus vplaty",
	"POTENTIAL_PAYOUT": "Potenciln vplata",
	"PAST_PAYOUT": "Minul vplata",
	"AUTHOR_PAYOUT": "Autorsk odmna",
	"CURATION_PAYOUT": "Kurtorsk odmna",
	"POST_SUBMITTED": "lnek je odesln!",
	"POST_LATER": "Uschovat pro pozdj odesln!",
	"SAVED": "Uloen",
	"CLEARED": "Vyitno",
	"FLAGGING_TEXT": "Oznaen pspvku za zvadn me odebrat odmny a uinit tento materil mn viditelnm.<br><br>Toto oznaen by mlo bt pouito na nsledujc: <ul><li>podvod nebo plagitorstv</li><li>projevy nenvisti nebo internetov trolovn</li><li>zmrn chybn kategorizace obsahu nebo spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limit poadavk dosaen. Zkontrolujte ostatn trendy/ttky!",
	"POST_IS_UNBOOKMARK": "Pspvek je odstrann ze zloek!",
	"POST_IS_BOOKMARK": "Pspvek je pidn do zloek!",
	"RESET": "Resetovat",
	"MODIFY_PICTURE": "Upravit profilov obrzek",
	"MODIFY_COVER_PICTURE": "Upravit tituln obrzek",
	"ACTIVE_KEY_REQUIRED_TEXT": "Zadejte Aktivn soukrom kl, pokud jste vybrali pokroil md pstupu!",
	"RESET_PICTURE_TEXT": "Tmto resetujete profilov obrzek uivatele!",
	"RESET_COVER_PICTURE_TEXT": "Tmto resetujete tituln obrzek uivatele!",
	"UPDATE_REQUIRES_RESTART": "Aktualizace serveru vyaduje restart!",
	"SETTINGS_UPDATED": "Nastaven jsou aktualizovna.",
	"LANGUAGES": "Jazyky",
	"LANGUAGES_TEXT": "Zde mete zmnit jazyk aplikace.",
	"LOGIN_TO_X": "Tato operace vyaduje pihlen uivatele hlavnm heslem, Aktivnm/Odeslacm klem. Prosm pihlate se a opakujte pokus.",
	"GALLERY": "Galerie",
	"TRANSLATIONS": "Peloili",
	"SHARE": "Akcie",
	"MARKETPLACE": "Trh",
	"EXCHANGE": "Burza",
	"DRAFTS": "Koncepty",
	"POST_IS_UNDRAFT": "Pspvek je z koncept odstrann !",
	"POST_IS_DRAFT": "Pspvek je pidn do koncept!",
	"SWIPE_LEFT": "Pro zobrazen monost peje vlevo",
	"MANAGE": "Spravovat",
	"IMAGE_REMOVED": "Obraz je odstrann",
	"COPY": "Koprovat",
	"NO_IMAGE": "Dosud jste nenahrl dn obraz.",
	"PULL_DOWN_TO_REFRESH": "Pro obnoven zathni dol",
	"EXTERNAL_APPS": "Extern aplikace",
	"PLUGINS": "Pdavn moduly",
	"SUGGEST": "Nvrh",
	"COMING_SOON": "Ji brzy chystme",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Zde mete zmnit blockchain nebo vchoz platformu.",
	"CURRENCY": "Mna",
	"CURRENCY_TEXT": "Zde mete zmnit svoji vchoz mnu. V tto mn se pot budou zobrazovat odmny za pspvky/komente.",
	"ABOUT_11": "<br><b>Seznam funkc</b> <br>-Pstup k jedinenm lnkm v kadm tmatu, kter jsou zajmav ke ten<br>Angaovn se s autory komentovnm a diskutovnm tmat.<br>Hlasovnm pspvk odmovat autory stejn tak jako zskvat kurtorsk odmny. <br>Publikovat lnky, pspvky do blogu a hostovat je zdarma, dostvat odmny za publikovn a zskvat stoupence. <br>Pst lnky kdekoliv a kdykoliv a mt monost uloit jejich koncepty pro pozdj publikaci. <br>Uloit si oblben lnky do zloek pro pozdj peten. <br>Vmna nebo proplacen vaeho vdlku. <br>Monost poslat vae prostedky jakmukoliv autorovi, uivatelovi, pteli, stoupencm atd.<br>Nsledovat zajmav autory, bloggery. <br>Prohlet si pspvky stoupenc a autor, kter sledujete. <br>Dostvat oznmen, abyste zstali v kontaktu se svmi stoupenci a diskuzemi, ve kterch jste zapojen<br>Prohledvat zajmav tagy/kategorie lnk a zajmav autory. <br>Pizpsobte si svj profil. <br>A mnohem vce funkc, kter pijdou <br><br><b>Bezpenost</b> <br>1. Aplikace nem pstup ani nedr penn prostedky uivatel. <br>2. Aplikace nabz model zabezpeen na stran klienta se soukrommi kli umstn lokln a nikdy je neodesl na server, jste sami zodpovdn za zlohovn Vaich hesel. <br>3. Aplikace nabz jednoduch, atraktivn uivatelsk rozhran. <br>4. Aplikace nabz dal vrstvu zabezpeen pomoc pin-kdu <br><br>eSteem podporuje platformy Steem a Golos. <br>",
	"FOUNDER": "Zakladatel a hlavn vvoj",
	"ADD_ACCOUNT": "Pidat et",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow zprostedkovatel",
	"RATIFICATION_DEADLINE": "Konen termn ratifikace",
	"ESCROW_EXPIRATION": "Escrow expirace",
	"ESCROW_FEE": "Escrow poplatek",
	"ESCROW_TERMS": "Escrow podmnky",
	"NIGHT_MODE": "Non reim",
	"DAY_MODE": "Denn reim",
	"VIEW_CONTEXT": "Zobrazit pln kontext",
	"USER_NOTFOUND": "Uivatel nenalezen",
	"APPROVE": "Schvlit",
	"DISPUTE": "Odporovat",
	"RELEASE": "Vydat",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Odeslat",
	"RECEIVER": "Pjemce",
	"LOCATION": "Umstn",
	"WEBSITE": "Web",
	"DISPLAY_NAME": "Zobrazovan jmno"
}
},{}],107:[function(require,module,exports){
module.exports={
	"HOME": "Startseite",
	"LOGIN": "Anmelden",
	"LOGOUT": "Abmelden",
	"PROFILE": "Profil",
	"FOLLOW": "Folgen",
	"BOOKMARKS": "Lesezeichen",
	"TRANSFER": "bertragen",
	"MARKET": "Markt",
	"SETTINGS": "Einstellungen",
	"ABOUT": "Info",
	"ABOUT_1": "die Plattform, bei der jeder fr seine Inhalte vergtet wird!",
	"ABOUT_2": "wird untersttzt durch die {{platformname}} Plattform. Anwendung erstellt von",
	"ABOUT_3": "und ist eine mobile Open Source Anwendung, die durch die Community untersttzt wird. Die Anwendung erlaubt den Zugriff auf die Inhalte fr das Lesen, Kommentieren, Abstimmen, Posten, bertragen von Einknften etc. Die Funktionen werden durch die {{platformname}} Blockchain und {{sitename}} bereitgestellt.",
	"ABOUT_4": "1. Die Anwendung greift niemals auf Ihre Mittel zu.",
	"ABOUT_5": "2. Die Anwendung nutzt ein Client-basiertes Sicherheitskonzept, dass auf Schlsseln basiert, die lokal vorhanden sind und niemals an einen Server bertragen werden.",
	"ABOUT_6": "3. Die Anwendung bietet ein simples, attraktives Interface.",
	"ABOUT_7": "4. Die Anwendung fragt niemals nach persnlichen Daten.",
	"ABOUT_8": "Good-Karma als Zeuge abstimmen",
	"ABOUT_9": "Kontakt/Feedback:",
	"ABOUT_10": "Weitere Informationen:",
	"REMOVE": "Entfernen",
	"MARKET_VIEW": "Marktansicht",
	"PRICE": "Preis",
	"AMOUNT": "Menge",
	"TOTAL": "Gesamt",
	"NOORDERS": "Keine offenen Order",
	"DATE": "Datum",
	"BUY": "Kaufen",
	"SELL": "Verkaufen",
	"OPEN": "Offen",
	"HISTORY": "Historie",
	"FOLLOW_BACK": "Ebenfalls folgen",
	"FOLLOWED": "Sie folgen nun diesem Nutzer",
	"UNFOLLOW": "Nicht mehr folgen",
	"FOLLOWING": "Sie folgen diesem Nutzer",
	"FOLLOWERS": "Personen, die Ihnen folgen",
	"SEARCH_FOLLOWERS": "Durchsuchen der Nutzer, die Ihnen folgen",
	"SEARCH_FOLLOWING": "Durchsuchen der Nutzer, denen Sie folgen",
	"BY": "von",
	"IN": "in",
	"MENU": "Men",
	"BOOKMARK": "Lesezeichen",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Downvote entfernen",
	"UNVOTE_UPVOTED": "Upvote entfernen",
	"REPLY": "Antworten",
	"EDIT": "Editieren",
	"POST_1": "Nach links wischen um Kommentare zu sehen",
	"POST_2": "Auf Kommentare tippen um dessen Antworten zu sehen",
	"OPTIONS": "Optionen",
	"RESTEEMED_BY": "Resteemed von",
	"NOTHING_HERE": "Hier gibt es noch nichts zu sehen...",
	"BALANCES": "Kontostand",
	"PROFILE_1": "{{platformname}}, handelbare Tokens die zu jeder Zeit bertragen werden knnen. {{platformname}} kann in {{platformpower}} konvertiert werden. Dieser Prozess heit \"powering up\".",
	"PROFILE_2": "{{platformpower}}, tokens die sich automatisch vermehren, wenn Sie besessen werden und beeinflussen, wie viel Ihre Stimme wert ist. Desto mehr Sie besitzen, desto mehr Einfluss hat Ihre Stimme.",
	"PROFILE_3": "Tokens mit einem Wert von etwa {{platformsunit}} in {{platformname}}.",
	"ESTIMATED_VALUE": "Geschtzter Wert",
	"PROFILE_4": "Der geschtzte Wert basiert auf einem 7-Tage-Durchschnittswert von {{platformname}}.",
	"TRANSACTION_HISTORY": "Transaktions Historie",
	"POSTING": "Beitrag",
	"PROFILE_5": "Der \"posting key\" wird fr das Verffentlichen und Abstimmen bentigt. Er sollte sich vom \"active key\" und vom \"owner key\" unterscheiden.",
	"OWNER": "Besitzer",
	"PROFILE_6": "Der \"owner key\" ist der Hauptschlssel fr den Account und wird bentigt, um andere Schlssel zu ndern. Der \"private key\" oder das Passwort sollten nur offline verfgbar sein.",
	"ACTIVE": "Aktiv",
	"PROFILE_7": "Der \"active key\" wird benutzt, um bertragungen durchzufhren oder Gebote auf dem Markt zu platzieren.",
	"MEMO": "Notiz",
	"PROFILE_8": "Der \"memo key\" wird bentigt, um Memos zu lesen und zu speichern.",
	"BLOG": "Blog",
	"POSTS": "Beitrge",
	"REPLIES": "Antworten",
	"WALLET": "Brieftasche",
	"TAG": "Tag",
	"USER": "Benutzer",
	"CLOSE": "Schlieen",
	"TO": "Empfnger",
	"ASSET": "Zusatz",
	"SEND": "Senden",
	"SECURITY": "Sicherheit",
	"AVAILABLE": "Verfgbar",
	"PUBLIC_MEMO": "ffentliche Notiz",
	"TO_DESC": "Benutzer z.B. good-karma",
	"PIN_CODE": "Pin",
	"PIN_TEXT": "Der PIN dient der Sicherheit der Anwendung, sowie deren Daten. <br/><br/><b>Hinweis:</b> Nach Aktivierung stehen maximal 4 Anmeldeversuche zur Verfgung. Danach werden die Daten des aktuell angemeldeten Nutzers gelscht und die Anwendung kann wieder normal genutzt werden.",
	"NOTIFICATIONS": "Benachrichtigungen",
	"VOTE_TEXT": "Sie werden informiert, sobald jemand fr Ihre Beitrge abgestimmt hat! <br/> <b>Hinweis:</b> Die Notifikation gibt aufschluss ber die Art der Abstimmung (Positiv, Negativ, wieder entfernt) und die Gewichtung der Stimme.",
	"VOTE": "Abstimmen",
	"COMMENT_TEXT": "Sie werden informiert, sobald jemand auf Ihre Beitrge oder Kommentare antwortet!<br/> <b>Hinweis:</b> Sie werden auch beim ndern eines Beitrags/Kommentars erneut informiert.",
	"COMMENT": "Kommentar",
	"FOLLOW_TEXT": "Sie werden benachrichtigt, sobald Ihnen jemand folgt oder nicht mehr folgt!",
	"MENTIONS": "Erwhnungen",
	"MENTIONS_TEXT": "Sie werden benachrichtigt, sobald Sie von jemanden in Kommentaren oder Beitragen erwhnt werden!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Sie werden benachrichtigt sobald jemand Ihren Post erneut verffentlicht hat!",
	"CONFIGURATIONS": "Einstellungen",
	"VOTING": "Abstimmung",
	"VOTING_TEXT": "Das Gewicht / der prozentuale Anteil der Stimme beeinflusst die Menge der Vergtung fr den Autor. <br/><br/><b>Hinweis:</b> Diese Einstellung ndert auch die Gewichtung/ den prozentualen Anteil fr negative Stimmen. Diese Einstellung wird in der gesamten Anwendung verwendet.",
	"SERVER": "Server",
	"SERVER_TEXT": "Empfohlen",
	"SAVE_CHANGES": "nderungen speichern",
	"VOTERS_INFO": "Abstimmungsinformationen",
	"WELCOME_BACK": "Willkommen zurck!",
	"LOGIN_1": "Melden Sie sich mit Ihrem Benutzernamen und Passwort an, um fortzufahren.",
	"LOGIN_2": "Der \"Posting key\" wird fr das Verffentlichen von Beitragen, Kommentaren und Abstimmungen, sowie dem Folgen von Nutzern bentigt.",
	"LOGIN_3": "Der \"Active key\" wird fr die bertragung und das aktualisieren des Profilbilds bentigt.",
	"LOGIN_4": "Zugangsdaten werden local im Gert gespeichert und nach dem Logout gelscht!",
	"DONT_HAVE": "Noch keinen Account?",
	"SIGN_UP_NOW": "Jetzt registrieren",
	"CANCEL": "Abbrechen",
	"ADVANCED": "Erweitert",
	"ACTIVE_PRIKEY": "Aktiver privater Zugangsschlssel",
	"POSTING_PRIKEY": "Privater Zugangsschlssel fr das Verffentlichen von Inhalten",
	"MASTER_PASS": "Master- /Haupt-Passwort",
	"USERNAME": "Benutzername",
	"CARD_VIEW": "Karten-Ansicht",
	"COMPACT_VIEW": "Kompaktansicht",
	"SEARCH": "Suchen",
	"SUBMIT_A_STORY": "Beitrag erstellen",
	"REPLYTO": "Antworten",
	"POST": "Verffentlichen",
	"PREVIEW": "Vorschau",
	"DEFAULT": "Standard 50% / 50%",
	"POWERUP": "Power erhhen mit 100%",
	"DECLINE_PAYOUT": "Auf die Auszahlung verzichten",
	"SAVE_FOR_LATER": "Fr einen spteren Zeitpunkt speichern",
	"CLEAR": "LSCHEN",
	"POST_CONTENT": "Inhalt verffentlichen",
	"COMMENT_CONTENT": "Inhalt kommentieren",
	"TITLE": "Titel",
	"TAGS": "Tags",
	"NOT_MATCH": "KEINE BEREINSTIMMUNG",
	"CONFIRM_PIN": "PIN besttigen",
	"INCORRECT": "FALSCH",
	"OPENING_POST": "ffne Beitrag",
	"SET_PIN": "Setzen Sie Ihren PIN",
	"ENTER_PIN": "Bitte geben Sie Ihren PIN ein",
	"ARE_YOU_SURE": "Sind Sie sicher?",
	"REBLOG_TEXT": "Das neu verffentlichen kann nicht rckgngig gemacht werden, wollen Sie weiter machen?",
	"BROADCAST_ERROR": "Fehler beim verffentlichen, bitte versuchen Sie es erneut!",
	"SUCCESS": "Erfolgreich",
	"REBLOGGED_POST": "Neu verffentlicht!",
	"LOGIN_FAIL": "Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, fr den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
	"LOGIN_FAIL_A": "Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, fr den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
	"WARNING": "Warnung",
	"VOTE_FOR_WITNESS": "Fr einen Witness abstimmen",
	"VOTED_FOR_WITNESS": "Erfolgreich fr einen Witness abgestimmt",
	"AGO": "seit",
	"FROM_NOW": "ab jetzt",
	"SECS": "Sekunden",
	"A_MIN": "eine Minute",
	"MINS": "Minuten",
	"AN_HOUR": "eine Stunde",
	"HOURS": "Stunden",
	"A_DAY": "einen Tag",
	"DAYS": "Tage",
	"A_MONTH": "einen Monat",
	"MONTHS": "Monate",
	"A_YEAR": "ein Jahr",
	"YEARS": "Jahre",
	"MIN_READ": "min. lesen",
	"DOWNVOTE_FLAG": "Negativ bewerten oder markieren",
	"CAPTURE_PICTURE": "Bild aufnehmen",
	"SELECT_PICTURE": "Bild auswhlen",
	"SET_CUSTOM_URL": "Eigene URL",
	"INSERT_PICTURE": "Bild einfgen",
	"ERROR": "Fehler",
	"UPLOAD_ERROR": "Upload fehlgeschlagen",
	"CAMERA_CANCELLED": "Kamera geschlossen",
	"SET_URL": "URL setzen",
	"DIRECT_LINK_PICTURE": "Direkter Link zum Bild",
	"COMMENT_SUBMITTED": "Kommentar abgegeben!",
	"DELETE_COMMENT": "Gelschte Kommentare knnen nicht widerhergestellt werden...",
	"DELETED_COMMENT": "Kommentar gelscht",
	"UPLOADING_PICTURE": "Bild wird hochgeladen",
	"UPLOAD_COMPLETED": "Hochladen abgeschlossen",
	"UPLOAD_FAILED": "Hochladen fehlgeschlagen",
	"PASSWORD_INCORRECT": "Passwort oder Benutzername nicht korrekt",
	"INFO": "Information",
	"QR_TEXT": "Platzieren Sie einen QR code innerhalb des Bereichs",
	"BALANCE_TEXT": "Stellen Sie sicher, dass Sie ber ausreichende Mittel verfgen!",
	"NONEXIST_USER": "Sie verfgen nicht ber ausreichende Mittel fr diese Aktion!",
	"TRANSFER_TEXT": "Wollen Sie wirklich bertragen?",
	"CONFIRMATION": "Besttigungen",
	"TX_BROADCASTED": "Die Transaktion wurde bertragen",
	"FEED": "Feed",
	"TRENDING": "Im Trend",
	"HOT": "Beliebt",
	"NEW": "Neu",
	"PROMOTED": "Beworben",
	"VOTES": "Stimmen",
	"PAYOUT": "Auszahlung",
	"COMMENTS": "Kommentare",
	"TRENDING_30": "Seit 30 Tagen im Trend",
	"SORT_POST_BY": "Sortieren der Posts nach:",
	"PAYOUT_CYCLE": "Auszahlungskreislauf",
	"POTENTIAL_PAYOUT": "Voraussichtliche Auszahlungen",
	"PAST_PAYOUT": "Vergangene Auszahlungen",
	"AUTHOR_PAYOUT": "Auszahlung an den Autor",
	"CURATION_PAYOUT": "Kurationsauszahlungen",
	"POST_SUBMITTED": "Post wurde verffentlicht!",
	"POST_LATER": "Posts zur spteren Verffentlichung!",
	"SAVED": "Gespeichert",
	"CLEARED": "Geleert",
	"FLAGGING_TEXT": "Das markieren eines Posts kann zum Verlust der Vergtung fhren und verringert die Sichtbarkeit des Posts.<br><br>Sie sollten Posts nur unter markieren, wenn einer der folgenden Punkte zutrifft: <ul><li>Betrug oder Plagiat</li><li>Vulgre Ausdrucke oder \"Trolling\"</li><li>Mutwillig falsch kategorisiert oder Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Maximale Anzahl von Anfragen erreicht. Bitte schauen Sie sich andere trend/tags an!",
	"POST_IS_UNBOOKMARK": "Post von den Lesezeichen entfernt!",
	"POST_IS_BOOKMARK": "Post zu den Lesezeichen hinzugefgt!",
	"RESET": "Zurcksetzen",
	"MODIFY_PICTURE": "Profilbild ndern",
	"MODIFY_COVER_PICTURE": "Titelbild ndern",
	"ACTIVE_KEY_REQUIRED_TEXT": "Bitte tragen Sie den \"Active private key\" ein, wenn Sie den erweiterten Login Modus gewhlt haben!",
	"RESET_PICTURE_TEXT": "Zurcksetzen des Profilbilds",
	"RESET_COVER_PICTURE_TEXT": "Zurcksetzen des Titelbilds.",
	"UPDATE_REQUIRES_RESTART": "Aufgrund eines Serverupdates muss ein die Anwendung neugestartet werden!",
	"SETTINGS_UPDATED": "Einstellungen aktualisiert!",
	"LANGUAGES": "Sprachen",
	"LANGUAGES_TEXT": "Hier kann die Sprache der Anwendung gendert werden.",
	"LOGIN_TO_X": "Fr die gewnschte Operation mssen Sie angemeldet sein. Bitte melden Sie sich mit Ihrem Passwort oder dem \"active/posting\"-Schlssel sein",
	"GALLERY": "Gallerie",
	"TRANSLATIONS": "Mitwirkende an der bersetzung",
	"SHARE": "Teilen",
	"MARKETPLACE": "Marktplatz",
	"EXCHANGE": "Brse",
	"DRAFTS": "Entwrfe",
	"POST_IS_UNDRAFT": "Beitrag aus Entwrfen entfernt!",
	"POST_IS_DRAFT": "Beitrag zu Entwrfen hinzugefgt!",
	"SWIPE_LEFT": "Links wischen fr Optionen",
	"MANAGE": "Verwalten",
	"IMAGE_REMOVED": "Bild entfernt",
	"COPY": "Kopieren",
	"NO_IMAGE": "Sie haben noch kein Foto hochgeladen!",
	"PULL_DOWN_TO_REFRESH": "Nach unten ziehen zum aktualisieren",
	"EXTERNAL_APPS": "Externe Apps",
	"PLUGINS": "Plug-Ins",
	"SUGGEST": "Vorschlagen",
	"COMING_SOON": "Kommt bald",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Hier kannst du die Blockchain oder die Standardplattform wechseln.",
	"CURRENCY": "Whrung",
	"CURRENCY_TEXT": "Hier knnen Sie Ihre Standardwhrung ndern. Sie sehen all Ihre Verdienste fr Beitrge / Kommentare in dieser Standardwhrung.",
	"ABOUT_11": "<br><b>Feature Liste</b><br>- Zugang erhalten zu einzigartigen Artikeln all der Themengebiete, die Sie gerne lesen mchten.<br>- Interagieren Sie mit den Autoren, in dem Sie die Beitrge kommentieren und mit anderen diskutieren.<br>- Stimmen Sie fr Artikel um Autoren zu belohnen und selbst Curation Rewards zu verdienen.<br>- Verffentlichen Sie Ihre Artikel, Blog Posts, die kostenlos gehosted werden und erhalten Sie Entgelt fr Interagieren und gewinnen Sie zustzlich Anhnger fr Ihre Inhalte.<br>- Schreiben Sie Artikel von unterwegs. Speichern Sie eine Vielzahl von Entwrfen um diese spter zu verffentlichen.<br>- Bookmarken Sie Ihre Lieblingsartikel, um diese spter zu lesen.<br>- Einnahmen tauschen oder auszahlen.<br>- berweisen Sie Guthaben an Autoren, Nutzer, Freunde, Anhnger, etc.<br>- Folgen Sie interessanten Autoren, Bloggern.<br>- Durchsuchen Sie Inhalte Ihrer Follower und Autoren.<br>- Erhalten Sie Benachrichtigungen von Ihren Follower und Diskussionen, an denen Sie teilgenommen haben.<br>- Suchen Sie interessante Tags / Kategorien aller Artikel und Autoren.<br>- Personalisieren Sie Ihre Profil.<br>- Viele neue Features werden demnchst vorgestellt.<br><br><b>Sicherheit</b><br>1. App hat keinen Zugriff auf Ihre Einnahmen.<br>2. App bieten einfliet-side Sicherheits-Modell mit privaten Schlsseln, die lokal gehostet und niemals an andere Server geschickt werden. Sie sind lediglich dafr verantwortlich Ihre Passwort zu sichern.<br>3. Die App bietet simples Nutzer Interface und attraktive User Erfahrungen<br>4. Die App beinhaltet eine zustzliche Sicherheitsebene durch einen Pin-Code<br><br>eSteem untersttz die Plattformen Steem sowie Golos.<br>",
	"FOUNDER": "Grnder und leitender Entwickler",
	"ADD_ACCOUNT": "Account hinzufgen",
	"PLATFORM": "Plattform",
	"ESCROW": "Treuhandservice",
	"ESCROW_AGENT": "Escrow Agent",
	"RATIFICATION_DEADLINE": "Ratifizierungsfrist",
	"ESCROW_EXPIRATION": "Escrow Ablaufdatum",
	"ESCROW_FEE": "Escrow Gebhr",
	"ESCROW_TERMS": "Escrow Bedingungen",
	"NIGHT_MODE": "Nachtmodus",
	"DAY_MODE": "Tagmodus",
	"VIEW_CONTEXT": "Den ganzen Artikel ansehen",
	"USER_NOTFOUND": "Benutzer nicht gefunden",
	"APPROVE": "Zustimmen",
	"DISPUTE": "Anfechten",
	"RELEASE": "Verffentlichung",
	"FROM": "Von",
	"ID": "iD",
	"SUBMIT": "Senden",
	"RECEIVER": "Empfnger",
	"LOCATION": "Position",
	"WEBSITE": "Webseite",
	"DISPLAY_NAME": "Angezeigter Name"
}
},{}],108:[function(require,module,exports){
module.exports={
	"HOME": "hom",
	"LOGIN": "lgin",
	"LOGOUT": "lgootu",
	"PROFILE": "porfli",
	"FOLLOW": "fluw",
	"BOOKMARKS": "bkumakrz",
	"TRANSFER": "tarnsefr",
	"MARKET": "mrakte",
	"SETTINGS": "stetignz",
	"ABOUT": "abut",
	"ABOUT_1": "wer anyon cna eran rwardz fer thir cntnt!",
	"ABOUT_2": "iz pwered bi {{platformname}} paltfrom. app iz crated bi",
	"ABOUT_3": "and it iz opn-src, cmounti dirvne mbil prjct. it offezr cntnt accezs fer rdng, coemntng, vtoign, pstng, tarnsefr eranignz, etc. ftrz offered bi {{platformname}} blckchin and {{sitename}}.",
	"ABOUT_4": "1. app nver accezs or hlod otno uesr fndz.",
	"ABOUT_5": "2. app offezr a clnt-sid sceurti mdel, wtih pirvta kyez hsotde lcoail and nver snet tu ani srvrz.",
	"ABOUT_6": "3. app offezr smpl, atrtaciv uesr inetrfcz and exprncz.",
	"ABOUT_7": "4. app nver rqeuri usrz tu inpt ani presoanl infrmatn.",
	"ABOUT_8": "vot good-karma az witnsez",
	"ABOUT_9": "kontakt/fedbak:",
	"ABOUT_10": "mur inf:",
	"REMOVE": "rmov",
	"MARKET_VIEW": "mrakte veiw",
	"PRICE": "pirc",
	"AMOUNT": "aomutn",
	"TOTAL": "ttal",
	"NOORDERS": "no oepn odrezr fer",
	"DATE": "dat",
	"BUY": "bui",
	"SELL": "sel",
	"OPEN": "oepn",
	"HISTORY": "hstr",
	"FOLLOW_BACK": "fluw bak",
	"FOLLOWED": "flowed",
	"UNFOLLOW": "unfolow",
	"FOLLOWING": "floownig",
	"FOLLOWERS": "floowrez",
	"SEARCH_FOLLOWERS": "saerhc floowrez",
	"SEARCH_FOLLOWING": "saerhc floownig",
	"BY": "bi",
	"MENU": "mneu",
	"BOOKMARK": "bkmrk",
	"REBLOG": "rbelgo",
	"UPVOTE": "upvt",
	"DOWNVOTE": "dwnvot",
	"UNVOTE_DOWNVOTED": "unvt donwvoed",
	"UNVOTE_UPVOTED": "unvt upvoed",
	"REPLY": "rpli",
	"EDIT": "eidt",
	"POST_1": "siwp lfet on cmentz tu c optinz",
	"POST_2": "tap on cmentz tu c sub-cmntz",
	"OPTIONS": "optinz",
	"RESTEEMED_BY": "rseteemd bi",
	"NOTHING_HERE": "nthng hir, yet...",
	"BALANCES": "blancz",
	"PROFILE_1": "{{platformname}}, traedbal $$ dat cn b trnsfred anytiem. {{platformname}} cn b covnered 2 {{platformpower}} in a prcsz cled pwoernig up.",
	"PROFILE_2": "{{platformpower}}, ifnlunec $$ dat ern mur pwer fer hldng lnog tiem and votign on postz. teh mur u holdz teh mur u cna ifnlunec otherz rwardz and ern rwardz fer accurat votign.",
	"PROFILE_3": "$$ wrth abut {{platformsunit}} of {{platformname}}.",
	"ESTIMATED_VALUE": "esitmaed vlau",
	"PROFILE_4": "teh esitmaed vlau iz bsed on a 7 dai aevrga vlau of {{platformname}}.",
	"TRANSACTION_HISTORY": "transactn hstr",
	"POSTING": "pstng",
	"PROFILE_5": "teh pstng kei iz uesd fer pstng and vtoign. it sohudl b differnt frum teh actv and ownr kyez.",
	"OWNER": "ownr",
	"PROFILE_6": "teh ownr kei iz teh msatre kei fer teh accont and iz rqeuierd tu chng teh othr kyez. teh pirvta kei or psaswrod fer teh ownr kei sohudl b kpet offlni az mcuh az pssbl.",
	"ACTIVE": "actv",
	"PROFILE_7": "teh actv kei iz uesd tu maek trnasfrz and palc odrezr in teh itneranl mrakte.",
	"MEMO": "mmeo",
	"PROFILE_8": "teh mmeo kei iz uesd tu crat and raed mmoz.",
	"BLOG": "bolg",
	"POSTS": "pstz",
	"REPLIES": "rplies",
	"WALLET": "wlet",
	"TAG": "tagg",
	"USER": "uesr",
	"CLOSE": "cols",
	"TO": "to",
	"ASSET": "asst",
	"SEND": "snd",
	"SECURITY": "sceurti",
	"AVAILABLE": "aavilbal",
	"PUBLIC_MEMO": "pbulci mmeo",
	"TO_DESC": "uesr e.g. good-karma",
	"PIN_CODE": "pin cod",
	"PIN_TEXT": "pin cod hlpz yu tu scur app and ur dtaa. <br/><br/><b>note:</b> onc enbled, yu hev max 4 tirz tu unlk, if yu frgt pin or fial, app wil rmov lgogde in uesr dtaa. yu cna r-eloign and cntn usng app.",
	"NOTIFICATIONS": "notifikationz",
	"VOTE_TEXT": "yu wil get notfikatin wehn smoeno vtoz ur cntnt! <br/> <b>nt:</b> notifikationz icnldu vtoign wiegth az wel in alrt messig. (b it upvt, dwnvot, unvt).",
	"VOTE": "vot",
	"COMMENT_TEXT": "yu wil get notfikatin wehn smoeno cmentz on ur pstz or koments!<br/> <b>nt:</b> notifikationz icnldu wehn smoeno <b>dts</b> thir cmentz az wel.",
	"COMMENT": "cmoetn",
	"FOLLOW_TEXT": "yu wil get notfikatin wehn smoeno fluw or unfolow yu!",
	"MENTIONS": "mnetinoz",
	"MENTIONS_TEXT": "yu wil get notfikatin wehn smoeno mnetinoz yu in thir pst/cmnt!",
	"CONFIGURATIONS": "konfguratonz",
	"VOTING": "vtoign",
	"VOTING_TEXT": "vot wiegth or pecrenag affectz vtoign pwer on app, so yu cna rgulat ur vtoign rweadr. <br/><br/><b>note:</b> diz wil chng vtoign weight/percentag fer dwnvting az wel and it iz evreywer on app",
	"SERVER": "srevre",
	"SERVER_TEXT": "rcmnded",
	"SAVE_CHANGES": "sav cahnzg",
	"VOTERS_INFO": "vtoezr ifno",
	"WELCOME_BACK": "wlcum bak!",
	"LOGIN_1": "sgin in wtih ur usrnam and psaswrod tu cntn.",
	"LOGIN_2": "pstng kei iz uesd fer psot, cmoetn, vot, fluw.",
	"LOGIN_3": "actv kei iz uesd fer trnasfrz and porfli pcitru updt.",
	"LOGIN_4": "uesr crdntalz ar kpet lcoail on teh dvic. uopn lgootu crdntalz ar rmoved!",
	"DONT_HAVE": "dnt hev an accont?",
	"SIGN_UP_NOW": "sgin up now",
	"CANCEL": "cnacle",
	"ADVANCED": "avdanecd",
	"ACTIVE_PRIKEY": "actv pirvta kei",
	"POSTING_PRIKEY": "pstng pirvta kei",
	"MASTER_PASS": "mastr/man psaswrod",
	"USERNAME": "usrnam",
	"CARD_VIEW": "crad veiw",
	"COMPACT_VIEW": "cmpct veiw",
	"SEARCH": "saerhc",
	"SUBMIT_A_STORY": "sbumti a stri",
	"REPLYTO": "rpli tu",
	"POST": "psot",
	"PREVIEW": "prvew",
	"DEFAULT": "dfalt 50% / 50%",
	"POWERUP": "pwer up 100%",
	"DECLINE_PAYOUT": "dcelni pyaotu",
	"SAVE_FOR_LATER": "sav fer lter",
	"POST_CONTENT": "psot cntnt",
	"COMMENT_CONTENT": "cmoetn cntnt",
	"TITLE": "ttil",
	"TAGS": "tegz",
	"NOT_MATCH": "not mtch",
	"CONFIRM_PIN": "cnfrm pin",
	"OPENING_POST": "opnng psot",
	"SET_PIN": "set pin",
	"ENTER_PIN": "entr pin",
	"ARE_YOU_SURE": "ar yu sur?",
	"BROADCAST_ERROR": "braodcst eorr, tri agn!",
	"SUCCESS": "sccsz",
	"REBLOGGED_POST": "relboged psot!",
	"LOGIN_FAIL": "lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd pstng pirvta kei on lgin if yu hev cuhsde avdanecd mod.",
	"LOGIN_FAIL_A": "lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd actv pirvta kei on lgin if yu hev cohsne avdanecd mod.",
	"WARNING": "wrnng",
	"VOTE_FOR_WITNESS": "vtoign fer wtnsz",
	"VOTED_FOR_WITNESS": "vted fer wtnsz",
	"FROM_NOW": "frum now",
	"SECS": "secz",
	"MINS": "minz",
	"AN_HOUR": "an hrz",
	"HOURS": "hrz",
	"A_DAY": "a dai",
	"DAYS": "dyaz",
	"A_MONTH": "a mnth",
	"MONTHS": "mnotzh",
	"A_YEAR": "a yaer",
	"YEARS": "yarz",
	"MIN_READ": "min raed",
	"DOWNVOTE_FLAG": "dwnvot or falg",
	"CAPTURE_PICTURE": "cpatru pcitur",
	"SELECT_PICTURE": "silect pcitur",
	"SET_CUSTOM_URL": "set csutmo url",
	"INSERT_PICTURE": "isnetr pcitru",
	"ERROR": "eorr",
	"UPLOAD_ERROR": "ulpoda eorr",
	"CAMERA_CANCELLED": "cmaear cnaceeld",
	"SET_URL": "set url",
	"DIRECT_LINK_PICTURE": "drietc web lnik fer teh pcitru",
	"COMMENT_SUBMITTED": "cmoetn iz sumbited!",
	"DELETE_COMMENT": "dleetnig cmentz ar irvrsbl...",
	"DELETED_COMMENT": "dleted cmoetn",
	"UPLOADING_PICTURE": "upoladng pcitru",
	"UPLOAD_COMPLETED": "ulpoda copmleed",
	"UPLOAD_FAILED": "ulpoda fialde",
	"PASSWORD_INCORRECT": "teh psaswrod or accont nam waz icnorcet",
	"INFO": "ifno",
	"QR_TEXT": "palc a qr cod insd teh sacn aera",
	"BALANCE_TEXT": "maek sur yu hev eonuhg $$ fer transactn!",
	"NONEXIST_USER": "uesr yu ar tyrign tu tarnsefr $$, dsn't exst!",
	"TRANSFER_TEXT": "ar yu sur yu wanan tu tarnsefr?",
	"CONFIRMATION": "konfrmatin",
	"TX_BROADCASTED": "transactn iz bradcastd",
	"FEED": "fed",
	"TRENDING": "terndnig",
	"HOT": "hot",
	"NEW": "new",
	"PROMOTED": "pormoetd",
	"VOTES": "vtoz",
	"PAYOUT": "pyaotu",
	"COMMENTS": "cmentz",
	"TRENDING_30": "terndnig fer 30 dyaz",
	"SORT_POST_BY": "srot pstz by:",
	"PAYOUT_CYCLE": "pyaotu ccyl",
	"POTENTIAL_PAYOUT": "poetntal pyaotu",
	"PAST_PAYOUT": "psat pyaotu",
	"AUTHOR_PAYOUT": "atuhro pyaotu",
	"CURATION_PAYOUT": "cruatoin pyaotu",
	"POST_SUBMITTED": "psot iz sumbited!",
	"POST_LATER": "psot fer lter sbmsson!",
	"SAVED": "sved",
	"CLEARED": "clared",
	"FLAGGING_TEXT": "falggnig a psot cna rmov rwardz and maek diz mtaerail lsez visible.<br><br>th falg sohudl b uesd fer teh foolwig: <ul><li>fraut or plagiarism</li><li>hat spch or itnerent troling</li><li>intentional mskategorzed cntnt or spam</l></ul>",
	"REQUEST_LIMIT_TEXT": "rqust lmit rched. cehk out othr trnd/tegz!",
	"POST_IS_UNBOOKMARK": "psot iz rmoved frum bkumakrz!",
	"POST_IS_BOOKMARK": "psot iz addd tu bkumakrz!",
	"RESET": "rset",
	"MODIFY_PICTURE": "chng porfli pcitru",
	"MODIFY_COVER_PICTURE": "chng cver pcitru",
	"ACTIVE_KEY_REQUIRED_TEXT": "plz porvdi actv pirvta kei if yu hev cohsne avdanecd lgin mod!",
	"RESET_PICTURE_TEXT": "diz wil rset uesr porfli pcitru",
	"RESET_COVER_PICTURE_TEXT": "diz wil rset uesr cver pcitru",
	"UPDATE_REQUIRES_RESTART": "srevre updt rqurz rstrt!",
	"SETTINGS_UPDATED": "stetignz ar updated!",
	"LANGUAGES": "lnagugaz",
	"LANGUAGES_TEXT": "hir yu cna chng lngag of teh app.",
	"LOGIN_TO_X": "diz opreaton rqurz uesr tu b lgogde in wtih mian psaswrod, aktve/postng kei. plz lgin and tri agn.",
	"GALLERY": "glaeir",
	"TRANSLATIONS": "translatn kontrbutrz",
	"SHARE": "shre",
	"MARKETPLACE": "mrakte palc",
	"EXCHANGE": "exchng",
	"DRAFTS": "darfzt",
	"POST_IS_UNDRAFT": "psot iz rmoved frum darfzt!",
	"POST_IS_DRAFT": "psot iz addd tu darfzt!",
	"SWIPE_LEFT": "siwp lfet tu c optinz",
	"MANAGE": "mnag",
	"IMAGE_REMOVED": "iamg iz rmoved",
	"COPY": "cpoi",
	"NO_IMAGE": "yu hev not ulpoaedd ani iamg, yet!",
	"PULL_DOWN_TO_REFRESH": "pul dwon tu rfrsh",
	"EXTERNAL_APPS": "etxeranl appz",
	"PLUGINS": "plgnz",
	"SUGGEST": "sggst",
	"COMING_SOON": "cmoign sun",
	"CHAIN": "chin",
	"CHAIN_TEXT": "hir yu cna chng blckchin or dfalt paltfrom."
}
},{}],109:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "          !",
	"ABOUT_2": "    {{platformname}}.   ",
	"ABOUT_3": "   ,    .,     , , , ,  , .      {{platformname}} blockchain   {{sitename}}.",
	"ABOUT_4": "1.            .",
	"ABOUT_5": "2.             ,      \"\"        .",
	"ABOUT_6": "3.          .",
	"ABOUT_7": "4,        .",
	"ABOUT_8": " good-karma  witness",
	"ABOUT_9": "/",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "    ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": " ",
	"SEARCH_FOLLOWERS": "   ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": " ",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": " -",
	"UNVOTE_UPVOTED": " -",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "       ",
	"POST_2": "      -",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": " , ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},  ,      . {{platformname}}     {{platformpower}}      powering up. ",
	"PROFILE_2": "{{platformpower}},        ,      .       ,             .",
	"PROFILE_3": "   {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": "   ",
	"PROFILE_4": "          {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "          .        \"\"     \"\".",
	"OWNER": "",
	"PROFILE_6": "                 .                  .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": " - ",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": " . good-karma",
	"PIN_CODE": " PIN",
	"PIN_TEXT": " PIN          . <br/><br/><b>:</b>   ,  max 4   .     PIN  ,         .          .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "        . <br/> <b>:</b>            . ( ,  , -).",
	"VOTE": "",
	"COMMENT_TEXT": "         !<br/> <b>:</b>        <b></b>   .",
	"COMMENT": "",
	"FOLLOW_TEXT": "           .",
	"MENTIONS": "",
	"MENTIONS_TEXT": "        / .",
	"RESTEEM": "",
	"RESTEEM_TEXT": "       .",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "\"\"         ,       <br/><br/><b>:</b>     \"\"/            ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": " ",
	"WELCOME_BACK": "  !",
	"LOGIN_1": "         .",
	"LOGIN_2": "     , ,       .",
	"LOGIN_3": "          .",
	"LOGIN_4": "      .       .",
	"DONT_HAVE": "  ?",
	"SIGN_UP_NOW": "  ",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "/ ",
	"USERNAME": " ",
	"CARD_VIEW": "  ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"POWERUP": "  100%",
	"DECLINE_PAYOUT": " ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " PIN",
	"ENTER_PIN": " PIN",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "    ,   ?",
	"BROADCAST_ERROR": " ,  !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !                   .",
	"LOGIN_FAIL_A": "  !                   .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  witness",
	"VOTED_FOR_WITNESS": "  witness",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": ".",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": " ",
	"DAYS": "",
	"A_MONTH": " ",
	"MONTHS": "",
	"A_YEAR": " ",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "    Flag",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "    ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "     ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": " ",
	"PASSWORD_INCORRECT": "       ",
	"INFO": "",
	"QR_TEXT": "  QR    ",
	"BALANCE_TEXT": "      !",
	"NONEXIST_USER": "      ,  !",
	"TRANSFER_TEXT": "      ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "    ",
	"TRENDING": " ",
	"HOT": "   ",
	"NEW": " ",
	"PROMOTED": "",
	"VOTES": " ",
	"PAYOUT": " ",
	"COMMENTS": " ",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": "  Curation",
	"POST_SUBMITTED": "  !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "             .<br><br>       : <ul><li>    </li><li>   Trolling</li><li>       Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "     .   /",
	"POST_IS_UNBOOKMARK": "     !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": "  ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "  /Active       !",
	"RESET_PICTURE_TEXT": "       ",
	"RESET_COVER_PICTURE_TEXT": "     ",
	"UPDATE_REQUIRES_RESTART": "     !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "       .",
	"LOGIN_TO_X": "             active/posting key.    .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "\n",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "     ",
	"POST_IS_DRAFT": "    ",
	"SWIPE_LEFT": "      ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    ",
	"PULL_DOWN_TO_REFRESH": "     ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "           .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "       .      /     .",
	"ABOUT_11": "<br><b>   </b> <br>-        . <br> -\"\"     . <br>-         . <br>-   ,              . <br>-       ,    . <br>-         . <br>-     . <br>-    , , ,   <br>-  , bloggers. <br> -       . <br>-               . <br>-  / , . <br> -   . <br>-     . <br><br><b></b> <br>1.             . <br>2.           -,              ,            . <br>3.           <br>4.          pin <br><br>   Steem  Golos. <br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": ""
}
},{}],110:[function(require,module,exports){
module.exports={
	"HOME": "Home",
	"LOGIN": "Login",
	"LOGOUT": "Logout",
	"PROFILE": "Profile",
	"FOLLOW": "Follow",
	"BOOKMARKS": "Bookmarks",
	"TRANSFER": "Transfer",
	"MARKET": "Market",
	"SETTINGS": "Settings",
	"ABOUT": "About",
	"ABOUT_1": "where anyone can earn rewards for their content!",
	"ABOUT_2": "is social application where you get paid for blogging, commenting and curating.",
	"ABOUT_3": "and it is open-source, community driven mobile project. It offers content access for reading, commenting, voting, posting, transfer earnings, etc. features offered by {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. App never access or hold onto user funds.",
	"ABOUT_5": "2. App offers a client-side security model, with private keys hosted locally and never sent to any servers.",
	"ABOUT_6": "3. App offers simple, attractive user interfaces and experiences.",
	"ABOUT_7": "4. App never require users to input any personal information.",
	"ABOUT_8": "Vote good-karma as witness",
	"ABOUT_9": "Contact/Feedback:",
	"ABOUT_10": "More info:",
	"REMOVE": "Remove",
	"MARKET_VIEW": "Market View",
	"PRICE": "Price",
	"AMOUNT": "Amount",
	"TOTAL": "Total",
	"NOORDERS": "No open orders for",
	"DATE": "Date",
	"BUY": "Buy",
	"SELL": "Sell",
	"OPEN": "Open",
	"HISTORY": "History",
	"FOLLOW_BACK": "Follow back",
	"FOLLOWED": "Followed",
	"UNFOLLOW": "Unfollow",
	"FOLLOWING": "Following",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Search followers",
	"SEARCH_FOLLOWING": "Search following",
	"BY": "by",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Unvote Downvoted",
	"UNVOTE_UPVOTED": "Unvote upvoted",
	"REPLY": "Reply",
	"EDIT": "Edit",
	"POST_1": "Swipe left on comments to see options",
	"POST_2": "Tap on comments to see sub-comments",
	"OPTIONS": "Options",
	"RESTEEMED_BY": "Reblogged by",
	"NOTHING_HERE": "Nothing here, yet...",
	"BALANCES": "Balances",
	"PROFILE_1": "{{platformname}}, tradeable tokens that may be transferred at anytime. {{platformname}} can be converted to {{platformpower}} in a process called powering up.",
	"PROFILE_2": "{{platformpower}}, influence tokens that earn more power for holding long term and voting on posts. The more one holds the more one can influence others rewards and earn rewards for accurate voting.",
	"PROFILE_3": "Tokens worth about {{platformsunit}} of {{platformname}}.",
	"ESTIMATED_VALUE": "Estimated Value",
	"PROFILE_4": "The estimated value is based on a 7 day average value of {{platformname}}.",
	"TRANSACTION_HISTORY": "Transaction History",
	"POSTING": "Posting",
	"PROFILE_5": "The posting key is used for posting and voting. It should be different from the active and owner keys.",
	"OWNER": "Owner",
	"PROFILE_6": "The owner key is the master key for the account and is required to change the other keys. The private key or password for the owner key should be kept offline as much as possible.",
	"ACTIVE": "Active",
	"PROFILE_7": "The active key is used to make transfers and place orders in the internal market.",
	"MEMO": "Memo",
	"PROFILE_8": "The memo key is used to create and read memos.",
	"BLOG": "Blog",
	"POSTS": "Posts",
	"REPLIES": "Replies",
	"WALLET": "Wallet",
	"TAG": "Tag",
	"USER": "User",
	"CLOSE": "Close",
	"TO": "To",
	"ASSET": "Asset",
	"SEND": "Send",
	"SECURITY": "Security",
	"AVAILABLE": "Available",
	"PUBLIC_MEMO": "Public Memo",
	"TO_DESC": "User e.g. good-karma",
	"PIN_CODE": "Pin Code",
	"PIN_TEXT": "PIN code helps you to secure app and your data. <br/><br/><b>Note:</b> Once enabled, you have max 4 tries to unlock, if you forgot pin or fail, app will remove logged in user data. You can re-login and continue using app.",
	"NOTIFICATIONS": "Notifications",
	"VOTE_TEXT": "You will get notification when someone votes your content! <br/> <b>Note:</b> Notifications include voting weight as well in alert message. (be it up-vote, down-vote, un-vote).",
	"VOTE": "Vote",
	"COMMENT_TEXT": "You will get notification when someone comments on your posts or comments!<br/> <b>Note:</b> Notifications include when someone <b>edits</b> their comments as well.",
	"COMMENT": "Comment",
	"FOLLOW_TEXT": "You will get notification when someone Follow or Unfollow you!",
	"MENTIONS": "Mentions",
	"MENTIONS_TEXT": "You will get notification when someone mentions you in their post/comment!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "You will get notification when someone reblogs your post!",
	"CONFIGURATIONS": "Configurations",
	"VOTING": "Voting",
	"VOTING_TEXT": "Vote weight or percentage affects voting power on app, so you can regulate your voting reward. <br/><br/><b>Note:</b> This will change voting weight/percentage for downvoting as well and it is everywhere on app",
	"SERVER": "Server",
	"SERVER_TEXT": "Recommended",
	"SAVE_CHANGES": "Save Changes",
	"VOTERS_INFO": "Voters info",
	"WELCOME_BACK": "Welcome back!",
	"LOGIN_1": "Sign in with your username and password to continue.",
	"LOGIN_2": "Posting key is used for post, comment, vote, follow.",
	"LOGIN_3": "Active key is used for transfers and profile picture update.",
	"LOGIN_4": "User credentials are kept locally on the device. Upon Logout credentials are removed!",
	"DONT_HAVE": "Don't have an account?",
	"SIGN_UP_NOW": "Sign up now",
	"CANCEL": "Cancel",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Active private key",
	"POSTING_PRIKEY": "Posting private key",
	"MASTER_PASS": "Master/main password",
	"USERNAME": "Username",
	"CARD_VIEW": "Card view",
	"COMPACT_VIEW": "Compact view",
	"SEARCH": "Search",
	"SUBMIT_A_STORY": "Submit a story",
	"REPLYTO": "Reply to",
	"POST": "Post",
	"PREVIEW": "Preview",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Decline Payout",
	"SAVE_FOR_LATER": "SAVE FOR LATER",
	"CLEAR": "CLEAR",
	"POST_CONTENT": "Post content",
	"COMMENT_CONTENT": "Comment content",
	"TITLE": "Title",
	"TAGS": "Tags",
	"NOT_MATCH": "NOT MATCH",
	"CONFIRM_PIN": "Confirm PIN",
	"INCORRECT": "INCORRECT",
	"OPENING_POST": "opening post",
	"SET_PIN": "Set PIN",
	"ENTER_PIN": "Enter PIN",
	"ARE_YOU_SURE": "Are you sure?",
	"REBLOG_TEXT": "Reblog is irreversible, do you want to continue?",
	"BROADCAST_ERROR": "Broadcast error, try again!",
	"SUCCESS": "Success",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Login failed! Please make sure you have logged in with master password or provided Posting private key on Login if you have choosed Advanced mode.",
	"LOGIN_FAIL_A": "Login failed! Please make sure you have logged in with master password or provided Active private key on Login if you have chosen Advanced mode.",
	"WARNING": "Warning",
	"VOTE_FOR_WITNESS": "Voting for witness",
	"VOTED_FOR_WITNESS": "Voted for witness",
	"AGO": "ago",
	"FROM_NOW": "from now",
	"SECS": "secs",
	"A_MIN": "a min",
	"MINS": "mins",
	"AN_HOUR": "an hr",
	"HOURS": "hrs",
	"A_DAY": "a day",
	"DAYS": "days",
	"A_MONTH": "a month",
	"MONTHS": "months",
	"A_YEAR": "a year",
	"YEARS": "years",
	"MIN_READ": "min read",
	"DOWNVOTE_FLAG": "Downvote or Flag",
	"CAPTURE_PICTURE": "Capture Picture",
	"SELECT_PICTURE": "Select Picture",
	"SET_CUSTOM_URL": "Set Custom URL",
	"INSERT_PICTURE": "Insert Picture",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Upload Error",
	"CAMERA_CANCELLED": "Camera Cancelled",
	"SET_URL": "Set URL",
	"DIRECT_LINK_PICTURE": "Direct web link for the picture",
	"COMMENT_SUBMITTED": "Comment is submitted!",
	"DELETE_COMMENT": "Deleting comments are irreversible...",
	"DELETED_COMMENT": "Deleted comment",
	"UPLOADING_PICTURE": "Uploading Picture",
	"UPLOAD_COMPLETED": "Upload Completed",
	"UPLOAD_FAILED": "Upload Failed",
	"PASSWORD_INCORRECT": "The password or account name was incorrect",
	"INFO": "Info",
	"QR_TEXT": "Place a QR code inside the scan area",
	"BALANCE_TEXT": "Make sure you have enough balance for transaction!",
	"NONEXIST_USER": "User you are trying to transfer fund, doesn't exist!",
	"TRANSFER_TEXT": "Are you sure you want to transfer?",
	"CONFIRMATION": "Confirmation",
	"TX_BROADCASTED": "Transaction is broadcasted",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "Hot",
	"NEW": "New",
	"PROMOTED": "Promoted",
	"VOTES": "Votes",
	"PAYOUT": "Payout",
	"COMMENTS": "Comments",
	"TRENDING_30": "Trending for 30 days",
	"SORT_POST_BY": "Sort Posts By:",
	"PAYOUT_CYCLE": "Payout Cycle",
	"POTENTIAL_PAYOUT": "Potential Payout",
	"PAST_PAYOUT": "Past Payout",
	"AUTHOR_PAYOUT": "Author Payout",
	"CURATION_PAYOUT": "Curation Payout",
	"POST_SUBMITTED": "Post is submitted!",
	"POST_LATER": "Post for later submission!",
	"SAVED": "Saved",
	"CLEARED": "Cleared",
	"FLAGGING_TEXT": "Flagging a post can remove rewards and make this material less visible.<br><br>The flag should be used for the following: <ul><li>Fraud or Plagiarism</li><li>Hate Speech or Internet Trolling</li><li>Intentional miscategorized content or Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Request limit reached. Check out other trend/tags!",
	"POST_IS_UNBOOKMARK": "Post is removed from bookmarks!",
	"POST_IS_BOOKMARK": "Post is added to bookmarks!",
	"RESET": "Reset",
	"MODIFY_PICTURE": "Modify Profile Picture",
	"MODIFY_COVER_PICTURE": "Modify Cover Picture",
	"ACTIVE_KEY_REQUIRED_TEXT": "Please provide Active private key if you have chosen Advanced login mode!",
	"RESET_PICTURE_TEXT": "This will reset user profile picture",
	"RESET_COVER_PICTURE_TEXT": "This will reset user cover picture",
	"UPDATE_REQUIRES_RESTART": "Server update requires Restart!",
	"SETTINGS_UPDATED": "Settings are updated!",
	"LANGUAGES": "Languages",
	"LANGUAGES_TEXT": "Here you can change language of the app.",
	"LOGIN_TO_X": "This operation requires user to be logged in with main password, active/posting key. Please login and try again.",
	"GALLERY": "Gallery",
	"TRANSLATIONS": "Translation contributors",
	"SHARE": "Share",
	"MARKETPLACE": "Market Place",
	"EXCHANGE": "Exchange",
	"DRAFTS": "Drafts",
	"POST_IS_UNDRAFT": "Post is removed from drafts!",
	"POST_IS_DRAFT": "Post is added to drafts!",
	"SWIPE_LEFT": "Swipe left to see options",
	"MANAGE": "Manage",
	"IMAGE_REMOVED": "Image is removed",
	"COPY": "Copy",
	"NO_IMAGE": "You have not uploaded any image, yet!",
	"PULL_DOWN_TO_REFRESH": "Pull down to refresh",
	"EXTERNAL_APPS": "External Apps",
	"PLUGINS": "Plugins",
	"SUGGEST": "Suggest",
	"COMING_SOON": "Coming soon",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Here you can change blockchain or default platform.",
	"CURRENCY": "Currency",
	"CURRENCY_TEXT": "Here you can change your default currency. You will see post/comment reward value in this currency.",
	"ABOUT_11": "<br><b>Feature list</b><br>- Access unique articles in any subject you are interested reading.<br>- Engage with authors by commenting, discussing topics.<br>- Voting for posts to reward author as well as earn curation reward.<br>- Publish your articles, blog posts and host them for free and earn rewards by engaging and gain followers.<br>- Write articles on go, save multiple drafts of the post for later publication.<br>- Bookmark favorite articles to read later.<br>- Exchange or cash out your earnings.<br>- Send your funds to any authors or users, friends, followers, etc.<br>- Follow interesting authors, bloggers.<br>- Search your followers and authors you are following.<br>- Get notifications to stay in touch with your followers and discussions you are involved in.<br>- Search for interesting tags/categories of articles, authors.<br>- Personalize your profile.<br>- Many more features to come.<br><br><b>Security</b><br>1. App never access or hold onto user funds.<br>2. App offer a client-side security model, with private keys hosted locally and never sent to any servers, you are responsible to backing up your passwords.<br>3. App offers simple, attractive user interfaces and experiences<br>4. App offers extra layer of security with pin-code<br><br>eSteem supports Steem and Golos platforms.<br>",
	"FOUNDER": "Founder and Lead developer",
	"ADD_ACCOUNT": "Add account",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Ratification deadline",
	"ESCROW_EXPIRATION": "Escrow expiration",
	"ESCROW_FEE": "Escrow fee",
	"ESCROW_TERMS": "Escrow terms",
	"NIGHT_MODE": "Night mode",
	"DAY_MODE": "Day mode",
	"VIEW_CONTEXT": "View the full context",
	"USER_NOTFOUND": "User Not Found",
	"APPROVE": "Approve",
	"DISPUTE": "Dispute",
	"RELEASE": "Release",
	"FROM": "From",
	"ID": "id",
	"SUBMIT": "Submit",
	"RECEIVER": "Receiver",
	"LOCATION": "Location",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Display name"
}
},{}],111:[function(require,module,exports){
module.exports={
	"HOME": "Hogar",
	"LOGIN": "Iniciar Sesin",
	"LOGOUT": "Cerrar Sesin",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Marcadores",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Ajustes",
	"ABOUT": "Acerca de",
	"ABOUT_1": "donde todo el mundo puede obtener ganancias por su contenido",
	"ABOUT_2": "provisto por la plataforma {{platformname}}. App creada por",
	"ABOUT_3": "es un proyecto de mvil impulsado por la comunidad, de cdigo abierto. Ofrece acceso al contenido para su lectura, comentarios, votos, publicaciones, transferencia de ganancias, etc; caractersticas ofrecidas por la cadena de bloques {{platformname}} y {{sitename}}.",
	"ABOUT_4": "1. La App nunca accede o retiene fondos de los usuarios.",
	"ABOUT_5": "2. La App ofrece un modelo de seguridad del cliente con contraseas privadas almacenadas localmente y que no son nunca enviadas a ningn servidor.",
	"ABOUT_6": "3. La App ofrece una experiencia y una interfaz simple y atractica.",
	"ABOUT_7": "4. La App nunca pide que los usuarios introduzcan ninguna informacin personal.",
	"ABOUT_8": "Vota a good-karma como testigo",
	"ABOUT_9": "Contacto/Sugerencias",
	"ABOUT_10": "Ms informacin",
	"REMOVE": "Eliminar",
	"MARKET_VIEW": "Vista de Mercado",
	"PRICE": "Precio",
	"AMOUNT": "Cantidad",
	"TOTAL": "Total",
	"NOORDERS": "Sin rdenes abiertas para",
	"DATE": "Fecha",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Historial",
	"FOLLOW_BACK": "Devolver Seguimiento",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Dejar de Seguir",
	"FOLLOWING": "Siguiendo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Buscar seguidores",
	"SEARCH_FOLLOWING": "Buscar seguidos",
	"BY": "por",
	"IN": "en",
	"MENU": "Men",
	"BOOKMARK": "Marcador",
	"REBLOG": "Rebloguear",
	"UPVOTE": "Voto Positivo",
	"DOWNVOTE": "Voto Negativo",
	"UNVOTE_DOWNVOTED": "Deshacer Voto Negativo",
	"UNVOTE_UPVOTED": "Deshacer Voto Positivo",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Desliza a la izquierda en los comentarios para ver las opciones",
	"POST_2": "Pulsa en los comentarios para ver los subcomentarios",
	"OPTIONS": "Opciones",
	"RESTEEMED_BY": "Resteemed por",
	"NOTHING_HERE": "Nada por aqu an...",
	"BALANCES": "Saldos",
	"PROFILE_1": "{{platformname}}, fichas comerciables que pueden ser transferidas en cualquier momento. {{platformname}} pueden ser convertidas a {{platformpower}} en un proceso llamado power up.",
	"PROFILE_2": "{{platformpower}}, fichas de influencia que consiguen ms poder por mantenerlas a largo plazo y votar en los posts. Cuantas ms tengas ms influencia tendrs en las recompensas que le das al resto de usuarios y ms recompensas obtendrs por tus votos.",
	"PROFILE_3": "Valor de las fichas {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor Estimado",
	"PROFILE_4": "El valor estimado se basa en un valor promedio de 7 das de {{platformname}}.",
	"TRANSACTION_HISTORY": "Historial de Transacciones",
	"POSTING": "Publicacin",
	"PROFILE_5": "La clave de publicacin es utilizada para publicar y votar. Tiene que ser diferente a la clave activa y a la clave de propietario.",
	"OWNER": "Propietario",
	"PROFILE_6": "La clave de propietario es la clave maestra de la cuenta y se requiere para cambiar las otras claves. La clave o contrasea privada de la clave de propietario debera ser mantenida \"offline\" tanto como sea posible.",
	"ACTIVE": "Activa",
	"PROFILE_7": "La clave activa se utiliza para hacer transferencias y hacer pedidos en el mercado interno.",
	"MEMO": "Memorndum",
	"PROFILE_8": "La clave de memorndums se utiliza para crear y leer memorndums.",
	"BLOG": "Escribe",
	"POSTS": "Publicaciones",
	"REPLIES": "Respuestas",
	"WALLET": "Monedero",
	"TAG": "Etiqueta",
	"USER": "Usuario",
	"CLOSE": "Cerrar",
	"TO": "A",
	"ASSET": "Posesin de Capital",
	"SEND": "Enviar",
	"SECURITY": "Seguridad",
	"AVAILABLE": "Disponible",
	"PUBLIC_MEMO": "Memorndum Pblico",
	"TO_DESC": "Usuario ej. good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "El cdigo PIN te ayuda a dar seguridad a la app y a tus datos.\n<br/><br/><b>Nota:</b> Una vez activado, tienes un mximo de 4 intentos para desbloquearlo; si te olvidas de tu pin o fallas, la app eliminar los registros en los datos de usuario. Puedes volver a iniciar sesin y continuar usando la app.",
	"NOTIFICATIONS": "Notificaciones",
	"VOTE_TEXT": "Recibirs una notificacin cuando alguien vote tu contenido! <br/> <b>Nota:</b> Las notificaciones incluyen tambin el peso de la votacin en el mensaje de alerta. (ya sea por votacin positiva, votacin negativa, deshacer votacin).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Recibirs una notificacin cuando alguien comente en tus publicaciones o comentarios!<br/> <b>Note:</b> Las notificaciones incluyen cuando alguien <b>edita</b> sus comentarios tambin.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Recibirs una notificacin cuando alguien te siga o te deje de seguir!",
	"MENTIONS": "Menciones",
	"MENTIONS_TEXT": "Recibirs una notificacin cuando alguien te mencione en su publicacin/comentario!",
	"RESTEEM": "Rebloguear",
	"RESTEEM_TEXT": "Recibirs una notificacin cuando alguien haga reblog a tu publicacin!",
	"CONFIGURATIONS": "Configuraciones",
	"VOTING": "Voto",
	"VOTING_TEXT": "El peso o porcentaje del voto afecta al poder de votacin en la app, de tal manera que puedes regular tu recompensa de votacin. <br/><br/><b>Nota:</b> Esto cambiar tambin el peso/porcentaje del voto a la hora de hacer un voto negativo",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Guardar Cambios",
	"VOTERS_INFO": "Info de votantes",
	"WELCOME_BACK": "Bienvenido!",
	"LOGIN_1": "Regstrate con tu nombre de usuario y contrasea para continuar.",
	"LOGIN_2": "La clave de publicacin se usa para publicar, comentar, votar, seguir.",
	"LOGIN_3": "La clave activa se usa para las transferencias y la actualizacin de la foto de perfil.",
	"LOGIN_4": "Las credenciales del usuario se guardan localmente en el dispositivo. Al cerrar la sesin las credenciales son eliminadas!",
	"DONT_HAVE": "No tienes una cuenta?",
	"SIGN_UP_NOW": "Regstrate ahora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanzado",
	"ACTIVE_PRIKEY": "Clave activa privada",
	"POSTING_PRIKEY": "Clave de publicacin privada",
	"MASTER_PASS": "Contrasea maestra/principal",
	"USERNAME": "Nombre de Usuario",
	"CARD_VIEW": "Vista de casillas",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Buscar",
	"SUBMIT_A_STORY": "Publicar un artculo",
	"REPLYTO": "Responder a",
	"POST": "Publicar",
	"PREVIEW": "Previsualizacin",
	"DEFAULT": "Por defecto 50% / 50%",
	"POWERUP": "Potenciacin 100%",
	"DECLINE_PAYOUT": "Rechazar Pago",
	"SAVE_FOR_LATER": "GUARDAR PARA MS TARDE",
	"CLEAR": "BORRAR",
	"POST_CONTENT": "Publicar contenido",
	"COMMENT_CONTENT": "Comentar contenido",
	"TITLE": "Ttulo",
	"TAGS": "Etiquetas",
	"NOT_MATCH": "NO COINCIDE",
	"CONFIRM_PIN": "Confirmar PIN",
	"INCORRECT": "INCORRECTO",
	"OPENING_POST": "Post inicial",
	"SET_PIN": "Establecer PIN",
	"ENTER_PIN": "Introducir PIN",
	"ARE_YOU_SURE": "Ests seguro?",
	"REBLOG_TEXT": "Reblogear es irreversible deseas continuar?",
	"BROADCAST_ERROR": "Error de transmisin, intntalo de nuevo!",
	"SUCCESS": "Conseguido",
	"REBLOGGED_POST": "Publicacin Reblogueada",
	"LOGIN_FAIL": "Inicio de sesin fallido! Por favor asegrate de que has iniciado sesin con tu contrasea maestra o con la clave de Publicacin privada proporcionada en el apartado Iniciar Sesin si elegiste el Modo Avanzado.",
	"LOGIN_FAIL_A": "Inicio de sesin fallido! Por favor asegrate de que has iniciado sesin con tu contrasea maestra o con la clave Activa privada en el apartado Iniciar Sesin si elegiste el Modo Avanzado.",
	"WARNING": "Advertencia",
	"VOTE_FOR_WITNESS": "Votar a testigo",
	"VOTED_FOR_WITNESS": "Votado a testigo",
	"AGO": "hace",
	"FROM_NOW": "desde ahora",
	"SECS": "segundos",
	"A_MIN": "un minuto",
	"MINS": "minutos",
	"AN_HOUR": "una hora",
	"HOURS": "horas",
	"A_DAY": "un da",
	"DAYS": "das",
	"A_MONTH": "un mes",
	"MONTHS": "meses",
	"A_YEAR": "un ao",
	"YEARS": "aos",
	"MIN_READ": "minutos de lectura",
	"DOWNVOTE_FLAG": "Votar Negativamente o Marcar Como Inapropiado",
	"CAPTURE_PICTURE": "Tomar foto",
	"SELECT_PICTURE": "Seleccionar Imagen",
	"SET_CUSTOM_URL": "Establecer URL personalizada",
	"INSERT_PICTURE": "Insertar Imagen",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Error al Cargar",
	"CAMERA_CANCELLED": "Cmara Cancelada",
	"SET_URL": "Establecer URL",
	"DIRECT_LINK_PICTURE": "Enlace web directo a la imagen",
	"COMMENT_SUBMITTED": "El comentario se ha entregado!",
	"DELETE_COMMENT": "Eliminar comentarios es irreversible...",
	"DELETED_COMMENT": "Eliminar comentario",
	"UPLOADING_PICTURE": "Subiendo Imagen",
	"UPLOAD_COMPLETED": "Subida Completada",
	"UPLOAD_FAILED": "La subida ha fallado",
	"PASSWORD_INCORRECT": "La contrasea o el nombre de cuenta son incorrectos",
	"INFO": "Informacin",
	"QR_TEXT": "Coloca el cdigo QR dentro de la zona de escaneo",
	"BALANCE_TEXT": "Asegrate de que tienes suficiente saldo para la transaccin!",
	"NONEXIST_USER": "El usuario al que ests intentando transferir fondos no existe!",
	"TRANSFER_TEXT": "Ests seguro de que quieres hacer la transferencia?",
	"CONFIRMATION": "Confirmacin",
	"TX_BROADCASTED": "Transaccin transmitida",
	"FEED": "Inicio",
	"TRENDING": "Tendencias",
	"HOT": "Caliente",
	"NEW": "Nuevo",
	"PROMOTED": "Promocionado",
	"VOTES": "Votos",
	"PAYOUT": "Pago",
	"COMMENTS": "Comentarios",
	"TRENDING_30": "Siendo Tendencia durante 30 das",
	"SORT_POST_BY": "Ordenar Publicaciones Por",
	"PAYOUT_CYCLE": "Ciclo de Pago",
	"POTENTIAL_PAYOUT": "Pago Potencial",
	"PAST_PAYOUT": "Pago Pasado",
	"AUTHOR_PAYOUT": "Pago de Autor",
	"CURATION_PAYOUT": "Pago de Curacin",
	"POST_SUBMITTED": "La publicacin fue enviada!",
	"POST_LATER": "Publicacin para posterior presentacin!",
	"SAVED": "Guardado",
	"CLEARED": "Borrado",
	"FLAGGING_TEXT": "Marcar como inapropiada una publicacin puede eliminar las recompensas y hacer que el material marcado sea menos visible.<br><br> Marcar como inapropiado debe utilizarse en los siguientes casos: <ul><li>Fraude o Plagio</li><li>Discursos de Odio o Actitudes de Provocacin y Molestia Constantes</li><li>Contenido categrizado mal intencionadamente o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Lmite de solicitud alcanzado. Revisa otras etiquetas/tendencias!",
	"POST_IS_UNBOOKMARK": "Publicacin eliminada de los marcadores!",
	"POST_IS_BOOKMARK": "Publicacin aadida a marcadores!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar Foto de Perfil",
	"MODIFY_COVER_PICTURE": "Modificar Foto de Portada",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor proporciona la clave Activa privada si has elegido el modo de Inicio de Sesin Avanzado!",
	"RESET_PICTURE_TEXT": "Esto reiniciar la foto de perfil del usuario",
	"RESET_COVER_PICTURE_TEXT": "Esto reiniciar la foto de portada del usuario",
	"UPDATE_REQUIRES_RESTART": "La actualizacin del servidor requiere un reinicio!",
	"SETTINGS_UPDATED": "Ajustes actualizados!",
	"LANGUAGES": "Idiomas",
	"LANGUAGES_TEXT": "Aqu puedes cambiar el idioma de la app",
	"LOGIN_TO_X": "Esta operacin requiere que el usuario inicie sesin con la contrasea maestra/principal, clave activa/publicar. Por favor inicia sesin y vuelve a intentarlo.",
	"GALLERY": "Galera",
	"TRANSLATIONS": "Colaboradores de traducciones",
	"SHARE": "Compartir",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cambio",
	"DRAFTS": "Borradores",
	"POST_IS_UNDRAFT": "La publicacin se ha eliminado de borradores!",
	"POST_IS_DRAFT": "La publicacin se ha aadido a borradores!",
	"SWIPE_LEFT": "Deslice hacia la izquierda para ver las opciones",
	"MANAGE": "Gestionar",
	"IMAGE_REMOVED": "La foto se ha eliminado",
	"COPY": "Copiar",
	"NO_IMAGE": "An no has subido ninguna foto!",
	"PULL_DOWN_TO_REFRESH": "Tire hacia abajo para actualizar",
	"EXTERNAL_APPS": "Apps externas",
	"PLUGINS": "Extensiones",
	"SUGGEST": "Sugerir",
	"COMING_SOON": "Muy pronto",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Aqu puedes cambiar la blockchain o la plataforma por defecto.",
	"CURRENCY": "Divisa",
	"CURRENCY_TEXT": "Aqu puede cambiar su moneda por defecto. Ver el valor de recompensa post/comentario en esta moneda.",
	"ABOUT_11": "<br><b>Lista de Caractersticas</b><br> Accede a artculos nicos de cualquier tema en los que ests interesado <br> Comparte con los autores comentando, discutiendo temas.<br> Votar los artculos recompensa al autor tanto como gana recompensas por curacin de contenidos. <br> Publica tus artculos, notas de blog, hospeda gratuitamente y gana recompensas al atraer y ganar seguidores.<br> Escribe artculos en vivo, as como tambin guardar mltiples borradores del articulo para futura publicacin.<br> Marca tus artculos favoritos para leerlos mas tarde.<br> Intercambia o saca dinero de tus ganancias<br> Envia fondos a cualquier autor o usuario, amigos, seguidores, etc.<br> Sigue autores interesantes, bloggers.<br> Busca tus seguidores y autores que sigues.<br> Recibe notificaciones para mantenerte en contacto con tus seguidores y discusiones en las que estes involucrado. <br> Busca categoras/etiquetas de artculos y autores.<br>Personaliza tu perfil.<br> Muchas mas funcionalidades por venir.<br><br><b>Seguridad</b><br>1. La aplicacin nunca acceder o mantendr fondos de usuarios. <br>2. La aplicacin ofrece un modelo de seguridad lado-cliente, con claves privadas hospedadas localmente y nunca enviadas a ningn servidor, usted es responsable de respaldar sus contraseas.<br>3. La aplicacin ofrece una experiencia del usuario simple y atractiva, a travs de su interfaz. <br>4. La aplicacin ofrece una capa extra de seguridad con un cdigo-pin<br><br>Soporte de eSteem soporta Steem y Plataformas Golos.<br>",
	"FOUNDER": "Fundador y desarrollador Principal",
	"ADD_ACCOUNT": "Aadir cuenta",
	"PLATFORM": "Plataforma",
	"ESCROW": "Depsito de garanta",
	"ESCROW_AGENT": "Agente Escrow",
	"RATIFICATION_DEADLINE": "Fecha lmite de ratificacin",
	"ESCROW_EXPIRATION": "Vencimiento Escrow",
	"ESCROW_FEE": "Tarifa de Escrow",
	"ESCROW_TERMS": "Trminos de Escrow",
	"NIGHT_MODE": "Modo Noche",
	"DAY_MODE": "Modo Da",
	"VIEW_CONTEXT": "Ver el texto completo",
	"USER_NOTFOUND": "Usuario No Encontrado",
	"APPROVE": "Aprobada",
	"DISPUTE": "Conflicto",
	"RELEASE": "Liberar",
	"FROM": "Desde",
	"ID": "ID",
	"SUBMIT": "Enviar",
	"RECEIVER": "Recibir",
	"LOCATION": "Localizacin",
	"WEBSITE": "Pgina Web",
	"DISPLAY_NAME": "Mostrar nombre"
}
},{}],112:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": " ",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "           !",
	"ABOUT_2": "   {{ }}   .     ",
	"ABOUT_3": "                 .                      .     {{ }}  {{ }}   .",
	"ABOUT_4": ".              .",
	"ABOUT_5": ".                       .",
	"ABOUT_6": ".         .",
	"ABOUT_7": ".        .",
	"ABOUT_8": " good-karma     ",
	"ABOUT_9": "/:",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "  ",
	"FOLLOWED": " ",
	"UNFOLLOW": "  ",
	"FOLLOWING": " ",
	"FOLLOWERS": " ",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": " ",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "       .",
	"POST_2": "       .",
	"OPTIONS": "",
	"RESTEEMED_BY": "  ",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{ }}            . {{ }}            {{  }}  .",
	"PROFILE_2": "{{  }}               .                        .",
	"PROFILE_3": "    {{platformsunit}}  {{ }}.",
	"ESTIMATED_VALUE": "  ",
	"PROFILE_4": "         {{ }} .",
	"TRANSACTION_HISTORY": " ",
	"POSTING": " ",
	"PROFILE_5": "           .         .",
	"OWNER": "",
	"PROFILE_6": "              .              .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": "",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": " ",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": "  good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "         . <br/><br/><b>:</b>                              .           .",
	"NOTIFICATIONS": " ",
	"VOTE_TEXT": "             ! <br/> <b>:</b>          . (      ).",
	"VOTE": " ",
	"COMMENT_TEXT": "             !<br/> <b>:</b>         <b></b>   .",
	"COMMENT": " ",
	"FOLLOW_TEXT": "                !",
	"MENTIONS": " ",
	"MENTIONS_TEXT": "       /        !",
	"RESTEEM": "  ",
	"RESTEEM_TEXT": "              !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "                  . <br/><br/><b>:</b>  /                 ",
	"SERVER": "",
	"SERVER_TEXT": " ",
	"SAVE_CHANGES": "  ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": "         .",
	"LOGIN_2": "               .",
	"LOGIN_3": "           .",
	"LOGIN_4": "        .      !",
	"DONT_HAVE": " ",
	"SIGN_UP_NOW": "  ",
	"CANCEL": " ",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "   ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": "  ",
	"REPLYTO": "  ",
	"POST": " ",
	"PREVIEW": "",
	"DEFAULT": "  / ",
	"POWERUP": "   ",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "   ",
	"CLEAR": " ",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " ",
	"INCORRECT": "",
	"OPENING_POST": "  ",
	"SET_PIN": " ",
	"ENTER_PIN": "  ",
	"ARE_YOU_SURE": "",
	"REBLOG_TEXT": "        ",
	"BROADCAST_ERROR": "    !",
	"SUCCESS": "",
	"REBLOGGED_POST": "   !",
	"LOGIN_FAIL": "    !                            .",
	"LOGIN_FAIL_A": "    !                           .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "   ",
	"VOTED_FOR_WITNESS": "    ",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": "",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": " ",
	"DAYS": "",
	"A_MONTH": " ",
	"MONTHS": "",
	"A_YEAR": " ",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "    ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "   ",
	"INSERT_PICTURE": "  ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": "  ",
	"SET_URL": "  ",
	"DIRECT_LINK_PICTURE": "    ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "    ...",
	"DELETED_COMMENT": "  ",
	"UPLOADING_PICTURE": "    ",
	"UPLOAD_COMPLETED": "  ",
	"UPLOAD_FAILED": "    ",
	"PASSWORD_INCORRECT": "     ",
	"INFO": "",
	"QR_TEXT": "        ",
	"BALANCE_TEXT": "        !",
	"NONEXIST_USER": "       !",
	"TRANSFER_TEXT": "     ",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "  ",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "   ",
	"SORT_POST_BY": "  :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": "  !",
	"POST_LATER": "    !",
	"SAVED": " ",
	"CLEARED": " ",
	"FLAGGING_TEXT": "                  .<br><br>       : <ul><li>   </li><li>   </li><li>     </li></ul>",
	"REQUEST_LIMIT_TEXT": "   .  /   !",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": " ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "               !",
	"RESET_PICTURE_TEXT": "       ",
	"RESET_COVER_PICTURE_TEXT": "       ",
	"UPDATE_REQUIRES_RESTART": "     !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "       .",
	"LOGIN_TO_X": "           /    .       .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": " ",
	"MARKETPLACE": "",
	"EXCHANGE": " ",
	"DRAFTS": " ",
	"POST_IS_UNDRAFT": "       !",
	"POST_IS_DRAFT": "       !",
	"SWIPE_LEFT": "      ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    !",
	"PULL_DOWN_TO_REFRESH": "      ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "         .",
	"CURRENCY": " ",
	"CURRENCY_TEXT": "             /          .",
	"ABOUT_11": "<br><b>  </b><br>-                  .<br>-               .<br>-                   .<br>-                               .<br>-                      .<br>-             .<br>-               .<br>-          .<br>-          .<br>-             .<br>-                   .<br>-                  .<br>-      .<br>-      .<br><br><b></b><br>1.         .<br>2.                                     .<br>3.             <br>4.             .<br><br>esteem    Steem  Golos   .<br>",
	"FOUNDER": "    ",
	"ADD_ACCOUNT": "  ",
	"PLATFORM": "",
	"ESCROW": " ",
	"ESCROW_AGENT": "   ",
	"RATIFICATION_DEADLINE": " ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": " ",
	"FROM": " ",
	"ID": " ",
	"SUBMIT": "",
	"RECEIVER": " ",
	"LOCATION": "",
	"WEBSITE": " ",
	"DISPLAY_NAME": "     "
}
},{}],113:[function(require,module,exports){
module.exports={
	"HOME": "Bahay",
	"LOGIN": "Mag-Login",
	"LOGOUT": "Lumabas",
	"PROFILE": "Iyong Profile",
	"FOLLOW": "sundan",
	"BOOKMARKS": "Mga Bookmark",
	"TRANSFER": "Ilipat",
	"MARKET": "Merkado",
	"SETTINGS": "Mga Setting",
	"ABOUT": "Tungkol dito",
	"ABOUT_1": "kung saan na kahit sino ang puwedeng kumita sa kanilang nilathala!",
	"ABOUT_2": "ay sosyal na aplikasyon kung saan babayaran ka sa pag-boblog, pag-kukumentaryo at pagpili ng tama.",
	"ABOUT_3": "at ito ay open-source, proyektong pang kumunindad. Nag o-offer ng akses sa pagbasa ng mga nilathala, pagkumentaryo, pagboto, paglathala, paglipat ng pera at iba pa na ino-offer ng {{platformname}} at ng {{sitename}}.",
	"ABOUT_4": "1. Di pinapayagan ng App ang pag-akses o pag-hawak ng pondo ng may-ari.",
	"ABOUT_5": "2. Ang App ay nag o-offer ng client-side na seguridad, na may pribadong keys na lokal at hindi nagpapadala sa anumang server.",
	"ABOUT_6": "3. Ang App ay nag o-offer ng payak, mga atraktib na user interfaces at mga karanasan.",
	"ABOUT_7": "Ang App ay hindi kailanman pumipilit sa mga may-ari na maglagay ng personal na impormasyon.",
	"ABOUT_8": "Iboto ang good-karma bilang tistigo",
	"ABOUT_9": "Kontak/Tugon:",
	"ABOUT_10": "Maraming info:",
	"REMOVE": "Tinangal",
	"MARKET_VIEW": "Tanawin ng Merkado",
	"PRICE": "Presyo",
	"AMOUNT": "Halagd",
	"TOTAL": "Kabuohan",
	"NOORDERS": "Walang bukas na order",
	"DATE": "Petsa",
	"BUY": "Bili",
	"SELL": "Benta",
	"OPEN": "Bukas",
	"HISTORY": "Kasaysayan",
	"FOLLOW_BACK": "Sundan_pabalik",
	"FOLLOWED": "sinundan",
	"UNFOLLOW": "Wag sundan",
	"FOLLOWING": "sinusundan",
	"FOLLOWERS": "sumusunod",
	"SEARCH_FOLLOWERS": "hanapin ang mga sumusunod",
	"SEARCH_FOLLOWING": "hanapin ang mga sinusundan",
	"BY": "ni",
	"IN": "sa",
	"MENU": "pagpipilian",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Uliting i-blog",
	"UPVOTE": "Pagboto ng mataas",
	"DOWNVOTE": "Pagboto ng mababa",
	"UNVOTE_DOWNVOTED": "Tanggalin ang Pagboto ng mababa",
	"UNVOTE_UPVOTED": "Tanggalin ang Pagboto ng mataas",
	"REPLY": "sagot",
	"EDIT": "Baguhin",
	"POST_1": "padulasin pakaliwa sa kumentaryo para makita ang pagpipilian",
	"POST_2": "I-tap ang mga komento para makita ang iba pang komentong nakapaloob",
	"OPTIONS": "pagpipilian",
	"RESTEEMED_BY": "Inulit na i-blog ni",
	"NOTHING_HERE": "wala pa dito",
	"BALANCES": "Balanse",
	"PROFILE_1": "{{platformname}}, mga tradeable na token na puwedeng ilipat kahit anumang oras.{{platformname}} puwedeng i-convert sa {{platformpower}} na isang prosesong tinatawag na powering up.",
	"PROFILE_2": "{{platformpower}}, impluwensya ng mga token na kumita ng higit pang power sa paghahawak ng matagal at pagboto sa mga ipinost. Kapag marami ang hinawakan mas malaki ang puwedeng maibigay na rewards.",
	"PROFILE_3": "Kahalagahan ng mga token tungkol sa{{platformsunit}} ng {{platformname}}.",
	"ESTIMATED_VALUE": "enistimang halaga",
	"PROFILE_4": "Ang tinatayang halaga ay nakabase sa isang 7-araw na karaniwang halaga ng {{platformname}}.",
	"TRANSACTION_HISTORY": "Kasaysayan ng mga Transaksyon",
	"POSTING": "Pag-post",
	"PROFILE_5": "Ang susi sa pagpost ay ginagamit sa pag-popost at pagboto. Dapat iba ito sa aktib na susi at susi ng may-ari.",
	"OWNER": "may ari",
	"PROFILE_6": "Ang susi ng may-ari ay ang master key para sa account at kailangan ito para sa pag-iba ng ibang keys. Ang pribadong key o ang password ng susi ng may-ari ay dapat itago offline.",
	"ACTIVE": "aktibo",
	"PROFILE_7": "Ang aktib na susi ay ginagamit sa paglipat at paglagay ng order sa internal na merkado.",
	"MEMO": "Tala",
	"PROFILE_8": "Ang susi ng tala ay ginagamit sa paggawa at pagbasa ng mga tala.",
	"BLOG": "Blog",
	"POSTS": "Posts",
	"REPLIES": "mga sagot",
	"WALLET": "pitaka",
	"TAG": "Tag",
	"USER": "Gumagamit",
	"CLOSE": "sara",
	"TO": "para kay",
	"ASSET": "Asset",
	"SEND": "pinadala",
	"SECURITY": "seguridad",
	"AVAILABLE": "Nagagamit",
	"PUBLIC_MEMO": "Publikong Tala",
	"TO_DESC": "Gumagamit halimbawa, good-karma",
	"PIN_CODE": "Pin Code",
	"PIN_TEXT": "Ang PIN code ay tumutulong sa pag siguro ng app at ng iyong mga datos.<br/><br/><b> Tandaan:</b> Kapag naka enable, may higit 4 na beses ka mag unlock, kapag nakalimutan mo ito, ang datos ng gumagamit ay tatanggalin ng app. Maaari kang mag re-login at magpatuloy sa paggamit ng app.",
	"NOTIFICATIONS": "Mga Abiso",
	"VOTE_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao na boboto sa ipinost mo! <br/><b>Tandaan:</b> Nakapaloob din sa mga abiso ang bigat ng iyong pagboto at mga mensaheng may alerto.",
	"VOTE": "boto",
	"COMMENT_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao na magkukumento sa mga pinost at mga komento mo!<br/><b>Tandaan:</b>Nakapaloob din sa mga abiso kung may sino mang tao <b>ang mag bago</b> sa kanilang mga komento.",
	"COMMENT": "kumentaryo",
	"FOLLOW_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang susunod at di susunod sa iyo!",
	"MENTIONS": "sinabi",
	"MENTIONS_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang babanggit sa pangalan mo sa posts/komento nila!",
	"RESTEEM": "Uliting i-blog",
	"RESTEEM_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang mag uulit sa pagblog ng iyong ipinost!",
	"CONFIGURATIONS": "Configurations",
	"VOTING": "binoboto",
	"VOTING_TEXT": "Ang bigat ng pagboto ay nakakaapekto sa power ng pagboto, kaya puwede mong ma-iregulate ang reward sa pagboto.<br/><br/><b>Tandaan:</b>Makakaiba ito sa bigat ng pagboto kapag bumoto ka ng mababa",
	"SERVER": "Server",
	"SERVER_TEXT": "Nirerekomenda",
	"SAVE_CHANGES": "I-save ang mga Pagbabago",
	"VOTERS_INFO": "Impormasyon ng mga botante",
	"WELCOME_BACK": "maligayang pagbabalik",
	"LOGIN_1": "Mag-sign in gamit ang iyong username at password para magpatuloy.",
	"LOGIN_2": "Ang susi ng pag-post ay ginagamit sa pag-post, komento, pagboto, pag-sunod.",
	"LOGIN_3": "Ang aktib na susi ay ginagamit sa paglipat at pag-update ng larawan ng may-ari.",
	"LOGIN_4": "Ang mga kredensyal ng gumagamit ay lokal na tinatago sa device. Kapag nag-logout, ang mga kredensyal ay tinatanggal!",
	"DONT_HAVE": "Wala pang account?",
	"SIGN_UP_NOW": "Mag-sign up",
	"CANCEL": "Kaselahin",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Pribadong aktib na susi",
	"POSTING_PRIKEY": "Pribadong susi sa pag-post",
	"MASTER_PASS": "Master/main password",
	"USERNAME": "Username",
	"CARD_VIEW": "Tanawin ng card",
	"COMPACT_VIEW": "Tanawing compact",
	"SEARCH": "hanapin",
	"SUBMIT_A_STORY": "magpapasa ng storya",
	"REPLYTO": "sumagot kay",
	"POST": "Post",
	"PREVIEW": "Preview",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Tanggihan ang Payout",
	"SAVE_FOR_LATER": "I-SAVE PARA MAMAYA",
	"CLEAR": "BURAHIN",
	"POST_CONTENT": "Pag-post ng nilalaman",
	"COMMENT_CONTENT": "Magkumento sa nilalaman",
	"TITLE": "titolo",
	"TAGS": "Tags",
	"NOT_MATCH": "HINDI TUGMA",
	"CONFIRM_PIN": "Kumpirhamin ang PIN",
	"INCORRECT": "hindi tama",
	"OPENING_POST": "ang post ay binubuksan",
	"SET_PIN": "Mag-set ng PIN",
	"ENTER_PIN": "ipasok ang pin",
	"ARE_YOU_SURE": "sigurado ka?",
	"REBLOG_TEXT": "Ang pagulit sa pagblog ay hindi mawawalan ng bisa, gusto mo bang magpatuloy?",
	"BROADCAST_ERROR": "Error sa pag-broadcast, subukang muli!",
	"SUCCESS": "Tagumpay",
	"REBLOGGED_POST": "Ang post ay nai-blogged ulit!",
	"LOGIN_FAIL": "Bigo sa pag-login! Mangyaring tiyakin ang master password o ang pribadong susi sa pag-post kung pinili mo ang Advanced mode.",
	"LOGIN_FAIL_A": "Bigo sa pag-login! Mangyaring tiyakin ang master password o ang pribadong aktib na susi kung pinili mo ang Advanced mode.",
	"WARNING": "babala",
	"VOTE_FOR_WITNESS": "ibinoto para maging testigo",
	"VOTED_FOR_WITNESS": "binoto para maging testigo",
	"AGO": "nakalipas",
	"FROM_NOW": "mula ngayon",
	"SECS": "segondo",
	"A_MIN": "isang minuto",
	"MINS": "mga minuto",
	"AN_HOUR": "isang oras",
	"HOURS": "mga oras",
	"A_DAY": "isang araw",
	"DAYS": "mga araw",
	"A_MONTH": "isang buwan",
	"MONTHS": "mga buwan",
	"A_YEAR": "isang taon",
	"YEARS": "mga taon",
	"MIN_READ": "minuto sa pagbasa",
	"DOWNVOTE_FLAG": "Pagboto ng mababa o Flag",
	"CAPTURE_PICTURE": "Kunan ng Larawan",
	"SELECT_PICTURE": "pili ng litrato",
	"SET_CUSTOM_URL": "Mag-set ng Custom URL",
	"INSERT_PICTURE": "Mag-insert ng Larawan",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Error sa Pag-upload",
	"CAMERA_CANCELLED": "Kinansela ang Camera",
	"SET_URL": "I-set ang URL",
	"DIRECT_LINK_PICTURE": "Direkta na web link para sa larawan",
	"COMMENT_SUBMITTED": "kumento ay napasa na",
	"DELETE_COMMENT": "bura ang kumento",
	"DELETED_COMMENT": "nabura na ang kumento",
	"UPLOADING_PICTURE": "Ang larawan ay ina-upload",
	"UPLOAD_COMPLETED": "Ang pag-upload ay nakumpleto",
	"UPLOAD_FAILED": "Bigo ang pag-upload",
	"PASSWORD_INCORRECT": "Ang password o account ay hindi tama",
	"INFO": "Impormasyon",
	"QR_TEXT": "Ilagay ang QR code sa loob ng scan area",
	"BALANCE_TEXT": "Siguraduhing may sapat na balanse para sa transaksyon!",
	"NONEXIST_USER": "Ang gumagamit na gusto mong lipatan ng pondo ay di matagpuan!",
	"TRANSFER_TEXT": "sigurado ka na gusto mo ilipat?",
	"CONFIRMATION": "Kompirmasyon",
	"TX_BROADCASTED": "Ang transaksyon ay nai-broadcast",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "mainit",
	"NEW": "bago",
	"PROMOTED": "Promoted",
	"VOTES": "mga boto",
	"PAYOUT": "bayad",
	"COMMENTS": "kumento",
	"TRENDING_30": "Trending sa 30 araw",
	"SORT_POST_BY": "Uriin ang mga post ng:",
	"PAYOUT_CYCLE": "Payout Cycle",
	"POTENTIAL_PAYOUT": "Potensyal na Payout",
	"PAST_PAYOUT": "nakaraang bayaad",
	"AUTHOR_PAYOUT": "bayad sa may akda",
	"CURATION_PAYOUT": "Curation Payout",
	"POST_SUBMITTED": "Ang post ay nai-submit!",
	"POST_LATER": "Post para sa mamayang pag-submit!",
	"SAVED": "Nai-save",
	"CLEARED": "Nai-bura",
	"FLAGGING_TEXT": "Sa pag-flag ng post na ito ay maaring matanggal ang rewards at ang material ay di na makikita.<br><br>Ang pag-flag ay puwedeng gamitin laban sa: <ul><li>Kasinungalingan o Pagkopya</li><li>Hate Speech o Internet Trolling</li><li>Di categorado na nilalaman o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Umabot sa limitasyon ang hinihiling. Tignan ang ibang trends/tags!",
	"POST_IS_UNBOOKMARK": "Ang post ay natanggal sa mga bookmarks!",
	"POST_IS_BOOKMARK": "Ang post ay naidagdag sa mga bookmarks!",
	"RESET": "I-reset",
	"MODIFY_PICTURE": "Baguhin ang larawan ng may-ari",
	"MODIFY_COVER_PICTURE": "Baguhin ang Cover ng Larawan",
	"ACTIVE_KEY_REQUIRED_TEXT": "Mangyaring magbigay ng pribadong aktib na susi kung pinili mo ang Advanced login mode!",
	"RESET_PICTURE_TEXT": "Iri-reset nito ang larawan ng gumagamit",
	"RESET_COVER_PICTURE_TEXT": "Iri-reset nito ang cover na larawan ng gumagamit",
	"UPDATE_REQUIRES_RESTART": "Kailangan i-restart para sa server update!",
	"SETTINGS_UPDATED": "Na-update ang mga settings!",
	"LANGUAGES": "lenguage",
	"LANGUAGES_TEXT": "Dito mo puwedeng ibahin ang lingguwahe ng app.",
	"LOGIN_TO_X": "Main password ang kailangan sa operasyon na ito. Mangyaring mag-login at subukang muli.",
	"GALLERY": "Gallery",
	"TRANSLATIONS": "Mga nag-ambag ng pagsasalin",
	"SHARE": "Ibahagi",
	"MARKETPLACE": "Lugar ng Merkado",
	"EXCHANGE": "magpalit",
	"DRAFTS": "Mga Borador",
	"POST_IS_UNDRAFT": "Ang post ay tinanggal sa mga borador!",
	"POST_IS_DRAFT": "Ang post ay naidagdag sa mga borador!",
	"SWIPE_LEFT": "padulasin pakaliwa para makita ang pagpipilian",
	"MANAGE": "Pamahalaan",
	"IMAGE_REMOVED": "natangal na ang imahe",
	"COPY": "copya",
	"NO_IMAGE": "walang larawan",
	"PULL_DOWN_TO_REFRESH": "Hilahin para mai-refresh",
	"EXTERNAL_APPS": "Panlabas na mga App",
	"PLUGINS": "Plugins",
	"SUGGEST": "Magmungkahi",
	"COMING_SOON": "Malapit na",
	"CHAIN": "Kadena",
	"CHAIN_TEXT": "Dito mi puwedeng baguhin ang blockchain o default na platform.",
	"CURRENCY": "Pera",
	"CURRENCY_TEXT": "Dito mo puwedeng baguhin ang iyong default na pera.",
	"ABOUT_11": "<br><b>Tampok na listahan</b> <br>-Akses sa kakaibang artikulo sa anumang paksa mo ay interesado sa pagbabasa. <br> -Makisali sa may-akda sa pamamagitan ng pagkumento, pagtalakay ng mga paksa. <br>-Pagboto para sa post na may rewards sa mga awtor pati rewards sa curation. <br>-Paglathala ng mga artikulo, blog post at mag-host sa kanila nang libre at kumita ng premyo sa pagsali at magkaroon ng tagasunod. <br>-Sumulat ng artikulo tungkol sa mga bagay, maliban sa maraming borador ng ang post na ito para sa mga mamaya publikasyon. <br>-Bookmark paborito ninyong mga artikulo para basahin sa ibang pagkakataon. <br>-Exchange o cash out sa iyong kita. <br>-Padala mong pera para sa anumang mga may-akda o mga gumagamit, mga kaibigan, mga tagasunod, at kung anu-ano pa <br>Follow kawili-wiling mga may-akda, blogger. <br> -Saliksikin ang inyong mga tagasunod at sinusunod mo ang mga may-akda. Kumuha ng mga <br>notification na manatiling may ugnayan sa iyong mga tagasunod at talakayan kayo ay kasangkot. pa <br>-Search para sa kawili-wiling tags/kategorya ng artikulo, may-akda. <br> -I-personalize ang iyong profile. <br>Sa maraming karagdagang tampok na darating. <br><br><b>Security</b> <br>1 I-access ang app kailanman o humawak ng mga gumagamit ng mga pondo. <br>2. app ay nag-aalok ng isang modelo ng seguridad sa client side, may pribadong susi na naka-host sa kanilang lugar at hindi nagpadala sa anumang mga server, ikaw ay responsable para sa pag-back up ng iyong password. <br>3. app ay nag-aalok ng mga gumagamit ng simple at kaakit-akit na interfaces at <br>4 mga karanasan. App ay nag-aalok ng dagdag na patong ng seguridad sa Kodigo ng pin <br><br>pagpapahalaga ay sumusuporta sa Steem at Golos na platform. <br>",
	"FOUNDER": "Tagapagtatag at Nangungunang Developer",
	"ADD_ACCOUNT": "Magdagdag ng account",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Deadline sa pagpapatibay",
	"ESCROW_EXPIRATION": "Escrow expiration",
	"ESCROW_FEE": "Bayad sa Escrow",
	"ESCROW_TERMS": "Mga tuntunin sa Escrow",
	"NIGHT_MODE": "Pang-gabi na mode",
	"DAY_MODE": "Pang-umagang mode",
	"VIEW_CONTEXT": "Tignan ang buong konteksto",
	"USER_NOTFOUND": "Hindi mahanap ang gumagamit",
	"APPROVE": "Aprubahan",
	"DISPUTE": "Pagtatalo",
	"RELEASE": "Release",
	"FROM": "Mula sa",
	"ID": "id",
	"SUBMIT": "Isumite",
	"RECEIVER": "Tagatanggap",
	"LOCATION": "Lokasyon",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Pangalan na nakadisplay"
}
},{}],114:[function(require,module,exports){
module.exports={
	"HOME": "Accueil",
	"LOGIN": "Connexion",
	"LOGOUT": "Dconnexion",
	"PROFILE": "Profil",
	"FOLLOW": "Suivre",
	"BOOKMARKS": "Signets",
	"TRANSFER": "Transfert",
	"MARKET": "March",
	"SETTINGS": "Paramtres",
	"ABOUT": "A propos",
	"ABOUT_1": "o n'importe qui peut gagner des rcompenses pour son contenu!",
	"ABOUT_2": "est support par la plate-forme {{platformname}}. Application cre par",
	"ABOUT_3": "Il s'agit d'un projet pour la communaut mobile et il est open-source. Il offre un accs pour lire, commenter, voter, poster, afficher le transfert de rcompense, etc. Toutes les fonctionnalits offertes par {{sitename}} et la blockchain {{platformname}}.",
	"ABOUT_4": "1. L'application n'a jamais accs aux fonds de l'utilisateur.",
	"ABOUT_5": "2. L'application offre un modle de scurit  ses client, avec des cls prives hberges localement et jamais envoyes  aucun serveurs.",
	"ABOUT_6": "3. L'application offre une interface simple et des expriences attrayantes aux utilisateurs.",
	"ABOUT_7": "4. L'application ne demande jamais  ce que les utilisateurs saisissent des informations personnelles.",
	"ABOUT_8": "Votez pour good-karma comme tmoin",
	"ABOUT_9": "Contact/Raction:",
	"ABOUT_10": "Plus d'infos:",
	"REMOVE": "Supprimer",
	"MARKET_VIEW": "Vue du march",
	"PRICE": "Prix",
	"AMOUNT": "Montant",
	"NOORDERS": "Pas d'ordres ouverts pour",
	"BUY": "Achat",
	"SELL": "Vente",
	"OPEN": "Ouvert",
	"HISTORY": "Historique",
	"FOLLOW_BACK": "Suivre",
	"FOLLOWED": "Abonn",
	"UNFOLLOW": "Dsabonner",
	"SEARCH_FOLLOWERS": "Chercher followers",
	"SEARCH_FOLLOWING": "Chercher following",
	"BY": "par",
	"IN": "dans",
	"BOOKMARK": "Signet",
	"UNVOTE_DOWNVOTED": "Retirer Downvote",
	"UNVOTE_UPVOTED": "Retirer Upvote",
	"REPLY": "Rpondre",
	"EDIT": "Editer",
	"POST_1": "Glisser vers la gauche sur les commentaires pour voir les options",
	"POST_2": "Appuyez sur les commentaires pour voir les sous-commentaires",
	"RESTEEMED_BY": "Resteem par",
	"NOTHING_HERE": "Rien ici encore...",
	"BALANCES": "Soldes",
	"PROFILE_1": "Les {{platformname}}, jetons ngociables qui peuvent tre transfrs  tout moment. Le {{platformname}} peut tre converti en {{platformpower}} dans un processus appel power-up.",
	"PROFILE_2": "{{platformpower}}, jetons d'influence, vous gagnez plus de Steem Power en le concervant  long terme et en votant sur les postes. Plus on le conserve, plus on a d'influence sur les rcompenses des autres et dans l'obtention de rcompense pour un vote en particulier.",
	"PROFILE_3": "Jetons d'une valeur d'environ {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valeur estime",
	"PROFILE_4": "La valeur estime est calcule sur une moyenne de 3.5 jours de la valeur du {{platformname}}.",
	"TRANSACTION_HISTORY": "Historique des Transactions",
	"POSTING": "Poste",
	"PROFILE_5": "La cl de post est utilise pour poster et voter. Elle doit tre diffrente des cls actives et propritaires.",
	"OWNER": "Propritaire",
	"PROFILE_6": "La cl propritaire est la cl principale du compte et est requise pour changer les autres cls. La cl prive ou le mot de passe de la cl propritaire doivent tre mis hors ligne autant que possible.",
	"PROFILE_7": "La cl active est utilise pour effectuer des transferts et passer des ordres dans le march intrieur.",
	"MEMO": "Mmo",
	"PROFILE_8": "La cl mmo permet de crer et de lire des mmos.",
	"REPLIES": "Rponses",
	"WALLET": "Portefeuille",
	"USER": "Utilisateur",
	"CLOSE": "Fermer",
	"TO": "",
	"ASSET": "Type",
	"SEND": "Envoyer",
	"SECURITY": "Scurit",
	"AVAILABLE": "Disponible",
	"PUBLIC_MEMO": "Mmo publique",
	"TO_DESC": "Utilisateur par ex. good-karma",
	"PIN_CODE": "Code PIN",
	"PIN_TEXT": "Le code PIN vous aide  scuriser l'application et vos donnes. <br/><br/><b>Note:</b> Une fois activ, vous avez 4 tentatives maximum pour dverrouiller, si vous avez oubli le pin ou si vous chouez, l'application supprimera les donnes utilisateur enregistres. Vous pouvez vous reconnecter et continuer  utiliser l'application.",
	"VOTE_TEXT": "Vous recevrez une notification quand quelqu'un votera pour un des vos contenus! <br/> <b>Note:</b> Les notifications incluent le poids du vote dans le message d'alerte. (Qu'il s'agisse d'un upvote, d' un downvote ou d'un vote retir).",
	"COMMENT_TEXT": "Vous recevrez une notification quand quelqu'un commentera un des vos posts ou un de vos commentaires!<br/> <b>Note:</b> Les notifications incluent quand quelqu'un <b>dite</b> ses propres commentaires aussi.",
	"COMMENT": "Commentaire",
	"FOLLOW_TEXT": "Vous recevrez une notification quand quelqu'un s'abonnera ou se dsabonnera de vous!",
	"MENTIONS_TEXT": "Vous recevrez une notification quand quelqu'un vous mentionnera dans un post/commentaire!",
	"VOTING": "Vote",
	"VOTING_TEXT": "Le poids ou le pourcentage du vote affecte le pouvoir de vote dans l'application, de telle manire vous pouvez rgler votre rcompense de vote. <br/><br/><b>Note:</b> Cela changera le poids/pourcentage du vote pour le downvote partout dans l'application",
	"SERVER": "Serveur",
	"SERVER_TEXT": "Recommand",
	"SAVE_CHANGES": "Sauvegarder les changements",
	"VOTERS_INFO": "Info vote",
	"WELCOME_BACK": "Bienvenue  nouveau!",
	"LOGIN_1": "Connectez-vous avec votre nom d'utilisateur et votre mot de passe pour continuer.",
	"LOGIN_2": "La cl de posts est utilise pour poster, commenter, voter, suivre.",
	"LOGIN_3": "La cl active est utilise pour les transferts et la mise  jour de l'image de profil.",
	"LOGIN_4": "Les informations d'identification de l'utilisateur sont conserves localement sur votre appareil. Lors de la dconnexion elles sont supprimes!",
	"DONT_HAVE": "Pas encore de compte?",
	"SIGN_UP_NOW": "Enregistrez-vous maintenant",
	"CANCEL": "Supprimer",
	"ADVANCED": "Avanc",
	"ACTIVE_PRIKEY": "Cl prive active",
	"POSTING_PRIKEY": "Cl prive de posts",
	"MASTER_PASS": "Mot de passe principal",
	"USERNAME": "Nom d'utilisateur",
	"CARD_VIEW": "Vue thuile",
	"COMPACT_VIEW": "Vue compacte",
	"SEARCH": "Rechercher",
	"SUBMIT_A_STORY": "Proposer un post",
	"REPLYTO": "Rpondre ",
	"PREVIEW": "Aperu",
	"DEFAULT": "Par dfaut 50% / 50%",
	"DECLINE_PAYOUT": "Refuser le payement",
	"SAVE_FOR_LATER": "Sauvegarder pour plus tard",
	"CLEAR": "Effacer",
	"POST_CONTENT": "Poster le contenu",
	"COMMENT_CONTENT": "Commenter",
	"TITLE": "Titre",
	"NOT_MATCH": "Pas de concordance",
	"CONFIRM_PIN": "Confirmer PIN",
	"OPENING_POST": "Ouverture du post",
	"SET_PIN": "Configurer PIN",
	"ENTER_PIN": "Entrer PIN",
	"ARE_YOU_SURE": "Vous tes sur?",
	"BROADCAST_ERROR": "Erreur de diffusion, essayer  nouveau!",
	"SUCCESS": "Russite",
	"REBLOGGED_POST": "Post reblog!",
	"LOGIN_FAIL": "Echec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou votre cl prive de post si vous avez choisi le mode avanc.",
	"LOGIN_FAIL_A": "chec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou avoir fourni une cl prive active lors de la connexion si vous avez choisi le mode Avanc.",
	"WARNING": "Attention",
	"VOTE_FOR_WITNESS": "Vote pour tmoin",
	"VOTED_FOR_WITNESS": "a vot pour tmoin",
	"AGO": "depuis",
	"FROM_NOW": " partir de maintenant",
	"SECS": "Secondes",
	"A_MIN": "une min",
	"AN_HOUR": "une heure",
	"HOURS": "h",
	"A_DAY": "un jour",
	"DAYS": "jours",
	"A_MONTH": "un mois",
	"MONTHS": "mois",
	"A_YEAR": "une anne",
	"YEARS": "annes",
	"MIN_READ": "min temps lecture",
	"DOWNVOTE_FLAG": "Downvote",
	"CAPTURE_PICTURE": "Capturer Image",
	"SELECT_PICTURE": "Slectionner Image",
	"SET_CUSTOM_URL": "Configurer URL personnalise",
	"INSERT_PICTURE": "Insrer Image",
	"ERROR": "Erreur",
	"UPLOAD_ERROR": "Erreur tlchargement",
	"CAMERA_CANCELLED": "Camra supprime",
	"SET_URL": "Configurer URL",
	"DIRECT_LINK_PICTURE": "Lien direct pour l'image",
	"COMMENT_SUBMITTED": "Commentaire envoy!",
	"DELETE_COMMENT": "La suppression des commentaires est irrversible.",
	"DELETED_COMMENT": "Commentaire supprim",
	"UPLOADING_PICTURE": "Tlchargement de l'image",
	"UPLOAD_COMPLETED": "Tlchargement termin",
	"UPLOAD_FAILED": "Tlchargement chou",
	"PASSWORD_INCORRECT": "Mot de passe ou nom d'utilisateur incorrect",
	"QR_TEXT": "Placer le QR code dans la zone de scan",
	"BALANCE_TEXT": "Soyez sur d'avoir un solde suffisant pour la transaction!",
	"NONEXIST_USER": "L'utilisateur auquel vous essayez d'envoyer des fonds n'existe pas!",
	"TRANSFER_TEXT": "Etes-vous sur de vouloir transfrer?",
	"TX_BROADCASTED": "La transaction est diffuse",
	"FEED": "Suivis",
	"TRENDING": "Tendance",
	"NEW": "Nouveau",
	"PROMOTED": "Promu",
	"PAYOUT": "Paiement",
	"COMMENTS": "Commentaires",
	"TRENDING_30": "Tendance depuis 30 jours",
	"SORT_POST_BY": "Classer posts par:",
	"PAYOUT_CYCLE": "Cycle de Paiement",
	"POTENTIAL_PAYOUT": "Paiement potentiel",
	"PAST_PAYOUT": "Paiement pass",
	"AUTHOR_PAYOUT": "Paiement auteur",
	"CURATION_PAYOUT": "Paiement votes",
	"POST_SUBMITTED": "Post envoy!",
	"POST_LATER": "Soumettre le post plus tard!",
	"SAVED": "Sauvegard",
	"CLEARED": "Supprim",
	"FLAGGING_TEXT": "Downvote un post peut enlever les rcompenses et rendre celui-ci moins visible.<br><br>Le Downvote devrait tre utilis pour ceci: <ul><li>Fraude ou Plagiarisme</li><li>Trolls ou discours de haine</li><li>Contenu inappropri intentionnel ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite atteinte. Dcouvrez d'autres tags/tendances!",
	"POST_IS_UNBOOKMARK": "Post enlev des signets!",
	"POST_IS_BOOKMARK": "Post ajout au signets!",
	"RESET": "Rinitialiser",
	"MODIFY_PICTURE": "Modifier l'image du profil",
	"MODIFY_COVER_PICTURE": "Modifier l'image de couverture",
	"ACTIVE_KEY_REQUIRED_TEXT": "SVP, veuillez indiquer la cl prive active si vous avez choisi le mode de connexion avanc.",
	"RESET_PICTURE_TEXT": "Ceci va rinitialiser l'image profil de l'utilisateur",
	"RESET_COVER_PICTURE_TEXT": "Ceci va rinitialiser l'image de couverture de l'utilisateur",
	"UPDATE_REQUIRES_RESTART": "La mise  jour du serveur ncessite un redmarrage!",
	"SETTINGS_UPDATED": "Paramtres mis  jour!",
	"LANGUAGES": "Langues",
	"LANGUAGES_TEXT": "Vous pouvez changer ici la langue de l'application",
	"LOGIN_TO_X": "Cette opration requiert que l'utilisateur soit connect avec le mot de passe principal, la cl de post/cl active. Veuillez vous connecter et ressayer.",
	"GALLERY": "Gallerie",
	"TRANSLATIONS": "Contributeurs de traduction",
	"SHARE": "Partage",
	"MARKETPLACE": "March",
	"EXCHANGE": "Echange",
	"DRAFTS": "Brouillons",
	"POST_IS_UNDRAFT": "Post supprim des brouillons!",
	"POST_IS_DRAFT": "Post ajout aux brouillons!",
	"SWIPE_LEFT": "Glisser vers la gauche pour voir les options",
	"MANAGE": "Grer",
	"IMAGE_REMOVED": "Image enleve",
	"COPY": "copi",
	"NO_IMAGE": "Vous n'avez pas encore tlcharger d'images pour le moment!",
	"PULL_DOWN_TO_REFRESH": "Tirez vers le bas pour rafrachir",
	"EXTERNAL_APPS": "Apps externe",
	"SUGGEST": "Suggestion",
	"COMING_SOON": "Bientt",
	"CHAIN_TEXT": "Ici vous pouvez changer pour la blockchain ou la plate-forme par dfaut."
}
},{}],115:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "        !",
	"ABOUT_2": "   {{platformname}}.    ",
	"ABOUT_3": " ,    .    ,  , ,   '.     '  {{platformname}}   {{sitename}}",
	"ABOUT_4": "1.      .",
	"ABOUT_5": "2.   ,        .",
	"ABOUT_6": "3.      .",
	"ABOUT_7": "4.      .",
	"ABOUT_8": " -good-karma  ",
	"ABOUT_9": " ",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": " ",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "    ",
	"BY": " ",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": " ",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": " ",
	"UNVOTE_UPVOTED": " ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "     ",
	"POST_2": "     -",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},     .   {{platformname}} -{{platformpower}}    -.",
	"PROFILE_2": "{{platformpower}},      .    ,             .",
	"PROFILE_3": "  {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "      -7    {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": " ",
	"PROFILE_5": "     .       .",
	"OWNER": "",
	"PROFILE_6": "            .            .",
	"ACTIVE": "",
	"PROFILE_7": "         .",
	"MEMO": "",
	"PROFILE_8": "     .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "        . :  ,     4 .    ,      .     .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "     ! :       (  , ,   ).",
	"VOTE": "",
	"COMMENT_TEXT": "       ! :        .",
	"COMMENT": "",
	"FOLLOW_TEXT": "       !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "       !",
	"RESTEEM": " ",
	"RESTEEM_TEXT": "      !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "       . :        ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": "       .",
	"LOGIN_2": "     , .",
	"LOGIN_3": "      .",
	"LOGIN_4": "      .   !",
	"DONT_HAVE": "   ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": " ",
	"POSTING_PRIKEY": " ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " -",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": "  50% / 50%",
	"POWERUP": "- 100%",
	"DECLINE_PAYOUT": " ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " ",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " ",
	"ENTER_PIN": " ",
	"ARE_YOU_SURE": "?",
	"REBLOG_TEXT": "   ,  ?",
	"BROADCAST_ERROR": " ,  !",
	"SUCCESS": "",
	"REBLOGGED_POST": "  !",
	"LOGIN_FAIL": " !                .",
	"LOGIN_FAIL_A": " !                .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": " ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": " ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": " ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "    ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": " ",
	"PASSWORD_INCORRECT": "    ",
	"INFO": "",
	"QR_TEXT": "  QR   ",
	"BALANCE_TEXT": "     !",
	"NONEXIST_USER": "      !",
	"TRANSFER_TEXT": "    ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": " ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": " -30  ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "  ",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "       .    : , ,  , , ",
	"REQUEST_LIMIT_TEXT": "   .   !",
	"POST_IS_UNBOOKMARK": "  !",
	"POST_IS_BOOKMARK": "  !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "        !",
	"RESET_PICTURE_TEXT": "  ",
	"RESET_COVER_PICTURE_TEXT": "  ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "    .",
	"LOGIN_TO_X": "             .    .",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "  !",
	"POST_IS_DRAFT": "  !",
	"SWIPE_LEFT": "   ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "   !",
	"PULL_DOWN_TO_REFRESH": "   ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": " ",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "   '    ",
	"CURRENCY": "",
	"CURRENCY_TEXT": "       .   \\   .",
	"ABOUT_11": "<br><b>  </b> <br>-       . <br> -    . <br>-    ,    . <br>-  ,        . <br>-  ,       . <br>-      . <br>-    . <br>-      <br>-     . <br> -     . <br>-            . <br>- /    . <br> -    . <br>-   . <br><br><b></b> <br>1.     . <br>2.      ,         ,     . <br>3.       <br>4.         <br><br> eSteem   Steem -Golos. <br>",
	"FOUNDER": "  ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": ""
}
},{}],116:[function(require,module,exports){
module.exports={
	"HOME": "Poetna stranica",
	"LOGIN": "Prijava",
	"LOGOUT": "Odjava",
	"PROFILE": "Profil",
	"FOLLOW": "Prati",
	"BOOKMARKS": "Oznake",
	"TRANSFER": "Prijenos",
	"MARKET": "Trgovina",
	"SETTINGS": "Postavke",
	"ABOUT": "O aplikaciji",
	"ABOUT_1": "gdje svatko moe zaraditi nagrade za svoj sadraj!",
	"ABOUT_2": "je drutvena aplikacija gdje si plaen za bloganje, komentiranje i kuracije.",
	"ABOUT_3": "i ona je otvorenog-izvora, zajednica pokree mobilni projekt. Nudi sadraj koji je dostupan za itanje, komentiranje, glasanje, objavljivanje, prijenos zarade i druge pogodnosti koje nam nudi {{platformname}} blockchain i {{sitename}}.",
	"ABOUT_4": "Aplikacija nikad ne pristupa ili zadrava korisnika sredstva.",
	"ABOUT_5": "2. Aplikacija nudi sigurnosni model na strani klijenta. Privatni kljuevi su spremeljani lokalno i nikad se ne alju na servere.",
	"ABOUT_6": "3. Aplikacija nudi jednostavno, atraktivno korisniko suelje i doivljaj.",
	"ABOUT_7": "4. Aplikacija nikad ne zahtjeva od korisnika da unosi privatne informacije.",
	"ABOUT_8": "Glasaj za good-karma kao svjedoka",
	"ABOUT_9": "Kontakt/feedback:",
	"ABOUT_10": "Vie informacija:",
	"REMOVE": "Ukloni",
	"MARKET_VIEW": "Pregled trita",
	"PRICE": "Cijena",
	"AMOUNT": "Iznos",
	"TOTAL": "Ukupno",
	"NOORDERS": "Nema otvorenih narudbi za",
	"DATE": "Datum",
	"BUY": "Kupi",
	"SELL": "Prodaj",
	"OPEN": "Otvori",
	"HISTORY": "Povijest",
	"FOLLOW_BACK": "Uzvrati praenje",
	"FOLLOWED": "Pratim",
	"UNFOLLOW": "Prestani pratiti",
	"FOLLOWING": "Praenje",
	"FOLLOWERS": "Pratitelji",
	"SEARCH_FOLLOWERS": "Pretrai pratitelje",
	"SEARCH_FOLLOWING": "Pretrai one koje pratite",
	"BY": "od",
	"IN": "u",
	"MENU": "Izbornik",
	"BOOKMARK": "Oznaka",
	"REBLOG": "Podijeli",
	"UPVOTE": "Svia mi se",
	"DOWNVOTE": "Ne svia mi se",
	"UNVOTE_DOWNVOTED": "Poniti glas",
	"UNVOTE_UPVOTED": "Poniti glas",
	"REPLY": "Odgovor",
	"EDIT": "Uredi",
	"POST_1": "Povucite u lijevo komentare da bi ste vidjeli opcije",
	"POST_2": "Dodirnite komentare da bi ste vidjeli pod-komentare",
	"OPTIONS": "Opcije",
	"RESTEEMED_BY": "Podjeljeno od",
	"NOTHING_HERE": "Jo uvijek nemate nita ovdje...",
	"BALANCES": "Stanje",
	"PROFILE_1": "{{platformname}}, Trgovinski tokeni koji se mogu prebaciti u bilo koje vrijeme.{{platformname}} moe biti prebaen u {{platformpower}} u procesu koji se zove Jaanje profila.",
	"PROFILE_2": "{{platformpower}}, tokeni koji prezentiraju jainu vaeg profila. to ih vie netko ima to ima vei utjecaj na nagradu objave za koju glasuje i zarauje vee nagrade za glasovanje.",
	"PROFILE_3": "Tokeni vrijede otprilike {{platformsunit}} od {{platformname}}.",
	"ESTIMATED_VALUE": "Procijenjena vrijednost",
	"PROFILE_4": "Procijenjena vrijednost bazirana na 7 dnevnoj prosjenoj vrijednosti od {{platformname}}.",
	"TRANSACTION_HISTORY": "Povijest transakcija",
	"POSTING": "Objavljivanje",
	"PROFILE_5": "Klju za objavljivanje se koristi za objave i glasanje. Trebao bi biti drugaiji od aktivnog i vlasnikog kljua.",
	"OWNER": "Vlasnik",
	"PROFILE_6": "Vlasniki klju je master klju za raun i potreban je za promjenu drugih kljueva. Privatni klju ili lozinka za vlasniki klju trebala bi biti van mree to je vie mogue.",
	"ACTIVE": "Aktivnosti",
	"PROFILE_7": "Aktivni klju se koristi za transakcije i zadavanje narudbi u ugraenom tritu.",
	"MEMO": "Biljeka",
	"PROFILE_8": "Klju za biljeku se koristi za izradu i itanje biljeki.",
	"BLOG": "Blog",
	"POSTS": "Objave",
	"REPLIES": "Odgovori",
	"WALLET": "Novanik",
	"TAG": "Tagovi",
	"USER": "Korisnik",
	"CLOSE": "Zatvori",
	"TO": "Za",
	"ASSET": "Imovina",
	"SEND": "Poalji",
	"SECURITY": "Sigurnost",
	"AVAILABLE": "Dostupno",
	"PUBLIC_MEMO": "Javna biljeka",
	"TO_DESC": "Korisnik npr. good-karma",
	"PIN_CODE": "Pin kod",
	"PIN_TEXT": "PIN kod vam pomae zatititi aplikaciju i vae podatke.<br/><br/><b>Napomena:</b>Kad se jednom ukljui, imate maksimalno 4 pokuaja za otkljuati, ako zaboravite pin ili pogrijeite, aplikacija e maknuti podatke logiranja. Moete se ponovo logirati i nastaviti koristiti aplikaciju.",
	"NOTIFICATIONS": "Obavijesti",
	"VOTE_TEXT": "Dobit ete obavijest kada netko glasuje za va sadraj! <br/><b>Napomena:</b> Obavijesti takoer sadre postotak glasa i opis glasa. (Svia mi se, Ne svia mi se, Ponitavanje glasa).",
	"VOTE": "Glas",
	"COMMENT_TEXT": "Dobit ete obavijest kad netko komentira vau objavu ili komentar!<br/><b>Napomena:</b>Obavijesti e takoer sadravati i <b>promjene</b> njihovih komentara.",
	"COMMENT": "Komentar",
	"FOLLOW_TEXT": "Dobit ete obavijest kad vas netko pone ili prestane pratiti!",
	"MENTIONS": "Spominjanja",
	"MENTIONS_TEXT": "Dobit ete obavijest kad vas netko spomene u objavi ili komentaru!",
	"RESTEEM": "Podijeli",
	"RESTEEM_TEXT": "Dobit ete obavijest kada netko podijeli tvoju objavu!",
	"CONFIGURATIONS": "Konfiguracija",
	"VOTING": "Glasovanje",
	"VOTING_TEXT": "Postotak glasa utjee na glasanja u aplikaciji, znai moete regulirati nagradu koju predajete objavi.<br/><br/><b>Napomena:</b> Ovo e takoer promijeniti postotak i \"Nesvianja\" i to svugdje u aplikaciji",
	"SERVER": "Server",
	"SERVER_TEXT": "Preporueno",
	"SAVE_CHANGES": "Spremi promjene",
	"VOTERS_INFO": "Informacije glasaa",
	"WELCOME_BACK": "Dobro doli natrag!",
	"LOGIN_1": "Prijavite se sa svojim korisnikim imenon i lozinkom za nastavak.",
	"LOGIN_2": "Klju za objave se koristi za objave, komentare, glasovanje, praenje.",
	"LOGIN_3": "Aktivni klju se koristi za prijenos sredstava i promjenu profilne slike.",
	"LOGIN_4": "Korisniki podatci prijave uvaju se lokalno na ureaju. Nakon odjave podatci za prijavu nestaju!",
	"DONT_HAVE": "Nemate korisniki raun?",
	"SIGN_UP_NOW": "Registrirajte se odmah",
	"CANCEL": "Odustani",
	"ADVANCED": "Napredno",
	"ACTIVE_PRIKEY": "Aktivni privatni klju",
	"POSTING_PRIKEY": "Privatni klju za objave",
	"MASTER_PASS": "Master/glavna lozinka",
	"USERNAME": "Korisniko ime",
	"CARD_VIEW": "Kartini pregled",
	"COMPACT_VIEW": "Kompaktni pregled",
	"SEARCH": "Pretrai",
	"SUBMIT_A_STORY": "Objavi novu priu",
	"REPLYTO": "Odgovor na",
	"POST": "Objava",
	"PREVIEW": "Predpregled",
	"DEFAULT": "Zadano 50% / 50%",
	"POWERUP": "Jaanje profila 100%",
	"DECLINE_PAYOUT": "Otkai isplatu",
	"SAVE_FOR_LATER": "SPREMI ZA KASNIJE",
	"CLEAR": "OISTI",
	"POST_CONTENT": "Sadraj objave",
	"COMMENT_CONTENT": "Komentirajte sadraj",
	"TITLE": "Naslov",
	"TAGS": "Tagovi",
	"NOT_MATCH": "NE ODGOVARA",
	"CONFIRM_PIN": "Potvrdite PIN",
	"INCORRECT": "NEISPRAVNO",
	"OPENING_POST": "otvaranje objave",
	"SET_PIN": "Postavi PIN",
	"ENTER_PIN": "Unesite PIN",
	"ARE_YOU_SURE": "Jeste li sigurni?",
	"REBLOG_TEXT": "Dijeljenje posta je nepovratno, elite li nastaviti?",
	"BROADCAST_ERROR": "Pogreka prilikom emitiranja, pokuajte ponovo!",
	"SUCCESS": "Uspjeno",
	"REBLOGGED_POST": "Objava je podijeljena!",
	"LOGIN_FAIL": "Prijava nije uspjela. Molimo provjerite jeste li prijavljeni sa master lozinkom ili kljuem za objave ako ste odabrali napredni nain rada.",
	"LOGIN_FAIL_A": "Prijava nije uspjela! Molimo vas provjerite jeste li prijavljeni sa master lozinkom ili aktivnim privatnim kljuem ako ste odabrali napredni nain.",
	"WARNING": "Upozorenje",
	"VOTE_FOR_WITNESS": "Glasovanje za svjedoka",
	"VOTED_FOR_WITNESS": "Glasali ste za svjedoka",
	"AGO": "prije",
	"FROM_NOW": "od sada",
	"SECS": "sekundi",
	"A_MIN": "1 min",
	"MINS": "min",
	"AN_HOUR": "1 sat",
	"HOURS": "sati",
	"A_DAY": "1 dan",
	"DAYS": "dana",
	"A_MONTH": "mjesec dana",
	"MONTHS": "mjeseci",
	"A_YEAR": "godinu dana",
	"YEARS": "godine",
	"MIN_READ": "min itanja",
	"DOWNVOTE_FLAG": "Nesvianje ili prijava",
	"CAPTURE_PICTURE": "Snimi sliku",
	"SELECT_PICTURE": "Odaberite sliku",
	"SET_CUSTOM_URL": "Postavljanje prilagoenog URL-a",
	"INSERT_PICTURE": "Umetni sliku",
	"ERROR": "Greka",
	"UPLOAD_ERROR": "Pogreka pri prijenosu",
	"CAMERA_CANCELLED": "Kamera otkazana",
	"SET_URL": "Postavi URL",
	"DIRECT_LINK_PICTURE": "Direktni web link na sliku",
	"COMMENT_SUBMITTED": "Komentar je poslan!",
	"DELETE_COMMENT": "Brisanje komentara je nepovratno...",
	"DELETED_COMMENT": "Izbrisani komentar",
	"UPLOADING_PICTURE": "Uitavanje slike",
	"UPLOAD_COMPLETED": "Uitavanje zavreno",
	"UPLOAD_FAILED": "Neuspjean prijenos",
	"PASSWORD_INCORRECT": "Pogreno korisniko ime ili lozinka",
	"INFO": "Info",
	"QR_TEXT": "Postavi QR kod unutar podruja skeniranja",
	"BALANCE_TEXT": "Provjerite imate li dovoljno sredstava za transakciju!",
	"NONEXIST_USER": "Korisnik kojem elite poslati sredstva ne postoji!",
	"TRANSFER_TEXT": "Jeste li sigurni da elite obaviti transakciju?",
	"CONFIRMATION": "Potvrda",
	"TX_BROADCASTED": "Tranksacija je provedena",
	"FEED": "Novosti",
	"TRENDING": "Popularno",
	"HOT": "Aktualno",
	"NEW": "Novo",
	"PROMOTED": "Promovirano",
	"VOTES": "Glasovi",
	"PAYOUT": "Isplata",
	"COMMENTS": "Komentari",
	"TRENDING_30": "Popularno zadnjih 30 dana",
	"SORT_POST_BY": "Rasporedi postove po:",
	"PAYOUT_CYCLE": "Isplatni ciklus",
	"POTENTIAL_PAYOUT": "Mogua isplata",
	"PAST_PAYOUT": "Prola isplata",
	"AUTHOR_PAYOUT": "Autorska isplata",
	"CURATION_PAYOUT": "Kuracijska isplata",
	"POST_SUBMITTED": "Objava je objavljena!",
	"POST_LATER": "Objava za objavljivanje kasnije!",
	"SAVED": "Spremljeno",
	"CLEARED": "Izbrisano",
	"FLAGGING_TEXT": "Prijava objave moe maknuti nagrade i uiniti njen sadraj manje vidljiv.<br><br>Prijava bi se trebala koristiti za:<ul><li>Prevare i plagijate</li><li>Govor mrnje ili provociranje</li><li>pogren</ul></ul>o kategorizirani sadraj ili spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Nema sadraja. Pogledajte druge stranice/tagove!",
	"POST_IS_UNBOOKMARK": "Objava je izbrisana iz oznaka!",
	"POST_IS_BOOKMARK": "Objava je dodana u oznake!",
	"RESET": "Resetiraj",
	"MODIFY_PICTURE": "Promijeni sliku profila",
	"MODIFY_COVER_PICTURE": "Promijeni naslovnu sliku",
	"ACTIVE_KEY_REQUIRED_TEXT": "Molimo unesite aktivni klju ako ste odabrali napredni nain logiranja!",
	"RESET_PICTURE_TEXT": "Ovo e resetirati korisniku profilnu sliku",
	"RESET_COVER_PICTURE_TEXT": "Ovo e resetirati korisniku naslovnu sliku",
	"UPDATE_REQUIRES_RESTART": "Auriranje servera zahtjeva Restart!",
	"SETTINGS_UPDATED": "Postavke su aurirane!",
	"LANGUAGES": "Jezici",
	"LANGUAGES_TEXT": "Ovdje moete promijeniti jezik aplikacije.",
	"LOGIN_TO_X": "Ovaj postupak zahtjeva da korisnik bude prijavljen sa glavnom lozinkom, aktivnim/kljuem za objave. Molimo prijavite se i pokuajte ponovo.",
	"GALLERY": "Galerija",
	"TRANSLATIONS": "Preveli i prilagodili:",
	"SHARE": "Podijeli",
	"MARKETPLACE": "Trgovina",
	"EXCHANGE": "Burza",
	"DRAFTS": "Skice",
	"POST_IS_UNDRAFT": "Objava je maknuta iz skica!",
	"POST_IS_DRAFT": "Objava je dodana u skice!",
	"SWIPE_LEFT": "Povuci u lijevo za vidjeti opcije",
	"MANAGE": "Upravljanje",
	"IMAGE_REMOVED": "Slika je uklonjena",
	"COPY": "Kopiraj",
	"NO_IMAGE": "Jo niste postavili nijednu sliku!",
	"PULL_DOWN_TO_REFRESH": "Povucite dolje za osvjeavanje",
	"EXTERNAL_APPS": "Vanjske aplikacije",
	"PLUGINS": "Dodatci",
	"SUGGEST": "Predloi",
	"COMING_SOON": "Uskoro dolazi",
	"CHAIN": "Lanac",
	"CHAIN_TEXT": "Ovdje moete promijeniti blockchain ili zadanu platformu.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Ovdje moeze promijeniti vau zadanu valutu. Nagrade na objavama i komentarima e vam biti prikazane u ovoj valuti.",
	"ABOUT_11": "<br><b>Lista mogunosti</b><br>-Pristupite bilo kojoj objavi u bilo kojoj temi koja vas zanima.<br>Ukljuite se sa autorima s komentiranjem i raspravljanjem o temama.<br>-Glasujte za objave tako da nagradite autora i da zaradite na kuracijama.<br>-Objavite vae lanke,objave besplatno i zaradite nagrade s privlaenjem i dobivanjem pratitelja.<br>-Piite lanke za putu, spremite vie skica za kasniju objavu.<br>-Oznai najdrae lanke za proitati kasnije.<br>-Razmjeni ili isplati svoju zaradu.<br>-Poaljite vaa sredstva bilo kojem autoru ili korisniku, prijatelju, pratitelju, itd.<br>-Prati zanimljive autore, blogere.<br>-Pretrai svoje pratitelje i autore koje pratite.<br>-Dobivajte obavijesti da bi ste ostali u kontaktu sa svojim pratiteljima i raspravama u kojima ste ukljueni.<br>-Pretraite zanimljive tagove/kategorije lanaka, autora.<br>Personalizirajte va profil.<br>-Jo puno novosti stie.<br><br><b>Sigurnost</b><br>1.Aplikacija nikad ne pristupa ili zadrava na korisnikim sredstvima.<br>2.Aplikacija nudi sigurnosni model na strani klijenta, s privatnim kljuevima pohranjenima lokalno i nikad se ne alju na server, vi ste odgovorni za uvanje vaih lozinki.<br>3. Aplikacija nudi jednostavano, atraktivano korisniko suelje i doivljaj<br>4.Aplikacija nudi dodatan sloj zatite sa PIN kodom<br><br>eSteem podrava Steem i Golos platforme.<br>",
	"FOUNDER": "Osniva i glavni programer",
	"ADD_ACCOUNT": "Dodaj raun",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Rok potvrivanja",
	"ESCROW_EXPIRATION": "Escrow istek",
	"ESCROW_FEE": "Escrow honorar",
	"ESCROW_TERMS": "Escrow uvjeti",
	"NIGHT_MODE": "Noni nain",
	"DAY_MODE": "Dnevni nain",
	"VIEW_CONTEXT": "Pogledaj cijeli sadraj",
	"USER_NOTFOUND": "Korisnik nije pronaen",
	"APPROVE": "Dozvoli",
	"DISPUTE": "Raspravi",
	"RELEASE": "Izdanje",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Objavi",
	"RECEIVER": "Primatelj",
	"LOCATION": "Lokacija",
	"WEBSITE": "Web stranica",
	"DISPLAY_NAME": "Prikazani naziv"
}
},{}],117:[function(require,module,exports){
module.exports={
	"HOME": "Kezdlap",
	"LOGIN": "Bejelentkezs",
	"LOGOUT": "Kijelentkezs",
	"PROFILE": "Profil",
	"FOLLOW": "Kvets",
	"BOOKMARKS": "Knyvjelzk",
	"TRANSFER": "tutals",
	"MARKET": "Piac",
	"SETTINGS": "Belltsok",
	"ABOUT": "Rlunk",
	"ABOUT_1": "ahol brki kaphat jutalmakat a tartalmairt!",
	"ABOUT_2": "a {{platformname}} platform zemelteti. Az alkalmazs ksztje",
	"ABOUT_3": "s nylt forrskd, kzssg ltal mkdtetett projekt. Tmogatja a tartalomhozzfrst olvassrt, a hozzszlst, szavazst, posztolst, fizetsg tutalst, stb. funkcikat, amiket a {{platformname}} blokklnc s a {{sitename}} knlnak.",
	"ABOUT_4": "1. Az alkalmazs soha nem fr hozz vagy trolja a felhasznlk pnzt.",
	"ABOUT_5": "2. Az alkalmazs kliens oldali biztonsgi modellt knl, a privt kulcsok helybeni trolsval, amik soha nem kerlnek elkldsre semmilyen szerverre.",
	"ABOUT_6": "3. Az alkalmazs egyszer, tetszets felhasznli felletet s -lmnyt nyjt.",
	"ABOUT_7": "4. Az alkalmazs soha nem kri a felhasznlkat a szemlyes adataik megadsra.",
	"ABOUT_8": "Szavazz good-karma -ra mint tan",
	"ABOUT_9": "Kapcsolat/Visszajelzs:",
	"ABOUT_10": "Tbb inf:",
	"REMOVE": "Eltvolts",
	"MARKET_VIEW": "Piac Nzet",
	"PRICE": "r",
	"AMOUNT": "sszeg",
	"TOTAL": "sszesen",
	"NOORDERS": "Nincs nyitott megbzs",
	"DATE": "Dtum",
	"BUY": "Vtel",
	"SELL": "Elads",
	"OPEN": "Nyits",
	"HISTORY": "Trtnet",
	"FOLLOW_BACK": "Visszakvets",
	"FOLLOWED": "Kvetve",
	"UNFOLLOW": "Kvets megszntetse",
	"FOLLOWING": "Kvetettek",
	"FOLLOWERS": "Kvetk",
	"SEARCH_FOLLOWERS": "Kvetk keresse",
	"SEARCH_FOLLOWING": "Kvetettek keresse",
	"BY": "ltal",
	"IN": "itt:",
	"MENU": "Men",
	"BOOKMARK": "Knyvjelzk",
	"REBLOG": "jrablogols",
	"UPVOTE": "Felszavazs",
	"DOWNVOTE": "Leszavazs",
	"UNVOTE_DOWNVOTED": "Leszavazs eltvoltsa",
	"UNVOTE_UPVOTED": "Felszavazs eltvoltsa",
	"REPLY": "Vlasz",
	"EDIT": "Szerkeszts",
	"POST_1": "Cssztass balra a hozzszlsokon, hogy lsd az opcikat",
	"POST_2": "Koppints a hozzszlsokon, hogy lsd az al-hozzszlsokat",
	"OPTIONS": "Opcik",
	"RESTEEMED_BY": "jraosztva ltala:",
	"NOTHING_HERE": "Semmi sincs itt mg...",
	"BALANCES": "Egyenlegek",
	"PROFILE_1": "{{platformname}}, eladhat tokenek, amelyeket t lehet utalni brmikor.\n{{platformname}} konvertlhat {{platformpower}} - egy folyamatban, amit feltltsnek neveznk.",
	"PROFILE_2": "{{platformpower}}, befolysol tokenek, amik tbb ert kapnak a hossz tv birtoklsukrt s a posztok felszavazsrt. Minl tbbet birtokol belle valaki, annl jobban tudja befolysolni msok jutalmait s kap tbb jutalmat az alapos szavazsrt.",
	"PROFILE_3": "Tokenek, amik krlbell {{platformsunit}} -nyi {{platformname}} -et rnek.",
	"ESTIMATED_VALUE": "Becslt rtk",
	"PROFILE_4": "A becslt rtk a {{platformname}} 7 napos tlagos rtkn alapszik.",
	"TRANSACTION_HISTORY": "tutals Trtnet",
	"POSTING": "Posztols",
	"PROFILE_5": "A posztol kulcs posztolsra s szavazsra hasznlatos. Klnbznek kell lennie az aktv s a tulajdonosi kulcsoktl.",
	"OWNER": "Tulajdonos",
	"PROFILE_6": "A tulajdonos kulcs egy mesterkulcs a szmlhoz s ktelez a tbbi kulcs megvltoztatshoz. A tulajdonosi kulcs privt kulcst vagy jelszavt titokban s offline kell tartani, amennyire csak lehetsges.",
	"ACTIVE": "Aktv",
	"PROFILE_7": "Az aktv kulcs hasznlatos az tutalsok indtshoz s a megbzsok bejegyzshez a bels piacon.",
	"MEMO": "Feljegyzs",
	"PROFILE_8": "A feljegyzs kulcs hasznlatos feljegyzsek ksztsre s olvassra.",
	"BLOG": "Blog",
	"POSTS": "Posztok",
	"REPLIES": "Vlaszok",
	"WALLET": "Trca",
	"TAG": "Cmke",
	"USER": "Felhasznl",
	"CLOSE": "Bezr",
	"TO": "Neki",
	"ASSET": "Vagyontrgy",
	"SEND": "Kld",
	"SECURITY": "Biztonsg",
	"AVAILABLE": "Rendelkezsre ll",
	"PUBLIC_MEMO": "Nyilvnos feljegyzs",
	"TO_DESC": "Felhasznl, pl. good-karma",
	"PIN_CODE": "PIN-kd",
	"PIN_TEXT": "A PIN-kd segt hogy megvd az alkalmazsod s az adataid. <br/><br/><b>Megjegyzs:</b> Miutn alkalmazva van, max. 4 prblkozsi lehetsged van hogy felnyisd; ha elfelejted a PIN-t vagy hibzol, az alkalmazs el fogja tvoltani minden bejelentkezett felhasznli adatot. Vissza tudsz jelentkezni s folytathatod az alkalmazs hasznlatt.",
	"NOTIFICATIONS": "rtestsek",
	"VOTE_TEXT": "rtestseket kapsz, amikor valaki szavaz a bejegyzsedre! br/> <b>Megjegyzs:</b> Az rtestsek tartalmazzk a szavazs slyozst a figyelmeztet zenetben is (Legyen az felszavazs, leszavazs vagy szavazat visszavonsa).",
	"VOTE": "Szavazs",
	"COMMENT_TEXT": "rtestst kapsz ha valaki hozzszl a posztodhoz vagy a hozzszlsodhoz! <br/> <b>Megjegyzs:</b> Az rtestsek tartalmazzk azt is, amikor valaki <b>szerkeszti</b> a hozzszlsait.",
	"COMMENT": "Hozzszls",
	"FOLLOW_TEXT": "rtestst kapsz, amikor valaki Kvet tged vagy Visszavonja a kvetst!",
	"MENTIONS": "Emltsek",
	"MENTIONS_TEXT": "rtestseket kapsz, amikor valaki megemlt tged egy posztban/hozzszlsban!",
	"RESTEEM": "jrablogols",
	"RESTEEM_TEXT": "rtestst kapsz, amikor valaki resteemeli a posztodat!",
	"CONFIGURATIONS": "Konfigurci",
	"VOTING": "Szavazs",
	"VOTING_TEXT": "A szavazat slyozsa vagy szzalka a szavazati erre van kihatssal az alkalmazsban, gy szablyozni tudod a szavazsi jutalmaid. <br/><br/><b>Megjegyzs:</b> Ez a leszavazs szavazati erejt/szzalkt is meg fogja vltoztatni s mindentt rvnyes az alkalmazson bell.",
	"SERVER": "Szerver",
	"SERVER_TEXT": "Ajnlott",
	"SAVE_CHANGES": "Vltoztatsok Mentse",
	"VOTERS_INFO": "Inf a szavazkrl",
	"WELCOME_BACK": "dv jra!",
	"LOGIN_1": "A folytatshoz jelentkezz be a felhasznlneveddel s jelszavaddal.",
	"LOGIN_2": "A posztol kulcs a posztokhoz, hozzszlsokhoz, szavazshoz s kvetshez hasznlatos.",
	"LOGIN_3": "Az aktv kulcs az utalsokhoz s a profilkp frisstshez hasznlatos.",
	"LOGIN_4": "A felhasznl bejelentkezsi adatai helyileg vannak trolva a kszlken. Kijelentkezskor a bejelentkezsi adatok eltvoltdnak!",
	"DONT_HAVE": "Nincs mg fikod?",
	"SIGN_UP_NOW": "Regisztrlj most",
	"CANCEL": "Mgse",
	"ADVANCED": "Halad",
	"ACTIVE_PRIKEY": "Aktv privt kulcs",
	"POSTING_PRIKEY": "Posztol privt kulcs",
	"MASTER_PASS": "Mester/f jelsz",
	"USERNAME": "Felhasznlnv",
	"CARD_VIEW": "Krtya nzet",
	"COMPACT_VIEW": "Kompakt nzet",
	"SEARCH": "Keress",
	"SUBMIT_A_STORY": "Cikk bekldse",
	"REPLYTO": "Vlasz neki",
	"POST": "Poszt",
	"PREVIEW": "Elnzet",
	"DEFAULT": "Alaprtelmezett 50% / 50%",
	"POWERUP": "Feltlts 100%",
	"DECLINE_PAYOUT": "Kifizets Elutastsa",
	"SAVE_FOR_LATER": "MENTS KSBBRE",
	"CLEAR": "TRLS",
	"POST_CONTENT": "Tartalom posztolsa",
	"COMMENT_CONTENT": "Hozzszls tartalomhoz",
	"TITLE": "Cm",
	"TAGS": "Cmkk",
	"NOT_MATCH": "NEM ILLIK SSZE",
	"CONFIRM_PIN": "PIN megerstse",
	"INCORRECT": "NEM MEGFELEL",
	"OPENING_POST": "nyit poszt",
	"SET_PIN": "PIN belltsa",
	"ENTER_PIN": "PIN megadsa",
	"ARE_YOU_SURE": "Biztos vagy benne?",
	"REBLOG_TEXT": "A resteem visszavonhatatlan, biztos vagy benne?",
	"BROADCAST_ERROR": "Terjesztsi hiba, prbld jra.",
	"SUCCESS": "Siker",
	"REBLOGGED_POST": "jrablogolt poszt!",
	"LOGIN_FAIL": "A belps nem sikerlt! Krlek gyzdj meg rla, hogy a mesterjelszavaddal lptl be vagy megadtad a Posztol privt kulcsot, ha a Halad mdot vlasztottad Bejelentkezskor.",
	"LOGIN_FAIL_A": "A belps nem sikerlt! Krlek gyzdj meg rla, hogy a mesterjelszavaddal lptl be vagy megadtad az Aktv privt kulcsot, ha a Halad mdot vlasztottad Bejelentkezskor.",
	"WARNING": "Figyelmeztets",
	"VOTE_FOR_WITNESS": "Szavazs tanra",
	"VOTED_FOR_WITNESS": "Szavaztl tanra",
	"AGO": "ta",
	"FROM_NOW": "mostantl",
	"SECS": "msodperc",
	"A_MIN": "egy perc",
	"MINS": "percek",
	"AN_HOUR": "egy ra",
	"HOURS": "ra",
	"A_DAY": "egy nap",
	"DAYS": "napok",
	"A_MONTH": "egy hnap",
	"MONTHS": "hnapok",
	"A_YEAR": "egy v",
	"YEARS": "vek",
	"MIN_READ": "perc olvass",
	"DOWNVOTE_FLAG": "Leszavazs vagy Jelents",
	"CAPTURE_PICTURE": "Kp Kszts",
	"SELECT_PICTURE": "Kp Kivlaszts",
	"SET_CUSTOM_URL": "Egyedi URL Bellts",
	"INSERT_PICTURE": "Kp Beilleszts",
	"ERROR": "Hiba",
	"UPLOAD_ERROR": "Feltltsi Hiba",
	"CAMERA_CANCELLED": "Kamera Trlve",
	"SET_URL": "URL bellts",
	"DIRECT_LINK_PICTURE": "Direkt web link a kphez",
	"COMMENT_SUBMITTED": "A hozszls elkldve!",
	"DELETE_COMMENT": "A hozzszlsok trlse visszavonhatatlan...",
	"DELETED_COMMENT": "Trlt hozzszls",
	"UPLOADING_PICTURE": "Kp feltltse",
	"UPLOAD_COMPLETED": "Feltlts Ksz",
	"UPLOAD_FAILED": "Feltlts Meghisult",
	"PASSWORD_INCORRECT": "A jelsz vagy felhasznlnv hibs volt",
	"INFO": "Inf",
	"QR_TEXT": "Helyezz egy QR-kdot a leolvassi terletbe",
	"BALANCE_TEXT": "Gyzdj meg rla, hogy elegend egyenleged van az utalshoz!",
	"NONEXIST_USER": "A felhasznl, akinek utalni prblsz, nem ltezik!",
	"TRANSFER_TEXT": "Biztos vagy benne, hogy utalni akarsz?",
	"CONFIRMATION": "Megersts",
	"TX_BROADCASTED": "A tranzakci kzvettve",
	"FEED": "Hrfolyam",
	"TRENDING": "Npszer",
	"HOT": "Forr",
	"NEW": "j",
	"PROMOTED": "Tmogatott",
	"VOTES": "Szavazatok",
	"PAYOUT": "Kifizets",
	"COMMENTS": "Hozzszlsok",
	"TRENDING_30": "Npszer 30 napra",
	"SORT_POST_BY": "Posztok rendezse:",
	"PAYOUT_CYCLE": "Kifizetsi Ciklus",
	"POTENTIAL_PAYOUT": "Lehetsges Kifizets",
	"PAST_PAYOUT": "Rgi Kifizets",
	"AUTHOR_PAYOUT": "Szerzi Kifizets",
	"CURATION_PAYOUT": "Kurtori Kifizets",
	"POST_SUBMITTED": "A poszt bekldve!",
	"POST_LATER": "Poszt ksbbi bekldsre!",
	"SAVED": "Mentve",
	"CLEARED": "Trlve",
	"FLAGGING_TEXT": "Egy poszt jelentse el tudja tvoltani a jutalmakat s kevsb lthatv teszi ezt az anyagot.<br><br>A jelentst a kvetkezkre kellene hasznlni: <ul><li>Csals vagy Plagizls</li><li>Gyllet beszd vagy Internet Trollkods</li><li>Tudatosan flrekategorizlt tartalom vagy Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Krsi limit elrve. Nzz meg ms trendet/cmkt!",
	"POST_IS_UNBOOKMARK": "A poszt eltvoltva a knyvjelzk kzl!",
	"POST_IS_BOOKMARK": "A poszt hozzadva a knyvjelzkhz!",
	"RESET": "Visszallts",
	"MODIFY_PICTURE": "Profilkp Mdostsa",
	"MODIFY_COVER_PICTURE": "Bortkp Mdostsa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Krlek add meg az Aktv privt kulcsot, ha a Halad belpsi mdot vlasztottad!",
	"RESET_PICTURE_TEXT": "Ez vissza fogja lltani a profilkpet",
	"RESET_COVER_PICTURE_TEXT": "Ez vissza fogja lltani a bortkpet",
	"UPDATE_REQUIRES_RESTART": "A szerver frisstse megkveteli az jraindtst.",
	"SETTINGS_UPDATED": "Belltsok frisstve!",
	"LANGUAGES": "Nyelvek",
	"LANGUAGES_TEXT": "Itt tudod megvltoztatni az alkalmazs nyelvt.",
	"LOGIN_TO_X": "Ez a mvelet megkveteli, hogy a felhasznl a f jelszavval, aktv/posztol kulcsval legyen bejelentkezve. Krlek lpj be s prbld jra.",
	"GALLERY": "Galria",
	"TRANSLATIONS": "A fordts kzremkdi",
	"SHARE": "Megoszts",
	"MARKETPLACE": "Piactr",
	"EXCHANGE": "Vlt",
	"DRAFTS": "Piszkozat",
	"POST_IS_UNDRAFT": "A bejegyzs eltvoltva a piszkozatokbl!",
	"POST_IS_DRAFT": "A bejegyzs hozzadva a piszkozatokhoz!",
	"SWIPE_LEFT": "Cssztass balra az opcikrt",
	"MANAGE": "Kezels",
	"IMAGE_REMOVED": "Kp trlve",
	"COPY": "Msols",
	"NO_IMAGE": "Mg nem tltttl fel semmilyen kpet!",
	"PULL_DOWN_TO_REFRESH": "Hzd le a frisstshez",
	"EXTERNAL_APPS": "Kls Alkalmazsok",
	"PLUGINS": "Beplk",
	"SUGGEST": "Javasol",
	"COMING_SOON": "Hamarosan megjelenik",
	"CHAIN": "Lnc",
	"CHAIN_TEXT": "Itt tudsz blokklncot vagy alaprtelmezett felletet cserlni.",
	"CURRENCY": "Pnznem",
	"CURRENCY_TEXT": "Itt tudod megvltoztatni az alaprtelmezett pnznemet. Ebben a pnznemben fogod ltni a bejegyzseid jutalmait.",
	"ABOUT_11": "<br><b>Funkci lista</b><br>- Frj hozz egyedi cikkekhez brmilyen tmban, ami csak rdekel.<br>- Kerlj kzelebb a szerzkhz hozzszlsokkal, beszlgetsekkel.<br>- Szavazz bejegyzsekre, hogy megjutalmazd a szerzket s ekzben kurtori jutalmat kapj.<br>- Publikld a cikkeid s blog posztjaid, trold ket ingyen s rj el jutalmakat azzal, hogy kvetket szerzel s foglalkozol velk.<br>- rj cikkeket menet kzben, ments el tbb piszkozatot a ksbbi publikcihoz.<br>- Knyvjelzzd a kedvenc cikkeid a ksbbi olvasshoz.<br>- Vltsd t vagy vedd ki a fizetsged.<br>- Kldj pnzt brmely szerznek, felhasznlnak, bartnak, kvetnek, stb.<br>- Kvess rdekes szerzket, bloggereket.<br>- Keress r a kvetidre s az ltalad kvetettekre.<br>- Kapj rtestseket, hogy kapcsolatban maradhass a kvetiddel s a beszlgetsekkel, amikben rszt veszel.<br>- Keress cikkeket s szerzket rdekes cmkk/kategrik alatt.<br>- Szabd szemlyre a profilodat.<br>- s mg sok j funkci vrhat.<br><br><b>Biztonsg</b><br>1. Az alkalmazs soha nem fr hozz a felhasznl pnzhez.<br>2. Az alkalmazs kliens-oldali hitelestst hasznl, a privt kulcsok helyben vannak trolva s soha nem kerlnek elkldsre semmilyen szerverre; te vagy a felels a jelszavaid biztonsgi mentseirt.<br>3. Az alkalmazs egyszer, tetszets felhasznli felletet s lmnyt nyjt<br>4. Az alkalmazs extra biztonsgi rteget knl a PIN-kddal<br><br>Az eSteem tmogatja a Steem s a Golos platformokat.<br>",
	"FOUNDER": "Alapt s Vezet fejleszt",
	"ADD_ACCOUNT": "Fik hozzadsa",
	"PLATFORM": "Platform",
	"ESCROW": "Lett",
	"ESCROW_AGENT": "Letti gynk",
	"RATIFICATION_DEADLINE": "Megerstsi hatrid",
	"ESCROW_EXPIRATION": "Lett lejrta",
	"ESCROW_FEE": "Letti dj",
	"ESCROW_TERMS": "Letti felttelek",
	"NIGHT_MODE": "jszakai md",
	"DAY_MODE": "Nappali md",
	"VIEW_CONTEXT": "Mutasd szvegkrnyezetben",
	"USER_NOTFOUND": "A Felhasznl Nem Tallhat",
	"APPROVE": "Jvhagy",
	"DISPUTE": "Vita",
	"RELEASE": "Kiads",
	"FROM": "Felad",
	"ID": "id",
	"SUBMIT": "Kld",
	"RECEIVER": "Fogad",
	"LOCATION": "Hely",
	"WEBSITE": "Weboldal",
	"DISPLAY_NAME": "Megjelentend nv"
}
},{}],118:[function(require,module,exports){
module.exports={
	"HOME": "Beranda",
	"LOGIN": "Masuk",
	"LOGOUT": "Keluar",
	"PROFILE": "Profil",
	"FOLLOW": "Ikuti",
	"BOOKMARKS": "Tandai",
	"TRANSFER": "Transfer",
	"MARKET": "Pasar",
	"SETTINGS": "Setelan",
	"ABOUT": "Tentang",
	"ABOUT_1": "Siapapun bisa mendapatkan keuntungan dari konten",
	"ABOUT_2": "Applikasi dibuat oleh",
	"ABOUT_3": "dan ini adalah open source, proyek mobile berbasis masyarakat. Ini menawarkan akses konten untuk membaca, berkomentar, voting, posting, mentransfer pendapatan, dll fitur yang ditawarkan oleh {{platformname}} blockchain dan {{sitename}}.",
	"ABOUT_4": "1. Aplikasi tidak pernah mengakses atau memegang dana pengguna.",
	"ABOUT_5": "2. Aplikasi menawarkan model keamanan client-side, dengan kunci pribadi host secara lokal dan tidak pernah dikirim ke server.",
	"ABOUT_6": "3. Aplikasi menawarkan sederhana, user interface yang menarik dan pengalaman.",
	"ABOUT_7": "4. Aplikasi tidak pernah mengharuskan pengguna untuk memasukkan informasi pribadi apapun.",
	"ABOUT_8": "Pilih good-karma sebagai witness",
	"ABOUT_9": "Kontak/Saran:",
	"ABOUT_10": "Info lebih lanjut:",
	"REMOVE": "Menghapus",
	"MARKET_VIEW": "Pasar",
	"PRICE": "Harga",
	"AMOUNT": "Jumlah",
	"TOTAL": "Jumlah",
	"NOORDERS": "No open order untuk",
	"DATE": "Tanggal",
	"BUY": "Beli",
	"SELL": "Jual",
	"OPEN": "Buka",
	"HISTORY": "Riwayat",
	"FOLLOW_BACK": "Mengikuti kembali",
	"FOLLOWED": "Diikuti",
	"UNFOLLOW": "Berhenti mengikuti",
	"FOLLOWING": "Mengikuti",
	"FOLLOWERS": "Pengikut",
	"SEARCH_FOLLOWERS": "Mencari Pengikut",
	"SEARCH_FOLLOWING": "Mencari Mengikuti",
	"BY": "oleh",
	"IN": "dalam",
	"MENU": "Menu",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Batalkan Downvote\n",
	"UNVOTE_UPVOTED": "Batalkan Upvoted\n",
	"REPLY": "Balas",
	"EDIT": "Edit",
	"POST_1": "Geser ke kiri pada komentar untuk melihat opsi",
	"POST_2": "Ketuk pada komentar untuk melihat sub-komentar",
	"OPTIONS": "Opsi",
	"RESTEEMED_BY": "Resteemed Oleh",
	"NOTHING_HERE": "Tidak ada di sini...",
	"BALANCES": "Saldo",
	"PROFILE_1": "{{Platformname}}, token tradeable yang dapat ditransfer kapan saja. {{Platformname}} dapat dikonversi ke {{kekuatan platform yang}} dalam proses yang disebut powering up.",
	"PROFILE_2": "{{Platformpower}}, mempengaruhi token yang mendapatkan lebih banyak kekuatan untuk memegang jangka panjang dan suara pada posting. Semakin satu memegang lebih satu dapat mempengaruhi imbalan lain dan mendapatkan imbalan untuk voting akurat.",
	"PROFILE_3": "Token bernilai sekitar {{platformsunit}} dari {{platformname}}.",
	"ESTIMATED_VALUE": "Perkiraan Nilai",
	"PROFILE_4": "Nilai estimasi ini didasarkan pada nilai rata-rata 7 hari {{platformname}}.",
	"TRANSACTION_HISTORY": "Sejarah Transaksi",
	"POSTING": "Postingan",
	"PROFILE_5": "Kunci postingan digunakan untuk posting dan voting. Ini harus berbeda dari tombol aktif dan pemilik.",
	"OWNER": "Pemilik",
	"PROFILE_6": "Kunci pemilik adalah kunci master untuk account dan diperlukan untuk mengubah kunci lainnya. Kunci pribadi atau password untuk kunci pemilik harus disimpan secara offline sebanyak mungkin.",
	"ACTIVE": "Aktif",
	"PROFILE_7": "Kunci aktif digunakan untuk melakukan transfer dan tempat order di pasar internal.",
	"MEMO": "Memo",
	"PROFILE_8": "Kunci memo digunakan untuk membuat dan membaca memo.",
	"BLOG": "Blog",
	"POSTS": "Post",
	"REPLIES": "Balasan",
	"WALLET": "Dompet",
	"TAG": "Tag",
	"USER": "Pengguna",
	"CLOSE": "Tutup",
	"TO": "Kepada",
	"ASSET": "Aset",
	"SEND": "Kirim",
	"SECURITY": "Keamanan",
	"AVAILABLE": "Tersedia",
	"PUBLIC_MEMO": "Memo publik",
	"TO_DESC": "Pengguna misalnya good-karma",
	"PIN_CODE": "Kode Pin",
	"PIN_TEXT": "Kode PIN membantu Anda untuk mengamankan aplikasi dan data Anda. <br/><br/> <b>Catatan:</b> Setelah diaktifkan, Anda memiliki max 4 mencoba untuk membuka, jika Anda lupa pin atau gagal, aplikasi akan hapus login data pengguna. Anda dapat login kembali dan terus menggunakan aplikasi.",
	"NOTIFICATIONS": "Notifikasi",
	"VOTE_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang memberikan suara konten Anda! <br/> <b>Catatan:</b> Pemberitahuan termasuk suara berat serta dalam pesan peringatan. (Baik itu up-vote, down-vote, un-vote).",
	"VOTE": "Voting",
	"COMMENT_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang komentar pada posting atau komentar!<br/> <b>Catatan:</b> Pemberitahuan termasuk ketika seseorang <b>Sunting</b> komentar mereka juga.",
	"COMMENT": "Komentar",
	"FOLLOW_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang Follow atau Unfollow Anda!",
	"MENTIONS": "Menyebutkan",
	"MENTIONS_TEXT": "Anda akan mendapatkan pemberitahuan bila seseorang menyebutkan Anda dalam postingan mereka/komentar!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang reblogs posting Anda!",
	"CONFIGURATIONS": "Konfigurasi",
	"VOTING": "Voting",
	"VOTING_TEXT": "Kekuatan Voting atau persentase mempengaruhi hak suara pada aplikasi, sehingga Anda dapat mengatur reward Voting Anda. <br/><br/><b>Catatan:</b> ini akan mengubah kekuatan voting/persentase untuk downvoting juga dan itu adalah di mana-mana pada aplikasi",
	"SERVER": "Server",
	"SERVER_TEXT": "Direkomendasikan",
	"SAVE_CHANGES": "Simpan perubahan",
	"VOTERS_INFO": "Voters info",
	"WELCOME_BACK": "Selamat Datang kembali!",
	"LOGIN_1": "Masuk dengan nama pengguna dan password untuk melanjutkan.",
	"LOGIN_2": "Posting kunci digunakan untuk posting, komentar, voting, follow.",
	"LOGIN_3": "Active kunci digunakan untuk transfer dan memperbarui gambar profil.",
	"LOGIN_4": "kredensial pengguna disimpan secara lokal pada perangkat. Setelah Keluar kredensial dihapus!",
	"DONT_HAVE": "Tidak memiliki akun?",
	"SIGN_UP_NOW": "Daftar Sekarang",
	"CANCEL": "Batal",
	"ADVANCED": "Lanjutan",
	"ACTIVE_PRIKEY": "Kunci aktif pribadi",
	"POSTING_PRIKEY": "Kunci Posting Pribadi",
	"MASTER_PASS": "Master/password utama",
	"USERNAME": "Nama Pengguna",
	"CARD_VIEW": "Lihat kartu",
	"COMPACT_VIEW": "Compact View",
	"SEARCH": "Cari",
	"SUBMIT_A_STORY": "Masukkan cerita",
	"REPLYTO": "Balas ke",
	"POST": "posting",
	"PREVIEW": "Tinjauan",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Menolak pembayaran",
	"SAVE_FOR_LATER": "SIMPAN UNTUK NANTI",
	"CLEAR": "BERSIHKAN",
	"POST_CONTENT": "Posting konten",
	"COMMENT_CONTENT": "Konten komentar",
	"TITLE": "Judul",
	"TAGS": "Tags",
	"NOT_MATCH": "TIDAK COCOK",
	"CONFIRM_PIN": "Konfirmasi Pin",
	"INCORRECT": "SALAH",
	"OPENING_POST": "Post pembukaan",
	"SET_PIN": "Atur PIN",
	"ENTER_PIN": "Masukan PIN",
	"ARE_YOU_SURE": "Apakah anda yakin?",
	"REBLOG_TEXT": "Reblog ireversibel, apakah Anda ingin melanjutkan?",
	"BROADCAST_ERROR": "Siaran error, coba lagi!",
	"SUCCESS": "Sukses",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Gagal masuk! Pastikan Anda telah login dengan password master atau tersedia Posting kunci pribadi pada Login jika Anda telah choosed mode Advanced.",
	"LOGIN_FAIL_A": "Gagal masuk! Pastikan Anda telah login dengan password master atau disediakan kunci pribadi Aktif di Login jika Anda telah memilih mode Advanced.",
	"WARNING": "Peringatan",
	"VOTE_FOR_WITNESS": "Voting untuk witness",
	"VOTED_FOR_WITNESS": "Voted untuk witness",
	"AGO": "lalu",
	"FROM_NOW": "dari sekarang",
	"SECS": "detik",
	"A_MIN": "semenit",
	"MINS": "menit",
	"AN_HOUR": "sejam",
	"HOURS": "jam",
	"A_DAY": "sehari",
	"DAYS": "hari",
	"A_MONTH": "sebulan",
	"MONTHS": "bulan",
	"A_YEAR": "setahun",
	"YEARS": "tahun",
	"MIN_READ": "min baca",
	"DOWNVOTE_FLAG": "Downvote atau bendera",
	"CAPTURE_PICTURE": "Ambil Gambar",
	"SELECT_PICTURE": "Pilih Gambar",
	"SET_CUSTOM_URL": "Menetapkan URL kustom",
	"INSERT_PICTURE": "Masukan Gambar",
	"ERROR": "kesalahan",
	"UPLOAD_ERROR": "kesalahan Mengupload ",
	"CAMERA_CANCELLED": "Kamera Dibatalkan",
	"SET_URL": "Menetapkan URL",
	"DIRECT_LINK_PICTURE": "Direct web link utuk Gambar",
	"COMMENT_SUBMITTED": "Komentar disampaikan!",
	"DELETE_COMMENT": "Menghapus komentar adalah ireversibel...",
	"DELETED_COMMENT": "Menghapus komentar",
	"UPLOADING_PICTURE": "Upload Gambar",
	"UPLOAD_COMPLETED": "Upload Selesai",
	"UPLOAD_FAILED": "Upload Gagal",
	"PASSWORD_INCORRECT": "Password atau nama akun tidak benar",
	"INFO": "Info",
	"QR_TEXT": "Tempatkan kode QR di dalam area pindai",
	"BALANCE_TEXT": "Pastikan Anda memiliki saldo yang cukup untuk transaksi!",
	"NONEXIST_USER": "Pengguna yang Anda ccoba untuk mentransfer dana, tidak ada!",
	"TRANSFER_TEXT": "Apakah Anda yakin Anda ingin mentransfer?",
	"CONFIRMATION": "Konfirmasi",
	"TX_BROADCASTED": "Transaksi disiarkan",
	"FEED": "Umpan",
	"TRENDING": "Trending",
	"HOT": "Hot",
	"NEW": "Baru",
	"PROMOTED": "Promosi",
	"VOTES": "Vote",
	"PAYOUT": "Dibayar",
	"COMMENTS": "Komentar",
	"TRENDING_30": "Trending 30 Hari",
	"SORT_POST_BY": "Urutkan Postingan:",
	"PAYOUT_CYCLE": "Siklus pembayaran",
	"POTENTIAL_PAYOUT": "Potensi Pembayaran",
	"PAST_PAYOUT": "Pembayaran terakhir",
	"AUTHOR_PAYOUT": "Pembayaran Penulis",
	"CURATION_PAYOUT": "Pembayaran Kurasi",
	"POST_SUBMITTED": "Post ditayangkan!",
	"POST_LATER": "Posting untuk diajukan nanti!",
	"SAVED": "Disimpan",
	"CLEARED": "Dibersihkan",
	"FLAGGING_TEXT": "Flagging postingan dapat menghapus imbalan dan membuat bahan ini kurang terlihat <br> bendera harus digunakan untuk berikut: <ul><li>Penipuan atau Plagiarisme</li><li>Kata kasar atau Internet Trolling </li><li>Konten Disengaja dikategorikan atau Spam</li> </ul>",
	"REQUEST_LIMIT_TEXT": "Batas permintaan tercapai. Lihat tren/tag lainnya!",
	"POST_IS_UNBOOKMARK": "Posting dihilangkan dari bookmark!",
	"POST_IS_BOOKMARK": "Posting ditambahkan ke bookmark!",
	"RESET": "Setel Ulang",
	"MODIFY_PICTURE": "Modifikasi gambar Profil",
	"MODIFY_COVER_PICTURE": "Memodifikasi Sampul gambar",
	"ACTIVE_KEY_REQUIRED_TEXT": "Harap memberikan kunci pribadi Active jika Anda telah memilih modus masuk Lanjutan!",
	"RESET_PICTURE_TEXT": "Ini akan menyetel ulang gambar profil",
	"RESET_COVER_PICTURE_TEXT": "Ini akan mereset gambar sampul",
	"UPDATE_REQUIRES_RESTART": "Update server memerlukan Restart!",
	"SETTINGS_UPDATED": "Pengaturan diperbarui!",
	"LANGUAGES": "Bahasa",
	"LANGUAGES_TEXT": "Di sini Anda dapat mengubah bahasa aplikasi.",
	"LOGIN_TO_X": "Operasi ini mengharuskan pengguna untuk login dengan password utama, aktif/postingan kunci. Silahkan login dan coba lagi.",
	"GALLERY": "Galeri",
	"TRANSLATIONS": "Kontributor terjemahan",
	"SHARE": "Bagikan\n",
	"MARKETPLACE": "Pasar",
	"EXCHANGE": "Pertukaran",
	"DRAFTS": "draft",
	"POST_IS_UNDRAFT": "Posting akan dihapus dari draft!",
	"POST_IS_DRAFT": "Posting ditambahkan ke draft!",
	"SWIPE_LEFT": "Geser ke kiri untuk melihat opsi",
	"MANAGE": "Mengelola\n",
	"IMAGE_REMOVED": "Gambar dihapus",
	"COPY": "copy",
	"NO_IMAGE": "Anda belum mengunggah gambar apapun, belum!",
	"PULL_DOWN_TO_REFRESH": "Tarik ke bawah untuk menyegarkan",
	"EXTERNAL_APPS": "\n External Apps",
	"PLUGINS": "Plugins",
	"SUGGEST": "Saran",
	"COMING_SOON": "Segera hadir",
	"CHAIN": "Chain\n",
	"CHAIN_TEXT": "Di sini Anda dapat mengubah blockchain atau platform default.\nChain_Text",
	"CURRENCY": "Mata uang",
	"CURRENCY_TEXT": "Di sini Anda dapat mengubah mata uang default Anda. Anda akan melihat nilai hadiah posting/komentar pada mata uang ini.",
	"ABOUT_11": "<br><b>Daftar fitur</b> <br>-akses unik artikel dalam subjek Anda tertarik membaca. <br> -Terlibat dengan penulis dengan komentar, membahas topik. <br>-Voting untuk posting ke penulis hadiah serta mendapatkan pahala pengkurasian. <br>-Publish artikel, posting blog dan host mereka secara gratis dan mendapatkan imbalan dengan melibatkan dan mendapatkan pengikut. <br>-Menulis artikel tentang pergi, menyimpan draf beberapa posting untuk kemudian publikasi. <br>-Bookmark favorit artikel untuk dibaca nanti. <br>-Exchange atau uang tunai penghasilan Anda. <br>-Mengirim dana kepada penulis atau pengguna, temanmu, pengikutmu, dll <br>-ikuti menarik penulis, blogger. <br> -Cari pengikutnya dan penulis Anda mengikuti Anda. <br>-Get pemberitahuan untuk tetap berhubungan dengan pengikut Anda dan diskusi Anda yang terlibat in. <br>-pencarian untuk menarik tags/Kategori artikel, penulis. <br> -Mempersonalisasikan profil Anda. <br>-Banyak lebih banyak fitur untuk datang. <br><br><b>Keamanan</b> <br>1. App tidak pernah mengakses atau memegang pengguna dana. <br>2. app menawarkan model keamanan sisi klien dengan private key host secara lokal dan tidak pernah dikirimkan ke server apapun, Anda bertanggung jawab untuk membuat cadangan password Anda. <br>3. app menawarkan antarmuka pengguna yang sederhana, menarik dan pengalaman <br>4. App menawarkan lapisan tambahan keamanan dengan kode pin <br><br>harga mendukung platform Steem dan Golos. <br>",
	"FOUNDER": "Pendiri dan pengembang",
	"ADD_ACCOUNT": "Tambah akun",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Agen escrow",
	"RATIFICATION_DEADLINE": "Ratifikasi tenggat waktu",
	"ESCROW_EXPIRATION": "Escrow kadaluarsa",
	"ESCROW_FEE": "Escrow biaya",
	"ESCROW_TERMS": "Escrow persyaratan",
	"NIGHT_MODE": "Mode malam",
	"DAY_MODE": "Mode Siang",
	"VIEW_CONTEXT": "Lihat konteks lengkap",
	"USER_NOTFOUND": "Pengguna tidak ditemukan",
	"APPROVE": "Disetujui",
	"DISPUTE": "Sengketa",
	"RELEASE": "Rilis",
	"FROM": "Dari",
	"ID": "id",
	"SUBMIT": "Submit",
	"RECEIVER": "Penerima",
	"LOCATION": "Lokasi",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Nama tampilan"
}
},{}],119:[function(require,module,exports){
module.exports={
	"HOME": "Pagina Iniziale",
	"LOGIN": "Accedi",
	"LOGOUT": "Esci",
	"PROFILE": "Profilo",
	"FOLLOW": "Chi Segui",
	"BOOKMARKS": "Preferiti",
	"TRANSFER": "Trasferimenti",
	"MARKET": "Mercato",
	"SETTINGS": "Impostazioni",
	"ABOUT": "Info",
	"ABOUT_1": "dove chiunque pu guadagnare ricompense per i propri contenuti!",
	"ABOUT_2": " offerto dalla piattaforma {{platformname}}. L'app  creata da",
	"ABOUT_3": "ed  un progetto per dispositivi mobili, open-source e portato avanti dalla community. Offre l'accesso per la lettura, il commento, il voto, e la pubblicazione di contenuti. Caratteristiche offerte dalla {{platformname}} blockchain e da {{sitename}}",
	"ABOUT_4": "1. L'app non ha mai l'accesso n il controllo sui fondi dell'utente.",
	"ABOUT_5": "2. L'app offre un modello di sicurezza \"lato cliente\", grazie alle chiavi private memorizzate localmente e mai trasmesse ad alcun server.",
	"ABOUT_6": "3. L'app offre un'esperienza e un'inferfaccia grafica semplice e attraente.",
	"ABOUT_7": "4. L'app non richiede mai l'inserimento di informazioni personali da parte dell'utente",
	"ABOUT_8": "Vota good-karma come testimonial",
	"ABOUT_9": "Contatti/Feedback:",
	"ABOUT_10": "Maggiori informazioni:",
	"REMOVE": "Elimina",
	"MARKET_VIEW": "Mercato",
	"PRICE": "Prezzo",
	"AMOUNT": "Importo",
	"TOTAL": "Totale",
	"NOORDERS": "Nessun ordine aperto",
	"DATE": "Data",
	"BUY": "Compra",
	"SELL": "Vendi",
	"OPEN": "Apri",
	"HISTORY": "Cronologia",
	"FOLLOW_BACK": "Segui",
	"FOLLOWED": "Seguito",
	"UNFOLLOW": "Smetti di seguire",
	"FOLLOWING": "Seguito",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Cerca tra i tuoi followers",
	"SEARCH_FOLLOWING": "Cerca tra chi segui",
	"BY": "da",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Aggiungi ai preferiti",
	"REBLOG": "Condividi",
	"UPVOTE": "Vota",
	"DOWNVOTE": "Disapprova",
	"UNVOTE_DOWNVOTED": "Rimuovi Downvote",
	"UNVOTE_UPVOTED": "Rimuovi Upvote",
	"REPLY": "Rispondi",
	"EDIT": "Modifica",
	"POST_1": "Swipe a sinistra sui commenti per visualizzare le opzioni",
	"POST_2": "Clicca sui commenti per visualizzare i sotto-commenti",
	"OPTIONS": "Opzioni",
	"RESTEEMED_BY": "Contdiviso da",
	"NOTHING_HERE": "Non c' ancora niente qui...",
	"BALANCES": "Saldi",
	"PROFILE_1": "{{platformname}}, sono tokens che possono essere scambiati. {{platformname}} possono essere convertiti in {{platformpower}} attraverso un processo chiamato powering up.",
	"PROFILE_2": " \n",
	"PROFILE_3": "I tokens valgono circa {{platformsunit}} di {{platformname}}. ",
	"ESTIMATED_VALUE": "Valore Stimato",
	"PROFILE_4": "Il valore stimato si basa sulla media degli ultimi 7 giorni di {{platformname}}.",
	"TRANSACTION_HISTORY": "Cronologia delle transazioni",
	"POSTING": "Pubblicazione",
	"PROFILE_5": "La \"posting key\"  utilizzata per la pubblicazione e la votazione di contenuti. Essa dovrebbe essere diversa dall'active e dall'owner key.",
	"OWNER": "Proprietario",
	"PROFILE_6": "La \"owner key\"  la chiave maestra dell'account ed  richiesta per modificare le altre chiavi. Tale chiave privata, cos come la password principale, dovrebbero essere tenute offline il pi possibile.",
	"ACTIVE": "Attivit",
	"PROFILE_7": "La \"active key\"  utilizzata per effettuare trasferimenti e piazzare ordini nel mercato interno.",
	"MEMO": "Memo",
	"PROFILE_8": "La \"memo key\"  utilizzata per la creazione e lettura dei memo.",
	"BLOG": "Blog",
	"POSTS": "Commenti",
	"REPLIES": "Risposte",
	"WALLET": "Portafoglio",
	"TAG": "Tag",
	"USER": "Utente",
	"CLOSE": "Chiudi",
	"TO": "A",
	"ASSET": "Asset",
	"SEND": "Invia",
	"SECURITY": "Sicurezza",
	"AVAILABLE": "Disponibile",
	"PUBLIC_MEMO": "Memo pubblica",
	"TO_DESC": "Utente ad esempio good-karma",
	"PIN_CODE": "Codice PIN",
	"PIN_TEXT": "Il codice PIN ti aiuta a rendere sicuri l'applicazione e i tuoi dati. <br/><br/><b>Attenzione:</b> una volta attivato, hai al massimo 4 tentativi per sbloccare l'app, se ti dimentichi il PIN o fallisci i tentativi, l'applicazione rimuover i dati utente. Potrai fare nuovamente il login e continuare ad usare l'applicazione.",
	"NOTIFICATIONS": "Notifiche",
	"VOTE_TEXT": "Riceverai una notifica quando qualcuno vota i tuoi contenuti!<br/><br>Nota:</b> La notifica includer il tipo di voto. (up-vote, down-vote, un-vote).",
	"VOTE": "Voto",
	"COMMENT_TEXT": "Riceverai una notifica quando qualcuno commenta un tuo post o risponde ad un tuo commento!<br/><br>Nota:</b> Riceverai una notifica anche quando qualcuno modifica il suo commento!",
	"COMMENT": "Commento",
	"FOLLOW_TEXT": "Riceverai una notifica quando qualcuno inizia o smette di seguirti!",
	"MENTIONS": "Menzione",
	"MENTIONS_TEXT": "Riceverai una notifica quando qualcuno ti menziona in un suo post o commento!",
	"RESTEEM": "Condividi",
	"RESTEEM_TEXT": "Riceverai una notifica quando qualcuno condivide il tuo post!",
	"CONFIGURATIONS": "Configurazioni",
	"VOTING": "Voto",
	"VOTING_TEXT": "Il peso del voto o la percentuale influenzano il potere di voto nell'app, cos puoi regolare il premio del tuo voto. <br/><br/><b>Nota:</b> questo cambier anche peso/percentuale del downvote.",
	"SERVER": "Server",
	"SERVER_TEXT": "Raccomandati",
	"SAVE_CHANGES": "Salva le modifiche",
	"VOTERS_INFO": "Info Votanti",
	"WELCOME_BACK": "Bentornato!",
	"LOGIN_1": "Accedi fornendo il tuo Nome Utente e la tua Password per continuare.",
	"LOGIN_2": "La \"posting key\" viene usata per pubblicare nuovi post e commenti, per votare, e per gestire chi segui",
	"LOGIN_3": "La \"active key\"  utilizzata per i trasferimenti e per aggiornare la foto del profilo.",
	"LOGIN_4": "Le tue credenziali sono memorizzate localmente sul dispositivo. Se fai il Logout le credenziali verranno rimosse!",
	"DONT_HAVE": "Non hai un account?",
	"SIGN_UP_NOW": "Registrati ora",
	"CANCEL": "Cancella",
	"ADVANCED": "Avanzate",
	"ACTIVE_PRIKEY": "Chiave privata attiva",
	"POSTING_PRIKEY": "Chiave Privata per pubblicazione",
	"MASTER_PASS": "Password principale",
	"USERNAME": "Nome Utente",
	"CARD_VIEW": "Vista estesa",
	"COMPACT_VIEW": "Vista compatta",
	"SEARCH": "Cerca",
	"SUBMIT_A_STORY": "Inserisci un articolo",
	"REPLYTO": "Rispondi a",
	"POST": "Pubblica",
	"PREVIEW": "Anteprima",
	"DEFAULT": "Predefinito 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Rifiuta ricompensa",
	"SAVE_FOR_LATER": "SALVA PER DOPO",
	"CLEAR": "CANCELLA",
	"POST_CONTENT": "Testo del post",
	"COMMENT_CONTENT": "Testo del commento",
	"TITLE": "Titolo",
	"TAGS": "Tags",
	"NOT_MATCH": "NON TROVATO",
	"CONFIRM_PIN": "Conferma PIN",
	"INCORRECT": "INCORRETTO",
	"OPENING_POST": "apertura post",
	"SET_PIN": "Imposta PIN",
	"ENTER_PIN": "Inserisci PIN",
	"ARE_YOU_SURE": "Sei sicuro?",
	"REBLOG_TEXT": "Il reblog  irreversibile, vuoi continuare?",
	"BROADCAST_ERROR": "Errore di trasmissione, riprova!",
	"SUCCESS": "Successo",
	"REBLOGGED_POST": "Post condiviso!",
	"LOGIN_FAIL": "Accesso fallito! Per favore, assicurati di aver richiesto l'accesso tramite la tua password principale o avendo inserito la \"Posting private key\" se hai scelto la modalit Avanzata.",
	"LOGIN_FAIL_A": "Accesso fallito! Per favore, assicurati di aver richiesto l'accesso tramite la tua password principale o avendo inserito la tua \"Active private key\" se hai scelto la modalit Avanzata.",
	"WARNING": "Attenzione",
	"VOTE_FOR_WITNESS": "Votazione per il witness",
	"VOTED_FOR_WITNESS": "Votato per il testimonial",
	"AGO": "fa",
	"FROM_NOW": "da ora",
	"SECS": "secondi",
	"A_MIN": "un minuto",
	"MINS": "minuti",
	"AN_HOUR": "un'ora",
	"HOURS": "ore",
	"A_DAY": "un giorno",
	"DAYS": "giorni",
	"A_MONTH": "un mese",
	"MONTHS": "mesi",
	"A_YEAR": "un anno",
	"YEARS": "anni",
	"MIN_READ": "minuti di lettura.",
	"DOWNVOTE_FLAG": "Downvote o segnala",
	"CAPTURE_PICTURE": "Scatta Foto",
	"SELECT_PICTURE": "Seleziona foto",
	"SET_CUSTOM_URL": "Imposta URL personalizzata",
	"INSERT_PICTURE": "Inserisci Immagine",
	"ERROR": "Errore",
	"UPLOAD_ERROR": "Errore durante il caricamento",
	"CAMERA_CANCELLED": "Camera cancellata",
	"SET_URL": "Imposta URL",
	"DIRECT_LINK_PICTURE": "Link web diretto per l'immagine",
	"COMMENT_SUBMITTED": "Commento inserito!",
	"DELETE_COMMENT": "La cancellazione dei commenti  irreversibile...",
	"DELETED_COMMENT": "Commento rimosso",
	"UPLOADING_PICTURE": "Sto caricando l'immagine",
	"UPLOAD_COMPLETED": "Caricamento completato",
	"UPLOAD_FAILED": "Caricamento fallito",
	"PASSWORD_INCORRECT": "Nome Utente o Password errati",
	"INFO": "Info",
	"QR_TEXT": "Posiziona un codice QR all'interno dell'area di scansione",
	"BALANCE_TEXT": "Assicurati che il tuo bilancio sia sufficiente per la transazione",
	"NONEXIST_USER": "L'utente a cui stai cercando di trasferire dei fondi non esiste!",
	"TRANSFER_TEXT": "Sei sicuro di voler procedere con il trasferimento?",
	"CONFIRMATION": "Conferma",
	"TX_BROADCASTED": "La transazione  stata trasmessa",
	"FEED": "Feed",
	"TRENDING": "Di tendenza",
	"HOT": "Popolari",
	"NEW": "Nuovo",
	"PROMOTED": "Sponsorizzati",
	"VOTES": "Voti",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Commenti",
	"TRENDING_30": "Trending per 30 giorni",
	"SORT_POST_BY": "Ordina per:",
	"PAYOUT_CYCLE": "Ciclo dei pagamenti",
	"POTENTIAL_PAYOUT": "Payout potenziale",
	"PAST_PAYOUT": "Payout passato",
	"AUTHOR_PAYOUT": "Ricompensa dell'autore",
	"CURATION_PAYOUT": "Ricompensa dei curatori",
	"POST_SUBMITTED": "L'articolo  stato inserito!",
	"POST_LATER": "Inserisci Port pi tardi!",
	"SAVED": "Salvato",
	"CLEARED": "Cancellato",
	"FLAGGING_TEXT": "Segnalare un post pu annullare le ricompense e rendere questo materiale meno visibile. <br><br> La segnalazione dovrebbe essere usata per i seguenti motivi: <ul> truffa o Plagio </li><li> incitazione all'odio o Trolling </li><li> post inseriti intenzionalmente in categorie errate o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite raggiunto. Verifica altri trend/tags!",
	"POST_IS_UNBOOKMARK": "Il post  stato rimosso dai segnalibri!",
	"POST_IS_BOOKMARK": "Il post  stato aggiunto ai segnalibri!",
	"RESET": "Reimposta",
	"MODIFY_PICTURE": "Modifica la Foto del Profilo",
	"MODIFY_COVER_PICTURE": "Modifica l'immagine di copertina",
	"ACTIVE_KEY_REQUIRED_TEXT": "Per favore, inserisci la tua \"Active private key\" se hai scelto l'accesso in modalit Avanzata!",
	"RESET_PICTURE_TEXT": "Questa azione resetter l'immagine del profilo",
	"RESET_COVER_PICTURE_TEXT": "Questa azione resetter l'immagine di copertina",
	"UPDATE_REQUIRES_RESTART": "Un aggiornamento lato server richiede il Riavvio dell'applicazione!",
	"SETTINGS_UPDATED": "Impostazioni aggiornate!",
	"LANGUAGES": "Lingua",
	"LANGUAGES_TEXT": "Qui puoi cambiare la lingua dell'app",
	"LOGIN_TO_X": "Questa operazioni richiede che l'utente abbia effettuato l'accesso. Per favore, accedi e riprova.",
	"GALLERY": "Galleria Immagini",
	"TRANSLATIONS": "Traduttori",
	"SHARE": "Condividi",
	"MARKETPLACE": "Altre applicazioni",
	"EXCHANGE": "Scambio",
	"DRAFTS": "Bozze",
	"POST_IS_UNDRAFT": "Il post  stato rimosso dalle bozze!",
	"POST_IS_DRAFT": "Il post  stato aggiunto alle bozze!",
	"SWIPE_LEFT": "Trascina a sinistra per vedere le opzioni",
	"MANAGE": "Gestisci",
	"IMAGE_REMOVED": "Immagine rimossa",
	"COPY": "Copia",
	"NO_IMAGE": "Non hai ancora caricato un'immagine!",
	"PULL_DOWN_TO_REFRESH": "Trascina in basso per aggiornare",
	"EXTERNAL_APPS": "Applicazioni esterne",
	"PLUGINS": "PlugIns",
	"SUGGEST": "Suggerisci",
	"COMING_SOON": "Prossimamente",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Qui puoi cambiare la blockchain o la piattaforma predefinita.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Qui puoi modificare la tua valuta predefinita. Vedrai il valore di ricompensa post/commento in questa valuta.",
	"ABOUT_11": "<br><b>Lista delle funzionalit</b><br>- Accesso agli articoli sulle tematiche di vostro interesse. <br>- Interazione con gli autori degli articoli commentando e discutendo sugli argomenti.<br>- Possibilit di votare i post per ricompensare gli autori e, allo stesso tempo, guadagnare ricompense dai voti dati.<br>- Possibilit di pubblicare i vostri articoli, postarli sul blog gratuitamente e guadagnare ricompense interagendo e incrementando il numero dei followers. <br>- Possibilit di scrivere articoli da pubblicare, salvando le bozze per pubblicarli in seguito.<br>- Utilizzo di un \"segnalibro\" per gli articoli preferiti, in modo da poterli leggere successivamente.<br>- Possibilit di scambiare o incassare i vostri guadagni.<br>- Possibilit di inviare i vostri fondi ad altri autori o utenti, amici, followers, etc. <br>- Ricerca dei vostri followers e degli autori che seguite.<br>- Ricezione di notifiche per rimanere aggiornati sui vostri followers e sulle discussioni in cui siete coinvolti. <br>- Ricerca di articoli per tags/categorie di vostro interesse e autori.<br>- Possibilit di personalizzare il proprio profilo.<br>- Molte altre funzionalit sono in fase di sviluppo.<br><br><b>Sicurezza</b><br>1. L'Applicazione non avr mai accesso ai fondi degli utenti n li potr detenere. <br>2. L'Applicazione offre un modello di sicurezza Client-side, con Chiavi private detenute localmente e mai inviate ad alcun server. Tu stesso sarai responsabile di fare il backup delle tue Chiavi Private/Passwords. <br>3. L'Applicazione offre interfaccia ed esperienze semplice e attraenti per l'utente. <br>4. L'Applicazione offre un ulteriore livello di sicurezza tramite l'uso di codice Pin. <br><br>eSteem supporta le piattaforme di Steem e di Golos.<br>",
	"FOUNDER": "Fondatore e responsabile dello sviluppo",
	"ADD_ACCOUNT": "Aggiungi account",
	"PLATFORM": "Piattaforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Depositario",
	"RATIFICATION_DEADLINE": "Scadenza della ratificazione",
	"ESCROW_EXPIRATION": "Scadenza del deposito",
	"ESCROW_FEE": "Tassa del deposito",
	"ESCROW_TERMS": "Condizioni e termini del Deposito",
	"NIGHT_MODE": "Modalit notturna",
	"DAY_MODE": "Modalit diurna",
	"VIEW_CONTEXT": "Mostra il testo completo",
	"USER_NOTFOUND": "Utente non trovato",
	"APPROVE": "Approva",
	"DISPUTE": "Controversia",
	"RELEASE": "Rilascia",
	"FROM": "Da",
	"ID": "id",
	"SUBMIT": "Inserisci",
	"RECEIVER": "Destinatario",
	"LOCATION": "Localit",
	"WEBSITE": "Sito Web",
	"DISPLAY_NAME": "Visualizza nome"
}
},{}],120:[function(require,module,exports){
module.exports={
	"HOME": "Kediaman",
	"LOGIN": "Log Masuk",
	"LOGOUT": "Log Keluar",
	"PROFILE": "Profil",
	"FOLLOW": "Ikut",
	"BOOKMARKS": "Penanda buku",
	"TRANSFER": "Pindah",
	"MARKET": "Pasar",
	"SETTINGS": "Tetapan",
	"ABOUT": "Mengenai",
	"ABOUT_1": "di mana anda terima ganjaran untuk isi kandundan anda!",
	"ABOUT_2": "dikuasai oleh platform {{platformname}}, aplikasi dicipta oleh.",
	"ABOUT_3": "dan ianya sumber terbuka, komuniti yang didorong oleh projek mudah alih. Ia menawarkan akses kandungan untuk membaca, mengulas, mengundi, posting, pemindahan pendapatan, dan lain-lain ciri-ciri yang ditawarkan oleh {{platformname}} blockchain dan {{sitename}}.",
	"ABOUT_4": "1. Aplikasi ini tidak mempynyai akses ke akaun anda.",
	"ABOUT_5": "2. Aplikasi menawarkan keselamatan-klien, dengan kunci peribadi yang dihoskan dalam tempatan dan tidak akan dihantar ke mana-mana server lain.",
	"ABOUT_6": "3. Aplikasi menawarkan antaramuka pengguna yang mudah dan menarik.",
	"ABOUT_7": "4. Aplikasi tidak akan memerlukan pengguna untuk memasukkan maklumat peribadi.",
	"ABOUT_8": "Undi good-karma sebagai saksi",
	"ABOUT_9": "Hubungi/Maklum balas:",
	"ABOUT_10": "Info lanjut:",
	"REMOVE": "Membuang",
	"MARKET_VIEW": "Gambaran Pasaran",
	"PRICE": "Harga",
	"AMOUNT": "Jumlah",
	"TOTAL": "Jumlah",
	"NOORDERS": "Pesanan tidak terbuka untuk",
	"DATE": "Tarikh",
	"BUY": "Beli",
	"SELL": "Menjual",
	"OPEN": "Dibuka",
	"HISTORY": "Sejarah",
	"FOLLOW_BACK": "Ikut kembali",
	"FOLLOWED": "Diikuti",
	"UNFOLLOW": "Berhenti",
	"FOLLOWING": "Berikut",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Cari pengikut",
	"SEARCH_FOLLOWING": "Cari pengikut",
	"BY": "oleh",
	"IN": "dalam",
	"MENU": "Menu",
	"BOOKMARK": "Penanda buku",
	"REBLOG": "Reblog",
	"UPVOTE": "Undi naik",
	"DOWNVOTE": "Undi (negatif)",
	"UNVOTE_DOWNVOTED": "Batalkan undi (negatif)",
	"UNVOTE_UPVOTED": "Batalkan undi",
	"REPLY": "Jawapan",
	"EDIT": "Edit",
	"POST_1": "Sapu ke kiri atas komen untuk melihat opsyen",
	"POST_2": "Ketuk atas komen untuk melihat sub-komen",
	"OPTIONS": "Pilihan",
	"RESTEEMED_BY": "Reblogged oleh",
	"NOTHING_HERE": "TIADA APA DI SINI",
	"BALANCES": "Baki",
	"PROFILE_1": "{{platformname}}, token cair yang boleh dipindahkan pada bila-bila masa. {{platformname}} boleh ditukar kepada {{platformpower}} di dalam proses yang dipanggil menjanakan.",
	"PROFILE_2": "{{platformpower}}, pengaruh token yang mendapat kuasa yang lebih untuk pegangan jangka panjang dan pengundian ke atas posting. Lebih banyak seseorang memegang lebih banyak yang boleh mempengaruhi ganjaran lain dan mendapat ganjaran untuk undian yang tepat.",
	"PROFILE_3": "Token bernilai kira-kira {{platformsunit}} daripada {{platformname}}.",
	"ESTIMATED_VALUE": "Anggaran nilai",
	"PROFILE_4": "Nilai anggaran ini adalah berdasarkan nilai purata 7 hari {{platformname}}.",
	"TRANSACTION_HISTORY": "Urus niaga",
	"POSTING": "PENEMPATAN",
	"PROFILE_5": "Kekunci posting digunakan untuk posting dan mengundi. Ia harus berbeza daripada kekunci aktif dan pemilik.",
	"OWNER": "Pemilik",
	"PROFILE_6": "Kekunci pemilik adalah kunci utama untuk akaun dan dikehendaki menukar kekunci yang lain. Kunci peribadi dan kata laluan untuk pemilik kunci perlu disimpan di luar talian sebanyak mungkin.",
	"ACTIVE": "Aktif",
	"PROFILE_7": "Kekunci yang aktif digunakan untuk membuat pemindahan dan membuat pesanan dalam pasaran dalaman.",
	"MEMO": "Memo",
	"PROFILE_8": "Kekunci memo digunakan untuk mencipta dan membaca memo.",
	"BLOG": "Blog",
	"POSTS": "Jawatan",
	"REPLIES": "Balasan",
	"WALLET": "Wallet",
	"TAG": "Tag",
	"USER": "Pengguna",
	"CLOSE": "Tutup",
	"TO": "To",
	"ASSET": "Aset",
	"SEND": "Hantar",
	"SECURITY": "Keselamatan",
	"AVAILABLE": "Tersedia",
	"PUBLIC_MEMO": "Memo awam",
	"TO_DESC": "Pengguna contohnya good-karma",
	"PIN_CODE": "Kod Pin",
	"PIN_TEXT": "Kod PIN membantu anda untuk mendapatkan aplikasi dan data anda. <br/> <br/> <b>Nota:</b> Sebaik sahaja dibolehkan, anda mempunyai maksimum 4 cuba untuk membuka, jika anda terlupa pin atau gagal, aplikasi akan memadam log masuk data pengguna. Anda boleh login semula dan terus menggunakan aplikasi.",
	"NOTIFICATIONS": "Warta",
	"VOTE_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang undi kandungan anda! <br/> <b>Nota:</b> pemberitahuan termasuk mengundi berat serta mesej amaran. (sama ada undi (positif), undi (negatif), membatalkan undi).",
	"VOTE": "Vote",
	"COMMENT_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang atau memberi komen pada posting atau komen anda! <br/> <b>Nota:</b> Pemberitahuan termasuk apabila seseorang <b>suntingan</b> komen mereka juga.",
	"COMMENT": "Komen",
	"FOLLOW_TEXT": "Anda akan mendapatkan pemberitahuan apabila seseorang mengikuti atau ikut anda!",
	"MENTIONS": "Menyebut",
	"MENTIONS_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang menyebut anda di post/komen!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang reblog post anda!",
	"CONFIGURATIONS": "Konfigurasi",
	"VOTING": "Mengundi",
	"VOTING_TEXT": "Berat undi atau peratus menjejaskan kuasa mengundi pada aplikasi, supaya anda boleh mengawal ganjaran mengundi. <br/> <br/> <b>Nota:</b> Ini akan mengubah berat/peratusan undian untuk undi (negatif) juga dan ia adalah di mana-mana aplikasi",
	"SERVER": "Server",
	"SERVER_TEXT": "Disyorkan",
	"SAVE_CHANGES": "Simpan perubahan",
	"VOTERS_INFO": "Info pengundi",
	"WELCOME_BACK": "Selamat kembali!",
	"LOGIN_1": "Daftar Masuk dengan username dan password anda untuk teruskan.",
	"LOGIN_2": "Kunci posting digunakan untuk pos komen, undi, ikut.",
	"LOGIN_3": "Kunci aktif digunakan untuk pemindahan dan kemaskini gambar profil.",
	"LOGIN_4": "Kelayakan pengguna disimpan secara tempatan pada peranti. Apabila log keluar kelayakan akan dikeluarkan!",
	"DONT_HAVE": "Tidak ada akaun?",
	"SIGN_UP_NOW": "Daftarlah sekarang",
	"CANCEL": "Batal",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Kunci aktif persendirian",
	"POSTING_PRIKEY": "Kunci posting persendirian",
	"MASTER_PASS": "Kata laluan induk/utama",
	"USERNAME": "Nama Pengguna",
	"CARD_VIEW": "Kad paparan",
	"COMPACT_VIEW": "Paparan yang padat",
	"SEARCH": "Carian",
	"SUBMIT_A_STORY": "Hantar cerita",
	"REPLYTO": "Balas kepada",
	"POST": "Hantar",
	"PREVIEW": "Preview",
	"DEFAULT": "Lalai 50% / 50%",
	"POWERUP": "Mengekuasai 100%",
	"DECLINE_PAYOUT": "Menolak bayaran",
	"SAVE_FOR_LATER": "SIMPAN UNTUK KEMUDIAN",
	"CLEAR": "JELAS",
	"POST_CONTENT": "Post kandungan",
	"COMMENT_CONTENT": "Komen kandungan",
	"TITLE": "Tajuk",
	"TAGS": "Tags",
	"NOT_MATCH": "TIDAK PADAN",
	"CONFIRM_PIN": "Sahkan PIN",
	"INCORRECT": "BETUL",
	"OPENING_POST": "pembukaan post",
	"SET_PIN": "Tetapkan PIN",
	"ENTER_PIN": "Masukkan PIN",
	"ARE_YOU_SURE": "Adakah anda pasti?",
	"REBLOG_TEXT": "Reblog tidak boleh dibalikkan, adakah anda pasti hendak meneruskan?",
	"BROADCAST_ERROR": "Disiarkan ralat, cuba lagi!",
	"SUCCESS": "Kejayaan",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Log masuk gagal! Sila pastikan anda telah log masuk dengan kata laluan induk atau kunci peribadi posting anda ke atas log masuk jika anda telah memilih mod Advanced.",
	"LOGIN_FAIL_A": "Log masuk gagal! Sila pastikan anda telah log masuk dengan kata laluan induk atau kunci peribadi posting anda ke atas log masuk jika anda telah memilih mod Advanced.",
	"WARNING": "Amaran",
	"VOTE_FOR_WITNESS": "Mengundi untuk saksi",
	"VOTED_FOR_WITNESS": "Mengundi untuk saksi",
	"AGO": "Lalu",
	"FROM_NOW": "dari sekarang",
	"SECS": "saat",
	"A_MIN": "minit",
	"MINS": "minit",
	"AN_HOUR": "sejam",
	"HOURS": "jam",
	"A_DAY": "satu hari",
	"DAYS": "hari",
	"A_MONTH": "sebulan",
	"MONTHS": "bulan",
	"A_YEAR": "setahun",
	"YEARS": "tahun",
	"MIN_READ": "minit membaca",
	"DOWNVOTE_FLAG": "Vote (negatif) atau Menandai",
	"CAPTURE_PICTURE": "Tangkap gambar",
	"SELECT_PICTURE": "Pilih gambar",
	"SET_CUSTOM_URL": "Tetapkan URL boleh-ubah",
	"INSERT_PICTURE": "Masukkan gambar",
	"ERROR": "Ralat",
	"UPLOAD_ERROR": "Ralat muat naik",
	"CAMERA_CANCELLED": "Kamera Telah Dibatalkan",
	"SET_URL": "Tetapkan URL",
	"DIRECT_LINK_PICTURE": "Pautan web langsung gambar",
	"COMMENT_SUBMITTED": "Komen dihantar!",
	"DELETE_COMMENT": "Menghapuskan komen tidak boleh dibalikkan...",
	"DELETED_COMMENT": "Komen dihapuskan",
	"UPLOADING_PICTURE": "Muat Naik Gambar",
	"UPLOAD_COMPLETED": "Muat Naik Selesai",
	"UPLOAD_FAILED": "Muat Naik Gagal",
	"PASSWORD_INCORRECT": "Nama akaun atau kata laluan tidak betul",
	"INFO": "Maklumat",
	"QR_TEXT": "Letakkan Kod QR di dalam kawasan imbasan",
	"BALANCE_TEXT": "Pastikan anda mempunyai baki yang mencukupi untuk transaksi!",
	"NONEXIST_USER": "Pengguna yang anda cuba untuk memindahkan dana, tidak wujud!",
	"TRANSFER_TEXT": "Adakah anda pasti anda mahu memindahkan?",
	"CONFIRMATION": "Pengesahan",
	"TX_BROADCASTED": "Urus niaga disiarkan",
	"FEED": "Suapan",
	"TRENDING": "Tren",
	"HOT": "Panas",
	"NEW": "Baru",
	"PROMOTED": "Digalakkan",
	"VOTES": "Undi",
	"PAYOUT": "Pembayaran",
	"COMMENTS": "KOMENTAR",
	"TRENDING_30": "Tren untuk 30 hari",
	"SORT_POST_BY": "Posting susun oleh:",
	"PAYOUT_CYCLE": "Kitaran pembayaran",
	"POTENTIAL_PAYOUT": "Potensi Pembayaran",
	"PAST_PAYOUT": "Pembayaran Masa Lalu",
	"AUTHOR_PAYOUT": "Bayaran Penulis",
	"CURATION_PAYOUT": "Pembayaran Curation",
	"POST_SUBMITTED": "Pos dihantar!",
	"POST_LATER": "Pos untuk penghantaran lewat!",
	"SAVED": "tersimpan",
	"CLEARED": "DIPADAMKAN",
	"FLAGGING_TEXT": "Menanda atau undian (negatif) pos boleh keluarkan ganjaran dan jadikan bahan ini kurang kelihatan. <br><br>Bendera hendaklah digunakan untuk perkara-perkara berikut: <ul><li>penipuan atau plagiat</li> <li>ucapan benci atau Internet Trolling</li> <li>Kategori yang mengelirukan atau Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Had pemintaan dicapai. Menyemak aliran tag lain!",
	"POST_IS_UNBOOKMARK": "Pos dialih keluar daripada penanda!",
	"POST_IS_BOOKMARK": "Post ditambah ke penanda!",
	"RESET": "Tetapkan semula",
	"MODIFY_PICTURE": "Tukar Gambar Profil",
	"MODIFY_COVER_PICTURE": "Tukar Gambar Cover",
	"ACTIVE_KEY_REQUIRED_TEXT": "Sila berikan kunci peribadi yang aktif jika anda telah memilih mod login maju!",
	"RESET_PICTURE_TEXT": "Ini akan menetapkan semula gambar profil pengguna",
	"RESET_COVER_PICTURE_TEXT": "Ini akan menetapkan semula gambar profil pengguna",
	"UPDATE_REQUIRES_RESTART": "Kemaskini pelayan memerlukan reset!",
	"SETTINGS_UPDATED": "Tetapan dikemaskini!",
	"LANGUAGES": "BAHASA",
	"LANGUAGES_TEXT": "Di sini anda boleh menukar bahasa daripada aplikasi ini.",
	"LOGIN_TO_X": "Operasi ini memerlukan pengguna log masuk dengan kata laluan utama, kekunci aktif/posting. Sila log masuk dan cuba lagi.",
	"GALLERY": "GALERI",
	"TRANSLATIONS": "TERJEMAHAN",
	"SHARE": "Kongsi",
	"MARKETPLACE": "Pasaran",
	"EXCHANGE": "Pertukaran",
	"DRAFTS": "Draf",
	"POST_IS_UNDRAFT": "Pos dialih keluar daripada draf!",
	"POST_IS_DRAFT": "Post ditambah kepada draf!",
	"SWIPE_LEFT": "Sapu kiri untuk melihat opsyen",
	"MANAGE": "Urus",
	"IMAGE_REMOVED": "Imej dikeluarkan",
	"COPY": "Salin",
	"NO_IMAGE": "Anda tidak upload gambar apa-apa, lagi!",
	"PULL_DOWN_TO_REFRESH": "Tarik ke bawah untuk memuat semula",
	"EXTERNAL_APPS": "Aplikasi luaran",
	"PLUGINS": "Plugin",
	"SUGGEST": "Cadangkan",
	"COMING_SOON": "Akan datang",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Di sini anda boleh menukar platform blockchain atau lalai.",
	"CURRENCY": "Matawang",
	"CURRENCY_TEXT": "Di sini anda boleh menukar Mata Wang lalai anda. Anda akan melihat post/komen ganjaran nilai Mata Wang ini.",
	"ABOUT_11": "<br><b>Senarai ciri-ciri</b> <br>akses unik artikel dalam mana-mana subjek anda berminat membaca. <br> -Melibatkan diri dengan penulis oleh mengulas, membincangkan topik. <br>-Pengundian bagi jawatan kepada pengarang ganjaran serta mendapat ganjaran curation. <br>-Siarkan artikel, posting blog anda dan host mereka secara percuma dan mendapat ganjaran dengan melibatkan dan mendapat pengikut. <br>Tulis artikel mengenai pergi, simpan beberapa Draf jawatan untuk penerbitan kemudian. <br>-Bookmark artikel kegemaran membaca kemudian. <br>-Pertukaran atau Wang Tunai daripada pendapatan anda. <br>Menghantar dana anda kepada mana-mana pengarang atau pengguna, rakan-rakan, pengikut, dan lain-lain <br>-ikut penulis menarik, Blogger. <br> -Cari pengikut dan penulis anda mengikuti anda. <br>-Dapatkan pemberitahuan untuk kekal berhubung dengan pengikut dan perbincangan anda anda akan terlibat in. <br>-Cari label/kategori menarik artikel, pengarang. <br> -Memperibadikan profil anda. <br>-Banyak lebih banyak ciri untuk datang. <br><br><b>Keselamatan</b> <br>1. Aplikasi tidak pernah mencapai atau memegang wang pengguna. <br>2. aplikasi menawarkan model Keselamatan-klien, dengan kunci peribadi yang dihoskan dalam negara dan tidak pernah dihantar ke mana-mana pelayan, anda bertanggungjawab untuk menyandarkan kata laluan anda. <br>3. aplikasi menawarkan antara muka pengguna yang mudah, menarik dan pengalaman <br>4. Aplikasi menawarkan tambahan lapisan Keselamatan dengan harga <br><br>kod pin menyokong platform Steem dan Golos. <br>",
	"FOUNDER": "Pengasas dan pemaju utama",
	"ADD_ACCOUNT": "Tambah akaun",
	"PLATFORM": "Platform",
	"ESCROW_AGENT": "Ejen escrow",
	"RATIFICATION_DEADLINE": "Tarikh akhir kelulusan",
	"ESCROW_EXPIRATION": "Escrow tamat",
	"ESCROW_FEE": "Yuran escrow",
	"ESCROW_TERMS": "Terma-terma escrow"
}
},{}],121:[function(require,module,exports){
module.exports={
	"HOME": "Home",
	"LOGIN": "Log in",
	"LOGOUT": "Log uit",
	"PROFILE": "Profiel",
	"FOLLOW": "Volgen",
	"BOOKMARKS": "Bladwijzers",
	"TRANSFER": "Overschrijven",
	"MARKET": "Markt",
	"SETTINGS": "Instellingen",
	"ABOUT": "Over",
	"ABOUT_1": "waar iedereen een beloning kan verdienen!",
	"ABOUT_2": "is social media dienst waar je betaald wordt voor het bloggen, antwoorden en cureren.",
	"ABOUT_3": "en het is een open-source, communitie gedreven project. Het biedt mogelijkheden tot lezen, reageren, stemmen, plaatsen van berichten, overschrijven van inkomsten, etc. functies worden aangeboden door {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. De app heeft geen toegang tot tegoeden van de gebruiker.",
	"ABOUT_5": "2. De app biedt een client beveiligingsmodel, met priv sleutels die lokaal worden opgeslagen en nooit naar servers worden verzonden.",
	"ABOUT_6": "3. De app biedt simpele, aantrekkelijke gebruikersomgevingen en ervaringen.",
	"ABOUT_7": "4. De app vraagt u nooit om persoonlijke informatie.",
	"ABOUT_8": "Stem op good-karma als witness",
	"ABOUT_9": "Contact/Terugkoppeling:",
	"ABOUT_10": "Meer informatie:",
	"REMOVE": "Verwijderen",
	"MARKET_VIEW": "Markt Weergave",
	"PRICE": "Prijs",
	"AMOUNT": "Bedrag",
	"TOTAL": "Totaal",
	"NOORDERS": "Geen uitstaande bestellingen voor",
	"DATE": "Datum",
	"BUY": "Kopen",
	"SELL": "Verkopen",
	"OPEN": "Open",
	"HISTORY": "Geschiedenis",
	"FOLLOW_BACK": "Terugvolgen",
	"FOLLOWED": "Gevolgd",
	"UNFOLLOW": "Ontvolgen",
	"FOLLOWING": "Volgen",
	"FOLLOWERS": "Volgers",
	"SEARCH_FOLLOWERS": "Zoek volgers",
	"SEARCH_FOLLOWING": "Zoek volgen",
	"BY": "door",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Bladwijzer",
	"REBLOG": "Herblog",
	"UPVOTE": "Stem Omhoog",
	"DOWNVOTE": "Stem Omlaag",
	"UNVOTE_DOWNVOTED": "Downvote weghalen",
	"UNVOTE_UPVOTED": "Stem Omhaag weghalen",
	"REPLY": "Reageer",
	"EDIT": "Wijzigen",
	"POST_1": "Swipe naar links op een reactie om opties te zien",
	"POST_2": "Tik op reacties om sub-reacties te zien",
	"OPTIONS": "Opties",
	"RESTEEMED_BY": "Herblogd door",
	"NOTHING_HERE": "Nog niets te zien hier...",
	"BALANCES": "Tegoeden",
	"PROFILE_1": "{{platformname}}, verhandelbare tokens die altijd overgemaakt kan worden. {{platformname}} kan worden omgezet naar {{platformpower}} in een proces genaamd powering up.",
	"PROFILE_2": "{{platformpower}}, invloed tokens die meer kracht krijgen door het op lange termijn te bewaren en door het stemmen op bercihten. Hoe meer tokens u vasthoudt, hoe meer invloed u heeft op andermans opbrengsten en hoe hoger de opbrengsten bij cureren.",
	"PROFILE_3": "Tokens zijn ongeveer {{platformsunit}} {{platformname}} waard.",
	"ESTIMATED_VALUE": "Geschatte waarde",
	"PROFILE_4": "De geschatte waarde is gebaseerd op een 7-daags gemiddelde waarde van {{platformname}}.",
	"TRANSACTION_HISTORY": "Transactie geschiedenis",
	"POSTING": "Plaatsen",
	"PROFILE_5": "De berichten sleutel wordt gebruikt voor het plaatsen van en voor het stemmen op berichten. Deze zou anders moeten zijn dan de actieve- en eigenaar sleutels.",
	"OWNER": "Eigenaar",
	"PROFILE_6": "De eigenaars sleutel is de hoofdsleutel voor het account en is nodig om andere sleutels aan te passen. De priv sleutel of wachtwoord voor de eigenaars sleutel zou zo veel mogelijk offline opgeslagen moeten worden.",
	"ACTIVE": "Actief",
	"PROFILE_7": "De actieve sleutel wordt gebruikt om transacties en bestellingen te plaatsen in de interne markt.",
	"MEMO": "Memo",
	"PROFILE_8": "De memo sleutel wordt gebruikt voor het maken en lezen van memo's.",
	"BLOG": "Blog",
	"POSTS": "Berichten",
	"REPLIES": "Reacties",
	"WALLET": "Portemonnee",
	"TAG": "Label",
	"USER": "Gebruiker",
	"CLOSE": "Afsluiten",
	"TO": "Naar",
	"ASSET": "Bezitting",
	"SEND": "Verzenden",
	"SECURITY": "Beveiliging",
	"AVAILABLE": "Beschikbaar",
	"PUBLIC_MEMO": "Publiekelijke memo",
	"TO_DESC": "Gebruiker bijv. good-karma",
	"PIN_CODE": "Pincode",
	"PIN_TEXT": "PIN code helpt u uw app en gegevens te beschermen. <br/><br/><b>Opmerking:</b> Eenmaal ingesteld heeft u maximaal 4 kansen, wanneer u de PIN bent vergeten of u het 4 keer verkeerd heeft ingevoerd zal de app uw gebruikersgegevens verwijderen. U kunt dan opnieuw inloggen om de app weer te kunnen gebruiken.",
	"NOTIFICATIONS": "Notificaties",
	"VOTE_TEXT": "U krijgt een notificatie wanneer iemand voor uw bericht stemt.<br/> <b>Opmerking:</b> Notificaties geeft stemgewicht aan alsook in het meldingsbericht. (zowel voor stem omhoog, stem omlaag, verwijder stem).",
	"VOTE": "Stem",
	"COMMENT_TEXT": "U krijgt een notificatie wanneer iemand reageert op uw berichten of reacties. <br/> <b>Opmerking:</b> Notificaties ook wanneer iemand zijn/haar reacties <b>aanpast</b>.",
	"COMMENT": "Commentaar",
	"FOLLOW_TEXT": "U krijgt een notificatie wanneer iemand u volgt of stopt met volgen!",
	"MENTIONS": "Vermeldingen",
	"MENTIONS_TEXT": "U krijgt een notificatie wanneer iemand u noemt in zijn of haar bericht/reactie!",
	"RESTEEM": "Herblog",
	"RESTEEM_TEXT": "U krijgt een notificatie wanneer iemand uw bericht herblogd!",
	"CONFIGURATIONS": "Configuraties",
	"VOTING": "Stemmen",
	"VOTING_TEXT": "Stemgewicht of percentage hebben invloed op Stemkracht in de app, zodat u uw stemopbrengsten kunt reguleren. <br/><br/><b>Opmerking:</b> Dit zal uw stemgewicht/percentage voor het omlaag stemmen ook aantasten en geldt voor de gehele app",
	"SERVER": "Server",
	"SERVER_TEXT": "Aanbevolen",
	"SAVE_CHANGES": "Wijzigingen opslaan",
	"VOTERS_INFO": "Stemmers informatie",
	"WELCOME_BACK": "Welkom terug!",
	"LOGIN_1": "Log in met uw gebruikersnaam en wachtwoord om verder te gaan.",
	"LOGIN_2": "Posting sleutel wordt gebruikt voor het plaatsen van berichten, reacties, stemmen en het volgen van gebruikers.",
	"LOGIN_3": "Actieve sleutel wordt gebruikt voor overmaken en aanpassingen van de profiel foto.",
	"LOGIN_4": "Gebruikersgegevens worden lokaal op uw apparaat opgeslagen. Bij het uitloggen worden de gegevens verwijderd!",
	"DONT_HAVE": "Heeft u geen account?",
	"SIGN_UP_NOW": "Meld je nu aan",
	"CANCEL": "Annuleren",
	"ADVANCED": "Uitgebreid",
	"ACTIVE_PRIKEY": "Actieve priv sleutel",
	"POSTING_PRIKEY": "Posting priv sleutel",
	"MASTER_PASS": "Hoofdwachtwoord",
	"USERNAME": "Gebruikersnaam",
	"CARD_VIEW": "Kaart weergave",
	"COMPACT_VIEW": "Compacte weergave",
	"SEARCH": "Zoeken",
	"SUBMIT_A_STORY": "Plaats een bericht",
	"REPLYTO": "Reageer op",
	"POST": "Bericht",
	"PREVIEW": "Preview",
	"DEFAULT": "Standaard 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Uitbetaling Afwijzen",
	"SAVE_FOR_LATER": "OPSLAAN VOOR LATER",
	"CLEAR": "LEEGMAKEN",
	"POST_CONTENT": "Plaats bericht",
	"COMMENT_CONTENT": "Reageer op bericht",
	"TITLE": "Titel",
	"TAGS": "Labels",
	"NOT_MATCH": "KOMT NIET OVEREEN",
	"CONFIRM_PIN": "Bevestig PIN",
	"INCORRECT": "ONJUIST",
	"OPENING_POST": "Bericht openen",
	"SET_PIN": "Instellen PIN",
	"ENTER_PIN": "Invoeren PIN",
	"ARE_YOU_SURE": "Weet u het zeker?",
	"REBLOG_TEXT": "Herbloggen is definitief, wilt u doorgaan?",
	"BROADCAST_ERROR": "Verzendfout, probeer opnieuw!",
	"SUCCESS": "Succesvol",
	"REBLOGGED_POST": "Bericht herblogd!",
	"LOGIN_FAIL": "Inloggen mislukt! Controleer of u geprobeerd heeft in te loggen met uw hoofdwachtwoord of Posting priv sleutel als u voor geavanceerde modus heeft gekozen.",
	"LOGIN_FAIL_A": "Inloggen mislukt! Controleer of u geprobeerd heeft in te loggen met uw hoofdwachtwoord of Actieve priv sleutel als u voor geavanceerde modus heeft gekozen.",
	"WARNING": "Waarschuwing",
	"VOTE_FOR_WITNESS": "Stemmen voor witness",
	"VOTED_FOR_WITNESS": "Gestemd voor witness",
	"AGO": "geleden",
	"FROM_NOW": "vanaf nu",
	"SECS": "secs",
	"A_MIN": "een minuut",
	"MINS": "minuten",
	"AN_HOUR": "een uur",
	"HOURS": "uren",
	"A_DAY": "een dag",
	"DAYS": "dagen",
	"A_MONTH": "een maand",
	"MONTHS": "maanden",
	"A_YEAR": "een jaar",
	"YEARS": "jaren",
	"MIN_READ": "min. leestijd",
	"DOWNVOTE_FLAG": "Stem Omlaag of Vlag",
	"CAPTURE_PICTURE": "Neem Beeld",
	"SELECT_PICTURE": "Selecteer Foto",
	"SET_CUSTOM_URL": "Stel Eigen URL in",
	"INSERT_PICTURE": "Foto Invoegen",
	"ERROR": "Fout",
	"UPLOAD_ERROR": "Upload Fout",
	"CAMERA_CANCELLED": "Camera Geannuleerd",
	"SET_URL": "Stel URL in",
	"DIRECT_LINK_PICTURE": "Directe web link voor de foto",
	"COMMENT_SUBMITTED": "Commentaar is verstuurd!",
	"DELETE_COMMENT": "Het verwijderen van reacties is definitief...",
	"DELETED_COMMENT": "Verwijderde reactie",
	"UPLOADING_PICTURE": "Foto is aan het uploaden",
	"UPLOAD_COMPLETED": "Upload Geslaagd",
	"UPLOAD_FAILED": "Upload Mislukt",
	"PASSWORD_INCORRECT": "Het wachtwoord of gebruikersnaam is fout",
	"INFO": "Info",
	"QR_TEXT": "Plaats een QR code in het scangebied",
	"BALANCE_TEXT": "Controleer of u genoeg tegoed heeft voor de transactie!",
	"NONEXIST_USER": "De gebruiker naar wie u probeert over te maken, bestaat niet!",
	"TRANSFER_TEXT": "Weet u zeker dat u wilt overmaken?",
	"CONFIRMATION": "Bevestiging",
	"TX_BROADCASTED": "Transactie is verstuurd",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "Populair",
	"NEW": "Nieuw",
	"PROMOTED": "Gesponsord",
	"VOTES": "Stemmen",
	"PAYOUT": "Uitbetaling",
	"COMMENTS": "Reacties",
	"TRENDING_30": "Trending laatste 30 dagen",
	"SORT_POST_BY": "Sorteer berichten op:",
	"PAYOUT_CYCLE": "Uitbetalingscyclus",
	"POTENTIAL_PAYOUT": "Potentile Uitbetaling",
	"PAST_PAYOUT": "Verleden Uitbetaling",
	"AUTHOR_PAYOUT": "Auteur Uitbetaling",
	"CURATION_PAYOUT": "Curatie Uitbetaling",
	"POST_SUBMITTED": "Bericht is verzonden!",
	"POST_LATER": "Te versturen berichten!",
	"SAVED": "Opgeslagen",
	"CLEARED": "Gewist",
	"FLAGGING_TEXT": "Een bericht vlaggen of omlaag stemmen kan de opbrengsten weghalen en minder zichtbaar maken.<br><br>De vlag mag alleen in de volgende gevallen gebruikt worden: <ul><li>Fraude of Plagiaat</li><li>Haatspraak of Internet Trolling</li><li>Met intentie in verkeerde categorie geplaatst of Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limiet verzoek bereikt. Bekijk ook andere trends/tags!",
	"POST_IS_UNBOOKMARK": "Bericht is van bladwijzers verwijderd!",
	"POST_IS_BOOKMARK": "Bericht is aan bladwijzers toegevoegd!",
	"RESET": "Herstellen",
	"MODIFY_PICTURE": "Pas profielfoto aan",
	"MODIFY_COVER_PICTURE": "Pas omslagfoto aan",
	"ACTIVE_KEY_REQUIRED_TEXT": "Gelieve een actieve sleutel te gberuiken wanneer u kiest voor geavanceerde inlog modus!",
	"RESET_PICTURE_TEXT": "Dit zal de profielfoto van de gebruiker herstellen",
	"RESET_COVER_PICTURE_TEXT": "Dit zal de omslagfoto van de gebruiker herstellen",
	"UPDATE_REQUIRES_RESTART": "Server update vereist herstart!",
	"SETTINGS_UPDATED": "Instellingen zijn bijgewerkt!",
	"LANGUAGES": "Talen",
	"LANGUAGES_TEXT": "Hier kunt u de taal van de app veranderen.",
	"LOGIN_TO_X": "Om dit te doen dient u in te loggen met uw hoofdwachtwoord, actieve/posting sleutel. Log alstublieft in en probeer opnieuw.",
	"GALLERY": "Gallerij",
	"TRANSLATIONS": "Vertalers",
	"SHARE": "Delen",
	"MARKETPLACE": "Marktplaats",
	"EXCHANGE": "Beurs",
	"DRAFTS": "Concepten",
	"POST_IS_UNDRAFT": "Bericht is uit concepten verwijderd!",
	"POST_IS_DRAFT": "Bericht toegevoegd aan concepten!",
	"SWIPE_LEFT": "Veeg naar links voor opties",
	"MANAGE": "Beheer",
	"IMAGE_REMOVED": "Afbeelding is verwijderd",
	"COPY": "Kopiren",
	"NO_IMAGE": "Je hebt nog geen afbeelding geupload!",
	"PULL_DOWN_TO_REFRESH": "Trek omlaag om te verversen",
	"EXTERNAL_APPS": "Externe applicaties",
	"PLUGINS": "Plugins",
	"SUGGEST": "Suggereer",
	"COMING_SOON": "Binnenkort",
	"CHAIN": "Keten",
	"CHAIN_TEXT": "Hier kunt u veranderen van blockchain of standaard platform.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Verander hier uw standaard valuta. Beloningen voor berichten/reacties in deze valuta.",
	"ABOUT_11": "<br><b>Functies</b><br>- Toegang tot unieke artikelen met uiteenlopende onderwerpen.<br>- Converseer met auteurs door te reageren en te discussiren.<br>- Stemmen voor berichten om zo de auteur te belonen alsook beloning te ontvangen voor cureren.<br>- Publiceren van uw artikelen en berichten en verdien beloningen door interactie en groei van volgers.<br>- Schrijf artikelen, sla meerdere concepten op een later tijdstip te publiceren.<br>- Sla favoriete artikelen op onder bladwijzers om deze later te lezen.<br>- Wissel of verzilver je inkomsten.<br>- Maak tegoeden over aan andere auteurs of gebruikers, vrienden, volgers, etc.<br>- Volg interessante auteurs, bloggers.<br>- Zoek je volgers en auteurs die je volgt.<br>- Ontvang notificaties om in contact te blijven met je volgers en discussies waarin je betrokken bent.<br>- Zoek op interestante labels/categorien van artikelen, auteurs.<br>- Personaliseer je profiel.<br>- Vele andere functies die nog zullen worden toegevoegd.<br><br><b>Veiligheid</b><br>1. App zal nooit tegoeden van de gebruiker aanraken of opslaan.<br>2. App heeft een client-side beveiligingsmodel, met priv sleutels die lokaal opgeslagen worden en nooit naar andere servers toegestuurd worden, u bent zelf verantwoordelijk om het wachtwoord op te slaan.<br>3. App biedt een simpele en aansprekende gebruikerstoegang.<br>4. App biedt een extra beveiliging door middel van een pincode<br><br>eSteem ondersteund Steem en Golos platformen.<br>",
	"FOUNDER": "Oprichter en Hoofdontwikkelaar",
	"ADD_ACCOUNT": "Account toevoegen",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow-agent",
	"RATIFICATION_DEADLINE": "Ratificatie termijn",
	"ESCROW_EXPIRATION": "Escrow verlopen",
	"ESCROW_FEE": "Escrow vergoeding",
	"ESCROW_TERMS": "Escrow voorwaarden",
	"NIGHT_MODE": "Nacht modus",
	"DAY_MODE": "Dag modus",
	"VIEW_CONTEXT": "Bekijk de volledige context",
	"USER_NOTFOUND": "Gebruiker niet gevonden",
	"APPROVE": "Goedkeuren",
	"DISPUTE": "Geschil",
	"RELEASE": "Versie",
	"FROM": "Van",
	"ID": "id",
	"SUBMIT": "Verzend",
	"RECEIVER": "Ontvanger",
	"LOCATION": "Plaats",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Toon naam"
}
},{}],122:[function(require,module,exports){
module.exports={
	"HOME": "Strona gwna",
	"LOGIN": "Zaloguj",
	"LOGOUT": "Wyloguj",
	"PROFILE": "Profil",
	"FOLLOW": "Obserwuj",
	"BOOKMARKS": "Zakadki",
	"TRANSFER": "Przelew",
	"MARKET": "Gieda",
	"SETTINGS": "Ustawienia",
	"ABOUT": "O Nas",
	"ABOUT_1": "gdzie kady moe zdobywa wynagrodzenie za swoje wpisy!",
	"ABOUT_2": "funkcjonuje w oparciu o patform {{platformname}}. Aplikacja jest stworzona przez",
	"ABOUT_3": "i jest ona otwartym i prowadzonym przez spoeczno projektem. Oferuje dostp do czytania, komentowania, oddawania gosu na treci oraz udostpniania wpisw, a take na zarzdzanie zarobkami oraz innymi dostpnymi opcjami oferowanymi przez acuch blokw {{platformname}} i {{sitename}}.",
	"ABOUT_4": "Aplikacja nigdy nie ma dostpu i nie przetrzymuje rodkw finansowych uytkownika.",
	"ABOUT_5": "Aplikacja oferuje model bezpieczestwa po stronie klienta, gdzie klucze prywatne s przechowywane lokalnie i nigdy nie s przesyane na jakiekolwiek serwery.",
	"ABOUT_6": "Aplikacja oferuje atwy i przyjemny w obsudze interfejs.",
	"ABOUT_7": "Aplikacja nigdy nie wymaga podania danych osobowych od swoich uytkownikw.",
	"ABOUT_8": "Zagosuj na good-karma na wiadka",
	"ABOUT_9": "Kontakt/Opinie",
	"ABOUT_10": "Wicej informacji:",
	"REMOVE": "Usu",
	"MARKET_VIEW": "Widok na gied",
	"PRICE": "Cena",
	"AMOUNT": "Ilo",
	"TOTAL": "Suma",
	"NOORDERS": "Brak otwartych zlece dla",
	"DATE": "Data",
	"BUY": "Kup",
	"SELL": "Sprzedaj",
	"OPEN": "W toku",
	"HISTORY": "Historia",
	"FOLLOW_BACK": "Obserwuj rwnie",
	"FOLLOWED": "Obserwowany",
	"UNFOLLOW": "Przesta obserwowa",
	"FOLLOWING": "Obserwujesz",
	"FOLLOWERS": "Obserwuj ci",
	"SEARCH_FOLLOWERS": "Szukaj wrd obserwujcych",
	"SEARCH_FOLLOWING": "Szukaj wrd obserwowanych",
	"BY": "przez",
	"IN": "w",
	"MENU": "Menu",
	"BOOKMARK": "Zakadki",
	"REBLOG": "Rebloguj",
	"UPVOTE": "Gos za",
	"DOWNVOTE": "Gos przeciw",
	"UNVOTE_DOWNVOTED": "Anuluj gos przeciw",
	"UNVOTE_UPVOTED": "Anuluj gos za",
	"REPLY": "Odpowied",
	"EDIT": "Edytuj",
	"POST_1": "Przecignij komentarz w lewo, aby zobaczy dostpne opcje",
	"POST_2": "Nacinij na komentarze, aby rozwin",
	"OPTIONS": "Opcje",
	"RESTEEMED_BY": "Resteemowany przez",
	"NOTHING_HERE": "Na razie nic tu nie ma...",
	"BALANCES": "Salda",
	"PROFILE_1": "{{platformname}} wymienialne tokeny, ktre mog by przetransferowane w dowolnym momencie. {{platformname}} mog by wymienione na {{platformpower}} w procesie zwanym Power-up.\n",
	"PROFILE_2": "{{platformpower}} tokeny wpywu, ktre umoliwiaj na zdobywanie wikszej iloci mocy za trzymanie ich duoterminowo oraz za gosowanie na wpisy. Im wicej si ich posiada, tym bardziej wpywa si na wynagrodzenie innych wpisw i na zdobywanie nagrd zwizane z oddaniem gosu.",
	"PROFILE_3": "Tokeny warte okoo {{platformsunit}} platformy {{platformname}}.",
	"ESTIMATED_VALUE": "Szacowana warto",
	"PROFILE_4": "Warto jest szacowana na podstawie redniej wartoci z 7-miu dni.",
	"TRANSACTION_HISTORY": "Historia transakcji",
	"POSTING": "Udostpnianie",
	"PROFILE_5": "Klucz udostpnienia jest uywany przy udostpnianiu wpisw i oddawaniu gosw. Powinien by inny ni klucz aktywny i klucz wasnoci.",
	"OWNER": "Waciciel",
	"PROFILE_6": "Klucz wasnoci jest kluczem gwnym konta i jest wymagany do zmiany pozostaych kluczy. Klucz prywatny lub haso do klucza wasnoci powinno by trzymane offline, gdy jest to tylko moliwe.",
	"ACTIVE": "Aktywny",
	"PROFILE_7": "Klucz aktywny jest uywany do wykonywania przeleww i skadania zamwie na wewntrznej giedzie.",
	"MEMO": "Notatka",
	"PROFILE_8": "Klucz notatki jest uyty, aby sporzdza i czyta notatki.",
	"BLOG": "Blog",
	"POSTS": "Wpisy",
	"REPLIES": "Odpowiedzi",
	"WALLET": "Portfel",
	"TAG": "Etykieta",
	"USER": "Uytkownik",
	"CLOSE": "Zamknij",
	"TO": "Do",
	"ASSET": "Kapita",
	"SEND": "Wylij",
	"SECURITY": "Bezpieczestwo",
	"AVAILABLE": "Dostpny",
	"PUBLIC_MEMO": "Notatka publiczna",
	"TO_DESC": "Uytkownik np. good-karma",
	"PIN_CODE": "Kod PIN",
	"PIN_TEXT": "Kod PIN pozwala Ci zabezpieczy aplikacj oraz twoje dane. <br/><br/> <b>Uwaga:</> Masz maksymalnie 4 prby aby wpisa poprawne haso i odblokowa konto, jeeli zapomniae kodu PIN lub wpisae ze haso wicej razy, aplikacja usunie wszystkie dane uytkownika. Moesz si wtedy zalogowa ponownie i kontynuowa uytkowanie aplikacji.",
	"NOTIFICATIONS": "Powiadomienia",
	"VOTE_TEXT": "Otrzymasz powiadomienie, gdy kto odda gos na twj wpis! <br/><b>Uwaga:</b>Powiadomienia zawieraj take typ gosu (tzn. gos za, gos przeciw, anuluj gos).",
	"VOTE": "Zagosuj",
	"COMMENT_TEXT": "Otrzymasz powadomienie, gdy kto skomentuje twj wpis lub komentarz!<br/> <b>Uwaga:</b>Zostaniesz rwnie powiadomiony, gdy kto <b>edytuje</b> swj komentarz.",
	"COMMENT": "Komentarz",
	"FOLLOW_TEXT": "Otrzymasz powiadomienie, gdy kto zacznie lub przestanie ci obserwowa!",
	"MENTIONS": "Wzmianki",
	"MENTIONS_TEXT": "Zostaniesz powiadomiony, gdy kto wspomni ci w swoim wpisie/komentarzu!",
	"RESTEEM": "Rebloguj",
	"RESTEEM_TEXT": "Otrzymasz powiadomienie, gdy kto resteemuje twj wpis!",
	"CONFIGURATIONS": "Konfiguracje",
	"VOTING": "Oddanie gosu",
	"VOTING_TEXT": "Moc lub procent gosu wpywa na moc oddanego gosu i umoliwia ci na regulowanie swojego wynagrodzenia za oddane gosy. <br/><br/><b>Uwaga:</b> Zmiana wpynie na moc/procent gosu caej aplikacji, dotyczy to rwnie gosw oddanych przeciw",
	"SERVER": "Serwer",
	"SERVER_TEXT": "Rekomendowane",
	"SAVE_CHANGES": "Zachowaj zmiany",
	"VOTERS_INFO": "Gosowali",
	"WELCOME_BACK": "Witaj ponownie!",
	"LOGIN_1": "Aby kontynuowa, zaloguj si przy uyciu loginu i hasa.",
	"LOGIN_2": "Klucz udostpniajcy jest uywany do udostpniania wpisw, komentowania, gosowania i ledzenia.",
	"LOGIN_3": "Klucz aktywny uywany jest do wykonywania przeleww i zmian zdjcia profilowego.",
	"LOGIN_4": "Dane uytkownika s trzymane lokalnie przy uycia twojego urzdzenia. Po wylogowaniu dane zostaj usunite!",
	"DONT_HAVE": "Nie masz jeszcze konta?",
	"SIGN_UP_NOW": "Za konto",
	"CANCEL": "Anuluj",
	"ADVANCED": "Zaawansowane",
	"ACTIVE_PRIKEY": "Klucz aktywny prywatny",
	"POSTING_PRIKEY": "Klucz udostpniajcy prywatny",
	"MASTER_PASS": "Haso gwne",
	"USERNAME": "Login",
	"CARD_VIEW": "Widok karty",
	"COMPACT_VIEW": "Widok kompaktowy",
	"SEARCH": "Szukaj",
	"SUBMIT_A_STORY": "Opublikuj tre",
	"REPLYTO": "Odpowiedz",
	"POST": "Opublikuj",
	"PREVIEW": "Podgld",
	"DEFAULT": "Standardowe 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Odmw wynagrodzenia",
	"SAVE_FOR_LATER": "ZACHOWAJ NA PNIEJ",
	"CLEAR": "WYCZY",
	"POST_CONTENT": "Opublikuj wpis",
	"COMMENT_CONTENT": "Skomentuj",
	"TITLE": "Tytu",
	"TAGS": "Etykiety",
	"NOT_MATCH": "BRAK ZGODNOCI",
	"CONFIRM_PIN": "Powtrz PIN",
	"INCORRECT": "NIEPOPRAWNY",
	"OPENING_POST": "otwieranie wpisu",
	"SET_PIN": "Ustaw PIN",
	"ENTER_PIN": "Podaj PIN",
	"ARE_YOU_SURE": "Czy jeste pewien?",
	"REBLOG_TEXT": "Reblog jest nieodwracalne, czy chcesz kontynuowa?",
	"BROADCAST_ERROR": "Bd poczenia, sprbuj ponownie!",
	"SUCCESS": "Zakoczono powodzeniem",
	"REBLOGGED_POST": "Rebloguj wpis!",
	"LOGIN_FAIL": "Bd logowania! Upewnij si czy zalogowae si przy uyciu klucza gwnego lub czy uye aktywnego klucza prywatnego przy logowaniu w trybie zaawansowanym.",
	"LOGIN_FAIL_A": "Bd logowania! Upewnij si czy zalogowae si przy uyciu klucza gwnego lub czy uye prywatnego klucza udostpniajcego przy logowaniu w trybie zaawansowanym.",
	"WARNING": "Uwaga",
	"VOTE_FOR_WITNESS": "Gosujesz na wiadka",
	"VOTED_FOR_WITNESS": "Zagosowae na wiadka",
	"AGO": "temu",
	"FROM_NOW": "od teraz",
	"SECS": "sekund(y)",
	"A_MIN": "minut",
	"MINS": "minut(y)",
	"AN_HOUR": "godzin",
	"HOURS": "godzin(y)",
	"A_DAY": "dzie",
	"DAYS": "dni",
	"A_MONTH": "miesic",
	"MONTHS": "miesicy",
	"A_YEAR": "rok",
	"YEARS": "lat(a)",
	"MIN_READ": "minut temu zostao przeczytane",
	"DOWNVOTE_FLAG": "Gosuj przeciw lub oflaguj",
	"CAPTURE_PICTURE": "Zrb zdjcie",
	"SELECT_PICTURE": "Wybierz obraz",
	"SET_CUSTOM_URL": "Ustaw wybrany URL",
	"INSERT_PICTURE": "Wstaw obraz",
	"ERROR": "Bd",
	"UPLOAD_ERROR": "Bd przy wrzucaniu pliku",
	"CAMERA_CANCELLED": "Aparat nieaktywna",
	"SET_URL": "Ustaw URL",
	"DIRECT_LINK_PICTURE": "Bezporedni link na stron ze zdjciem",
	"COMMENT_SUBMITTED": "Komentarz zosta opublikowany!",
	"DELETE_COMMENT": "Usunicie komentarzy jest nieodwracalne...",
	"DELETED_COMMENT": "Usu komentarz",
	"UPLOADING_PICTURE": "Wstaw zdjcie",
	"UPLOAD_COMPLETED": "Wstawienie zakoczone",
	"UPLOAD_FAILED": "Wrzucenie nie powiodo si",
	"PASSWORD_INCORRECT": "Nieprawidowy login lub haso",
	"INFO": "Informacja",
	"QR_TEXT": "Umie kod QR w obrbie pola skanowania",
	"BALANCE_TEXT": "Upewnij si, czy masz wystarczajc ilo rodkw aby wykona transakcj!",
	"NONEXIST_USER": "Uytkownik do ktrego prbujesz przesa rodki, nie istnieje!",
	"TRANSFER_TEXT": "Czy na pewno chcesz wysa rodki?",
	"CONFIRMATION": "Potwierdzenie",
	"TX_BROADCASTED": "Transakcja w toku",
	"FEED": "Aktualnoci",
	"TRENDING": "Trendy",
	"HOT": "Na topie",
	"NEW": "Nowe",
	"PROMOTED": "Promowane",
	"VOTES": "Ilo gosw",
	"PAYOUT": "Przychd",
	"COMMENTS": "Ilo Komentarzy",
	"TRENDING_30": "Trendy z 30 dni",
	"SORT_POST_BY": "Uporzdkuj wedug:",
	"PAYOUT_CYCLE": "Cykl przychodu",
	"POTENTIAL_PAYOUT": "Potencjalny przychd",
	"PAST_PAYOUT": "Wczeniej wypacono",
	"AUTHOR_PAYOUT": "Przychd autora",
	"CURATION_PAYOUT": "Przychd za mecenat",
	"POST_SUBMITTED": "Wpis zosta opublikowany!",
	"POST_LATER": "Opublikuj wpis pniej!",
	"SAVED": "Zapamitaj",
	"CLEARED": "Wyczy",
	"FLAGGING_TEXT": "Oflagowanie wpisu moe spowodowa usunicie wynagrodzenia i zmniejszenie jego widocznoci.<br><br>Flaga powinna by uyta w sytuacjach takich jak: <ul><li>Oszustwo lub Plagiat</li><li>Mow nienawici lub Internetowy trolling</li><li>Wpis celowo le skatagoryzowany lub Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limit zosta osignity. Sprawd inne etykiety/trendy!",
	"POST_IS_UNBOOKMARK": "Wpis zosta usunity z zakadek!",
	"POST_IS_BOOKMARK": "Wpis zosta dodany do zakadek!",
	"RESET": "Zresetuj",
	"MODIFY_PICTURE": "Zmodyfikuj zdjcie profilowe",
	"MODIFY_COVER_PICTURE": "Zmie zdjcie w tle",
	"ACTIVE_KEY_REQUIRED_TEXT": "Podaj aktywny klucz prywatny jeli wybrae tryb zaawansowanego logowania!",
	"RESET_PICTURE_TEXT": "Spowoduje zresetowanie zdjcia profilowego",
	"RESET_COVER_PICTURE_TEXT": "Spowoduje zresetowanie zdjcia w tle",
	"UPDATE_REQUIRES_RESTART": "Aktualizacja serwera wymaga zresetowania!",
	"SETTINGS_UPDATED": "Ustawienia zostay zaktualizowane",
	"LANGUAGES": "Jzyk",
	"LANGUAGES_TEXT": "Tu moesz zmieni jzyk aplikacji.",
	"LOGIN_TO_X": "Ta operacja wymaga zalogowania hasem gwnym, kluczem akytwnym/udostpniajcym. Zaloguj si i sprbuj ponownie.",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Przetumaczyli",
	"SHARE": "Pole",
	"MARKETPLACE": "Sklep",
	"EXCHANGE": "Wymiana",
	"DRAFTS": "Wersje robocze",
	"POST_IS_UNDRAFT": "Wpis zosta usunity z roboczych!",
	"POST_IS_DRAFT": "Wpis zosta zapisany jako wersja robocza!",
	"SWIPE_LEFT": "Przecignij w lewo, aby zobaczy opcje",
	"MANAGE": "Zarzdzaj",
	"IMAGE_REMOVED": "Obraz zosta usunity",
	"COPY": "Kopiuj",
	"NO_IMAGE": "Nie opublikowae jeszcze adnego obrazu!",
	"PULL_DOWN_TO_REFRESH": "Przecignij w d, aby odwiey.",
	"EXTERNAL_APPS": "Aplikacje zewntrzne",
	"PLUGINS": "Pluginy",
	"SUGGEST": "Zasugeruj",
	"COMING_SOON": "Ju wkrtce",
	"CHAIN": "acuch",
	"CHAIN_TEXT": "Tutaj moesz zmieni acuch blokw lub domyln platform.",
	"CURRENCY": "Waluta",
	"CURRENCY_TEXT": "Tutaj mona zmieni domyln walut. Warto nagrody za post/komentarz zostanie wywietlona w tej walucie.",
	"ABOUT_11": "<br><b>Lista funkcji</b><br>- Dostp do unikalnych treci z krgw Twoich zainteresowa.<br>- Zaangauj si w dyskusje z autorami.<br> - Gosuj na posty by nagrodzi autorw, zdobywaj wynagrodzenie za znajdowanie wartociowych treci.<br> - Publikuj artykuy i zarabiaj na nich zdobywajc zwolennikw<br> - Pisz podczas podry, zapisuj wiele kopii roboczych do pniejszej publikacji.<br> - Dodaj ulubione artykuy do zakadek by przeczyta je pniej.<br> - Wymie lub wypa swoje zarobki. <br> - Wylij swoje rodki do autorw, uytkownikw, przyjaci, zwolennikw, etc.<br> -led ciekawych autorw.<br> - Wyszukiwanie wrd postw swoich zwolennikw oraz ledzonych autorw..<br> - Otrzymuj powiadomienia by nie przegapi dyskusji w ktre jeste zaangaowany.<br> - Szukaj ciekawych tagw / kategorii. <br> -Spersonalizuj swj profil. <br> Jeszcze wicej funkcji wkrtce.. <br><br><b>Bezpieczestwo</b> <br>1. Aplikacja nigdy nie siga do Twoich rodkw.. <br>2. Aplikacja oferuje model zabezpiecze po stronie klienta, z kluczami prywatnymi trzymanymi lokalnie i nigdy nie wysya ich do adnego serwera. Jeste odpowiedzialny za wykonywanie kopii zapasowych swoich hase. <br>3. Aplikacja oferuje prosty, atrakcyjny interfejs uytkownika. <br>4. Dodatkowa warstwa zabezpiecze w postaci kodu Pin <br><br>eSteem obsuguje platformy Steem oraz Golos. <br>",
	"FOUNDER": "Zaoyciel i gwny programista",
	"ADD_ACCOUNT": "Dodaj konto",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Agent Escrow",
	"RATIFICATION_DEADLINE": "Termin ratyfikacji",
	"ESCROW_EXPIRATION": "Wyganicie Escrow",
	"ESCROW_FEE": "Opata za usug Escrow",
	"ESCROW_TERMS": "Warunki usugi Escrow",
	"NIGHT_MODE": "Tryb Nocny",
	"DAY_MODE": "Tryb dzienny",
	"VIEW_CONTEXT": "Zobacz peny kontekst",
	"USER_NOTFOUND": "Nie znaleziono uytkownika",
	"APPROVE": "Zatwierd",
	"DISPUTE": "Spr",
	"RELEASE": "Uwolnij",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Przelij",
	"RECEIVER": "Odbiorca",
	"LOCATION": "Lokalizacja",
	"WEBSITE": "Witryna internetowa",
	"DISPLAY_NAME": "Nazwa wywietlana"
}
},{}],123:[function(require,module,exports){
module.exports={
	"HOME": "Pgina Inicial",
	"LOGIN": "Entrar",
	"LOGOUT": "Sair",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Favoritos",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Configuraes",
	"ABOUT": "Sobre",
	"ABOUT_1": "onde qualquer um pode ganhar recompensas pelo seu contedo",
	"ABOUT_2": " patrocinado pela plataforma {{platformname}}. Aplicativo criado por",
	"ABOUT_3": "e  cdigo-aberto, projecto orientado para a comunidade mvel. Oferece acesso ao contedo para leitura, comentrios, votos, publicar, tranferir ganhos etc. Caratersticas oferecidas pel {{platformname}} blockchain e {{sitename}}.",
	"ABOUT_4": "1. O aplicativo nunca acessa ou guarda o dinheiro dos usurios.",
	"ABOUT_5": "2. A App oferee um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca envida a outros servidores.",
	"ABOUT_6": "3. O Aplicativo oferece simplicidade, interfaces de usurio e experincias atrativas.",
	"ABOUT_7": "4. O Aplicativo requer que os usurios insiram informaes pessoais.",
	"ABOUT_8": "Vote bom-karma como testemunha",
	"ABOUT_9": "Contato/Comentrios",
	"ABOUT_10": "Mais informaes:",
	"REMOVE": "Remover",
	"MARKET_VIEW": "Viso do Mercado",
	"PRICE": "Preo",
	"AMOUNT": "Quantidade",
	"NOORDERS": "Sem ordens abertas para",
	"DATE": "Data",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Hitrico",
	"FOLLOW_BACK": "Seguir de volta",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Deixar de seguir",
	"FOLLOWING": "Seguindo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Procurar seguidores",
	"SEARCH_FOLLOWING": "Procurar quem estou seguindo",
	"BY": "por",
	"IN": "no",
	"BOOKMARK": "Favoritos",
	"REBLOG": "Repostar",
	"UPVOTE": "Upvote",
	"UNVOTE_DOWNVOTED": "Cancelar Downvote",
	"UNVOTE_UPVOTED": "Cancelar Upvote",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Deslize para esquerda nos comentrios para ver as opes",
	"POST_2": "Toque nos comentrios para ver os sub-comentrios",
	"OPTIONS": "Opes",
	"RESTEEMED_BY": "Repostado por",
	"NOTHING_HERE": "Nada por aqui, ainda...",
	"BALANCES": "Balano",
	"PROFILE_1": "{{platformname}}, provas transacionveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
	"PROFILE_2": "{{platformpower}}, provas de influencia par ganhar mais poder por guardar a longo prazo e votar nas publicaes. Quanto mais se possui mais se pode influenciar as recompensas a outros e ganhar mais recompensas por votar.",
	"PROFILE_3": "Provas valendo cerca de {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor estimado",
	"PROFILE_4": "O valor estimado  baseado numa mdia do valor de 7 dias de {{platformname}}.",
	"TRANSACTION_HISTORY": "Histrico de Transaes",
	"POSTING": "Postando",
	"PROFILE_5": "A chave de postagem  usada para postar e votar. Ela dever ser diferente da chave de ativao e da chave de proprietrio.",
	"OWNER": "Proprietrio",
	"PROFILE_6": "A chave de proprietrio  a chave mestra para conta e  exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietrio dever ser mantida offline assim que possvel.",
	"ACTIVE": "Ativo",
	"PROFILE_7": "A chave de ativao  usada para fazer transferncias e colocar ordens no mercado interno.",
	"MEMO": "Anotaes",
	"PROFILE_8": "A chave de anotaes  usada para criar e ler anotaes.",
	"POSTS": "Postagens",
	"REPLIES": "Respostas",
	"WALLET": "Carteira",
	"USER": "Usurio",
	"CLOSE": "Fechado",
	"TO": "Para",
	"ASSET": "Ativo",
	"SEND": "Enviar",
	"SECURITY": "Segurana",
	"AVAILABLE": "Disponvel",
	"PUBLIC_MEMO": "Memorando Pblico",
	"TO_DESC": "Utilizador ex: good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "Cdigo Pin ajuda voc a assegurar o aplicativo e suas informaes. <br/><br/> Uma vez ativado, voc ter no mximo 4 tentativas para destravar, se voce esquecero pin ou errar, o aplicativo ir remover suas informaes de usurio. Voc pode entrar de novo e continuar a usar o aplicativo.",
	"NOTIFICATIONS": "Notificaes",
	"VOTE_TEXT": "Voc receber uma notificao quando algum voter no seu contedo! Notificaes tambm incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Voc receber notificao quando algum comentar nas suas postagens ou comentrios.<br/> Notificaes incluem quando algum edita os comentrios tambm.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Voc receber uma notificao quando algum Seguir ou Deixar de seguir voc!",
	"MENTIONS": "Menes",
	"MENTIONS_TEXT": "Voc receber uma notificao quando algum mencionar voc em alguma postagem ou comentrio!",
	"CONFIGURATIONS": "Configuraes",
	"VOTING": "Votando",
	"VOTING_TEXT": "O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto ir modificar o pseso/percentagem para votar para baixo tambm e em todo o lado na App",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Salvar mudanas",
	"VOTERS_INFO": "Informaes dos eleitores",
	"WELCOME_BACK": "Bem vindo de Volta!",
	"LOGIN_1": "Conecte-se com seu nome de usurio e senha para continuar.",
	"LOGIN_2": "Chave de postagem  usada para postar, comentar, votar, seguir.",
	"LOGIN_3": "Chave de ativao  usada para tranferncias e atualizao de fotos de perfil.",
	"LOGIN_4": "As credenciais do utilizador so guardadas localmente no seu aparelho. Depis de desligar as suas cerdenciais so removidas!",
	"DONT_HAVE": "No possui uma conta?\n",
	"SIGN_UP_NOW": "Cadastre-se agora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanado",
	"ACTIVE_PRIKEY": "Chave de ativao privada",
	"POSTING_PRIKEY": "Chave de postagem privada",
	"MASTER_PASS": "Senha Mestra/Principal",
	"USERNAME": "Usurio",
	"CARD_VIEW": "Viso de Carto",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Procurar",
	"SUBMIT_A_STORY": "Postar uma histria",
	"REPLYTO": "Responder para",
	"POST": "Postagem",
	"PREVIEW": "Vizualizao",
	"DEFAULT": "Padro 50% / 50%",
	"POWERUP": "Fora Total 100%",
	"DECLINE_PAYOUT": "Recusar Pagamento",
	"SAVE_FOR_LATER": "Guardar pra mais tarde",
	"CLEAR": "Terminado",
	"POST_CONTENT": "Contedo da postagem",
	"COMMENT_CONTENT": "Contedo do comentrio",
	"TITLE": "Ttulo",
	"NOT_MATCH": "No condiz",
	"CONFIRM_PIN": "Confirmar Pin",
	"INCORRECT": "Incorreto",
	"OPENING_POST": "Abrindo postagem",
	"SET_PIN": "Configure PIN",
	"ENTER_PIN": "Entrar com Pin",
	"ARE_YOU_SURE": "Voc tem certeza?",
	"REBLOG_TEXT": "Republicar  irreversvel, quer mesmo continuar?",
	"BROADCAST_ERROR": "Erro de difuso, tente novamente!",
	"SUCCESS": "Sucesso",
	"REBLOGGED_POST": "Publucao republicada",
	"LOGIN_FAIL": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave publicao privada no Login se escolheu o modo avanado.",
	"LOGIN_FAIL_A": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avanado.",
	"WARNING": "Cuidado",
	"VOTE_FOR_WITNESS": "Votando por uma Testemunha",
	"VOTED_FOR_WITNESS": "Votou por uma Testemunha",
	"AGO": "atrs",
	"FROM_NOW": "de agora",
	"SECS": "segs",
	"A_MIN": "um minuto",
	"AN_HOUR": "uma hora",
	"HOURS": "horas",
	"A_DAY": "um dia",
	"DAYS": "dias",
	"A_MONTH": "um ms",
	"MONTHS": "meses",
	"A_YEAR": "um ano",
	"YEARS": "anos",
	"MIN_READ": "ler min",
	"DOWNVOTE_FLAG": "Vote abaixo ou bandeire",
	"CAPTURE_PICTURE": "Capturar imagem",
	"SELECT_PICTURE": "Escolher uma imagem",
	"SET_CUSTOM_URL": "Configure URL costumizada",
	"INSERT_PICTURE": "Inserir uma imagem",
	"ERROR": "Erro",
	"UPLOAD_ERROR": "Erro no carregamento",
	"CAMERA_CANCELLED": "Camera cancelada",
	"SET_URL": "Configural URL",
	"DIRECT_LINK_PICTURE": "Link web direto para a imagem",
	"COMMENT_SUBMITTED": "Comentrio postado!",
	"DELETE_COMMENT": "Deletar comentrios  irreversvel",
	"DELETED_COMMENT": "Comentrio deletado",
	"UPLOADING_PICTURE": "Carregabdo imagem",
	"UPLOAD_COMPLETED": "Carregamento compeleto",
	"UPLOAD_FAILED": "Carregamento falhou",
	"PASSWORD_INCORRECT": "A senha ou nome da conta esto incorretos",
	"INFO": "Informaes",
	"QR_TEXT": "Ponha o cdigo QR dentro da rea de scan",
	"BALANCE_TEXT": "Certifique-se que possui saldo suficiente para a transao!",
	"NONEXIST_USER": "O utilizador para quem est a tentar transferir fundos, no existe",
	"TRANSFER_TEXT": "Tem certeza que quer transferir?",
	"CONFIRMATION": "Confirmao",
	"TX_BROADCASTED": "Transao foi difundida",
	"TRENDING": "Tendencia",
	"HOT": "Quente",
	"NEW": "Novidades",
	"PROMOTED": "Promovidos",
	"VOTES": "Votos",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Comentrios",
	"TRENDING_30": "Tendencia a 30 dias",
	"SORT_POST_BY": "Ordenar publicaes por:",
	"PAYOUT_CYCLE": "Ciclo de Pagamento",
	"POTENTIAL_PAYOUT": "Pagamento em potencial",
	"PAST_PAYOUT": "ltimo Pagamento",
	"AUTHOR_PAYOUT": "Pagamento do Autor",
	"CURATION_PAYOUT": "Pagamento de curadoria",
	"POST_SUBMITTED": "Postagem enviada!",
	"POST_LATER": "Publique para futura submisso",
	"SAVED": "Salvo",
	"CLEARED": "Limpo",
	"FLAGGING_TEXT": "Por Bandeira numa publicao pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira dev ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de dio ou Internet Trolling</li><li>Categorizao mal feita intencionalmente ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite de pedidos atingido. verifique outro assunto/etiqueta!",
	"POST_IS_UNBOOKMARK": "Postagem removida dos favoritos!",
	"POST_IS_BOOKMARK": "Postagem adicionada aos favoritos!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar foto de perfil",
	"MODIFY_COVER_PICTURE": "Modificar foto de capa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor fornaa a chave de activao privada que escolheu, Modo de Login Avanado",
	"RESET_PICTURE_TEXT": "Isto reconfigura a imagem do perfil ultizador",
	"RESET_COVER_PICTURE_TEXT": "Isto reconfigura a imagem do ultizador",
	"UPDATE_REQUIRES_RESTART": "Atualizao do server obriga a Reiniciar!",
	"SETTINGS_UPDATED": "Configuraes foram atualizadas",
	"LANGUAGES": "Lnguas",
	"LANGUAGES_TEXT": "Aqui pode mudar a lngua da App",
	"LOGIN_TO_X": "Est operao obriga que o utilizador estaja ligado com a senha prinipal, chave activao/publicao",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Tradutores que contribuiram",
	"SHARE": "Partilhar",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cambio",
	"DRAFTS": "Rascunhos",
	"POST_IS_UNDRAFT": "Postagem removida dos Rascunhos!",
	"POST_IS_DRAFT": "Postagem adicionada a Rascunhos!",
	"SWIPE_LEFT": "Role para a esquerda para opes",
	"MANAGE": "Gerir",
	"IMAGE_REMOVED": "Image. removida",
	"COPY": "Copiar",
	"NO_IMAGE": "No carregou nenhuma imagem, ainda",
	"PULL_DOWN_TO_REFRESH": "Carregue para refrescar",
	"EXTERNAL_APPS": "Apps Externas",
	"SUGGEST": "Sugira",
	"COMING_SOON": "Brevemente",
	"CHAIN_TEXT": "Aqui pode escolher blockchain ou a plataforma por defeito"
}
},{}],124:[function(require,module,exports){
module.exports={
	"HOME": "Pgina Inicial",
	"LOGIN": "Entrar",
	"LOGOUT": "Sair",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Favoritos",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Configuraes",
	"ABOUT": "Sobre",
	"ABOUT_1": "Onde qualquer um pode ganhar recompensas pelo seu contedo",
	"ABOUT_2": " uma aplicao social onde voc  pago por publicar, comentar e curar.",
	"ABOUT_3": "e  cdigo-aberto, projecto orientado para a comunidade mvel. Oferece acesso ao contedo para leitura, comentrios, votos, publicar, tranferir ganhos etc. Carateristicas oferecidas por {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. O aplicativo nunca acessa ou guarda o dinheiro dos utilizadores.",
	"ABOUT_5": "2. A App oferece um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca enviada para outros servidores.",
	"ABOUT_6": "3. O Aplicativo oferece simplicidade, interfaces de utilizador e experincias atrativas.",
	"ABOUT_7": "4. O Aplicativo requer que os utilizadores insiram informaes pessoais.",
	"ABOUT_8": "Vote bom-karma como testemunha",
	"ABOUT_9": "Contato/Comentrios",
	"ABOUT_10": "Mais informaes:",
	"REMOVE": "Remover",
	"MARKET_VIEW": "Viso do Mercado",
	"PRICE": "Preo",
	"AMOUNT": "Quantidade",
	"TOTAL": "Total",
	"NOORDERS": "Sem ordens abertas para",
	"DATE": "Data",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Hitrico",
	"FOLLOW_BACK": "Voltar a seguir",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Deixar de seguir",
	"FOLLOWING": "Seguindo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Procurar seguidores",
	"SEARCH_FOLLOWING": "Procurar por quem estou a seguir",
	"BY": "por",
	"IN": "no",
	"MENU": "Menu",
	"BOOKMARK": "Favoritos",
	"REBLOG": "Repostar",
	"UPVOTE": "Voto positivo",
	"DOWNVOTE": "Voto negativo",
	"UNVOTE_DOWNVOTED": "Cancelar voto negativo",
	"UNVOTE_UPVOTED": "Cancelar voto positivo",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Deslize para esquerda nos comentrios para ver as opes",
	"POST_2": "Toque nos comentrios para ver os sub-comentrios",
	"OPTIONS": "Opes",
	"RESTEEMED_BY": "Repostado por",
	"NOTHING_HERE": "Nada por aqui, ainda...",
	"BALANCES": "Balano",
	"PROFILE_1": "{{platformname}}, provas transacionveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
	"PROFILE_2": "{{platformpower}}, tokens de influencia para ganhar mais poder para guardar a longo prazo e votar nas publicaes. Quanto mais se possui mais se pode influenciar as recompensas para outros e ganhar mais recompensas por votar.",
	"PROFILE_3": "Provas que valem cerca de {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor estimado",
	"PROFILE_4": "O valor estimado  baseado numa mdia do valor de 7 dias de {{platformname}}.",
	"TRANSACTION_HISTORY": "Histrico de Transao",
	"POSTING": "Publicando",
	"PROFILE_5": "A chave de publicao  usada para publicar e votar. Ela deve ser diferente da chave de ativao e da chave de proprietrio.",
	"OWNER": "Proprietrio",
	"PROFILE_6": "A chave de proprietrio  a chave mestra para conta e  exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietrio dever ser mantida offline assim que possvel.",
	"ACTIVE": "Ativo",
	"PROFILE_7": "A chave de ativao  usada para fazer transferncias e colocar ordens no mercado interno.",
	"MEMO": "Anotaes",
	"PROFILE_8": "A chave de anotaes  usada para criar e ler anotaes.",
	"BLOG": "Blogue",
	"POSTS": "Publicaes",
	"REPLIES": "Respostas",
	"WALLET": "Carteira",
	"TAG": "Etiqueta",
	"USER": "Utilizador",
	"CLOSE": "Fechado",
	"TO": "Para",
	"ASSET": "Ativo",
	"SEND": "Enviar",
	"SECURITY": "Segurana",
	"AVAILABLE": "Disponvel",
	"PUBLIC_MEMO": "Memorando Pblico",
	"TO_DESC": "Utilizador ex: good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "Cdigo Pin ajuda a assegurar o aplicativo e suas informaes. <br/><br/> Uma vez ativado, ter no mximo 4 tentativas para destravar, se esquecer o pin ou errar, o aplicativo ir remover suas informaes de utilizador. Pode entrar de novo e continuar a usar o aplicativo.",
	"NOTIFICATIONS": "Notificaes",
	"VOTE_TEXT": "Voc receber uma notificao quando algum votar no seu contedo! Notificaes tambm incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Recebe uma notificao quando algum comentar nas suas publicaes ou comentrios.<br/> Notificaes incluem quando algum edita os comentrios tambm.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Recebe sempre uma notificao quando algum Seguir ou Deixar de segui-lo!",
	"MENTIONS": "Menes",
	"MENTIONS_TEXT": "Recebe sempre uma notificao quando algum o mencionar nalguma publicao ou comentrio!",
	"RESTEEM": "Repostar",
	"RESTEEM_TEXT": "Ir receber uma notificao quando algum partilhar a sua publicao!",
	"CONFIGURATIONS": "Configuraes",
	"VOTING": "Votando",
	"VOTING_TEXT": "O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto ir modificar o peso/percentagem para votar para baixo tambm e em todo o lado na App",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Salvar mudanas",
	"VOTERS_INFO": "Informaes dos eleitores",
	"WELCOME_BACK": "Bem vindo de Volta!",
	"LOGIN_1": "Conecte-se com seu nome de utilizador e senha para continuar.",
	"LOGIN_2": "Chave de publicao  usada para publicar, comentar, votar, seguir.",
	"LOGIN_3": "Chave de ativao  usada para tranferncias e atualizao de fotos de perfil.",
	"LOGIN_4": "As credenciais do utilizador so guardadas localmente no seu aparelho. Depis de desligar as suas credenciais so removidas",
	"DONT_HAVE": "No possui conta?\n",
	"SIGN_UP_NOW": "Registe-se agora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanado",
	"ACTIVE_PRIKEY": "Chave de ativao privada",
	"POSTING_PRIKEY": "Chave de publicao privada",
	"MASTER_PASS": "Senha Mestra/Principal",
	"USERNAME": "Utilizador",
	"CARD_VIEW": "Viso de Carto",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Procurar",
	"SUBMIT_A_STORY": "Publicar uma histria",
	"REPLYTO": "Responder para",
	"POST": "Publicao",
	"PREVIEW": "Vizualizar",
	"DEFAULT": "Padro 50% / 50%",
	"POWERUP": "Fora Total 100%",
	"DECLINE_PAYOUT": "Recusar Pagamento",
	"SAVE_FOR_LATER": "Guardar pra mais tarde",
	"CLEAR": "Terminado",
	"POST_CONTENT": "Contedo da publicao",
	"COMMENT_CONTENT": "Contedo do comentrio",
	"TITLE": "Ttulo",
	"TAGS": "Etiquetas\nMarcadores",
	"NOT_MATCH": "No condiz",
	"CONFIRM_PIN": "Confirmar Pin",
	"INCORRECT": "Incorreto",
	"OPENING_POST": "Abrindo postagem",
	"SET_PIN": "Configure PIN",
	"ENTER_PIN": "Entrar com Pin",
	"ARE_YOU_SURE": "Tem a certeza?",
	"REBLOG_TEXT": "Republicar  irreversvel, quer mesmo continuar?",
	"BROADCAST_ERROR": "Erro de difuso, tente novamente!",
	"SUCCESS": "Sucesso",
	"REBLOGGED_POST": "Publicao republicada",
	"LOGIN_FAIL": "Login falhou! por favor certifique-se que est ligado com a senha master ou a chave publicao privada no Login se escolheu o modo avanado.",
	"LOGIN_FAIL_A": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avanado.",
	"WARNING": "Cuidado",
	"VOTE_FOR_WITNESS": "Votando por uma Testemunha",
	"VOTED_FOR_WITNESS": "Votou por uma Testemunha",
	"AGO": "atrs",
	"FROM_NOW": "de agora",
	"SECS": "segs",
	"A_MIN": "um minuto",
	"MINS": "minutos",
	"AN_HOUR": "uma hora",
	"HOURS": "horas",
	"A_DAY": "um dia",
	"DAYS": "dias",
	"A_MONTH": "um ms",
	"MONTHS": "meses",
	"A_YEAR": "um ano",
	"YEARS": "anos",
	"MIN_READ": "ler min",
	"DOWNVOTE_FLAG": "Vote para baixo ou bandeira",
	"CAPTURE_PICTURE": "Capturar imagem",
	"SELECT_PICTURE": "Escolher uma imagem",
	"SET_CUSTOM_URL": "Configure URL costumizada",
	"INSERT_PICTURE": "Inserir uma imagem",
	"ERROR": "Erro",
	"UPLOAD_ERROR": "Erro no carregamento",
	"CAMERA_CANCELLED": "Camera cancelada",
	"SET_URL": "Configurarl URL",
	"DIRECT_LINK_PICTURE": "Link web direto para a imagem",
	"COMMENT_SUBMITTED": "Comentrio publicado!",
	"DELETE_COMMENT": "Apagar comentrios  irreversvel",
	"DELETED_COMMENT": "Comentrio apagado",
	"UPLOADING_PICTURE": "Carregando imagem",
	"UPLOAD_COMPLETED": "Carregamento completo",
	"UPLOAD_FAILED": "Carregamento falhou",
	"PASSWORD_INCORRECT": "A senha ou nome da conta so incorretos",
	"INFO": "Informaes",
	"QR_TEXT": "Ponha o cdigo QR dentro da rea de scan",
	"BALANCE_TEXT": "Certifique-se que possui saldo suficiente para a transao!",
	"NONEXIST_USER": "O utilizador para quem est a tentar transferir fundos, no existe",
	"TRANSFER_TEXT": "Tem certeza que quer transferir?",
	"CONFIRMATION": "Confirmao",
	"TX_BROADCASTED": "Transao foi difundida",
	"FEED": "Contedo de notcias",
	"TRENDING": "Tendencia",
	"HOT": "Quente",
	"NEW": "Novidades",
	"PROMOTED": "Promovidos",
	"VOTES": "Votos",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Comentrios",
	"TRENDING_30": "Tendencia a 30 dias",
	"SORT_POST_BY": "Ordenar publicaes por:",
	"PAYOUT_CYCLE": "Ciclo de Pagamento",
	"POTENTIAL_PAYOUT": "Pagamento em potencial",
	"PAST_PAYOUT": "ltimo Pagamento",
	"AUTHOR_PAYOUT": "Pagamento do Autor",
	"CURATION_PAYOUT": "Pagamento de curadoria",
	"POST_SUBMITTED": "Publicao enviada!",
	"POST_LATER": "Publique para futura submisso",
	"SAVED": "Salvo",
	"CLEARED": "Limpo",
	"FLAGGING_TEXT": "Por uma bandeira numa publicao pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira deve ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de dio ou Internet Trolling</li><li>Categorizao mal feita intencionalmente ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite de pedidos atingido. verifique outro assunto/etiqueta!",
	"POST_IS_UNBOOKMARK": "Publicao removida dos favoritos!",
	"POST_IS_BOOKMARK": "Publicao adicionada aos favoritos!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar a fotografia de perfil",
	"MODIFY_COVER_PICTURE": "Modificar fotografia da capa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor insira a chave de activao privada que escolheu, Modo de Login Avanado",
	"RESET_PICTURE_TEXT": "Isto reconfigura a imagem do perfil ultizador",
	"RESET_COVER_PICTURE_TEXT": "Isto reconfigura a imagem do ultizador",
	"UPDATE_REQUIRES_RESTART": "Atualizao do server obriga a Reiniciar!",
	"SETTINGS_UPDATED": "Configuraes foram atualizadas",
	"LANGUAGES": "Lngua",
	"LANGUAGES_TEXT": "Aqui pode mudar a lngua da App",
	"LOGIN_TO_X": "Esta operao obriga que o utilizador estaja ligado com a senha principal, chave activao/publicao",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Tradutores que contribuiram",
	"SHARE": "Partilhar",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cmbio",
	"DRAFTS": "Rascunhos",
	"POST_IS_UNDRAFT": "Publicao removida dos Rascunhos!",
	"POST_IS_DRAFT": "Puplicao adicionada a Rascunhos!",
	"SWIPE_LEFT": "Role para a esquerda para opes",
	"MANAGE": "Gerir",
	"IMAGE_REMOVED": "Imagem removida",
	"COPY": "Copiar",
	"NO_IMAGE": "No carregou nenhuma imagem, ainda",
	"PULL_DOWN_TO_REFRESH": "Carregue para refrescar",
	"EXTERNAL_APPS": "Apps Externas",
	"PLUGINS": "Mdulos de extenso",
	"SUGGEST": "Sugira",
	"COMING_SOON": "Brevemente",
	"CHAIN": "Corrente",
	"CHAIN_TEXT": "Aqui pode escolher blockchain ou a plataforma por defeito",
	"CURRENCY": "Moeda",
	"CURRENCY_TEXT": "Aqui pode alterar a sua unidade monetria padro. Ver o valor da recompensa do post/comentrio nessa moeda.",
	"ABOUT_11": "<br><b>Lista de funcionalidades</b><br>- Tenha acesso a artigos exclusivos sobre qualquer assunto que esteja interessado em ler.<br>- Envolva-se com os autores, comentando e discutindo os tpicos.<br>- Vote em posts para recompensar o autor, bem como para ganhar uma recompensa de curador.<br>- Publique os seus artigos e posts hospedando-os gratuitamente e ganhe recompensas por cativar e ganhar seguidores.<br>- Escreva artigos em movimento, salve mltiplos rascunhos do post para publicao posterior.<br>- Adicione artigos aos seus favoritos para ler mais tarde.<br>- Cambie ou recolha os seus ganhos.<br>- Envie os seus fundos para quaisquer autores ou usurios, amigos, seguidores, etc.<br>- Siga autores interessantes, bloggers<br>-. Procure os seguidores e autores que segue.<br>- Receba notificaes para se manter em contacto com os seus seguidores e discusses em que se encontre envolvido.<br>- Procure por marcadores/categorias interessantes de artigos, autores.<br>- Personalize o seu perfil.<br>- Muitas mais funcionalidades a caminho.<br><br><br>Segurana</b><br>1. A aplicao nunca acede ou retm fundos do usurio.<br>2. A aplicao oferece um modelo de segurana que privilegia o cliente, com chaves privadas hospedadas localmente e nunca enviadas para qualquer servidor, voc  responsvel por fazer uma cpia de segurana das suas senhas.<br>3. A aplicao oferece experincias e interfaces de usurio, simples e atraentes.<br>4. A aplicao oferece um nvel extra de segurana atravs do cdigo Pin<br><br>O eSteem apoia as plataformas Steem e Golos.<br>",
	"FOUNDER": "Fundador e desenvolvedor principal",
	"ADD_ACCOUNT": "Adicionar conta",
	"PLATFORM": "Plataforma",
	"ESCROW": "Compromisso",
	"ESCROW_AGENT": "Agente depositrio",
	"RATIFICATION_DEADLINE": "Prazo de ratificao",
	"ESCROW_EXPIRATION": "Vencimento do compromisso",
	"ESCROW_FEE": "Taxa de depsito",
	"ESCROW_TERMS": "Termos do compromisso",
	"NIGHT_MODE": "Modo nocturno",
	"DAY_MODE": "Modo diurno",
	"VIEW_CONTEXT": "Ver o contexto completo",
	"USER_NOTFOUND": "Utilizador no encontrado",
	"APPROVE": "Aprovar",
	"DISPUTE": "Disputa",
	"RELEASE": "Lanamento",
	"FROM": "De",
	"ID": "identificao",
	"SUBMIT": "Submeter",
	"RECEIVER": "Destinatrio",
	"LOCATION": "Localizao",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Nome a exibir"
}
},{}],125:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": " ",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ",
	"ABOUT_1": "       !",
	"ABOUT_2": "   {{platformname}}.  ",
	"ABOUT_3": "         .       , ,   ,       ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "1.            ;",
	"ABOUT_5": "2.       ,          ;",
	"ABOUT_6": "3.       ;",
	"ABOUT_7": "4.       -  .",
	"ABOUT_8": "   good-karma",
	"ABOUT_9": "/ :",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": " ",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ,   ",
	"POST_2": "  ,    ",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},   ,       . {{platformname}}     {{platformpower}},     {{platformname}}-.",
	"PROFILE_2": "{{platformpower}},   ,          .     ,                  .",
	"PROFILE_3": "   {{platformsunit}}  {{platformname}} .",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7-   {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "      .         .",
	"OWNER": "",
	"PROFILE_6": "            .          ,   .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": "",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "PIN-",
	"PIN_TEXT": "PIN-       . <br/><br/><b>:</b>  ,     4   ,    PIN-     ,       .         .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,       ! <br/><b>:</b>       (   ,  ,  ).",
	"VOTE": "",
	"COMMENT_TEXT": "  ,  -     !<br/> <b>:</b>    ,  - <b></b>  .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,  -     !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,  -     /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,  -    !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "         ,        . <br/><br/><b>:</b>      ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": " ,       .",
	"LOGIN_2": "     , ,   .",
	"LOGIN_3": "          .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": " ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "/ ",
	"USERNAME": " ",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": "  50% / 50%",
	"POWERUP": " 100%  {{platformpower}}",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "   ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN-",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " PIN-",
	"ENTER_PIN": " PIN-",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "  ,   ?",
	"BROADCAST_ERROR": "  ,   !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": " ! , ,                    .",
	"LOGIN_FAIL_A": " ! , ,                    .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "  ",
	"SECS": "",
	"A_MIN": "",
	"MINS": "()",
	"AN_HOUR": "",
	"HOURS": "()",
	"A_DAY": "",
	"DAYS": "()",
	"A_MONTH": "",
	"MONTHS": "()",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": "  ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "   ",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "    ",
	"INFO": "",
	"QR_TEXT": " QR    ",
	"BALANCE_TEXT": "       !",
	"NONEXIST_USER": ",     ,  !",
	"TRANSFER_TEXT": "      ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": "  :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "  ,          .<br><br>      : <ul><li>  </li><li>   </li><li>     </li></ul>",
	"REQUEST_LIMIT_TEXT": "  .   /!",
	"POST_IS_UNBOOKMARK": "   !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": ",    ,      !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     .",
	"LOGIN_TO_X": "        , / . ,    .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "   !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": "     ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "      !",
	"PULL_DOWN_TO_REFRESH": " ,  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       ().",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .   /     .",
	"ABOUT_11": "<br><b> </b><br>-          ;<br>-   ,     ;<br>-   ,   ,     ;<br>-       ,      ;<br>-    ,       ,   ;<br>-     ,     ;<br>-     ;<br>-    , , ,   ..;<br>-      ;<br>-       ,    ;<br>-   -           ,   ;<br>-      ,    /;<br>-    ;<br>-    -        !<br><br><b></b><br>1.         ;<br>2.       ,              -       ;<br>3.      ,      ;<br>4.         -.<br><br>eSteem   Steem  Golos.<br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": "",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "-",
	"DISPLAY_NAME": " "
}
},{}],126:[function(require,module,exports){
module.exports={
	"HOME": "Hem",
	"LOGIN": "Logga in",
	"LOGOUT": "Logga ut",
	"PROFILE": "Profil",
	"FOLLOW": "Flj",
	"BOOKMARKS": "Bokmrken",
	"TRANSFER": "verfring",
	"MARKET": "Marknad",
	"SETTINGS": "Instllningar",
	"ABOUT": "Om",
	"ABOUT_1": "dr vem som helst kan belnas fr sitt material!",
	"ABOUT_2": "r en social mediaplatform dr du betalas fr att blogga, kommentera och kurrera inlgg.",
	"ABOUT_3": "och r ett community-drivet projekt fr mobilen som baseras p ppen kllkod. Den ger ger dig tillgng s att du kan lsa innehll, kommentera, rsta, skapa inlgg och fra ver belningar, och diverse andra funktioner som grs mjliga av {{platformname}} block-kedja och {{sitename}}.",
	"ABOUT_4": "Appen har aldrig tillgng till anvndarens pengar.",
	"ABOUT_5": "Appen erbjuder en klientcentrerad skerhetsmodell, dvs. dina privata nycklar stannar lokalt och skickas inte till andra servrar.",
	"ABOUT_6": "Appen erbjuder ett enkelt och attraktivt anvndergrnssnitt, vilket ger en god anvndarupplevelse.",
	"ABOUT_7": "Appen krver aldrig att anvndaren matar in personlig information.",
	"ABOUT_8": "Rsta p good-karma som vittne",
	"ABOUT_9": "Kontakt/terkoppling",
	"ABOUT_10": "Mera information:",
	"REMOVE": "Ta bort",
	"MARKET_VIEW": "Marknadsvy",
	"PRICE": "Pris",
	"AMOUNT": "Mngd",
	"TOTAL": "Summa",
	"NOORDERS": "Inga aktiva ordrar fr",
	"DATE": "Datum",
	"BUY": "Kp",
	"SELL": "Slj",
	"OPEN": "ppen",
	"HISTORY": "Historik",
	"FOLLOW_BACK": "Flj tillbaka",
	"FOLLOWED": "Fljer",
	"UNFOLLOW": "Sluta flja",
	"FOLLOWING": "Fljer",
	"FOLLOWERS": "Fljare",
	"SEARCH_FOLLOWERS": "Sk bland fljare",
	"SEARCH_FOLLOWING": "Sk bland de du fljer",
	"BY": "av",
	"IN": "i",
	"MENU": "Meny",
	"BOOKMARK": "Bokmrk",
	"REBLOG": "terblogga",
	"UPVOTE": "Rsta upp",
	"DOWNVOTE": "Rsta ner",
	"UNVOTE_DOWNVOTED": "ngra rsta ner",
	"UNVOTE_UPVOTED": "ngra rsta upp",
	"REPLY": "Svara",
	"EDIT": "Redigera",
	"POST_1": "Svep t vnster ver kommentarer fr att se alternativ",
	"POST_2": "Dutta p kommentarer fr att se underkommentarer",
	"OPTIONS": "Alternativ",
	"RESTEEMED_BY": "tersteemades av",
	"NOTHING_HERE": "Tomt n s lnge...",
	"BALANCES": "Saldon",
	"PROFILE_1": "Steem, utbytsbara polletter som gr att verfra nr som helst. Steem kan omvandlas till SteemPower i en process som kallas att ka rsteffekt eller \"nga upp\".",
	"PROFILE_2": "SteemPower, inflytandepolletter som ger hgre rsteffekt fr att du sparar dem lngsiktigt och rstar p inlgg. Ju mer du har, desto mer kan du pverka andras belningar och belnas fr smart rstning.",
	"PROFILE_3": "Polletter vrda ungefr {{platformsunit}} av {{platformname}.",
	"ESTIMATED_VALUE": "Uppskattat vrde",
	"PROFILE_4": "Det uppskattade vrdet r baserat p ett 7 dagars genomsnittlig vrde av {{platformname}.",
	"TRANSACTION_HISTORY": "Transaktionshistorik",
	"POSTING": "Inlgg",
	"PROFILE_5": "Inlggsnyckeln anvnds fr att skriva inlgg och rsta. Den br vara olik allmnnyckeln och huvudnyckeln.",
	"OWNER": "gare",
	"PROFILE_6": "garnyckeln r huvudnyckeln fr kontot och behvs fr att kunna byta de andra nycklarna. Fr att ka skerheten br den \"privata nyckeln\" eller lsenordet till huvudnyckeln anvndas s lite som mjligt.",
	"ACTIVE": "Rrelse",
	"PROFILE_7": "Allmnnyckeln anvnds fr att gra verfringar och att lgga ordrar i den interna marknaden.",
	"MEMO": "Anteckning",
	"PROFILE_8": "Anteckningsnyckeln anvnds fr att skapa och lsa anteckningar.",
	"BLOG": "Blogg",
	"POSTS": "Inlgg",
	"REPLIES": "Svar",
	"WALLET": "Plnbok",
	"TAG": "mne",
	"USER": "Anvndare",
	"CLOSE": "Stng",
	"TO": "Till",
	"ASSET": "Tillgng",
	"SEND": "Skicka",
	"SECURITY": "Skerhet",
	"AVAILABLE": "Tillgnglig",
	"PUBLIC_MEMO": "Offentlig anteckning",
	"TO_DESC": "Anvndare t.ex. good-karma",
	"PIN_CODE": "Pinkod",
	"PIN_TEXT": "Pinkoden hjlper dig att skra appen och din data. Nr den aktiveras har du max 4 frsk att lsa upp appen. Om du har glmt den eller misslyckas kommer appen att ta bort inloggad anvndardata. Du mste d logga in p nytt fr att fortstta anvnda appen.",
	"NOTIFICATIONS": "Meddelanden",
	"VOTE_TEXT": "Du kommer f ett meddelande nr ngon rstar upp ditt inlgg. Meddelanden talar ven om den valda rstvikten. (oavsett upprstning, nedrstning, av/omrstning).",
	"VOTE": "Rsta",
	"COMMENT_TEXT": "Du kommer f ett meddelande nr ngon kommenterar p ditt inlgg eller kommentar. Meddelanden inkluderar ven nr ngon redigerar sin kommentar.",
	"COMMENT": "Kommentar",
	"FOLLOW_TEXT": "Du kommer f ett meddelande nr ngon fljer eller slutar flja dig.",
	"MENTIONS": "Omnmnande",
	"MENTIONS_TEXT": "Du kommer f ett meddelande nr ngon nmnar ditt namn i deras inlgg/kommentar!",
	"RESTEEM": "terblogga",
	"RESTEEM_TEXT": "Du kommer f ett meddelande nr ngon terbloggar ditt inlgg!",
	"CONFIGURATIONS": "Instllningar",
	"VOTING": "Rstning",
	"VOTING_TEXT": "Rstningsvikt eller procent pverkar rstningskraften p appen s att du kan reglera hur mycket du vill belna inlgg. Detta ndrar ocks p rstningsvikten/procenten fr nedrstningar och gller verallt p appen.",
	"SERVER": "Server",
	"SERVER_TEXT": "Rekommenderas",
	"SAVE_CHANGES": "Spara ndringar",
	"VOTERS_INFO": "Rstarens information",
	"WELCOME_BACK": "Vlkommen tillbaka!",
	"LOGIN_1": "Logga in med ditt anvndarnamn och lsenord fr att fortstta.",
	"LOGIN_2": "Inlggsnyckeln anvnds fr att gra inlgg, kommentera, rst, flja.",
	"LOGIN_3": "Allmnnyckeln anvnds fr att gra verfringar och att uppdatera profilbild.",
	"LOGIN_4": "Anvndaruppgifter lagras lokalt p enheten. Vid utloggning avlgsnas uppgifterna!",
	"DONT_HAVE": "Har du inget konto?",
	"SIGN_UP_NOW": "Registrera dig nu",
	"CANCEL": "Avbryt",
	"ADVANCED": "Avancerat lge",
	"ACTIVE_PRIKEY": "Privat allmnnyckel",
	"POSTING_PRIKEY": "Privat inlggsnyckel",
	"MASTER_PASS": "gare/huvudlsenord",
	"USERNAME": "Anvndarnamn",
	"CARD_VIEW": "Kortvy",
	"COMPACT_VIEW": "Kompakt vy",
	"SEARCH": "Sk",
	"SUBMIT_A_STORY": "Gr ett inlgg",
	"REPLYTO": "Svara",
	"POST": "Skicka",
	"PREVIEW": "Frhandsgranska",
	"DEFAULT": "Normal 50% / 50%",
	"POWERUP": "nga upp 100%",
	"DECLINE_PAYOUT": "Avsg dig belning",
	"SAVE_FOR_LATER": "SPARA TILL SENARE",
	"CLEAR": "TM",
	"POST_CONTENT": "Skriv inlgg",
	"COMMENT_CONTENT": "Kommentera material",
	"TITLE": "Titel",
	"TAGS": "mnen",
	"NOT_MATCH": "MATCHAR INTE",
	"CONFIRM_PIN": "Bekrfta pinkod",
	"INCORRECT": "FELAKTIG",
	"OPENING_POST": "ppnar inlgg",
	"SET_PIN": "Stll in pinkod",
	"ENTER_PIN": "Ange pinkod",
	"ARE_YOU_SURE": "r du sker?",
	"REBLOG_TEXT": "terbloggade inlgg kan inte ngras, vill du fortstta?",
	"BROADCAST_ERROR": "Sndningsfel, frsk igen!",
	"SUCCESS": "Utfrt",
	"REBLOGGED_POST": "terbloggade inlgg!",
	"LOGIN_FAIL": "Inloggning misslyckades! Var god skerstll att du loggar in med huvudlsenord eller din privata inlggsnyckel om du valt \"Avancerat lge\".",
	"LOGIN_FAIL_A": "Inloggning misslyckades! Var god skerstll att du loggar in med huvudlsenord eller din privata rrelsenyckel om du valt \"Avancerat lge\".",
	"WARNING": "Varning",
	"VOTE_FOR_WITNESS": "Rsta p vittne",
	"VOTED_FOR_WITNESS": "Rstade p vittnet",
	"AGO": "sedan",
	"FROM_NOW": "frn och med nu",
	"SECS": "sek",
	"A_MIN": "en minut",
	"MINS": "min",
	"AN_HOUR": "en timme",
	"HOURS": "timmar",
	"A_DAY": "en dag",
	"DAYS": "dagar",
	"A_MONTH": "en mnad",
	"MONTHS": "mnader",
	"A_YEAR": "ett r",
	"YEARS": "r",
	"MIN_READ": "min lsning",
	"DOWNVOTE_FLAG": "Rsta Ner",
	"CAPTURE_PICTURE": "Ta Foto",
	"SELECT_PICTURE": "Vlj Bild",
	"SET_CUSTOM_URL": "Stll in egen URL",
	"INSERT_PICTURE": "Infoga Bild",
	"ERROR": "Fel",
	"UPLOAD_ERROR": "Uppladdningsfel",
	"CAMERA_CANCELLED": "Kamera Avbruten",
	"SET_URL": "Stll in URL",
	"DIRECT_LINK_PICTURE": "Direkt webblnk fr bild",
	"COMMENT_SUBMITTED": "Kommentaren r skickad!",
	"DELETE_COMMENT": "Borttagning av kommentarer gr inte att ngra...",
	"DELETED_COMMENT": "Tog bort kommentaren",
	"UPLOADING_PICTURE": "Laddar upp bild",
	"UPLOAD_COMPLETED": "Uppladdning Slutfrd",
	"UPLOAD_FAILED": "Uppladdning Misslyckades",
	"PASSWORD_INCORRECT": "Lsenordet eller kontonamnet var felaktigt",
	"INFO": "Info",
	"QR_TEXT": "Placera QR-kod innanfr skanningsomrdet",
	"BALANCE_TEXT": "Se till att du har tillrckligt saldo fr transaktionen!",
	"NONEXIST_USER": "Anvndaren du frsker verfra till existerar inte!",
	"TRANSFER_TEXT": "r du sker att du vill fra ver?",
	"CONFIRMATION": "Bekrftelse",
	"TX_BROADCASTED": "verfring sndes",
	"FEED": "Flde",
	"TRENDING": "Trendande",
	"HOT": "Hett",
	"NEW": "Nytt",
	"PROMOTED": "Marknadsfrt",
	"VOTES": "Rster",
	"PAYOUT": "Utbetalning",
	"COMMENTS": "Kommentarer",
	"TRENDING_30": "Trendande fr 30 dagar",
	"SORT_POST_BY": "Sortera inlgg efter",
	"PAYOUT_CYCLE": "Utbetalningsperiod",
	"POTENTIAL_PAYOUT": "Potentiell Utbetalning",
	"PAST_PAYOUT": "Tidigare Utbetalning",
	"AUTHOR_PAYOUT": "Skribents Utbetalning",
	"CURATION_PAYOUT": "Kuratorers Utbetalning",
	"POST_SUBMITTED": "Inlgget r publicerat!",
	"POST_LATER": "Inlgg fr senare publicering!",
	"SAVED": "Sparat",
	"CLEARED": "Tmt",
	"FLAGGING_TEXT": "Att rsta ner ett inlgg kan ta bort belning och gra inlgget mindre synligt.<br><br> Nedrsten br anvndas fr fljande: <ul><li>Bedrger eller Plagiat</li><li>Hets eller Trolling</li><li>Medvetet felkategoriserat innehll eller Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Slut p fldet ntt. Kolla in andra trender/mnestaggar!",
	"POST_IS_UNBOOKMARK": "Inlgget har tagits bort frn bokmrken!",
	"POST_IS_BOOKMARK": "Inlgget har lagts till i bokmrken!",
	"RESET": "terstll",
	"MODIFY_PICTURE": "Modifiera profilbild",
	"MODIFY_COVER_PICTURE": "Modifiera uppslagsbild",
	"ACTIVE_KEY_REQUIRED_TEXT": "Var god ange den privata rrelsenyckeln om du har valt Avancerat lge!",
	"RESET_PICTURE_TEXT": "Det hr terstller profilbild",
	"RESET_COVER_PICTURE_TEXT": "Det hr terstller uppslagsbild",
	"UPDATE_REQUIRES_RESTART": "Serveruppdatering krver omstart!",
	"SETTINGS_UPDATED": "Instllningar har uppdaterats!",
	"LANGUAGES": "Sprk",
	"LANGUAGES_TEXT": "Hr kan du vlja det sprk som appen anvnder.",
	"LOGIN_TO_X": "Den hr operationen krver att anvndaren r inloggad med lsenord, allmnnyckel/inlggsnyckel. Var god logga in och frsk igen.",
	"GALLERY": "Galleri",
	"TRANSLATIONS": "Bidragande versttare",
	"SHARE": "Dela",
	"MARKETPLACE": "Marknadsplats",
	"EXCHANGE": "Brs",
	"DRAFTS": "Utskick",
	"POST_IS_UNDRAFT": "Inlgg har tagits bort frn utskick!",
	"POST_IS_DRAFT": "Inlgg har lagts till i utskick!",
	"SWIPE_LEFT": "Dra t vnster fr att se alternativ",
	"MANAGE": "Hantera",
	"IMAGE_REMOVED": "Bilden r borttagen",
	"COPY": "Kopiera",
	"NO_IMAGE": "Du har inte laddat upp ngon bild nnu!",
	"PULL_DOWN_TO_REFRESH": "Dra ner fr att uppdatera",
	"EXTERNAL_APPS": "Externa appar",
	"PLUGINS": "Plugin",
	"SUGGEST": "Frslag",
	"COMING_SOON": "Kommer snart",
	"CHAIN": "Kedja",
	"CHAIN_TEXT": "Hr kan du ndra blockkedja eller frvald plattform.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Hr kan du ndra din standardvaluta. Det r den valuta som belningar fr inlgg/kommentarer kommer att visas i.",
	"ABOUT_11": "<br><b>Lista ver funktioner</b><br>- Tillgng till artiklar i mnen som intresserar dig.<br>- Interagera med skribenter genom att kommentera, diskutera mnen.<br>- Rsta p inlgg fr at belna skribenter och tjna kureringsbelningar.<br>- Publicera dina artiklar, blogginlgg och gr dem tillgnliga fr andra helt gratis, samt tjna belningar genom att engagera och f fljare.<br>- Skriv artiklar p stende ft, spara flera utkast av dina inlgg fr senare publicering.<br>- Bokmrk favortinlgg fr att lsa senare.<br>- Handla med eller ta ut dina belningar.<br>- Gr transaktioner till valfri anvndare, vn, fljare, etc.<br>- Flj intressanta skribenter, bloggare.<br>- Sk bland dina fljare och skribenter du fljer.<br>- F meddelande s att du kan hlla kontakten med dina fljare och ha koll p de diskussioner du deltar i.<br>- Sk efter intressanta mnen/artikelkategorier, skribenter.<br>- Gr din profil mer personlig.<br>- Mnga fler funktioner p vg<br><br><b>Skerhet</b><br>1. Appen har fr aldrig tillgng till eller kontroll ver dina pengar.<br>2. Appens skerhetsmodell r klientcentrerad, med privata nycklar sparade lokalt och aldrig skickade till ngra andra servrar, du r sjlv ansvarig fr att skerhetskopiera dina lsenord.<br>3. Appen erbjuder ett enkelt, attraktivt anvndargrnssnitt och anvndarupplevelse.<br>4. Appen erbjuder extra skerhet med pin-kod<br><br>eSteem stdjer Steem- och Golos- plattformarna.<br>",
	"FOUNDER": "Grundare och Lead Developer",
	"ADD_ACCOUNT": "Lgg till konto",
	"PLATFORM": "Plattform",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Ratificeringen tidsfristen",
	"ESCROW_EXPIRATION": "Escrow frfallodatum",
	"ESCROW_FEE": "Escrow avgift",
	"ESCROW_TERMS": "Escrow villkor"
}
},{}],127:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": " ",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ...",
	"ABOUT_1": "       !",
	"ABOUT_2": "  ,      ,   .",
	"ABOUT_3": "       .       , , , ,       ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "          .",
	"ABOUT_5": "  -  .              .",
	"ABOUT_6": "3.   ,     .",
	"ABOUT_7": "        .",
	"ABOUT_8": "  good-karma   ",
	"ABOUT_9": "/ '",
	"ABOUT_10": " ",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "  ",
	"UNFOLLOW": " ",
	"FOLLOWING": " ",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ,   ",
	"POST_2": "  ,    ",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": " ,  ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},  ,     - . {{platformname}}    {{platformpower}}  ,    \"\".",
	"PROFILE_2": "{{platformpower}},  ,            .     ,        ,      .",
	"PROFILE_3": "   {{platformsunit}} {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7-   {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "-     .         .",
	"OWNER": "",
	"PROFILE_6": "   -         .            .",
	"ACTIVE": "",
	"PROFILE_7": "    ,         .",
	"MEMO": "'",
	"PROFILE_8": "'       '.",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " '",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "PIN-",
	"PIN_TEXT": "PIN-       . <br/> <br/> <b>:</b>       4 ,  .    -     ,    ,    .        .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,      ! <br/> <b>:</b>         (   ,  ,  ).",
	"VOTE": "",
	"COMMENT_TEXT": "  ,       ! <br/> <b>:</b>     ,   <b></b>   .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,          !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,       /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,      !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "         ,        . <br/> <br/> <b>:</b>     /   ,    ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ,  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": " ,        .",
	"LOGIN_2": "-     , , , .",
	"LOGIN_3": "        .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": "  ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "-",
	"MASTER_PASS": "/ ",
	"USERNAME": "' ",
	"CARD_VIEW": "  ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": "  50% / 50%",
	"POWERUP": "   100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN-",
	"INCORRECT": " ",
	"OPENING_POST": " ",
	"SET_PIN": " PIN-",
	"ENTER_PIN": " PIN-",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "  ,   ?",
	"BROADCAST_ERROR": " ,   !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !  , ,     -    -       .",
	"LOGIN_FAIL_A": "  !  , ,     -            .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "  ",
	"SECS": "",
	"A_MIN": "",
	"MINS": ".",
	"AN_HOUR": ".",
	"HOURS": ".",
	"A_DAY": "",
	"DAYS": "()",
	"A_MONTH": "",
	"MONTHS": "()",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": ". ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": " URL ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "   ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "   ' ",
	"INFO": "",
	"QR_TEXT": " QR-   ",
	"BALANCE_TEXT": ",       !",
	"NONEXIST_USER": ",     ,  !",
	"TRANSFER_TEXT": "    ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": " ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "           . <br><br>     : <ul><li>  </li> <li>   </li> <li>       </li></ul>",
	"REQUEST_LIMIT_TEXT": "  .   /!",
	"POST_IS_UNBOOKMARK": "   !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": " ,    ,      !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     .",
	"LOGIN_TO_X": "        , / .  ,      .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "   !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": " ,   ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "     !",
	"PULL_DOWN_TO_REFRESH": " ,  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .   /     .",
	"ABOUT_11": "<br><b></b> <br>-      -    . <br> -  ,    . <br>  ,   ,     . <br>  ,       ,      . <br>   ,            . <br>        . <br>      . <br>  -   , ,   <br>   , . <br> -     ,    . <br> ,    '       ,      <br>    / , . <br> -  . <br>     . <br><br><b></b> <br>1.         . <br>2.   - ,           - ,       . <br>3.   ,       . <br>4.         pin-. <br><br> eSteem   Steem  Golos. <br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": " ",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": "  ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "ID",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "-",
	"DISPLAY_NAME": " '"
}
},{}],128:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "",
	"ABOUT_2": "{{platformname}}",
	"ABOUT_3": "{{platformname}}{{sitename}}",
	"ABOUT_4": "1.",
	"ABOUT_5": "2. ",
	"ABOUT_6": "3.",
	"ABOUT_7": "4.",
	"ABOUT_8": " good-karma ",
	"ABOUT_9": "/",
	"ABOUT_10": "",
	"REMOVE": "",
	"MARKET_VIEW": "",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "",
	"SEARCH_FOLLOWING": "",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": "",
	"UNVOTE_UPVOTED": "",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "",
	"POST_2": "",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}}, . {{platformname}} {{platformpower}}",
	"PROFILE_2": "{{platformpower}}, ",
	"PROFILE_3": "{{platformsunit}} {{platformname}}",
	"ESTIMATED_VALUE": "",
	"PROFILE_4": "{{platformname}}7",
	"TRANSACTION_HISTORY": "",
	"POSTING": "",
	"PROFILE_5": "",
	"OWNER": "",
	"PROFILE_6": "",
	"ACTIVE": "",
	"PROFILE_7": "",
	"MEMO": "",
	"PROFILE_8": "",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": " (:good-karma)",
	"PIN_CODE": "Pin ",
	"PIN_TEXT": "PIN<br/><br/><b>:</b>4",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "<br/> <b>:</b>  (, , ). ",
	"VOTE": "",
	"COMMENT_TEXT": "<b>:</b> <b></b>. ",
	"COMMENT": "",
	"FOLLOW_TEXT": "",
	"MENTIONS": "",
	"MENTIONS_TEXT": "",
	"RESTEEM": "",
	"RESTEEM_TEXT": "",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "APP<br/><br/><b>:</b> /APP.",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "",
	"WELCOME_BACK": "",
	"LOGIN_1": "",
	"LOGIN_2": "",
	"LOGIN_3": "",
	"LOGIN_4": "",
	"DONT_HAVE": "",
	"SIGN_UP_NOW": "",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "",
	"POSTING_PRIKEY": "",
	"MASTER_PASS": "",
	"USERNAME": "",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": "",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"POWERUP": "100% ",
	"DECLINE_PAYOUT": "",
	"SAVE_FOR_LATER": "",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": "",
	"CONFIRM_PIN": " PIN",
	"INCORRECT": "",
	"OPENING_POST": "",
	"SET_PIN": " PIN",
	"ENTER_PIN": " PIN",
	"ARE_YOU_SURE": "",
	"REBLOG_TEXT": "",
	"BROADCAST_ERROR": "",
	"SUCCESS": "",
	"REBLOGGED_POST": "",
	"LOGIN_FAIL": "",
	"LOGIN_FAIL_A": "",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "",
	"VOTED_FOR_WITNESS": "",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "",
	"DOWNVOTE_FLAG": "",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": "",
	"SET_CUSTOM_URL": "URL",
	"INSERT_PICTURE": "",
	"ERROR": "",
	"UPLOAD_ERROR": "",
	"CAMERA_CANCELLED": "",
	"SET_URL": "URL",
	"DIRECT_LINK_PICTURE": "",
	"COMMENT_SUBMITTED": "",
	"DELETE_COMMENT": "...",
	"DELETED_COMMENT": "",
	"UPLOADING_PICTURE": "",
	"UPLOAD_COMPLETED": "",
	"UPLOAD_FAILED": "",
	"PASSWORD_INCORRECT": "",
	"INFO": "",
	"QR_TEXT": "",
	"BALANCE_TEXT": "",
	"NONEXIST_USER": "",
	"TRANSFER_TEXT": "",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "30",
	"SORT_POST_BY": "",
	"PAYOUT_CYCLE": "",
	"POTENTIAL_PAYOUT": "",
	"PAST_PAYOUT": "",
	"AUTHOR_PAYOUT": "",
	"CURATION_PAYOUT": "",
	"POST_SUBMITTED": "",
	"POST_LATER": "",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "<br><br><ul><li></li><li></li><li>SPAM</li></ul>",
	"REQUEST_LIMIT_TEXT": "/",
	"POST_IS_UNBOOKMARK": "",
	"POST_IS_BOOKMARK": "",
	"RESET": "",
	"MODIFY_PICTURE": "",
	"MODIFY_COVER_PICTURE": "",
	"ACTIVE_KEY_REQUIRED_TEXT": "",
	"RESET_PICTURE_TEXT": "",
	"RESET_COVER_PICTURE_TEXT": "",
	"UPDATE_REQUIRES_RESTART": "",
	"SETTINGS_UPDATED": "",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "",
	"LOGIN_TO_X": "/",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "",
	"POST_IS_DRAFT": "",
	"SWIPE_LEFT": "",
	"MANAGE": "",
	"IMAGE_REMOVED": "",
	"COPY": "",
	"NO_IMAGE": "",
	"PULL_DOWN_TO_REFRESH": "",
	"EXTERNAL_APPS": "",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "",
	"CURRENCY": "",
	"CURRENCY_TEXT": "",
	"ABOUT_11": "<br><b></b> <br> <br>-<br><br><br>-<br><br><br>-   <br> <br>-<br> <br> <br>-<br><br><br><b></b> <br>1<br>2.<br>3. <br>4 pin  <br><br> Golos  <br>",
	"FOUNDER": "",
	"ADD_ACCOUNT": "",
	"PLATFORM": ""
}
},{}],129:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "",
	"ABOUT_2": "{{platformname}}App",
	"ABOUT_3": "{{platformname}}{{sitename}}",
	"ABOUT_4": "App",
	"ABOUT_5": "App",
	"ABOUT_6": "App",
	"ABOUT_7": "App",
	"ABOUT_8": "good-karmawitness",
	"ABOUT_9": "/",
	"ABOUT_10": "",
	"REMOVE": "",
	"MARKET_VIEW": "",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "",
	"SEARCH_FOLLOWING": "",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": "",
	"UNVOTE_UPVOTED": "",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "",
	"POST_2": "",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}} {{platformname}}  {{platformpower}}powering up",
	"PROFILE_2": "{{platformpower}}  ",
	"PROFILE_3": "{{platformsunit}}{{platformname}}",
	"ESTIMATED_VALUE": "",
	"PROFILE_4": "{{platformname}}3-5",
	"TRANSACTION_HISTORY": "",
	"PROFILE_5": "PostingActiveOwner",
	"PROFILE_6": "OwnerOwner",
	"PROFILE_7": "Active",
	"PROFILE_8": "Memomemo",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": " good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "App<br/><br/><b></b>4AppApp",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "<br/> <b></b> ",
	"VOTE": "",
	"COMMENT_TEXT": "<br/> <b></b> <b></b>",
	"COMMENT": "",
	"FOLLOW_TEXT": "",
	"MENTIONS": "",
	"MENTIONS_TEXT": "",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "<br/> <b></b> ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "",
	"WELCOME_BACK": "",
	"LOGIN_1": "",
	"LOGIN_2": "Posting key",
	"LOGIN_3": "Active key",
	"LOGIN_4": "",
	"DONT_HAVE": "",
	"SIGN_UP_NOW": "",
	"CANCEL": "",
	"ADVANCED": "",
	"MASTER_PASS": "Master/",
	"USERNAME": "",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": "",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"DECLINE_PAYOUT": "Payout",
	"SAVE_FOR_LATER": "",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": "",
	"CONFIRM_PIN": "",
	"INCORRECT": "",
	"OPENING_POST": "",
	"SET_PIN": "",
	"ENTER_PIN": "",
	"ARE_YOU_SURE": "",
	"BROADCAST_ERROR": "",
	"SUCCESS": "",
	"REBLOGGED_POST": "",
	"LOGIN_FAIL": "masterPosting",
	"LOGIN_FAIL_A": "masterActive",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "",
	"VOTED_FOR_WITNESS": "",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "",
	"DOWNVOTE_FLAG": "",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": "",
	"SET_CUSTOM_URL": "",
	"INSERT_PICTURE": "",
	"ERROR": "",
	"UPLOAD_ERROR": "",
	"CAMERA_CANCELLED": "",
	"SET_URL": "URL",
	"DIRECT_LINK_PICTURE": "",
	"COMMENT_SUBMITTED": "",
	"DELETE_COMMENT": "",
	"DELETED_COMMENT": "",
	"UPLOADING_PICTURE": "",
	"UPLOAD_COMPLETED": "",
	"UPLOAD_FAILED": "",
	"PASSWORD_INCORRECT": "",
	"INFO": "",
	"QR_TEXT": "QR code",
	"BALANCE_TEXT": "",
	"NONEXIST_USER": "",
	"TRANSFER_TEXT": "",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "30",
	"SORT_POST_BY": "",
	"PAYOUT_CYCLE": "",
	"POTENTIAL_PAYOUT": "",
	"PAST_PAYOUT": "",
	"AUTHOR_PAYOUT": "",
	"CURATION_PAYOUT": "",
	"POST_SUBMITTED": "",
	"POST_LATER": "",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "<br><br> <ul><li></li><li></li><li></li></ul>",
	"REQUEST_LIMIT_TEXT": "",
	"POST_IS_UNBOOKMARK": "",
	"POST_IS_BOOKMARK": "",
	"RESET": "",
	"MODIFY_PICTURE": "",
	"MODIFY_COVER_PICTURE": "",
	"ACTIVE_KEY_REQUIRED_TEXT": "Active",
	"RESET_PICTURE_TEXT": "",
	"RESET_COVER_PICTURE_TEXT": "",
	"UPDATE_REQUIRES_RESTART": "",
	"SETTINGS_UPDATED": "",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "APP",
	"LOGIN_TO_X": "ActivePosting",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "",
	"POST_IS_DRAFT": "",
	"SWIPE_LEFT": "",
	"MANAGE": "",
	"IMAGE_REMOVED": "",
	"COPY": "",
	"NO_IMAGE": "",
	"PULL_DOWN_TO_REFRESH": "",
	"EXTERNAL_APPS": "App",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "",
	"RELEASE": ""
}
},{}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//angular.module('steem.services', [])
module.exports = function (app) {
	app.service('APIs', ['$http', '$rootScope', 'API_END_POINT', function ($http, $rootScope, API_END_POINT) {
		'use strict';
		return {
      getCurrencyRate: function(code_from, code_to){
        console.log(code_from,code_to);
        return $http.get("https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22"+code_from+code_to+"%22)&format=json&diagnostics=false&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys");
      },
      saveSubscription: function(deviceid, username, subscription) {
        return $http.post(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateSubscription: function(deviceid, username, subscription) {
        return $http.put(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateToken: function(deviceid, newdev) {
        return $http.put(API_END_POINT+"/api/device/"+deviceid, {newdev: newdev, chain: $rootScope.$storage.chain});
      },
      deleteSubscription: function(deviceid) {
        return $http.delete(API_END_POINT+"/api/devices/"+deviceid);
      },
      getSubscriptions: function(deviceid) {
        return $http.get(API_END_POINT+"/api/devices/"+deviceid);
      },
			addBookmark: function(user, bookmark) {
        return $http.post(API_END_POINT+"/api/bookmark", {username: user, author: bookmark.author, permlink: bookmark.permlink, chain: $rootScope.$storage.chain});
      },
			getBookmarks: function(user) {
        return $http.get(API_END_POINT+"/api/bookmarks/"+user);
      },
			removeBookmark: function(id, user) {
        return $http.delete(API_END_POINT+"/api/bookmarks/"+user+"/"+id);
      },
			addDraft: function(user, draft) {
        return $http.post(API_END_POINT+"/api/draft", {username: user, title: draft.title, body: draft.body, tags: draft.tags, post_type: draft.post_type, chain: $rootScope.$storage.chain});
      },
			getDrafts: function(user) {
        return $http.get(API_END_POINT+"/api/drafts/"+user);
      },
			removeDraft: function(id, user) {
        return $http.delete(API_END_POINT+"/api/drafts/"+user+"/"+id);
      },
			removeImage: function(id, user) {
        return $http.delete(API_END_POINT+"/api/images/"+user+"/"+id);
      },
			fetchImages: function(user) {
        return $http.get(API_END_POINT+"/api/images/"+user);
      },
      searchEscrow: function(id) {
        return $http.get(API_END_POINT+"/api/escrow/"+$rootScope.$storage.chain+"/"+id);
      },
		};
	}])
  app.directive('backImg', function(){
    return function(scope, element, attrs){
        var url = attrs.backImg;
        element.css({
            'background-image': 'url(' + url +')',
            'background-size' : 'cover'
        });
    };
  });
  app.directive('select', function() {
    return {
      restrict: 'E',
      link: function(scope, element, attrs) {
        element.bind('focus', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("show bar (hide = false)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
          }
        });
        element.bind('blur', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("hide bar (hide = true)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
          }
        });
      }
    };
  });
  app.directive('navigation', function () {
    var controller = ['$scope', '$rootScope', function ($scope, $rootScope) {
      $scope.addactiveclass = function (menuItem) {
          $scope.activeMenu = menuItem.name;
          //$rootScope.log(menuItem);
          $rootScope.$storage.filter = menuItem.href;
          $rootScope.$broadcast('filter:change');
          $scope.center(menuItem.name);
          $scope.someCtrlFn({menulinks: menuItem});
      };

      $(window).resize(function(){
        $scope.center();
      });
      $scope.center = function(menuItem) {
        var nav = document.getElementById("nav1");
        var navWidth = document.getElementById("nav2").offsetWidth;
        var currentElement = document.querySelectorAll('[name="'+menuItem+'"]');
        currentElement = menuItem ? currentElement[0] : document.getElementsByClassName('active')[0];
        if(currentElement) {
          var margin = 0;
          var lenm = nav.children.length;
          for(var i =0; i<lenm; i++){

            if(currentElement == nav.children[i]){
              break;
            }else {
              margin += nav.children[i].offsetWidth;
            }
          }
          nav.style.marginLeft = (navWidth/2 - margin - currentElement.offsetWidth/2) + 'px';
        }
        else {
          nav.style.marginLeft = (navWidth/2 - $scope.activeMenu.length) + 'px';
        }
      };
      var _len = $scope.menulinks.length;
      for (var i = 0; i < _len; i++) {
        if ($rootScope.$storage.filter) {
          if ($scope.menulinks[i].href == $rootScope.$storage.filter) {
            $scope.activeMenu = $scope.menulinks[i].name;
          }
        } else {
          $scope.activeMenu = "Trending";
        }
      }

      //$scope.center();
      setTimeout(function() {
        $scope.center();
      }, 50);
    }];

    return {
      restrict: "E",
      replace: true,
      scope: {
        menulinks: '=',
        someCtrlFn: '&callbackFn'
      },
      controller: controller,
      template: "<ul id='nav1'>"+
              "<li ng-repeat='menulinks in menulinks' name='{{menulink.name}}' class='top {{menulink.role}}' ng-class='{active : activeMenu === menulink.name}'>"+
                "<a on-tap='addactiveclass(menulink)'>"+
                  "{{menulink.name}}"
                +"</a>"+
                "<div class='arrow'></div>"+
                "</li>"
            +"</ul>"
    }
  });
  function SimplePubSub() {
      var events = {};
      return {
          on: function(names, handler) {
              names.split(' ').forEach(function(name) {
                  if (!events[name]) {
                      events[name] = [];
                  }
                  events[name].push(handler);
              });
              return this;
          },
          trigger: function(name, args) {
              angular.forEach(events[name], function(handler) {
                  handler.call(null, args);
              });
              return this;
          }
      };
  };

  app.directive('onFinishRender', function ($timeout) {
      return {
          restrict: 'A',
          link: function (scope, element, attr) {
              if (scope.$last === true) {
                  $timeout(function () {
                      scope.$emit('ngRepeatFinished');
                  });
              }
          }
      }
  })
  app.directive('clickHandler', function($timeout){
      return{
          restrict: 'A',
          link: function($scope, $element,$attr){
              $timeout(function(){
                      $element.on('tap', function(){
                        //the function you want to perform on tap
        alert("Just been Clicked");
                      });
              });
          }
      };
  })
  app.directive('tabSlideBox', [ '$timeout', '$window', '$ionicSlideBoxDelegate', '$ionicScrollDelegate', '$rootScope',
    function($timeout, $window, $ionicSlideBoxDelegate, $ionicScrollDelegate, $rootScope) {
      'use strict';

      return {
        restrict : 'A, E, C',
        link : function(scope, element, attrs, ngModel) {

          var ta = element[0], $ta = element;
          $ta.addClass("tabbed-slidebox");
          if(attrs.tabsPosition === "bottom"){
            $ta.addClass("btm");
          }

          //Handle multiple slide/scroll boxes
          var handle = ta.querySelector('.slider').getAttribute('delegate-handle');

          var ionicSlideBoxDelegate = $ionicSlideBoxDelegate;
          if(handle){
            ionicSlideBoxDelegate = ionicSlideBoxDelegate.$getByHandle(handle);
          }

          var ionicScrollDelegate = $ionicScrollDelegate;
          if(handle){
            ionicScrollDelegate = ionicScrollDelegate.$getByHandle(handle);
          }

          function renderScrollableTabs(){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            angular.forEach(icons, function(value, key){
                 var a = angular.element(value);
                 a.on('click', function(){
                   ionicSlideBoxDelegate.slide(key);
                 });

              if(a.attr('icon-off')) {
                a.attr("class", a.attr('icon-off'));
              }
            });

            var initialIndex = attrs.tab;
            //Initializing the middle tab
            if(typeof attrs.tab === 'undefined' || (totalTabs <= initialIndex) || initialIndex < 0){
              initialIndex = Math.floor(icons.length/2);
            }

            //If initial element is 0, set position of the tab to 0th tab
            if(initialIndex == 0){
              setPosition(0);
            }
            //$rootScope.log('initialIndex '+initialIndex);
            if ($rootScope.$storage.filter) {
              if ($rootScope.$storage.user) {
                if ($rootScope.$storage.filter === 'feed') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 8;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 9;
                }
              } else {
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 8;
                }
              }
            }
            $timeout(function() {
              ionicSlideBoxDelegate.slide(initialIndex);
            }, 10);
          }

          function setPosition(index){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            var middle = iconsDiv[0].offsetWidth/2;
            var curEl = angular.element(icons[index]);
            var prvEl = angular.element(iconsDiv[0].querySelector(".active"));
            if(curEl && curEl.length){
              var curElWidth = curEl[0].offsetWidth, curElLeft = curEl[0].offsetLeft;

              if(prvEl.attr('icon-off')) {
                prvEl.attr("class", prvEl.attr('icon-off'));
              } else{
                prvEl.removeClass("active");
              }
              if(curEl.attr('icon-on')) {
                curEl.attr("class", curEl.attr('icon-on'));
              }
              curEl.addClass("active");

              var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5);
              //If tabs are not scrollable
              if(!scrollDiv){
                var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5) + "px";
                wrap.style.webkitTransform =  "translate3d("+leftStr+",0,0)" ;
              } else {
                //If scrollable tabs
                var wrapWidth = wrap.offsetWidth;
                var currentX = Math.abs(getX(scrollDiv.style.webkitTransform));
                var leftOffset = 100;
                var elementOffset = 54;
                //If tabs are reaching right end or left end
                if(((currentX + wrapWidth) < (curElLeft + curElWidth + elementOffset)) || (currentX > (curElLeft - leftOffset))){
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  //Use this scrollTo, so when scrolling tab manually will not flicker
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);

                } else {
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);
                }
              }
            }
          };
          function getX(matrix) {

            matrix = matrix.replace("translate3d(","");
            matrix = matrix.replace("translate(","");
            return (parseInt(matrix));
          }
          var events = scope.events;
          events.on('slideChange', function(data){
            setPosition(data.index);
          });
          events.on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            renderScrollableTabs();
          });
          setTimeout(function() {
            renderScrollableTabs();
          }, 10);

        },
        controller : function($scope, $attrs, $element, $rootScope) {
          $scope.events = new SimplePubSub();
          $scope.slideHasChanged = function(index){
            $rootScope.log("SlideChanged "+index);
            $scope.currentSlide = index;
            $scope.events.trigger("slideChange", {"index" : index});
            $timeout(function(){
              if($scope.onSlideMove) {
                $scope.onSlideMove({"index" : eval(index)});
              }

              if ($rootScope.$storage.user) {
                if (index === 0) {
                  $rootScope.$storage.filter = 'feed';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 9) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              } else {
                if (index === 0) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              }
              if (!$rootScope.$$phase){
                $rootScope.$apply();
              }
            }, 10);
          };

          $scope.$on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            $rootScope.log('ngRepeatFinished');
            $scope.events.trigger("ngRepeatFinished", {"event" : ngRepeatFinishedEvent});
          });
        }
      };

    }
  ]);

	app.filter('timeago', function($filter, $translate, $rootScope) {

      function TimeAgo(input, p_allowFuture) {
        var substitute = function (stringOrFunction, number, strings) {
                var string = angular.isFunction(stringOrFunction) ? stringOrFunction(number, dateDifference) : stringOrFunction;
                var value = (strings.numbers && strings.numbers[number]) || number;
                return string.replace(/%d/i, value);
            },
            nowTime = (new Date()).getTime(),
            date = (new Date(input)).getTime(),
            //refreshMillis= 6e4, //A minute
            allowFuture = p_allowFuture || false,
            strings= {
                prefixAgo: '',
                prefixFromNow: '',
                suffixAgo: $filter('translate')('AGO'),
                suffixFromNow: $filter('translate')('FROM_NOW'),
                seconds: $filter('translate')('SECS'),
                minute: $filter('translate')('A_MIN'),
                minutes: "%d "+$filter('translate')('MINS'),
                hour: $filter('translate')('AN_HOUR'),
                hours: "%d "+$filter('translate')('HOURS'),
                day: $filter('translate')('A_DAY'),
                days: "%d "+$filter('translate')('DAYS'),
                month: $filter('translate')('A_MONTH'),
                months: "%d "+$filter('translate')('MONTHS'),
                year: $filter('translate')('A_YEAR'),
                years: "%d "+$filter('translate')('YEARS')
            },
            dateDifference = nowTime - date,
            words,
            seconds = Math.abs(dateDifference) / 1000,
            minutes = seconds / 60,
            hours = minutes / 60,
            days = hours / 24,
            years = days / 365,
            separator = strings.wordSeparator === undefined ?  " " : strings.wordSeparator,


            prefix = strings.prefixAgo,
            suffix = strings.suffixAgo;

        if (allowFuture) {
            if (dateDifference < 0) {
                prefix = strings.prefixFromNow;
                suffix = strings.suffixFromNow;
            }
        }

        words = seconds < 45 && substitute(strings.seconds, Math.round(seconds), strings) ||
        seconds < 90 && substitute(strings.minute, 1, strings) ||
        minutes < 45 && substitute(strings.minutes, Math.round(minutes), strings) ||
        minutes < 90 && substitute(strings.hour, 1, strings) ||
        hours < 24 && substitute(strings.hours, Math.round(hours), strings) ||
        hours < 42 && substitute(strings.day, 1, strings) ||
        days < 30 && substitute(strings.days, Math.round(days), strings) ||
        days < 45 && substitute(strings.month, 1, strings) ||
        days < 365 && substitute(strings.months, Math.round(days / 30), strings) ||
        years < 1.5 && substitute(strings.year, 1, strings) ||
        substitute(strings.years, Math.round(years), strings);
        //$rootScope.log(prefix+words+suffix+separator);
        prefix.replace(/ /g, '')
        words.replace(/ /g, '')
        suffix.replace(/ /g, '')
        return (prefix+' '+words+' '+suffix+' '+separator);

      };

      TimeAgo.$stateful = true;
      return TimeAgo;
    });

    app.filter('parseUrl', function($sce) {
	    var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
	    var emails = /(\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,6})/gim;
  	 	var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
  		var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
  		var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

	    return function(textu, subpart) {
        var options = {
        	gfm: true,
			    tables: true,
          smartLists: true,
			    breaks: true,
			    pedantic: false,
			    sanitize: false,
			    smartLists: true,
			    smartypants: false
			  };
        if (textu) {
          var textu = marked(textu, options);
          if (subpart) {
            var s = $sce.trustAsHtml(textu).toString();
            var text = s.substring(s.indexOf("<p>"), s.indexOf("</p>"));
            return text;
          } else {
            return $sce.trustAsHtml(textu);
          }
        }
	    };
	});

    app.filter('metadata', function($sce) {
        var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
        var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
        var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

        return function(textu) {
            var out = {};
            var murls = textu.match(urls);
            var musers = textu.match(users);
            var mimgs = [];
            var mlinks = [];
            if (murls) {
              var _len = murls.length;
                for (var i = 0; i < _len; i++) {
                    var ind = murls[i].match(imgs);
                    if (ind) {
                        mimgs.push(murls[i]);
                    } else {
                        mlinks.push(murls[i]);
                    }
                }
                if (mlinks) {
                    angular.merge(out, {links: mlinks});
                }
                if (mimgs) {
                    angular.merge(out, {image: mimgs});
                }
            }
            if (musers) {
              var _len = musers.length;
                for (var i = 0; i < _len; i++) {
                    musers[i] = musers[i].trim().substring(1);
                }
                if (musers) {
                    angular.merge(out, {users: musers});
                }
            }
            return out;
        };
    });

    app.filter('metadataUsers', function($sce) {
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        return function(textu) {
          if (textu) {
            var out = {};
            var musers = textu.match(users);

            $rootScope.log(angular.toJson(musers));

            return textu;
          }
        };
    });

    app.filter('ldots', function() {
        return function(text) {
          if (text) {
            return text+'...';
          }
        };
    });

    app.filter('regex', function() {
      return function(input, field, regex) {
          var patt = new RegExp(regex);      
          var out = [];
          for (var i = 0; i < input.length; i++){
            //console.log(patt.test(input[i][field]));
            if(!patt.test(input[i][field]))
              out.push(input[i]);
          }      
        return out;
      };
    });
    
    app.filter('detransliterate', function(){
      // copypaste from https://gist.github.com/tamr/5fb00a1c6214f5cab4f6
      // (it have been modified:  > iy and so on)
      // this have been done beecause we cannot use special symbols in url (`` and '')
      // and url seems to be the only source of thruth
      var d = /\s+/g,
      //rus = "                                           ".split(d),
      //eng = "sch  sh  ch  cz  yu  ju  ya  q  yie  iy  yo  jo  zh  w ye  y a b v g d e z i yi  k l m n o p r s t u f x h j".split(d);

      rus = "                                              ".split(d),
      eng = "shch sh ch cz ij yo ye yu ya kh zh a b v g d e z i k l m n o p r s t u f xx y x".split(d);
      return function (str, reverse) {
        if (!str) return str;
        if (!reverse && str.substring(0, 4) !== 'ru--') return str;
        if (!reverse) str = str.substring(4)

        // TODO rework this
        // (didnt placed this earlier because something is breaking and i am too lazy to figure it out ;( )
        if(!reverse) {
        //    str = str.replace(/j/g, '')
        //    str = str.replace(/w/g, '')
            str = str.replace(/yie/g, '')
        }
        else {
        //    str = str.replace(//g, 'j')
        //    str = str.replace(//g, 'w')
            str = str.replace(//g, 'yie')
        }

        var i,
            s = /[^[\]]+(?=])/g, orig = str.match(s),
            t = /<(.|\n)*?>/g, tags = str.match(t);

        if(reverse) {
            for(i = 0; i < rus.length; ++i) {
                str = str.split(rus[i]).join(eng[i]);
                str = str.split(rus[i].toUpperCase()).join(eng[i].toUpperCase());
            }
        }
        else {
            for(i = 0; i < rus.length; ++i) {
                str = str.split(eng[i]).join(rus[i]);
                str = str.split(eng[i].toUpperCase()).join(rus[i].toUpperCase());
            }
        }

        if(orig) {
            var restoreOrig = str.match(s);

            for (i = 0; i < restoreOrig.length; ++i)
                str = str.replace(restoreOrig[i], orig[i]);
        }

        if(tags) {
            var restoreTags = str.match(t);

            for (i = 0; i < restoreTags.length; ++i)
                str = str.replace(restoreTags[i], tags[i]);

            str = str.replace(/\[/g, '').replace(/\]/g, '');
        }

        return str;
      }
    })
     app.filter('getCurrencySymbol', function($filter) {
        return function(text) {
          if (text) {
            //console.log(text.split('-')[1]);
            //var x = text.split('-')[1];
            //var tt = $filter('uppercase')(x);
            var textu = window.getSymbol(text);
            return textu=="?"?text:textu;
          }
        };
    });

  function ansiWordBound(c) {
    return (
      (' ' === c) ||
      ('\n' === c) ||
      ('\r' === c) ||
      ('\t' === c)
    )
  }

  function readingTime(text, options) {
    var words = 0, start = 0, end = text.length - 1, wordBound, i

    options = options || {}

    // use default values if necessary
    options.wordsPerMinute = options.wordsPerMinute || 200

    // use provided function if available
    wordBound = options.wordBound || ansiWordBound

    // fetch bounds
    while (wordBound(text[start])) start++
    while (wordBound(text[end])) end--

    // calculate the number of words
    for (i = start; i <= end;) {
      for (; i <= end && !wordBound(text[i]); i++) ;
      words++
      for (; i <= end && wordBound(text[i]); i++) ;
    }

    // reading time stats
    var minutes = words / options.wordsPerMinute
    var time = minutes * 60 * 1000
    var displayed = Math.ceil(minutes.toFixed(2))

    return {
      text: displayed + ' min read',
      minutes: Math.ceil(minutes.toFixed(2)),
      time: time,
      words: words
    }
  }

  app.filter('readingtime', function($sce, $rootScope) {
      return function(text) {
        if (text) {
          return readingTime(text).minutes;
        }
      };
  })

	app.filter('sp', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests).toFixed(3);
	    	}
	    };
	})
	app.filter('sd', function($sce, $rootScope) {
	    return function(text, balance, sbd) {
	    	if (text) {
	    		return ((Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests*$rootScope.$storage.base + Number(balance.split(" ")[0])*$rootScope.$storage.base + Number(sbd.split(" ")[0])).toFixed(3))*$rootScope.$storage.currencyRate;
	    	}
	    };
	})
	app.filter('sbd', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('st', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('reputation', function(){
		return function(value, bool) {
			reputation_level = 1;
			neg = false;

			if (value < 0)
				neg = true;

			if (value != 0) {
				reputation_level = Math.log10(Math.abs(value));
				reputation_level = Math.max(reputation_level - 9, 0);

				if (reputation_level < 0)
					reputation_level = 0;
				if (neg)
					reputation_level *= -1;

				reputation_level = (reputation_level*9) + 25;
			} else {
				return 0;
			}

			return bool?reputation_level:Math.floor(reputation_level);
		}
	})

  app.filter("sumPostTotal", function($rootScope){
    function SumPostTotal(value, rate) {
      //console.log(value, rate);
      if (value && value.pending_payout_value) {
        //value.total_payout_value.split(" ")[0])+parseFloat(value.total_pending_payout_value.split(" ")[0])
        //return (parseFloat(value.pending_payout_value.split(" ")[0])*rate);
        return ((parseFloat(value.total_payout_value.split(" ")[0]))+(parseFloat(value.pending_payout_value.split(" ")[0]))*rate).toFixed(2);
      }
    }
    //SumPostTotal.$stateful = true;

    return SumPostTotal;
  });

  app.filter("rate", function($rootScope){
    return function(value) {
      if (value) {
        return (parseFloat(value)*$rootScope.$storage.currencyRate);
      }
    }
  });  

  app.filter('hrefToJS', function ($sce, $sanitize) {
      return function (text) {
          var regex = /href="([\S]+)"/g;
          var newString = $sanitize(text).replace(regex, "href onClick=\"window.open('$1', '_system', 'location=yes');return false;\"");
          return $sce.trustAsHtml(newString);
      }
  });

  app.directive('autofocus', ['$timeout',
    function ($timeout) {
      return {
        restrict: 'A',
        link: function ($scope, $element) {
          $timeout(function () {
            $element[0].focus();
          });
        }
      };
    }]);

  app.directive('selectInput', ['$ionicPopup', '$rootScope', function($ionicPopup, $rootScope) {
    return {
      restric: 'E',
      scope: {
        currentInput: '=ngModel',
        selectOptions: '='
      },
      require: '?^ngModel',
      template: '<div class="item-input item-icon-right" style="width:100%;"><input ng-model="currentInput" type="text" ng-change="socketChange(currentInput)"><i class="icon ion-android-arrow-dropdown" ng-click="showOptions()"></i></div>',
      link: function(scope, element, attrs) {
        scope.options = {
          selected: ''
        }
        scope.socketChange = function(xx){
          console.log(xx);
          $rootScope.$storage["socket"+$rootScope.$storage.chain] = xx;
          localStorage.socketUrl = xx;
          scope.restart = true;
        }
        scope.showOptions = function() {
          $ionicPopup.show({
            template: '<ion-radio ng-repeat="item in selectOptions" class="item-text-wrap" ng-model="options.selected" ng-value="item">{{item}}</ion-radio>',
            title: 'Server',
            cssClass: 'my-custom-popup',
            scope: scope,
            buttons: [{
              text: 'Cancel'
            }, {
              text: '<b>Confirm</b>',
              type: 'button-positive',
              onTap: function(e) {
                scope.currentInput = scope.options.selected;
              }
            }]
          });
        }
      }
    }
  }])

	app.directive('qrcode', function($interpolate) {
		return {
		    restrict: 'E',
		    link: function($scope, $element, $attrs) {

		      var options = {
		        text: '',
		        width: 128,
		        height: 128,
		        colorDark: '#000000',
		        colorLight: '#ffffff',
		        correctLevel: 'H'
		      };

		      Object.keys(options).forEach(function(key) {
		        options[key] = $interpolate($attrs[key] || '')($scope) || options[key];
		      });

		      options.correctLevel = QRCode.CorrectLevel[options.correctLevel];

		      new QRCode($element[0], options);

		    }
		}
	});


    app.directive('ionComment', ionComment)
    app.directive('ionThread', ionThread);

    function ionComment() {
        return {
            restrict: 'E',
            scope: {
                comment: '='
            },
            template: '<ion-item ng-if="comment.author" class="ion-comment item">\
                        <div class="ion-comment--author"><img class="round-avatar" src="img/user_profile.png" ng-src="{{$root.$storage.paccounts[comment.author].user_image||$root.$storage.paccounts[comment.author].profile.profile_image}}" onerror="this.src=\'img/user_profile.png\'" onabort="this.src=\'img/user_profile.png\'" /><b><a href="#/app/profile/{{comment.author}}">{{comment.author}}</a></b>&nbsp;<div class="reputation">{{comment.author_reputation|reputation|number:0}}</div>&middot;{{comment.created|timeago}}</div>\
                        <div class="ion-comment--score"><span on-tap="openTooltip($event,comment)"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if="comment.max_accepted_payout.split(\' \')[0] === \'0.000\'"><del>{{comment | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if="comment.max_accepted_payout.split(\' \')[0] !== \'0.000\'">{{comment | sumPostTotal:$root.$storage.currencyRate | number}}</span> </span> | <span on-tap="downvotePost(comment)"><span class="fa fa-flag" ng-class="{\'assertive\':comment.downvoted}"></span></span></div>\
                        <div class="ion-comment--text bodytext selectable" ng-bind-html="comment.body | parseUrl "></div>\
                        <div class="ion-comment--replies"><ion-spinner ng-if="comment.invoting"></ion-spinner><span on-tap="upvotePost(comment)" on-hold="openSliderr($event, comment)"><span class="fa fa-chevron-circle-up" ng-class="{\'positive\':comment.upvoted}"></span> {{"UPVOTE"|translate}}</span> | <span on-tap="$root.openInfo(comment)">{{comment.net_votes || 0}} {{"VOTES"|translate}}</span> | <span on-tap="toggleComment(comment)">{{comment.children || 0}} {{"REPLIES"|translate}}</span> | <span on-tap="replyToComment(comment)"><span class="fa fa-reply"></span> {{"REPLY"|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username && compateDate(comment)" on-tap="editComment(comment)"> | <span class="ion-ios-compose-outline"></span> {{\'EDIT\'|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username && comment.abs_rshares == 0" on-tap="deleteComment(comment)"> | <span class="ion-ios-trash-outline"></span> {{\'REMOVE\'|translate}}</span></div>\
                    </ion-item>',
            controller: function($scope, $rootScope, $state, $ionicModal, $ionicPopover, $ionicPopup, $ionicActionSheet, $cordovaCamera, $filter, ImageUploadService) {
                  $ionicPopover.fromTemplateUrl('popoverTr.html', {
                      scope: $scope
                   }).then(function(popover) {
                      $scope.tooltip = popover;
                   });
                  
                  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
                      scope: $scope
                  }).then(function(popover) {
                      $scope.tooltipSliderr = popover;
                  });

                  $scope.openSliderr = function($event, d) {
                    $scope.votingPost = d;
                    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
                    $scope.tooltipSliderr.show($event);
                  };
                  $scope.votePostS = function() {
                    $scope.tooltipSliderr.hide();
                    $scope.upvotePost($scope.votingPost);
                  }
                  $scope.drag = function(v) {
                    //console.log(v);
                    $rootScope.$storage.voteWeight = v*100;
                  };

                  $scope.closeSliderr = function() {
                    $scope.tooltipSliderr.hide();
                  };

                  $scope.openTooltip = function($event, d) {
                    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
                    $scope.tooltipText = texth;
                    $scope.tooltip.show($event);
                  };

                  $scope.closeTooltip = function() {
                      $scope.tooltip.hide();
                  };

                  //Cleanup the popover when we're done with it!
                  $scope.$on('$destroy', function() {
                      $scope.tooltip.remove();
                  });


                  $scope.compateDate = function(comment) {
                    if (comment.last_payout == "1970-01-01T00:00:00") {
                        return true;
                    } else {
                      if (comment.mode == "first_payout"){
                        return true;
                      } else {
                        return false;
                      }
                    }
                  };
                  $scope.toggleComment = function(comment) {
                      $rootScope.log('toggleComment '+comment.showChildren);

                      if (comment.showChildren) {
                        comment.showChildren = false;
                      } else {
                        console.log(comment.author, comment.permlink);
                        comment.showChildren = true;
                        if (comment.depth % 5 == 0) {
                          console.log('depth5');
                          $rootScope.$broadcast('openComments', { data: comment });
                        } else {
                          window.Api.initPromise.then(function(response) {
                          window.Api.database_api().exec("get_content_replies", [comment.author, comment.permlink]).then(function(dd){
                            comment.comments = dd;

                            for (var i = 0, len = dd.length; i < len; i++) {
                              var v = dd[i];
                              if ($rootScope.$storage.postAccounts.indexOf(v.author) == -1) {
                                $rootScope.$storage.postAccounts.push(v.author);
                              }  
                            }
                            setTimeout(function() {
                              $scope.$broadcast('postAccounts');
                            }, 10);

                            if (!$scope.$$phase){
                              $scope.$apply();
                            }
                            comment.showChildren = true;
                            console.log(comment);
                          });
                          });  
                        }
                      }
                        //$rootScope.$broadcast('update:content');
                    //$rootScope.$broadcast('hide:loading');
                  };
                  $scope.$on('postAccounts', function(){
                    //$rootScope.$storage.paccounts = {};
                    //console.log($rootScope.$storage.paccounts)
                    window.Api.initPromise.then(function(response) {
                    window.Api.database_api().exec("get_accounts", [$rootScope.$storage.postAccounts]).then(function(res){
                      for (var i = 0, len = res.length; i < len; i++) {
                        var v = res[i];
                        if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
                          if (v.json_metadata) {
                            if (v.json_metadata.indexOf("created_at")>-1) {
                              v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
                            } else {
                              v.json_metadata = angular.fromJson(v.json_metadata);
                            }
                            var key = v.name;
                            $rootScope.$storage.paccounts[key] = v.json_metadata;
                          }
                        }
                      }
                      if (!$scope.$$phase){
                        $scope.$apply();
                      }
                    });
                    });
                  });
                  $scope.upvotePost = function(post) {
                    $rootScope.votePost(post, 'upvote', 'update:content');
                  };

                  $scope.downvotePost = function(post) {
                    var confirmPopup = $ionicPopup.confirm({
                      title: $filter('translate')('ARE_YOU_SURE'),
                      template: $filter('translate')('DOWNVOTE_FLAG')
                    });
                    confirmPopup.then(function(res) {
                      if(res) {
                        $rootScope.log('You are sure');
                        $rootScope.votePost(post, 'downvote', 'update:content');
                      } else {
                        $rootScope.log('You are not sure');
                      }
                    });
                  };

                  $scope.unvotePost = function(post) {
                    $rootScope.votePost(post, 'unvote', 'update:content');
                  };
                  $scope.data={};
                  $ionicModal.fromTemplateUrl('templates/reply.html', {
                    scope: $scope  }).then(function(modal) {
                    $scope.cmodal = modal;
                  });

                  $scope.openModal = function(item) {
                    $scope.cmodal.show();
                  };

                  $scope.closeModal = function() {
                    $scope.replying = false;
                    $scope.cmodal.hide();
                  };

                  $scope.isreplying = function(cho, xx) {
                    $scope.replying = xx;
                    $scope.post = cho;
                    if (xx) {
                        $scope.editc = false;
                        $scope.edit = false;
                        $scope.data.comment = '';
                        $scope.openModal();
                    } else {
                        $scope.editc = true;
                        $scope.edit = true;
                        $scope.data.comment = $scope.post.body;
                        $scope.patchbody = $scope.post.body;
                        $scope.openModal();
                    }
                  };

                  $scope.showImg = function() {
                   var hideSheet = $ionicActionSheet.show({
                     buttons: [
                       { text: $filter('translate')('CAPTURE_PICTURE') },
                       { text: $filter('translate')('SELECT_PICTURE') },
                       { text: $filter('translate')('SET_CUSTOM_URL') },
                     ],
                     titleText: $filter('translate')('INSERT_PICTURE'),
                     cancelText: $filter('translate')('CANCEL'),
                     cancel: function() {
                        // add cancel code..
                      },
                     buttonClicked: function(index) {
                        $scope.insertImageC(index);
                        return true;
                     }
                   });
                  };

                  $scope.insertImageC = function(type) {
                    var options = {};
                    if (type == 0 || type == 1) {
                      options = {
                        quality: 50,
                        destinationType: Camera.DestinationType.FILE_URI,
                        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
                        allowEdit: (type===0)?true:false,
                        encodingType: Camera.EncodingType.JPEG,
                        popoverOptions: CameraPopoverOptions,
                        saveToPhotoAlbum: false
                        //correctOrientation:true
                      };
                      $cordovaCamera.getPicture(options).then(function(imageData) {
                        setTimeout(function() {
                          ImageUploadService.uploadImage(imageData).then(function(result) {
                            //var url = result.secure_url || '';
                            var url = result.imageUrl || '';
                            var final = " ![image](" + url + ")";
                            $rootScope.log(final);
                            if ($scope.data.comment) {
                              $scope.data.comment += final;
                            } else {
                              $scope.data.comment = final;
                            }
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          },
                          function(err) {
                            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          });
                        }, 10);
                      }, function(err) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
                      });
                    } else {
                      $ionicPopup.prompt({
                        title: $filter('translate')('SET_URL'),
                        template: $filter('translate')('DIRECT_LINK_PICTURE'),
                        inputType: 'text',
                        inputPlaceholder: 'http://example.com/image.jpg'
                      }).then(function(res) {
                        $rootScope.log('Your url is' + res);
                        if (res) {
                          var url = res.trim();
                          var final = " ![image](" + url + ")";
                          $rootScope.log(final);
                          if ($scope.data.comment) {
                            $scope.data.comment += final;
                          } else {
                            $scope.data.comment = final;
                          }
                        }
                      });
                    }
                  };

                  var dmp = new window.diff_match_patch();
                  function createPatch(text1, text2) {
                      if (!text1 && text1 === '') return undefined;
                      var patches = dmp.patch_make(text1, text2);
                      var patch = dmp.patch_toText(patches);
                      return patch;
                  }
                  $scope.reply = function (xx) {
                    window.Api.initPromise.then(function(response) {
                      if (!$scope.editc) {
                          $rootScope.$broadcast('show:loading');
                          if ($rootScope.$storage.user) {
                            $scope.mylogin = new window.ejs.Login();
                            $scope.mylogin.setRoles(["posting"]);
                            var loginSuccess = $scope.mylogin.checkKeys({
                                accountName: $rootScope.$storage.user.username,
                                password: $rootScope.$storage.user.password || null,
                                auths: {
                                    posting: $rootScope.$storage.user.posting.key_auths
                                },
                                privateKey: $rootScope.$storage.user.privatePostingKey || null
                              }
                            );
                            if (loginSuccess) {
                              var tr = new window.ejs.TransactionBuilder();
                              var t = new Date();
                              var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";

                              var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                              tr.add_type_operation("comment", {
                                parent_author: $scope.post.author,
                                parent_permlink: $scope.post.permlink,
                                author: $rootScope.$storage.user.username,
                                permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
                                title: "",
                                body: $scope.data.comment,
                                json_metadata: angular.toJson(json)
                              });
                              tr.add_type_operation("comment_options", {
                                allow_curation_rewards: true,
                                allow_votes: true,
                                author: $rootScope.$storage.user.username,
                                permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,  
                                max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
                                percent_steem_dollars: 10000,
                                extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
                              });
                              //$rootScope.log(my_pubkeys);
                              localStorage.error = 0;
                              tr.process_transaction($scope.mylogin, null, true);

                              $scope.replying = false;
                              setTimeout(function() {
                                if (localStorage.error == 1) {
                                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                } else {
                                  $scope.closeModal();
                                  $scope.data.comment = "";
                                  $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                  $rootScope.$broadcast("update:content");
                                }
                                $rootScope.$broadcast('hide:loading');
                              }, 3000);
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                            }
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                          }
                      } else {

                          var patch = createPatch($scope.patchbody, $scope.data.comment)
                          // Putting body into buffer will expand Unicode characters into their true length
                          if (patch && patch.length < new Buffer($scope.data.comment, 'utf-8').length) {
                            $scope.data.comment2 = patch;
                            //$rootScope.log(patch);
                          }

                          $rootScope.$broadcast('show:loading');
                          if ($rootScope.$storage.user) {
                            $scope.mylogin = new window.ejs.Login();
                            $scope.mylogin.setRoles(["posting"]);
                            var loginSuccess = $scope.mylogin.checkKeys({
                                accountName: $rootScope.$storage.user.username,
                                password: $rootScope.$storage.user.password || null,
                                auths: {
                                    posting: $rootScope.$storage.user.posting.key_auths
                                },
                                privateKey: $rootScope.$storage.user.privatePostingKey || null
                              }
                            );
                            if (loginSuccess) {
                              var tr = new window.ejs.TransactionBuilder();

                              var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                              tr.add_type_operation("comment", {
                                parent_author: $scope.post.parent_author,
                                parent_permlink: $scope.post.parent_permlink,
                                author: $scope.post.author,
                                permlink: $scope.post.permlink,
                                title: "",
                                body: $scope.data.comment2 || $scope.data.comment,
                                json_metadata: $scope.post.json_metadata
                              });
                              tr.add_type_operation("comment_options", {
                                allow_curation_rewards: true,
                                allow_votes: true,
                                author: $scope.post.author,
                                permlink: $scope.post.permlink,  
                                max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
                                percent_steem_dollars: 10000,
                                extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
                              });
                              //$rootScope.log(my_pubkeys);
                              localStorage.error = 0;
                              tr.process_transaction($scope.mylogin, null, true);

                              $scope.closeModal();
                              $scope.replying = false;
                              setTimeout(function() {
                                if (localStorage.error == 1) {
                                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                } else {
                                  $scope.data.comment = "";
                                  $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                  $rootScope.$broadcast("update:content");
                                }
                                $rootScope.$broadcast('hide:loading');
                              }, 3000);
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                            }
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                          }
                      }
                    $rootScope.$broadcast('hide:loading');
                  });
                }
                $scope.replyToComment = function(comment) {
                    $rootScope.log('reply to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, true);
                }
                $scope.editComment = function(comment) {
                    $rootScope.log('edit to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, false);
                }
                $scope.deleteComment = function(comment) {
                    $rootScope.log('delete to comment '+ angular.toJson(comment));
                    var confirmPopup = $ionicPopup.confirm({
                        title: $filter('translate')('ARE_YOU_SURE'),
                        template: $filter('translate')('DELETE_COMMENT')
                    });
                    confirmPopup.then(function(res) {
                        if(res) {
                            $rootScope.log('You are sure');
                            $rootScope.$broadcast('show:loading');
                            if ($rootScope.$storage.user) {
                              $scope.mylogin = new window.ejs.Login();
                              $scope.mylogin.setRoles(["posting"]);
                              var loginSuccess = $scope.mylogin.checkKeys({
                                  accountName: $rootScope.$storage.user.username,
                                  password: $rootScope.$storage.user.password || null,
                                  auths: {
                                      posting: $rootScope.$storage.user.posting.key_auths
                                  },
                                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                                }
                              );
                              if (loginSuccess) {
                                var tr = new window.ejs.TransactionBuilder();

                                tr.add_type_operation("delete_comment", {
                                  author: comment.author,
                                  permlink: comment.permlink
                                });
                                //$rootScope.log(my_pubkeys);
                                localStorage.error = 0;
                                tr.process_transaction($scope.mylogin, null, true);

                                setTimeout(function() {
                                  if (localStorage.error == 1) {
                                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                  } else {
                                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                                    $rootScope.$broadcast("update:content");
                                  }
                                  $rootScope.$broadcast('hide:loading');
                                }, 3000);
                              } else {
                                $rootScope.$broadcast('hide:loading');
                              }
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                            }
                        } else {
                          $rootScope.log('You are not sure');
                        }
                    });
                }
            }
        }
    }

    function ionThread() {
        return {
            restrict: 'E',
            scope: {
                comments: '='
            },
            //Replace ng-if="!comment.showChildren" with ng-if="comment.showChildren" to hide all child comments by default
            //Replace comment.data.replies.data.children according to the API you are using | orderBy:\'-net_votes\'
            template: '<script type="text/ng-template" id="node.html">\
                            <ion-comment comment="comment">\
                            </ion-comment>\
                            <div class="reddit-post--comment--container">\
                                 <ul ng-if="comment.showChildren" class="animate-if ion-comment--children">\
                                    <li ng-repeat="comment in comment.comments | orderBy:\'-pending_payout_value\' track by $index ">\
                                        <ng-include src="\'node.html\'"/>\
                                    </li>\
                                </ul>\
                            </div>\
                        </script>\
                        <ion-list ng-if="comments && comments.length > 0">\
                          <ul>\
                            <li ng-repeat="comment in comments | orderBy:\'-pending_payout_value\' track by $index">\
                                <ng-include src="\'node.html\'"/>\
                            </li>\
                          </ul>\
                        </ion-list>',
            controller: function($scope, $rootScope) {
                /*$scope.toggleComment = function(comment) {
                  //$rootScope.log('toggleComment');
                  if (comment.showChildren) {
                      comment.showChildren = false;
                  } else {
                      comment.showChildren = true;
                  }
                };*/
            }
        }
    }

    function ius($q, $ionicLoading, $cordovaFileTransfer, $ionicPlatform, $filter, $rootScope, API_END_POINT) {
        var service = {};
        service.uploadImage = uploadImage;
        return service;
        function uploadImage(imageURI) {
          var deferred = $q.defer();
          var fileSize;
          var percentage;
          /*if (ionic.Platform.isAndroid()) {
            if (imageURI.indexOf('file://')===-1) {
              imageURI="file://"+imageURI;
            }
          }*/
          // Find out how big the original file is
          window.resolveLocalFileSystemURL(imageURI, function(fileEntry) {
            fileEntry.file(function(fileObj) {
              fileSize = fileObj.size;
              // Display a loading indicator reporting the start of the upload
              $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + 0 + '%'});
              // Trigger the upload
              uploadFile();
            });
          });
          function uploadFile() {
            // Add the Cloudinary "upload preset" name to the headers
            // "https://api.cloudinary.com/v1_1/esteem/image/upload"
            var uploadOptions = {
              params : { 'username': $rootScope.$storage.user.username}
            };
            $ionicPlatform.ready(function() {
                $cordovaFileTransfer.upload(API_END_POINT+"/api/upload", imageURI, uploadOptions).then(function(result) {
                    // Let the user know the upload is completed
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_COMPLETED'), duration: 1000});
                    // Result has a "response" property that is escaped
                    // FYI: The result will also have URLs for any new images generated with
                    // eager transformations
                    var response = JSON.parse(decodeURIComponent(result.response));
                    deferred.resolve(response);
                  }, function(err) {
                    // Uh oh!
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_FAILED'), duration: 2000});
                    deferred.reject(err);
                  }, function (progress) {
                    // The upload plugin gives you information about how much data has been transferred
                    // on some interval.  Use this with the original file size to show a progress indicator.
                    percentage = Math.floor((progress.loaded / fileSize) * 100);
                    $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + percentage + '%'});
                  });
            });
          }
          return deferred.promise;
        }
    }

    app.factory('ImageUploadService', ius);

    app.constant('defaultSettings', {
        alphabetcolors: ["#5A8770", "#B2B7BB", "#6FA9AB", "#F5AF29", "#0088B9", "#F18636", "#D93A37", "#A6B12E", "#5C9BBC", "#F5888D", "#9A89B5", "#407887", "#9A89B5", "#5A8770", "#D33F33", "#A2B01F", "#F0B126", "#0087BF", "#F18636", "#0087BF", "#B2B7BB", "#72ACAE", "#9C8AB4", "#5A8770", "#EEB424", "#407887"],
        textColor: '#ffffff',
        defaultBorder: 'border:5px solid white',
        triangleup: 'width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid;',
        fontsize: 30, // unit in pixels
        height: 50, // unit in pixels
        width: 50, // unit in pixels
        fontWeight: 400, //
        charCount: 1,
        fontFamily: 'HelveticaNeue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial,Lucida Grande, sans-serif',
        base: 'data:image/svg+xml;base64,',
        radius: 'border-radius:50%;',
        custombgcolor: '',
        dynamic: 'false',
        rotatedeg: '0'
    });

    /**
     * directive to create the avatar
     * @param {type} param1
     * @param {type} param2
     */
    app.directive('ngLetterAvatar', ['defaultSettings', function (defaultSettings) {
        return {
            restrict: 'AE',
            replace: true,
            scope: {
                alphabetcolors: '=alphabetcolors',
                data: '@'
            },
            link: function (scope, element, attrs) {

                /**
                 * Populate the attribute values to params object
                 * @type type
                 */
                var params = {
                    charCount: attrs.charcount || defaultSettings.charCount,
                    data: attrs.data,
                    textColor: defaultSettings.textColor,
                    height: attrs.height || defaultSettings.height,
                    width: attrs.width || defaultSettings.width,
                    fontsize: attrs.fontsize || defaultSettings.fontsize,
                    fontWeight: attrs.fontweight || defaultSettings.fontWeight,
                    fontFamily: attrs.fontfamily || defaultSettings.fontFamily,
                    avatarBorderStyle: attrs.avatarcustomborder,
                    avatardefaultBorder: attrs.avatarborder,
                    defaultBorder: defaultSettings.defaultBorder,
                    shape: attrs.shape,
                    alphabetcolors: scope.alphabetcolors || defaultSettings.alphabetcolors,
                    avatarCustomBGColor: attrs.avatarcustombgcolor || defaultSettings.custombgcolor,
                    dynamic: attrs.dynamic || defaultSettings.dynamic,
                    rotatedeg: attrs.rotatedeg || defaultSettings.rotatedeg
                };

                /**
                 * to generate the avatar dynamically on data change, enable the below function to watch the event
                 */
                if (params.dynamic === 'true') {
                    scope.$watch('data', function () {
                        _generateLetterAvatar();
                    });
                } else {
                    _generateLetterAvatar();
                }

                function _generateLetterAvatar() {
                    var c = '';
                    if (params.charCount == 2) {
                        var _data = getFirstAndLastName(scope.data.toUpperCase());
                        if (_data) {
                            c = _data;
                        } else {
                            c = scope.data.substr(0, params.charCount).toUpperCase();
                        }
                    } else {
                        c = scope.data.substr(0, params.charCount).toUpperCase();
                    }
                    var cobj = getCharacterObject(c, params.textColor, params.fontFamily, params.fontWeight, params.fontsize);
                    var colorIndex = '';
                    var color = '';

                    /**
                     * Populate the colors according to attributes
                     */
                    if (c.charCodeAt(0) < 65) {
                        color = getRandomColors();
                    } else {
                        colorIndex = Math.floor((c.charCodeAt(0) - 65) % params.alphabetcolors.length);
                        color = params.alphabetcolors[colorIndex];
                    }

                    if (params.avatarCustomBGColor) {
                        color = params.avatarCustomBGColor;
                    }

                    var svg = getImgTag(params.width, params.height, color);
                    svg.append(cobj);
                    var lvcomponent = angular.element('<div>').append(svg.clone()).html();
                    var svgHtml = window.btoa(unescape(encodeURIComponent(lvcomponent)));
                    var component;
                    var base = defaultSettings.base;
                    var _style = '';
                    if (params.avatarBorderStyle) {
                        _style = params.avatarBorderStyle;
                    } else if (params.avatardefaultBorder) {
                        _style = params.defaultBorder;
                    }

                    if (params.rotatedeg != '0') {
                        _style = '-ms-transform: rotate(' + params.rotatedeg + 'deg); -webkit-transform: rotate(' + params.rotatedeg + 'deg); transform: rotate(' + params.rotatedeg + 'deg)';
                    }

                    if (params.shape) {
                        if (params.shape === 'round') {
                            var round_style = defaultSettings.radius + _style;
                            if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                                var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                                component = "<img src=" + scope.data + " style='" + img_size + round_style + "'  />";
                            } else {
                                component = "<img src=" + base + svgHtml + " style='" + round_style + "' title='" + scope.data + "' />";
                            }
                        }
                    } else {
                        if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                            var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                            component = "<img src=" + scope.data + " style='" + img_size + _style + "'  />";
                        } else {
                            component = "<img src=" + base + svgHtml + " style='" + _style + "' title='" + scope.data + "' />";
                        }
                    }

                    if (params.dynamic === 'true') {
                        element.empty();
                        element.append(component);
                    } else {
                        element.replaceWith(component);
                    }
                }
            }
        };
    }]);
    /**
     * Get the random colors
     * @returns {String}
     */
    function getRandomColors() {
        var letters = '0123456789ABCDEF'.split('');
        var _color = '#';
        for (var i = 0; i < 6; i++) {
            _color += letters[Math.floor(Math.random() * 16)];
        }
        return _color;
    }
    /**
     * get the first name and last name first letters and combined and form the letter avatar
     * @param {type} data
     * @returns {unresolved}
     */
    function getFirstAndLastName(data) {
        var names = data.split(" ");
        if (names && names.length >= 2) {
            var firstName = names[0];
            var lastName = names[1];
            if (firstName && lastName) {
                var text = firstName.substr(0, 1) + lastName.substr(0, 1);
                return text;
            } else {
                return data.substr(0, 2);
            }
        }
    }

    /**
     * Populate the svg tag which will used for the avatar generation
     * @param {type} width
     * @param {type} height
     * @param {type} color
     * @returns {unresolved}
     */
    function getImgTag(width, height, color) {

        var svgTag = angular.element('<svg></svg>')
                .attr({
                    'xmlns': 'http://www.w3.org/2000/svg',
                    'pointer-events': 'none',
                    'width': width,
                    'height': height
                })
                .css({
                    'background-color': color,
                    'width': width + 'px',
                    'height': height + 'px'
                });

        return svgTag;
    }

    /**
     *  Generate the Letter tag by using the svg text element
     * @param {type} character
     * @param {type} textColor
     * @param {type} fontFamily
     * @param {type} fontWeight
     * @param {type} fontsize
     * @returns {unresolved}
     */
    function getCharacterObject(character, textColor, fontFamily, fontWeight, fontsize) {
        var textTag = angular.element('<text text-anchor="middle"></text>')
                .attr({
                    'y': '50%',
                    'x': '50%',
                    'dy': '0.35em',
                    //'stroke': '#000000',
                    'pointer-events': 'auto',
                    'fill': textColor,
                    'font-family': fontFamily
                })
                .html(character)
                .css({
                    'font-weight': fontWeight,
                    'font-size': fontsize + 'px',
                });

        return textTag;
    }

}



}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/services.js","/posts")
},{"buffer":11,"pBGvAp":74}]},{},[100])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iYXNlLXgvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmlnaS9saWIvYmlnaS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9jb252ZXJ0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvcGFja2FnZS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvYnl0ZWJ1ZmZlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2hlbHBlcnMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1oZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXAvY3VycmVuY3ktc3ltYm9sLW1hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwL21hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9jdXJ2ZXMuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvbmFtZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9wb2ludC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpbkNvbmZpZy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpblZhbGlkYXRpb24uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9OdW1iZXJVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL09iamVjdElkLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25IZWxwZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9CcmFpbktleS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9LZXlVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9Qcml2YXRlS2V5LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL1B1YmxpY0tleS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9hZGRyZXNzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lY2RzYS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lY3NpZ25hdHVyZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lbmZvcmNlX3R5cGVzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2hhc2guanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvc2lnbmF0dXJlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvRmFzdFBhcnNlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL2Vycm9yX3dpdGhfY2F1c2UuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL251bWJlclV0aWxzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9vcGVyYXRpb25zLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvdHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9sb25nL2Rpc3QvbG9uZy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zZWN1cmUtcmFuZG9tL2xpYi9zZWN1cmUtcmFuZG9tLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9BcGlJbnN0YW5jZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL1N0ZWVtQXBpLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvV2ViU29ja2V0UnBjLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9yZWNvbm5lY3Rpbmctd2Vic29ja2V0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3Bhc3N0aHJvdWdoLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3JlYWRhYmxlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS93cml0YWJsZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL2Zha2VfOGI5NDk2MGUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvY29uZmlnLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2NvbnRyb2xsZXJzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvYXItU0EuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2JnLUJHLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9jcy1DWi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZGUtREUuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2RvbGFuLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9lbC1HUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZW4uanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2VzLUVTLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9mYS1JUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZmlsLVBILmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9mci1GUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvaGUtSUwuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2hyLUhSLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9odS1IVS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvaWQtSUQuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2l0LUlULmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9tcy1NWS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvbmwtTkwuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3BsLVBMLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9wdC1CUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvcHQtUFQuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3J1LVJVLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9zdi1TRS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvdWstVUEuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3poLUNOLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS96aC1UVy5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL3NlcnZpY2VzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNucEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2plQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmpJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9hc3NlcnRcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBiYXNlLXggZW5jb2Rpbmdcbi8vIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuLy8gT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuLy8gUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuLy8gTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICB2YXIgQUxQSEFCRVRfTUFQID0ge31cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuXG4gIC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgQUxQSEFCRVRfTUFQW0FMUEhBQkVULmNoYXJBdChpKV0gPSBpXG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm4gJydcblxuICAgIHZhciBkaWdpdHMgPSBbMF1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGNhcnJ5ID0gc291cmNlW2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4XG4gICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgQkFTRVxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpIHwgMFxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgQkFTRSlcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSB8IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgIGZvciAodmFyIGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgIGRpZ2l0cy5wdXNoKDApXG4gICAgfVxuXG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IgKHZhciBpaSA9IDAsIGpqID0gZGlnaXRzLmxlbmd0aCAtIDE7IGlpIDw9IGpqOyArK2lpLCAtLWpqKSB7XG4gICAgICB2YXIgdG1wID0gQUxQSEFCRVRbZGlnaXRzW2lpXV1cbiAgICAgIGRpZ2l0c1tpaV0gPSBBTFBIQUJFVFtkaWdpdHNbampdXVxuICAgICAgZGlnaXRzW2pqXSA9IHRtcFxuICAgIH1cblxuICAgIHJldHVybiBkaWdpdHMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBbXVxuXG4gICAgdmFyIGJ5dGVzID0gWzBdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IEFMUEhBQkVUX01BUFtzdHJpbmdbaV1dXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogQkFTRVxuICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZlxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKVxuICAgICAgICBjYXJyeSA+Pj0gOFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yICh2YXIgayA9IDA7IHN0cmluZ1trXSA9PT0gTEVBREVSICYmIGsgPCBzdHJpbmcubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICBieXRlcy5wdXNoKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzLnJldmVyc2UoKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jhc2UteC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iYXNlLXhcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsIGIsIGMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJpZ0ludGVnZXIpKVxuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhLCBiLCBjKVxuXG4gIGlmIChhICE9IG51bGwpIHtcbiAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsIGIsIGMpXG4gICAgZWxzZSBpZiAoYiA9PSBudWxsICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEpIHRoaXMuZnJvbVN0cmluZyhhLCAyNTYpXG4gICAgZWxzZSB0aGlzLmZyb21TdHJpbmcoYSwgYilcbiAgfVxufVxuXG52YXIgcHJvdG8gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZVxuXG4vLyBkdWNrLXR5cGVkIGlzQmlnSW50ZWdlclxucHJvdG8uX19iaWdpID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuQmlnSW50ZWdlci5pc0JpZ0ludGVnZXIgPSBmdW5jdGlvbiAob2JqLCBjaGVja192ZXIpIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19iaWdpICYmICghY2hlY2tfdmVyIHx8IG9iai5fX2JpZ2kgPT09IHByb3RvLl9fYmlnaSlcbn1cblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0c1xuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4ICogdGhpc1tpKytdICsgd1tqXSArIGNcbiAgICBjID0gTWF0aC5mbG9vcih2IC8gMHg0MDAwMDAwKVxuICAgIHdbaisrXSA9IHYgJiAweDNmZmZmZmZcbiAgfVxuICByZXR1cm4gY1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgdmFyIHhsID0geCAmIDB4N2ZmZixcbiAgICB4aCA9IHggPj4gMTVcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdmFyIGwgPSB0aGlzW2ldICYgMHg3ZmZmXG4gICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTVcbiAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bFxuICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDdmZmYpIDw8IDE1KSArIHdbal0gKyAoYyAmIDB4M2ZmZmZmZmYpXG4gICAgYyA9IChsID4+PiAzMCkgKyAobSA+Pj4gMTUpICsgeGggKiBoICsgKGMgPj4+IDMwKVxuICAgIHdbaisrXSA9IGwgJiAweDNmZmZmZmZmXG4gIH1cbiAgcmV0dXJuIGNcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgdmFyIHhsID0geCAmIDB4M2ZmZixcbiAgICB4aCA9IHggPj4gMTRcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdmFyIGwgPSB0aGlzW2ldICYgMHgzZmZmXG4gICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTRcbiAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bFxuICAgIGwgPSB4bCAqIGwgKyAoKG0gJiAweDNmZmYpIDw8IDE0KSArIHdbal0gKyBjXG4gICAgYyA9IChsID4+IDI4KSArIChtID4+IDE0KSArIHhoICogaFxuICAgIHdbaisrXSA9IGwgJiAweGZmZmZmZmZcbiAgfVxuICByZXR1cm4gY1xufVxuXG4vLyB3dGY/XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMVxuZGJpdHMgPSAyNlxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EQiA9IGRiaXRzXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMSA8PCBkYml0cykgLSAxKVxudmFyIERWID0gQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMSA8PCBkYml0cylcblxudmFyIEJJX0ZQID0gNTJcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMiwgQklfRlApXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQIC0gZGJpdHNcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYyID0gMiAqIGRiaXRzIC0gQklfRlBcblxuLy8gRGlnaXQgY29udmVyc2lvbnNcbnZhciBCSV9STSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCJcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpXG52YXIgcnIsIHZ2XG5yciA9IFwiMFwiLmNoYXJDb2RlQXQoMClcbmZvciAodnYgPSAwOyB2diA8PSA5OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2XG5yciA9IFwiYVwiLmNoYXJDb2RlQXQoMClcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2dlxucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApXG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnZcblxuZnVuY3Rpb24gaW50MmNoYXIobikge1xuICByZXR1cm4gQklfUk0uY2hhckF0KG4pXG59XG5cbmZ1bmN0aW9uIGludEF0KHMsIGkpIHtcbiAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldXG4gIHJldHVybiAoYyA9PSBudWxsKSA/IC0xIDogY1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSByW2ldID0gdGhpc1tpXVxuICByLnQgPSB0aGlzLnRcbiAgci5zID0gdGhpcy5zXG59XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIGludGVnZXIgdmFsdWUgeCwgLURWIDw9IHggPCBEVlxuZnVuY3Rpb24gYm5wRnJvbUludCh4KSB7XG4gIHRoaXMudCA9IDFcbiAgdGhpcy5zID0gKHggPCAwKSA/IC0xIDogMFxuICBpZiAoeCA+IDApIHRoaXNbMF0gPSB4XG4gIGVsc2UgaWYgKHggPCAtMSkgdGhpc1swXSA9IHggKyBEVlxuICBlbHNlIHRoaXMudCA9IDBcbn1cblxuLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuZnVuY3Rpb24gbmJ2KGkpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHIuZnJvbUludChpKVxuICByZXR1cm4gclxufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBzdHJpbmcgYW5kIHJhZGl4XG5mdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsIGIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGtcbiAgaWYgKGIgPT0gMTYpIGsgPSA0XG4gIGVsc2UgaWYgKGIgPT0gOCkgayA9IDNcbiAgZWxzZSBpZiAoYiA9PSAyNTYpIGsgPSA4OyAvLyBieXRlIGFycmF5XG4gIGVsc2UgaWYgKGIgPT0gMikgayA9IDFcbiAgZWxzZSBpZiAoYiA9PSAzMikgayA9IDVcbiAgZWxzZSBpZiAoYiA9PSA0KSBrID0gMlxuICBlbHNlIHtcbiAgICBzZWxmLmZyb21SYWRpeChzLCBiKVxuICAgIHJldHVyblxuICB9XG4gIHNlbGYudCA9IDBcbiAgc2VsZi5zID0gMFxuICB2YXIgaSA9IHMubGVuZ3RoLFxuICAgIG1pID0gZmFsc2UsXG4gICAgc2ggPSAwXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHZhciB4ID0gKGsgPT0gOCkgPyBzW2ldICYgMHhmZiA6IGludEF0KHMsIGkpXG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXCItXCIpIG1pID0gdHJ1ZVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgbWkgPSBmYWxzZVxuICAgIGlmIChzaCA9PSAwKVxuICAgICAgc2VsZltzZWxmLnQrK10gPSB4XG4gICAgZWxzZSBpZiAoc2ggKyBrID4gc2VsZi5EQikge1xuICAgICAgc2VsZltzZWxmLnQgLSAxXSB8PSAoeCAmICgoMSA8PCAoc2VsZi5EQiAtIHNoKSkgLSAxKSkgPDwgc2hcbiAgICAgIHNlbGZbc2VsZi50KytdID0gKHggPj4gKHNlbGYuREIgLSBzaCkpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmW3NlbGYudCAtIDFdIHw9IHggPDwgc2hcbiAgICBzaCArPSBrXG4gICAgaWYgKHNoID49IHNlbGYuREIpIHNoIC09IHNlbGYuREJcbiAgfVxuICBpZiAoayA9PSA4ICYmIChzWzBdICYgMHg4MCkgIT0gMCkge1xuICAgIHNlbGYucyA9IC0xXG4gICAgaWYgKHNoID4gMCkgc2VsZltzZWxmLnQgLSAxXSB8PSAoKDEgPDwgKHNlbGYuREIgLSBzaCkpIC0gMSkgPDwgc2hcbiAgfVxuICBzZWxmLmNsYW1wKClcbiAgaWYgKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8oc2VsZiwgc2VsZilcbn1cblxuLy8gKHByb3RlY3RlZCkgY2xhbXAgb2ZmIGV4Y2VzcyBoaWdoIHdvcmRzXG5mdW5jdGlvbiBibnBDbGFtcCgpIHtcbiAgdmFyIGMgPSB0aGlzLnMgJiB0aGlzLkRNXG4gIHdoaWxlICh0aGlzLnQgPiAwICYmIHRoaXNbdGhpcy50IC0gMV0gPT0gYyktLXRoaXMudFxufVxuXG4vLyAocHVibGljKSByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIGdpdmVuIHJhZGl4XG5mdW5jdGlvbiBiblRvU3RyaW5nKGIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLnMgPCAwKSByZXR1cm4gXCItXCIgKyBzZWxmLm5lZ2F0ZSgpXG4gICAgLnRvU3RyaW5nKGIpXG4gIHZhciBrXG4gIGlmIChiID09IDE2KSBrID0gNFxuICBlbHNlIGlmIChiID09IDgpIGsgPSAzXG4gIGVsc2UgaWYgKGIgPT0gMikgayA9IDFcbiAgZWxzZSBpZiAoYiA9PSAzMikgayA9IDVcbiAgZWxzZSBpZiAoYiA9PSA0KSBrID0gMlxuICBlbHNlIHJldHVybiBzZWxmLnRvUmFkaXgoYilcbiAgdmFyIGttID0gKDEgPDwgaykgLSAxLFxuICAgIGQsIG0gPSBmYWxzZSxcbiAgICByID0gXCJcIixcbiAgICBpID0gc2VsZi50XG4gIHZhciBwID0gc2VsZi5EQiAtIChpICogc2VsZi5EQikgJSBrXG4gIGlmIChpLS0gPiAwKSB7XG4gICAgaWYgKHAgPCBzZWxmLkRCICYmIChkID0gc2VsZltpXSA+PiBwKSA+IDApIHtcbiAgICAgIG0gPSB0cnVlXG4gICAgICByID0gaW50MmNoYXIoZClcbiAgICB9XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKHAgPCBrKSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoayAtIHApXG4gICAgICAgIGQgfD0gc2VsZlstLWldID4+IChwICs9IHNlbGYuREIgLSBrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9IChzZWxmW2ldID4+IChwIC09IGspKSAmIGttXG4gICAgICAgIGlmIChwIDw9IDApIHtcbiAgICAgICAgICBwICs9IHNlbGYuREJcbiAgICAgICAgICAtLWlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGQgPiAwKSBtID0gdHJ1ZVxuICAgICAgaWYgKG0pIHIgKz0gaW50MmNoYXIoZClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0gPyByIDogXCIwXCJcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHx0aGlzfFxuZnVuY3Rpb24gYm5BYnMoKSB7XG4gIHJldHVybiAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpc1xufVxuXG4vLyAocHVibGljKSByZXR1cm4gKyBpZiB0aGlzID4gYSwgLSBpZiB0aGlzIDwgYSwgMCBpZiBlcXVhbFxuZnVuY3Rpb24gYm5Db21wYXJlVG8oYSkge1xuICB2YXIgciA9IHRoaXMucyAtIGEuc1xuICBpZiAociAhPSAwKSByZXR1cm4gclxuICB2YXIgaSA9IHRoaXMudFxuICByID0gaSAtIGEudFxuICBpZiAociAhPSAwKSByZXR1cm4gKHRoaXMucyA8IDApID8gLXIgOiByXG4gIHdoaWxlICgtLWkgPj0gMClcbiAgICBpZiAoKHIgPSB0aGlzW2ldIC0gYVtpXSkgIT0gMCkgcmV0dXJuIHJcbiAgcmV0dXJuIDBcbn1cblxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbmZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgdmFyIHIgPSAxLFxuICAgIHRcbiAgaWYgKCh0ID0geCA+Pj4gMTYpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gMTZcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDgpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gOFxuICB9XG4gIGlmICgodCA9IHggPj4gNCkgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSA0XG4gIH1cbiAgaWYgKCh0ID0geCA+PiAyKSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDJcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDEpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gMVxuICB9XG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZiAodGhpcy50IDw9IDApIHJldHVybiAwXG4gIHJldHVybiB0aGlzLkRCICogKHRoaXMudCAtIDEpICsgbmJpdHModGhpc1t0aGlzLnQgLSAxXSBeICh0aGlzLnMgJiB0aGlzLkRNKSlcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQnl0ZUxlbmd0aCgpIHtcbiAgcmV0dXJuIHRoaXMuYml0TGVuZ3RoKCkgPj4gM1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuKkRCXG5mdW5jdGlvbiBibnBETFNoaWZ0VG8obiwgcikge1xuICB2YXIgaVxuICBmb3IgKGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkgcltpICsgbl0gPSB0aGlzW2ldXG4gIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkgcltpXSA9IDBcbiAgci50ID0gdGhpcy50ICsgblxuICByLnMgPSB0aGlzLnNcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gbipEQlxuZnVuY3Rpb24gYm5wRFJTaGlmdFRvKG4sIHIpIHtcbiAgZm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkgcltpIC0gbl0gPSB0aGlzW2ldXG4gIHIudCA9IE1hdGgubWF4KHRoaXMudCAtIG4sIDApXG4gIHIucyA9IHRoaXMuc1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuXG5mdW5jdGlvbiBibnBMU2hpZnRUbyhuLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYnMgPSBuICUgc2VsZi5EQlxuICB2YXIgY2JzID0gc2VsZi5EQiAtIGJzXG4gIHZhciBibSA9ICgxIDw8IGNicykgLSAxXG4gIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHNlbGYuREIpLFxuICAgIGMgPSAoc2VsZi5zIDw8IGJzKSAmIHNlbGYuRE0sXG4gICAgaVxuICBmb3IgKGkgPSBzZWxmLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgIHJbaSArIGRzICsgMV0gPSAoc2VsZltpXSA+PiBjYnMpIHwgY1xuICAgIGMgPSAoc2VsZltpXSAmIGJtKSA8PCBic1xuICB9XG4gIGZvciAoaSA9IGRzIC0gMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSAwXG4gIHJbZHNdID0gY1xuICByLnQgPSBzZWxmLnQgKyBkcyArIDFcbiAgci5zID0gc2VsZi5zXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuXG5mdW5jdGlvbiBibnBSU2hpZnRUbyhuLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByLnMgPSBzZWxmLnNcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gc2VsZi5EQilcbiAgaWYgKGRzID49IHNlbGYudCkge1xuICAgIHIudCA9IDBcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYnMgPSBuICUgc2VsZi5EQlxuICB2YXIgY2JzID0gc2VsZi5EQiAtIGJzXG4gIHZhciBibSA9ICgxIDw8IGJzKSAtIDFcbiAgclswXSA9IHNlbGZbZHNdID4+IGJzXG4gIGZvciAodmFyIGkgPSBkcyArIDE7IGkgPCBzZWxmLnQ7ICsraSkge1xuICAgIHJbaSAtIGRzIC0gMV0gfD0gKHNlbGZbaV0gJiBibSkgPDwgY2JzXG4gICAgcltpIC0gZHNdID0gc2VsZltpXSA+PiBic1xuICB9XG4gIGlmIChicyA+IDApIHJbc2VsZi50IC0gZHMgLSAxXSB8PSAoc2VsZi5zICYgYm0pIDw8IGNic1xuICByLnQgPSBzZWxmLnQgLSBkc1xuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgLSBhXG5mdW5jdGlvbiBibnBTdWJUbyhhLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaSA9IDAsXG4gICAgYyA9IDAsXG4gICAgbSA9IE1hdGgubWluKGEudCwgc2VsZi50KVxuICB3aGlsZSAoaSA8IG0pIHtcbiAgICBjICs9IHNlbGZbaV0gLSBhW2ldXG4gICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICBjID4+PSBzZWxmLkRCXG4gIH1cbiAgaWYgKGEudCA8IHNlbGYudCkge1xuICAgIGMgLT0gYS5zXG4gICAgd2hpbGUgKGkgPCBzZWxmLnQpIHtcbiAgICAgIGMgKz0gc2VsZltpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyArPSBzZWxmLnNcbiAgfSBlbHNlIHtcbiAgICBjICs9IHNlbGYuc1xuICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICBjIC09IGFbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgLT0gYS5zXG4gIH1cbiAgci5zID0gKGMgPCAwKSA/IC0xIDogMFxuICBpZiAoYyA8IC0xKSByW2krK10gPSBzZWxmLkRWICsgY1xuICBlbHNlIGlmIChjID4gMCkgcltpKytdID0gY1xuICByLnQgPSBpXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEsIHIpIHtcbiAgdmFyIHggPSB0aGlzLmFicygpLFxuICAgIHkgPSBhLmFicygpXG4gIHZhciBpID0geC50XG4gIHIudCA9IGkgKyB5LnRcbiAgd2hpbGUgKC0taSA+PSAwKSByW2ldID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgeS50OyArK2kpIHJbaSArIHgudF0gPSB4LmFtKDAsIHlbaV0sIHIsIGksIDAsIHgudClcbiAgci5zID0gMFxuICByLmNsYW1wKClcbiAgaWYgKHRoaXMucyAhPSBhLnMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLCByKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpc14yLCByICE9IHRoaXMgKEhBQyAxNC4xNilcbmZ1bmN0aW9uIGJucFNxdWFyZVRvKHIpIHtcbiAgdmFyIHggPSB0aGlzLmFicygpXG4gIHZhciBpID0gci50ID0gMiAqIHgudFxuICB3aGlsZSAoLS1pID49IDApIHJbaV0gPSAwXG4gIGZvciAoaSA9IDA7IGkgPCB4LnQgLSAxOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSwgeFtpXSwgciwgMiAqIGksIDAsIDEpXG4gICAgaWYgKChyW2kgKyB4LnRdICs9IHguYW0oaSArIDEsIDIgKiB4W2ldLCByLCAyICogaSArIDEsIGMsIHgudCAtIGkgLSAxKSkgPj0geC5EVikge1xuICAgICAgcltpICsgeC50XSAtPSB4LkRWXG4gICAgICByW2kgKyB4LnQgKyAxXSA9IDFcbiAgICB9XG4gIH1cbiAgaWYgKHIudCA+IDApIHJbci50IC0gMV0gKz0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSlcbiAgci5zID0gMFxuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgZGl2aWRlIHRoaXMgYnkgbSwgcXVvdGllbnQgYW5kIHJlbWFpbmRlciB0byBxLCByIChIQUMgMTQuMjApXG4vLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cbmZ1bmN0aW9uIGJucERpdlJlbVRvKG0sIHEsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwbSA9IG0uYWJzKClcbiAgaWYgKHBtLnQgPD0gMCkgcmV0dXJuXG4gIHZhciBwdCA9IHNlbGYuYWJzKClcbiAgaWYgKHB0LnQgPCBwbS50KSB7XG4gICAgaWYgKHEgIT0gbnVsbCkgcS5mcm9tSW50KDApXG4gICAgaWYgKHIgIT0gbnVsbCkgc2VsZi5jb3B5VG8ocilcbiAgICByZXR1cm5cbiAgfVxuICBpZiAociA9PSBudWxsKSByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgdHMgPSBzZWxmLnMsXG4gICAgbXMgPSBtLnNcbiAgdmFyIG5zaCA9IHNlbGYuREIgLSBuYml0cyhwbVtwbS50IC0gMV0pOyAvLyBub3JtYWxpemUgbW9kdWx1c1xuICBpZiAobnNoID4gMCkge1xuICAgIHBtLmxTaGlmdFRvKG5zaCwgeSlcbiAgICBwdC5sU2hpZnRUbyhuc2gsIHIpXG4gIH0gZWxzZSB7XG4gICAgcG0uY29weVRvKHkpXG4gICAgcHQuY29weVRvKHIpXG4gIH1cbiAgdmFyIHlzID0geS50XG4gIHZhciB5MCA9IHlbeXMgLSAxXVxuICBpZiAoeTAgPT0gMCkgcmV0dXJuXG4gIHZhciB5dCA9IHkwICogKDEgPDwgc2VsZi5GMSkgKyAoKHlzID4gMSkgPyB5W3lzIC0gMl0gPj4gc2VsZi5GMiA6IDApXG4gIHZhciBkMSA9IHNlbGYuRlYgLyB5dCxcbiAgICBkMiA9ICgxIDw8IHNlbGYuRjEpIC8geXQsXG4gICAgZSA9IDEgPDwgc2VsZi5GMlxuICB2YXIgaSA9IHIudCxcbiAgICBqID0gaSAtIHlzLFxuICAgIHQgPSAocSA9PSBudWxsKSA/IG5ldyBCaWdJbnRlZ2VyKCkgOiBxXG4gIHkuZGxTaGlmdFRvKGosIHQpXG4gIGlmIChyLmNvbXBhcmVUbyh0KSA+PSAwKSB7XG4gICAgcltyLnQrK10gPSAxXG4gICAgci5zdWJUbyh0LCByKVxuICB9XG4gIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbyh5cywgdClcbiAgdC5zdWJUbyh5LCB5KTsgLy8gXCJuZWdhdGl2ZVwiIHkgc28gd2UgY2FuIHJlcGxhY2Ugc3ViIHdpdGggYW0gbGF0ZXJcbiAgd2hpbGUgKHkudCA8IHlzKSB5W3kudCsrXSA9IDBcbiAgd2hpbGUgKC0taiA+PSAwKSB7XG4gICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICB2YXIgcWQgPSAoclstLWldID09IHkwKSA/IHNlbGYuRE0gOiBNYXRoLmZsb29yKHJbaV0gKiBkMSArIChyW2kgLSAxXSArIGUpICogZDIpXG4gICAgaWYgKChyW2ldICs9IHkuYW0oMCwgcWQsIHIsIGosIDAsIHlzKSkgPCBxZCkgeyAvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLCB0KVxuICAgICAgci5zdWJUbyh0LCByKVxuICAgICAgd2hpbGUgKHJbaV0gPCAtLXFkKSByLnN1YlRvKHQsIHIpXG4gICAgfVxuICB9XG4gIGlmIChxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cywgcSlcbiAgICBpZiAodHMgIT0gbXMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhxLCBxKVxuICB9XG4gIHIudCA9IHlzXG4gIHIuY2xhbXAoKVxuICBpZiAobnNoID4gMCkgci5yU2hpZnRUbyhuc2gsIHIpOyAvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYgKHRzIDwgMCkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbmZ1bmN0aW9uIGJuTW9kKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYWJzKClcbiAgICAuZGl2UmVtVG8oYSwgbnVsbCwgcilcbiAgaWYgKHRoaXMucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIGEuc3ViVG8ociwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHtcbiAgdGhpcy5tID0gbVxufVxuXG5mdW5jdGlvbiBjQ29udmVydCh4KSB7XG4gIGlmICh4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSlcbiAgZWxzZSByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHtcbiAgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gY1JlZHVjZSh4KSB7XG4gIHguZGl2UmVtVG8odGhpcy5tLCBudWxsLCB4KVxufVxuXG5mdW5jdGlvbiBjTXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuZnVuY3Rpb24gY1NxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5DbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gY0NvbnZlcnRcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnRcbkNsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGNSZWR1Y2VcbkNsYXNzaWMucHJvdG90eXBlLm11bFRvID0gY011bFRvXG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUb1xuXG4vLyAocHJvdGVjdGVkKSByZXR1cm4gXCItMS90aGlzICUgMl5EQlwiOyB1c2VmdWwgZm9yIE1vbnQuIHJlZHVjdGlvblxuLy8ganVzdGlmaWNhdGlvbjpcbi8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXG4vLyAgICAgICAgIHh5ID0gIDEra21cbi8vICAgeHkoMi14eSkgPSAoMStrbSkoMS1rbSlcbi8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxuLy8geFt5KDIteHkpXSA9PSAxIChtb2QgbV4yKVxuLy8gaWYgeSBpcyAxL3ggbW9kIG0sIHRoZW4geSgyLXh5KSBpcyAxL3ggbW9kIG1eMlxuLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXG4vLyBKUyBtdWx0aXBseSBcIm92ZXJmbG93c1wiIGRpZmZlcmVudGx5IGZyb20gQy9DKyssIHNvIGNhcmUgaXMgbmVlZGVkIGhlcmUuXG5mdW5jdGlvbiBibnBJbnZEaWdpdCgpIHtcbiAgaWYgKHRoaXMudCA8IDEpIHJldHVybiAwXG4gIHZhciB4ID0gdGhpc1swXVxuICBpZiAoKHggJiAxKSA9PSAwKSByZXR1cm4gMFxuICB2YXIgeSA9IHggJiAzOyAvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSAqICgyIC0gKHggJiAweGYpICogeSkpICYgMHhmOyAvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSAqICgyIC0gKHggJiAweGZmKSAqIHkpKSAmIDB4ZmY7IC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5ICogKDIgLSAoKCh4ICYgMHhmZmZmKSAqIHkpICYgMHhmZmZmKSkpICYgMHhmZmZmOyAvLyB5ID09IDEveCBtb2QgMl4xNlxuICAvLyBsYXN0IHN0ZXAgLSBjYWxjdWxhdGUgaW52ZXJzZSBtb2QgRFYgZGlyZWN0bHlcbiAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gIHkgPSAoeSAqICgyIC0geCAqIHkgJSB0aGlzLkRWKSkgJSB0aGlzLkRWOyAvLyB5ID09IDEveCBtb2QgMl5kYml0c1xuICAvLyB3ZSByZWFsbHkgd2FudCB0aGUgbmVnYXRpdmUgaW52ZXJzZSwgYW5kIC1EViA8IHkgPCBEVlxuICByZXR1cm4gKHkgPiAwKSA/IHRoaXMuRFYgLSB5IDogLXlcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtXG4gIHRoaXMubXAgPSBtLmludkRpZ2l0KClcbiAgdGhpcy5tcGwgPSB0aGlzLm1wICYgMHg3ZmZmXG4gIHRoaXMubXBoID0gdGhpcy5tcCA+PiAxNVxuICB0aGlzLnVtID0gKDEgPDwgKG0uREIgLSAxNSkpIC0gMVxuICB0aGlzLm10MiA9IDIgKiBtLnRcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHguYWJzKClcbiAgICAuZGxTaGlmdFRvKHRoaXMubS50LCByKVxuICByLmRpdlJlbVRvKHRoaXMubSwgbnVsbCwgcilcbiAgaWYgKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLCByKVxuICByZXR1cm4gclxufVxuXG4vLyB4L1IgbW9kIG1cbmZ1bmN0aW9uIG1vbnRSZXZlcnQoeCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgeC5jb3B5VG8ocilcbiAgdGhpcy5yZWR1Y2UocilcbiAgcmV0dXJuIHJcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlICh4LnQgPD0gdGhpcy5tdDIpIC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHhbeC50KytdID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geFtpXSptcCBtb2QgRFZcbiAgICB2YXIgaiA9IHhbaV0gJiAweDdmZmZcbiAgICB2YXIgdTAgPSAoaiAqIHRoaXMubXBsICsgKCgoaiAqIHRoaXMubXBoICsgKHhbaV0gPj4gMTUpICogdGhpcy5tcGwpICYgdGhpcy51bSkgPDwgMTUpKSAmIHguRE1cbiAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcbiAgICBqID0gaSArIHRoaXMubS50XG4gICAgeFtqXSArPSB0aGlzLm0uYW0oMCwgdTAsIHgsIGksIDAsIHRoaXMubS50KVxuICAgIC8vIHByb3BhZ2F0ZSBjYXJyeVxuICAgIHdoaWxlICh4W2pdID49IHguRFYpIHtcbiAgICAgIHhbal0gLT0geC5EVlxuICAgICAgeFsrK2pdKytcbiAgICB9XG4gIH1cbiAgeC5jbGFtcCgpXG4gIHguZHJTaGlmdFRvKHRoaXMubS50LCB4KVxuICBpZiAoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSwgeClcbn1cblxuLy8gciA9IFwieF4yL1IgbW9kIG1cIjsgeCAhPSByXG5mdW5jdGlvbiBtb250U3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbi8vIHIgPSBcInh5L1IgbW9kIG1cIjsgeCx5ICE9IHJcbmZ1bmN0aW9uIG1vbnRNdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnRcbk1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IG1vbnRSZXZlcnRcbk1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2Vcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IG1vbnRTcXJUb1xuXG4vLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cbmZ1bmN0aW9uIGJucElzRXZlbigpIHtcbiAgcmV0dXJuICgodGhpcy50ID4gMCkgPyAodGhpc1swXSAmIDEpIDogdGhpcy5zKSA9PSAwXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXCJyXCIgKEhBQyAxNC43OSlcbmZ1bmN0aW9uIGJucEV4cChlLCB6KSB7XG4gIGlmIChlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FXG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICByMiA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgZyA9IHouY29udmVydCh0aGlzKSxcbiAgICBpID0gbmJpdHMoZSkgLSAxXG4gIGcuY29weVRvKHIpXG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHouc3FyVG8ociwgcjIpXG4gICAgaWYgKChlICYgKDEgPDwgaSkpID4gMCkgei5tdWxUbyhyMiwgZywgcilcbiAgICBlbHNlIHtcbiAgICAgIHZhciB0ID0gclxuICAgICAgciA9IHIyXG4gICAgICByMiA9IHRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpXG59XG5cbi8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbmZ1bmN0aW9uIGJuTW9kUG93SW50KGUsIG0pIHtcbiAgdmFyIHpcbiAgaWYgKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pXG4gIGVsc2UgeiA9IG5ldyBNb250Z29tZXJ5KG0pXG4gIHJldHVybiB0aGlzLmV4cChlLCB6KVxufVxuXG4vLyBwcm90ZWN0ZWRcbnByb3RvLmNvcHlUbyA9IGJucENvcHlUb1xucHJvdG8uZnJvbUludCA9IGJucEZyb21JbnRcbnByb3RvLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nXG5wcm90by5jbGFtcCA9IGJucENsYW1wXG5wcm90by5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG9cbnByb3RvLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUb1xucHJvdG8ubFNoaWZ0VG8gPSBibnBMU2hpZnRUb1xucHJvdG8uclNoaWZ0VG8gPSBibnBSU2hpZnRUb1xucHJvdG8uc3ViVG8gPSBibnBTdWJUb1xucHJvdG8ubXVsdGlwbHlUbyA9IGJucE11bHRpcGx5VG9cbnByb3RvLnNxdWFyZVRvID0gYm5wU3F1YXJlVG9cbnByb3RvLmRpdlJlbVRvID0gYm5wRGl2UmVtVG9cbnByb3RvLmludkRpZ2l0ID0gYm5wSW52RGlnaXRcbnByb3RvLmlzRXZlbiA9IGJucElzRXZlblxucHJvdG8uZXhwID0gYm5wRXhwXG5cbi8vIHB1YmxpY1xucHJvdG8udG9TdHJpbmcgPSBiblRvU3RyaW5nXG5wcm90by5uZWdhdGUgPSBibk5lZ2F0ZVxucHJvdG8uYWJzID0gYm5BYnNcbnByb3RvLmNvbXBhcmVUbyA9IGJuQ29tcGFyZVRvXG5wcm90by5iaXRMZW5ndGggPSBibkJpdExlbmd0aFxucHJvdG8uYnl0ZUxlbmd0aCA9IGJuQnl0ZUxlbmd0aFxucHJvdG8ubW9kID0gYm5Nb2RcbnByb3RvLm1vZFBvd0ludCA9IGJuTW9kUG93SW50XG5cbi8vIChwdWJsaWMpXG5mdW5jdGlvbiBibkNsb25lKCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5jb3B5VG8ocilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbmZ1bmN0aW9uIGJuSW50VmFsdWUoKSB7XG4gIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgaWYgKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpc1swXSAtIHRoaXMuRFZcbiAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkgcmV0dXJuIC0xXG4gIH0gZWxzZSBpZiAodGhpcy50ID09IDEpIHJldHVybiB0aGlzWzBdXG4gIGVsc2UgaWYgKHRoaXMudCA9PSAwKSByZXR1cm4gMFxuICAvLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxuICByZXR1cm4gKCh0aGlzWzFdICYgKCgxIDw8ICgzMiAtIHRoaXMuREIpKSAtIDEpKSA8PCB0aGlzLkRCKSB8IHRoaXNbMF1cbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbmZ1bmN0aW9uIGJuQnl0ZVZhbHVlKCkge1xuICByZXR1cm4gKHRoaXMudCA9PSAwKSA/IHRoaXMucyA6ICh0aGlzWzBdIDw8IDI0KSA+PiAyNFxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuZnVuY3Rpb24gYm5TaG9ydFZhbHVlKCkge1xuICByZXR1cm4gKHRoaXMudCA9PSAwKSA/IHRoaXMucyA6ICh0aGlzWzBdIDw8IDE2KSA+PiAxNlxufVxuXG4vLyAocHJvdGVjdGVkKSByZXR1cm4geCBzLnQuIHJeeCA8IERWXG5mdW5jdGlvbiBibnBDaHVua1NpemUocikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMiAqIHRoaXMuREIgLyBNYXRoLmxvZyhyKSlcbn1cblxuLy8gKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuICBpZiAodGhpcy5zIDwgMCkgcmV0dXJuIC0xXG4gIGVsc2UgaWYgKHRoaXMudCA8PSAwIHx8ICh0aGlzLnQgPT0gMSAmJiB0aGlzWzBdIDw9IDApKSByZXR1cm4gMFxuICBlbHNlIHJldHVybiAxXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgdG8gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBUb1JhZGl4KGIpIHtcbiAgaWYgKGIgPT0gbnVsbCkgYiA9IDEwXG4gIGlmICh0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCJcbiAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYilcbiAgdmFyIGEgPSBNYXRoLnBvdyhiLCBjcylcbiAgdmFyIGQgPSBuYnYoYSksXG4gICAgeSA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgeiA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgciA9IFwiXCJcbiAgdGhpcy5kaXZSZW1UbyhkLCB5LCB6KVxuICB3aGlsZSAoeS5zaWdudW0oKSA+IDApIHtcbiAgICByID0gKGEgKyB6LmludFZhbHVlKCkpXG4gICAgICAudG9TdHJpbmcoYilcbiAgICAgIC5zdWJzdHIoMSkgKyByXG4gICAgeS5kaXZSZW1UbyhkLCB5LCB6KVxuICB9XG4gIHJldHVybiB6LmludFZhbHVlKClcbiAgICAudG9TdHJpbmcoYikgKyByXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgZnJvbSByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucEZyb21SYWRpeChzLCBiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmZyb21JbnQoMClcbiAgaWYgKGIgPT0gbnVsbCkgYiA9IDEwXG4gIHZhciBjcyA9IHNlbGYuY2h1bmtTaXplKGIpXG4gIHZhciBkID0gTWF0aC5wb3coYiwgY3MpLFxuICAgIG1pID0gZmFsc2UsXG4gICAgaiA9IDAsXG4gICAgdyA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHggPSBpbnRBdChzLCBpKVxuICAgIGlmICh4IDwgMCkge1xuICAgICAgaWYgKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHNlbGYuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB3ID0gYiAqIHcgKyB4XG4gICAgaWYgKCsraiA+PSBjcykge1xuICAgICAgc2VsZi5kTXVsdGlwbHkoZClcbiAgICAgIHNlbGYuZEFkZE9mZnNldCh3LCAwKVxuICAgICAgaiA9IDBcbiAgICAgIHcgPSAwXG4gICAgfVxuICB9XG4gIGlmIChqID4gMCkge1xuICAgIHNlbGYuZE11bHRpcGx5KE1hdGgucG93KGIsIGopKVxuICAgIHNlbGYuZEFkZE9mZnNldCh3LCAwKVxuICB9XG4gIGlmIChtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHNlbGYsIHNlbGYpXG59XG5cbi8vIChwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gYm5wRnJvbU51bWJlcihhLCBiLCBjKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuICAgIGlmIChhIDwgMikgc2VsZi5mcm9tSW50KDEpXG4gICAgZWxzZSB7XG4gICAgICBzZWxmLmZyb21OdW1iZXIoYSwgYylcbiAgICAgIGlmICghc2VsZi50ZXN0Qml0KGEgLSAxKSkgLy8gZm9yY2UgTVNCIHNldFxuICAgICAgICBzZWxmLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBvcF9vciwgc2VsZilcbiAgICAgIGlmIChzZWxmLmlzRXZlbigpKSBzZWxmLmRBZGRPZmZzZXQoMSwgMCk7IC8vIGZvcmNlIG9kZFxuICAgICAgd2hpbGUgKCFzZWxmLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICBzZWxmLmRBZGRPZmZzZXQoMiwgMClcbiAgICAgICAgaWYgKHNlbGYuYml0TGVuZ3RoKCkgPiBhKSBzZWxmLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIHNlbGYpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gICAgdmFyIHggPSBuZXcgQXJyYXkoKSxcbiAgICAgIHQgPSBhICYgN1xuICAgIHgubGVuZ3RoID0gKGEgPj4gMykgKyAxXG4gICAgYi5uZXh0Qnl0ZXMoeClcbiAgICBpZiAodCA+IDApIHhbMF0gJj0gKCgxIDw8IHQpIC0gMSlcbiAgICBlbHNlIHhbMF0gPSAwXG4gICAgc2VsZi5mcm9tU3RyaW5nKHgsIDI1NilcbiAgfVxufVxuXG4vLyAocHVibGljKSBjb252ZXJ0IHRvIGJpZ2VuZGlhbiBieXRlIGFycmF5XG5mdW5jdGlvbiBiblRvQnl0ZUFycmF5KCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGkgPSBzZWxmLnQsXG4gICAgciA9IG5ldyBBcnJheSgpXG4gIHJbMF0gPSBzZWxmLnNcbiAgdmFyIHAgPSBzZWxmLkRCIC0gKGkgKiBzZWxmLkRCKSAlIDgsXG4gICAgZCwgayA9IDBcbiAgaWYgKGktLSA+IDApIHtcbiAgICBpZiAocCA8IHNlbGYuREIgJiYgKGQgPSBzZWxmW2ldID4+IHApICE9IChzZWxmLnMgJiBzZWxmLkRNKSA+PiBwKVxuICAgICAgcltrKytdID0gZCB8IChzZWxmLnMgPDwgKHNlbGYuREIgLSBwKSlcbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICBpZiAocCA8IDgpIHtcbiAgICAgICAgZCA9IChzZWxmW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8ICg4IC0gcClcbiAgICAgICAgZCB8PSBzZWxmWy0taV0gPj4gKHAgKz0gc2VsZi5EQiAtIDgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gKHNlbGZbaV0gPj4gKHAgLT0gOCkpICYgMHhmZlxuICAgICAgICBpZiAocCA8PSAwKSB7XG4gICAgICAgICAgcCArPSBzZWxmLkRCXG4gICAgICAgICAgLS1pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoZCAmIDB4ODApICE9IDApIGQgfD0gLTI1NlxuICAgICAgaWYgKGsgPT09IDAgJiYgKHNlbGYucyAmIDB4ODApICE9IChkICYgMHg4MCkpKytrXG4gICAgICBpZiAoayA+IDAgfHwgZCAhPSBzZWxmLnMpIHJbaysrXSA9IGRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuZnVuY3Rpb24gYm5FcXVhbHMoYSkge1xuICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID09IDApXG59XG5cbmZ1bmN0aW9uIGJuTWluKGEpIHtcbiAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA8IDApID8gdGhpcyA6IGFcbn1cblxuZnVuY3Rpb24gYm5NYXgoYSkge1xuICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpID4gMCkgPyB0aGlzIDogYVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsIG9wLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaSwgZiwgbSA9IE1hdGgubWluKGEudCwgc2VsZi50KVxuICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSByW2ldID0gb3Aoc2VsZltpXSwgYVtpXSlcbiAgaWYgKGEudCA8IHNlbGYudCkge1xuICAgIGYgPSBhLnMgJiBzZWxmLkRNXG4gICAgZm9yIChpID0gbTsgaSA8IHNlbGYudDsgKytpKSByW2ldID0gb3Aoc2VsZltpXSwgZilcbiAgICByLnQgPSBzZWxmLnRcbiAgfSBlbHNlIHtcbiAgICBmID0gc2VsZi5zICYgc2VsZi5ETVxuICAgIGZvciAoaSA9IG07IGkgPCBhLnQ7ICsraSkgcltpXSA9IG9wKGYsIGFbaV0pXG4gICAgci50ID0gYS50XG4gIH1cbiAgci5zID0gb3Aoc2VsZi5zLCBhLnMpXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHVibGljKSB0aGlzICYgYVxuZnVuY3Rpb24gb3BfYW5kKHgsIHkpIHtcbiAgcmV0dXJuIHggJiB5XG59XG5cbmZ1bmN0aW9uIGJuQW5kKGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgsIHkpIHtcbiAgcmV0dXJuIHggfCB5XG59XG5cbmZ1bmN0aW9uIGJuT3IoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5iaXR3aXNlVG8oYSwgb3Bfb3IsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgXiBhXG5mdW5jdGlvbiBvcF94b3IoeCwgeSkge1xuICByZXR1cm4geCBeIHlcbn1cblxuZnVuY3Rpb24gYm5Yb3IoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfeG9yLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzICYgfmFcbmZ1bmN0aW9uIG9wX2FuZG5vdCh4LCB5KSB7XG4gIHJldHVybiB4ICYgfnlcbn1cblxuZnVuY3Rpb24gYm5BbmROb3QoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kbm90LCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByW2ldID0gdGhpcy5ETSAmIH50aGlzW2ldXG4gIHIudCA9IHRoaXMudFxuICByLnMgPSB+dGhpcy5zXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgPDwgblxuZnVuY3Rpb24gYm5TaGlmdExlZnQobikge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgaWYgKG4gPCAwKSB0aGlzLnJTaGlmdFRvKC1uLCByKVxuICBlbHNlIHRoaXMubFNoaWZ0VG8obiwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgaWYgKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLCByKVxuICBlbHNlIHRoaXMuclNoaWZ0VG8obiwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gcmV0dXJuIGluZGV4IG9mIGxvd2VzdCAxLWJpdCBpbiB4LCB4IDwgMl4zMVxuZnVuY3Rpb24gbGJpdCh4KSB7XG4gIGlmICh4ID09IDApIHJldHVybiAtMVxuICB2YXIgciA9IDBcbiAgaWYgKCh4ICYgMHhmZmZmKSA9PSAwKSB7XG4gICAgeCA+Pj0gMTZcbiAgICByICs9IDE2XG4gIH1cbiAgaWYgKCh4ICYgMHhmZikgPT0gMCkge1xuICAgIHggPj49IDhcbiAgICByICs9IDhcbiAgfVxuICBpZiAoKHggJiAweGYpID09IDApIHtcbiAgICB4ID4+PSA0XG4gICAgciArPSA0XG4gIH1cbiAgaWYgKCh4ICYgMykgPT0gMCkge1xuICAgIHggPj49IDJcbiAgICByICs9IDJcbiAgfVxuICBpZiAoKHggJiAxKSA9PSAwKSsrclxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm5zIGluZGV4IG9mIGxvd2VzdCAxLWJpdCAob3IgLTEgaWYgbm9uZSlcbmZ1bmN0aW9uIGJuR2V0TG93ZXN0U2V0Qml0KCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKVxuICAgIGlmICh0aGlzW2ldICE9IDApIHJldHVybiBpICogdGhpcy5EQiArIGxiaXQodGhpc1tpXSlcbiAgaWYgKHRoaXMucyA8IDApIHJldHVybiB0aGlzLnQgKiB0aGlzLkRCXG4gIHJldHVybiAtMVxufVxuXG4vLyByZXR1cm4gbnVtYmVyIG9mIDEgYml0cyBpbiB4XG5mdW5jdGlvbiBjYml0KHgpIHtcbiAgdmFyIHIgPSAwXG4gIHdoaWxlICh4ICE9IDApIHtcbiAgICB4ICY9IHggLSAxXG4gICAgKytyXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbiAgdmFyIHIgPSAwLFxuICAgIHggPSB0aGlzLnMgJiB0aGlzLkRNXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHIgKz0gY2JpdCh0aGlzW2ldIF4geClcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG4gIHZhciBqID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQilcbiAgaWYgKGogPj0gdGhpcy50KSByZXR1cm4gKHRoaXMucyAhPSAwKVxuICByZXR1cm4gKCh0aGlzW2pdICYgKDEgPDwgKG4gJSB0aGlzLkRCKSkpICE9IDApXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG5mdW5jdGlvbiBibnBDaGFuZ2VCaXQobiwgb3ApIHtcbiAgdmFyIHIgPSBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQobilcbiAgdGhpcy5iaXR3aXNlVG8ociwgb3AsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX29yKVxufVxuXG4vLyAocHVibGljKSB0aGlzICYgfigxPDxuKVxuZnVuY3Rpb24gYm5DbGVhckJpdChuKSB7XG4gIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF9hbmRub3QpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgXiAoMTw8bilcbmZ1bmN0aW9uIGJuRmxpcEJpdChuKSB7XG4gIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF94b3IpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgaSA9IDAsXG4gICAgYyA9IDAsXG4gICAgbSA9IE1hdGgubWluKGEudCwgc2VsZi50KVxuICB3aGlsZSAoaSA8IG0pIHtcbiAgICBjICs9IHNlbGZbaV0gKyBhW2ldXG4gICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICBjID4+PSBzZWxmLkRCXG4gIH1cbiAgaWYgKGEudCA8IHNlbGYudCkge1xuICAgIGMgKz0gYS5zXG4gICAgd2hpbGUgKGkgPCBzZWxmLnQpIHtcbiAgICAgIGMgKz0gc2VsZltpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyArPSBzZWxmLnNcbiAgfSBlbHNlIHtcbiAgICBjICs9IHNlbGYuc1xuICAgIHdoaWxlIChpIDwgYS50KSB7XG4gICAgICBjICs9IGFbaV1cbiAgICAgIHJbaSsrXSA9IGMgJiBzZWxmLkRNXG4gICAgICBjID4+PSBzZWxmLkRCXG4gICAgfVxuICAgIGMgKz0gYS5zXG4gIH1cbiAgci5zID0gKGMgPCAwKSA/IC0xIDogMFxuICBpZiAoYyA+IDApIHJbaSsrXSA9IGNcbiAgZWxzZSBpZiAoYyA8IC0xKSByW2krK10gPSBzZWxmLkRWICsgY1xuICByLnQgPSBpXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHVibGljKSB0aGlzICsgYVxuZnVuY3Rpb24gYm5BZGQoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5hZGRUbyhhLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5TdWJ0cmFjdChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLnN1YlRvKGEsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMubXVsdGlwbHlUbyhhLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzXjJcbmZ1bmN0aW9uIGJuU3F1YXJlKCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5zcXVhcmVUbyhyKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIC8gYVxuZnVuY3Rpb24gYm5EaXZpZGUoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5kaXZSZW1UbyhhLCByLCBudWxsKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzICUgYVxuZnVuY3Rpb24gYm5SZW1haW5kZXIoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5kaXZSZW1UbyhhLCBudWxsLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSBbdGhpcy9hLHRoaXMlYV1cbmZ1bmN0aW9uIGJuRGl2aWRlQW5kUmVtYWluZGVyKGEpIHtcbiAgdmFyIHEgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuZGl2UmVtVG8oYSwgcSwgcilcbiAgcmV0dXJuIG5ldyBBcnJheShxLCByKVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbiAgdGhpc1t0aGlzLnRdID0gdGhpcy5hbSgwLCBuIC0gMSwgdGhpcywgMCwgMCwgdGhpcy50KVxuICArK3RoaXMudFxuICB0aGlzLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLCB3KSB7XG4gIGlmIChuID09IDApIHJldHVyblxuICB3aGlsZSAodGhpcy50IDw9IHcpIHRoaXNbdGhpcy50KytdID0gMFxuICB0aGlzW3ddICs9IG5cbiAgd2hpbGUgKHRoaXNbd10gPj0gdGhpcy5EVikge1xuICAgIHRoaXNbd10gLT0gdGhpcy5EVlxuICAgIGlmICgrK3cgPj0gdGhpcy50KSB0aGlzW3RoaXMudCsrXSA9IDBcbiAgICArK3RoaXNbd11cbiAgfVxufVxuXG4vLyBBIFwibnVsbFwiIHJlZHVjZXJcbmZ1bmN0aW9uIE51bGxFeHAoKSB7fVxuXG5mdW5jdGlvbiBuTm9wKHgpIHtcbiAgcmV0dXJuIHhcbn1cblxuZnVuY3Rpb24gbk11bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG59XG5cbmZ1bmN0aW9uIG5TcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbn1cblxuTnVsbEV4cC5wcm90b3R5cGUuY29udmVydCA9IG5Ob3Bcbk51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3Bcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvXG5OdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IG5TcXJUb1xuXG4vLyAocHVibGljKSB0aGlzXmVcbmZ1bmN0aW9uIGJuUG93KGUpIHtcbiAgcmV0dXJuIHRoaXMuZXhwKGUsIG5ldyBOdWxsRXhwKCkpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSBsb3dlciBuIHdvcmRzIG9mIFwidGhpcyAqIGFcIiwgYS50IDw9IG5cbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5TG93ZXJUbyhhLCBuLCByKSB7XG4gIHZhciBpID0gTWF0aC5taW4odGhpcy50ICsgYS50LCBuKVxuICByLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG4gIHIudCA9IGlcbiAgd2hpbGUgKGkgPiAwKSByWy0taV0gPSAwXG4gIHZhciBqXG4gIGZvciAoaiA9IHIudCAtIHRoaXMudDsgaSA8IGo7ICsraSkgcltpICsgdGhpcy50XSA9IHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgdGhpcy50KVxuICBmb3IgKGogPSBNYXRoLm1pbihhLnQsIG4pOyBpIDwgajsgKytpKSB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIG4gLSBpKVxuICByLmNsYW1wKClcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IFwidGhpcyAqIGFcIiB3aXRob3V0IGxvd2VyIG4gd29yZHMsIG4gPiAwXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSwgbiwgcikge1xuICAtLW5cbiAgdmFyIGkgPSByLnQgPSB0aGlzLnQgKyBhLnQgLSBuXG4gIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgd2hpbGUgKC0taSA+PSAwKSByW2ldID0gMFxuICBmb3IgKGkgPSBNYXRoLm1heChuIC0gdGhpcy50LCAwKTsgaSA8IGEudDsgKytpKVxuICAgIHJbdGhpcy50ICsgaSAtIG5dID0gdGhpcy5hbShuIC0gaSwgYVtpXSwgciwgMCwgMCwgdGhpcy50ICsgaSAtIG4pXG4gIHIuY2xhbXAoKVxuICByLmRyU2hpZnRUbygxLCByKVxufVxuXG4vLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbiAgLy8gc2V0dXAgQmFycmV0dFxuICB0aGlzLnIyID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLnEzID0gbmV3IEJpZ0ludGVnZXIoKVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiAqIG0udCwgdGhpcy5yMilcbiAgdGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pXG4gIHRoaXMubSA9IG1cbn1cblxuZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCkge1xuICBpZiAoeC5zIDwgMCB8fCB4LnQgPiAyICogdGhpcy5tLnQpIHJldHVybiB4Lm1vZCh0aGlzLm0pXG4gIGVsc2UgaWYgKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geFxuICBlbHNlIHtcbiAgICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgICB4LmNvcHlUbyhyKVxuICAgIHRoaXMucmVkdWNlKHIpXG4gICAgcmV0dXJuIHJcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpIHtcbiAgcmV0dXJuIHhcbn1cblxuLy8geCA9IHggbW9kIG0gKEhBQyAxNC40MilcbmZ1bmN0aW9uIGJhcnJldHRSZWR1Y2UoeCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgeC5kclNoaWZ0VG8oc2VsZi5tLnQgLSAxLCBzZWxmLnIyKVxuICBpZiAoeC50ID4gc2VsZi5tLnQgKyAxKSB7XG4gICAgeC50ID0gc2VsZi5tLnQgKyAxXG4gICAgeC5jbGFtcCgpXG4gIH1cbiAgc2VsZi5tdS5tdWx0aXBseVVwcGVyVG8oc2VsZi5yMiwgc2VsZi5tLnQgKyAxLCBzZWxmLnEzKVxuICBzZWxmLm0ubXVsdGlwbHlMb3dlclRvKHNlbGYucTMsIHNlbGYubS50ICsgMSwgc2VsZi5yMilcbiAgd2hpbGUgKHguY29tcGFyZVRvKHNlbGYucjIpIDwgMCkgeC5kQWRkT2Zmc2V0KDEsIHNlbGYubS50ICsgMSlcbiAgeC5zdWJUbyhzZWxmLnIyLCB4KVxuICB3aGlsZSAoeC5jb21wYXJlVG8oc2VsZi5tKSA+PSAwKSB4LnN1YlRvKHNlbGYubSwgeClcbn1cblxuLy8gciA9IHheMiBtb2QgbTsgeCAhPSByXG5mdW5jdGlvbiBiYXJyZXR0U3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbi8vIHIgPSB4KnkgbW9kIG07IHgseSAhPSByXG5mdW5jdGlvbiBiYXJyZXR0TXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0XG5CYXJyZXR0LnByb3RvdHlwZS5yZWR1Y2UgPSBiYXJyZXR0UmVkdWNlXG5CYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUb1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG9cblxuLy8gKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSwgbSkge1xuICB2YXIgaSA9IGUuYml0TGVuZ3RoKCksXG4gICAgaywgciA9IG5idigxKSxcbiAgICB6XG4gIGlmIChpIDw9IDApIHJldHVybiByXG4gIGVsc2UgaWYgKGkgPCAxOCkgayA9IDFcbiAgZWxzZSBpZiAoaSA8IDQ4KSBrID0gM1xuICBlbHNlIGlmIChpIDwgMTQ0KSBrID0gNFxuICBlbHNlIGlmIChpIDwgNzY4KSBrID0gNVxuICBlbHNlIGsgPSA2XG4gIGlmIChpIDwgOClcbiAgICB6ID0gbmV3IENsYXNzaWMobSlcbiAgZWxzZSBpZiAobS5pc0V2ZW4oKSlcbiAgICB6ID0gbmV3IEJhcnJldHQobSlcbiAgZWxzZVxuICAgIHogPSBuZXcgTW9udGdvbWVyeShtKVxuXG4gIC8vIHByZWNvbXB1dGF0aW9uXG4gIHZhciBnID0gbmV3IEFycmF5KCksXG4gICAgbiA9IDMsXG4gICAgazEgPSBrIC0gMSxcbiAgICBrbSA9ICgxIDw8IGspIC0gMVxuICBnWzFdID0gei5jb252ZXJ0KHRoaXMpXG4gIGlmIChrID4gMSkge1xuICAgIHZhciBnMiA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgICB6LnNxclRvKGdbMV0sIGcyKVxuICAgIHdoaWxlIChuIDw9IGttKSB7XG4gICAgICBnW25dID0gbmV3IEJpZ0ludGVnZXIoKVxuICAgICAgei5tdWxUbyhnMiwgZ1tuIC0gMl0sIGdbbl0pXG4gICAgICBuICs9IDJcbiAgICB9XG4gIH1cblxuICB2YXIgaiA9IGUudCAtIDEsXG4gICAgdywgaXMxID0gdHJ1ZSxcbiAgICByMiA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgdFxuICBpID0gbmJpdHMoZVtqXSkgLSAxXG4gIHdoaWxlIChqID49IDApIHtcbiAgICBpZiAoaSA+PSBrMSkgdyA9IChlW2pdID4+IChpIC0gazEpKSAmIGttXG4gICAgZWxzZSB7XG4gICAgICB3ID0gKGVbal0gJiAoKDEgPDwgKGkgKyAxKSkgLSAxKSkgPDwgKGsxIC0gaSlcbiAgICAgIGlmIChqID4gMCkgdyB8PSBlW2ogLSAxXSA+PiAodGhpcy5EQiArIGkgLSBrMSlcbiAgICB9XG5cbiAgICBuID0ga1xuICAgIHdoaWxlICgodyAmIDEpID09IDApIHtcbiAgICAgIHcgPj49IDFcbiAgICAgIC0tblxuICAgIH1cbiAgICBpZiAoKGkgLT0gbikgPCAwKSB7XG4gICAgICBpICs9IHRoaXMuREJcbiAgICAgIC0talxuICAgIH1cbiAgICBpZiAoaXMxKSB7IC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgICAgIGdbd10uY29weVRvKHIpXG4gICAgICBpczEgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgei5zcXJUbyhyLCByMilcbiAgICAgICAgei5zcXJUbyhyMiwgcilcbiAgICAgICAgbiAtPSAyXG4gICAgICB9XG4gICAgICBpZiAobiA+IDApIHouc3FyVG8ociwgcjIpXG4gICAgICBlbHNlIHtcbiAgICAgICAgdCA9IHJcbiAgICAgICAgciA9IHIyXG4gICAgICAgIHIyID0gdFxuICAgICAgfVxuICAgICAgei5tdWxUbyhyMiwgZ1t3XSwgcilcbiAgICB9XG5cbiAgICB3aGlsZSAoaiA+PSAwICYmIChlW2pdICYgKDEgPDwgaSkpID09IDApIHtcbiAgICAgIHouc3FyVG8ociwgcjIpXG4gICAgICB0ID0gclxuICAgICAgciA9IHIyXG4gICAgICByMiA9IHRcbiAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgIGkgPSB0aGlzLkRCIC0gMVxuICAgICAgICAtLWpcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpXG59XG5cbi8vIChwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG5mdW5jdGlvbiBibkdDRChhKSB7XG4gIHZhciB4ID0gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXMuY2xvbmUoKVxuICB2YXIgeSA9IChhLnMgPCAwKSA/IGEubmVnYXRlKCkgOiBhLmNsb25lKClcbiAgaWYgKHguY29tcGFyZVRvKHkpIDwgMCkge1xuICAgIHZhciB0ID0geFxuICAgIHggPSB5XG4gICAgeSA9IHRcbiAgfVxuICB2YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksXG4gICAgZyA9IHkuZ2V0TG93ZXN0U2V0Qml0KClcbiAgaWYgKGcgPCAwKSByZXR1cm4geFxuICBpZiAoaSA8IGcpIGcgPSBpXG4gIGlmIChnID4gMCkge1xuICAgIHguclNoaWZ0VG8oZywgeClcbiAgICB5LnJTaGlmdFRvKGcsIHkpXG4gIH1cbiAgd2hpbGUgKHguc2lnbnVtKCkgPiAwKSB7XG4gICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB4LnJTaGlmdFRvKGksIHgpXG4gICAgaWYgKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGksIHkpXG4gICAgaWYgKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgICAgIHguc3ViVG8oeSwgeClcbiAgICAgIHguclNoaWZ0VG8oMSwgeClcbiAgICB9IGVsc2Uge1xuICAgICAgeS5zdWJUbyh4LCB5KVxuICAgICAgeS5yU2hpZnRUbygxLCB5KVxuICAgIH1cbiAgfVxuICBpZiAoZyA+IDApIHkubFNoaWZ0VG8oZywgeSlcbiAgcmV0dXJuIHlcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG5mdW5jdGlvbiBibnBNb2RJbnQobikge1xuICBpZiAobiA8PSAwKSByZXR1cm4gMFxuICB2YXIgZCA9IHRoaXMuRFYgJSBuLFxuICAgIHIgPSAodGhpcy5zIDwgMCkgPyBuIC0gMSA6IDBcbiAgaWYgKHRoaXMudCA+IDApXG4gICAgaWYgKGQgPT0gMCkgciA9IHRoaXNbMF0gJSBuXG4gICAgZWxzZVxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSByID0gKGQgKiByICsgdGhpc1tpXSkgJSBuXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIDEvdGhpcyAlIG0gKEhBQyAxNC42MSlcbmZ1bmN0aW9uIGJuTW9kSW52ZXJzZShtKSB7XG4gIHZhciBhYyA9IG0uaXNFdmVuKClcbiAgaWYgKHRoaXMuc2lnbnVtKCkgPT09IDApIHRocm93IG5ldyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG4gIGlmICgodGhpcy5pc0V2ZW4oKSAmJiBhYykgfHwgbS5zaWdudW0oKSA9PSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPXG4gIHZhciB1ID0gbS5jbG9uZSgpLFxuICAgIHYgPSB0aGlzLmNsb25lKClcbiAgdmFyIGEgPSBuYnYoMSksXG4gICAgYiA9IG5idigwKSxcbiAgICBjID0gbmJ2KDApLFxuICAgIGQgPSBuYnYoMSlcbiAgd2hpbGUgKHUuc2lnbnVtKCkgIT0gMCkge1xuICAgIHdoaWxlICh1LmlzRXZlbigpKSB7XG4gICAgICB1LnJTaGlmdFRvKDEsIHUpXG4gICAgICBpZiAoYWMpIHtcbiAgICAgICAgaWYgKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7XG4gICAgICAgICAgYS5hZGRUbyh0aGlzLCBhKVxuICAgICAgICAgIGIuc3ViVG8obSwgYilcbiAgICAgICAgfVxuICAgICAgICBhLnJTaGlmdFRvKDEsIGEpXG4gICAgICB9IGVsc2UgaWYgKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sIGIpXG4gICAgICBiLnJTaGlmdFRvKDEsIGIpXG4gICAgfVxuICAgIHdoaWxlICh2LmlzRXZlbigpKSB7XG4gICAgICB2LnJTaGlmdFRvKDEsIHYpXG4gICAgICBpZiAoYWMpIHtcbiAgICAgICAgaWYgKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7XG4gICAgICAgICAgYy5hZGRUbyh0aGlzLCBjKVxuICAgICAgICAgIGQuc3ViVG8obSwgZClcbiAgICAgICAgfVxuICAgICAgICBjLnJTaGlmdFRvKDEsIGMpXG4gICAgICB9IGVsc2UgaWYgKCFkLmlzRXZlbigpKSBkLnN1YlRvKG0sIGQpXG4gICAgICBkLnJTaGlmdFRvKDEsIGQpXG4gICAgfVxuICAgIGlmICh1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICAgICB1LnN1YlRvKHYsIHUpXG4gICAgICBpZiAoYWMpIGEuc3ViVG8oYywgYSlcbiAgICAgIGIuc3ViVG8oZCwgYilcbiAgICB9IGVsc2Uge1xuICAgICAgdi5zdWJUbyh1LCB2KVxuICAgICAgaWYgKGFjKSBjLnN1YlRvKGEsIGMpXG4gICAgICBkLnN1YlRvKGIsIGQpXG4gICAgfVxuICB9XG4gIGlmICh2LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVST1xuICB3aGlsZSAoZC5jb21wYXJlVG8obSkgPj0gMCkgZC5zdWJUbyhtLCBkKVxuICB3aGlsZSAoZC5zaWdudW0oKSA8IDApIGQuYWRkVG8obSwgZClcbiAgcmV0dXJuIGRcbn1cblxudmFyIGxvd3ByaW1lcyA9IFtcbiAgMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOSwgMzEsIDM3LCA0MSwgNDMsIDQ3LCA1MywgNTksIDYxLCA2NywgNzEsXG4gIDczLCA3OSwgODMsIDg5LCA5NywgMTAxLCAxMDMsIDEwNywgMTA5LCAxMTMsIDEyNywgMTMxLCAxMzcsIDEzOSwgMTQ5LCAxNTEsXG4gIDE1NywgMTYzLCAxNjcsIDE3MywgMTc5LCAxODEsIDE5MSwgMTkzLCAxOTcsIDE5OSwgMjExLCAyMjMsIDIyNywgMjI5LCAyMzMsXG4gIDIzOSwgMjQxLCAyNTEsIDI1NywgMjYzLCAyNjksIDI3MSwgMjc3LCAyODEsIDI4MywgMjkzLCAzMDcsIDMxMSwgMzEzLCAzMTcsXG4gIDMzMSwgMzM3LCAzNDcsIDM0OSwgMzUzLCAzNTksIDM2NywgMzczLCAzNzksIDM4MywgMzg5LCAzOTcsIDQwMSwgNDA5LCA0MTksXG4gIDQyMSwgNDMxLCA0MzMsIDQzOSwgNDQzLCA0NDksIDQ1NywgNDYxLCA0NjMsIDQ2NywgNDc5LCA0ODcsIDQ5MSwgNDk5LCA1MDMsXG4gIDUwOSwgNTIxLCA1MjMsIDU0MSwgNTQ3LCA1NTcsIDU2MywgNTY5LCA1NzEsIDU3NywgNTg3LCA1OTMsIDU5OSwgNjAxLCA2MDcsXG4gIDYxMywgNjE3LCA2MTksIDYzMSwgNjQxLCA2NDMsIDY0NywgNjUzLCA2NTksIDY2MSwgNjczLCA2NzcsIDY4MywgNjkxLCA3MDEsXG4gIDcwOSwgNzE5LCA3MjcsIDczMywgNzM5LCA3NDMsIDc1MSwgNzU3LCA3NjEsIDc2OSwgNzczLCA3ODcsIDc5NywgODA5LCA4MTEsXG4gIDgyMSwgODIzLCA4MjcsIDgyOSwgODM5LCA4NTMsIDg1NywgODU5LCA4NjMsIDg3NywgODgxLCA4ODMsIDg4NywgOTA3LCA5MTEsXG4gIDkxOSwgOTI5LCA5MzcsIDk0MSwgOTQ3LCA5NTMsIDk2NywgOTcxLCA5NzcsIDk4MywgOTkxLCA5OTdcbl1cblxudmFyIGxwbGltID0gKDEgPDwgMjYpIC8gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXVxuXG4vLyAocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbmZ1bmN0aW9uIGJuSXNQcm9iYWJsZVByaW1lKHQpIHtcbiAgdmFyIGksIHggPSB0aGlzLmFicygpXG4gIGlmICh4LnQgPT0gMSAmJiB4WzBdIDw9IGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoIC0gMV0pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKVxuICAgICAgaWYgKHhbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICh4LmlzRXZlbigpKSByZXR1cm4gZmFsc2VcbiAgaSA9IDFcbiAgd2hpbGUgKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gICAgdmFyIG0gPSBsb3dwcmltZXNbaV0sXG4gICAgICBqID0gaSArIDFcbiAgICB3aGlsZSAoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdXG4gICAgbSA9IHgubW9kSW50KG0pXG4gICAgd2hpbGUgKGkgPCBqKSBpZiAobSAlIGxvd3ByaW1lc1tpKytdID09IDApIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB4Lm1pbGxlclJhYmluKHQpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWYgcHJvYmFibHkgcHJpbWUgKEhBQyA0LjI0LCBNaWxsZXItUmFiaW4pXG5mdW5jdGlvbiBibnBNaWxsZXJSYWJpbih0KSB7XG4gIHZhciBuMSA9IHRoaXMuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpXG4gIHZhciBrID0gbjEuZ2V0TG93ZXN0U2V0Qml0KClcbiAgaWYgKGsgPD0gMCkgcmV0dXJuIGZhbHNlXG4gIHZhciByID0gbjEuc2hpZnRSaWdodChrKVxuICB0ID0gKHQgKyAxKSA+PiAxXG4gIGlmICh0ID4gbG93cHJpbWVzLmxlbmd0aCkgdCA9IGxvd3ByaW1lcy5sZW5ndGhcbiAgdmFyIGEgPSBuZXcgQmlnSW50ZWdlcihudWxsKVxuICB2YXIgaiwgYmFzZXMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGogPSBsb3dwcmltZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbG93cHJpbWVzLmxlbmd0aCldXG4gICAgICBpZiAoYmFzZXMuaW5kZXhPZihqKSA9PSAtMSkgYnJlYWtcbiAgICB9XG4gICAgYmFzZXMucHVzaChqKVxuICAgIGEuZnJvbUludChqKVxuICAgIHZhciB5ID0gYS5tb2RQb3cociwgdGhpcylcbiAgICBpZiAoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgIHZhciBqID0gMVxuICAgICAgd2hpbGUgKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgeSA9IHkubW9kUG93SW50KDIsIHRoaXMpXG4gICAgICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAoeS5jb21wYXJlVG8objEpICE9IDApIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBwcm90ZWN0ZWRcbnByb3RvLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZVxucHJvdG8udG9SYWRpeCA9IGJucFRvUmFkaXhcbnByb3RvLmZyb21SYWRpeCA9IGJucEZyb21SYWRpeFxucHJvdG8uZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXJcbnByb3RvLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUb1xucHJvdG8uY2hhbmdlQml0ID0gYm5wQ2hhbmdlQml0XG5wcm90by5hZGRUbyA9IGJucEFkZFRvXG5wcm90by5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHlcbnByb3RvLmRBZGRPZmZzZXQgPSBibnBEQWRkT2Zmc2V0XG5wcm90by5tdWx0aXBseUxvd2VyVG8gPSBibnBNdWx0aXBseUxvd2VyVG9cbnByb3RvLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUb1xucHJvdG8ubW9kSW50ID0gYm5wTW9kSW50XG5wcm90by5taWxsZXJSYWJpbiA9IGJucE1pbGxlclJhYmluXG5cbi8vIHB1YmxpY1xucHJvdG8uY2xvbmUgPSBibkNsb25lXG5wcm90by5pbnRWYWx1ZSA9IGJuSW50VmFsdWVcbnByb3RvLmJ5dGVWYWx1ZSA9IGJuQnl0ZVZhbHVlXG5wcm90by5zaG9ydFZhbHVlID0gYm5TaG9ydFZhbHVlXG5wcm90by5zaWdudW0gPSBiblNpZ051bVxucHJvdG8udG9CeXRlQXJyYXkgPSBiblRvQnl0ZUFycmF5XG5wcm90by5lcXVhbHMgPSBibkVxdWFsc1xucHJvdG8ubWluID0gYm5NaW5cbnByb3RvLm1heCA9IGJuTWF4XG5wcm90by5hbmQgPSBibkFuZFxucHJvdG8ub3IgPSBibk9yXG5wcm90by54b3IgPSBiblhvclxucHJvdG8uYW5kTm90ID0gYm5BbmROb3RcbnByb3RvLm5vdCA9IGJuTm90XG5wcm90by5zaGlmdExlZnQgPSBiblNoaWZ0TGVmdFxucHJvdG8uc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodFxucHJvdG8uZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXRcbnByb3RvLmJpdENvdW50ID0gYm5CaXRDb3VudFxucHJvdG8udGVzdEJpdCA9IGJuVGVzdEJpdFxucHJvdG8uc2V0Qml0ID0gYm5TZXRCaXRcbnByb3RvLmNsZWFyQml0ID0gYm5DbGVhckJpdFxucHJvdG8uZmxpcEJpdCA9IGJuRmxpcEJpdFxucHJvdG8uYWRkID0gYm5BZGRcbnByb3RvLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdFxucHJvdG8ubXVsdGlwbHkgPSBibk11bHRpcGx5XG5wcm90by5kaXZpZGUgPSBibkRpdmlkZVxucHJvdG8ucmVtYWluZGVyID0gYm5SZW1haW5kZXJcbnByb3RvLmRpdmlkZUFuZFJlbWFpbmRlciA9IGJuRGl2aWRlQW5kUmVtYWluZGVyXG5wcm90by5tb2RQb3cgPSBibk1vZFBvd1xucHJvdG8ubW9kSW52ZXJzZSA9IGJuTW9kSW52ZXJzZVxucHJvdG8ucG93ID0gYm5Qb3dcbnByb3RvLmdjZCA9IGJuR0NEXG5wcm90by5pc1Byb2JhYmxlUHJpbWUgPSBibklzUHJvYmFibGVQcmltZVxuXG4vLyBKU0JOLXNwZWNpZmljIGV4dGVuc2lvblxucHJvdG8uc3F1YXJlID0gYm5TcXVhcmVcblxuLy8gY29uc3RhbnRzXG5CaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMClcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpXG5CaWdJbnRlZ2VyLnZhbHVlT2YgPSBuYnZcblxubW9kdWxlLmV4cG9ydHMgPSBCaWdJbnRlZ2VyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2JpZ2kuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBGSVhNRTogS2luZCBvZiBhIHdlaXJkIHdheSB0byB0aHJvdyBleGNlcHRpb25zLCBjb25zaWRlciByZW1vdmluZ1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJy4vYmlnaScpXG5cbi8qKlxuICogVHVybnMgYSBieXRlIGFycmF5IGludG8gYSBiaWcgaW50ZWdlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgaW50ZXJwcmV0IGEgYnl0ZSBhcnJheSBhcyBhIGJpZyBpbnRlZ2VyIGluIGJpZ1xuICogZW5kaWFuIG5vdGF0aW9uLlxuICovXG5CaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZCA9IGZ1bmN0aW9uKGJ5dGVBcnJheSkge1xuICAvLyBCaWdJbnRlZ2VyIGV4cGVjdHMgYSBERVIgaW50ZWdlciBjb25mb3JtYW50IGJ5dGUgYXJyYXlcbiAgaWYgKGJ5dGVBcnJheVswXSAmIDB4ODApIHtcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoWzBdLmNvbmNhdChieXRlQXJyYXkpKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJ5dGVBcnJheSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYnl0ZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnIGludGVnZXIuXG4gKlxuICogVGhpcyByZXR1cm5zIHRoZSBhYnNvbHV0ZSBvZiB0aGUgY29udGFpbmVkIHZhbHVlIGluIGJpZyBlbmRpYW5cbiAqIGZvcm0uIEEgdmFsdWUgb2YgemVybyByZXN1bHRzIGluIGFuIGVtcHR5IGFycmF5LlxuICovXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheVVuc2lnbmVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBieXRlQXJyYXkgPSB0aGlzLnRvQnl0ZUFycmF5KClcbiAgcmV0dXJuIGJ5dGVBcnJheVswXSA9PT0gMCA/IGJ5dGVBcnJheS5zbGljZSgxKSA6IGJ5dGVBcnJheVxufVxuXG5CaWdJbnRlZ2VyLmZyb21ERVJJbnRlZ2VyID0gZnVuY3Rpb24oYnl0ZUFycmF5KSB7XG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihieXRlQXJyYXkpXG59XG5cbi8qXG4gKiBDb252ZXJ0cyBCaWdJbnRlZ2VyIHRvIGEgREVSIGludGVnZXIgcmVwcmVzZW50YXRpb24uXG4gKlxuICogVGhlIGZvcm1hdCBmb3IgdGhpcyB2YWx1ZSB1c2VzIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBhcyBhIHNpZ25cbiAqIGJpdC4gIElmIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyBhbHJlYWR5IHNldCBhbmQgdGhlIGludGVnZXIgaXNcbiAqIHBvc2l0aXZlLCBhIDB4MDAgaXMgcHJlcGVuZGVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgMCA9PiAgICAgMHgwMFxuICogICAgICAxID0+ICAgICAweDAxXG4gKiAgICAgLTEgPT4gICAgIDB4ZmZcbiAqICAgIDEyNyA9PiAgICAgMHg3ZlxuICogICAtMTI3ID0+ICAgICAweDgxXG4gKiAgICAxMjggPT4gICAweDAwODBcbiAqICAgLTEyOCA9PiAgICAgMHg4MFxuICogICAgMjU1ID0+ICAgMHgwMGZmXG4gKiAgIC0yNTUgPT4gICAweGZmMDFcbiAqICAxNjMwMCA9PiAgIDB4M2ZhY1xuICogLTE2MzAwID0+ICAgMHhjMDU0XG4gKiAgNjIzMDAgPT4gMHgwMGYzNWNcbiAqIC02MjMwMCA9PiAweGZmMGNhNFxuKi9cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvREVSSW50ZWdlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5XG5cbkJpZ0ludGVnZXIuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBCaWdJbnRlZ2VyIGV4cGVjdHMgYSBERVIgaW50ZWdlciBjb25mb3JtYW50IGJ5dGUgYXJyYXlcbiAgaWYgKGJ1ZmZlclswXSAmIDB4ODApIHtcbiAgICB2YXIgYnl0ZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnVmZmVyKVxuXG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXS5jb25jYXQoYnl0ZUFycmF5KSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihidWZmZXIpXG59XG5cbkJpZ0ludGVnZXIuZnJvbUhleCA9IGZ1bmN0aW9uKGhleCkge1xuICBpZiAoaGV4ID09PSAnJykgcmV0dXJuIEJpZ0ludGVnZXIuWkVST1xuXG4gIGFzc2VydC5lcXVhbChoZXgsIGhleC5tYXRjaCgvXltBLUZhLWYwLTldKy8pLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgYXNzZXJ0LmVxdWFsKGhleC5sZW5ndGggJSAyLCAwLCAnSW5jb21wbGV0ZSBoZXgnKVxuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoaGV4LCAxNilcbn1cblxuQmlnSW50ZWdlci5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbihzaXplKSB7XG4gIHZhciBieXRlQXJyYXkgPSB0aGlzLnRvQnl0ZUFycmF5VW5zaWduZWQoKVxuICB2YXIgemVyb3MgPSBbXVxuXG4gIHZhciBwYWRkaW5nID0gc2l6ZSAtIGJ5dGVBcnJheS5sZW5ndGhcbiAgd2hpbGUgKHplcm9zLmxlbmd0aCA8IHBhZGRpbmcpIHplcm9zLnB1c2goMClcblxuICByZXR1cm4gbmV3IEJ1ZmZlcih6ZXJvcy5jb25jYXQoYnl0ZUFycmF5KSlcbn1cblxuQmlnSW50ZWdlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihzaXplKSB7XG4gIHJldHVybiB0aGlzLnRvQnVmZmVyKHNpemUpLnRvU3RyaW5nKCdoZXgnKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9jb252ZXJ0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCcuL2JpZ2knKVxuXG4vL2FkZG9uc1xucmVxdWlyZSgnLi9jb252ZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBCaWdJbnRlZ2VyXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYlwiKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAge1xuICAgICAgICBcInJhd1wiOiBcImJpZ2lAXjEuNC4yXCIsXG4gICAgICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICAgICAgXCJlc2NhcGVkTmFtZVwiOiBcImJpZ2lcIixcbiAgICAgICAgXCJuYW1lXCI6IFwiYmlnaVwiLFxuICAgICAgICBcInJhd1NwZWNcIjogXCJeMS40LjJcIixcbiAgICAgICAgXCJzcGVjXCI6IFwiPj0xLjQuMiA8Mi4wLjBcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwicmFuZ2VcIlxuICAgICAgfSxcbiAgICAgIFwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtYXV0aFwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwiYmlnaUA+PTEuNC4yIDwyLjAuMFwiLFxuICBcIl9pZFwiOiBcImJpZ2lAMS40LjJcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi9iaWdpXCIsXG4gIFwiX25vZGVWZXJzaW9uXCI6IFwiNi4xLjBcIixcbiAgXCJfbnBtT3BlcmF0aW9uYWxJbnRlcm5hbFwiOiB7XG4gICAgXCJob3N0XCI6IFwicGFja2FnZXMtMTItd2VzdC5pbnRlcm5hbC5ucG1qcy5jb21cIixcbiAgICBcInRtcFwiOiBcInRtcC9iaWdpLTEuNC4yLnRnel8xNDY5NTg0MTkyNDEzXzAuNjgwMTIzODYxMTgwNjE4NFwiXG4gIH0sXG4gIFwiX25wbVVzZXJcIjoge1xuICAgIFwibmFtZVwiOiBcImpwcmljaGFyZHNvblwiLFxuICAgIFwiZW1haWxcIjogXCJqcHJpY2hhcmRzb25AZ21haWwuY29tXCJcbiAgfSxcbiAgXCJfbnBtVmVyc2lvblwiOiBcIjMuOC42XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInJhd1wiOiBcImJpZ2lAXjEuNC4yXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwiZXNjYXBlZE5hbWVcIjogXCJiaWdpXCIsXG4gICAgXCJuYW1lXCI6IFwiYmlnaVwiLFxuICAgIFwicmF3U3BlY1wiOiBcIl4xLjQuMlwiLFxuICAgIFwic3BlY1wiOiBcIj49MS40LjIgPDIuMC4wXCIsXG4gICAgXCJ0eXBlXCI6IFwicmFuZ2VcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9lY3VydmVcIixcbiAgICBcIi9zdGVlbWF1dGhcIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2JpZ2kvLS9iaWdpLTEuNC4yLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCI5YzY2NWE5NWY4OGI4YjA4ZmMwNWNmZDczMWY1NjE4NTlkNzI1ODI1XCIsXG4gIFwiX3Nocmlua3dyYXBcIjogbnVsbCxcbiAgXCJfc3BlY1wiOiBcImJpZ2lAXjEuNC4yXCIsXG4gIFwiX3doZXJlXCI6IFwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtYXV0aFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQmlnIGludGVnZXJzLlwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjb3ZlcmFsbHNcIjogXCJeMi4xMS4yXCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcIl4wLjMuNVwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuNS4xXCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjEuMFwiLFxuICAgIFwibW9jaGlmeVwiOiBcIl4yLjEuMFwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge30sXG4gIFwiZGlzdFwiOiB7XG4gICAgXCJzaGFzdW1cIjogXCI5YzY2NWE5NWY4OGI4YjA4ZmMwNWNmZDczMWY1NjE4NTlkNzI1ODI1XCIsXG4gICAgXCJ0YXJiYWxsXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvYmlnaS8tL2JpZ2ktMS40LjIudGd6XCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiYzI1MzA4MDgxYzg5NmZmODQ3MDIzMDM3MjJiZjVlY2Q4YjNmNzhlM1wiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpI3JlYWRtZVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImNyeXB0b2dyYXBoeVwiLFxuICAgIFwibWF0aFwiLFxuICAgIFwiYml0Y29pblwiLFxuICAgIFwiYXJiaXRyYXJ5XCIsXG4gICAgXCJwcmVjaXNpb25cIixcbiAgICBcImFyaXRobWV0aWNcIixcbiAgICBcImJpZ1wiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiaW50XCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImJpZ2ludGVnZXJcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwiYmlnbnVtYmVyXCIsXG4gICAgXCJkZWNpbWFsXCIsXG4gICAgXCJmbG9hdFwiXG4gIF0sXG4gIFwibWFpblwiOiBcIi4vbGliL2luZGV4LmpzXCIsXG4gIFwibWFpbnRhaW5lcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIm1pZG5pZ2h0bGlnaHRuaW5nXCIsXG4gICAgICBcImVtYWlsXCI6IFwiYm95ZGJAbWlkbmlnaHRkZXNpZ24ud3NcIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwic2lkYXpoYW5nXCIsXG4gICAgICBcImVtYWlsXCI6IFwic2lkYXpoYW5nODlAZ21haWwuY29tXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIm5hZGF2XCIsXG4gICAgICBcImVtYWlsXCI6IFwibnBtQHNoZXNlay5pbmZvXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImpwcmljaGFyZHNvblwiLFxuICAgICAgXCJlbWFpbFwiOiBcImpwcmljaGFyZHNvbkBnbWFpbC5jb21cIlxuICAgIH1cbiAgXSxcbiAgXCJuYW1lXCI6IFwiYmlnaVwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kuZ2l0XCIsXG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJyb3dzZXItdGVzdFwiOiBcIm1vY2hpZnkgLS13ZCAtUiBzcGVjXCIsXG4gICAgXCJjb3ZlcmFnZVwiOiBcImlzdGFuYnVsIGNvdmVyIC4vbm9kZV9tb2R1bGVzLy5iaW4vX21vY2hhIC0tIC0tcmVwb3J0ZXIgbGlzdCB0ZXN0LyouanNcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcIm5wbSBydW4tc2NyaXB0IGNvdmVyYWdlICYmIG5vZGUgLi9ub2RlX21vZHVsZXMvLmJpbi9jb3ZlcmFsbHMgPCBjb3ZlcmFnZS9sY292LmluZm9cIixcbiAgICBcImpzaGludFwiOiBcImpzaGludCAtLWNvbmZpZyBqc2hpbnQuanNvbiBsaWIvKi5qcyA7IHRydWVcIixcbiAgICBcInRlc3RcIjogXCJfbW9jaGEgLS0gdGVzdC8qLmpzXCIsXG4gICAgXCJ1bml0XCI6IFwibW9jaGFcIlxuICB9LFxuICBcInRlc3RsaW5nXCI6IHtcbiAgICBcImZpbGVzXCI6IFwidGVzdC8qLmpzXCIsXG4gICAgXCJoYXJuZXNzXCI6IFwibW9jaGFcIixcbiAgICBcImJyb3dzZXJzXCI6IFtcbiAgICAgIFwiaWUvOS4ubGF0ZXN0XCIsXG4gICAgICBcImZpcmVmb3gvbGF0ZXN0XCIsXG4gICAgICBcImNocm9tZS9sYXRlc3RcIixcbiAgICAgIFwic2FmYXJpLzYuMC4ubGF0ZXN0XCIsXG4gICAgICBcImlwaG9uZS82LjAuLmxhdGVzdFwiLFxuICAgICAgXCJhbmRyb2lkLWJyb3dzZXIvNC4yLi5sYXRlc3RcIlxuICAgIF1cbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMS40LjJcIlxufVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCBvZmZzZXQsIGkpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IChpIC0gb2Zmc2V0KTtcbiAgICBvZmZzZXQgPSBpO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGkgPT0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIGNoYXJTdHI7XG5cbiAgICAvLyBvdGhlcndpc2UgY3V0IG9mZiB0aGUgY2hhcmFjdGVycyBlbmQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGksIGJ1ZmZlci5sZW5ndGgpO1xuICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGxlbkluY29tcGxldGUgPSB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIGxlbkluY29tcGxldGUsIGVuZCk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBsZW5JbmNvbXBsZXRlO1xuICAgIGVuZCAtPSBsZW5JbmNvbXBsZXRlO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgdGhpcy5jaGFyQnVmZmVyLndyaXRlKGNoYXJTdHIuY2hhckF0KGNoYXJTdHIubGVuZ3RoIC0gMSksIHRoaXMuZW5jb2RpbmcpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdmFyIGluY29tcGxldGUgPSB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSBpbmNvbXBsZXRlID8gMiA6IDA7XG4gIHJldHVybiBpbmNvbXBsZXRlO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdmFyIGluY29tcGxldGUgPSB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSBpbmNvbXBsZXRlID8gMyA6IDA7XG4gIHJldHVybiBpbmNvbXBsZXRlO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2RlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBiYXNleCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG52YXIgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcbnZhciBiYXNlNTggPSBiYXNleChBTFBIQUJFVClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY29kZTogYmFzZTU4LmVuY29kZSxcbiAgZGVjb2RlOiBiYXNlNTguZGVjb2RlXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYnM1OFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxyXG4gQ29weXJpZ2h0IDIwMTMtMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBieXRlYnVmZmVyLmpzIChjKSAyMDE1IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIEJhY2tpbmcgYnVmZmVyOiBBcnJheUJ1ZmZlciwgQWNjZXNzb3I6IFVpbnQ4QXJyYXlcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2J5dGVidWZmZXIuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lW1wiYW1kXCJdKVxyXG4gICAgICAgIGRlZmluZShbXCJsb25nXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXHJcbiAgICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBMb25nOyB0cnkgeyBMb25nID0gcmVxdWlyZShcImxvbmdcIik7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KExvbmcpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJCeXRlQnVmZmVyXCJdID0gZmFjdG9yeShnbG9iYWxbXCJkY29kZUlPXCJdW1wiTG9uZ1wiXSk7XHJcblxyXG59KSh0aGlzLCBmdW5jdGlvbihMb25nKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBjbGFzcyBUaGUgc3dpc3MgYXJteSBrbmlmZSBmb3IgYmluYXJ5IGRhdGEgaW4gSmF2YVNjcmlwdC5cclxuICAgICAqIEBleHBvcnRzIEJ5dGVCdWZmZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBjYXBhY2l0eSBJbml0aWFsIGNhcGFjaXR5LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgdmFyIEJ5dGVCdWZmZXIgPSBmdW5jdGlvbihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FwYWNpdHkgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBjYXBhY2l0eSA9IEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWTtcclxuICAgICAgICBpZiAodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU47XHJcbiAgICAgICAgaWYgKHR5cGVvZiBub0Fzc2VydCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUO1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgY2FwYWNpdHkgPSBjYXBhY2l0eSB8IDA7XHJcbiAgICAgICAgICAgIGlmIChjYXBhY2l0eSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eVwiKTtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gISFsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gISFub0Fzc2VydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhY2tpbmcgQXJyYXlCdWZmZXIuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheUJ1ZmZlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBjYXBhY2l0eSA9PT0gMCA/IEVNUFRZX0JVRkZFUiA6IG5ldyBBcnJheUJ1ZmZlcihjYXBhY2l0eSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVpbnQ4QXJyYXkgdXRpbGl6ZWQgdG8gbWFuaXB1bGF0ZSB0aGUgYmFja2luZyBidWZmZXIuIEJlY29tZXMgYG51bGxgIGlmIHRoZSBiYWNraW5nIGJ1ZmZlciBoYXMgYSBjYXBhY2l0eSBvZiBgMGAuXHJcbiAgICAgICAgICogQHR5cGUgez9VaW50OEFycmF5fVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpZXcgPSBjYXBhY2l0eSA9PT0gMCA/IG51bGwgOiBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic29sdXRlIHJlYWQvd3JpdGUgb2Zmc2V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNmbGlwXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2NsZWFyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXJrZWQgb2Zmc2V0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzb2x1dGUgbGltaXQgb2YgdGhlIGNvbnRhaW5lZCBkYXRhLiBTZXQgdG8gdGhlIGJhY2tpbmcgYnVmZmVyJ3MgY2FwYWNpdHkgdXBvbiBhbGxvY2F0aW9uLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNmbGlwXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2NsZWFyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW1pdCA9IGNhcGFjaXR5O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW4uXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWAuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm9Bc3NlcnQgPSBub0Fzc2VydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeXRlQnVmZmVyIHZlcnNpb24uXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuVkVSU0lPTiA9IFwiNS4wLjFcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpdHRsZSBlbmRpYW4gY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGl0cyBib29sZWFuIHZhbHVlLiBFdmFsdWF0ZXMgdG8gYHRydWVgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOID0gdHJ1ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJpZyBlbmRpYW4gY29uc3RhbnQgdGhhdCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGl0cyBib29sZWFuIHZhbHVlLiBFdmFsdWF0ZXMgdG8gYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuQklHX0VORElBTiA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBpbml0aWFsIGNhcGFjaXR5IG9mIGAxNmAuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFkgPSAxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgZW5kaWFuZXNzIG9mIGBmYWxzZWAgZm9yIGJpZyBlbmRpYW4uXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTiA9IEJ5dGVCdWZmZXIuQklHX0VORElBTjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgbm8gYXNzZXJ0aW9ucyBmbGFnIG9mIGBmYWxzZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGBMb25nYCBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQtYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS4gTWF5IGJlIGBudWxsYCBpZiBMb25nLmpzIGhhcyBub3QgYmVlbiBsb2FkZWRcclxuICAgICAqICBhbmQgaW50NjQgc3VwcG9ydCBpcyBub3QgYXZhaWxhYmxlLlxyXG4gICAgICogQHR5cGUgez9Mb25nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2xvbmcuanNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5Mb25nID0gTG9uZyB8fCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIEJ5dGVCdWZmZXIucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEJ5dGVCdWZmZXJQcm90b3R5cGUgPSBCeXRlQnVmZmVyLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCeXRlQnVmZmVyIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLl9faXNCeXRlQnVmZmVyX187XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVCdWZmZXJQcm90b3R5cGUsIFwiX19pc0J5dGVCdWZmZXJfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaGVscGVyc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFBcnJheUJ1ZmZlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgRU1QVFlfQlVGRkVSID0gbmV3IEFycmF5QnVmZmVyKDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaW5nLmZyb21DaGFyQ29kZSByZWZlcmVuY2UgZm9yIGNvbXBpbGUtdGltZSByZW5hbWluZy5cclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbiguLi5udW1iZXIpOnN0cmluZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzb3VyY2UgZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHMgU3RyaW5nIHRvIHJlYWQgZnJvbVxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKCk6bnVtYmVyfG51bGx9IFNvdXJjZSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlXHJcbiAgICAgKiAgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBhcmd1bWVudCBpcyBpbnZhbGlkXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RyaW5nU291cmNlKHMpIHtcclxuICAgICAgICB2YXIgaT0wOyByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpIDwgcy5sZW5ndGggPyBzLmNoYXJDb2RlQXQoaSsrKSA6IG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkZXN0aW5hdGlvbiBmdW5jdGlvbiBmb3IgYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24obnVtYmVyPSk6dW5kZWZpbmVkfHN0cmluZ30gRGVzdGluYXRpb24gZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGNoYXIgY29kZS5cclxuICAgICAqICBSZXR1cm5zIHRoZSBmaW5hbCBzdHJpbmcgd2hlbiBjYWxsZWQgd2l0aG91dCBhcmd1bWVudHMuXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3RyaW5nRGVzdGluYXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGNzID0gW10sIHBzID0gW107IHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHMuam9pbignJykrc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY3MpO1xyXG4gICAgICAgICAgICBpZiAoY3MubGVuZ3RoICsgYXJndW1lbnRzLmxlbmd0aCA+IDEwMjQpXHJcbiAgICAgICAgICAgICAgICBwcy5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgY3MubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY3MsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFjY2Vzc29yIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGBCdWZmZXJgIHVuZGVyIG5vZGUuanMsIGBVaW50OEFycmF5YCByZXNwZWN0aXZlbHkgYERhdGFWaWV3YCBpbiB0aGUgYnJvd3NlciAoY2xhc3NlcylcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5hY2Nlc3NvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGEgbmV3IEJ5dGVCdWZmZXIgYmFja2VkIGJ5IGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgY2FwYWNpdHkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNhcGFjaXR5IEluaXRpYWwgY2FwYWNpdHkuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFl9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmFsbG9jYXRlID0gZnVuY3Rpb24oY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbmNhdGVuYXRlcyBtdWx0aXBsZSBCeXRlQnVmZmVycyBpbnRvIG9uZS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nPn0gYnVmZmVycyBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8Ym9vbGVhbik9fSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcgaWYgYGJ1ZmZlcnNgIGNvbnRhaW5zIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLFxyXG4gICAgICogIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIgZm9yIHRoZSByZXN1bHRpbmcgQnl0ZUJ1ZmZlci4gRGVmYXVsdHNcclxuICAgICAqICB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMgZm9yIHRoZSByZXN1bHRpbmcgQnl0ZUJ1ZmZlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ29uY2F0ZW5hdGVkIEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbihidWZmZXJzLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5vQXNzZXJ0ID0gbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWJ1ZmZlcnMubGVuZ3RoLCBsZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyc1tpXSkpXHJcbiAgICAgICAgICAgICAgICBidWZmZXJzW2ldID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcnNbaV0sIGVuY29kaW5nKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnVmZmVyc1tpXS5saW1pdCAtIGJ1ZmZlcnNbaV0ub2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMCkgY2FwYWNpdHkgKz0gbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FwYWNpdHkgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCksXHJcbiAgICAgICAgICAgIGJpO1xyXG4gICAgICAgIGk9MDsgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBiaSA9IGJ1ZmZlcnNbaSsrXTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYmkubGltaXQgLSBiaS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGJiLnZpZXcuc2V0KGJpLnZpZXcuc3ViYXJyYXkoYmkub2Zmc2V0LCBiaS5saW1pdCksIGJiLm9mZnNldCk7XHJcbiAgICAgICAgICAgIGJiLm9mZnNldCArPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLmxpbWl0ID0gYmIub2Zmc2V0O1xyXG4gICAgICAgIGJiLm9mZnNldCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0geyp9IGJiIEJ5dGVCdWZmZXIgdG8gdGVzdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBpdCBpcyBhIEJ5dGVCdWZmZXIsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyID0gZnVuY3Rpb24oYmIpIHtcclxuICAgICAgICByZXR1cm4gKGJiICYmIGJiW1wiX19pc0J5dGVCdWZmZXJfX1wiXSkgPT09IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBiYWNraW5nIGJ1ZmZlciB0eXBlLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBgQnVmZmVyYCB1bmRlciBub2RlLmpzLCBgQXJyYXlCdWZmZXJgIGluIHRoZSBicm93c2VyIChjbGFzc2VzKVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnR5cGUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyBhIGJ1ZmZlciBvciBhIHN0cmluZy4gU2V0cyB0aGUgYWxsb2NhdGVkIEJ5dGVCdWZmZXIncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IHRvIGAwYCBhbmQgaXRzXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9IHRvIHRoZSBsZW5ndGggb2YgdGhlIHdyYXBwZWQgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ3whQXJyYXkuPG51bWJlcj59IGJ1ZmZlciBBbnl0aGluZyB0aGF0IGNhbiBiZSB3cmFwcGVkXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8Ym9vbGVhbik9fSBlbmNvZGluZyBTdHJpbmcgZW5jb2RpbmcgaWYgYGJ1ZmZlcmAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvXHJcbiAgICAgKiAgXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEEgQnl0ZUJ1ZmZlciB3cmFwcGluZyBgYnVmZmVyYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLndyYXAgPSBmdW5jdGlvbihidWZmZXIsIGVuY29kaW5nLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CYXNlNjQoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhleFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21IZXgoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tVVRGOChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tRGVidWcoYnVmZmVyLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nOiBcIitlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCB8fCB0eXBlb2YgYnVmZmVyICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBidWZmZXJcIik7XHJcbiAgICAgICAgdmFyIGJiO1xyXG4gICAgICAgIGlmIChCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcihidWZmZXIpKSB7XHJcbiAgICAgICAgICAgIGJiID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZS5jYWxsKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gYmI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IC8vIEV4dHJhY3QgQXJyYXlCdWZmZXIgZnJvbSBVaW50OEFycmF5XHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkgeyAvLyBBdm9pZCByZWZlcmVuY2VzIHRvIG1vcmUgdGhhbiBvbmUgRU1QVFlfQlVGRkVSXHJcbiAgICAgICAgICAgICAgICBiYi5idWZmZXIgPSBidWZmZXIuYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYnVmZmVyLmJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7IC8vIFJldXNlIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoMCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJiLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYmIudmlldyA9IGJ1ZmZlci5ieXRlTGVuZ3RoID4gMCA/IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYnVmZmVyKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7IC8vIENyZWF0ZSBmcm9tIG9jdGV0c1xyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGJ1ZmZlci5sZW5ndGgsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICBiYi5saW1pdCA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxidWZmZXIubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBiYi52aWV3W2ldID0gYnVmZmVyW2ldO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTsgLy8gT3RoZXJ3aXNlIGZhaWxcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHRoZSBhcnJheSBhcyBhIGJpdHNldC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXk8Ym9vbGVhbj59IHZhbHVlIEFycmF5IG9mIGJvb2xlYW5zIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQml0U2V0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgQml0U2V0OiBOb3QgYW4gYXJyYXlcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgYml0cyA9IHZhbHVlLmxlbmd0aCxcclxuICAgICAgICAgIGJ5dGVzID0gKGJpdHMgPj4gMyksXHJcbiAgICAgICAgICBiaXQgPSAwLFxyXG4gICAgICAgICAgaztcclxuXHJcbiAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoYml0cyxvZmZzZXQpO1xyXG5cclxuICAgICAgd2hpbGUoYnl0ZXMtLSkge1xyXG4gICAgICAgIGsgPSAoISF2YWx1ZVtiaXQrK10gJiAxKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAxKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAyKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAzKSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA0KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA1KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCA3KTtcclxuICAgICAgICB0aGlzLndyaXRlQnl0ZShrLG9mZnNldCsrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoYml0IDwgYml0cykge1xyXG4gICAgICAgIHZhciBtID0gMDsgayA9IDA7XHJcbiAgICAgICAgd2hpbGUoYml0IDwgYml0cykgayA9IGsgfCAoKCEhdmFsdWVbYml0KytdICYgMSkgPDwgKG0rKykpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGssb2Zmc2V0KyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIEJpdFNldCBhcyBhbiBhcnJheSBvZiBib29sZWFucy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQml0U2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblxyXG4gICAgICB2YXIgcmV0ID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KSxcclxuICAgICAgICAgIGJpdHMgPSByZXQudmFsdWUsXHJcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxyXG4gICAgICAgICAgYml0ID0gMCxcclxuICAgICAgICAgIHZhbHVlID0gW10sXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgb2Zmc2V0ICs9IHJldC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZShieXRlcy0tKSB7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDAxKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMik7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDQpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA4KTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgxMCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MjApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDQwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg4MCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcclxuICAgICAgICB2YXIgbSA9IDA7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHdoaWxlKGJpdCA8IGJpdHMpIHZhbHVlW2JpdCsrXSA9ICEhKChrID4+IChtKyspKSAmIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYGxlbmd0aGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIGxlbmd0aCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiK2xlbmd0aCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2xpY2UgPSB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHBheWxvYWQgb2YgYnl0ZXMuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjYXBwZW5kfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfSBzb3VyY2UgRGF0YSB0byB3cml0ZS4gSWYgYHNvdXJjZWAgaXMgYSBCeXRlQnVmZmVyLCBpdHMgb2Zmc2V0c1xyXG4gICAgICogIHdpbGwgYmUgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJ5dGVzID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5hcHBlbmQ7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQ4XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB2YXIgY2FwYWNpdHkwID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTAgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMTtcbiAgICAgICAgdGhpcy52aWV3W29mZnNldF0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50OH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCeXRlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlld1tvZmZzZXRdO1xyXG4gICAgICAgIGlmICgodmFsdWUgJiAweDgwKSA9PT0gMHg4MCkgdmFsdWUgPSAtKDB4RkYgLSB2YWx1ZSArIDEpOyAvLyBDYXN0IHRvIHNpZ25lZFxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCeXRlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDggPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlld1tvZmZzZXRdO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50OCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ4O1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50MTZcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdmFyIGNhcGFjaXR5MiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkyICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkyIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDI7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSAgID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDE2fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAyID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMitcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXSA8PCA4O1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHZhbHVlICYgMHg4MDAwKSA9PT0gMHg4MDAwKSB2YWx1ZSA9IC0oMHhGRkZGIC0gdmFsdWUgKyAxKTsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTaG9ydCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDE2ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTMgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkzKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MyA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDE2ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTYgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAyID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMitcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXSA8PCA4O1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50MTYgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MTY7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQzMlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5NCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk0ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk0IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDMyfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgfD0gMDsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQzMn0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5NSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTUpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk1IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDMyID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyO1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50NjRcclxuXHJcbiAgICBpZiAoTG9uZykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHk2ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTYpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NiA6IG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgICAgIHZhciBsbyA9IHZhbHVlLmxvdyxcclxuICAgICAgICAgICAgICAgIGhpID0gdmFsdWUuaGlnaDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQ2NH0uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUxvbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG8gPSAwLFxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgTG9uZyhsbywgaGksIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDY0fS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZExvbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk3KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTcgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTcgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXHJcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50NjR9LlxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvID0gMCxcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IExvbmcobG8sIGhpLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDY0fS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQ2NCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ2NDtcclxuXHJcbiAgICB9IC8vIExvbmdcclxuXHJcblxyXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0MzJcclxuXHJcbiAgICAvKlxyXG4gICAgIGllZWU3NTQgLSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcclxuXHJcbiAgICAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcblxyXG4gICAgIENvcHlyaWdodCAoYykgRmVyb3NzIEFib3VraGFkaWplaFxyXG5cclxuICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAgICAgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gICAgIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICAgICB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAgICAgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAgICAgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICAgICBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuXHJcbiAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gICAgIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gICAgIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICAgICBUSEUgU09GVFdBUkUuXHJcbiAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gSUVFRTc1NCBmbG9hdCBmcm9tIGEgYnl0ZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5fSBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1MZW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXNcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaWVlZTc1NF9yZWFkKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcclxuICAgICAgICB2YXIgZSwgbSxcclxuICAgICAgICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcclxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcclxuICAgICAgICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXHJcbiAgICAgICAgICAgIG5CaXRzID0gLTcsXHJcbiAgICAgICAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcclxuICAgICAgICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXHJcbiAgICAgICAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XHJcblxyXG4gICAgICAgIGkgKz0gZDtcclxuXHJcbiAgICAgICAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XHJcbiAgICAgICAgcyA+Pj0gKC1uQml0cyk7XHJcbiAgICAgICAgbkJpdHMgKz0gZUxlbjtcclxuICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICAgICAgICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcclxuICAgICAgICBlID4+PSAoLW5CaXRzKTtcclxuICAgICAgICBuQml0cyArPSBtTGVuO1xyXG4gICAgICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XHJcblxyXG4gICAgICAgIGlmIChlID09PSAwKSB7XHJcbiAgICAgICAgICAgIGUgPSAxIC0gZUJpYXM7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xyXG4gICAgICAgICAgICBlID0gZSAtIGVCaWFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBJRUVFNzU0IGZsb2F0IHRvIGEgYnl0ZSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7IUFycmF5fSBidWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xFXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbUxlblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlc1xyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGllZWU3NTRfd3JpdGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcclxuICAgICAgICB2YXIgZSwgbSwgYyxcclxuICAgICAgICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcclxuICAgICAgICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcclxuICAgICAgICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXHJcbiAgICAgICAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcclxuICAgICAgICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxyXG4gICAgICAgICAgICBkID0gaXNMRSA/IDEgOiAtMSxcclxuICAgICAgICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcclxuXHJcbiAgICAgICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XHJcblxyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcclxuICAgICAgICAgICAgZSA9IGVNYXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBlLS07XHJcbiAgICAgICAgICAgICAgICBjICo9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBydCAvIGM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBlKys7XHJcbiAgICAgICAgICAgICAgICBjIC89IDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xyXG4gICAgICAgICAgICAgICAgbSA9IDA7XHJcbiAgICAgICAgICAgICAgICBlID0gZU1heDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xyXG4gICAgICAgICAgICAgICAgZSA9IGUgKyBlQmlhcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxyXG5cclxuICAgICAgICBlID0gKGUgPDwgbUxlbikgfCBtO1xyXG4gICAgICAgIGVMZW4gKz0gbUxlbjtcclxuICAgICAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XHJcblxyXG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB2YXIgY2FwYWNpdHk4ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5OClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTggKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTggOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNDtcbiAgICAgICAgaWVlZTc1NF93cml0ZSh0aGlzLnZpZXcsIHZhbHVlLCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCAyMywgNCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUZsb2F0MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaWVlZTc1NF9yZWFkKHRoaXMudmlldywgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEZsb2F0MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMjtcclxuXHJcbiAgICAvLyB0eXBlcy9mbG9hdHMvZmxvYXQ2NFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgNjRiaXQgZmxvYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYSBudW1iZXIpXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHZhciBjYXBhY2l0eTkgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk5KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5OSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5OSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICBpZWVlNzU0X3dyaXRlKHRoaXMudmlldywgdmFsdWUsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlRmxvYXQ2NH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRG91YmxlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0NjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gaWVlZTc1NF9yZWFkKHRoaXMudmlldywgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgNTIsIDgpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgNjRiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEZsb2F0NjR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZERvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0NjQ7XHJcblxyXG5cclxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50MzJcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDMyX0JZVEVTID0gNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyByZXF1aXJlZC4gQ2FwcGVkIHRvIHtAbGluayBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFU31cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDA7XHJcbiAgICAgICAgICAgICBpZiAodmFsdWUgPCAxIDw8IDcgKSByZXR1cm4gMTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMTQpIHJldHVybiAyO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAyMSkgcmV0dXJuIDM7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDI4KSByZXR1cm4gNDtcclxuICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDMyYml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFNpZ25lZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCB6aWd6YWcgZW5jb2RlZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIgPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKG4gfD0gMCkgPDwgMSkgXiAobiA+PiAzMSkpID4+PiAwOyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIHppZ3phZyBlbmNvZGVkIHNpZ25lZCAzMmJpdCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMiA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICByZXR1cm4gKChuID4+PiAxKSBeIC0obiAmIDEpKSB8IDA7IC8vIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaXplID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgIHZhciBjYXBhY2l0eTEwID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTAgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gc2l6ZTtcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+PSAweDgwKSB7XHJcbiAgICAgICAgICAgIGIgPSAodmFsdWUgJiAweDdmKSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB6aWctemFnIGVuY29kZWQgKHNpZ25lZCkgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMlppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVZhcmludDMyKEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIodmFsdWUpLCBvZmZzZXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcnwhe3ZhbHVlOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWRcclxuICAgICAqICBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludC4gSGFzIGEgcHJvcGVydHkgYHRydW5jYXRlZCA9IHRydWVgIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBhdmFpbGFibGVcclxuICAgICAqICB0byBmdWxseSBkZWNvZGUgdGhlIHZhcmludC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYyA9IDAsXHJcbiAgICAgICAgICAgIHZhbHVlID0gMCA+Pj4gMCxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCAmJiBvZmZzZXQgPiB0aGlzLmxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXCJUcnVuY2F0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICBlcnJbJ3RydW5jYXRlZCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTtcclxuICAgICAgICAgICAgaWYgKGMgPCA1KVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgfD0gKGIgJiAweDdmKSA8PCAoNypjKTtcclxuICAgICAgICAgICAgKytjO1xyXG4gICAgICAgIH0gd2hpbGUgKChiICYgMHg4MCkgIT09IDApO1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwidmFsdWVcIjogdmFsdWUsXHJcbiAgICAgICAgICAgIFwibGVuZ3RoXCI6IGNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXHJcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50MzJaaWdaYWcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHZhbFtcInZhbHVlXCJdID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWxbXCJ2YWx1ZVwiXSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB2YWwgPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTMyKHZhbCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvdmFyaW50cy92YXJpbnQ2NFxyXG5cclxuICAgIGlmIChMb25nKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVMgPSAxMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UNjRfQllURVN9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICAgICAgdmFyIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCkgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0MiA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFydDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0MCA8IDEgPDwgMTQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgNyA/IDEgOiAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQwIDwgMSA8PCAyMSA/IDMgOiA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDEgPCAxIDw8IDE0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDEgPCAxIDw8IDcgPyA1IDogNjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MSA8IDEgPDwgMjEgPyA3IDogODtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDIgPCAxIDw8IDcgPyA5IDogMTA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogWmlnemFnIGVuY29kZXMgYSBzaWduZWQgNjRiaXQgaW50ZWdlciBzbyB0aGF0IGl0IGNhbiBiZSBlZmZlY3RpdmVseSB1c2VkIHdpdGggdmFyaW50IGVuY29kaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBTaWduZWQgbG9uZ1xyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgemlnemFnIGVuY29kZWQgbG9uZ1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2hpZnRMZWZ0KDEpLnhvcih2YWx1ZS5zaGlmdFJpZ2h0KDYzKSkudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSB6aWd6YWcgZW5jb2RlZCBzaWduZWQgNjRiaXQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcn0gdmFsdWUgVW5zaWduZWQgemlnemFnIGVuY29kZWQgbG9uZyBvciBKYXZhU2NyaXB0IG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgxKS54b3IodmFsdWUuYW5kKExvbmcuT05FKS50b1NpZ25lZCgpLm5lZ2F0ZSgpKS50b1NpZ25lZCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfExvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50NjQodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgcGFydDAgPSB2YWx1ZS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDEgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKSA+Pj4gMDtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHkxMSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTEgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHRoaXMudmlld1tvZmZzZXQrOV0gPSAocGFydDIgPj4+ICA3KSAmIDB4MDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkgOiB0aGlzLnZpZXdbb2Zmc2V0KzhdID0gc2l6ZSAhPT0gOSA/IChwYXJ0MiAgICAgICApIHwgMHg4MCA6IChwYXJ0MiAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgOCA6IHRoaXMudmlld1tvZmZzZXQrN10gPSBzaXplICE9PSA4ID8gKHBhcnQxID4+PiAyMSkgfCAweDgwIDogKHBhcnQxID4+PiAyMSkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3IDogdGhpcy52aWV3W29mZnNldCs2XSA9IHNpemUgIT09IDcgPyAocGFydDEgPj4+IDE0KSB8IDB4ODAgOiAocGFydDEgPj4+IDE0KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDYgOiB0aGlzLnZpZXdbb2Zmc2V0KzVdID0gc2l6ZSAhPT0gNiA/IChwYXJ0MSA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gIDcpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNSA6IHRoaXMudmlld1tvZmZzZXQrNF0gPSBzaXplICE9PSA1ID8gKHBhcnQxICAgICAgICkgfCAweDgwIDogKHBhcnQxICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IDogdGhpcy52aWV3W29mZnNldCszXSA9IHNpemUgIT09IDQgPyAocGFydDAgPj4+IDIxKSB8IDB4ODAgOiAocGFydDAgPj4+IDIxKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMgOiB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gc2l6ZSAhPT0gMyA/IChwYXJ0MCA+Pj4gMTQpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gMTQpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMiA6IHRoaXMudmlld1tvZmZzZXQrMV0gPSBzaXplICE9PSAyID8gKHBhcnQwID4+PiAgNykgfCAweDgwIDogKHBhcnQwID4+PiAgNykgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIDogdGhpcy52aWV3W29mZnNldCAgXSA9IHNpemUgIT09IDEgPyAocGFydDAgICAgICAgKSB8IDB4ODAgOiAocGFydDAgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIHppZy16YWcgZW5jb2RlZCA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NFppZ1phZyA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQ2NChCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTY0KHZhbHVlKSwgb2Zmc2V0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxyXG4gICAgICAgICAqICB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgICAgIHBhcnQwID0gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gMCxcclxuICAgICAgICAgICAgICAgIGIgID0gMDtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwICA9IChiICYgMHg3RikgICAgICA7IGlmICggYiAmIDB4ODAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgMTQ7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQwIHw9IChiICYgMHg3RikgPDwgMjE7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxICA9IChiICYgMHg3RikgICAgICA7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgMTQ7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQxIHw9IChiICYgMHg3RikgPDwgMjE7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQyICA9IChiICYgMHg3RikgICAgICA7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107IHBhcnQyIHw9IChiICYgMHg3RikgPDwgIDc7IGlmICgoYiAmIDB4ODApIHx8ICh0aGlzLm5vQXNzZXJ0ICYmIHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCdWZmZXIgb3ZlcnJ1blwiKTsgfX19fX19fX19fVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBMb25nLmZyb21CaXRzKHBhcnQwIHwgKHBhcnQxIDw8IDI4KSwgKHBhcnQxID4+PiA0KSB8IChwYXJ0MikgPDwgMjQsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldC1zdGFydFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLiBSZXF1aXJlcyBMb25nLmpzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ3whe3ZhbHVlOiBMb25nLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkIGFuZFxyXG4gICAgICAgICAqICB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQ2NFppZ1phZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5yZWFkVmFyaW50NjQob2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWxbJ3ZhbHVlJ10gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICAgICAgdmFsW1widmFsdWVcIl0gPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTY0KHZhbFtcInZhbHVlXCJdKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCh2YWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgfSAvLyBMb25nXHJcblxyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvY3N0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgTlVMTC10ZXJtaW5hdGVkIFVURjggZW5jb2RlZCBzdHJpbmcuIEZvciB0aGlzIHRvIHdvcmsgdGhlIHNwZWNpZmllZCBzdHJpbmcgbXVzdCBub3QgY29udGFpbiBhbnkgTlVMTFxyXG4gICAgICogIGNoYXJhY3RlcnMgaXRzZWxmLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIGNvbnRhaW5lZCBpbiBgc3RyYCArIDEgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQ1N0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICBrID0gc3RyLmxlbmd0aDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgZm9yIChpPTA7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBOVUxMLWNoYXJhY3RlcnNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVURjggc3RyaW5ncyBkbyBub3QgY29udGFpbiB6ZXJvIGJ5dGVzIGluIGJldHdlZW4gZXhjZXB0IGZvciB0aGUgemVybyBjaGFyYWN0ZXIsIHNvOlxyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcclxuICAgICAgICBvZmZzZXQgKz0gaysxO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTIgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEyIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGsrMTtcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSAwO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgTlVMTC10ZXJtaW5hdGVkIFVURjggZW5jb2RlZCBzdHJpbmcuIEZvciB0aGlzIHRvIHdvcmsgdGhlIHN0cmluZyByZWFkIG11c3Qgbm90IGNvbnRhaW4gYW55IE5VTEwgY2hhcmFjdGVyc1xyXG4gICAgICogIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRDU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICB0ZW1wO1xyXG4gICAgICAgIC8vIFVURjggc3RyaW5ncyBkbyBub3QgY29udGFpbiB6ZXJvIGJ5dGVzIGluIGJldHdlZW4gZXhjZXB0IGZvciB0aGUgemVybyBjaGFyYWN0ZXIgaXRzZWxmLCBzbzpcclxuICAgICAgICB2YXIgc2QsIGIgPSAtMTtcclxuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiIDwgXCIrdGhpcy5saW1pdCk7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IG51bGwgOiBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpLCB0cnVlKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvaXN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIGs7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSA0K2s7XG4gICAgICAgIHZhciBjYXBhY2l0eTEzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNCtrO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQgKyA0ICsgaylcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCs0K2spKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBsZW5ndGggYXMgdWludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZWFkVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSVN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSA0KTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy91dGY4c3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzLiBFdmFsdWF0ZXMgdG8gYGNgLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMgPSAnYyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgYnl0ZXMuIEV2YWx1YXRlcyB0byBgYmAuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUyA9ICdiJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGs7XG4gICAgICAgIHZhciBjYXBhY2l0eTE0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTQgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gaztcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVURjhTdHJpbmd9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzIG9mIGEgc3RyaW5nLiBKYXZhU2NyaXB0IGl0c2VsZiB1c2VzIFVURi0xNiwgc28gdGhhdCBhIHN0cmluZydzXHJcbiAgICAgKiAgYGxlbmd0aGAgcHJvcGVydHkgZG9lcyBub3QgcmVmbGVjdCBpdHMgYWN0dWFsIFVURjggc2l6ZSBpZiBpdCBjb250YWlucyBjb2RlIHBvaW50cyBsYXJnZXIgdGhhbiAweEZGRkYuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Q2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgb2YgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggYnl0ZXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVTdHJpbmcgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIHRvIHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG1ldHJpY3MgTWV0cmljcyBzcGVjaWZ5aW5nIHdoYXQgYGxlbmd0aGAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSU30uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVVRGOFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgbWV0cmljcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBtZXRyaWNzO1xyXG4gICAgICAgICAgICBtZXRyaWNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAndW5kZWZpbmVkJykgbWV0cmljcyA9IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUztcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgc2Q7XHJcbiAgICAgICAgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUykgeyAvLyBUaGUgc2FtZSBmb3Igbm9kZSBhbmQgdGhlIGJyb3dzZXJcclxuICAgICAgICAgICAgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpO1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbmd0aCAmJiBvZmZzZXQgPCB0aGlzLmxpbWl0ID8gdGhpcy52aWV3W29mZnNldCsrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgICsraTsgdXRmeC5VVEY4dG9VVEYxNihjcCwgc2QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIraStcIiA9PSBcIitsZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IHNkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrbGVuZ3RoK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGsgPSBvZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0IDwgayA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGspXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIitrKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogc2QoKSxcclxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0cmljczogXCIrbWV0cmljcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVVRGOFN0cmluZ30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtZXRyaWNzIE1ldHJpY3Mgc3BlY2lmeWluZyB3aGF0IGBuYCBpcyBtZWFudCB0byBjb3VudC4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTdHJpbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nO1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdnN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHZhcmludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3dyaXRlVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgaywgbDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdGhpcy5ub0Fzc2VydClbMV07XHJcbiAgICAgICAgbCA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoayk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IGwraztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsK2s7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoaywgb2Zmc2V0KTtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQraytsKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIisob2Zmc2V0K2srbCkpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuWyd2YWx1ZSddLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSBsZW5bJ2xlbmd0aCddKTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBzb21lIGRhdGEgdG8gdGhpcyBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWhpbmQgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGFwcGVuZGVkXHJcbiAgICAgKiAgZGF0YSdzIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gYXBwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXRzXHJcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZW5jb2RpbmcgRW5jb2RpbmcgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBhcHBlbmQgYXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDwwMSAwMj4wMy5hcHBlbmQoPDA0IDA1PilgIHdpbGwgcmVzdWx0IGluIGA8MDEgMDIgMDQgMDU+LCAwNCAwNXxgXHJcbiAgICAgKiBAZXhhbXBsZSBBbiBhYnNvbHV0ZSBgPDAxIDAyPjAzLmFwcGVuZCgwNCAwNT4sIDEpYCB3aWxsIHJlc3VsdCBpbiBgPDAxIDA0PjA1LCAwNCAwNXxgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBhcHBlbmRcclxuICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE2KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE2IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGxlbmd0aDtcbiAgICAgICAgdGhpcy52aWV3LnNldChzb3VyY2Uudmlldy5zdWJhcnJheShzb3VyY2Uub2Zmc2V0LCBzb3VyY2UubGltaXQpLCBvZmZzZXQpO1xyXG4gICAgICAgIHNvdXJjZS5vZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYXQgYW5kIGFmdGVyIHRoZVxyXG4gICAgICAgIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGxlbmd0aCBvZiB0aGlzIEJ5dGVCdWZmZXIncyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjYXBwZW5kXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5hcHBlbmQodGhpcywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGFzc2VydGlvbnMgb2YgYXJndW1lbnQgdHlwZXMgYW5kIG9mZnNldHMuIEFzc2VydGlvbnMgYXJlIGVuYWJsZWQgYnkgZGVmYXVsdCBidXQgeW91IGNhbiBvcHQgdG9cclxuICAgICAqICBkaXNhYmxlIHRoZW0gaWYgeW91ciBjb2RlIGFscmVhZHkgbWFrZXMgc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzc2VydCBgdHJ1ZWAgdG8gZW5hYmxlIGFzc2VydGlvbnMsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbihhc3NlcnQpIHtcclxuICAgICAgICB0aGlzLm5vQXNzZXJ0ID0gIWFzc2VydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjYXBhY2l0eSBvZiB0aGlzIEJ5dGVCdWZmZXIncyBiYWNraW5nIGJ1ZmZlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENhcGFjaXR5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNhcGFjaXR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhpcyBCeXRlQnVmZmVyJ3Mgb2Zmc2V0cyBieSBzZXR0aW5nIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gdG8gYDBgIGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlXHJcbiAgICAgKiAgYmFja2luZyBidWZmZXIncyBjYXBhY2l0eS4gRGlzY2FyZHMge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGlzIEJ5dGVCdWZmZXIsIHByZXNldCB3aXRoIHRoaXMgQnl0ZUJ1ZmZlcidzIHZhbHVlcyBmb3Ige0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSxcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb3B5IFdoZXRoZXIgdG8gY29weSB0aGUgYmFja2luZyBidWZmZXIgb3IgdG8gcmV0dXJuIGFub3RoZXIgdmlldyBvbiB0aGUgc2FtZSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDbG9uZWQgaW5zdGFuY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNvcHkpIHtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgaWYgKGNvcHkpIHtcclxuICAgICAgICAgICAgYmIuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmIuYnVmZmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYi5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICAgICAgYmIudmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gdGhpcy5tYXJrZWRPZmZzZXQ7XHJcbiAgICAgICAgYmIubGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYWN0cyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfSBvZiBpdHMgY29udGVudHMnIGxlbmd0aC4gQ29udGVudHMgYXJlIHRoZSBieXRlc1xyXG4gICAgICogIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBXaWxsIHNldCBgb2Zmc2V0ID0gMGAgYW5kIGBsaW1pdCA9IGNhcGFjaXR5YCBhbmRcclxuICAgICAqICBhZGFwdCB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IHRvIHRoZSBzYW1lIHJlbGF0aXZlIHBvc2l0aW9uIGlmIHNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gMCAmJiBlbmQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBBbHJlYWR5IGNvbXBhY3RlZFxyXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBiZWdpbjtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XHJcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShiZWdpbiwgZW5kKSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsZW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDb3B5XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gZW5kIC0gYmVnaW4sXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gY2FwYWNpdHk7XHJcbiAgICAgICAgaWYgKGJiLm1hcmtlZE9mZnNldCA+PSAwKSBiYi5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5jb3B5VG8oYmIsIDAsIGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gdGFyZ2V0T2Zmc2V0IE9mZnNldCB0byBjb3B5IHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2UgdGhlIHRhcmdldCdzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqICBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VPZmZzZXQgT2Zmc2V0IHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlXHJcbiAgICAgKiAgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VMaW1pdCBPZmZzZXQgdG8gZW5kIGNvcHlpbmcgZnJvbSwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldE9mZnNldCwgc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSxcclxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmU7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdGFyZ2V0OiBOb3QgYSBCeXRlQnVmZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRPZmZzZXQgPSAodGFyZ2V0UmVsYXRpdmUgPSB0eXBlb2YgdGFyZ2V0T2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0YXJnZXQub2Zmc2V0IDogdGFyZ2V0T2Zmc2V0IHwgMDtcclxuICAgICAgICBzb3VyY2VPZmZzZXQgPSAocmVsYXRpdmUgPSB0eXBlb2Ygc291cmNlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0aGlzLm9mZnNldCA6IHNvdXJjZU9mZnNldCB8IDA7XHJcbiAgICAgICAgc291cmNlTGltaXQgPSB0eXBlb2Ygc291cmNlTGltaXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5saW1pdCA6IHNvdXJjZUxpbWl0IHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldCA8IDAgfHwgdGFyZ2V0T2Zmc2V0ID4gdGFyZ2V0LmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQgcmFuZ2U6IDAgPD0gXCIrdGFyZ2V0T2Zmc2V0K1wiIDw9IFwiK3RhcmdldC5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHNvdXJjZU9mZnNldCA8IDAgfHwgc291cmNlTGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrc291cmNlT2Zmc2V0K1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gc291cmNlTGltaXQgLSBzb3VyY2VPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDsgLy8gTm90aGluZyB0byBjb3B5XHJcblxyXG4gICAgICAgIHRhcmdldC5lbnN1cmVDYXBhY2l0eSh0YXJnZXRPZmZzZXQgKyBsZW4pO1xyXG5cclxuICAgICAgICB0YXJnZXQudmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KHNvdXJjZU9mZnNldCwgc291cmNlTGltaXQpLCB0YXJnZXRPZmZzZXQpO1xyXG5cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICBpZiAodGFyZ2V0UmVsYXRpdmUpIHRhcmdldC5vZmZzZXQgKz0gbGVuO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgdGhpcyBCeXRlQnVmZmVyIGlzIGJhY2tlZCBieSBhIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn0gb2YgYXQgbGVhc3QgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS4gSWYgdGhlXHJcbiAgICAgKiAgY3VycmVudCBjYXBhY2l0eSBpcyBleGNlZWRlZCwgaXQgd2lsbCBiZSBkb3VibGVkLiBJZiBkb3VibGUgdGhlIGN1cnJlbnQgY2FwYWNpdHkgaXMgbGVzcyB0aGFuIHRoZSByZXF1aXJlZCBjYXBhY2l0eSxcclxuICAgICAqICB0aGUgcmVxdWlyZWQgY2FwYWNpdHkgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHkgUmVxdWlyZWQgY2FwYWNpdHlcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBjYXBhY2l0eSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKChjdXJyZW50ICo9IDIpID4gY2FwYWNpdHkgPyBjdXJyZW50IDogY2FwYWNpdHkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIEJ5dGUgdmFsdWUgdG8gZmlsbCB3aXRoLiBJZiBnaXZlbiBhcyBhIHN0cmluZywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyB1c2VkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIGBzb21lQnl0ZUJ1ZmZlci5jbGVhcigpLmZpbGwoMClgIGZpbGxzIHRoZSBlbnRpcmUgYmFja2luZyBidWZmZXIgd2l0aCB6ZXJvZXNcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID49IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gZmlsbFxyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkgdGhpcy52aWV3W2JlZ2luKytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCA9IGJlZ2luO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoaXMgQnl0ZUJ1ZmZlciByZWFkeSBmb3IgYSBuZXcgc2VxdWVuY2Ugb2Ygd3JpdGUgb3IgcmVsYXRpdmUgcmVhZCBvcGVyYXRpb25zLiBTZXRzIGBsaW1pdCA9IG9mZnNldGAgYW5kXHJcbiAgICAgKiAgYG9mZnNldCA9IDBgLiBNYWtlIHN1cmUgYWx3YXlzIHRvIGZsaXAgYSBCeXRlQnVmZmVyIHdoZW4gYWxsIHJlbGF0aXZlIHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9ucyBhcmUgY29tcGxldGUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1hcmtzIGFuIG9mZnNldCBvbiB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgdXNlZCBsYXRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBtYXJrLiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIG9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJ5dGUgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBgdHJ1ZWAgZm9yIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgYGZhbHNlYCBmb3IgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuTEUgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gISFsaXR0bGVFbmRpYW4gOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYmlnRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgbGl0dGxlIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuQkUgPSBmdW5jdGlvbihiaWdFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBiaWdFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gIWJpZ0VuZGlhbiA6IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgc29tZSBkYXRhIHRvIHRoaXMgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZVxyXG4gICAgICogIHByZXBlbmRlZCBkYXRhJ3MgbGVuZ3RoLiBJZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBgb2Zmc2V0YCwgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfHN0cmluZ3whQXJyYXlCdWZmZXJ9IHNvdXJjZSBEYXRhIHRvIHByZXBlbmQuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldCB3aWxsIGJlXHJcbiAgICAgKiAgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcHJlcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGRlY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHByZXBlbmRlZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBBIHJlbGF0aXZlIGAwMDwwMSAwMiAwMz4ucHJlcGVuZCg8MDQgMDU+KWAgcmVzdWx0cyBpbiBgPDA0IDA1IDAxIDAyIDAzPiwgMDQgMDV8YFxyXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4sIDIpYCByZXN1bHRzIGluIGAwNDwwNSAwMiAwMz4sIDA0IDA1fGBcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBwcmVwZW5kXHJcbiAgICAgICAgdmFyIGRpZmYgPSBsZW4gLSBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7IC8vIE5vdCBlbm91Z2ggc3BhY2UgYmVmb3JlIG9mZnNldCwgc28gcmVzaXplICsgbW92ZVxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBkaWZmKTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkob2Zmc2V0LCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSwgbGVuKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLmxpbWl0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheVZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0IC0gbGVuKTtcclxuXHJcbiAgICAgICAgc291cmNlLm9mZnNldCA9IHNvdXJjZS5saW1pdDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpXHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWZvcmUgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlXHJcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqICB3aWxsIGJlIHJlc2l6ZWQgYW5kIGl0cyBjb250ZW50cyBtb3ZlZCBhY2NvcmRpbmdseS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBwcmVwZW5kZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3ByZXBlbmRcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5wcmVwZW5kKHRoaXMsIG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmludHMgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk9fSBvdXQgT3V0cHV0IGZ1bmN0aW9uIHRvIGNhbGwsIGRlZmF1bHRzIHRvIGNvbnNvbGUubG9nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJpbnREZWJ1ZyA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0ICE9PSAnZnVuY3Rpb24nKSBvdXQgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xyXG4gICAgICAgIG91dChcclxuICAgICAgICAgICAgdGhpcy50b1N0cmluZygpK1wiXFxuXCIrXHJcbiAgICAgICAgICAgIFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiK1xyXG4gICAgICAgICAgICB0aGlzLnRvRGVidWcoLyogY29sdW1ucyAqLyB0cnVlKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LCBzbyB0aGlzIHJldHVybnMgYGxpbWl0IC0gb2Zmc2V0YC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gTWF5IGJlIG5lZ2F0aXZlIGlmIGBvZmZzZXQgPiBsaW1pdGAuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVtYWluaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQgLSB0aGlzLm9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGlzIEJ5dGVCdWZmZXIncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LiBJZiBhbiBvZmZzZXQgaGFzIGJlZW4gbWFya2VkIHRocm91Z2gge0BsaW5rIEJ5dGVCdWZmZXIjbWFya31cclxuICAgICAqICBiZWZvcmUsIGBvZmZzZXRgIHdpbGwgYmUgc2V0IHRvIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0sIHdoaWNoIHdpbGwgdGhlbiBiZSBkaXNjYXJkZWQuIElmIG5vIG9mZnNldCBoYXMgYmVlblxyXG4gICAgICogIG1hcmtlZCwgc2V0cyBgb2Zmc2V0ID0gMGAuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSBiYWNrZWQgYnkgYSBidWZmZXIgb2YgYXQgbGVhc3QgdGhlIGdpdmVuIGNhcGFjaXR5LiBXaWxsIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSB0aGF0XHJcbiAgICAgKiAgbGFyZ2Ugb3IgbGFyZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IENhcGFjaXR5IHJlcXVpcmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYGNhcGFjaXR5YCBpcyBub3QgYSBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBjYXBhY2l0eSA8IDBgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXBhY2l0eSAhPT0gJ251bWJlcicgfHwgY2FwYWNpdHkgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IFwiK2NhcGFjaXR5K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBjYXBhY2l0eSB8PSAwO1xuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2NhcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPCBjYXBhY2l0eSkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZlcnNlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byByZXZlcnNlXHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgdGhlIG5leHQgYGxlbmd0aGAgYnl0ZXMuIFRoaXMgd2lsbCBqdXN0IGFkdmFuY2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuIE1heSBhbHNvIGJlIG5lZ2F0aXZlIHRvIG1vdmUgdGhlIG9mZnNldCBiYWNrLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrbGVuZ3RoK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBsZW5ndGggfD0gMDtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIGxlbmd0aDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogMCA8PSBcIit0aGlzLm9mZnNldCtcIiArIFwiK2xlbmd0aCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2xpY2VzIHRoaXMgQnl0ZUJ1ZmZlciBieSBjcmVhdGluZyBhIGNsb25lZCBpbnN0YW5jZSB3aXRoIGBvZmZzZXQgPSBiZWdpbmAgYW5kIGBsaW1pdCA9IGVuZGAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmUgb2YgdGhpcyBCeXRlQnVmZmVyIHdpdGggc2xpY2luZyBhcHBsaWVkLCBiYWNrZWQgYnkgdGhlIHNhbWUge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmIgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gYmVnaW47XHJcbiAgICAgICAgYmIubGltaXQgPSBlbmQ7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGJhY2tpbmcgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlQ29weSBJZiBgdHJ1ZWAgcmV0dXJucyBhIGNvcHksIG90aGVyd2lzZSByZXR1cm5zIGEgdmlldyByZWZlcmVuY2luZyB0aGUgc2FtZSBtZW1vcnkgaWZcclxuICAgICAqICBwb3NzaWJsZS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKGZvcmNlQ29weSkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCxcclxuICAgICAgICAgICAgbGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgbGltaXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGltaXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgbGltaXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbGltaXQgfHwgbGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK29mZnNldCtcIiA8PSBcIitsaW1pdCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PVEU6IEl0J3Mgbm90IHBvc3NpYmxlIHRvIGhhdmUgYW5vdGhlciBBcnJheUJ1ZmZlciByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5IGFzIHRoZSBiYWNraW5nIGJ1ZmZlci4gVGhpcyBpc1xyXG4gICAgICAgIC8vIHBvc3NpYmxlIHdpdGggVWludDhBcnJheSNzdWJhcnJheSBvbmx5LCBidXQgd2UgaGF2ZSB0byByZXR1cm4gYW4gQXJyYXlCdWZmZXIgYnkgY29udHJhY3QuIFNvOlxyXG4gICAgICAgIGlmICghZm9yY2VDb3B5ICYmIG9mZnNldCA9PT0gMCAmJiBsaW1pdCA9PT0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxpbWl0KVxyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGltaXQgLSBvZmZzZXQpO1xyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKS5zdWJhcnJheShvZmZzZXQsIGxpbWl0KSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmF3IGJ1ZmZlciBjb21wYWN0ZWQgdG8gY29udGFpbiB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3RvQnVmZmVyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VDb3B5IElmIGB0cnVlYCByZXR1cm5zIGEgY29weSwgb3RoZXJ3aXNlIHJldHVybnMgYSB2aWV3IHJlZmVyZW5jaW5nIHRoZSBzYW1lIG1lbW9yeS5cclxuICAgICAqICBEZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5QnVmZmVyfSBDb250ZW50cyBhcyBhbiBBcnJheUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgT3V0cHV0IGVuY29kaW5nLiBSZXR1cm5zIGFuIGluZm9ybWF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiBvbWl0dGVkIGJ1dCBhbHNvIGFsbG93c1xyXG4gICAgICogIGRpcmVjdCBjb252ZXJzaW9uIHRvIFwidXRmOFwiLCBcImhleFwiLCBcImJhc2U2NFwiIGFuZCBcImJpbmFyeVwiIGVuY29kaW5nLiBcImRlYnVnXCIgcmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiB3aXRoXHJcbiAgICAgKiAgaGlnaGxpZ2h0ZWQgb2Zmc2V0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGBlbmNvZGluZ2AgaXMgaW52YWxpZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgcmV0dXJuIFwiQnl0ZUJ1ZmZlckFCKG9mZnNldD1cIit0aGlzLm9mZnNldCtcIixtYXJrZWRPZmZzZXQ9XCIrdGhpcy5tYXJrZWRPZmZzZXQrXCIsbGltaXQ9XCIrdGhpcy5saW1pdCtcIixjYXBhY2l0eT1cIit0aGlzLmNhcGFjaXR5KCkrXCIpXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCIsXHJcbiAgICAgICAgICAgIGJlZ2luID0gZW5jb2RpbmcsXHJcbiAgICAgICAgICAgIGVuZCA9IGJlZ2luO1xyXG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVVRGOChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CYXNlNjQoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0JpbmFyeShiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RlYnVnKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5zXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbHVtbnMoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2VuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGx4aXYtZW1iZWRkYWJsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbHhpdi1lbWJlZGRhYmxlIChjKSAyMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAgICAgKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2x4aXYgZm9yIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgdmFyIGx4aXYgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbHhpdiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKiBAZXhwb3J0cyBseGl2XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGx4aXYgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhcmFjdGVyIGNvZGVzIGZvciBvdXRwdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYW91dCA9IFtcclxuICAgICAgICAgICAgNjUsIDY2LCA2NywgNjgsIDY5LCA3MCwgNzEsIDcyLCA3MywgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsXHJcbiAgICAgICAgICAgIDgxLCA4MiwgODMsIDg0LCA4NSwgODYsIDg3LCA4OCwgODksIDkwLCA5NywgOTgsIDk5LCAxMDAsIDEwMSwgMTAyLFxyXG4gICAgICAgICAgICAxMDMsIDEwNCwgMTA1LCAxMDYsIDEwNywgMTA4LCAxMDksIDExMCwgMTExLCAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsXHJcbiAgICAgICAgICAgIDExOSwgMTIwLCAxMjEsIDEyMiwgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQzLCA0N1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJhY3RlciBjb2RlcyBmb3IgaW5wdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWFvdXQubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgYWluW2FvdXRbaV1dID0gaTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBieXRlcyB0byBiYXNlNjQgY2hhciBjb2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZlxyXG4gICAgICAgICAqICB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggZW5jb2RlZCBjaGFyXHJcbiAgICAgICAgICogIGNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi5lbmNvZGUgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYiwgdDtcclxuICAgICAgICAgICAgd2hpbGUgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkc3QoYW91dFsoYj4+MikmMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiJjB4Myk8PDQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0IHw9IChiPj40KSYweGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj40KSYweGYpKSYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IChiJjB4Zik8PDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFsodHwoKGI+PjYpJjB4MykpJjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbYiYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KDYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W3QmMHgzZl0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCg2MSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KDYxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYmFzZTY0IGNoYXIgY29kZXMgdG8gYnl0ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBjaGFyYWN0ZXIgY29kZSBpcyBpbnZhbGlkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi5kZWNvZGUgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYywgdDEsIHQyO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKGMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgY29kZTogXCIrYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0MSA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDEgPT09ICd1bmRlZmluZWQnKSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdDIgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MiA9PT0gJ3VuZGVmaW5lZCcpIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCh0MTw8Mik+Pj4wfCh0MiYweDMwKT4+NCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQxID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSA2MSkgYnJlYWs7IGVsc2UgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHN0KCgodDImMHhmKTw8NCk+Pj4wfCh0MSYweDNjKT4+Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoYyA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDIgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQyID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gNjEpIGJyZWFrOyBlbHNlIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3QoKCh0MSYweDMpPDw2KT4+PjB8dDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBzdHJpbmcgaXMgdmFsaWQgYmFzZTY0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRlc3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbGlkLCBvdGhlcndpc2UgYGZhbHNlYFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx4aXYudGVzdCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gbHhpdjtcclxuICAgIH0oKTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvYmFzZTY0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBiZWdpbmAgb3IgYGVuZGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQmFzZTY0ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBiZWdpbiA9IGJlZ2luIHwgMDsgZW5kID0gZW5kIHwgMDtcclxuICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGVuZCA+IHRoaXMuY2FwYWNpdHkgfHwgYmVnaW4gPiBlbmQpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xyXG4gICAgICAgIHZhciBzZDsgbHhpdi5lbmNvZGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZWdpbiA8IGVuZCA/IHRoaXMudmlld1tiZWdpbisrXSA6IG51bGw7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCkpO1xyXG4gICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihzdHIubGVuZ3RoLzQqMywgbGl0dGxlRW5kaWFuKSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgbHhpdi5kZWNvZGUoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgYmIudmlld1tpKytdID0gYjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYi5saW1pdCA9IGk7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgYSBiaW5hcnkgc3RyaW5nIHRvIGJhc2U2NCBsaWtlIGB3aW5kb3cuYnRvYWAgZG9lcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQmluYXJ5IHN0cmluZ1xyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYnRvYVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmJ0b2EgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5KHN0cikudG9CYXNlNjQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGJpbmFyeSBsaWtlIGB3aW5kb3cuYXRvYmAgZG9lcy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiNjQgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCaW5hcnkgc3RyaW5nXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuYXRvYlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmF0b2IgPSBmdW5jdGlvbihiNjQpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5mcm9tQmFzZTY0KGI2NCkudG9CaW5hcnkoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2JpbmFyeVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmluYXJ5IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0ID4gbGltaXRgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CaW5hcnkgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGJlZ2luIHw9IDA7IGVuZCB8PSAwO1xyXG4gICAgICAgIGlmIChiZWdpbiA8IDAgfHwgZW5kID4gdGhpcy5jYXBhY2l0eSgpIHx8IGJlZ2luID4gZW5kKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiYmVnaW4sIGVuZFwiKTtcclxuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgdmFyIGNoYXJzID0gW10sXHJcbiAgICAgICAgICAgIHBhcnRzID0gW107XHJcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIGNoYXJzLnB1c2godGhpcy52aWV3W2JlZ2luKytdKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA+PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpKSxcclxuICAgICAgICAgICAgICAgIGNoYXJzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKSArIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaGFycyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZywgdGhhdCBpcyB1c2luZyBvbmx5IGNoYXJhY3RlcnMgMHgwMC0weEZGIGFzIGJ5dGVzLCB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21CaW5hcnkgPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO1xyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGNoYXJDb2RlLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKGssIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPiAweGZmKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImlsbGVnYWwgY2hhciBjb2RlOiBcIitjaGFyQ29kZSk7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGNoYXJDb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGs7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvZGVidWdcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nIHdpdGggbWFya2VkIG9mZnNldHMuIE9mZnNldCBzeW1ib2xzIGFyZTpcclxuICAgICAqICogYDxgIDogb2Zmc2V0LFxyXG4gICAgICogKiBgJ2AgOiBtYXJrZWRPZmZzZXQsXHJcbiAgICAgKiAqIGA+YCA6IGxpbWl0LFxyXG4gICAgICogKiBgfGAgOiBvZmZzZXQgYW5kIGxpbWl0LFxyXG4gICAgICogKiBgW2AgOiBvZmZzZXQgYW5kIG1hcmtlZE9mZnNldCxcclxuICAgICAqICogYF1gIDogbWFya2VkT2Zmc2V0IGFuZCBsaW1pdCxcclxuICAgICAqICogYCFgIDogb2Zmc2V0LCBtYXJrZWRPZmZzZXQgYW5kIGxpbWl0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb2x1bW5zIElmIGB0cnVlYCByZXR1cm5zIHR3byBjb2x1bW5zIGhleCArIGFzY2lpLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCFBcnJheS48c3RyaW5nPn0gRGVidWcgc3RyaW5nIG9yIGFycmF5IG9mIGxpbmVzIGlmIGBhc0FycmF5ID0gdHJ1ZWBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIGA+MDAnMDEgMDI8MDNgIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgbGltaXQ9MCwgbWFya2VkT2Zmc2V0PTEsIG9mZnNldD0zYFxyXG4gICAgICogQGV4YW1wbGUgYDAwWzAxIDAyIDAzPmAgY29udGFpbnMgZm91ciBieXRlcyB3aXRoIGBvZmZzZXQ9bWFya2VkT2Zmc2V0PTEsIGxpbWl0PTRgXHJcbiAgICAgKiBAZXhhbXBsZSBgMDB8MDEgMDIgMDNgIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PWxpbWl0PTEsIG1hcmtlZE9mZnNldD0tMWBcclxuICAgICAqIEBleGFtcGxlIGB8YCBjb250YWlucyB6ZXJvIGJ5dGVzIHdpdGggYG9mZnNldD1saW1pdD0wLCBtYXJrZWRPZmZzZXQ9LTFgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9EZWJ1ZyA9IGZ1bmN0aW9uKGNvbHVtbnMpIHtcclxuICAgICAgICB2YXIgaSA9IC0xLFxyXG4gICAgICAgICAgICBrID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgYixcclxuICAgICAgICAgICAgaGV4ID0gXCJcIixcclxuICAgICAgICAgICAgYXNjID0gXCJcIixcclxuICAgICAgICAgICAgb3V0ID0gXCJcIjtcclxuICAgICAgICB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IHRoaXMudmlld1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChiIDwgMHgxMCkgaGV4ICs9IFwiMFwiK2IudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGhleCArPSBiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYXNjICs9IGIgPiAzMiAmJiBiIDwgMTI3ID8gU3RyaW5nLmZyb21DaGFyQ29kZShiKSA6ICcuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChjb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgaSAlIDE2ID09PSAwICYmIGkgIT09IGspIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMykgaGV4ICs9IFwiIFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBoZXgrYXNjK1wiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYXNjID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5vZmZzZXQgJiYgaSA9PT0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiIVwiIDogXCJ8XCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IHRoaXMub2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IGkgPT09IHRoaXMubWFya2VkT2Zmc2V0ID8gXCJbXCIgOiBcIjxcIjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiXVwiIDogXCI+XCI7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiJ1wiIDogKGNvbHVtbnMgfHwgKGkgIT09IDAgJiYgaSAhPT0gaykgPyBcIiBcIiA6IFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sdW1ucyAmJiBoZXggIT09IFwiIFwiKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMyoxNiszKVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IFwiIFwiO1xyXG4gICAgICAgICAgICBvdXQgKz0gaGV4ICsgYXNjICsgXCJcXG5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMgPyBvdXQgOiBoZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgRGVidWcgc3RyaW5nIHRvIGRlY29kZSAobm90IGJlIGdlbmVyYXRlZCB3aXRoIGBjb2x1bW5zID0gdHJ1ZWApXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN0b0RlYnVnXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbURlYnVnID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgdmFyIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKCgoaysxKS8zKXwwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICB2YXIgaSA9IDAsIGogPSAwLCBjaCwgYixcclxuICAgICAgICAgICAgcnMgPSBmYWxzZSwgLy8gUmVxdWlyZSBzeW1ib2wgbmV4dFxyXG4gICAgICAgICAgICBobyA9IGZhbHNlLCBobSA9IGZhbHNlLCBobCA9IGZhbHNlLCAvLyBBbHJlYWR5IGhhcyBvZmZzZXQgKGhvKSwgbWFya2VkT2Zmc2V0IChobSksIGxpbWl0IChobCk/XHJcbiAgICAgICAgICAgIGZhaWwgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2ggPSBzdHIuY2hhckF0KGkrKykpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtIHx8IGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaG0gPSBobCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLm1hcmtlZE9mZnNldCA9IGJiLmxpbWl0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnfCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8gfHwgaGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLmxpbWl0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8gfHwgaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnXSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGwgfHwgaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGwgPSBobSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCInXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiID0gcGFyc2VJbnQoY2grc3RyLmNoYXJBdChpKyspLCAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZhaWwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogSW52YWxpZCBzeW1ib2wgYXQgXCIraSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKCFobyB8fCAhaGwpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTWlzc2luZyBvZmZzZXQgb3IgbGltaXRcIik7XHJcbiAgICAgICAgICAgIGlmIChqPGJiLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nIChpcyBpdCBoZXg/KSBcIitqK1wiIDwgXCIrayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2hleFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgT2Zmc2V0IHRvIGVuZCBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgYmVnaW4gPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBiZWdpbjtcclxuICAgICAgICBlbmQgPSB0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJyA/IHRoaXMubGltaXQgOiBlbmQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dCA9IG5ldyBBcnJheShlbmQgLSBiZWdpbiksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbYmVnaW4rK107XHJcbiAgICAgICAgICAgIGlmIChiIDwgMHgxMClcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiMFwiLCBiLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgIGVsc2Ugb3V0LnB1c2goYi50b1N0cmluZygxNikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tSGV4ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgIT09IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTGVuZ3RoIG5vdCBhIG11bHRpcGxlIG9mIDJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigoayAvIDIpIHwgMCwgbGl0dGxlRW5kaWFuKSxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGo9MDsgaTxrOyBpKz0yKSB7XHJcbiAgICAgICAgICAgIGIgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkrMiksIDE2KTtcclxuICAgICAgICAgICAgaWYgKCFub0Fzc2VydClcclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoYikgfHwgYiA8IDAgfHwgYiA+IDI1NSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgbm9uLWhleCBjaGFyYWN0ZXJzXCIpO1xyXG4gICAgICAgICAgICBiYi52aWV3W2orK10gPSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB1dGZ4LWVtYmVkZGFibGVcclxuXHJcbiAgICAvKipcclxuICAgICAqIHV0ZngtZW1iZWRkYWJsZSAoYykgMjAxNCBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gICAgICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxyXG4gICAgICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy91dGZ4IGZvciBkZXRhaWxzXHJcbiAgICAgKi9cclxuICAgIHZhciB1dGZ4ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHV0ZnggbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIHV0ZnggPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4aW11bSB2YWxpZCBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5NQVhfQ09ERVBPSU5UID0gMHgxMEZGRkY7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgVVRGOCBjb2RlIHBvaW50cyB0byBVVEY4IGJ5dGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KCFmdW5jdGlvbigpOm51bWJlcnxudWxsKSB8IG51bWJlcn0gc3JjIENvZGUgcG9pbnRzIHNvdXJjZSwgZWl0aGVyIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiAgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0IG9yIGEgc2luZ2xlIG51bWVyaWMgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNwID0gc3JjLFxyXG4gICAgICAgICAgICAgICAgc3JjID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3AgPCAweDgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChjcCYweDdGKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNwIDwgMHg4MDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4MUYpfDB4QzApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjcCA8IDB4MTAwMDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjEyKSYweDBGKXwweEUwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+NikmMHgzRil8MHg4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTgpJjB4MDcpfDB4RjApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgzRil8MHg4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4M0YpfDB4ODApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIFVURjggYnl0ZXMgdG8gVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZVxyXG4gICAgICAgICAqICBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDb2RlIHBvaW50cyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGRlY29kZWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIHN0YXJ0aW5nIGJ5dGUgaXMgaW52YWxpZCBpbiBVVEY4XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXN0IHNlcXVlbmNlIGlzIHRydW5jYXRlZC4gSGFzIGFuIGFycmF5IHByb3BlcnR5IGBieXRlc2AgaG9sZGluZyB0aGVcclxuICAgICAgICAgKiAgcmVtYWluaW5nIGJ5dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkLCBmYWlsID0gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuc2xpY2UoMCwgYi5pbmRleE9mKG51bGwpKTtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIlRydW5jYXRlZEVycm9yXCI7XHJcbiAgICAgICAgICAgICAgICBlcnJbJ2J5dGVzJ10gPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoKGEgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYSYweDgwKSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEUwKSA9PT0gMHhDMClcclxuICAgICAgICAgICAgICAgICAgICAoKGIgPSBzcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGJdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MUYpPDw2KSB8IChiJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChhJjB4RjApID09PSAweEUwKVxyXG4gICAgICAgICAgICAgICAgICAgICgoYj1zcmMoKSkgPT09IG51bGwgfHwgKGM9c3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiLCBjXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDBGKTw8MTIpIHwgKChiJjB4M0YpPDw2KSB8IChjJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChhJjB4RjgpID09PSAweEYwKVxyXG4gICAgICAgICAgICAgICAgICAgICgoYj1zcmMoKSkgPT09IG51bGwgfHwgKGM9c3JjKCkpID09PSBudWxsIHx8IChkPXNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYiwgYyAsZF0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgwNyk8PDE4KSB8ICgoYiYweDNGKTw8MTIpIHwgKChjJjB4M0YpPDw2KSB8IChkJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RhcnRpbmcgYnl0ZTogXCIrYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEYxNiBjaGFyYWN0ZXJzIHRvIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ29kZSBwb2ludHMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY29kZVxyXG4gICAgICAgICAqICBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LlVURjE2dG9VVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGMxLCBjMiA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMxID0gYzIgIT09IG51bGwgPyBjMiA6IHNyYygpKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGlmIChjMSA+PSAweEQ4MDAgJiYgYzEgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjMiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPj0gMHhEQzAwICYmIGMyIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KChjMS0weEQ4MDApKjB4NDAwK2MyLTB4REMwMCsweDEwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyID0gbnVsbDsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkc3QoYzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gbnVsbCkgZHN0KGMyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjE2IGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpIHwgbnVtYmVyfSBzcmMgQ29kZSBwb2ludHMgc291cmNlLCBlaXRoZXIgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludFxyXG4gICAgICAgICAqICByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQgb3IgYSBzaW5nbGUgbnVtZXJpYyBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIGNvZGUgcG9pbnQgaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5VVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNwID0gc3JjLCBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgICAgIHdoaWxlIChjcCAhPT0gbnVsbCB8fCAoY3AgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjcCA8PSAweEZGRkYpXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjcCAtPSAweDEwMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3A+PjEwKSsweEQ4MDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoY3AlMHg0MDApKzB4REMwMCk7XHJcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhbmQgZW5jb2RlcyBVVEYxNiBjaGFyYWN0ZXJzIHRvIFVURjggYnl0ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgXHJcbiAgICAgICAgICogIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQnl0ZXMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdXRmeC5VVEYxNnRvVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICB1dGZ4LmVuY29kZVVURjgoY3AsIGRzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYW5kIGNvbnZlcnRzIFVURjggYnl0ZXMgdG8gVVRGMTYgY2hhcmFjdGVycy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZVxyXG4gICAgICAgICAqICBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIHN0YXJ0aW5nIGJ5dGUgaXMgaW52YWxpZCBpbiBVVEY4XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXN0IHNlcXVlbmNlIGlzIHRydW5jYXRlZC4gSGFzIGFuIGFycmF5IHByb3BlcnR5IGBieXRlc2AgaG9sZGluZyB0aGUgcmVtYWluaW5nIGJ5dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoc3JjLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgdXRmeC5VVEY4dG9VVEYxNihjcCwgZHN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gVVRGOCBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcCBVVEY4IGNvZGUgcG9pbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlQ29kZVBvaW50ID0gZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjcCA8IDB4ODApID8gMSA6IChjcCA8IDB4ODAwKSA/IDIgOiAoY3AgPCAweDEwMDAwKSA/IDMgOiA0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpfSBzcmMgQ29kZSBwb2ludHMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNvZGUgcG9pbnQgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb2RlIHBvaW50cyBsZWZ0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGOCA9IGZ1bmN0aW9uKHNyYykge1xyXG4gICAgICAgICAgICB2YXIgY3AsIGw9MDtcclxuICAgICAgICAgICAgd2hpbGUgKChjcCA9IHNyYygpKSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGwgKz0gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgICAgIHJldHVybiBsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGNvZGUgcG9pbnRzIHJlc3BlY3RpdmVseSBVVEY4IGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIFVURjE2IGNoYXIgY29kZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IFRoZSBudW1iZXIgb2YgVVRGOCBjb2RlIHBvaW50cyBhdCBpbmRleCAwIGFuZCB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWQgYXQgaW5kZXggMS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4ID0gZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICAgIHZhciBuPTAsIGw9MDtcclxuICAgICAgICAgICAgdXRmeC5VVEYxNnRvVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICArK247IGwgKz0gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gW24sbF07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHV0Zng7XHJcbiAgICB9KCk7XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL3V0ZjhcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gYW4gVVRGOCBlbmNvZGVkXHJcbiAgICAgKiAgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gSGV4IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0ID4gbGltaXRgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9VVEY4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2Q7IHRyeSB7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVnaW4gPCBlbmQgPyB0aGlzLnZpZXdbYmVnaW4rK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoYmVnaW4gIT09IGVuZClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrYmVnaW4rXCIgIT0gXCIrZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbVVURjggPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRydWUpWzFdLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSxcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gaTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBCeXRlQnVmZmVyO1xyXG59KTtcclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvYnl0ZWJ1ZmZlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3RcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxubW9kdWxlLmV4cG9ydHMgPSBDaXBoZXJCYXNlXG5pbmhlcml0cyhDaXBoZXJCYXNlLCBUcmFuc2Zvcm0pXG5mdW5jdGlvbiBDaXBoZXJCYXNlIChoYXNoTW9kZSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICB0aGlzLmhhc2hNb2RlID0gdHlwZW9mIGhhc2hNb2RlID09PSAnc3RyaW5nJ1xuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHRoaXNbaGFzaE1vZGVdID0gdGhpcy5fZmluYWxPckRpZ2VzdFxuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluYWwgPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH1cbiAgdGhpcy5fZGVjb2RlciA9IG51bGxcbiAgdGhpcy5fZW5jb2RpbmcgPSBudWxsXG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgaW5wdXRFbmMpXG4gIH1cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmIChvdXRwdXRFbmMpIHtcbiAgICBvdXREYXRhID0gdGhpcy5fdG9TdHJpbmcob3V0RGF0YSwgb3V0cHV0RW5jKVxuICB9XG4gIHJldHVybiBvdXREYXRhXG59XG5cbkNpcGhlckJhc2UucHJvdG90eXBlLnNldEF1dG9QYWRkaW5nID0gZnVuY3Rpb24gKCkge31cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuZ2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gZ2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0aFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0cnlpbmcgdG8gc2V0IGF1dGggdGFnIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QUFEID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYWFkIGluIHVuc3VwcG9ydGVkIHN0YXRlJylcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBuZXh0KSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKGRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLl91cGRhdGUoZGF0YSkpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyID0gZVxuICB9IGZpbmFsbHkge1xuICAgIG5leHQoZXJyKVxuICB9XG59XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoZG9uZSkge1xuICB2YXIgZXJyXG4gIHRyeSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgZG9uZShlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX2ZpbmFsKCkgfHwgbmV3IEJ1ZmZlcignJylcbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX3RvU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBlbmMsIGZpbikge1xuICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICAgIHRoaXMuX2VuY29kaW5nID0gZW5jXG4gIH1cbiAgaWYgKHRoaXMuX2VuY29kaW5nICE9PSBlbmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3Qgc3dpdGNoIGVuY29kaW5ncycpXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXG4gIGlmIChmaW4pIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2VcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxudmFyIHJtZDE2MCA9IHJlcXVpcmUoJ3JpcGVtZDE2MCcpXG52YXIgc2hhID0gcmVxdWlyZSgnc2hhLmpzJylcblxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbmZ1bmN0aW9uIEhhc2hOb0NvbnN0cnVjdG9yKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG4gIHRoaXMuYnVmZmVycyA9IFtdXG59XG5cbmluaGVyaXRzKEhhc2hOb0NvbnN0cnVjdG9yLCBCYXNlKVxuXG5IYXNoTm9Db25zdHJ1Y3Rvci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGRhdGEpXG59XG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycylcbiAgdmFyIHIgPSB0aGlzLl9oYXNoKGJ1ZilcbiAgdGhpcy5idWZmZXJzID0gbnVsbFxuXG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIEhhc2goaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbn1cblxuaW5oZXJpdHMoSGFzaCwgQmFzZSlcblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEpXG59XG5cbkhhc2gucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc2guZGlnZXN0KClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIYXNoIChhbGcpIHtcbiAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKClcbiAgaWYgKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3IobWQ1KVxuICBpZiAoJ3JtZDE2MCcgPT09IGFsZyB8fCAncmlwZW1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IEhhc2hOb0NvbnN0cnVjdG9yKHJtZDE2MClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2hcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG52YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2hlbHBlcnMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2hcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4xIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjb3JlX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xuXG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWQ1KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9tZDUsIDE2KTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9tZDUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2hcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoL2Jyb3dzZXInKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybVxuXG52YXIgWkVST1MgPSBuZXcgQnVmZmVyKDEyOClcblpFUk9TLmZpbGwoMClcblxuZnVuY3Rpb24gSG1hYyhhbGcsIGtleSkge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzKVxuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBuZXcgQnVmZmVyKGtleSlcbiAgfVxuXG4gIHZhciBibG9ja3NpemUgPSAoYWxnID09PSAnc2hhNTEyJyB8fCBhbGcgPT09ICdzaGEzODQnKSA/IDEyOCA6IDY0XG5cbiAgdGhpcy5fYWxnID0gYWxnXG4gIHRoaXMuX2tleSA9IGtleVxuXG4gIGlmIChrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG5cbiAgfSBlbHNlIGlmIChrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCBaRVJPU10sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gdGhpcy5faXBhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuICB2YXIgb3BhZCA9IHRoaXMuX29wYWQgPSBuZXcgQnVmZmVyKGJsb2Nrc2l6ZSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2Nrc2l6ZTsgaSsrKSB7XG4gICAgaXBhZFtpXSA9IGtleVtpXSBeIDB4MzZcbiAgICBvcGFkW2ldID0ga2V5W2ldIF4gMHg1Q1xuICB9XG5cbiAgdGhpcy5faGFzaCA9IGNyZWF0ZUhhc2goYWxnKS51cGRhdGUoaXBhZClcbn1cblxuaW5oZXJpdHMoSG1hYywgVHJhbnNmb3JtKVxuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIHRoaXMuX2hhc2gudXBkYXRlKGRhdGEsIGVuYylcblxuICByZXR1cm4gdGhpc1xufVxuXG5IbWFjLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcblxuICBuZXh0KClcbn1cblxuSG1hYy5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgdGhpcy5wdXNoKHRoaXMuZGlnZXN0KCkpXG5cbiAgbmV4dCgpXG59XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIGggPSB0aGlzLl9oYXNoLmRpZ2VzdCgpXG5cbiAgcmV0dXJuIGNyZWF0ZUhhc2godGhpcy5fYWxnKS51cGRhdGUodGhpcy5fb3BhZCkudXBkYXRlKGgpLmRpZ2VzdChlbmMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSG1hYyhhbGcsIGtleSkge1xuICByZXR1cm4gbmV3IEhtYWMoYWxnLCBrZXkpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZW5jLWJhc2U2NFwiKSwgcmVxdWlyZShcIi4vbWQ1XCIpLCByZXF1aXJlKFwiLi9ldnBrZGZcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYWVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIENCQztcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG1vZGU6IENCQyxcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVbnBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxMjgvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gY2lwaGVydGV4dCBUaGUgcmF3IGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IHNhbHQgVGhlIHNhbHQgdXNlZCB3aXRoIGEga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc2NoZW1lIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXG5cdCAgICAgKiBAcHJvcGVydHkge0Zvcm1hdH0gZm9ybWF0dGVyIFRoZSBkZWZhdWx0IGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaXBoZXJQYXJhbXMgQW4gb2JqZWN0IHdpdGggYW55IG9mIHRoZSBwb3NzaWJsZSBjaXBoZXIgcGFyYW1ldGVycy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBrZXk6IGtleVdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBhbGdvcml0aG06IENyeXB0b0pTLmFsZ28uQUVTLFxuXHQgICAgICAgICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXG5cdCAgICAgICAgICogICAgICAgICBibG9ja1NpemU6IDQsXG5cdCAgICAgICAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG5cdCAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMRm9ybWF0dGVyID0gQ19mb3JtYXQuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBvcGVuU1NMU3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wuc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gd29yZEFycmF5LnRvU3RyaW5nKEJhc2U2NCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5wYXJzZShvcGVuU1NMU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gQmFzZTY0LnBhcnNlKG9wZW5TU0xTdHIpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcblx0ICAgICAgICAgICAgaWYgKGNpcGhlcnRleHRXb3Jkc1swXSA9PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PSAweDY1NjQ1ZjVmKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHNhbHRcblx0ICAgICAgICAgICAgICAgIHZhciBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdHJvb3QuQ3J5cHRvSlMgPSBmYWN0b3J5KCk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHR2YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xuXHQgICAgLypcblx0ICAgICAqIExvY2FsIHBvbHlmaWwgb2YgT2JqZWN0LmNyZWF0ZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fTtcblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIHZhciByID0gKGZ1bmN0aW9uIChtX3cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtX3cgPSBtX3c7XG5cdCAgICAgICAgICAgICAgICB2YXIgbV96ID0gMHgzYWRlNjhiMTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYXNrID0gMHhmZmZmZmZmZjtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtX3ogPSAoMHg5MDY5ICogKG1feiAmIDB4RkZGRikgKyAobV96ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgbV93ID0gKDB4NDY1MCAqIChtX3cgJiAweEZGRkYpICsgKG1fdyA+PiAweDEwKSkgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoKG1feiA8PCAweDEwKSArIG1fdykgJiBtYXNrO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAvPSAweDEwMDAwMDAwMDtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gMC41O1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAoTWF0aC5yYW5kb20oKSA+IC41ID8gMSA6IC0xKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3IgPSByKChyY2FjaGUgfHwgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwMDAwMCk7XG5cblx0ICAgICAgICAgICAgICAgIHJjYWNoZSA9IF9yKCkgKiAweDNhZGU2N2I3O1xuXHQgICAgICAgICAgICAgICAgd29yZHMucHVzaCgoX3IoKSAqIDB4MTAwMDAwMDAwKSB8IDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xuXHQgICAgICAgICAgICBpZiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgdG8gaW5jbHVkZSBwYXJ0aWFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2Nrcyxcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBieXRlcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJ5dGVzUmVhZHkgPSBNYXRoLm1pbihuV29yZHNSZWFkeSAqIDQsIGRhdGFTaWdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBibG9ja3Ncblx0ICAgICAgICAgICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtYWxnb3JpdGhtIGxvZ2ljXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZGF0YVdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0czEgfCBiaXRzMikgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkhleDtcblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1oZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL2htYWNcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMVwiLCBcIi4vaG1hY1wiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxuXHQgICAgICAgICAgICB3aGlsZSAoZGVyaXZlZEtleVdvcmRzLmxlbmd0aCA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZXZwa2RmLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9obWFjLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgVCA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcblxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTEgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTEgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LFxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgKyAweDZlZDllYmExO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoaSA8IDgwKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGUgPSBkO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gdDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTEobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEExKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEExO1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgY3VycmVuY3lTeW1ib2xNYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG52YXIgc3ltYm9sQ3VycmVuY3lNYXAgPSB7fTtcbk9iamVjdC5rZXlzKGN1cnJlbmN5U3ltYm9sTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgc3ltYm9sQ3VycmVuY3lNYXBbY3VycmVuY3lTeW1ib2xNYXBba2V5XV0gPSBrZXlcbn0pXG5cbmZ1bmN0aW9uIGdldFN5bWJvbEZyb21DdXJyZW5jeShjdXJyZW5jeUNvZGUpIHtcbiAgaWYgKHR5cGVvZiBjdXJyZW5jeUNvZGUgIT09ICdzdHJpbmcnKSByZXR1cm4gdW5kZWZpbmVkXG4gIHZhciBjb2RlID0gY3VycmVuY3lDb2RlLnRvVXBwZXJDYXNlKCk7XG4gIGlmICghY3VycmVuY3lTeW1ib2xNYXAuaGFzT3duUHJvcGVydHkoY29kZSkpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIGN1cnJlbmN5U3ltYm9sTWFwW2NvZGVdO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW5jeUZyb21TeW1ib2woc3ltYm9sKSB7XG4gIGlmICghc3ltYm9sQ3VycmVuY3lNYXAuaGFzT3duUHJvcGVydHkoc3ltYm9sKSkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gc3ltYm9sQ3VycmVuY3lNYXBbc3ltYm9sXVxufVxuXG5mdW5jdGlvbiBnZXRTeW1ib2woY3VycmVuY3lDb2RlKSB7XG4gIGlmICh0eXBlb2YgY3VycmVuY3lDb2RlICE9PSAnc3RyaW5nJykgcmV0dXJuICc/J1xuICB2YXIgc3ltYm9sID0gZ2V0U3ltYm9sRnJvbUN1cnJlbmN5KGN1cnJlbmN5Q29kZS50b1VwcGVyQ2FzZSgpKVxuICByZXR1cm4gc3ltYm9sICE9PSB1bmRlZmluZWQgPyBzeW1ib2wgOiAnPydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xcbm1vZHVsZS5leHBvcnRzLmdldFN5bWJvbEZyb21DdXJyZW5jeSA9IGdldFN5bWJvbEZyb21DdXJyZW5jeVxubW9kdWxlLmV4cG9ydHMuZ2V0Q3VycmVuY3lGcm9tU3ltYm9sID0gZ2V0Q3VycmVuY3lGcm9tU3ltYm9sXG5tb2R1bGUuZXhwb3J0cy5zeW1ib2xDdXJyZW5jeU1hcCA9IHN5bWJvbEN1cnJlbmN5TWFwXG5tb2R1bGUuZXhwb3J0cy5jdXJyZW5jeVN5bWJvbE1hcCA9IGN1cnJlbmN5U3ltYm9sTWFwXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXAvY3VycmVuY3ktc3ltYm9sLW1hcC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPVxueyBcIkFMTFwiOiBcIkxcIlxuLCBcIkFGTlwiOiBcItiLXCJcbiwgXCJBUlNcIjogXCIkXCJcbiwgXCJBV0dcIjogXCLGklwiXG4sIFwiQVVEXCI6IFwiJFwiXG4sIFwiQVpOXCI6IFwi4oK8XCJcbiwgXCJCU0RcIjogXCIkXCJcbiwgXCJCQkRcIjogXCIkXCJcbiwgXCJCWVJcIjogXCJwLlwiXG4sIFwiQlpEXCI6IFwiQlokXCJcbiwgXCJCTURcIjogXCIkXCJcbiwgXCJCT0JcIjogXCJCcy5cIlxuLCBcIkJBTVwiOiBcIktNXCJcbiwgXCJCV1BcIjogXCJQXCJcbiwgXCJCR05cIjogXCLQu9CyXCJcbiwgXCJCUkxcIjogXCJSJFwiXG4sIFwiQk5EXCI6IFwiJFwiXG4sIFwiQlRDXCI6IFwiyYNcIlxuLCBcIktIUlwiOiBcIuGfm1wiXG4sIFwiQ0FEXCI6IFwiJFwiXG4sIFwiS1lEXCI6IFwiJFwiXG4sIFwiQ0xQXCI6IFwiJFwiXG4sIFwiQ05ZXCI6IFwiwqVcIlxuLCBcIkNPUFwiOiBcIiRcIlxuLCBcIkNSQ1wiOiBcIuKCoVwiXG4sIFwiSFJLXCI6IFwia25cIlxuLCBcIkNVUFwiOiBcIuKCsVwiXG4sIFwiQ1pLXCI6IFwiS8SNXCJcbiwgXCJES0tcIjogXCJrclwiXG4sIFwiRE9QXCI6IFwiUkQkXCJcbiwgXCJYQ0RcIjogXCIkXCJcbiwgXCJFR1BcIjogXCLCo1wiXG4sIFwiU1ZDXCI6IFwiJFwiXG4sIFwiRUVLXCI6IFwia3JcIlxuLCBcIkVVUlwiOiBcIuKCrFwiXG4sIFwiRktQXCI6IFwiwqNcIlxuLCBcIkZKRFwiOiBcIiRcIlxuLCBcIkdIQ1wiOiBcIuKCtVwiXG4sIFwiR0lQXCI6IFwiwqNcIlxuLCBcIkdUUVwiOiBcIlFcIlxuLCBcIkdHUFwiOiBcIsKjXCJcbiwgXCJHWURcIjogXCIkXCJcbiwgXCJITkxcIjogXCJMXCJcbiwgXCJIS0RcIjogXCIkXCJcbiwgXCJIVUZcIjogXCJGdFwiXG4sIFwiSVNLXCI6IFwia3JcIlxuLCBcIklOUlwiOiBcIuKCuVwiXG4sIFwiSURSXCI6IFwiUnBcIlxuLCBcIklSUlwiOiBcIu+3vFwiXG4sIFwiSU1QXCI6IFwiwqNcIlxuLCBcIklMU1wiOiBcIuKCqlwiXG4sIFwiSk1EXCI6IFwiSiRcIlxuLCBcIkpQWVwiOiBcIsKlXCJcbiwgXCJKRVBcIjogXCLCo1wiXG4sIFwiS0VTXCI6IFwiS1NoXCJcbiwgXCJLWlRcIjogXCLQu9CyXCJcbiwgXCJLUFdcIjogXCLigqlcIlxuLCBcIktSV1wiOiBcIuKCqVwiXG4sIFwiS0dTXCI6IFwi0LvQslwiXG4sIFwiTEFLXCI6IFwi4oKtXCJcbiwgXCJMVkxcIjogXCJMc1wiXG4sIFwiTEJQXCI6IFwiwqNcIlxuLCBcIkxSRFwiOiBcIiRcIlxuLCBcIkxUTFwiOiBcIkx0XCJcbiwgXCJNS0RcIjogXCLQtNC10L1cIlxuLCBcIk1ZUlwiOiBcIlJNXCJcbiwgXCJNVVJcIjogXCLigqhcIlxuLCBcIk1YTlwiOiBcIiRcIlxuLCBcIk1OVFwiOiBcIuKCrlwiXG4sIFwiTVpOXCI6IFwiTVRcIlxuLCBcIk5BRFwiOiBcIiRcIlxuLCBcIk5QUlwiOiBcIuKCqFwiXG4sIFwiQU5HXCI6IFwixpJcIlxuLCBcIk5aRFwiOiBcIiRcIlxuLCBcIk5JT1wiOiBcIkMkXCJcbiwgXCJOR05cIjogXCLigqZcIlxuLCBcIk5PS1wiOiBcImtyXCJcbiwgXCJPTVJcIjogXCLvt7xcIlxuLCBcIlBLUlwiOiBcIuKCqFwiXG4sIFwiUEFCXCI6IFwiQi8uXCJcbiwgXCJQWUdcIjogXCJHc1wiXG4sIFwiUEVOXCI6IFwiUy8uXCJcbiwgXCJQSFBcIjogXCLigrFcIlxuLCBcIlBMTlwiOiBcInrFglwiXG4sIFwiUUFSXCI6IFwi77e8XCJcbiwgXCJST05cIjogXCJsZWlcIlxuLCBcIlJVQlwiOiBcIuKCvVwiXG4sIFwiUk1CXCI6IFwi77+lXCJcbiwgXCJTSFBcIjogXCLCo1wiXG4sIFwiU0FSXCI6IFwi77e8XCJcbiwgXCJSU0RcIjogXCLQlNC40L0uXCJcbiwgXCJTQ1JcIjogXCLigqhcIlxuLCBcIlNHRFwiOiBcIiRcIlxuLCBcIlNCRFwiOiBcIiRcIlxuLCBcIlNPU1wiOiBcIlNcIlxuLCBcIlpBUlwiOiBcIlJcIlxuLCBcIkxLUlwiOiBcIuKCqFwiXG4sIFwiU0VLXCI6IFwia3JcIlxuLCBcIkNIRlwiOiBcIkNIRlwiXG4sIFwiU1JEXCI6IFwiJFwiXG4sIFwiU1lQXCI6IFwiwqNcIlxuLCBcIlRaU1wiOiBcIlRTaFwiXG4sIFwiVFdEXCI6IFwiTlQkXCJcbiwgXCJUSEJcIjogXCLguL9cIlxuLCBcIlRURFwiOiBcIlRUJFwiXG4sIFwiVFJZXCI6IFwi4oK6XCJcbiwgXCJUUkxcIjogXCLigqRcIlxuLCBcIlRWRFwiOiBcIiRcIlxuLCBcIlVHWFwiOiBcIlVTaFwiXG4sIFwiVUFIXCI6IFwi4oK0XCJcbiwgXCJHQlBcIjogXCLCo1wiXG4sIFwiVVNEXCI6IFwiJFwiXG4sIFwiVVlVXCI6IFwiJFVcIlxuLCBcIlVaU1wiOiBcItC70LJcIlxuLCBcIlZFRlwiOiBcIkJzXCJcbiwgXCJWTkRcIjogXCLigqtcIlxuLCBcIllFUlwiOiBcIu+3vFwiXG4sIFwiWldEXCI6IFwiWiRcIlxuLCBcIkdFTFwiOiBcIuKCvlwiXG4sIFwiS1pUXCI6IFwi4oK4XCJcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3VycmVuY3ktc3ltYm9sLW1hcC9tYXAuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3VycmVuY3ktc3ltYm9sLW1hcFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0J1xyXG5cclxuLyoqXHJcbiAqIERpZmYgTWF0Y2ggYW5kIFBhdGNoXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDA2IEdvb2dsZSBJbmMuXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC9cclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHRleHRzIHRvIGNyZWF0ZSBhIHBhdGNoLlxyXG4gKiBBcHBsaWVzIHRoZSBwYXRjaCBvbnRvIGFub3RoZXIgdGV4dCwgYWxsb3dpbmcgZm9yIGVycm9ycy5cclxuICogQGF1dGhvciBmcmFzZXJAZ29vZ2xlLmNvbSAoTmVpbCBGcmFzZXIpXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGNvbnRhaW5pbmcgdGhlIGRpZmYsIG1hdGNoIGFuZCBwYXRjaCBtZXRob2RzLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIGRpZmZfbWF0Y2hfcGF0Y2goKSB7XHJcblxyXG4gIC8vIERlZmF1bHRzLlxyXG4gIC8vIFJlZGVmaW5lIHRoZXNlIGluIHlvdXIgcHJvZ3JhbSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXHJcblxyXG4gIC8vIE51bWJlciBvZiBzZWNvbmRzIHRvIG1hcCBhIGRpZmYgYmVmb3JlIGdpdmluZyB1cCAoMCBmb3IgaW5maW5pdHkpLlxyXG4gIHRoaXMuRGlmZl9UaW1lb3V0ID0gMS4wO1xyXG4gIC8vIENvc3Qgb2YgYW4gZW1wdHkgZWRpdCBvcGVyYXRpb24gaW4gdGVybXMgb2YgZWRpdCBjaGFyYWN0ZXJzLlxyXG4gIHRoaXMuRGlmZl9FZGl0Q29zdCA9IDQ7XHJcbiAgLy8gQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXHJcbiAgdGhpcy5NYXRjaF9UaHJlc2hvbGQgPSAwLjU7XHJcbiAgLy8gSG93IGZhciB0byBzZWFyY2ggZm9yIGEgbWF0Y2ggKDAgPSBleGFjdCBsb2NhdGlvbiwgMTAwMCsgPSBicm9hZCBtYXRjaCkuXHJcbiAgLy8gQSBtYXRjaCB0aGlzIG1hbnkgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGV4cGVjdGVkIGxvY2F0aW9uIHdpbGwgYWRkXHJcbiAgLy8gMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXHJcbiAgdGhpcy5NYXRjaF9EaXN0YW5jZSA9IDEwMDA7XHJcbiAgLy8gV2hlbiBkZWxldGluZyBhIGxhcmdlIGJsb2NrIG9mIHRleHQgKG92ZXIgfjY0IGNoYXJhY3RlcnMpLCBob3cgY2xvc2UgZG9cclxuICAvLyB0aGUgY29udGVudHMgaGF2ZSB0byBiZSB0byBtYXRjaCB0aGUgZXhwZWN0ZWQgY29udGVudHMuICgwLjAgPSBwZXJmZWN0aW9uLFxyXG4gIC8vIDEuMCA9IHZlcnkgbG9vc2UpLiAgTm90ZSB0aGF0IE1hdGNoX1RocmVzaG9sZCBjb250cm9scyBob3cgY2xvc2VseSB0aGVcclxuICAvLyBlbmQgcG9pbnRzIG9mIGEgZGVsZXRlIG5lZWQgdG8gbWF0Y2guXHJcbiAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQgPSAwLjU7XHJcbiAgLy8gQ2h1bmsgc2l6ZSBmb3IgY29udGV4dCBsZW5ndGguXHJcbiAgdGhpcy5QYXRjaF9NYXJnaW4gPSA0O1xyXG5cclxuICAvLyBUaGUgbnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50LlxyXG4gIHRoaXMuTWF0Y2hfTWF4Qml0cyA9IDMyO1xyXG59XHJcblxyXG5cclxuLy8gIERJRkYgRlVOQ1RJT05TXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBkYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgYSBkaWZmIGlzIGFuIGFycmF5IG9mIHR1cGxlczpcclxuICogW1tESUZGX0RFTEVURSwgJ0hlbGxvJ10sIFtESUZGX0lOU0VSVCwgJ0dvb2RieWUnXSwgW0RJRkZfRVFVQUwsICcgd29ybGQuJ11dXHJcbiAqIHdoaWNoIG1lYW5zOiBkZWxldGUgJ0hlbGxvJywgYWRkICdHb29kYnllJyBhbmQga2VlcCAnIHdvcmxkLidcclxuICovXHJcbnZhciBESUZGX0RFTEVURSA9IC0xO1xyXG52YXIgRElGRl9JTlNFUlQgPSAxO1xyXG52YXIgRElGRl9FUVVBTCA9IDA7XHJcblxyXG4vKiogQHR5cGVkZWYge3swOiBudW1iZXIsIDE6IHN0cmluZ319ICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2guRGlmZjtcclxuXHJcblxyXG4vKipcclxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBTaW1wbGlmaWVzIHRoZSBwcm9ibGVtIGJ5IHN0cmlwcGluZ1xyXG4gKiBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXggb2ZmIHRoZSB0ZXh0cyBiZWZvcmUgZGlmZmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9jaGVja2xpbmVzIE9wdGlvbmFsIHNwZWVkdXAgZmxhZy4gSWYgcHJlc2VudCBhbmQgZmFsc2UsXHJcbiAqICAgICB0aGVuIGRvbid0IHJ1biBhIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cclxuICogICAgIERlZmF1bHRzIHRvIHRydWUsIHdoaWNoIGRvZXMgYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0X2RlYWRsaW5lIE9wdGlvbmFsIHRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGVcclxuICogICAgIGJ5LiAgVXNlZCBpbnRlcm5hbGx5IGZvciByZWN1cnNpdmUgY2FsbHMuICBVc2VycyBzaG91bGQgc2V0IERpZmZUaW1lb3V0XHJcbiAqICAgICBpbnN0ZWFkLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbWFpbiA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Miwgb3B0X2NoZWNrbGluZXMsXHJcbiAgICBvcHRfZGVhZGxpbmUpIHtcclxuICAvLyBTZXQgYSBkZWFkbGluZSBieSB3aGljaCB0aW1lIHRoZSBkaWZmIG11c3QgYmUgY29tcGxldGUuXHJcbiAgaWYgKHR5cGVvZiBvcHRfZGVhZGxpbmUgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0aGlzLkRpZmZfVGltZW91dCA8PSAwKSB7XHJcbiAgICAgIG9wdF9kZWFkbGluZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvcHRfZGVhZGxpbmUgPSAobmV3IERhdGUpLmdldFRpbWUoKSArIHRoaXMuRGlmZl9UaW1lb3V0ICogMTAwMDtcclxuICAgIH1cclxuICB9XHJcbiAgdmFyIGRlYWRsaW5lID0gb3B0X2RlYWRsaW5lO1xyXG5cclxuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXHJcbiAgaWYgKHRleHQxID09IG51bGwgfHwgdGV4dDIgPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAoZGlmZl9tYWluKScpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgZm9yIGVxdWFsaXR5IChzcGVlZHVwKS5cclxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcclxuICAgIGlmICh0ZXh0MSkge1xyXG4gICAgICByZXR1cm4gW1tESUZGX0VRVUFMLCB0ZXh0MV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBvcHRfY2hlY2tsaW5lcyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgb3B0X2NoZWNrbGluZXMgPSB0cnVlO1xyXG4gIH1cclxuICB2YXIgY2hlY2tsaW5lcyA9IG9wdF9jaGVja2xpbmVzO1xyXG5cclxuICAvLyBUcmltIG9mZiBjb21tb24gcHJlZml4IChzcGVlZHVwKS5cclxuICB2YXIgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xyXG4gIHZhciBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcclxuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xyXG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XHJcblxyXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBzdWZmaXggKHNwZWVkdXApLlxyXG4gIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dDEsIHRleHQyKTtcclxuICB2YXIgY29tbW9uc3VmZml4ID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcclxuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xyXG5cclxuICAvLyBDb21wdXRlIHRoZSBkaWZmIG9uIHRoZSBtaWRkbGUgYmxvY2suXHJcbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX2NvbXB1dGVfKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xyXG5cclxuICAvLyBSZXN0b3JlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cclxuICBpZiAoY29tbW9ucHJlZml4KSB7XHJcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBjb21tb25wcmVmaXhdKTtcclxuICB9XHJcbiAgaWYgKGNvbW1vbnN1ZmZpeCkge1xyXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSk7XHJcbiAgfVxyXG4gIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIHJldHVybiBkaWZmcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmluZCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGV4dHMuICBBc3N1bWVzIHRoYXQgdGhlIHRleHRzIGRvIG5vdFxyXG4gKiBoYXZlIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tsaW5lcyBTcGVlZHVwIGZsYWcuICBJZiBmYWxzZSwgdGhlbiBkb24ndCBydW4gYVxyXG4gKiAgICAgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxyXG4gKiAgICAgSWYgdHJ1ZSwgdGhlbiBydW4gYSBmYXN0ZXIsIHNsaWdodGx5IGxlc3Mgb3B0aW1hbCBkaWZmLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbXB1dGVfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBjaGVja2xpbmVzLFxyXG4gICAgZGVhZGxpbmUpIHtcclxuICB2YXIgZGlmZnM7XHJcblxyXG4gIGlmICghdGV4dDEpIHtcclxuICAgIC8vIEp1c3QgYWRkIHNvbWUgdGV4dCAoc3BlZWR1cCkuXHJcbiAgICByZXR1cm4gW1tESUZGX0lOU0VSVCwgdGV4dDJdXTtcclxuICB9XHJcblxyXG4gIGlmICghdGV4dDIpIHtcclxuICAgIC8vIEp1c3QgZGVsZXRlIHNvbWUgdGV4dCAoc3BlZWR1cCkuXHJcbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcclxuICB9XHJcblxyXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XHJcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XHJcbiAgdmFyIGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XHJcbiAgaWYgKGkgIT0gLTEpIHtcclxuICAgIC8vIFNob3J0ZXIgdGV4dCBpcyBpbnNpZGUgdGhlIGxvbmdlciB0ZXh0IChzcGVlZHVwKS5cclxuICAgIGRpZmZzID0gW1tESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpXSxcclxuICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLFxyXG4gICAgICAgICAgICAgW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHNob3J0dGV4dC5sZW5ndGgpXV07XHJcbiAgICAvLyBTd2FwIGluc2VydGlvbnMgZm9yIGRlbGV0aW9ucyBpZiBkaWZmIGlzIHJldmVyc2VkLlxyXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xyXG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlmZnM7XHJcbiAgfVxyXG5cclxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAvLyBTaW5nbGUgY2hhcmFjdGVyIHN0cmluZy5cclxuICAgIC8vIEFmdGVyIHRoZSBwcmV2aW91cyBzcGVlZHVwLCB0aGUgY2hhcmFjdGVyIGNhbid0IGJlIGFuIGVxdWFsaXR5LlxyXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBwcm9ibGVtIGNhbiBiZSBzcGxpdCBpbiB0d28uXHJcbiAgdmFyIGhtID0gdGhpcy5kaWZmX2hhbGZNYXRjaF8odGV4dDEsIHRleHQyKTtcclxuICBpZiAoaG0pIHtcclxuICAgIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cclxuICAgIHZhciB0ZXh0MV9hID0gaG1bMF07XHJcbiAgICB2YXIgdGV4dDFfYiA9IGhtWzFdO1xyXG4gICAgdmFyIHRleHQyX2EgPSBobVsyXTtcclxuICAgIHZhciB0ZXh0Ml9iID0gaG1bM107XHJcbiAgICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xyXG4gICAgLy8gU2VuZCBib3RoIHBhaXJzIG9mZiBmb3Igc2VwYXJhdGUgcHJvY2Vzc2luZy5cclxuICAgIHZhciBkaWZmc19hID0gdGhpcy5kaWZmX21haW4odGV4dDFfYSwgdGV4dDJfYSwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xyXG4gICAgdmFyIGRpZmZzX2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MV9iLCB0ZXh0Ml9iLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XHJcbiAgICAvLyBNZXJnZSB0aGUgcmVzdWx0cy5cclxuICAgIHJldHVybiBkaWZmc19hLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZF9jb21tb25dXSwgZGlmZnNfYik7XHJcbiAgfVxyXG5cclxuICBpZiAoY2hlY2tsaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaWZmX2xpbmVNb2RlXyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0Xyh0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRG8gYSBxdWljayBsaW5lLWxldmVsIGRpZmYgb24gYm90aCBzdHJpbmdzLCB0aGVuIHJlZGlmZiB0aGUgcGFydHMgZm9yXHJcbiAqIGdyZWF0ZXIgYWNjdXJhY3kuXHJcbiAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlIGJ5LlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZU1vZGVfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xyXG4gIC8vIFNjYW4gdGhlIHRleHQgb24gYSBsaW5lLWJ5LWxpbmUgYmFzaXMgZmlyc3QuXHJcbiAgdmFyIGEgPSB0aGlzLmRpZmZfbGluZXNUb0NoYXJzXyh0ZXh0MSwgdGV4dDIpO1xyXG4gIHRleHQxID0gYS5jaGFyczE7XHJcbiAgdGV4dDIgPSBhLmNoYXJzMjtcclxuICB2YXIgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XHJcblxyXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UsIGRlYWRsaW5lKTtcclxuXHJcbiAgLy8gQ29udmVydCB0aGUgZGlmZiBiYWNrIHRvIG9yaWdpbmFsIHRleHQuXHJcbiAgdGhpcy5kaWZmX2NoYXJzVG9MaW5lc18oZGlmZnMsIGxpbmVhcnJheSk7XHJcbiAgLy8gRWxpbWluYXRlIGZyZWFrIG1hdGNoZXMgKGUuZy4gYmxhbmsgbGluZXMpXHJcbiAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XHJcblxyXG4gIC8vIFJlZGlmZiBhbnkgcmVwbGFjZW1lbnQgYmxvY2tzLCB0aGlzIHRpbWUgY2hhcmFjdGVyLWJ5LWNoYXJhY3Rlci5cclxuICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxyXG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7XHJcbiAgdmFyIHBvaW50ZXIgPSAwO1xyXG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xyXG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xyXG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XHJcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgY291bnRfZGVsZXRlKys7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxyXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xyXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XHJcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydDtcclxuICAgICAgICAgIHZhciBhID0gdGhpcy5kaWZmX21haW4odGV4dF9kZWxldGUsIHRleHRfaW5zZXJ0LCBmYWxzZSwgZGVhZGxpbmUpO1xyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IGEubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGFbal0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgKyBhLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcclxuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xyXG4gICAgICAgIHRleHRfZGVsZXRlID0gJyc7XHJcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcbiAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXHJcblxyXG4gIHJldHVybiBkaWZmcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmluZCB0aGUgJ21pZGRsZSBzbmFrZScgb2YgYSBkaWZmLCBzcGxpdCB0aGUgcHJvYmxlbSBpbiB0d29cclxuICogYW5kIHJldHVybiB0aGUgcmVjdXJzaXZlbHkgY29uc3RydWN0ZWQgZGlmZi5cclxuICogU2VlIE15ZXJzIDE5ODYgcGFwZXI6IEFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBJdHMgVmFyaWF0aW9ucy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIGF0IHdoaWNoIHRvIGJhaWwgaWYgbm90IHlldCBjb21wbGV0ZS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XHJcbiAgLy8gQ2FjaGUgdGhlIHRleHQgbGVuZ3RocyB0byBwcmV2ZW50IG11bHRpcGxlIGNhbGxzLlxyXG4gIHZhciB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XHJcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcclxuICB2YXIgbWF4X2QgPSBNYXRoLmNlaWwoKHRleHQxX2xlbmd0aCArIHRleHQyX2xlbmd0aCkgLyAyKTtcclxuICB2YXIgdl9vZmZzZXQgPSBtYXhfZDtcclxuICB2YXIgdl9sZW5ndGggPSAyICogbWF4X2Q7XHJcbiAgdmFyIHYxID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcclxuICB2YXIgdjIgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xyXG4gIC8vIFNldHRpbmcgYWxsIGVsZW1lbnRzIHRvIC0xIGlzIGZhc3RlciBpbiBDaHJvbWUgJiBGaXJlZm94IHRoYW4gbWl4aW5nXHJcbiAgLy8gaW50ZWdlcnMgYW5kIHVuZGVmaW5lZC5cclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZfbGVuZ3RoOyB4KyspIHtcclxuICAgIHYxW3hdID0gLTE7XHJcbiAgICB2Mlt4XSA9IC0xO1xyXG4gIH1cclxuICB2MVt2X29mZnNldCArIDFdID0gMDtcclxuICB2Mlt2X29mZnNldCArIDFdID0gMDtcclxuICB2YXIgZGVsdGEgPSB0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGg7XHJcbiAgLy8gSWYgdGhlIHRvdGFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIGlzIG9kZCwgdGhlbiB0aGUgZnJvbnQgcGF0aCB3aWxsIGNvbGxpZGVcclxuICAvLyB3aXRoIHRoZSByZXZlcnNlIHBhdGguXHJcbiAgdmFyIGZyb250ID0gKGRlbHRhICUgMiAhPSAwKTtcclxuICAvLyBPZmZzZXRzIGZvciBzdGFydCBhbmQgZW5kIG9mIGsgbG9vcC5cclxuICAvLyBQcmV2ZW50cyBtYXBwaW5nIG9mIHNwYWNlIGJleW9uZCB0aGUgZ3JpZC5cclxuICB2YXIgazFzdGFydCA9IDA7XHJcbiAgdmFyIGsxZW5kID0gMDtcclxuICB2YXIgazJzdGFydCA9IDA7XHJcbiAgdmFyIGsyZW5kID0gMDtcclxuICBmb3IgKHZhciBkID0gMDsgZCA8IG1heF9kOyBkKyspIHtcclxuICAgIC8vIEJhaWwgb3V0IGlmIGRlYWRsaW5lIGlzIHJlYWNoZWQuXHJcbiAgICBpZiAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IGRlYWRsaW5lKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdhbGsgdGhlIGZyb250IHBhdGggb25lIHN0ZXAuXHJcbiAgICBmb3IgKHZhciBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XHJcbiAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGsxO1xyXG4gICAgICB2YXIgeDE7XHJcbiAgICAgIGlmIChrMSA9PSAtZCB8fCAoazEgIT0gZCAmJiB2MVtrMV9vZmZzZXQgLSAxXSA8IHYxW2sxX29mZnNldCArIDFdKSkge1xyXG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0ICsgMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgLSAxXSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHkxID0geDEgLSBrMTtcclxuICAgICAgd2hpbGUgKHgxIDwgdGV4dDFfbGVuZ3RoICYmIHkxIDwgdGV4dDJfbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQoeDEpID09IHRleHQyLmNoYXJBdCh5MSkpIHtcclxuICAgICAgICB4MSsrO1xyXG4gICAgICAgIHkxKys7XHJcbiAgICAgIH1cclxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xyXG4gICAgICBpZiAoeDEgPiB0ZXh0MV9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSByaWdodCBvZiB0aGUgZ3JhcGguXHJcbiAgICAgICAgazFlbmQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmICh5MSA+IHRleHQyX2xlbmd0aCkge1xyXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGJvdHRvbSBvZiB0aGUgZ3JhcGguXHJcbiAgICAgICAgazFzdGFydCArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKGZyb250KSB7XHJcbiAgICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMTtcclxuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPSAtMSkge1xyXG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgICAgICB2YXIgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xyXG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XHJcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2FsayB0aGUgcmV2ZXJzZSBwYXRoIG9uZSBzdGVwLlxyXG4gICAgZm9yICh2YXIgazIgPSAtZCArIGsyc3RhcnQ7IGsyIDw9IGQgLSBrMmVuZDsgazIgKz0gMikge1xyXG4gICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMjtcclxuICAgICAgdmFyIHgyO1xyXG4gICAgICBpZiAoazIgPT0gLWQgfHwgKGsyICE9IGQgJiYgdjJbazJfb2Zmc2V0IC0gMV0gPCB2MltrMl9vZmZzZXQgKyAxXSkpIHtcclxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCArIDFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB5MiA9IHgyIC0gazI7XHJcbiAgICAgIHdoaWxlICh4MiA8IHRleHQxX2xlbmd0aCAmJiB5MiA8IHRleHQyX2xlbmd0aCAmJlxyXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHgyIC0gMSkgPT1cclxuICAgICAgICAgICAgIHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpKSB7XHJcbiAgICAgICAgeDIrKztcclxuICAgICAgICB5MisrO1xyXG4gICAgICB9XHJcbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcclxuICAgICAgaWYgKHgyID4gdGV4dDFfbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgbGVmdCBvZiB0aGUgZ3JhcGguXHJcbiAgICAgICAgazJlbmQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmICh5MiA+IHRleHQyX2xlbmd0aCkge1xyXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHRvcCBvZiB0aGUgZ3JhcGguXHJcbiAgICAgICAgazJzdGFydCArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKCFmcm9udCkge1xyXG4gICAgICAgIHZhciBrMV9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazI7XHJcbiAgICAgICAgaWYgKGsxX29mZnNldCA+PSAwICYmIGsxX29mZnNldCA8IHZfbGVuZ3RoICYmIHYxW2sxX29mZnNldF0gIT0gLTEpIHtcclxuICAgICAgICAgIHZhciB4MSA9IHYxW2sxX29mZnNldF07XHJcbiAgICAgICAgICB2YXIgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xyXG4gICAgICAgICAgLy8gTWlycm9yIHgyIG9udG8gdG9wLWxlZnQgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgICAgICB4MiA9IHRleHQxX2xlbmd0aCAtIHgyO1xyXG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XHJcbiAgICAgICAgICAgIC8vIE92ZXJsYXAgZGV0ZWN0ZWQuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpZmZfYmlzZWN0U3BsaXRfKHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIERpZmYgdG9vayB0b28gbG9uZyBhbmQgaGl0IHRoZSBkZWFkbGluZSBvclxyXG4gIC8vIG51bWJlciBvZiBkaWZmcyBlcXVhbHMgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIG5vIGNvbW1vbmFsaXR5IGF0IGFsbC5cclxuICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBsb2NhdGlvbiBvZiB0aGUgJ21pZGRsZSBzbmFrZScsIHNwbGl0IHRoZSBkaWZmIGluIHR3byBwYXJ0c1xyXG4gKiBhbmQgcmVjdXJzZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIE9sZCBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgTmV3IHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQxLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geSBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0Mi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfYmlzZWN0U3BsaXRfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCB4LCB5LFxyXG4gICAgZGVhZGxpbmUpIHtcclxuICB2YXIgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xyXG4gIHZhciB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XHJcbiAgdmFyIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcclxuICB2YXIgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xyXG5cclxuICAvLyBDb21wdXRlIGJvdGggZGlmZnMgc2VyaWFsbHkuXHJcbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDFhLCB0ZXh0MmEsIGZhbHNlLCBkZWFkbGluZSk7XHJcbiAgdmFyIGRpZmZzYiA9IHRoaXMuZGlmZl9tYWluKHRleHQxYiwgdGV4dDJiLCBmYWxzZSwgZGVhZGxpbmUpO1xyXG5cclxuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFNwbGl0IHR3byB0ZXh0cyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXHJcbiAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHt7Y2hhcnMxOiBzdHJpbmcsIGNoYXJzMjogc3RyaW5nLCBsaW5lQXJyYXk6ICFBcnJheS48c3RyaW5nPn19XHJcbiAqICAgICBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZW5jb2RlZCB0ZXh0MSwgdGhlIGVuY29kZWQgdGV4dDIgYW5kXHJcbiAqICAgICB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXHJcbiAqICAgICBUaGUgemVyb3RoIGVsZW1lbnQgb2YgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzIGlzIGludGVudGlvbmFsbHkgYmxhbmsuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVzVG9DaGFyc18gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICB2YXIgbGluZUFycmF5ID0gW107ICAvLyBlLmcuIGxpbmVBcnJheVs0XSA9PSAnSGVsbG9cXG4nXHJcbiAgdmFyIGxpbmVIYXNoID0ge307ICAgLy8gZS5nLiBsaW5lSGFzaFsnSGVsbG9cXG4nXSA9PSA0XHJcblxyXG4gIC8vICdcXHgwMCcgaXMgYSB2YWxpZCBjaGFyYWN0ZXIsIGJ1dCB2YXJpb3VzIGRlYnVnZ2VycyBkb24ndCBsaWtlIGl0LlxyXG4gIC8vIFNvIHdlJ2xsIGluc2VydCBhIGp1bmsgZW50cnkgdG8gYXZvaWQgZ2VuZXJhdGluZyBhIG51bGwgY2hhcmFjdGVyLlxyXG4gIGxpbmVBcnJheVswXSA9ICcnO1xyXG5cclxuICAvKipcclxuICAgKiBTcGxpdCBhIHRleHQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxyXG4gICAqIGhhc2hlcyB3aGVyZSBlYWNoIFVuaWNvZGUgY2hhcmFjdGVyIHJlcHJlc2VudHMgb25lIGxpbmUuXHJcbiAgICogTW9kaWZpZXMgbGluZWFycmF5IGFuZCBsaW5laGFzaCB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTdHJpbmcgdG8gZW5jb2RlLlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRW5jb2RlZCBzdHJpbmcuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBkaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0KSB7XHJcbiAgICB2YXIgY2hhcnMgPSAnJztcclxuICAgIC8vIFdhbGsgdGhlIHRleHQsIHB1bGxpbmcgb3V0IGEgc3Vic3RyaW5nIGZvciBlYWNoIGxpbmUuXHJcbiAgICAvLyB0ZXh0LnNwbGl0KCdcXG4nKSB3b3VsZCB3b3VsZCB0ZW1wb3JhcmlseSBkb3VibGUgb3VyIG1lbW9yeSBmb290cHJpbnQuXHJcbiAgICAvLyBNb2RpZnlpbmcgdGV4dCB3b3VsZCBjcmVhdGUgbWFueSBsYXJnZSBzdHJpbmdzIHRvIGdhcmJhZ2UgY29sbGVjdC5cclxuICAgIHZhciBsaW5lU3RhcnQgPSAwO1xyXG4gICAgdmFyIGxpbmVFbmQgPSAtMTtcclxuICAgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyaWFibGUgaXMgZmFzdGVyIHRoYW4gbG9va2luZyBpdCB1cC5cclxuICAgIHZhciBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgbGluZUVuZCA9IHRleHQuaW5kZXhPZignXFxuJywgbGluZVN0YXJ0KTtcclxuICAgICAgaWYgKGxpbmVFbmQgPT0gLTEpIHtcclxuICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XHJcbiAgICAgIGxpbmVTdGFydCA9IGxpbmVFbmQgKyAxO1xyXG5cclxuICAgICAgaWYgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOlxyXG4gICAgICAgICAgKGxpbmVIYXNoW2xpbmVdICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lSGFzaFtsaW5lXSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xyXG4gICAgICAgIGxpbmVIYXNoW2xpbmVdID0gbGluZUFycmF5TGVuZ3RoO1xyXG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhcnM7XHJcbiAgfVxyXG5cclxuICB2YXIgY2hhcnMxID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDEpO1xyXG4gIHZhciBjaGFyczIgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0Mik7XHJcbiAgcmV0dXJuIHtjaGFyczE6IGNoYXJzMSwgY2hhcnMyOiBjaGFyczIsIGxpbmVBcnJheTogbGluZUFycmF5fTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVoeWRyYXRlIHRoZSB0ZXh0IGluIGEgZGlmZiBmcm9tIGEgc3RyaW5nIG9mIGxpbmUgaGFzaGVzIHRvIHJlYWwgbGluZXMgb2ZcclxuICogdGV4dC5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGxpbmVBcnJheSBBcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2hhcnNUb0xpbmVzXyA9IGZ1bmN0aW9uKGRpZmZzLCBsaW5lQXJyYXkpIHtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgY2hhcnMgPSBkaWZmc1t4XVsxXTtcclxuICAgIHZhciB0ZXh0ID0gW107XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNoYXJzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgIHRleHRbeV0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdCh5KV07XHJcbiAgICB9XHJcbiAgICBkaWZmc1t4XVsxXSA9IHRleHQuam9pbignJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBwcmVmaXggb2YgdHdvIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIHN0YXJ0IG9mIGVhY2hcclxuICogICAgIHN0cmluZy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uUHJlZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxyXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPSB0ZXh0Mi5jaGFyQXQoMCkpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICAvLyBCaW5hcnkgc2VhcmNoLlxyXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXHJcbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xyXG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xyXG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcclxuICB2YXIgcG9pbnRlcnN0YXJ0ID0gMDtcclxuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcclxuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSA9PVxyXG4gICAgICAgIHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpKSB7XHJcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xyXG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XHJcbiAgICB9XHJcbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xyXG4gIH1cclxuICByZXR1cm4gcG9pbnRlcm1pZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gc3VmZml4IG9mIHR3byBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgZWFjaCBzdHJpbmcuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblN1ZmZpeCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cclxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fFxyXG4gICAgICB0ZXh0MS5jaGFyQXQodGV4dDEubGVuZ3RoIC0gMSkgIT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgLy8gQmluYXJ5IHNlYXJjaC5cclxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xyXG4gIHZhciBwb2ludGVybWluID0gMDtcclxuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcclxuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XHJcbiAgdmFyIHBvaW50ZXJlbmQgPSAwO1xyXG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xyXG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PVxyXG4gICAgICAgIHRleHQyLnN1YnN0cmluZyh0ZXh0Mi5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0Mi5sZW5ndGggLSBwb2ludGVyZW5kKSkge1xyXG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcclxuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcclxuICAgIH1cclxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XHJcbiAgfVxyXG4gIHJldHVybiBwb2ludGVybWlkO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgaWYgdGhlIHN1ZmZpeCBvZiBvbmUgc3RyaW5nIGlzIHRoZSBwcmVmaXggb2YgYW5vdGhlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdFxyXG4gKiAgICAgc3RyaW5nIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHNlY29uZCBzdHJpbmcuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vbk92ZXJsYXBfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgLy8gQ2FjaGUgdGhlIHRleHQgbGVuZ3RocyB0byBwcmV2ZW50IG11bHRpcGxlIGNhbGxzLlxyXG4gIHZhciB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XHJcbiAgdmFyIHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcclxuICAvLyBFbGltaW5hdGUgdGhlIG51bGwgY2FzZS5cclxuICBpZiAodGV4dDFfbGVuZ3RoID09IDAgfHwgdGV4dDJfbGVuZ3RoID09IDApIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICAvLyBUcnVuY2F0ZSB0aGUgbG9uZ2VyIHN0cmluZy5cclxuICBpZiAodGV4dDFfbGVuZ3RoID4gdGV4dDJfbGVuZ3RoKSB7XHJcbiAgICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGgpO1xyXG4gIH0gZWxzZSBpZiAodGV4dDFfbGVuZ3RoIDwgdGV4dDJfbGVuZ3RoKSB7XHJcbiAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0MV9sZW5ndGgpO1xyXG4gIH1cclxuICB2YXIgdGV4dF9sZW5ndGggPSBNYXRoLm1pbih0ZXh0MV9sZW5ndGgsIHRleHQyX2xlbmd0aCk7XHJcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIHRoZSB3b3JzdCBjYXNlLlxyXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xyXG4gICAgcmV0dXJuIHRleHRfbGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RhcnQgYnkgbG9va2luZyBmb3IgYSBzaW5nbGUgY2hhcmFjdGVyIG1hdGNoXHJcbiAgLy8gYW5kIGluY3JlYXNlIGxlbmd0aCB1bnRpbCBubyBtYXRjaCBpcyBmb3VuZC5cclxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDEwLzExLzA0L1xyXG4gIHZhciBiZXN0ID0gMDtcclxuICB2YXIgbGVuZ3RoID0gMTtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgdmFyIHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpO1xyXG4gICAgdmFyIGZvdW5kID0gdGV4dDIuaW5kZXhPZihwYXR0ZXJuKTtcclxuICAgIGlmIChmb3VuZCA9PSAtMSkge1xyXG4gICAgICByZXR1cm4gYmVzdDtcclxuICAgIH1cclxuICAgIGxlbmd0aCArPSBmb3VuZDtcclxuICAgIGlmIChmb3VuZCA9PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCkgPT1cclxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkge1xyXG4gICAgICBiZXN0ID0gbGVuZ3RoO1xyXG4gICAgICBsZW5ndGgrKztcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERvIHRoZSB0d28gdGV4dHMgc2hhcmUgYSBzdWJzdHJpbmcgd2hpY2ggaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIHRoZVxyXG4gKiBsb25nZXIgdGV4dD9cclxuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXHJcbiAqICAgICB0ZXh0MSwgdGhlIHN1ZmZpeCBvZiB0ZXh0MSwgdGhlIHByZWZpeCBvZiB0ZXh0MiwgdGhlIHN1ZmZpeCBvZlxyXG4gKiAgICAgdGV4dDIgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2hhbGZNYXRjaF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xyXG4gICAgLy8gRG9uJ3QgcmlzayByZXR1cm5pbmcgYSBub24tb3B0aW1hbCBkaWZmIGlmIHdlIGhhdmUgdW5saW1pdGVkIHRpbWUuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcclxuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcclxuICBpZiAobG9uZ3RleHQubGVuZ3RoIDwgNCB8fCBzaG9ydHRleHQubGVuZ3RoICogMiA8IGxvbmd0ZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG51bGw7ICAvLyBQb2ludGxlc3MuXHJcbiAgfVxyXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxyXG5cclxuICAvKipcclxuICAgKiBEb2VzIGEgc3Vic3RyaW5nIG9mIHNob3J0dGV4dCBleGlzdCB3aXRoaW4gbG9uZ3RleHQgc3VjaCB0aGF0IHRoZSBzdWJzdHJpbmdcclxuICAgKiBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgbG9uZ3RleHQ/XHJcbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb25ndGV4dCBMb25nZXIgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzaG9ydHRleHQgU2hvcnRlciBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgU3RhcnQgaW5kZXggb2YgcXVhcnRlciBsZW5ndGggc3Vic3RyaW5nIHdpdGhpbiBsb25ndGV4dC5cclxuICAgKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcclxuICAgKiAgICAgbG9uZ3RleHQsIHRoZSBzdWZmaXggb2YgbG9uZ3RleHQsIHRoZSBwcmVmaXggb2Ygc2hvcnR0ZXh0LCB0aGUgc3VmZml4XHJcbiAgICogICAgIG9mIHNob3J0dGV4dCBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCwgaSkge1xyXG4gICAgLy8gU3RhcnQgd2l0aCBhIDEvNCBsZW5ndGggc3Vic3RyaW5nIGF0IHBvc2l0aW9uIGkgYXMgYSBzZWVkLlxyXG4gICAgdmFyIHNlZWQgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSwgaSArIE1hdGguZmxvb3IobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xyXG4gICAgdmFyIGogPSAtMTtcclxuICAgIHZhciBiZXN0X2NvbW1vbiA9ICcnO1xyXG4gICAgdmFyIGJlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iO1xyXG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0LmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPSAtMSkge1xyXG4gICAgICB2YXIgcHJlZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uUHJlZml4KGxvbmd0ZXh0LnN1YnN0cmluZyhpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGopKTtcclxuICAgICAgdmFyIHN1ZmZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblN1ZmZpeChsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqKSk7XHJcbiAgICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGgpIHtcclxuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgK1xyXG4gICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKGosIGogKyBwcmVmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcclxuICAgICAgICBiZXN0X2xvbmd0ZXh0X2IgPSBsb25ndGV4dC5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XHJcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaiAtIHN1ZmZpeExlbmd0aCk7XHJcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dC5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggKiAyID49IGxvbmd0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLFxyXG4gICAgICAgICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2IsIGJlc3RfY29tbW9uXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHNlY29uZCBxdWFydGVyIGlzIHRoZSBzZWVkIGZvciBhIGhhbGYtbWF0Y2guXHJcbiAgdmFyIGhtMSA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gNCkpO1xyXG4gIC8vIENoZWNrIGFnYWluIGJhc2VkIG9uIHRoZSB0aGlyZCBxdWFydGVyLlxyXG4gIHZhciBobTIgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcclxuICB2YXIgaG07XHJcbiAgaWYgKCFobTEgJiYgIWhtMikge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSBlbHNlIGlmICghaG0yKSB7XHJcbiAgICBobSA9IGhtMTtcclxuICB9IGVsc2UgaWYgKCFobTEpIHtcclxuICAgIGhtID0gaG0yO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBCb3RoIG1hdGNoZWQuICBTZWxlY3QgdGhlIGxvbmdlc3QuXHJcbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xyXG4gIH1cclxuXHJcbiAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxyXG4gIHZhciB0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iO1xyXG4gIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcclxuICAgIHRleHQxX2EgPSBobVswXTtcclxuICAgIHRleHQxX2IgPSBobVsxXTtcclxuICAgIHRleHQyX2EgPSBobVsyXTtcclxuICAgIHRleHQyX2IgPSBobVszXTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGV4dDJfYSA9IGhtWzBdO1xyXG4gICAgdGV4dDJfYiA9IGhtWzFdO1xyXG4gICAgdGV4dDFfYSA9IGhtWzJdO1xyXG4gICAgdGV4dDFfYiA9IGhtWzNdO1xyXG4gIH1cclxuICB2YXIgbWlkX2NvbW1vbiA9IGhtWzRdO1xyXG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGVkaXRzIGJ5IGVsaW1pbmF0aW5nIHNlbWFudGljYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpYyA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcclxuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cclxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXHJcbiAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gIC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cclxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxyXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBwcmlvciB0byB0aGUgZXF1YWxpdHkuXHJcbiAgdmFyIGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7XHJcbiAgdmFyIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcclxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgYWZ0ZXIgdGhlIGVxdWFsaXR5LlxyXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xyXG4gIHZhciBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBFcXVhbGl0eSBmb3VuZC5cclxuICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcclxuICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xyXG4gICAgICBsZW5ndGhfZGVsZXRpb25zMSA9IGxlbmd0aF9kZWxldGlvbnMyO1xyXG4gICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xyXG4gICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XHJcbiAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgfSBlbHNlIHsgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRWxpbWluYXRlIGFuIGVxdWFsaXR5IHRoYXQgaXMgc21hbGxlciBvciBlcXVhbCB0byB0aGUgZWRpdHMgb24gYm90aFxyXG4gICAgICAvLyBzaWRlcyBvZiBpdC5cclxuICAgICAgaWYgKGxhc3RlcXVhbGl0eSAmJiAobGFzdGVxdWFsaXR5Lmxlbmd0aCA8PVxyXG4gICAgICAgICAgTWF0aC5tYXgobGVuZ3RoX2luc2VydGlvbnMxLCBsZW5ndGhfZGVsZXRpb25zMSkpICYmXHJcbiAgICAgICAgICAobGFzdGVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhfZGVsZXRpb25zMikpKSB7XHJcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZC5cclxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cclxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XHJcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkLlxyXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcclxuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eSAoaXQgbmVlZHMgdG8gYmUgcmVldmFsdWF0ZWQpLlxyXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcclxuICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xyXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7ICAvLyBSZXNldCB0aGUgY291bnRlcnMuXHJcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xyXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XHJcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcblxyXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZGlmZi5cclxuICBpZiAoY2hhbmdlcykge1xyXG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XHJcbiAgfVxyXG4gIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XHJcblxyXG4gIC8vIEZpbmQgYW55IG92ZXJsYXBzIGJldHdlZW4gZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zLlxyXG4gIC8vIGUuZzogPGRlbD5hYmN4eHg8L2RlbD48aW5zPnh4eGRlZjwvaW5zPlxyXG4gIC8vICAgLT4gPGRlbD5hYmM8L2RlbD54eHg8aW5zPmRlZjwvaW5zPlxyXG4gIC8vIGUuZzogPGRlbD54eHhhYmM8L2RlbD48aW5zPmRlZnh4eDwvaW5zPlxyXG4gIC8vICAgLT4gPGlucz5kZWY8L2lucz54eHg8ZGVsPmFiYzwvZGVsPlxyXG4gIC8vIE9ubHkgZXh0cmFjdCBhbiBvdmVybGFwIGlmIGl0IGlzIGFzIGJpZyBhcyB0aGUgZWRpdCBhaGVhZCBvciBiZWhpbmQgaXQuXHJcbiAgcG9pbnRlciA9IDE7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9ERUxFVEUgJiZcclxuICAgICAgICBkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICB2YXIgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XHJcbiAgICAgIHZhciBpbnNlcnRpb24gPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMSA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhkZWxldGlvbiwgaW5zZXJ0aW9uKTtcclxuICAgICAgdmFyIG92ZXJsYXBfbGVuZ3RoMiA9IHRoaXMuZGlmZl9jb21tb25PdmVybGFwXyhpbnNlcnRpb24sIGRlbGV0aW9uKTtcclxuICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBvdmVybGFwX2xlbmd0aDIpIHtcclxuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcclxuICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgxID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XHJcbiAgICAgICAgICAvLyBPdmVybGFwIGZvdW5kLiAgSW5zZXJ0IGFuIGVxdWFsaXR5IGFuZCB0cmltIHRoZSBzdXJyb3VuZGluZyBlZGl0cy5cclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLFxyXG4gICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMSldKTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9XHJcbiAgICAgICAgICAgICAgZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMSk7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMSk7XHJcbiAgICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxyXG4gICAgICAgICAgICBvdmVybGFwX2xlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcclxuICAgICAgICAgIC8vIFJldmVyc2Ugb3ZlcmxhcCBmb3VuZC5cclxuICAgICAgICAgIC8vIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgc3dhcCBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcclxuICAgICAgICAgICAgICBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBfbGVuZ3RoMildKTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJUO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID1cclxuICAgICAgICAgICAgICBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDIpO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEU7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPVxyXG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDIpO1xyXG4gICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwb2ludGVyKys7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcclxuICogd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gYWxpZ24gdGhlIGVkaXQgdG8gYSB3b3JkIGJvdW5kYXJ5LlxyXG4gKiBlLmc6IFRoZSBjPGlucz5hdCBjPC9pbnM+YW1lLiAtPiBUaGUgPGlucz5jYXQgPC9pbnM+Y2FtZS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIC8qKlxyXG4gICAqIEdpdmVuIHR3byBzdHJpbmdzLCBjb21wdXRlIGEgc2NvcmUgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhlIGludGVybmFsXHJcbiAgICogYm91bmRhcnkgZmFsbHMgb24gbG9naWNhbCBib3VuZGFyaWVzLlxyXG4gICAqIFNjb3JlcyByYW5nZSBmcm9tIDYgKGJlc3QpIHRvIDAgKHdvcnN0KS5cclxuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9uZSBGaXJzdCBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR3byBTZWNvbmQgc3RyaW5nLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNjb3JlLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8ob25lLCB0d28pIHtcclxuICAgIGlmICghb25lIHx8ICF0d28pIHtcclxuICAgICAgLy8gRWRnZXMgYXJlIHRoZSBiZXN0LlxyXG4gICAgICByZXR1cm4gNjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFYWNoIHBvcnQgb2YgdGhpcyBmdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IGR1ZSB0b1xyXG4gICAgLy8gc3VidGxlIGRpZmZlcmVuY2VzIGluIGVhY2ggbGFuZ3VhZ2UncyBkZWZpbml0aW9uIG9mIHRoaW5ncyBsaWtlXHJcbiAgICAvLyAnd2hpdGVzcGFjZScuICBTaW5jZSB0aGlzIGZ1bmN0aW9uJ3MgcHVycG9zZSBpcyBsYXJnZWx5IGNvc21ldGljLFxyXG4gICAgLy8gdGhlIGNob2ljZSBoYXMgYmVlbiBtYWRlIHRvIHVzZSBlYWNoIGxhbmd1YWdlJ3MgbmF0aXZlIGZlYXR1cmVzXHJcbiAgICAvLyByYXRoZXIgdGhhbiBmb3JjZSB0b3RhbCBjb25mb3JtaXR5LlxyXG4gICAgdmFyIGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XHJcbiAgICB2YXIgY2hhcjIgPSB0d28uY2hhckF0KDApO1xyXG4gICAgdmFyIG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChkaWZmX21hdGNoX3BhdGNoLm5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XHJcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcclxuICAgIHZhciB3aGl0ZXNwYWNlMSA9IG5vbkFscGhhTnVtZXJpYzEgJiZcclxuICAgICAgICBjaGFyMS5tYXRjaChkaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8pO1xyXG4gICAgdmFyIHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJlxyXG4gICAgICAgIGNoYXIyLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gud2hpdGVzcGFjZVJlZ2V4Xyk7XHJcbiAgICB2YXIgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmXHJcbiAgICAgICAgY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xyXG4gICAgdmFyIGxpbmVCcmVhazIgPSB3aGl0ZXNwYWNlMiAmJlxyXG4gICAgICAgIGNoYXIyLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfKTtcclxuICAgIHZhciBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJlxyXG4gICAgICAgIG9uZS5tYXRjaChkaWZmX21hdGNoX3BhdGNoLmJsYW5rbGluZUVuZFJlZ2V4Xyk7XHJcbiAgICB2YXIgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiZcclxuICAgICAgICB0d28ubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVTdGFydFJlZ2V4Xyk7XHJcblxyXG4gICAgaWYgKGJsYW5rTGluZTEgfHwgYmxhbmtMaW5lMikge1xyXG4gICAgICAvLyBGaXZlIHBvaW50cyBmb3IgYmxhbmsgbGluZXMuXHJcbiAgICAgIHJldHVybiA1O1xyXG4gICAgfSBlbHNlIGlmIChsaW5lQnJlYWsxIHx8IGxpbmVCcmVhazIpIHtcclxuICAgICAgLy8gRm91ciBwb2ludHMgZm9yIGxpbmUgYnJlYWtzLlxyXG4gICAgICByZXR1cm4gNDtcclxuICAgIH0gZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSAmJiAhd2hpdGVzcGFjZTEgJiYgd2hpdGVzcGFjZTIpIHtcclxuICAgICAgLy8gVGhyZWUgcG9pbnRzIGZvciBlbmQgb2Ygc2VudGVuY2VzLlxyXG4gICAgICByZXR1cm4gMztcclxuICAgIH0gZWxzZSBpZiAod2hpdGVzcGFjZTEgfHwgd2hpdGVzcGFjZTIpIHtcclxuICAgICAgLy8gVHdvIHBvaW50cyBmb3Igd2hpdGVzcGFjZS5cclxuICAgICAgcmV0dXJuIDI7XHJcbiAgICB9IGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMikge1xyXG4gICAgICAvLyBPbmUgcG9pbnQgZm9yIG5vbi1hbHBoYW51bWVyaWMuXHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICB2YXIgcG9pbnRlciA9IDE7XHJcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xyXG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcclxuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cclxuICAgICAgdmFyIGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcclxuICAgICAgdmFyIGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgdmFyIGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcclxuXHJcbiAgICAgIC8vIEZpcnN0LCBzaGlmdCB0aGUgZWRpdCBhcyBmYXIgbGVmdCBhcyBwb3NzaWJsZS5cclxuICAgICAgdmFyIGNvbW1vbk9mZnNldCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcclxuICAgICAgaWYgKGNvbW1vbk9mZnNldCkge1xyXG4gICAgICAgIHZhciBjb21tb25TdHJpbmcgPSBlZGl0LnN1YnN0cmluZyhlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XHJcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcclxuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xyXG4gICAgICAgIGVxdWFsaXR5MiA9IGNvbW1vblN0cmluZyArIGVxdWFsaXR5MjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2Vjb25kLCBzdGVwIGNoYXJhY3RlciBieSBjaGFyYWN0ZXIgcmlnaHQsIGxvb2tpbmcgZm9yIHRoZSBiZXN0IGZpdC5cclxuICAgICAgdmFyIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XHJcbiAgICAgIHZhciBiZXN0RWRpdCA9IGVkaXQ7XHJcbiAgICAgIHZhciBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xyXG4gICAgICB2YXIgYmVzdFNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZXF1YWxpdHkxLCBlZGl0KSArXHJcbiAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xyXG4gICAgICB3aGlsZSAoZWRpdC5jaGFyQXQoMCkgPT09IGVxdWFsaXR5Mi5jaGFyQXQoMCkpIHtcclxuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCk7XHJcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcclxuICAgICAgICBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIHZhciBzY29yZSA9IGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVxdWFsaXR5MSwgZWRpdCkgK1xyXG4gICAgICAgICAgICBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlZGl0LCBlcXVhbGl0eTIpO1xyXG4gICAgICAgIC8vIFRoZSA+PSBlbmNvdXJhZ2VzIHRyYWlsaW5nIHJhdGhlciB0aGFuIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBlZGl0cy5cclxuICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKSB7XHJcbiAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XHJcbiAgICAgICAgICBiZXN0RWRpdCA9IGVkaXQ7XHJcbiAgICAgICAgICBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPSBiZXN0RXF1YWxpdHkxKSB7XHJcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBpbXByb3ZlbWVudCwgc2F2ZSBpdCBiYWNrIHRvIHRoZSBkaWZmLlxyXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkxKSB7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xyXG4gICAgICAgICAgcG9pbnRlci0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGJlc3RFZGl0O1xyXG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xyXG4gICAgICAgICAgcG9pbnRlci0tO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIERlZmluZSBzb21lIHJlZ2V4IHBhdHRlcm5zIGZvciBtYXRjaGluZyBib3VuZGFyaWVzLlxyXG5kaWZmX21hdGNoX3BhdGNoLm5vbkFscGhhTnVtZXJpY1JlZ2V4XyA9IC9bXmEtekEtWjAtOV0vO1xyXG5kaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8gPSAvXFxzLztcclxuZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8gPSAvW1xcclxcbl0vO1xyXG5kaWZmX21hdGNoX3BhdGNoLmJsYW5rbGluZUVuZFJlZ2V4XyA9IC9cXG5cXHI/XFxuJC87XHJcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lU3RhcnRSZWdleF8gPSAvXlxccj9cXG5cXHI/XFxuLztcclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBvcGVyYXRpb25hbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cEVmZmljaWVuY3kgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XHJcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXHJcbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cclxuICB2YXIgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXHJcbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cclxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cclxuICB2YXIgcHJlX2lucyA9IGZhbHNlO1xyXG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGJlZm9yZSB0aGUgbGFzdCBlcXVhbGl0eS5cclxuICB2YXIgcHJlX2RlbCA9IGZhbHNlO1xyXG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHBvc3RfaW5zID0gZmFsc2U7XHJcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYWZ0ZXIgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHBvc3RfZGVsID0gZmFsc2U7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0VRVUFMKSB7ICAvLyBFcXVhbGl0eSBmb3VuZC5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAmJlxyXG4gICAgICAgICAgKHBvc3RfaW5zIHx8IHBvc3RfZGVsKSkge1xyXG4gICAgICAgIC8vIENhbmRpZGF0ZSBmb3VuZC5cclxuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xyXG4gICAgICAgIHByZV9pbnMgPSBwb3N0X2lucztcclxuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XHJcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm90IGEgY2FuZGlkYXRlLCBhbmQgY2FuIG5ldmVyIGJlY29tZSBvbmUuXHJcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XHJcbiAgICB9IGVsc2UgeyAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9ERUxFVEUpIHtcclxuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcG9zdF9pbnMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8qXHJcbiAgICAgICAqIEZpdmUgdHlwZXMgdG8gYmUgc3BsaXQ6XHJcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlhZPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XHJcbiAgICAgICAqIDxpbnM+QTwvaW5zPlg8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cclxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxpbnM+QzwvaW5zPlxyXG4gICAgICAgKiA8aW5zPkE8L2RlbD5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XHJcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlg8ZGVsPkM8L2RlbD5cclxuICAgICAgICovXHJcbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgobGFzdGVxdWFsaXR5Lmxlbmd0aCA8IHRoaXMuRGlmZl9FZGl0Q29zdCAvIDIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocHJlX2lucyArIHByZV9kZWwgKyBwb3N0X2lucyArIHBvc3RfZGVsKSA9PSAzKSkpIHtcclxuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxyXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCBsYXN0ZXF1YWxpdHldKTtcclxuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxyXG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07ICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQ7XHJcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAgICAgICBpZiAocHJlX2lucyAmJiBwcmVfZGVsKSB7XHJcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzIG1hZGUgd2hpY2ggY291bGQgYWZmZWN0IHByZXZpb3VzIGVudHJ5LCBrZWVwIGdvaW5nLlxyXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XHJcbiAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXHJcbiAgICAgICAgICBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgP1xyXG4gICAgICAgICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XHJcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG5cclxuICBpZiAoY2hhbmdlcykge1xyXG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW9yZGVyIGFuZCBtZXJnZSBsaWtlIGVkaXQgc2VjdGlvbnMuICBNZXJnZSBlcXVhbGl0aWVzLlxyXG4gKiBBbnkgZWRpdCBzZWN0aW9uIGNhbiBtb3ZlIGFzIGxvbmcgYXMgaXQgZG9lc24ndCBjcm9zcyBhbiBlcXVhbGl0eS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cE1lcmdlID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pOyAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuICB2YXIgcG9pbnRlciA9IDA7XHJcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XHJcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XHJcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XHJcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XHJcbiAgdmFyIGNvbW1vbmxlbmd0aDtcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGNvdW50X2luc2VydCsrO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBjb3VudF9kZWxldGUrKztcclxuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICAvLyBVcG9uIHJlYWNoaW5nIGFuIGVxdWFsaXR5LCBjaGVjayBmb3IgcHJpb3IgcmVkdW5kYW5jaWVzLlxyXG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQgPiAxKSB7XHJcbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwICYmIGNvdW50X2luc2VydCAhPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gcHJlZml4aWVzLlxyXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XHJcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICBpZiAoKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQpID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT1cclxuICAgICAgICAgICAgICAgICAgRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCldKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBzdWZmaXhpZXMuXHJcbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcclxuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtXHJcbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0X2luc2VydC5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKDAsIHRleHRfZGVsZXRlLmxlbmd0aCAtXHJcbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXHJcbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfaW5zZXJ0LFxyXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvdW50X2luc2VydCA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSxcclxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXHJcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdLFxyXG4gICAgICAgICAgICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgK1xyXG4gICAgICAgICAgICAgICAgICAgIChjb3VudF9kZWxldGUgPyAxIDogMCkgKyAoY291bnRfaW5zZXJ0ID8gMSA6IDApICsgMTtcclxuICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgIC8vIE1lcmdlIHRoaXMgZXF1YWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgb25lLlxyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XHJcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcclxuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gJycpIHtcclxuICAgIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxyXG4gIH1cclxuXHJcbiAgLy8gU2Vjb25kIHBhc3M6IGxvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xyXG4gIC8vIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGVsaW1pbmF0ZSBhbiBlcXVhbGl0eS5cclxuICAvLyBlLmc6IEE8aW5zPkJBPC9pbnM+QyAtPiA8aW5zPkFCPC9pbnM+QUNcclxuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xyXG4gIHBvaW50ZXIgPSAxO1xyXG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSkge1xyXG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICtcclxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcclxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgPT1cclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSkge1xyXG4gICAgICAgIC8vIFNoaWZ0IHRoZSBlZGl0IG92ZXIgdGhlIG5leHQgZXF1YWxpdHkuXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcclxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9XHJcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArXHJcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcclxuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xyXG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG4gIC8vIElmIHNoaWZ0cyB3ZXJlIG1hZGUsIHRoZSBkaWZmIG5lZWRzIHJlb3JkZXJpbmcgYW5kIGFub3RoZXIgc2hpZnQgc3dlZXAuXHJcbiAgaWYgKGNoYW5nZXMpIHtcclxuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogbG9jIGlzIGEgbG9jYXRpb24gaW4gdGV4dDEsIGNvbXB1dGUgYW5kIHJldHVybiB0aGUgZXF1aXZhbGVudCBsb2NhdGlvbiBpblxyXG4gKiB0ZXh0Mi5cclxuICogZS5nLiAnVGhlIGNhdCcgdnMgJ1RoZSBiaWcgY2F0JywgMS0+MSwgNS0+OFxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIExvY2F0aW9uIHdpdGhpbiB0ZXh0MS5cclxuICogQHJldHVybiB7bnVtYmVyfSBMb2NhdGlvbiB3aXRoaW4gdGV4dDIuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3hJbmRleCA9IGZ1bmN0aW9uKGRpZmZzLCBsb2MpIHtcclxuICB2YXIgY2hhcnMxID0gMDtcclxuICB2YXIgY2hhcnMyID0gMDtcclxuICB2YXIgbGFzdF9jaGFyczEgPSAwO1xyXG4gIHZhciBsYXN0X2NoYXJzMiA9IDA7XHJcbiAgdmFyIHg7XHJcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKSB7ICAvLyBFcXVhbGl0eSBvciBkZWxldGlvbi5cclxuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHsgIC8vIEVxdWFsaXR5IG9yIGluc2VydGlvbi5cclxuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChjaGFyczEgPiBsb2MpIHsgIC8vIE92ZXJzaG90IHRoZSBsb2NhdGlvbi5cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsYXN0X2NoYXJzMSA9IGNoYXJzMTtcclxuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xyXG4gIH1cclxuICAvLyBXYXMgdGhlIGxvY2F0aW9uIHdhcyBkZWxldGVkP1xyXG4gIGlmIChkaWZmcy5sZW5ndGggIT0geCAmJiBkaWZmc1t4XVswXSA9PT0gRElGRl9ERUxFVEUpIHtcclxuICAgIHJldHVybiBsYXN0X2NoYXJzMjtcclxuICB9XHJcbiAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hhcmFjdGVyIGxlbmd0aC5cclxuICByZXR1cm4gbGFzdF9jaGFyczIgKyAobG9jIC0gbGFzdF9jaGFyczEpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgZGlmZiBhcnJheSBpbnRvIGEgcHJldHR5IEhUTUwgcmVwb3J0LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhUTUwgcmVwcmVzZW50YXRpb24uXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3ByZXR0eUh0bWwgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBodG1sID0gW107XHJcbiAgdmFyIHBhdHRlcm5fYW1wID0gLyYvZztcclxuICB2YXIgcGF0dGVybl9sdCA9IC88L2c7XHJcbiAgdmFyIHBhdHRlcm5fZ3QgPSAvPi9nO1xyXG4gIHZhciBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07ICAgIC8vIE9wZXJhdGlvbiAoaW5zZXJ0LCBkZWxldGUsIGVxdWFsKVxyXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTsgIC8vIFRleHQgb2YgY2hhbmdlLlxyXG4gICAgdmFyIHRleHQgPSBkYXRhLnJlcGxhY2UocGF0dGVybl9hbXAsICcmYW1wOycpLnJlcGxhY2UocGF0dGVybl9sdCwgJyZsdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKHBhdHRlcm5fZ3QsICcmZ3Q7JykucmVwbGFjZShwYXR0ZXJuX3BhcmEsICcmcGFyYTs8YnI+Jyk7XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgaHRtbFt4XSA9ICc8aW5zIHN0eWxlPVwiYmFja2dyb3VuZDojZTZmZmU2O1wiPicgKyB0ZXh0ICsgJzwvaW5zPic7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgaHRtbFt4XSA9ICc8ZGVsIHN0eWxlPVwiYmFja2dyb3VuZDojZmZlNmU2O1wiPicgKyB0ZXh0ICsgJzwvZGVsPic7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICBodG1sW3hdID0gJzxzcGFuPicgKyB0ZXh0ICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gaHRtbC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzb3VyY2UgdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGRlbGV0aW9ucykuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gU291cmNlIHRleHQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQxID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgdGV4dCA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgaW5zZXJ0aW9ucykuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVzdGluYXRpb24gdGV4dC5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDIgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciB0ZXh0ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkge1xyXG4gICAgICB0ZXh0W3hdID0gZGlmZnNbeF1bMV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBMZXZlbnNodGVpbiBkaXN0YW5jZTsgdGhlIG51bWJlciBvZiBpbnNlcnRlZCwgZGVsZXRlZCBvclxyXG4gKiBzdWJzdGl0dXRlZCBjaGFyYWN0ZXJzLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBjaGFuZ2VzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9sZXZlbnNodGVpbiA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIGxldmVuc2h0ZWluID0gMDtcclxuICB2YXIgaW5zZXJ0aW9ucyA9IDA7XHJcbiAgdmFyIGRlbGV0aW9ucyA9IDA7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIG9wID0gZGlmZnNbeF1bMF07XHJcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdO1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgLy8gQSBkZWxldGlvbiBhbmQgYW4gaW5zZXJ0aW9uIGlzIG9uZSBzdWJzdGl0dXRpb24uXHJcbiAgICAgICAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcclxuICAgICAgICBpbnNlcnRpb25zID0gMDtcclxuICAgICAgICBkZWxldGlvbnMgPSAwO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xyXG4gIHJldHVybiBsZXZlbnNodGVpbjtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ3J1c2ggdGhlIGRpZmYgaW50byBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlIG9wZXJhdGlvbnNcclxuICogcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIuXHJcbiAqIEUuZy4gPTNcXHQtMlxcdCtpbmcgIC0+IEtlZXAgMyBjaGFycywgZGVsZXRlIDIgY2hhcnMsIGluc2VydCAnaW5nJy5cclxuICogT3BlcmF0aW9ucyBhcmUgdGFiLXNlcGFyYXRlZC4gIEluc2VydGVkIHRleHQgaXMgZXNjYXBlZCB1c2luZyAleHggbm90YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVsdGEgdGV4dC5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdG9EZWx0YSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBzd2l0Y2ggKGRpZmZzW3hdWzBdKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgdGV4dFt4XSA9ICcrJyArIGVuY29kZVVSSShkaWZmc1t4XVsxXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgdGV4dFt4XSA9ICctJyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIHRleHRbeF0gPSAnPScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0LmpvaW4oJ1xcdCcpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0aGUgb3JpZ2luYWwgdGV4dDEsIGFuZCBhbiBlbmNvZGVkIHN0cmluZyB3aGljaCBkZXNjcmliZXMgdGhlXHJcbiAqIG9wZXJhdGlvbnMgcmVxdWlyZWQgdG8gdHJhbnNmb3JtIHRleHQxIGludG8gdGV4dDIsIGNvbXB1dGUgdGhlIGZ1bGwgZGlmZi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIFNvdXJjZSBzdHJpbmcgZm9yIHRoZSBkaWZmLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVsdGEgRGVsdGEgdGV4dC5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfZnJvbURlbHRhID0gZnVuY3Rpb24odGV4dDEsIGRlbHRhKSB7XHJcbiAgdmFyIGRpZmZzID0gW107XHJcbiAgdmFyIGRpZmZzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cclxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBDdXJzb3IgaW4gdGV4dDFcclxuICB2YXIgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xyXG4gICAgLy8gRWFjaCB0b2tlbiBiZWdpbnMgd2l0aCBhIG9uZSBjaGFyYWN0ZXIgcGFyYW1ldGVyIHdoaWNoIHNwZWNpZmllcyB0aGVcclxuICAgIC8vIG9wZXJhdGlvbiBvZiB0aGlzIHRva2VuIChkZWxldGUsIGluc2VydCwgZXF1YWxpdHkpLlxyXG4gICAgdmFyIHBhcmFtID0gdG9rZW5zW3hdLnN1YnN0cmluZygxKTtcclxuICAgIHN3aXRjaCAodG9rZW5zW3hdLmNoYXJBdCgwKSkge1xyXG4gICAgICBjYXNlICcrJzpcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9JTlNFUlQsIGRlY29kZVVSSShwYXJhbSldO1xyXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAvLyBNYWxmb3JtZWQgVVJJIHNlcXVlbmNlLlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cclxuICAgICAgY2FzZSAnPSc6XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZUludChwYXJhbSwgMTApO1xyXG4gICAgICAgIGlmIChpc05hTihuKSB8fCBuIDwgMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBpbiBkaWZmX2Zyb21EZWx0YTogJyArIHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlciwgcG9pbnRlciArPSBuKTtcclxuICAgICAgICBpZiAodG9rZW5zW3hdLmNoYXJBdCgwKSA9PSAnPScpIHtcclxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfRVFVQUwsIHRleHRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0RFTEVURSwgdGV4dF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vIEJsYW5rIHRva2VucyBhcmUgb2sgKGZyb20gYSB0cmFpbGluZyBcXHQpLlxyXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgYW4gZXJyb3IuXHJcbiAgICAgICAgaWYgKHRva2Vuc1t4XSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNbeF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHBvaW50ZXIgIT0gdGV4dDEubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbHRhIGxlbmd0aCAoJyArIHBvaW50ZXIgK1xyXG4gICAgICAgICcpIGRvZXMgbm90IGVxdWFsIHNvdXJjZSB0ZXh0IGxlbmd0aCAoJyArIHRleHQxLmxlbmd0aCArICcpLicpO1xyXG4gIH1cclxuICByZXR1cm4gZGlmZnM7XHJcbn07XHJcblxyXG5cclxuLy8gIE1BVENIIEZVTkNUSU9OU1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgVGhlIGxvY2F0aW9uIHRvIHNlYXJjaCBhcm91bmQuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX21haW4gPSBmdW5jdGlvbih0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcclxuICAvLyBDaGVjayBmb3IgbnVsbCBpbnB1dHMuXHJcbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBpbnB1dC4gKG1hdGNoX21haW4pJyk7XHJcbiAgfVxyXG5cclxuICBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2MsIHRleHQubGVuZ3RoKSk7XHJcbiAgaWYgKHRleHQgPT0gcGF0dGVybikge1xyXG4gICAgLy8gU2hvcnRjdXQgKHBvdGVudGlhbGx5IG5vdCBndWFyYW50ZWVkIGJ5IHRoZSBhbGdvcml0aG0pXHJcbiAgICByZXR1cm4gMDtcclxuICB9IGVsc2UgaWYgKCF0ZXh0Lmxlbmd0aCkge1xyXG4gICAgLy8gTm90aGluZyB0byBtYXRjaC5cclxuICAgIHJldHVybiAtMTtcclxuICB9IGVsc2UgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09IHBhdHRlcm4pIHtcclxuICAgIC8vIFBlcmZlY3QgbWF0Y2ggYXQgdGhlIHBlcmZlY3Qgc3BvdCEgIChJbmNsdWRlcyBjYXNlIG9mIG51bGwgcGF0dGVybilcclxuICAgIHJldHVybiBsb2M7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIERvIGEgZnV6enkgY29tcGFyZS5cclxuICAgIHJldHVybiB0aGlzLm1hdGNoX2JpdGFwXyh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJyB1c2luZyB0aGVcclxuICogQml0YXAgYWxnb3JpdGhtLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBzZWFyY2guXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHNlYXJjaCBmb3IuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgVGhlIGxvY2F0aW9uIHRvIHNlYXJjaCBhcm91bmQuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gQmVzdCBtYXRjaCBpbmRleCBvciAtMS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2JpdGFwXyA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xyXG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuJyk7XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIHRoZSBhbHBoYWJldC5cclxuICB2YXIgcyA9IHRoaXMubWF0Y2hfYWxwaGFiZXRfKHBhdHRlcm4pO1xyXG5cclxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBzY29yZSBmb3IgYSBtYXRjaCB3aXRoIGUgZXJyb3JzIGFuZCB4IGxvY2F0aW9uLlxyXG4gICAqIEFjY2Vzc2VzIGxvYyBhbmQgcGF0dGVybiB0aHJvdWdoIGJlaW5nIGEgY2xvc3VyZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZSBOdW1iZXIgb2YgZXJyb3JzIGluIG1hdGNoLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IExvY2F0aW9uIG9mIG1hdGNoLlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3ZlcmFsbCBzY29yZSBmb3IgbWF0Y2ggKDAuMCA9IGdvb2QsIDEuMCA9IGJhZCkuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBtYXRjaF9iaXRhcFNjb3JlXyhlLCB4KSB7XHJcbiAgICB2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGg7XHJcbiAgICB2YXIgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XHJcbiAgICBpZiAoIWRtcC5NYXRjaF9EaXN0YW5jZSkge1xyXG4gICAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cclxuICAgICAgcmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjY3VyYWN5ICsgKHByb3hpbWl0eSAvIGRtcC5NYXRjaF9EaXN0YW5jZSk7XHJcbiAgfVxyXG5cclxuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxyXG4gIHZhciBzY29yZV90aHJlc2hvbGQgPSB0aGlzLk1hdGNoX1RocmVzaG9sZDtcclxuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXHJcbiAgdmFyIGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XHJcbiAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XHJcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XHJcbiAgICAvLyBXaGF0IGFib3V0IGluIHRoZSBvdGhlciBkaXJlY3Rpb24/IChzcGVlZHVwKVxyXG4gICAgYmVzdF9sb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKTtcclxuICAgIGlmIChiZXN0X2xvYyAhPSAtMSkge1xyXG4gICAgICBzY29yZV90aHJlc2hvbGQgPVxyXG4gICAgICAgICAgTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZV8oMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGlzZSB0aGUgYml0IGFycmF5cy5cclxuICB2YXIgbWF0Y2htYXNrID0gMSA8PCAocGF0dGVybi5sZW5ndGggLSAxKTtcclxuICBiZXN0X2xvYyA9IC0xO1xyXG5cclxuICB2YXIgYmluX21pbiwgYmluX21pZDtcclxuICB2YXIgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XHJcbiAgdmFyIGxhc3RfcmQ7XHJcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XHJcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cclxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSAnbG9jJyB3ZSBjYW4gc3RyYXkgYXQgdGhpc1xyXG4gICAgLy8gZXJyb3IgbGV2ZWwuXHJcbiAgICBiaW5fbWluID0gMDtcclxuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xyXG4gICAgd2hpbGUgKGJpbl9taW4gPCBiaW5fbWlkKSB7XHJcbiAgICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlXyhkLCBsb2MgKyBiaW5fbWlkKSA8PSBzY29yZV90aHJlc2hvbGQpIHtcclxuICAgICAgICBiaW5fbWluID0gYmluX21pZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBiaW5fbWF4ID0gYmluX21pZDtcclxuICAgICAgfVxyXG4gICAgICBiaW5fbWlkID0gTWF0aC5mbG9vcigoYmluX21heCAtIGJpbl9taW4pIC8gMiArIGJpbl9taW4pO1xyXG4gICAgfVxyXG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXHJcbiAgICBiaW5fbWF4ID0gYmluX21pZDtcclxuICAgIHZhciBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbl9taWQgKyAxKTtcclxuICAgIHZhciBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcclxuXHJcbiAgICB2YXIgcmQgPSBBcnJheShmaW5pc2ggKyAyKTtcclxuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xyXG4gICAgZm9yICh2YXIgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCAocykgaXMgYSBzcGFyc2UgaGFzaCwgc28gdGhlIGZvbGxvd2luZyBsaW5lIGdlbmVyYXRlc1xyXG4gICAgICAvLyB3YXJuaW5ncy5cclxuICAgICAgdmFyIGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcclxuICAgICAgaWYgKGQgPT09IDApIHsgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoLlxyXG4gICAgICAgIHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcclxuICAgICAgfSBlbHNlIHsgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaC5cclxuICAgICAgICByZFtqXSA9ICgoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoKSB8XHJcbiAgICAgICAgICAgICAgICAoKChsYXN0X3JkW2ogKyAxXSB8IGxhc3RfcmRbal0pIDw8IDEpIHwgMSkgfFxyXG4gICAgICAgICAgICAgICAgbGFzdF9yZFtqICsgMV07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJkW2pdICYgbWF0Y2htYXNrKSB7XHJcbiAgICAgICAgdmFyIHNjb3JlID0gbWF0Y2hfYml0YXBTY29yZV8oZCwgaiAtIDEpO1xyXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cclxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxyXG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcclxuICAgICAgICAgIC8vIFRvbGQgeW91IHNvLlxyXG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XHJcbiAgICAgICAgICBiZXN0X2xvYyA9IGogLSAxO1xyXG4gICAgICAgICAgaWYgKGJlc3RfbG9jID4gbG9jKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBsb2MsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGxvYy5cclxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdF9sb2MpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgbG9jLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cclxuICAgIGlmIChtYXRjaF9iaXRhcFNjb3JlXyhkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZCkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGxhc3RfcmQgPSByZDtcclxuICB9XHJcbiAgcmV0dXJuIGJlc3RfbG9jO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXNlIHRoZSBhbHBoYWJldCBmb3IgdGhlIEJpdGFwIGFsZ29yaXRobS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHRleHQgdG8gZW5jb2RlLlxyXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBIYXNoIG9mIGNoYXJhY3RlciBsb2NhdGlvbnMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9hbHBoYWJldF8gPSBmdW5jdGlvbihwYXR0ZXJuKSB7XHJcbiAgdmFyIHMgPSB7fTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcclxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxKTtcclxuICB9XHJcbiAgcmV0dXJuIHM7XHJcbn07XHJcblxyXG5cclxuLy8gIFBBVENIIEZVTkNUSU9OU1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbmNyZWFzZSB0aGUgY29udGV4dCB1bnRpbCBpdCBpcyB1bmlxdWUsXHJcbiAqIGJ1dCBkb24ndCBsZXQgdGhlIHBhdHRlcm4gZXhwYW5kIGJleW9uZCBNYXRjaF9NYXhCaXRzLlxyXG4gKiBAcGFyYW0geyFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29ian0gcGF0Y2ggVGhlIHBhdGNoIHRvIGdyb3cuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFNvdXJjZSB0ZXh0LlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkQ29udGV4dF8gPSBmdW5jdGlvbihwYXRjaCwgdGV4dCkge1xyXG4gIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHZhciBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxKTtcclxuICB2YXIgcGFkZGluZyA9IDA7XHJcblxyXG4gIC8vIExvb2sgZm9yIHRoZSBmaXJzdCBhbmQgbGFzdCBtYXRjaGVzIG9mIHBhdHRlcm4gaW4gdGV4dC4gIElmIHR3byBkaWZmZXJlbnRcclxuICAvLyBtYXRjaGVzIGFyZSBmb3VuZCwgaW5jcmVhc2UgdGhlIHBhdHRlcm4gbGVuZ3RoLlxyXG4gIHdoaWxlICh0ZXh0LmluZGV4T2YocGF0dGVybikgIT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJlxyXG4gICAgICAgICBwYXR0ZXJuLmxlbmd0aCA8IHRoaXMuTWF0Y2hfTWF4Qml0cyAtIHRoaXMuUGF0Y2hfTWFyZ2luIC1cclxuICAgICAgICAgdGhpcy5QYXRjaF9NYXJnaW4pIHtcclxuICAgIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XHJcbiAgICBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XHJcbiAgfVxyXG4gIC8vIEFkZCBvbmUgY2h1bmsgZm9yIGdvb2QgbHVjay5cclxuICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xyXG5cclxuICAvLyBBZGQgdGhlIHByZWZpeC5cclxuICB2YXIgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcclxuICBpZiAocHJlZml4KSB7XHJcbiAgICBwYXRjaC5kaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBwcmVmaXhdKTtcclxuICB9XHJcbiAgLy8gQWRkIHRoZSBzdWZmaXguXHJcbiAgdmFyIHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcclxuICBpZiAoc3VmZml4KSB7XHJcbiAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBzdWZmaXhdKTtcclxuICB9XHJcblxyXG4gIC8vIFJvbGwgYmFjayB0aGUgc3RhcnQgcG9pbnRzLlxyXG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xyXG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xyXG4gIC8vIEV4dGVuZCB0aGUgbGVuZ3Rocy5cclxuICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xyXG4gIHBhdGNoLmxlbmd0aDIgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgYSBsaXN0IG9mIHBhdGNoZXMgdG8gdHVybiB0ZXh0MSBpbnRvIHRleHQyLlxyXG4gKiBVc2UgZGlmZnMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBjb21wdXRlIGl0IG91cnNlbHZlcy5cclxuICogVGhlcmUgYXJlIGZvdXIgd2F5cyB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGRlcGVuZGluZyBvbiB3aGF0IGRhdGEgaXNcclxuICogYXZhaWxhYmxlIHRvIHRoZSBjYWxsZXI6XHJcbiAqIE1ldGhvZCAxOlxyXG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MlxyXG4gKiBNZXRob2QgMjpcclxuICogYSA9IGRpZmZzXHJcbiAqIE1ldGhvZCAzIChvcHRpbWFsKTpcclxuICogYSA9IHRleHQxLCBiID0gZGlmZnNcclxuICogTWV0aG9kIDQgKGRlcHJlY2F0ZWQsIHVzZSBtZXRob2QgMyk6XHJcbiAqIGEgPSB0ZXh0MSwgYiA9IHRleHQyLCBjID0gZGlmZnNcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gYSB0ZXh0MSAobWV0aG9kcyAxLDMsNCkgb3JcclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMikuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IG9wdF9iIHRleHQyIChtZXRob2RzIDEsNCkgb3JcclxuICogQXJyYXkgb2YgZGlmZiB0dXBsZXMgZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgMykgb3IgdW5kZWZpbmVkIChtZXRob2QgMikuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IG9wdF9jIEFycmF5IG9mIGRpZmYgdHVwbGVzXHJcbiAqIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDQpIG9yIHVuZGVmaW5lZCAobWV0aG9kcyAxLDIsMykuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX21ha2UgPSBmdW5jdGlvbihhLCBvcHRfYiwgb3B0X2MpIHtcclxuICB2YXIgdGV4dDEsIGRpZmZzO1xyXG4gIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcclxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBNZXRob2QgMTogdGV4dDEsIHRleHQyXHJcbiAgICAvLyBDb21wdXRlIGRpZmZzIGZyb20gdGV4dDEgYW5kIHRleHQyLlxyXG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8oYSk7XHJcbiAgICBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCAvKiogQHR5cGUge3N0cmluZ30gKi8ob3B0X2IpLCB0cnVlKTtcclxuICAgIGlmIChkaWZmcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xyXG4gICAgICB0aGlzLmRpZmZfY2xlYW51cEVmZmljaWVuY3koZGlmZnMpO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBNZXRob2QgMjogZGlmZnNcclxuICAgIC8vIENvbXB1dGUgdGV4dDEgZnJvbSBkaWZmcy5cclxuICAgIGRpZmZzID0gLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqLyhhKTtcclxuICAgIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKGRpZmZzKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSAnb2JqZWN0JyAmJlxyXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIE1ldGhvZCAzOiB0ZXh0MSwgZGlmZnNcclxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xyXG4gICAgZGlmZnMgPSAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovKG9wdF9iKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxyXG4gICAgICBvcHRfYyAmJiB0eXBlb2Ygb3B0X2MgPT0gJ29iamVjdCcpIHtcclxuICAgIC8vIE1ldGhvZCA0OiB0ZXh0MSwgdGV4dDIsIGRpZmZzXHJcbiAgICAvLyB0ZXh0MiBpcyBub3QgdXNlZC5cclxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xyXG4gICAgZGlmZnMgPSAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovKG9wdF9jKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgZm9ybWF0IHRvIHBhdGNoX21ha2UuJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gW107ICAvLyBHZXQgcmlkIG9mIHRoZSBudWxsIGNhc2UuXHJcbiAgfVxyXG4gIHZhciBwYXRjaGVzID0gW107XHJcbiAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgdmFyIHBhdGNoRGlmZkxlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXHJcbiAgdmFyIGNoYXJfY291bnQxID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQxIHN0cmluZy5cclxuICB2YXIgY2hhcl9jb3VudDIgPSAwOyAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW50byB0aGUgdGV4dDIgc3RyaW5nLlxyXG4gIC8vIFN0YXJ0IHdpdGggdGV4dDEgKHByZXBhdGNoX3RleHQpIGFuZCBhcHBseSB0aGUgZGlmZnMgdW50aWwgd2UgYXJyaXZlIGF0XHJcbiAgLy8gdGV4dDIgKHBvc3RwYXRjaF90ZXh0KS4gIFdlIHJlY3JlYXRlIHRoZSBwYXRjaGVzIG9uZSBieSBvbmUgdG8gZGV0ZXJtaW5lXHJcbiAgLy8gY29udGV4dCBpbmZvLlxyXG4gIHZhciBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XHJcbiAgdmFyIHBvc3RwYXRjaF90ZXh0ID0gdGV4dDE7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIGRpZmZfdHlwZSA9IGRpZmZzW3hdWzBdO1xyXG4gICAgdmFyIGRpZmZfdGV4dCA9IGRpZmZzW3hdWzFdO1xyXG5cclxuICAgIGlmICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZfdHlwZSAhPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAvLyBBIG5ldyBwYXRjaCBzdGFydHMgaGVyZS5cclxuICAgICAgcGF0Y2guc3RhcnQxID0gY2hhcl9jb3VudDE7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xyXG4gICAgfVxyXG5cclxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArIGRpZmZfdGV4dCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcclxuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiB0aGlzLlBhdGNoX01hcmdpbiAmJlxyXG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9IHggKyAxKSB7XHJcbiAgICAgICAgICAvLyBTbWFsbCBlcXVhbGl0eSBpbnNpZGUgYSBwYXRjaC5cclxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogdGhpcy5QYXRjaF9NYXJnaW4pIHtcclxuICAgICAgICAgIC8vIFRpbWUgZm9yIGEgbmV3IHBhdGNoLlxyXG4gICAgICAgICAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGNoX2FkZENvbnRleHRfKHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcclxuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcclxuICAgICAgICAgICAgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gVW5saWtlIFVuaWRpZmYsIG91ciBwYXRjaCBsaXN0cyBoYXZlIGEgcm9sbGluZyBjb250ZXh0LlxyXG4gICAgICAgICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvd2lraS9VbmlkaWZmXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwcmVwYXRjaCB0ZXh0ICYgcG9zIHRvIHJlZmxlY3QgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGNvbXBsZXRlZCBwYXRjaC5cclxuICAgICAgICAgICAgcHJlcGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0O1xyXG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGNvdW50LlxyXG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgY2hhcl9jb3VudDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgIGNoYXJfY291bnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFBpY2sgdXAgdGhlIGxlZnRvdmVyIHBhdGNoIGlmIG5vdCBlbXB0eS5cclxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XHJcbiAgICB0aGlzLnBhdGNoX2FkZENvbnRleHRfKHBhdGNoLCBwcmVwYXRjaF90ZXh0KTtcclxuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGF0Y2hlcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2YgcGF0Y2hlcywgcmV0dXJuIGFub3RoZXIgYXJyYXkgdGhhdCBpcyBpZGVudGljYWwuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2RlZXBDb3B5ID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIC8vIE1ha2luZyBkZWVwIGNvcGllcyBpcyBoYXJkIGluIEphdmFTY3JpcHQuXHJcbiAgdmFyIHBhdGNoZXNDb3B5ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW3hdO1xyXG4gICAgdmFyIHBhdGNoQ29weSA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gW107XHJcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgIHBhdGNoQ29weS5kaWZmc1t5XSA9IHBhdGNoLmRpZmZzW3ldLnNsaWNlKCk7XHJcbiAgICB9XHJcbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xyXG4gICAgcGF0Y2hDb3B5LnN0YXJ0MiA9IHBhdGNoLnN0YXJ0MjtcclxuICAgIHBhdGNoQ29weS5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMTtcclxuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcclxuICAgIHBhdGNoZXNDb3B5W3hdID0gcGF0Y2hDb3B5O1xyXG4gIH1cclxuICByZXR1cm4gcGF0Y2hlc0NvcHk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGEgc2V0IG9mIHBhdGNoZXMgb250byB0aGUgdGV4dC4gIFJldHVybiBhIHBhdGNoZWQgdGV4dCwgYXMgd2VsbFxyXG4gKiBhcyBhIGxpc3Qgb2YgdHJ1ZS9mYWxzZSB2YWx1ZXMgaW5kaWNhdGluZyB3aGljaCBwYXRjaGVzIHdlcmUgYXBwbGllZC5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgT2xkIHRleHQuXHJcbiAqIEByZXR1cm4geyFBcnJheS48c3RyaW5nfCFBcnJheS48Ym9vbGVhbj4+fSBUd28gZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGVcclxuICogICAgICBuZXcgdGV4dCBhbmQgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hcHBseSA9IGZ1bmN0aW9uKHBhdGNoZXMsIHRleHQpIHtcclxuICBpZiAocGF0Y2hlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XHJcbiAgfVxyXG5cclxuICAvLyBEZWVwIGNvcHkgdGhlIHBhdGNoZXMgc28gdGhhdCBubyBjaGFuZ2VzIGFyZSBtYWRlIHRvIG9yaWdpbmFscy5cclxuICBwYXRjaGVzID0gdGhpcy5wYXRjaF9kZWVwQ29weShwYXRjaGVzKTtcclxuXHJcbiAgdmFyIG51bGxQYWRkaW5nID0gdGhpcy5wYXRjaF9hZGRQYWRkaW5nKHBhdGNoZXMpO1xyXG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZztcclxuXHJcbiAgdGhpcy5wYXRjaF9zcGxpdE1heChwYXRjaGVzKTtcclxuICAvLyBkZWx0YSBrZWVwcyB0cmFjayBvZiB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGV4cGVjdGVkIGFuZCBhY3R1YWwgbG9jYXRpb25cclxuICAvLyBvZiB0aGUgcHJldmlvdXMgcGF0Y2guICBJZiB0aGVyZSBhcmUgcGF0Y2hlcyBleHBlY3RlZCBhdCBwb3NpdGlvbnMgMTAgYW5kXHJcbiAgLy8gMjAsIGJ1dCB0aGUgZmlyc3QgcGF0Y2ggd2FzIGZvdW5kIGF0IDEyLCBkZWx0YSBpcyAyIGFuZCB0aGUgc2Vjb25kIHBhdGNoXHJcbiAgLy8gaGFzIGFuIGVmZmVjdGl2ZSBleHBlY3RlZCBwb3NpdGlvbiBvZiAyMi5cclxuICB2YXIgZGVsdGEgPSAwO1xyXG4gIHZhciByZXN1bHRzID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgZXhwZWN0ZWRfbG9jID0gcGF0Y2hlc1t4XS5zdGFydDIgKyBkZWx0YTtcclxuICAgIHZhciB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcclxuICAgIHZhciBzdGFydF9sb2M7XHJcbiAgICB2YXIgZW5kX2xvYyA9IC0xO1xyXG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cykge1xyXG4gICAgICAvLyBwYXRjaF9zcGxpdE1heCB3aWxsIG9ubHkgcHJvdmlkZSBhbiBvdmVyc2l6ZWQgcGF0dGVybiBpbiB0aGUgY2FzZSBvZlxyXG4gICAgICAvLyBhIG1vbnN0ZXIgZGVsZXRlLlxyXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIHRoaXMuTWF0Y2hfTWF4Qml0cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZF9sb2MpO1xyXG4gICAgICBpZiAoc3RhcnRfbG9jICE9IC0xKSB7XHJcbiAgICAgICAgZW5kX2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LFxyXG4gICAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gdGhpcy5NYXRjaF9NYXhCaXRzKSxcclxuICAgICAgICAgICAgZXhwZWN0ZWRfbG9jICsgdGV4dDEubGVuZ3RoIC0gdGhpcy5NYXRjaF9NYXhCaXRzKTtcclxuICAgICAgICBpZiAoZW5kX2xvYyA9PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xyXG4gICAgICAgICAgLy8gQ2FuJ3QgZmluZCB2YWxpZCB0cmFpbGluZyBjb250ZXh0LiAgRHJvcCB0aGlzIHBhdGNoLlxyXG4gICAgICAgICAgc3RhcnRfbG9jID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFydF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3RhcnRfbG9jID09IC0xKSB7XHJcbiAgICAgIC8vIE5vIG1hdGNoIGZvdW5kLiAgOihcclxuICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgZGVsdGEgZm9yIHRoaXMgZmFpbGVkIHBhdGNoIGZyb20gc3Vic2VxdWVudCBwYXRjaGVzLlxyXG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBGb3VuZCBhIG1hdGNoLiAgOilcclxuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XHJcbiAgICAgIGRlbHRhID0gc3RhcnRfbG9jIC0gZXhwZWN0ZWRfbG9jO1xyXG4gICAgICB2YXIgdGV4dDI7XHJcbiAgICAgIGlmIChlbmRfbG9jID09IC0xKSB7XHJcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIGVuZF9sb2MgKyB0aGlzLk1hdGNoX01heEJpdHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xyXG4gICAgICAgIC8vIFBlcmZlY3QgbWF0Y2gsIGp1c3Qgc2hvdmUgdGhlIHJlcGxhY2VtZW50IHRleHQgaW4uXHJcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYykgK1xyXG4gICAgICAgICAgICAgICB0aGlzLmRpZmZfdGV4dDIocGF0Y2hlc1t4XS5kaWZmcykgK1xyXG4gICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEltcGVyZmVjdCBtYXRjaC4gIFJ1biBhIGRpZmYgdG8gZ2V0IGEgZnJhbWV3b3JrIG9mIGVxdWl2YWxlbnRcclxuICAgICAgICAvLyBpbmRpY2VzLlxyXG4gICAgICAgIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxLCB0ZXh0MiwgZmFsc2UpO1xyXG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMgJiZcclxuICAgICAgICAgICAgdGhpcy5kaWZmX2xldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+XHJcbiAgICAgICAgICAgIHRoaXMuUGF0Y2hfRGVsZXRlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAvLyBUaGUgZW5kIHBvaW50cyBtYXRjaCwgYnV0IHRoZSBjb250ZW50IGlzIHVuYWNjZXB0YWJseSBiYWQuXHJcbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XHJcbiAgICAgICAgICB2YXIgaW5kZXgxID0gMDtcclxuICAgICAgICAgIHZhciBpbmRleDI7XHJcbiAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHBhdGNoZXNbeF0uZGlmZnMubGVuZ3RoOyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XHJcbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgICAgICBpbmRleDIgPSB0aGlzLmRpZmZfeEluZGV4KGRpZmZzLCBpbmRleDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7ICAvLyBJbnNlcnRpb25cclxuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jICsgaW5kZXgyKSArIG1vZFsxXSArXHJcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGluZGV4Mik7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkgeyAgLy8gRGVsZXRpb25cclxuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jICsgaW5kZXgyKSArXHJcbiAgICAgICAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpIHtcclxuICAgICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBTdHJpcCB0aGUgcGFkZGluZyBvZmYuXHJcbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xyXG4gIHJldHVybiBbdGV4dCwgcmVzdWx0c107XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZCBzb21lIHBhZGRpbmcgb24gdGV4dCBzdGFydCBhbmQgZW5kIHNvIHRoYXQgZWRnZXMgY2FuIG1hdGNoIHNvbWV0aGluZy5cclxuICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHBhZGRpbmcgc3RyaW5nIGFkZGVkIHRvIGVhY2ggc2lkZS5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZFBhZGRpbmcgPSBmdW5jdGlvbihwYXRjaGVzKSB7XHJcbiAgdmFyIHBhZGRpbmdMZW5ndGggPSB0aGlzLlBhdGNoX01hcmdpbjtcclxuICB2YXIgbnVsbFBhZGRpbmcgPSAnJztcclxuICBmb3IgKHZhciB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspIHtcclxuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XHJcbiAgfVxyXG5cclxuICAvLyBCdW1wIGFsbCB0aGUgcGF0Y2hlcyBmb3J3YXJkLlxyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcclxuICAgIHBhdGNoZXNbeF0uc3RhcnQyICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIHN0YXJ0IG9mIGZpcnN0IGRpZmYuXHJcbiAgdmFyIHBhdGNoID0gcGF0Y2hlc1swXTtcclxuICB2YXIgZGlmZnMgPSBwYXRjaC5kaWZmcztcclxuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbMF1bMF0gIT0gRElGRl9FUVVBTCkge1xyXG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxyXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcclxuICAgIHBhdGNoLnN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXHJcbiAgICBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xyXG4gICAgLy8gR3JvdyBmaXJzdCBlcXVhbGl0eS5cclxuICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1swXVsxXS5sZW5ndGg7XHJcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XHJcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XHJcbiAgICBwYXRjaC5zdGFydDIgLT0gZXh0cmFMZW5ndGg7XHJcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gZW5kIG9mIGxhc3QgZGlmZi5cclxuICBwYXRjaCA9IHBhdGNoZXNbcGF0Y2hlcy5sZW5ndGggLSAxXTtcclxuICBkaWZmcyA9IHBhdGNoLmRpZmZzO1xyXG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPSBESUZGX0VRVUFMKSB7XHJcbiAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXHJcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pO1xyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xyXG4gICAgLy8gR3JvdyBsYXN0IGVxdWFsaXR5LlxyXG4gICAgdmFyIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aDtcclxuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCk7XHJcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsUGFkZGluZztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogTG9vayB0aHJvdWdoIHRoZSBwYXRjaGVzIGFuZCBicmVhayB1cCBhbnkgd2hpY2ggYXJlIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtXHJcbiAqIGxpbWl0IG9mIHRoZSBtYXRjaCBhbGdvcml0aG0uXHJcbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfc3BsaXRNYXggPSBmdW5jdGlvbihwYXRjaGVzKSB7XHJcbiAgdmFyIHBhdGNoX3NpemUgPSB0aGlzLk1hdGNoX01heEJpdHM7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBpZiAocGF0Y2hlc1t4XS5sZW5ndGgxIDw9IHBhdGNoX3NpemUpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICB2YXIgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xyXG4gICAgLy8gUmVtb3ZlIHRoZSBiaWcgb2xkIHBhdGNoLlxyXG4gICAgcGF0Y2hlcy5zcGxpY2UoeC0tLCAxKTtcclxuICAgIHZhciBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDE7XHJcbiAgICB2YXIgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xyXG4gICAgdmFyIHByZWNvbnRleHQgPSAnJztcclxuICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgLy8gQ3JlYXRlIG9uZSBvZiBzZXZlcmFsIHNtYWxsZXIgcGF0Y2hlcy5cclxuICAgICAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MSA9IHN0YXJ0MSAtIHByZWNvbnRleHQubGVuZ3RoO1xyXG4gICAgICBwYXRjaC5zdGFydDIgPSBzdGFydDIgLSBwcmVjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgaWYgKHByZWNvbnRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDIgPSBwcmVjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVjb250ZXh0XSk7XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMSA8IHBhdGNoX3NpemUgLSB0aGlzLlBhdGNoX01hcmdpbikge1xyXG4gICAgICAgIHZhciBkaWZmX3R5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcclxuICAgICAgICB2YXIgZGlmZl90ZXh0ID0gYmlncGF0Y2guZGlmZnNbMF1bMV07XHJcbiAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgICAgIC8vIEluc2VydGlvbnMgYXJlIGhhcm1sZXNzLlxyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9ERUxFVEUgJiYgcGF0Y2guZGlmZnMubGVuZ3RoID09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgIHBhdGNoLmRpZmZzWzBdWzBdID09IERJRkZfRVFVQUwgJiZcclxuICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dC5sZW5ndGggPiAyICogcGF0Y2hfc2l6ZSkge1xyXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhcmdlIGRlbGV0aW9uLiAgTGV0IGl0IHBhc3MgaW4gb25lIGNodW5rLlxyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbZGlmZl90eXBlLCBkaWZmX3RleHRdKTtcclxuICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIERlbGV0aW9uIG9yIGVxdWFsaXR5LiAgT25seSB0YWtlIGFzIG11Y2ggYXMgd2UgY2FuIHN0b21hY2guXHJcbiAgICAgICAgICBkaWZmX3RleHQgPSBkaWZmX3RleHQuc3Vic3RyaW5nKDAsXHJcbiAgICAgICAgICAgICAgcGF0Y2hfc2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSB0aGlzLlBhdGNoX01hcmdpbik7XHJcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xyXG4gICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PSBiaWdwYXRjaC5kaWZmc1swXVsxXSkge1xyXG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0gPVxyXG4gICAgICAgICAgICAgICAgYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBDb21wdXRlIHRoZSBoZWFkIGNvbnRleHQgZm9yIHRoZSBuZXh0IHBhdGNoLlxyXG4gICAgICBwcmVjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQyKHBhdGNoLmRpZmZzKTtcclxuICAgICAgcHJlY29udGV4dCA9XHJcbiAgICAgICAgICBwcmVjb250ZXh0LnN1YnN0cmluZyhwcmVjb250ZXh0Lmxlbmd0aCAtIHRoaXMuUGF0Y2hfTWFyZ2luKTtcclxuICAgICAgLy8gQXBwZW5kIHRoZSBlbmQgY29udGV4dCBmb3IgdGhpcyBwYXRjaC5cclxuICAgICAgdmFyIHBvc3Rjb250ZXh0ID0gdGhpcy5kaWZmX3RleHQxKGJpZ3BhdGNoLmRpZmZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygwLCB0aGlzLlBhdGNoX01hcmdpbik7XHJcbiAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gJycpIHtcclxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXHJcbiAgICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVsxXSArPSBwb3N0Y29udGV4dDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdGNvbnRleHRdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFlbXB0eSkge1xyXG4gICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUYWtlIGEgbGlzdCBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRleHQgcmVwcmVzZW50YXRpb24gb2YgcGF0Y2hlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3RvVGV4dCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcclxuICB2YXIgdGV4dCA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgbGlzdCBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dGxpbmUgVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEB0aHJvd3MgeyFFcnJvcn0gSWYgaW52YWxpZCBpbnB1dC5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2Zyb21UZXh0ID0gZnVuY3Rpb24odGV4dGxpbmUpIHtcclxuICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gIGlmICghdGV4dGxpbmUpIHtcclxuICAgIHJldHVybiBwYXRjaGVzO1xyXG4gIH1cclxuICB2YXIgdGV4dCA9IHRleHRsaW5lLnNwbGl0KCdcXG4nKTtcclxuICB2YXIgdGV4dFBvaW50ZXIgPSAwO1xyXG4gIHZhciBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XHJcbiAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcclxuICAgIHZhciBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xyXG4gICAgaWYgKCFtKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBzdHJpbmc6ICcgKyB0ZXh0W3RleHRQb2ludGVyXSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XHJcbiAgICBwYXRjaC5zdGFydDEgPSBwYXJzZUludChtWzFdLCAxMCk7XHJcbiAgICBpZiAobVsyXSA9PT0gJycpIHtcclxuICAgICAgcGF0Y2guc3RhcnQxLS07XHJcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAxO1xyXG4gICAgfSBlbHNlIGlmIChtWzJdID09ICcwJykge1xyXG4gICAgICBwYXRjaC5sZW5ndGgxID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgxID0gcGFyc2VJbnQobVsyXSwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIHBhdGNoLnN0YXJ0MiA9IHBhcnNlSW50KG1bM10sIDEwKTtcclxuICAgIGlmIChtWzRdID09PSAnJykge1xyXG4gICAgICBwYXRjaC5zdGFydDItLTtcclxuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDE7XHJcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT0gJzAnKSB7XHJcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGF0Y2guc3RhcnQyLS07XHJcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSBwYXJzZUludChtWzRdLCAxMCk7XHJcbiAgICB9XHJcbiAgICB0ZXh0UG9pbnRlcisrO1xyXG5cclxuICAgIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBzaWduID0gdGV4dFt0ZXh0UG9pbnRlcl0uY2hhckF0KDApO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHZhciBsaW5lID0gZGVjb2RlVVJJKHRleHRbdGV4dFBvaW50ZXJdLnN1YnN0cmluZygxKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZXNjYXBlIGluIHBhdGNoX2Zyb21UZXh0OiAnICsgbGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHNpZ24gPT0gJy0nKSB7XHJcbiAgICAgICAgLy8gRGVsZXRpb24uXHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKTtcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcrJykge1xyXG4gICAgICAgIC8vIEluc2VydGlvbi5cclxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJyAnKSB7XHJcbiAgICAgICAgLy8gTWlub3IgZXF1YWxpdHkuXHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJ0AnKSB7XHJcbiAgICAgICAgLy8gU3RhcnQgb2YgbmV4dCBwYXRjaC5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09PSAnJykge1xyXG4gICAgICAgIC8vIEJsYW5rIGxpbmU/ICBXaGF0ZXZlci5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBXVEY/XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIG1vZGUgXCInICsgc2lnbiArICdcIiBpbjogJyArIGxpbmUpO1xyXG4gICAgICB9XHJcbiAgICAgIHRleHRQb2ludGVyKys7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBwYXRjaGVzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgb25lIHBhdGNoIG9wZXJhdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaiA9IGZ1bmN0aW9uKCkge1xyXG4gIC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi9cclxuICB0aGlzLmRpZmZzID0gW107XHJcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xyXG4gIHRoaXMuc3RhcnQxID0gbnVsbDtcclxuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXHJcbiAgdGhpcy5zdGFydDIgPSBudWxsO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIHRoaXMubGVuZ3RoMSA9IDA7XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgdGhpcy5sZW5ndGgyID0gMDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRW1tdWxhdGUgR05VIGRpZmYncyBmb3JtYXQuXHJcbiAqIEhlYWRlcjogQEAgLTM4Miw4ICs0ODEsOSBAQFxyXG4gKiBJbmRpY2llcyBhcmUgcHJpbnRlZCBhcyAxLWJhc2VkLCBub3QgMC1iYXNlZC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgR05VIGRpZmYgc3RyaW5nLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIGNvb3JkczEsIGNvb3JkczI7XHJcbiAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMCkge1xyXG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgJywwJztcclxuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMSA9PSAxKSB7XHJcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb29yZHMxID0gKHRoaXMuc3RhcnQxICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDE7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmxlbmd0aDIgPT09IDApIHtcclxuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArICcsMCc7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT0gMSkge1xyXG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgMTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29vcmRzMiA9ICh0aGlzLnN0YXJ0MiArIDEpICsgJywnICsgdGhpcy5sZW5ndGgyO1xyXG4gIH1cclxuICB2YXIgdGV4dCA9IFsnQEAgLScgKyBjb29yZHMxICsgJyArJyArIGNvb3JkczIgKyAnIEBAXFxuJ107XHJcbiAgdmFyIG9wO1xyXG4gIC8vIEVzY2FwZSB0aGUgYm9keSBvZiB0aGUgcGF0Y2ggd2l0aCAleHggbm90YXRpb24uXHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBzd2l0Y2ggKHRoaXMuZGlmZnNbeF1bMF0pIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBvcCA9ICcrJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBvcCA9ICctJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIG9wID0gJyAnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgdGV4dFt4ICsgMV0gPSBvcCArIGVuY29kZVVSSSh0aGlzLmRpZmZzW3hdWzFdKSArICdcXG4nO1xyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcclxufTtcclxuXHJcblxyXG4vLyBUaGUgZm9sbG93aW5nIGV4cG9ydCBjb2RlIHdhcyBhZGRlZCBieSBARm9yYmVzTGluZGVzYXlcclxubW9kdWxlLmV4cG9ydHMgPSBkaWZmX21hdGNoX3BhdGNoO1xyXG5tb2R1bGUuZXhwb3J0c1snZGlmZl9tYXRjaF9wYXRjaCddID0gZGlmZl9tYXRjaF9wYXRjaDtcclxubW9kdWxlLmV4cG9ydHNbJ0RJRkZfREVMRVRFJ10gPSBESUZGX0RFTEVURTtcclxubW9kdWxlLmV4cG9ydHNbJ0RJRkZfSU5TRVJUJ10gPSBESUZGX0lOU0VSVDtcclxubW9kdWxlLmV4cG9ydHNbJ0RJRkZfRVFVQUwnXSA9IERJRkZfRVFVQUw7XHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZGlmZi1tYXRjaC1wYXRjaC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50JylcblxuZnVuY3Rpb24gQ3VydmUgKHAsIGEsIGIsIEd4LCBHeSwgbiwgaCkge1xuICB0aGlzLnAgPSBwXG4gIHRoaXMuYSA9IGFcbiAgdGhpcy5iID0gYlxuICB0aGlzLkcgPSBQb2ludC5mcm9tQWZmaW5lKHRoaXMsIEd4LCBHeSlcbiAgdGhpcy5uID0gblxuICB0aGlzLmggPSBoXG5cbiAgdGhpcy5pbmZpbml0eSA9IG5ldyBQb2ludCh0aGlzLCBudWxsLCBudWxsLCBCaWdJbnRlZ2VyLlpFUk8pXG5cbiAgLy8gcmVzdWx0IGNhY2hpbmdcbiAgdGhpcy5wT3ZlckZvdXIgPSBwLmFkZChCaWdJbnRlZ2VyLk9ORSkuc2hpZnRSaWdodCgyKVxufVxuXG5DdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIChpc09kZCwgeCkge1xuICB2YXIgYWxwaGEgPSB4LnBvdygzKS5hZGQodGhpcy5hLm11bHRpcGx5KHgpKS5hZGQodGhpcy5iKS5tb2QodGhpcy5wKVxuICB2YXIgYmV0YSA9IGFscGhhLm1vZFBvdyh0aGlzLnBPdmVyRm91ciwgdGhpcy5wKSAvLyBYWFg6IG5vdCBjb21wYXRpYmxlIHdpdGggYWxsIGN1cnZlc1xuXG4gIHZhciB5ID0gYmV0YVxuICBpZiAoYmV0YS5pc0V2ZW4oKSBeICFpc09kZCkge1xuICAgIHkgPSB0aGlzLnAuc3VidHJhY3QoeSkgLy8gLXkgJSBwXG4gIH1cblxuICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh0aGlzLCB4LCB5KVxufVxuXG5DdXJ2ZS5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIChRKSB7XG4gIGlmIChRID09PSB0aGlzLmluZmluaXR5KSByZXR1cm4gdHJ1ZVxuXG4gIHJldHVybiBRLnouc2lnbnVtKCkgPT09IDAgJiYgUS55LnNpZ251bSgpICE9PSAwXG59XG5cbkN1cnZlLnByb3RvdHlwZS5pc09uQ3VydmUgPSBmdW5jdGlvbiAoUSkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KFEpKSByZXR1cm4gdHJ1ZVxuXG4gIHZhciB4ID0gUS5hZmZpbmVYXG4gIHZhciB5ID0gUS5hZmZpbmVZXG4gIHZhciBhID0gdGhpcy5hXG4gIHZhciBiID0gdGhpcy5iXG4gIHZhciBwID0gdGhpcy5wXG5cbiAgLy8gQ2hlY2sgdGhhdCB4USBhbmQgeVEgYXJlIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMCwgcCAtIDFdXG4gIGlmICh4LnNpZ251bSgpIDwgMCB8fCB4LmNvbXBhcmVUbyhwKSA+PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKHkuc2lnbnVtKCkgPCAwIHx8IHkuY29tcGFyZVRvKHApID49IDApIHJldHVybiBmYWxzZVxuXG4gIC8vIGFuZCBjaGVjayB0aGF0IHleMiA9IHheMyArIGF4ICsgYiAobW9kIHApXG4gIHZhciBsaHMgPSB5LnNxdWFyZSgpLm1vZChwKVxuICB2YXIgcmhzID0geC5wb3coMykuYWRkKGEubXVsdGlwbHkoeCkpLmFkZChiKS5tb2QocClcbiAgcmV0dXJuIGxocy5lcXVhbHMocmhzKVxufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICpcbiAqIFNlZSBTRUMgMSwgc2VjdGlvbiAzLjIuMi4xOiBFbGxpcHRpYyBDdXJ2ZSBQdWJsaWMgS2V5IFZhbGlkYXRpb24gUHJpbWl0aXZlXG4gKi9cbkN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChRKSB7XG4gIC8vIENoZWNrIFEgIT0gT1xuICBhc3NlcnQoIXRoaXMuaXNJbmZpbml0eShRKSwgJ1BvaW50IGlzIGF0IGluZmluaXR5JylcbiAgYXNzZXJ0KHRoaXMuaXNPbkN1cnZlKFEpLCAnUG9pbnQgaXMgbm90IG9uIHRoZSBjdXJ2ZScpXG5cbiAgLy8gQ2hlY2sgblEgPSBPICh3aGVyZSBRIGlzIGEgc2NhbGFyIG11bHRpcGxlIG9mIEcpXG4gIHZhciBuUSA9IFEubXVsdGlwbHkodGhpcy5uKVxuICBhc3NlcnQodGhpcy5pc0luZmluaXR5KG5RKSwgJ1BvaW50IGlzIG5vdCBhIHNjYWxhciBtdWx0aXBsZSBvZiBHJylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYlwiKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJzZWNwMTI4cjFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZkZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIsXG4gICAgXCJhXCI6IFwiZmZmZmZmZmRmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNcIixcbiAgICBcImJcIjogXCJlODc1NzljMTEwNzlmNDNkZDgyNDk5M2MyY2VlNWVkM1wiLFxuICAgIFwiblwiOiBcImZmZmZmZmZlMDAwMDAwMDA3NWEzMGQxYjkwMzhhMTE1XCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiMTYxZmY3NTI4Yjg5OWIyZDBjMjg2MDdjYTUyYzViODZcIixcbiAgICBcIkd5XCI6IFwiY2Y1YWM4Mzk1YmFmZWIxM2MwMmRhMjkyZGRlZDdhODNcIlxuICB9LFxuICBcInNlY3AxNjBrMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmYWM3M1wiLFxuICAgIFwiYVwiOiBcIjAwXCIsXG4gICAgXCJiXCI6IFwiMDdcIixcbiAgICBcIm5cIjogXCIwMTAwMDAwMDAwMDAwMDAwMDAwMDAxYjhmYTE2ZGZhYjlhY2ExNmI2YjNcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCIzYjRjMzgyY2UzN2FhMTkyYTQwMTllNzYzMDM2ZjRmNWRkNGQ3ZWJiXCIsXG4gICAgXCJHeVwiOiBcIjkzOGNmOTM1MzE4ZmRjZWQ2YmMyODI4NjUzMTczM2MzZjAzYzRmZWVcIlxuICB9LFxuICBcInNlY3AxNjByMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY3ZmZmZmZmZlwiLFxuICAgIFwiYVwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2ZmZmZmZmNcIixcbiAgICBcImJcIjogXCIxYzk3YmVmYzU0YmQ3YThiNjVhY2Y4OWY4MWQ0ZDRhZGM1NjVmYTQ1XCIsXG4gICAgXCJuXCI6IFwiMDEwMDAwMDAwMDAwMDAwMDAwMDAwMWY0YzhmOTI3YWVkM2NhNzUyMjU3XCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiNGE5NmI1Njg4ZWY1NzMyODQ2NjQ2OTg5NjhjMzhiYjkxM2NiZmM4MlwiLFxuICAgIFwiR3lcIjogXCIyM2E2Mjg1NTMxNjg5NDdkNTlkY2M5MTIwNDIzNTEzNzdhYzVmYjMyXCJcbiAgfSxcbiAgXCJzZWNwMTkyazFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZWUzN1wiLFxuICAgIFwiYVwiOiBcIjAwXCIsXG4gICAgXCJiXCI6IFwiMDNcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmUyNmYyZmMxNzBmNjk0NjZhNzRkZWZkOGRcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCJkYjRmZjEwZWMwNTdlOWFlMjZiMDdkMDI4MGI3ZjQzNDFkYTVkMWIxZWFlMDZjN2RcIixcbiAgICBcIkd5XCI6IFwiOWIyZjJmNmQ5YzU2MjhhNzg0NDE2M2QwMTViZTg2MzQ0MDgyYWE4OGQ5NWUyZjlkXCJcbiAgfSxcbiAgXCJzZWNwMTkycjFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZmZmZmZmZmZmZmZlwiLFxuICAgIFwiYVwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZmZmZmZmZmZmZmY1wiLFxuICAgIFwiYlwiOiBcIjY0MjEwNTE5ZTU5YzgwZTcwZmE3ZTlhYjcyMjQzMDQ5ZmViOGRlZWNjMTQ2YjliMVwiLFxuICAgIFwiblwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjk5ZGVmODM2MTQ2YmM5YjFiNGQyMjgzMVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjE4OGRhODBlYjAzMDkwZjY3Y2JmMjBlYjQzYTE4ODAwZjRmZjBhZmQ4MmZmMTAxMlwiLFxuICAgIFwiR3lcIjogXCIwNzE5MmI5NWZmYzhkYTc4NjMxMDExZWQ2YjI0Y2RkNTczZjk3N2ExMWU3OTQ4MTFcIlxuICB9LFxuICBcInNlY3AyNTZrMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZlwiLFxuICAgIFwiYVwiOiBcIjAwXCIsXG4gICAgXCJiXCI6IFwiMDdcIixcbiAgICBcIm5cIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiLFxuICAgIFwiR3lcIjogXCI0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4XCJcbiAgfSxcbiAgXCJzZWNwMjU2cjFcIjoge1xuICAgIFwicFwiOiBcImZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiNWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YlwiLFxuICAgIFwiblwiOiBcImZmZmZmZmZmMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmYmNlNmZhYWRhNzE3OWU4NGYzYjljYWMyZmM2MzI1NTFcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCI2YjE3ZDFmMmUxMmM0MjQ3ZjhiY2U2ZTU2M2E0NDBmMjc3MDM3ZDgxMmRlYjMzYTBmNGExMzk0NWQ4OThjMjk2XCIsXG4gICAgXCJHeVwiOiBcIjRmZTM0MmUyZmUxYTdmOWI4ZWU3ZWI0YTdjMGY5ZTE2MmJjZTMzNTc2YjMxNWVjZWNiYjY0MDY4MzdiZjUxZjVcIlxuICB9XG59XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgUG9pbnQgPSByZXF1aXJlKCcuL3BvaW50JylcbnZhciBDdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKVxuXG52YXIgZ2V0Q3VydmVCeU5hbWUgPSByZXF1aXJlKCcuL25hbWVzJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEN1cnZlOiBDdXJ2ZSxcbiAgUG9pbnQ6IFBvaW50LFxuICBnZXRDdXJ2ZUJ5TmFtZTogZ2V0Q3VydmVCeU5hbWVcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcblxudmFyIGN1cnZlcyA9IHJlcXVpcmUoJy4vY3VydmVzLmpzb24nKVxudmFyIEN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpXG5cbmZ1bmN0aW9uIGdldEN1cnZlQnlOYW1lIChuYW1lKSB7XG4gIHZhciBjdXJ2ZSA9IGN1cnZlc1tuYW1lXVxuICBpZiAoIWN1cnZlKSByZXR1cm4gbnVsbFxuXG4gIHZhciBwID0gbmV3IEJpZ0ludGVnZXIoY3VydmUucCwgMTYpXG4gIHZhciBhID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuYSwgMTYpXG4gIHZhciBiID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuYiwgMTYpXG4gIHZhciBuID0gbmV3IEJpZ0ludGVnZXIoY3VydmUubiwgMTYpXG4gIHZhciBoID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuaCwgMTYpXG4gIHZhciBHeCA9IG5ldyBCaWdJbnRlZ2VyKGN1cnZlLkd4LCAxNilcbiAgdmFyIEd5ID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuR3ksIDE2KVxuXG4gIHJldHVybiBuZXcgQ3VydmUocCwgYSwgYiwgR3gsIEd5LCBuLCBoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnZlQnlOYW1lXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvbmFtZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJylcblxudmFyIFRIUkVFID0gQmlnSW50ZWdlci52YWx1ZU9mKDMpXG5cbmZ1bmN0aW9uIFBvaW50IChjdXJ2ZSwgeCwgeSwgeikge1xuICBhc3NlcnQubm90U3RyaWN0RXF1YWwoeiwgdW5kZWZpbmVkLCAnTWlzc2luZyBaIGNvb3JkaW5hdGUnKVxuXG4gIHRoaXMuY3VydmUgPSBjdXJ2ZVxuICB0aGlzLnggPSB4XG4gIHRoaXMueSA9IHlcbiAgdGhpcy56ID0gelxuICB0aGlzLl96SW52ID0gbnVsbFxuXG4gIHRoaXMuY29tcHJlc3NlZCA9IHRydWVcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ3pJbnYnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl96SW52ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl96SW52ID0gdGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5wKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl96SW52XG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2ludC5wcm90b3R5cGUsICdhZmZpbmVYJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy54Lm11bHRpcGx5KHRoaXMuekludikubW9kKHRoaXMuY3VydmUucClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ2FmZmluZVknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnkubXVsdGlwbHkodGhpcy56SW52KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB9XG59KVxuXG5Qb2ludC5mcm9tQWZmaW5lID0gZnVuY3Rpb24gKGN1cnZlLCB4LCB5KSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIHgsIHksIEJpZ0ludGVnZXIuT05FKVxufVxuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykgcmV0dXJuIHRydWVcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIHRoaXMuY3VydmUuaXNJbmZpbml0eShvdGhlcilcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eShvdGhlcikpIHJldHVybiB0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcylcblxuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdmFyIHUgPSBvdGhlci55Lm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55Lm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIGlmICh1LnNpZ251bSgpICE9PSAwKSByZXR1cm4gZmFsc2VcblxuICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgdmFyIHYgPSBvdGhlci54Lm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54Lm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIHJldHVybiB2LnNpZ251bSgpID09PSAwXG59XG5cblBvaW50LnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gdGhpcy5jdXJ2ZS5wLnN1YnRyYWN0KHRoaXMueSlcblxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMuY3VydmUsIHRoaXMueCwgeSwgdGhpcy56KVxufVxuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIGJcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eShiKSkgcmV0dXJuIHRoaXNcblxuICB2YXIgeDEgPSB0aGlzLnhcbiAgdmFyIHkxID0gdGhpcy55XG4gIHZhciB4MiA9IGIueFxuICB2YXIgeTIgPSBiLnlcblxuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdmFyIHUgPSB5Mi5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHkxLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2YXIgdiA9IHgyLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QoeDEubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucClcblxuICBpZiAodi5zaWdudW0oKSA9PT0gMCkge1xuICAgIGlmICh1LnNpZ251bSgpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50d2ljZSgpIC8vIHRoaXMgPT0gYiwgc28gZG91YmxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHkgLy8gdGhpcyA9IC1iLCBzbyBpbmZpbml0eVxuICB9XG5cbiAgdmFyIHYyID0gdi5zcXVhcmUoKVxuICB2YXIgdjMgPSB2Mi5tdWx0aXBseSh2KVxuICB2YXIgeDF2MiA9IHgxLm11bHRpcGx5KHYyKVxuICB2YXIgenUyID0gdS5zcXVhcmUoKS5tdWx0aXBseSh0aGlzLnopXG5cbiAgLy8geDMgPSB2ICogKHoyICogKHoxICogdV4yIC0gMiAqIHgxICogdl4yKSAtIHZeMylcbiAgdmFyIHgzID0genUyLnN1YnRyYWN0KHgxdjIuc2hpZnRMZWZ0KDEpKS5tdWx0aXBseShiLnopLnN1YnRyYWN0KHYzKS5tdWx0aXBseSh2KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB5MyA9IHoyICogKDMgKiB4MSAqIHUgKiB2XjIgLSB5MSAqIHZeMyAtIHoxICogdV4zKSArIHUgKiB2XjNcbiAgdmFyIHkzID0geDF2Mi5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkodSkuc3VidHJhY3QoeTEubXVsdGlwbHkodjMpKS5zdWJ0cmFjdCh6dTIubXVsdGlwbHkodSkpLm11bHRpcGx5KGIueikuYWRkKHUubXVsdGlwbHkodjMpKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB6MyA9IHZeMyAqIHoxICogejJcbiAgdmFyIHozID0gdjMubXVsdGlwbHkodGhpcy56KS5tdWx0aXBseShiLnopLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmN1cnZlLCB4MywgeTMsIHozKVxufVxuXG5Qb2ludC5wcm90b3R5cGUudHdpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiB0aGlzXG4gIGlmICh0aGlzLnkuc2lnbnVtKCkgPT09IDApIHJldHVybiB0aGlzLmN1cnZlLmluZmluaXR5XG5cbiAgdmFyIHgxID0gdGhpcy54XG4gIHZhciB5MSA9IHRoaXMueVxuXG4gIHZhciB5MXoxID0geTEubXVsdGlwbHkodGhpcy56KVxuICB2YXIgeTFzcXoxID0geTF6MS5tdWx0aXBseSh5MSkubW9kKHRoaXMuY3VydmUucClcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmFcblxuICAvLyB3ID0gMyAqIHgxXjIgKyBhICogejFeMlxuICB2YXIgdyA9IHgxLnNxdWFyZSgpLm11bHRpcGx5KFRIUkVFKVxuXG4gIGlmIChhLnNpZ251bSgpICE9PSAwKSB7XG4gICAgdyA9IHcuYWRkKHRoaXMuei5zcXVhcmUoKS5tdWx0aXBseShhKSlcbiAgfVxuXG4gIHcgPSB3Lm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHgzID0gMiAqIHkxICogejEgKiAod14yIC0gOCAqIHgxICogeTFeMiAqIHoxKVxuICB2YXIgeDMgPSB3LnNxdWFyZSgpLnN1YnRyYWN0KHgxLnNoaWZ0TGVmdCgzKS5tdWx0aXBseSh5MXNxejEpKS5zaGlmdExlZnQoMSkubXVsdGlwbHkoeTF6MSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8geTMgPSA0ICogeTFeMiAqIHoxICogKDMgKiB3ICogeDEgLSAyICogeTFeMiAqIHoxKSAtIHdeM1xuICB2YXIgeTMgPSB3Lm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh4MSkuc3VidHJhY3QoeTFzcXoxLnNoaWZ0TGVmdCgxKSkuc2hpZnRMZWZ0KDIpLm11bHRpcGx5KHkxc3F6MSkuc3VidHJhY3Qody5wb3coMykpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHozID0gOCAqICh5MSAqIHoxKV4zXG4gIHZhciB6MyA9IHkxejEucG93KDMpLnNoaWZ0TGVmdCgzKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5jdXJ2ZSwgeDMsIHkzLCB6Mylcbn1cblxuLy8gU2ltcGxlIE5BRiAoTm9uLUFkamFjZW50IEZvcm0pIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuLy8gVE9ETzogbW9kdWxhcml6ZSB0aGUgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG5Qb2ludC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoaykge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gdGhpc1xuICBpZiAoay5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHlcblxuICB2YXIgZSA9IGtcbiAgdmFyIGggPSBlLm11bHRpcGx5KFRIUkVFKVxuXG4gIHZhciBuZWcgPSB0aGlzLm5lZ2F0ZSgpXG4gIHZhciBSID0gdGhpc1xuXG4gIGZvciAodmFyIGkgPSBoLmJpdExlbmd0aCgpIC0gMjsgaSA+IDA7IC0taSkge1xuICAgIHZhciBoQml0ID0gaC50ZXN0Qml0KGkpXG4gICAgdmFyIGVCaXQgPSBlLnRlc3RCaXQoaSlcblxuICAgIFIgPSBSLnR3aWNlKClcblxuICAgIGlmIChoQml0ICE9PSBlQml0KSB7XG4gICAgICBSID0gUi5hZGQoaEJpdCA/IHRoaXMgOiBuZWcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJcbn1cblxuLy8gQ29tcHV0ZSB0aGlzKmogKyB4KmsgKHNpbXVsdGFuZW91cyBtdWx0aXBsaWNhdGlvbilcblBvaW50LnByb3RvdHlwZS5tdWx0aXBseVR3byA9IGZ1bmN0aW9uIChqLCB4LCBrKSB7XG4gIHZhciBpID0gTWF0aC5tYXgoai5iaXRMZW5ndGgoKSwgay5iaXRMZW5ndGgoKSkgLSAxXG4gIHZhciBSID0gdGhpcy5jdXJ2ZS5pbmZpbml0eVxuICB2YXIgYm90aCA9IHRoaXMuYWRkKHgpXG5cbiAgd2hpbGUgKGkgPj0gMCkge1xuICAgIHZhciBqQml0ID0gai50ZXN0Qml0KGkpXG4gICAgdmFyIGtCaXQgPSBrLnRlc3RCaXQoaSlcblxuICAgIFIgPSBSLnR3aWNlKClcblxuICAgIGlmIChqQml0KSB7XG4gICAgICBpZiAoa0JpdCkge1xuICAgICAgICBSID0gUi5hZGQoYm90aClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFIgPSBSLmFkZCh0aGlzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa0JpdCkge1xuICAgICAgUiA9IFIuYWRkKHgpXG4gICAgfVxuICAgIC0taVxuICB9XG5cbiAgcmV0dXJuIFJcbn1cblxuUG9pbnQucHJvdG90eXBlLmdldEVuY29kZWQgPSBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICBpZiAoY29tcHJlc3NlZCA9PSBudWxsKSBjb21wcmVzc2VkID0gdGhpcy5jb21wcmVzc2VkXG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiBuZXcgQnVmZmVyKCcwMCcsICdoZXgnKSAvLyBJbmZpbml0eSBwb2ludCBlbmNvZGVkIGlzIHNpbXBseSAnMDAnXG5cbiAgdmFyIHggPSB0aGlzLmFmZmluZVhcbiAgdmFyIHkgPSB0aGlzLmFmZmluZVlcblxuICB2YXIgYnVmZmVyXG5cbiAgLy8gRGV0ZXJtaW5lIHNpemUgb2YgcSBpbiBieXRlc1xuICB2YXIgYnl0ZUxlbmd0aCA9IE1hdGguZmxvb3IoKHRoaXMuY3VydmUucC5iaXRMZW5ndGgoKSArIDcpIC8gOClcblxuICAvLyAweDAyLzB4MDMgfCBYXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgYnVmZmVyID0gbmV3IEJ1ZmZlcigxICsgYnl0ZUxlbmd0aClcbiAgICBidWZmZXIud3JpdGVVSW50OCh5LmlzRXZlbigpID8gMHgwMiA6IDB4MDMsIDApXG5cbiAgLy8gMHgwNCB8IFggfCBZXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gbmV3IEJ1ZmZlcigxICsgYnl0ZUxlbmd0aCArIGJ5dGVMZW5ndGgpXG4gICAgYnVmZmVyLndyaXRlVUludDgoMHgwNCwgMClcblxuICAgIHkudG9CdWZmZXIoYnl0ZUxlbmd0aCkuY29weShidWZmZXIsIDEgKyBieXRlTGVuZ3RoKVxuICB9XG5cbiAgeC50b0J1ZmZlcihieXRlTGVuZ3RoKS5jb3B5KGJ1ZmZlciwgMSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cblBvaW50LmRlY29kZUZyb20gPSBmdW5jdGlvbiAoY3VydmUsIGJ1ZmZlcikge1xuICB2YXIgdHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoMClcbiAgdmFyIGNvbXByZXNzZWQgPSAodHlwZSAhPT0gNClcblxuICB2YXIgYnl0ZUxlbmd0aCA9IE1hdGguZmxvb3IoKGN1cnZlLnAuYml0TGVuZ3RoKCkgKyA3KSAvIDgpXG4gIHZhciB4ID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgxLCAxICsgYnl0ZUxlbmd0aCkpXG5cbiAgdmFyIFFcbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBhc3NlcnQuZXF1YWwoYnVmZmVyLmxlbmd0aCwgYnl0ZUxlbmd0aCArIDEsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpXG4gICAgYXNzZXJ0KHR5cGUgPT09IDB4MDIgfHwgdHlwZSA9PT0gMHgwMywgJ0ludmFsaWQgc2VxdWVuY2UgdGFnJylcblxuICAgIHZhciBpc09kZCA9ICh0eXBlID09PSAweDAzKVxuICAgIFEgPSBjdXJ2ZS5wb2ludEZyb21YKGlzT2RkLCB4KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLCAxICsgYnl0ZUxlbmd0aCArIGJ5dGVMZW5ndGgsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpXG5cbiAgICB2YXIgeSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSArIGJ5dGVMZW5ndGgpKVxuICAgIFEgPSBQb2ludC5mcm9tQWZmaW5lKGN1cnZlLCB4LCB5KVxuICB9XG5cbiAgUS5jb21wcmVzc2VkID0gY29tcHJlc3NlZFxuICByZXR1cm4gUVxufVxuXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiAnKElORklOSVRZKSdcblxuICByZXR1cm4gJygnICsgdGhpcy5hZmZpbmVYLnRvU3RyaW5nKCkgKyAnLCcgKyB0aGlzLmFmZmluZVkudG9TdHJpbmcoKSArICcpJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvcG9pbnQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgVHJhbnNhY3Rpb25CdWlsZGVyID0gcmVxdWlyZShcIi4vc3JjL1RyYW5zYWN0aW9uQnVpbGRlclwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVHJhbnNhY3Rpb25CdWlsZGVyOiBUcmFuc2FjdGlvbkJ1aWxkZXIsXG4gICAgQ2hhaW5Db25maWc6IHJlcXVpcmUoXCIuL3NyYy9DaGFpbkNvbmZpZ1wiKSxcbiAgICBDaGFpblR5cGVzOiByZXF1aXJlKFwiLi9zcmMvQ2hhaW5UeXBlc1wiKSxcbiAgICBPYmplY3RJZDogcmVxdWlyZShcIi4vc3JjL09iamVjdElkXCIpLFxuICAgIE51bWJlclV0aWxzOiByZXF1aXJlKFwiLi9zcmMvTnVtYmVyVXRpbHNcIiksXG4gICAgVHJhbnNhY3Rpb25IZWxwZXI6IHJlcXVpcmUoXCIuL3NyYy9UcmFuc2FjdGlvbkhlbHBlclwiKSxcbiAgICBDaGFpblZhbGlkYXRpb246IHJlcXVpcmUoXCIuL3NyYy9DaGFpblZhbGlkYXRpb25cIiksXG4gICAgTG9naW46IHJlcXVpcmUoXCIuL3NyYy9BY2NvdW50TG9naW5cIilcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZShcIi4uLy4uL2VjYy9zcmMvUHJpdmF0ZUtleVwiKTtcbnZhciBrZXkgPSByZXF1aXJlKFwiLi4vLi4vZWNjL3NyYy9LZXlVdGlsc1wiKTtcblxudmFyIEtleUNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEtleUNhY2hlKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5Q2FjaGUpO1xuXG4gICAgICAgIHRoaXMuX2tleUNhY2hlUHJpdiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fa2V5Q2FjaGVQdWIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX215S2V5cyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoS2V5Q2FjaGUsIFt7XG4gICAgICAgIGtleTogXCJzZXRQcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQcml2S2V5KGtleSwgcHJpdktleSkge1xuICAgICAgICAgICAgdGhpcy5fa2V5Q2FjaGVQcml2LnNldChrZXksIHByaXZLZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzUHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzUHJpdktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVByaXYuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcml2S2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNhY2hlUHJpdi5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldFB1YktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHViS2V5KGtleSwgcHViS2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlDYWNoZVB1Yi5zZXQoa2V5LCBwdWJLZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaGFzUHViS2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQdWJLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q2FjaGVQdWIuaGFzKGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQdWJLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVB1Yi5nZXQoa2V5KTs7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXRNeUtleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TXlLZXkoa2V5LCBwcml2S2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9teUtleXMuc2V0KGtleSwgcHJpdktleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRNeUtleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TXlLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXlLZXlzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEtleUNhY2hlO1xufSgpO1xuXG52YXIgQWNjb3VudExvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFjY291bnRMb2dpbigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY291bnRMb2dpbik7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmtleUNhY2hlID0gbmV3IEtleUNhY2hlKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEFjY291bnRMb2dpbiwgW3tcbiAgICAgICAga2V5OiBcInJlc2V0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7IGxvZ2dlZEluOiBmYWxzZSwgcm9sZXM6IFtcImFjdGl2ZVwiLCBcIm93bmVyXCIsIFwicG9zdGluZ1wiLCBcIm1lbW9cIl0gfTtcblxuICAgICAgICAgICAgdGhpcy5zdWJzID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRTdWJzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN1YnNjcmlwdGlvbihjYikge1xuICAgICAgICAgICAgdGhpcy5zdWJzW2NiXSA9IGNiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0Um9sZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJvbGVzKHJvbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnJvbGVzID0gcm9sZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRSb2xlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9sZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb2xlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdlbmVyYXRlS2V5c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVLZXlzKGFjY291bnROYW1lLCBwYXNzd29yZCwgcm9sZXMsIHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFhY2NvdW50TmFtZSB8fCAhcGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IG5hbWUgb3IgcGFzc3dvcmQgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBtdXN0IGhhdmUgYXQgbGVhc3QgMTIgY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByaXZLZXlzID0ge307XG4gICAgICAgICAgICB2YXIgcHViS2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAocm9sZXMgfHwgdGhpcy5zdGF0ZS5yb2xlcykuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWVkID0gYWNjb3VudE5hbWUgKyByb2xlICsgcGFzc3dvcmQ7XG4gICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBfdGhpcy5rZXlDYWNoZS5oYXNQcml2S2V5KHJvbGUpID8gX3RoaXMua2V5Q2FjaGUuZ2V0UHJpdktleShyb2xlKSA6IFByaXZhdGVLZXkuZnJvbVNlZWQoa2V5Lm5vcm1hbGl6ZV9icmFpbktleShzZWVkKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMua2V5Q2FjaGUuc2V0UHJpdktleShyb2xlLCBwa2V5KTtcblxuICAgICAgICAgICAgICAgIHByaXZLZXlzW3JvbGVdID0gcGtleTtcbiAgICAgICAgICAgICAgICBwdWJLZXlzW3JvbGVdID0gX3RoaXMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpID8gX3RoaXMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpIDogcGtleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKHByZWZpeCk7XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5rZXlDYWNoZS5zZXRQdWJLZXkocm9sZSwgcHViS2V5c1tyb2xlXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdktleXM6IHByaXZLZXlzLCBwdWJLZXlzOiBwdWJLZXlzIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmcm9tUHJpdktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVByaXZLZXkoYWNjb3VudE5hbWUsIHByaXZhdGVLZXksIHJvbGVzLCBwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcml2S2V5cyA9IHt9O1xuICAgICAgICAgICAgdmFyIHB1YktleXMgPSB7fTtcblxuICAgICAgICAgICAgKHJvbGVzIHx8IHRoaXMuc3RhdGUucm9sZXMpLmZvckVhY2goZnVuY3Rpb24gKHJvbGUpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwa2V5ID0gX3RoaXMyLmtleUNhY2hlLmhhc1ByaXZLZXkocm9sZSkgPyBfdGhpczIua2V5Q2FjaGUuZ2V0UHJpdktleShyb2xlKSA6IFByaXZhdGVLZXkuZnJvbVdpZihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICBfdGhpczIua2V5Q2FjaGUuc2V0UHJpdktleShyb2xlLCBwa2V5KTtcblxuICAgICAgICAgICAgICAgIHByaXZLZXlzW3JvbGVdID0gcGtleTtcbiAgICAgICAgICAgICAgICBwdWJLZXlzW3JvbGVdID0gX3RoaXMyLmtleUNhY2hlLmdldFB1YktleShyb2xlKSA/IF90aGlzMi5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSkgOiBwa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcocHJlZml4KTtcblxuICAgICAgICAgICAgICAgIF90aGlzMi5rZXlDYWNoZS5zZXRQdWJLZXkocm9sZSwgcHViS2V5c1tyb2xlXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcHJpdktleXM6IHByaXZLZXlzLCBwdWJLZXlzOiBwdWJLZXlzIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRQdWJLZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQdWJLZXlzKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvbGVzLm1hcChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjaGVja0tleXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5cyhfcmVmKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGFjY291bnROYW1lID0gX3JlZi5hY2NvdW50TmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZCA9IF9yZWYucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgYXV0aHMgPSBfcmVmLmF1dGhzLFxuICAgICAgICAgICAgICAgIF9yZWYkcHJpdmF0ZUtleSA9IF9yZWYucHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gX3JlZiRwcml2YXRlS2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRwcml2YXRlS2V5O1xuXG4gICAgICAgICAgICBpZiAoIWFjY291bnROYW1lIHx8ICFwYXNzd29yZCAmJiAhcHJpdmF0ZUtleSB8fCAhYXV0aHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGVja0tleXM6IE1pc3NpbmcgaW5wdXRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhc0tleSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChyb2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMgPSBfdGhpczQuZ2VuZXJhdGVLZXlzKGFjY291bnROYW1lLCBwYXNzd29yZCwgW3JvbGVdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF90aGlzNC5mcm9tUHJpdktleShhY2NvdW50TmFtZSwgcHJpdmF0ZUtleSwgW3JvbGVdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5cyAmJiBPYmplY3Qua2V5cyhrZXlzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXlzID0ga2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZLZXlzID0gX2tleXMucHJpdktleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJLZXlzID0gX2tleXMucHViS2V5cztcblxuICAgICAgICAgICAgICAgICAgICBhdXRoc1tyb2xlXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IHB1YktleXNbcm9sZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5rZXlDYWNoZS5zZXRNeUtleShyb2xlLCB7IHByaXY6IHByaXZLZXlzW3JvbGVdLCBwdWI6IHB1YktleXNbcm9sZV0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIHJvbGUgaW4gYXV0aHMpIHtcbiAgICAgICAgICAgICAgICBfbG9vcChyb2xlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBhY2NvdW50TmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5sb2dnZWRJbiA9IGhhc0tleTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhc0tleTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNpZ25UcmFuc2FjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHNpZ25lclB1YmtleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVkUHVia2V5cyA9IGFyZ3VtZW50c1syXTtcblxuXG4gICAgICAgICAgICB2YXIgbXlLZXlzID0ge307XG4gICAgICAgICAgICB2YXIgaGFzS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUucm9sZXMuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuICAgICAgICAgICAgICAgIHZhciBteUtleSA9IF90aGlzNS5rZXlDYWNoZS5nZXRNeUtleShyb2xlKTtcbiAgICAgICAgICAgICAgICBpZiAobXlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25lclB1YmtleXNbbXlLZXkucHViXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJQdWJrZXlzW215S2V5LnB1Yl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRQdWJrZXlzICYmIHJlcXVpcmVkUHVia2V5cy5pbmRleE9mKG15S2V5LnB1YikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRfc2lnbmVyKG15S2V5LnByaXYsIG15S2V5LnB1Yik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlcXVpcmVkUHVia2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3NpZ25lcihteUtleS5wcml2LCBteUtleS5wdWIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBkbyBub3QgaGF2ZSBhbnkgcHJpdmF0ZSBrZXlzIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgZG8gbm90IGhhdmUgYW55IHByaXZhdGUga2V5cyB0byBzaWduIHRoaXMgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWNjb3VudExvZ2luO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjY291bnRMb2dpbjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvQWNjb3VudExvZ2luLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxuLy92YXIgX3RoaXM7XG5cbnZhciBlY2NfY29uZmlnID0ge1xuICAgIGFkZHJlc3NfcHJlZml4OiBcIlNUTVwiXG59O1xuXG52YXIgX3RoaXMgPSB7XG4gICAgY29yZV9hc3NldDogXCJTVEVFTVwiLFxuICAgIHZlc3RfYXNzZXQ6IFwiVkVTVFNcIixcbiAgICBkb2xsYXJfYXNzZXQ6IFwiU0JEXCIsXG4gICAgYWRkcmVzc19wcmVmaXg6IFwiU1RNXCIsXG4gICAgZXhwaXJlX2luX3NlY3M6IDE1LFxuICAgIGV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsOiAyNCAqIDYwICogNjAsXG4gICAgY2hhaW5faWQ6IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgIG5ldHdvcmtzOiB7XG4gICAgICAgIFN0ZWVtOiB7XG4gICAgICAgICAgICBjb3JlX2Fzc2V0OiBcIlNURUVNXCIsXG4gICAgICAgICAgICB2ZXN0X2Fzc2V0OiBcIlZFU1RTXCIsXG4gICAgICAgICAgICBkb2xsYXJfYXNzZXQ6IFwiU0JEXCIsXG4gICAgICAgICAgICBhZGRyZXNzX3ByZWZpeDogXCJTVE1cIixcbiAgICAgICAgICAgIGNoYWluX2lkOiBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgICB9LFxuICAgICAgICBHb2xvczoge1xuICAgICAgICAgICAgY29yZV9hc3NldDogXCJHT0xPU1wiLFxuICAgICAgICAgICAgdmVzdF9hc3NldDogXCJHRVNUU1wiLFxuICAgICAgICAgICAgZG9sbGFyX2Fzc2V0OiBcIkdCR1wiLFxuICAgICAgICAgICAgYWRkcmVzc19wcmVmaXg6IFwiR0xTXCIsXG4gICAgICAgICAgICBjaGFpbl9pZDogXCI3ODJhMzAzOWI0NzhjODM5ZTRjYjBjOTQxZmY0ZWFlYjdkZjQwYmRkNjhiZDQ0MWFmZDQ0NGI5ZGE3NjNkZTEyXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIFNldCBhIGZldyBwcm9wZXJ0aWVzIGZvciBrbm93biBjaGFpbiBJRHMuICovXG4gICAgc2V0Q2hhaW5JZDogZnVuY3Rpb24gc2V0Q2hhaW5JZChjaGFpbl9pZCkge1xuXG4gICAgICAgIHZhciBpLCBsZW4sIG5ldHdvcmssIG5ldHdvcmtfbmFtZSwgcmVmO1xuICAgICAgICByZWYgPSBPYmplY3Qua2V5cyhfdGhpcy5uZXR3b3Jrcyk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIG5ldHdvcmtfbmFtZSA9IHJlZltpXTtcbiAgICAgICAgICAgIG5ldHdvcmsgPSBfdGhpcy5uZXR3b3Jrc1tuZXR3b3JrX25hbWVdO1xuXG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbl9pZCA9PT0gY2hhaW5faWQpIHtcblxuICAgICAgICAgICAgICAgIF90aGlzLm5ldHdvcmtfbmFtZSA9IG5ldHdvcmtfbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrLmFkZHJlc3NfcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gbmV0d29yay5hZGRyZXNzX3ByZWZpeDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9sbGFyX2Fzc2V0ID0gbmV0d29yay5kb2xsYXJfYXNzZXQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZlc3RfYXNzZXQgPSBuZXR3b3JrLnZlc3RfYXNzZXQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvcmVfYXNzZXQgPSBuZXR3b3JrLmNvcmVfYXNzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IG5ldHdvcmsuYWRkcmVzc19wcmVmaXg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYWluX2lkID0gY2hhaW5faWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJTkZPICAgIENvbmZpZ3VyZWQgZm9yXCIsIG5ldHdvcmtfbmFtZSwgXCI6XCIsIG5ldHdvcmsuY29yZV9hc3NldCwgXCJcXG5cIik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrX25hbWU6IG5ldHdvcmtfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIV90aGlzLm5ldHdvcmtfbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGNoYWluIGlkICh0aGlzIG1heSBiZSBhIHRlc3RuZXQpXCIsIGNoYWluX2lkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIF90aGlzLmNvcmVfYXNzZXQgPSBcIlNURUVNXCI7XG4gICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gXCJTVE1cIjtcbiAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IFwiU1RNXCI7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzID0gMTU7XG4gICAgICAgIF90aGlzLmV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsID0gMjQgKiA2MCAqIDYwO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hhaW4gY29uZmlnIHJlc2V0XCIpO1xuICAgIH0sXG5cbiAgICBzZXRQcmVmaXg6IGZ1bmN0aW9uIHNldFByZWZpeCgpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCJTVE1cIjtcblxuICAgICAgICBfdGhpcy5hZGRyZXNzX3ByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgZWNjX2NvbmZpZy5hZGRyZXNzX3ByZWZpeCA9IHByZWZpeDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBfdGhpcztcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5Db25maWcuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ2hhaW5UeXBlcyA9IHt9O1xuXG5DaGFpblR5cGVzLm9wZXJhdGlvbnMgPSB7XG4gICAgdm90ZTogMCxcbiAgICBjb21tZW50OiAxLFxuICAgIHRyYW5zZmVyOiAyLFxuICAgIHRyYW5zZmVyX3RvX3Zlc3Rpbmc6IDMsXG4gICAgd2l0aGRyYXdfdmVzdGluZzogNCxcbiAgICBsaW1pdF9vcmRlcl9jcmVhdGU6IDUsXG4gICAgbGltaXRfb3JkZXJfY2FuY2VsOiA2LFxuICAgIGZlZWRfcHVibGlzaDogNyxcbiAgICBjb252ZXJ0OiA4LFxuICAgIGFjY291bnRfY3JlYXRlOiA5LFxuICAgIGFjY291bnRfdXBkYXRlOiAxMCxcbiAgICB3aXRuZXNzX3VwZGF0ZTogMTEsXG4gICAgYWNjb3VudF93aXRuZXNzX3ZvdGU6IDEyLFxuICAgIGFjY291bnRfd2l0bmVzc19wcm94eTogMTMsXG4gICAgcG93OiAxNCxcbiAgICBjdXN0b206IDE1LFxuICAgIHJlcG9ydF9vdmVyX3Byb2R1Y3Rpb246IDE2LFxuICAgIGRlbGV0ZV9jb21tZW50OiAxNyxcbiAgICBjdXN0b21fanNvbjogMTgsXG4gICAgY29tbWVudF9vcHRpb25zOiAxOSxcbiAgICBzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZTogMjAsXG4gICAgbGltaXRfb3JkZXJfY3JlYXRlMjogMjEsXG4gICAgY2hhbGxlbmdlX2F1dGhvcml0eTogMjIsXG4gICAgcHJvdmVfYXV0aG9yaXR5OiAyMyxcbiAgICByZXF1ZXN0X2FjY291bnRfcmVjb3Zlcnk6IDI0LFxuICAgIHJlY292ZXJfYWNjb3VudDogMjUsXG4gICAgY2hhbmdlX3JlY292ZXJ5X2FjY291bnQ6IDI2LFxuICAgIGVzY3Jvd190cmFuc2ZlcjogMjcsXG4gICAgZXNjcm93X2Rpc3B1dGU6IDI4LFxuICAgIGVzY3Jvd19yZWxlYXNlOiAyOSxcbiAgICBwb3cyOiAzMCxcbiAgICBlc2Nyb3dfYXBwcm92ZTogMzEsXG4gICAgdHJhbnNmZXJfdG9fc2F2aW5nczogMzIsXG4gICAgdHJhbnNmZXJfZnJvbV9zYXZpbmdzOiAzMyxcbiAgICBjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzOiAzNCxcbiAgICBjdXN0b21fYmluYXJ5OiAzNSxcbiAgICBkZWNsaW5lX3ZvdGluZ19yaWdodHM6IDM2LFxuICAgIHJlc2V0X2FjY291bnQ6IDM3LFxuICAgIHNldF9yZXNldF9hY2NvdW50OiAzOCxcbiAgICBjbGFpbV9yZXdhcmRfYmFsYW5jZTogMzksXG4gICAgZGVsZWdhdGVfdmVzdGluZ19zaGFyZXM6IDQwLFxuICAgIGFjY291bnRfY3JlYXRlX3dpdGhfZGVsZWdhdGlvbjogNDEsXG4gICAgZmlsbF9jb252ZXJ0X3JlcXVlc3Q6IDQyLFxuICAgIGF1dGhvcl9yZXdhcmQ6IDQzLFxuICAgIGN1cmF0aW9uX3Jld2FyZDogNDQsXG4gICAgY29tbWVudF9yZXdhcmQ6IDQ1LFxuICAgIGxpcXVpZGl0eV9yZXdhcmQ6IDQ2LFxuICAgIGludGVyZXN0OiA0NyxcbiAgICBmaWxsX3Zlc3Rpbmdfd2l0aGRyYXc6IDQ4LFxuICAgIGZpbGxfb3JkZXI6IDQ5LFxuICAgIHNodXRkb3duX3dpdG5lc3M6IDUwLFxuICAgIGZpbGxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzOiA1MSxcbiAgICBoYXJkZm9yazogNTIsXG4gICAgY29tbWVudF9wYXlvdXRfdXBkYXRlOiA1MyxcbiAgICByZXR1cm5fdmVzdGluZ19kZWxlZ2F0aW9uOiA1NCxcbiAgICBjb21tZW50X2JlbmVmYWN0b3JfcmV3YXJkOiA1NVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFpblR5cGVzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpblR5cGVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICAgIEFjY291bnQgbmFtZXMgbWF5IGNvbnRhaW4gb25lIG9yIG1vcmUgbmFtZXMgc2VwYXJhdGVkIGJ5IGEgZG90LlxuICAgIEVhY2ggbmFtZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgbGV0dGVyIGFuZCBtYXkgY29udGFpblxuICAgIG51bWJlcnMsIG9yIHdlbGwgcGxhY2VkIGRhc2hlcy5cbiAgICBAc2VlIGlzX3ZhbGlkX25hbWUgZ3JhcGhlbmUvbGlicmFyaWVzL2NoYWluL3Byb3RvY29sL2FjY291bnQuY3BwXG4qL1xudmFyIGlkX3JlZ2V4ID0gL1xcYlxcZCtcXC5cXGQrXFwuKFxcZCspXFxiLztcblxudmFyIGNoYWluVmFsaWRhdGlvbiA9IHtcbiAgICBpc19hY2NvdW50X25hbWU6IGZ1bmN0aW9uIGlzX2FjY291bnRfbmFtZSh2YWx1ZSkge1xuICAgICAgICB2YXIgYWxsb3dfdG9vX3Nob3J0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICB2YXIgaSwgbGFiZWwsIGxlbiwgbGVuZ3RoLCByZWY7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFhbGxvd190b29fc2hvcnQgJiYgbGVuZ3RoIDwgMyB8fCBsZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gdmFsdWUuc3BsaXQoJy4nKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG5cbiAgICAgICAgICAgIGlmICghKC9eW2Etel1bYS16MC05LV0qJC8udGVzdChsYWJlbCkgJiYgIS8tLS8udGVzdChsYWJlbCkgJiYgL1thLXowLTldJC8udGVzdChsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpc19vYmplY3RfaWQ6IGZ1bmN0aW9uIGlzX29iamVjdF9pZChvYmpfaWQpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBvYmpfaWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSBpZF9yZWdleC5leGVjKG9ial9pZCk7XG4gICAgICAgIHJldHVybiBtYXRjaCAhPT0gbnVsbCAmJiBvYmpfaWQuc3BsaXQoXCIuXCIpLmxlbmd0aCA9PT0gMztcbiAgICB9LFxuXG4gICAgaXNfZW1wdHk6IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgaXNfYWNjb3VudF9uYW1lX2Vycm9yOiBmdW5jdGlvbiBpc19hY2NvdW50X25hbWVfZXJyb3IodmFsdWUsIGFsbG93X3Rvb19zaG9ydCkge1xuICAgICAgICB2YXIgaSwgbGFiZWwsIGxlbiwgbGVuZ3RoLCByZWYsIHN1ZmZpeDtcbiAgICAgICAgaWYgKGFsbG93X3Rvb19zaG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhbGxvd190b29fc2hvcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggPSBcIkFjY291bnQgbmFtZSBzaG91bGQgXCI7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwibm90IGJlIGVtcHR5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKCFhbGxvd190b29fc2hvcnQgJiYgbGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPiA2Mykge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgc2hvcnRlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcLi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHN1ZmZpeCA9IFwiRWFjaCBhY2NvdW50IHNlZ21lbnQgc2hvdWxkIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlZiA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbGFiZWwgPSByZWZbaV07XG4gICAgICAgICAgICBpZiAoIS9eW35hLXpdLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcInN0YXJ0IHdpdGggYSBsZXR0ZXIuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIS9eW35hLXowLTktXSokLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImhhdmUgb25seSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGRhc2hlcy5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLS0vLnRlc3QobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiaGF2ZSBvbmx5IG9uZSBkYXNoIGluIGEgcm93LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEvW2EtejAtOV0kLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImVuZCB3aXRoIGEgbGV0dGVyIG9yIGRpZ2l0LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEobGFiZWwubGVuZ3RoID49IDMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiYmUgbG9uZ2VyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGlzX2NoZWFwX25hbWU6IGZ1bmN0aW9uIGlzX2NoZWFwX25hbWUoYWNjb3VudF9uYW1lKSB7XG4gICAgICAgIHJldHVybiAoL1swLTktXS8udGVzdChhY2NvdW50X25hbWUpIHx8ICEvW2FlaW91eV0vLnRlc3QoYWNjb3VudF9uYW1lKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBpc19lbXB0eV91c2VyX2lucHV0OiBmdW5jdGlvbiBpc19lbXB0eV91c2VyX2lucHV0KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2YWx1ZSArIFwiXCIpLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSByZXF1aXJlZCBmb3IgXCIgKyBmaWVsZF9uYW1lICsgXCI6IFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqIEBzZWUgaXNfdmFsaWRfc3ltYm9sIGdyYXBoZW5lL2xpYnJhcmllcy9jaGFpbi9wcm90b2NvbC9hc3NldF9vcHMuY3BwICovXG4gICAgaXNfdmFsaWRfc3ltYm9sX2Vycm9yOiBmdW5jdGlvbiBpc192YWxpZF9zeW1ib2xfZXJyb3IodmFsdWUpIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9IFwiQXNzZXQgbmFtZSBzaG91bGQgXCI7XG4gICAgICAgIGlmICh0aGlzLmlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwibm90IGJlIGVtcHR5LlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5zcGxpdCgnLicpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImhhdmUgb25seSBvbmUgZG90LlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJiZSBsb25nZXIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJiZSBzaG9ydGVyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL15bQS1aXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcInN0YXJ0IHdpdGggYSBsZXR0ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9bQS1aXSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJlbmQgd2l0aCBhIGxldHRlclwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXltBLVowLTlcXC5dJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImNvbnRhaW4gb25seSBsZXR0ZXJzIG51bWJlcnMgYW5kIHBlcmhhcHMgYSBkb3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFpblZhbGlkYXRpb247XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVmFsaWRhdGlvbi5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuLyoqXG4gICAgQ29udmVydCAxMi4zNCB3aXRoIGEgcHJlY2lzaW9uIG9mIDMgaW50byAxMjM0MFxuICAgIFxuICAgIEBhcmcge251bWJlcnxzdHJpbmd9IG51bWJlciAtIFVzZSBzdHJpbmdzIGZvciBsYXJnZSBudW1iZXJzLiAgVGhpcyBtYXkgY29udGFpbiBvbmUgZGVjaW1hbCBidXQgbm8gc2lnblxuICAgIEBhcmcge251bWJlcn0gcHJlY2lzaW9uIC0gbnVtYmVyIG9mIGltcGxpZWQgZGVjaW1hbCBwbGFjZXMgKHVzdWFsbHkgY2F1c2VzIHJpZ2h0IHplcm8gcGFkZGluZylcbiAgICBAcmV0dXJuIHtzdHJpbmd9IC1cbiovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICB0b0ltcGxpZWREZWNpbWFsOiBmdW5jdGlvbiB0b0ltcGxpZWREZWNpbWFsKG51bWJlciwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGFzc2VydChudW1iZXIgPD0gOTAwNzE5OTI1NDc0MDk5MSwgXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICAgIG51bWJlciA9IFwiXCIgKyBudW1iZXI7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyLnRvU3RyaW5nKSBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcblxuICAgICAgICBhc3NlcnQodHlwZW9mIG51bWJlciA9PT0gXCJzdHJpbmdcIiwgXCJudW1iZXIgc2hvdWxkIGJlIGFuIGFjdHVhbCBudW1iZXIgb3Igc3RyaW5nOiBcIiArICh0eXBlb2YgbnVtYmVyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobnVtYmVyKSkpO1xuICAgICAgICBudW1iZXIgPSBudW1iZXIudHJpbSgpO1xuICAgICAgICBhc3NlcnQoL15bMC05XSpcXC4/WzAtOV0qJC8udGVzdChudW1iZXIpLCBcIkludmFsaWQgZGVjaW1hbCBudW1iZXIgXCIgKyBudW1iZXIpO1xuXG4gICAgICAgIHZhciBfbnVtYmVyJHNwbGl0ID0gbnVtYmVyLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgICAgIF9udW1iZXIkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX251bWJlciRzcGxpdCwgMiksXG4gICAgICAgICAgICBfbnVtYmVyJHNwbGl0MiQgPSBfbnVtYmVyJHNwbGl0MlswXSxcbiAgICAgICAgICAgIHdob2xlID0gX251bWJlciRzcGxpdDIkID09PSB1bmRlZmluZWQgPyBcIlwiIDogX251bWJlciRzcGxpdDIkLFxuICAgICAgICAgICAgX251bWJlciRzcGxpdDIkMiA9IF9udW1iZXIkc3BsaXQyWzFdLFxuICAgICAgICAgICAgZGVjaW1hbCA9IF9udW1iZXIkc3BsaXQyJDIgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQyO1xuXG4gICAgICAgIHZhciBwYWRkaW5nID0gcHJlY2lzaW9uIC0gZGVjaW1hbC5sZW5ndGg7XG4gICAgICAgIGFzc2VydChwYWRkaW5nID49IDAsIFwiVG9vIG1hbnkgZGVjaW1hbCBkaWdpdHMgaW4gXCIgKyBudW1iZXIgKyBcIiB0byBjcmVhdGUgYW4gaW1wbGllZCBkZWNpbWFsIG9mIFwiICsgcHJlY2lzaW9uKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGRpbmc7IGkrKykge1xuICAgICAgICAgICAgZGVjaW1hbCArPSBcIjBcIjtcbiAgICAgICAgfXdoaWxlICh3aG9sZS5jaGFyQXQoMCkgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICAgICAgfXJldHVybiB3aG9sZSArIGRlY2ltYWw7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvTnVtYmVyVXRpbHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpLFxuICAgIExvbmcgPSBfcmVxdWlyZS5Mb25nO1xuXG52YXIgdiA9IHJlcXVpcmUoJy4uLy4uL3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uJyk7XG5cbnZhciBEQl9NQVhfSU5TVEFOQ0VfSUQgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3coMiwgNDgpIC0gMSk7XG5cbnZhciBPYmplY3RJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RJZChzcGFjZSwgdHlwZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdElkKTtcblxuICAgICAgICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdmFyIGluc3RhbmNlX3N0cmluZyA9IHRoaXMuaW5zdGFuY2UudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIF9PYmplY3RJZCA9IHRoaXMuc3BhY2UgKyAnLicgKyB0aGlzLnR5cGUgKyAnLicgKyBpbnN0YW5jZV9zdHJpbmc7XG4gICAgICAgIGlmICghdi5pc19kaWdpdHMoaW5zdGFuY2Vfc3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3ICgnSW52YWxpZCBvYmplY3QgaWQgJyArIF9PYmplY3RJZCkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhPYmplY3RJZCwgW3tcbiAgICAgICAga2V5OiAndG9Mb25nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9uZygpIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodGhpcy5zcGFjZSkuc2hpZnRMZWZ0KDU2KS5vcihMb25nLmZyb21OdW1iZXIodGhpcy50eXBlKS5zaGlmdExlZnQoNDgpLm9yKHRoaXMuaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXBwZW5kQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLndyaXRlVWludDY0KHRoaXMudG9Mb25nKCkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYWNlICsgJy4nICsgdGhpcy50eXBlICsgJy4nICsgdGhpcy5pbnN0YW5jZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNwYWNlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudHlwZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB2LnJlcXVpcmVfbWF0Y2goL14oWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykkLywgdi5yZXF1aXJlZCh2YWx1ZSwgXCJPYmplY3RJZFwiKSwgXCJPYmplY3RJZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQocGFyc2VJbnQocGFyYW1zWzFdKSwgcGFyc2VJbnQocGFyYW1zWzJdKSwgTG9uZy5mcm9tU3RyaW5nKHBhcmFtc1szXSkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tTG9uZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTG9uZyhsb25nKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBsb25nLnNoaWZ0UmlnaHQoNTYpLnRvSW50KCk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGxvbmcuc2hpZnRSaWdodCg0OCkudG9JbnQoKSAmIDB4MDBmZjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGxvbmcuYW5kKERCX01BWF9JTlNUQU5DRV9JRCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKHNwYWNlLCB0eXBlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tTG9uZyhiLnJlYWRVaW50NjQoKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JqZWN0SWQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0SWQ7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL09iamVjdElkLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKSxcbiAgICBTaWduYXR1cmUgPSBfcmVxdWlyZS5TaWduYXR1cmUsXG4gICAgUHVibGljS2V5ID0gX3JlcXVpcmUuUHVibGljS2V5LFxuICAgIGhhc2ggPSBfcmVxdWlyZS5oYXNoO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uLy4uL3NlcmlhbGl6ZXJcIiksXG4gICAgb3BzID0gX3JlcXVpcmUyLm9wcztcblxudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoJ3N0ZWVtLXJwYycpLFxuICAgIENsaWVudCA9IF9yZXF1aXJlMy5DbGllbnQ7XG5cbnZhciBBcGkgPSBDbGllbnQuZ2V0KCk7XG5cbnZhciBfcmVxdWlyZTQgPSByZXF1aXJlKCdieXRlYnVmZmVyJyksXG4gICAgTG9uZyA9IF9yZXF1aXJlNC5Mb25nO1xuXG52YXIgQ2hhaW5UeXBlcyA9IHJlcXVpcmUoJy4vQ2hhaW5UeXBlcycpO1xuXG52YXIgaGVhZF9ibG9ja190aW1lX3N0cmluZztcblxudmFyIFRyYW5zYWN0aW9uQnVpbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkJ1aWxkZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2FjdGlvbkJ1aWxkZXIpO1xuXG4gICAgICAgIHRoaXMucmVmX2Jsb2NrX251bSA9IDA7XG4gICAgICAgIHRoaXMucmVmX2Jsb2NrX3ByZWZpeCA9IDA7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG5cbiAgICAgICAgLy8gc2VtaS1wcml2YXRlIG1ldGhvZCBiaW5kaW5nc1xuICAgICAgICB0aGlzLl9icm9hZGNhc3QgPSBfYnJvYWRjYXN0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIEBhcmcge3N0cmluZ30gbmFtZSAtIGxpa2UgXCJ0cmFuc2ZlclwiXG4gICAgICAgIEBhcmcge29iamVjdH0gb3BlcmF0aW9uIC0gSlNPTiBtYXRjaGNoaW5nIHRoZSBvcGVyYXRpb24ncyBmb3JtYXRcbiAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb25CdWlsZGVyLCBbe1xuICAgICAgICBrZXk6IFwiYWRkX3R5cGVfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFkZF9vcGVyYXRpb24odGhpcy5nZXRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIFRoaXMgZG9lcyBpdCBhbGw6IHNldCBmZWVzLCBmaW5hbGl6ZSwgc2lnbiwgYW5kIGJyb2FkY2FzdCAoaWYgd2FudGVkKS5cbiAgICAgICAgICAgICBAYXJnIHtDb25maWRlbnRpYWxXYWxsZXR9IGN3YWxsZXQgLSBtdXN0IGJlIHVubG9ja2VkLCB1c2VkIHRvIGdhdGhlciBzaWduaW5nIGtleXNcbiAgICAgICAgICAgICBAYXJnIHthcnJheTxzdHJpbmc+fSBbc2lnbmVyX3B1YmtleXMgPSBudWxsXSAtIE9wdGlvbmFsIFtcIkdQSEFiYzlEZWYwLi4uXCIsIC4uLl0uICBUaGVzZSBhcmUgYWRkaXRpb25hbCBzaWduaW5nIGtleXMuICBTb21lIGJhbGFuY2UgY2xhaW1zIHJlcXVpcmUgcHJvcHJpdGFyeSBhZGRyZXNzIGZvcm1hdHMsIHRoZSB3aXRuZXNzIG5vZGUgY2FuJ3QgdGVsbCB1cyB3aGljaCBvbmVzIGFyZSBuZWVkZWQgc28gdGhleSBtdXN0IGJlIHBhc3NlZCBpbi4gIElmIHRoZSB3aXRuZXNzIG5vZGUgY2FuIGZpZ3VyZSBvdXQgYSBzaWduaW5nIGtleSAobW9zdGx5IGFsbCBvdGhlciB0cmFuc2FjdGlvbnMpLCBpdCBzaG91bGQgbm90IGJlIHBhc3NlZCBpbiBoZXJlLlxuICAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFticm9hZGNhc3QgPSBmYWxzZV1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NfdHJhbnNhY3Rpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NfdHJhbnNhY3Rpb24oYWNjb3VudExvZ2luKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc2lnbmVyX3B1YmtleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgYnJvYWRjYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuXG4gICAgICAgICAgICAvLyBsZXQgd2FsbGV0X29iamVjdCA9IGN3YWxsZXQud2FsbGV0LndhbGxldF9vYmplY3RcbiAgICAgICAgICAgIC8vIGlmKEFwaS5jaGFpbl9pZCAhPT0gd2FsbGV0X29iamVjdC5nZXQoXCJjaGFpbl9pZFwiKSlcbiAgICAgICAgICAgIC8vICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJNaXNtYXRjaGVkIGNoYWluX2lkOyBleHBlY3RpbmcgXCIgK1xuICAgICAgICAgICAgLy8gICAgICAgICB3YWxsZXRfb2JqZWN0LmdldChcImNoYWluX2lkXCIpICsgXCIsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgLy8gICAgICAgICBBcGkuY2hhaW5faWQpXG5cbiAgICAgICAgICAgIHZhciBzaWduZXJfcHVia2V5c19hZGRlZCA9IHt9O1xuICAgICAgICAgICAgLy8gaWYoc2lnbmVyX3B1YmtleXMpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgLy8gQmFsYW5jZSBjbGFpbXMgYXJlIGJ5IGFkZHJlc3MsIG9ubHkgdGhlIHByaXZhdGVcbiAgICAgICAgICAgIC8vICAgICAvLyBrZXkgaG9sZGVyIGNhbiBrbm93IGFib3V0IHRoZXNlIGFkZGl0aW9uYWxcbiAgICAgICAgICAgIC8vICAgICAvLyBwb3RlbnRpYWwga2V5cy5cbiAgICAgICAgICAgIC8vICAgICB2YXIgcHVia2V5cyA9IGFjY291bnRMb2dpbi5nZXRQdWJLZXlzKClcbiAgICAgICAgICAgIC8vICAgICBpZiggISBwdWJrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzaWduaW5nIGtleVwiKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICBmb3IobGV0IHB1YmtleV9zdHJpbmcgb2YgcHVia2V5cykge1xuICAgICAgICAgICAgLy8gICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBjd2FsbGV0LmdldFByaXZhdGVLZXkocHVia2V5X3N0cmluZylcbiAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5hZGRfc2lnbmVyKHByaXZhdGVfa2V5LCBwdWJrZXlfc3RyaW5nKVxuICAgICAgICAgICAgLy8gICAgICAgICBzaWduZXJfcHVia2V5c19hZGRlZFtwdWJrZXlfc3RyaW5nXSA9IHRydWVcbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpLnRoZW4oIChwdWJrZXlzKT0+IHtcbiAgICAgICAgICAgIHZhciBteV9wdWJrZXlzID0gYWNjb3VudExvZ2luLmdldFB1YktleXMoKTtcblxuICAgICAgICAgICAgLy97Ly9UZXN0aW5nIG9ubHksIGRvbid0IHNlbmQgQWxsIHB1YmxpYyBrZXlzIVxuICAgICAgICAgICAgLy8gICAgdmFyIHB1YmtleXNfYWxsID0gUHJpdmF0ZUtleVN0b3JlLmdldFB1YmtleXMoKSAvLyBBbGwgcHVibGljIGtleXNcbiAgICAgICAgICAgIC8vICAgIHRoaXMuZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMocHVia2V5c19hbGwpLnRoZW4oIHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzID0+XG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJ2dldF9yZXF1aXJlZF9zaWduYXR1cmVzIGFsbFxcdCcscmVxdWlyZWRfcHVia2V5X3N0cmluZ3Muc29ydCgpLCBwdWJrZXlzX2FsbCkpXG4gICAgICAgICAgICAvLyAgICB0aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKG15X3B1YmtleXMpLnRoZW4oIHJlcXVpcmVkX3B1YmtleV9zdHJpbmdzID0+XG4gICAgICAgICAgICAvLyAgICAgICAgY29uc29sZS5sb2coJ2dldF9yZXF1aXJlZF9zaWduYXR1cmVzIG5vcm1hbFxcdCcscmVxdWlyZWRfcHVia2V5X3N0cmluZ3Muc29ydCgpLCBwdWJrZXlzKSlcbiAgICAgICAgICAgIC8vfVxuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldF9yZXF1aXJlZF9zaWduYXR1cmVzKG15X3B1YmtleXMpLnRoZW4oZnVuY3Rpb24gKHJlcXVpcmVkX3B1YmtleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlcXVpcmVkX3B1YmtleXNcIiwgcmVxdWlyZWRfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IG15X3B1YmtleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVia2V5X3N0cmluZyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInB1YmtleV9zdHJpbmdcIiwgcHVia2V5X3N0cmluZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWduZXJfcHVia2V5c19hZGRlZFtwdWJrZXlfc3RyaW5nXSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRMb2dpbi5zaWduVHJhbnNhY3Rpb24oX3RoaXMsIHNpZ25lcl9wdWJrZXlzX2FkZGVkLCByZXF1aXJlZF9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBwcml2YXRlX2tleSA9IGN3YWxsZXQuZ2V0UHJpdmF0ZUtleShwdWJrZXlfc3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYoICEgcHJpdmF0ZV9rZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgd2lsbCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy8gcmV0dXJuZWQga2V5cyBmcm9tIG15X3B1YmtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNpZ25pbmcga2V5IGZvciBcIiArIHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZF9zaWduZXIocHJpdmF0ZV9rZXksIHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNpZ25lcl9wdWJrZXlzX2FkZGVkXCIsIHNpZ25lcl9wdWJrZXlzX2FkZGVkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChicm9hZGNhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJyb2FkY2FzdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUeXBpY2FsbHkgdGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBqdXN0IHByaW9yIHRvIHNpZ25pbmcuICBPbmNlIGZpbmFsaXplZCB0aGlzIHRyYW5zYWN0aW9uIGNhbiBub3QgYmUgY2hhbmdlZC4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRyeSB0byBmaW5hbGl6ZVwiLCBcImV4cGlyYXRpb246XCIsIHRoaXMuZXhwaXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMi50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRfYmxvY2tfdGltZV9zdHJpbmcgPSByLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIuZXhwaXJhdGlvbiA9PT0gMCkgX3RoaXMyLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBDaGFpbkNvbmZpZy5leHBpcmVfaW5fc2VjcztcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJuZXcgZXhwaXJhdGlvbjpcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnJlZl9ibG9ja19udW0gPSByLmhlYWRfYmxvY2tfbnVtYmVyICYgMHhGRkZGO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIucmVmX2Jsb2NrX3ByZWZpeCA9IG5ldyBCdWZmZXIoci5oZWFkX2Jsb2NrX2lkLCAnaGV4JykucmVhZFVJbnQzMkxFKDQpO1xuICAgICAgICAgICAgICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKFwicmVmX2Jsb2NrXCIsQHJlZl9ibG9ja19udW0sQHJlZl9ibG9ja19wcmVmaXgscilcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSBfdGhpczIub3BlcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG9wOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMV1bXCJmaW5hbGl6ZVwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wWzFdLmZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnRyX2J1ZmZlciA9IG9wcy50cmFuc2FjdGlvbi50b0J1ZmZlcihfdGhpczIpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllcyBlcnI6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7c3RyaW5nfSBoZXggdHJhbnNhY3Rpb24gSUQgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImlkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpZCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZmluYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2guc2hhMjU2KHRoaXMudHJfYnVmZmVyKS50b1N0cmluZygnaGV4Jykuc3Vic3RyaW5nKDAsIDQwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgVHlwaWNhbGx5IG9uZSB3aWxsIHVzZSB7QGxpbmsgdGhpcy5hZGRfdHlwZV9vcGVyYXRpb259IGluc3RlYWQuXG4gICAgICAgICAgICBAYXJnIHthcnJheX0gb3BlcmF0aW9uIC0gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uXVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWRkX29wZXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkX29wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0KG9wZXJhdGlvbiwgXCJvcGVyYXRpb25cIik7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3BlcmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhcnJheSBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25dXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldF90eXBlX29wZXJhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3R5cGVfb3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQobmFtZSwgXCJuYW1lXCIpO1xuICAgICAgICAgICAgYXNzZXJ0KG9wZXJhdGlvbiwgXCJvcGVyYXRpb25cIik7XG4gICAgICAgICAgICB2YXIgX3R5cGUgPSBvcHNbbmFtZV07XG4gICAgICAgICAgICBhc3NlcnQoX3R5cGUsIFwiVW5rbm93biBvcGVyYXRpb24gXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25faWQgPSBDaGFpblR5cGVzLm9wZXJhdGlvbnNbX3R5cGUub3BlcmF0aW9uX25hbWVdO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBvcGVyYXRpb246IFwiICsgX3R5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb24uZmVlKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmZlZSA9IHsgYW1vdW50OiAwLCBhc3NldF9pZDogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdwcm9wb3NhbF9jcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLmV4cGlyYXRpb25fdGltZSB8fCAob3BlcmF0aW9uLmV4cGlyYXRpb25fdGltZSA9IGJhc2VfZXhwaXJhdGlvbl9zZWMoKSArIENoYWluQ29uZmlnLmV4cGlyZV9pbl9zZWNzX3Byb3Bvc2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25faW5zdGFuY2UgPSBfdHlwZS5mcm9tT2JqZWN0KG9wZXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gW29wZXJhdGlvbl9pZCwgb3BlcmF0aW9uX2luc3RhbmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBvcHRpb25hbDogdGhlcmUgaXMgYSBkZWFmdWx0IGV4cGlyYXRpb24gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldF9leHBpcmVfc2Vjb25kc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X2V4cGlyZV9zZWNvbmRzKHNlYykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHBpcmF0aW9uID0gYmFzZV9leHBpcmF0aW9uX3NlYygpICsgc2VjO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogV3JhcHMgdGhpcyB0cmFuc2FjdGlvbiBpbiBhIHByb3Bvc2FsX2NyZWF0ZSB0cmFuc2FjdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvcG9zZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvcG9zZShwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGQgb3BlcmF0aW9uIGZpcnN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NlcnQocHJvcG9zYWxfY3JlYXRlX29wdGlvbnMsIFwicHJvcG9zYWxfY3JlYXRlX29wdGlvbnNcIik7XG4gICAgICAgICAgICBhc3NlcnQocHJvcG9zYWxfY3JlYXRlX29wdGlvbnMuZmVlX3BheWluZ19hY2NvdW50LCBcInByb3Bvc2FsX2NyZWF0ZV9vcHRpb25zLmZlZV9wYXlpbmdfYWNjb3VudFwiKTtcblxuICAgICAgICAgICAgdmFyIHByb3Bvc2VkX29wcyA9IHRoaXMub3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3A6IG9wIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuICAgICAgICAgICAgcHJvcG9zYWxfY3JlYXRlX29wdGlvbnMucHJvcG9zZWRfb3BzID0gcHJvcG9zZWRfb3BzO1xuICAgICAgICAgICAgdGhpcy5hZGRfdHlwZV9vcGVyYXRpb24oXCJwcm9wb3NhbF9jcmVhdGVcIiwgcHJvcG9zYWxfY3JlYXRlX29wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJoYXNfcHJvcG9zZWRfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNfcHJvcG9zZWRfb3BlcmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhc1Byb3Bvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BlcmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChcInByb3Bvc2VkX29wc1wiIGluIHRoaXMub3BlcmF0aW9uc1tpXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNQcm9wb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb3Bvc2VkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3BvdGVudGlhbF9zaWduYXR1cmVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfcG90ZW50aWFsX3NpZ25hdHVyZXMoKSB7XG4gICAgICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9wb3RlbnRpYWxfc2lnbmF0dXJlc1wiLCBbdHJfb2JqZWN0XSkudGhlbihmdW5jdGlvbiAocHVia2V5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHB1YmtleXM6IHB1YmtleXMgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9yZXF1aXJlZF9zaWduYXR1cmVzKGF2YWlsYWJsZV9rZXlzKSB7XG5cbiAgICAgICAgICAgIGlmICghYXZhaWxhYmxlX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLHRyX29iamVjdCk7XG4gICAgICAgICAgICAvL0RFQlVHIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0Jyx0cl9vYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfcmVxdWlyZWRfc2lnbmF0dXJlc1wiLCBbdHJfb2JqZWN0LCBhdmFpbGFibGVfa2V5c10pLnRoZW4oZnVuY3Rpb24gKHJlcXVpcmVkX3B1YmxpY19rZXlzKSB7XG4gICAgICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcycscmVxdWlyZWRfcHVibGljX2tleXMpXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLi4uIGdldF9yZXF1aXJlZF9zaWduYXR1cmVzJyxyZXF1aXJlZF9wdWJsaWNfa2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkX3B1YmxpY19rZXlzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRfc2lnbmVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfc2lnbmVyKHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB2YXIgcHVibGljX2tleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKTtcblxuXG4gICAgICAgICAgICBhc3NlcnQocHJpdmF0ZV9rZXkuZCwgXCJyZXF1aXJlZCBQcml2YXRlS2V5IG9iamVjdFwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBzaWduZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXB1YmxpY19rZXkuUSkge1xuICAgICAgICAgICAgICAgIHB1YmxpY19rZXkgPSBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyhwdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgdmFyIHNwSGV4ID0gcHJpdmF0ZV9rZXkudG9IZXgoKTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcFswXS50b0hleCgpID09PSBzcEhleCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMucHVzaChbcHJpdmF0ZV9rZXksIHB1YmxpY19rZXldKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNpZ25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5faWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IENoYWluQ29uZmlnLmNoYWluX2lkO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhjaGFpbl9pZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgc2lnbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVuZCA9IHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGVuZCA/IGkgPCBlbmQgOiBpID4gZW5kOyAwIDwgZW5kID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9zaWduZXJfcHJpdmF0ZV9rZXlzJCA9IF9zbGljZWRUb0FycmF5KHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5c1tpXSwgMiksXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVfa2V5ID0gX3NpZ25lcl9wcml2YXRlX2tleXMkWzBdLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaWNfa2V5ID0gX3NpZ25lcl9wcml2YXRlX2tleXMkWzFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IFNpZ25hdHVyZS5zaWduQnVmZmVyKEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoY2hhaW5faWQsICdoZXgnKSwgdGhpcy50cl9idWZmZXJdKSwgcHJpdmF0ZV9rZXksIHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlcy5wdXNoKHNpZy50b0J1ZmZlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInRvT2JqZWN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYnJvYWRjYXN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBicm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9icm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMuX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUcmFuc2FjdGlvbkJ1aWxkZXI7XG59KCk7XG5cbnZhciBiYXNlX2V4cGlyYXRpb25fc2VjID0gZnVuY3Rpb24gYmFzZV9leHBpcmF0aW9uX3NlYygpIHtcbiAgICB2YXIgaGVhZF9ibG9ja19zZWMgPSBNYXRoLmNlaWwoZ2V0SGVhZEJsb2NrRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIHZhciBub3dfc2VjID0gTWF0aC5jZWlsKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAvLyBUaGUgaGVhZCBibG9jayB0aW1lIHNob3VsZCBiZSB1cGRhdGVkIGV2ZXJ5IDMgc2Vjb25kcy4gIElmIGl0IGlzbid0XG4gICAgLy8gdGhlbiBoZWxwIHRoZSB0cmFuc2FjdGlvbiB0byBleHBpcmUgKHVzZSBoZWFkX2Jsb2NrX3NlYylcbiAgICBpZiAobm93X3NlYyAtIGhlYWRfYmxvY2tfc2VjID4gMzApIHtcbiAgICAgICAgcmV0dXJuIGhlYWRfYmxvY2tfc2VjO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdXNlcidzIGNsb2NrIGlzIHZlcnkgZmFyIGJlaGluZCwgdXNlIHRoZSBoZWFkIGJsb2NrIHRpbWUuXG4gICAgcmV0dXJuIE1hdGgubWF4KG5vd19zZWMsIGhlYWRfYmxvY2tfc2VjKTtcbn07XG5cbmZ1bmN0aW9uIF9icm9hZGNhc3Qod2FzX2Jyb2FkY2FzdF9jYWxsYmFjaykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFfdGhpczQuc2lnbmVkKSB7XG4gICAgICAgICAgICBfdGhpczQuc2lnbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM0LnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vdCBmaW5hbGl6ZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXM0LnNpZ25hdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm90IHNpZ25lZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQub3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJubyBvcGVyYXRpb25zXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIgaW4gQXBpKSkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFwaSBkb2VzIG5vdCBpbmNsdWRlIG5ldHdvcmtfYnJvYWRjYXN0X2FwaVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyX29iamVjdCA9IG9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QoX3RoaXM0KTtcblxuICAgICAgICByZXR1cm4gQXBpLm5ldHdvcmtfYnJvYWRjYXN0X2FwaSgpLmV4ZWMoXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fd2l0aF9jYWxsYmFja1wiLCBbeyByZWplY3Q6IHJlamVjdCwgcmVzb2x2ZTogcmVzb2x2ZSB9LCB0cl9vYmplY3RdKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gYnJvYWRjYXN0IHN1Y2Nlc3MsIHdhaXRpbmcgZm9yIGNhbGxiYWNrJylcbiAgICAgICAgICAgIGlmICh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cgbWF5IGJlIHJlZHVuZGFudCBmb3IgbmV0d29yayBlcnJvcnMsIG90aGVyIGVycm9ycyBjb3VsZCBvY2N1clxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1lc3NhZ2UgKyBcIlxcblwiICsgJ2dyYXBoZW5lLWNyeXB0byAnICsgJyBkaWdlc3QgJyArIGhhc2guc2hhMjU2KF90aGlzNC50cl9idWZmZXIpLnRvU3RyaW5nKCdoZXgnKSArICcgdHJhbnNhY3Rpb24gJyArIF90aGlzNC50cl9idWZmZXIudG9TdHJpbmcoJ2hleCcpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkodHJfb2JqZWN0KSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZEJsb2NrRGF0ZSgpIHtcbiAgICByZXR1cm4gdGltZVN0cmluZ1RvRGF0ZShoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gdGltZVN0cmluZ1RvRGF0ZSh0aW1lX3N0cmluZykge1xuICAgIGlmICghdGltZV9zdHJpbmcpIHJldHVybiBuZXcgRGF0ZShcIjE5NzAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKTtcbiAgICBpZiAoIS9aJC8udGVzdCh0aW1lX3N0cmluZykpIC8vZG9lcyBub3QgZW5kIGluIFpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b25vbWV4L2dyYXBoZW5lL2lzc3Vlcy8zNjhcbiAgICAgICAgdGltZV9zdHJpbmcgPSB0aW1lX3N0cmluZyArIFwiWlwiO1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lX3N0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25CdWlsZGVyO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkJ1aWxkZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhlbHBlcjtcbm1vZHVsZS5leHBvcnRzID0gaGVscGVyID0ge307XG5cbnZhciBzZWN1cmVSYW5kb20gPSByZXF1aXJlKCdzZWN1cmUtcmFuZG9tJyk7XG5cbi8vUHJvbWlzZSA9IHJlcXVpcmUgJy4uL2NvbW1vbi9Qcm9taXNlJ1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdieXRlYnVmZmVyJyksXG4gICAgTG9uZyA9IF9yZXF1aXJlLkxvbmc7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpLFxuICAgIFNpZ25hdHVyZSA9IF9yZXF1aXJlMi5TaWduYXR1cmU7XG5cbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vLi4vc2VyaWFsaXplclwiKSxcbiAgICBvcHMgPSBfcmVxdWlyZTMub3BzO1xuXG5oZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgPSBudWxsO1xuaGVscGVyLnVuaXF1ZV9ub25jZV91aW50NjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVudHJvcHkgPSBoZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgaWYgKGhlbHBlci51bmlxdWVfbm9uY2VfZW50cm9weSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLi4uIHNlY3VyZVJhbmRvbS5yYW5kb21VaW50OEFycmF5KDEpWzBdJyxzZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSgxKVswXSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSgxKVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKytoZWxwZXIudW5pcXVlX25vbmNlX2VudHJvcHkgJSAyNTY7XG4gICAgICAgIH1cbiAgICB9KCk7XG4gICAgdmFyIGxvbmcgPSBMb25nLmZyb21OdW1iZXIoRGF0ZS5ub3coKSk7XG4gICAgLy9jb25zb2xlLmxvZygndW5pcXVlX25vbmNlX3VpbnQ2NCBkYXRlXFx0JyxCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KGxvbmcpLnRvSGV4KDApKVxuICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9ub25jZV91aW50NjQgZW50cm9weVxcdCcsQnl0ZUJ1ZmZlci5hbGxvY2F0ZSg4KS53cml0ZVVpbnQ2NChMb25nLmZyb21OdW1iZXIoZW50cm9weSkpLnRvSGV4KDApKVxuICAgIGxvbmcgPSBsb25nLnNoaWZ0TGVmdCg4KS5vcihMb25nLmZyb21OdW1iZXIoZW50cm9weSkpO1xuICAgIC8vY29uc29sZS5sb2coJ3VuaXF1ZV9ub25jZV91aW50NjQgc2hpZnQ4XFx0JyxCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KGxvbmcpLnRvSGV4KDApKVxuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59O1xuXG4vKiBUb2RvLCBzZXQgZmVlcyAqL1xuaGVscGVyLnRvX2pzb24gPSBmdW5jdGlvbiAodHIpIHtcbiAgICB2YXIgYnJvYWRjYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAodHIsIGJyb2FkY2FzdCkge1xuICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdCh0cik7XG4gICAgICAgIGlmIChicm9hZGNhc3QpIHtcbiAgICAgICAgICAgIHZhciBuZXQgPSBBcGlzLmluc3RhbmNlKCkubmV0d29ya19hcGkoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCcuLi4gdHJfb2JqZWN0JywgSlNPTi5zdHJpbmdpZnkodHJfb2JqZWN0KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV0LmV4ZWMoXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25cIiwgW3RyX29iamVjdF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRyX29iamVjdDtcbiAgICAgICAgfVxuICAgIH0odHIsIGJyb2FkY2FzdCk7XG59O1xuXG5oZWxwZXIuc2lnbmVkX3RyX2pzb24gPSBmdW5jdGlvbiAodHIsIHByaXZhdGVfa2V5cykge1xuICAgIHZhciB0cl9idWZmZXIgPSBvcHMudHJhbnNhY3Rpb24udG9CdWZmZXIodHIpO1xuICAgIHRyID0gb3BzLnRyYW5zYWN0aW9uLnRvT2JqZWN0KHRyKTtcbiAgICB0ci5zaWduYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgcHJpdmF0ZV9rZXlzLmxlbmd0aCA/IGkgPCBwcml2YXRlX2tleXMubGVuZ3RoIDogaSA+IHByaXZhdGVfa2V5cy5sZW5ndGg7IDAgPCBwcml2YXRlX2tleXMubGVuZ3RoID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleXNbaV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChTaWduYXR1cmUuc2lnbkJ1ZmZlcih0cl9idWZmZXIsIHByaXZhdGVfa2V5KS50b0hleCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0oKTtcbiAgICByZXR1cm4gdHI7XG59O1xuXG5oZWxwZXIuZXhwaXJlX2luX21pbiA9IGZ1bmN0aW9uIChtaW4pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBtaW4gKiA2MDtcbn07XG5cbmhlbHBlci5zZWNvbmRzX2Zyb21fbm93ID0gZnVuY3Rpb24gKHRpbWVvdXRfc2VjKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApICsgdGltZW91dF9zZWM7XG59O1xuXG4vKipcbiAgICBQcmludCB0byB0aGUgY29uc29sZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW55IG9iamVjdCBpblxuICAgIEBncmFwaGVuZS9zZXJpYWxpemVyIHsgdHlwZXMgfVxuKi9cbmhlbHBlci50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWUpIHtcbiAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH07XG5cbiAgICB2YXIgc28gPSB0eXBlW3NlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZV07XG4gICAgaWYgKCFzbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZSAnICsgc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpO1xufTtcblxuaGVscGVyLm5ld19vcGVyYXRpb24gPSBmdW5jdGlvbiAoc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKSB7XG4gICAgdmFyIHNvID0gdHlwZVtzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWVdO1xuICAgIGlmICghc28pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGUgJyArIHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZSk7XG4gICAgfVxuICAgIHZhciBvYmplY3QgPSBzby50b09iamVjdCh1bmRlZmluZWQsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH0pO1xuICAgIHJldHVybiBzby5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG5oZWxwZXIuaW5zdGFuY2UgPSBmdW5jdGlvbiAoT2JqZWN0SWQpIHtcbiAgICByZXR1cm4gT2JqZWN0SWQuc3Vic3RyaW5nKFwiMC4wLlwiLmxlbmd0aCk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9UcmFuc2FjdGlvbkhlbHBlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEFkZHJlc3M6IHJlcXVpcmUoXCIuL3NyYy9hZGRyZXNzXCIpLFxuICAgIEFlczogcmVxdWlyZShcIi4vc3JjL2Flc1wiKSxcbiAgICBQcml2YXRlS2V5OiByZXF1aXJlKFwiLi9zcmMvUHJpdmF0ZUtleVwiKSxcbiAgICBQdWJsaWNLZXk6IHJlcXVpcmUoXCIuL3NyYy9QdWJsaWNLZXlcIiksXG4gICAgU2lnbmF0dXJlOiByZXF1aXJlKFwiLi9zcmMvc2lnbmF0dXJlXCIpLFxuICAgIGJyYWluS2V5OiByZXF1aXJlKFwiLi9zcmMvQnJhaW5LZXlcIiksXG4gICAgaGFzaDogcmVxdWlyZShcIi4vc3JjL2hhc2hcIiksXG4gICAga2V5OiByZXF1aXJlKFwiLi9zcmMvS2V5VXRpbHNcIilcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplKGJyYWluS2V5KSB7XG4gICAgaWYgKHR5cGVvZiBicmFpbktleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHJlcXVpcmVkIGZvciBicmFpbktleVwiKTtcbiAgICB9XG4gICAgYnJhaW5LZXkgPSBicmFpbktleS50cmltKCk7XG4gICAgcmV0dXJuIGJyYWluS2V5LnNwbGl0KC9bXFx0XFxuXFx2XFxmXFxyIF0rLykuam9pbignICcpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL0JyYWluS2V5LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBrZXk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vUHJpdmF0ZUtleScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG52YXIgQWRkcmVzcyA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xudmFyIEFlcyA9IHJlcXVpcmUoJy4vYWVzJyk7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG4vLyB2YXIgZGljdGlvbmFyeSA9IHJlcXVpcmUoJy4vZGljdGlvbmFyeV9lbicpO1xudmFyIHNlY3VyZVJhbmRvbSA9IHJlcXVpcmUoJ3NlY3VyZS1yYW5kb20nKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbi8vIGhhc2ggZm9yIC4yNSBzZWNvbmRcbnZhciBIQVNIX1BPV0VSX01JTExTID0gMjUwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleSA9IHtcblxuICAgIC8qKiBVc2VzIDEgc2Vjb25kIG9mIGhhc2hpbmcgcG93ZXIgdG8gY3JlYXRlIGEga2V5L3Bhc3N3b3JkIGNoZWNrc3VtLiAgQW5cbiAgICBpbXBsZW1lbnRhdGlvbiBjYW4gcmUtY2FsbCB0aGlzIG1ldGhvZCB3aXRoIHRoZSBzYW1lIHBhc3N3b3JkIHRvIHJlLW1hdGNoXG4gICAgdGhlIHN0cmVuZ3RoIG9mIHRoZSBDUFUgKGVpdGhlciBhZnRlciBtb3ZpbmcgZnJvbSBhIGRlc2t0b3AgdG8gYSBtb2JpbGUsXG4gICAgbW9iaWxlIHRvIGRlc2t0b3AsIG9yIE4geWVhcnMgZnJvbSBub3cgd2hlbiBDUFVzIGFyZSBwcmVzdW1hYmx5IHN0cm9uZ2VyKS5cbiAgICAgQSBzYWx0IGlzIHVzZWQgZm9yIGFsbCB0aGUgbm9ybWFsIHJlYXNvbnMuLi5cbiAgICAgQHJldHVybiBvYmplY3Qge1xuICAgICAgICBhZXNfcHJpdmF0ZTogQWVzLFxuICAgICAgICBjaGVja3N1bTogXCJ7aGFzaF9pdGVyYXRpb25fY291bnR9LHtzYWx0fSx7Y2hlY2tzdW19XCJcbiAgICB9XG4gICAgKi9cbiAgICBhZXNfY2hlY2tzdW06IGZ1bmN0aW9uIGFlc19jaGVja3N1bShwYXNzd29yZCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgcGFzc3dvcmQgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgXCJwYXNzd29yZCBzdHJpbmcgcmVxdWlyZWRcIigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYWx0ID0gc2VjdXJlUmFuZG9tLnJhbmRvbUJ1ZmZlcig0KS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgICAgdmFyIHNlY3JldCA9IHNhbHQgKyBwYXNzd29yZDtcbiAgICAgICAgLy8gaGFzaCBmb3IgLjEgc2Vjb25kXG4gICAgICAgIHZhciBzdGFydF90ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydF90IDwgSEFTSF9QT1dFUl9NSUxMUykge1xuICAgICAgICAgICAgc2VjcmV0ID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2guc2hhMjU2KHNlY3JldCk7XG4gICAgICAgIHZhciBjaGVja3N1bV9zdHJpbmcgPSBbaXRlcmF0aW9ucywgc2FsdC50b1N0cmluZygnaGV4JyksIGNoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignLCcpO1xuXG4gICAgICAgIHJldHVybiB7IGFlc19wcml2YXRlOiBBZXMuZnJvbVNlZWQoc2VjcmV0KSxcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bV9zdHJpbmdcbiAgICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICAvKiogUHJvdmlkZSBhIG1hdGNoaW5nIHBhc3N3b3JkIGFuZCBrZXlfY2hlY2tzdW0uICBBIFwid3JvbmcgcGFzc3dvcmRcIlxuICAgIGVycm9yIGlzIHRocm93biBpZiB0aGUgcGFzc3dvcmQgZG9lcyBub3QgbWF0Y2guICBJZiB0aGlzIG1ldGhvZCB0YWtlc1xuICAgIG11Y2ggbW9yZSBvciBsZXNzIHRoYW4gMSBzZWNvbmQgdG8gcmV0dXJuLCBvbmUgc2hvdWxkIGNvbnNpZGVyIHVwZGF0aW5nXG4gICAgYWxsIGVuY3lycHRlZCBmaWVsZHMgdXNpbmcgYSBuZXcga2V5LmtleV9jaGVja3N1bS5cbiAgICAqL1xuICAgIGFlc19wcml2YXRlOiBmdW5jdGlvbiBhZXNfcHJpdmF0ZShwYXNzd29yZCwga2V5X2NoZWNrc3VtKSB7XG4gICAgICAgIHZhciBfa2V5X2NoZWNrc3VtJHNwbGl0ID0ga2V5X2NoZWNrc3VtLnNwbGl0KCcsJyksXG4gICAgICAgICAgICBfa2V5X2NoZWNrc3VtJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9rZXlfY2hlY2tzdW0kc3BsaXQsIDMpLFxuICAgICAgICAgICAgaXRlcmF0aW9ucyA9IF9rZXlfY2hlY2tzdW0kc3BsaXQyWzBdLFxuICAgICAgICAgICAgc2FsdCA9IF9rZXlfY2hlY2tzdW0kc3BsaXQyWzFdLFxuICAgICAgICAgICAgY2hlY2tzdW0gPSBfa2V5X2NoZWNrc3VtJHNwbGl0MlsyXTtcblxuICAgICAgICB2YXIgc2VjcmV0ID0gc2FsdCArIHBhc3N3b3JkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IGl0ZXJhdGlvbnMgPyBpIDwgaXRlcmF0aW9ucyA6IGkgPiBpdGVyYXRpb25zOyAwIDwgaXRlcmF0aW9ucyA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgc2VjcmV0ID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgaWYgKCEobmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpLnRvU3RyaW5nKCdoZXgnKSA9PT0gY2hlY2tzdW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBwYXNzd29yZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWVzLmZyb21TZWVkKHNlY3JldCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICAgIEEgd2VlayByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBjYW4gcnVuIG91dCBvZiBlbnRyb3B5LiAgVGhpcyBzaG91bGQgZW5zdXJlIGV2ZW4gdGhlIHdvcnN0IHJhbmRvbSBudW1iZXIgaW1wbGVtZW50YXRpb24gd2lsbCBiZSByZWFzb25hYmx5IHNhZmUuXG4gICAgICAgICBAcGFyYW0xIHN0cmluZyBlbnRyb3B5IG9mIGF0IGxlYXN0IDMyIGJ5dGVzXG4gICAgKi9cbiAgICByYW5kb20zMkJ5dGVCdWZmZXI6IGZ1bmN0aW9uIHJhbmRvbTMyQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuYnJvd3NlckVudHJvcHkoKTtcblxuXG4gICAgICAgIGlmICghKHR5cGVvZiBlbnRyb3B5ID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZXF1aXJlZCBmb3IgZW50cm9weVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyb3B5Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgYXQgbGVhc3QgMzIgYnl0ZXMgb2YgZW50cm9weVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydF90ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0X3QgPCBIQVNIX1BPV0VSX01JTExTKSB7XG4gICAgICAgICAgICBlbnRyb3B5ID0gaGFzaC5zaGEyNTYoZW50cm9weSk7XG4gICAgICAgIH12YXIgaGFzaF9hcnJheSA9IFtdO1xuICAgICAgICBoYXNoX2FycmF5LnB1c2goZW50cm9weSk7XG5cbiAgICAgICAgLy8gSGFzaGluZyBmb3IgMSBzZWNvbmQgbWF5IGhlbHBzIHRoZSBjb21wdXRlciBpcyBub3QgbG93IG9uIGVudHJvcHkgKHRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYmFjay10by1iYWNrKS5cbiAgICAgICAgaGFzaF9hcnJheS5wdXNoKHNlY3VyZVJhbmRvbS5yYW5kb21CdWZmZXIoMzIpKTtcblxuICAgICAgICByZXR1cm4gaGFzaC5zaGEyNTYoQnVmZmVyLmNvbmNhdChoYXNoX2FycmF5KSk7XG4gICAgfSxcblxuXG4gICAgc3VnZ2VzdF9icmFpbl9rZXk6IGZ1bmN0aW9uIHN1Z2dlc3RfYnJhaW5fa2V5KCkge1xuICAgICAgICB2YXIgZGljdGlvbmFyeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogXCIsXCI7XG4gICAgICAgIHZhciBlbnRyb3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmJyb3dzZXJFbnRyb3B5KCk7XG5cblxuICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gdGhpcy5yYW5kb20zMkJ5dGVCdWZmZXIoZW50cm9weSk7XG5cbiAgICAgICAgdmFyIHdvcmRfY291bnQgPSAxNjtcbiAgICAgICAgdmFyIGRpY3Rpb25hcnlfbGluZXMgPSBkaWN0aW9uYXJ5LnNwbGl0KCcsJyk7XG5cbiAgICAgICAgaWYgKCEoZGljdGlvbmFyeV9saW5lcy5sZW5ndGggPT09IDQ5NzQ0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgJyArIDQ5NzQ0ICsgJyBidXQgZ290ICcgKyBkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCArICcgZGljdGlvbmFyeSB3b3JkcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJyYWlua2V5ID0gW107XG4gICAgICAgIHZhciBlbmQgPSB3b3JkX2NvdW50ICogMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSArPSAyKSB7XG5cbiAgICAgICAgICAgIC8vIHJhbmRvbUJ1ZmZlciBoYXMgMjU2IGJpdHMgLyAxNiBiaXRzIHBlciB3b3JkID09IDE2IHdvcmRzXG4gICAgICAgICAgICB2YXIgbnVtID0gKHJhbmRvbUJ1ZmZlcltpXSA8PCA4KSArIHJhbmRvbUJ1ZmZlcltpICsgMV07XG5cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgaW50byBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEgKGluY2x1c2l2ZSlcbiAgICAgICAgICAgIHZhciBybmRNdWx0aXBsaWVyID0gbnVtIC8gTWF0aC5wb3coMiwgMTYpO1xuICAgICAgICAgICAgdmFyIHdvcmRJbmRleCA9IE1hdGgucm91bmQoZGljdGlvbmFyeV9saW5lcy5sZW5ndGggKiBybmRNdWx0aXBsaWVyKTtcblxuICAgICAgICAgICAgYnJhaW5rZXkucHVzaChkaWN0aW9uYXJ5X2xpbmVzW3dvcmRJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZV9icmFpbktleShicmFpbmtleS5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICBnZXRfcmFuZG9tX2tleTogZnVuY3Rpb24gZ2V0X3JhbmRvbV9rZXkoZW50cm9weSkge1xuICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKHRoaXMucmFuZG9tMzJCeXRlQnVmZmVyKGVudHJvcHkpKTtcbiAgICB9LFxuICAgIGdldF9icmFpblByaXZhdGVLZXk6IGZ1bmN0aW9uIGdldF9icmFpblByaXZhdGVLZXkoYnJhaW5LZXkpIHtcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgICAgIGlmIChzZXF1ZW5jZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2VxdWVuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJhaW5LZXkgPSBrZXkubm9ybWFsaXplX2JyYWluS2V5KGJyYWluS2V5KTtcbiAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihoYXNoLnNoYTI1NihoYXNoLnNoYTUxMihicmFpbktleSArIFwiIFwiICsgc2VxdWVuY2UpKSk7XG4gICAgfSxcblxuXG4gICAgLy8gVHVybiBpbnZpc2libGUgc3BhY2UgbGlrZSBjaGFyYWN0ZXJzIGludG8gYSBzaW5nbGUgc3BhY2VcbiAgICBub3JtYWxpemVfYnJhaW5LZXk6IGZ1bmN0aW9uIG5vcm1hbGl6ZV9icmFpbktleShicmFpbktleSkge1xuICAgICAgICBpZiAoISh0eXBlb2YgYnJhaW5LZXkgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHJlcXVpcmVkIGZvciBicmFpbktleVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyYWluS2V5ID0gYnJhaW5LZXkudHJpbSgpO1xuICAgICAgICByZXR1cm4gYnJhaW5LZXkuc3BsaXQoL1tcXHRcXG5cXHZcXGZcXHIgXSsvKS5qb2luKCcgJyk7XG4gICAgfSxcbiAgICBicm93c2VyRW50cm9weTogZnVuY3Rpb24gYnJvd3NlckVudHJvcHkoKSB7XG5cbiAgICAgICAgdmFyIGVudHJvcHlTdHIgPSBcIlwiO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZW50cm9weVN0ciA9IG5ldyBEYXRlKCkudG9TdHJpbmcoKSArIFwiIFwiICsgd2luZG93LnNjcmVlbi5oZWlnaHQgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4ud2lkdGggKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uY29sb3JEZXB0aCArIFwiIFwiICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0ICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmF2YWlsV2lkdGggKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4ucGl4ZWxEZXB0aCArIG5hdmlnYXRvci5sYW5ndWFnZSArIFwiIFwiICsgd2luZG93LmxvY2F0aW9uICsgXCIgXCIgKyB3aW5kb3cuaGlzdG9yeS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtaW1lVHlwZTsgaSA8IG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IG5hdmlnYXRvci5taW1lVHlwZXNbaV07XG4gICAgICAgICAgICAgICAgZW50cm9weVN0ciArPSBtaW1lVHlwZS5kZXNjcmlwdGlvbiArIFwiIFwiICsgbWltZVR5cGUudHlwZSArIFwiIFwiICsgbWltZVR5cGUuc3VmZml4ZXMgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSU5GT1xcdGJyb3dzZXJFbnRyb3B5IGdhdGhlcmVkXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy9ub2RlanM6UmVmZXJlbmNlRXJyb3I6IHdpbmRvdyBpcyBub3QgZGVmaW5lZFxuICAgICAgICAgICAgZW50cm9weVN0ciA9IGhhc2guc2hhMjU2KG5ldyBEYXRlKCkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYiA9IG5ldyBCdWZmZXIoZW50cm9weVN0cik7XG4gICAgICAgIGVudHJvcHlTdHIgKz0gYi50b1N0cmluZygnYmluYXJ5JykgKyBcIiBcIiArIG5ldyBEYXRlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGVudHJvcHlTdHI7XG4gICAgfSxcblxuXG4gICAgLy8gQHJldHVybiBhcnJheSBvZiA1IGxlZ2FjeSBhZGRyZXNzZXMgZm9yIGEgcHVia2V5IHN0cmluZyBwYXJhbWV0ZXIuXG4gICAgYWRkcmVzc2VzOiBmdW5jdGlvbiBhZGRyZXNzZXMocHVia2V5KSB7XG4gICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgdmFyIHB1YmxpY19rZXkgPSBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyhwdWJrZXksIGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgLy8gUyBMIE8gV1xuICAgICAgICB2YXIgYWRkcmVzc19zdHJpbmcgPSBbQWRkcmVzcy5mcm9tUHVibGljKHB1YmxpY19rZXksIGZhbHNlLCAwKS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIGJ0Y191bmNvbXByZXNzZWRcbiAgICAgICAgQWRkcmVzcy5mcm9tUHVibGljKHB1YmxpY19rZXksIHRydWUsIDApLnRvU3RyaW5nKGFkZHJlc3NfcHJlZml4KSwgLy8gYnRjX2NvbXByZXNzZWRcbiAgICAgICAgQWRkcmVzcy5mcm9tUHVibGljKHB1YmxpY19rZXksIGZhbHNlLCA1NikudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBwdHNfdW5jb21wcmVzc2VkXG4gICAgICAgIEFkZHJlc3MuZnJvbVB1YmxpYyhwdWJsaWNfa2V5LCB0cnVlLCA1NikudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBwdHNfY29tcHJlc3NlZFxuICAgICAgICBwdWJsaWNfa2V5LnRvQWRkcmVzc1N0cmluZyhhZGRyZXNzX3ByZWZpeCkgLy8gYnRzX3Nob3J0LCBtb3N0IHJlY2VudCBmb3JtYXRcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3Nfc3RyaW5nO1xuICAgIH1cbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9LZXlVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGVjdXJ2ZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdlY3VydmUnKSxcbiAgICBQb2ludCA9IF9yZXF1aXJlLlBvaW50LFxuICAgIGdldEN1cnZlQnlOYW1lID0gX3JlcXVpcmUuZ2V0Q3VydmVCeU5hbWU7XG5cbnZhciBzZWNwMjU2azEgPSBnZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ2JzNTgnKSxcbiAgICBlbmNvZGUgPSBfcmVxdWlyZTIuZW5jb2RlLFxuICAgIGRlY29kZSA9IF9yZXF1aXJlMi5kZWNvZGU7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9QdWJsaWNLZXknKTtcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKFwiZGVlcC1lcXVhbFwiKTtcblxudmFyIEcgPSBzZWNwMjU2azEuRyxcbiAgICBuID0gc2VjcDI1NmsxLm47XG5cbnZhciBQcml2YXRlS2V5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICAgIEBwcml2YXRlIHNlZSBzdGF0aWMgZnVuY3Rpb25zXG4gICAgICAgIEBwYXJhbSB7QmlnSW50ZWdlcn1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIFByaXZhdGVLZXkoZCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpdmF0ZUtleSk7XG5cbiAgICAgICAgdGhpcy5kID0gZDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUHJpdmF0ZUtleSwgW3tcbiAgICAgICAga2V5OiAndG9XaWYnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9XaWYoKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBjaGVja3N1bSBpbmNsdWRlcyB0aGUgdmVyc2lvblxuICAgICAgICAgICAgcHJpdmF0ZV9rZXkgPSBCdWZmZXIuY29uY2F0KFtuZXcgQnVmZmVyKFsweDgwXSksIHByaXZhdGVfa2V5XSk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1Nihwcml2YXRlX2tleSk7XG4gICAgICAgICAgICBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGNoZWNrc3VtKTtcbiAgICAgICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV93aWYgPSBCdWZmZXIuY29uY2F0KFtwcml2YXRlX2tleSwgY2hlY2tzdW1dKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUocHJpdmF0ZV93aWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcmV0dXJuIHtQb2ludH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdWJsaWNLZXlQb2ludCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleVBvaW50KCkge1xuICAgICAgICAgICAgdmFyIFE7XG4gICAgICAgICAgICByZXR1cm4gUSA9IHNlY3AyNTZrMS5HLm11bHRpcGx5KHRoaXMuZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUHVibGljS2V5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHVibGljS2V5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVibGljX2tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1YmxpY19rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNfa2V5ID0gUHVibGljS2V5LmZyb21Qb2ludCh0aGlzLnRvUHVibGljS2V5UG9pbnQoKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnVmZmVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZC50b0J1ZmZlcigzMik7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogRUNJRVMgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0X3NoYXJlZF9zZWNyZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGxlZ2FjeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSB0b1B1YmxpYyhwdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIHZhciBLQiA9IHB1YmxpY19rZXkudG9VbmNvbXByZXNzZWQoKS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIEtCUCA9IFBvaW50LmZyb21BZmZpbmUoc2VjcDI1NmsxLCBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoS0Iuc2xpY2UoMSwgMzMpKSwgLy8geFxuICAgICAgICAgICAgQmlnSW50ZWdlci5mcm9tQnVmZmVyKEtCLnNsaWNlKDMzLCA2NSkpIC8vIHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBQID0gS0JQLm11bHRpcGx5KEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihyKSk7XG4gICAgICAgICAgICB2YXIgUyA9IFAuYWZmaW5lWC50b0J1ZmZlcih7IHNpemU6IDMyIH0pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHRoZSBpbnB1dCB0byBzaGE1MTIgbXVzdCBiZSBleGFjdGx5IDMyLWJ5dGVzLCB0byBtYXRjaCB0aGUgYysrIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICBvZiBnZXRfc2hhcmVkX3NlY3JldC4gIFJpZ2h0IG5vdyBTIHdpbGwgYmUgc2hvcnRlciBpZiB0aGUgbW9zdCBzaWduaWZpY2FudFxuICAgICAgICAgICAgYnl0ZShzKSBpcyB6ZXJvLiAgUGFkIGl0IGJhY2sgdG8gdGhlIGZ1bGwgMzItYnl0ZXNcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWxlZ2FjeSAmJiBTLmxlbmd0aCA8IDMyKSB7XG4gICAgICAgICAgICAgICAgcGFkID0gbmV3IEJ1ZmZlcigzMiAtIFMubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICAgICAgICAgIFMgPSBCdWZmZXIuY29uY2F0KFtwYWQsIFNdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU0hBNTEyIHVzZWQgaW4gRUNJRVNcbiAgICAgICAgICAgIHJldHVybiBoYXNoLnNoYTUxMihTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC8qKiBFQ0lFUyAoZG9lcyBub3QgYWx3YXlzIG1hdGNoIHRoZSBQb2ludC5mcm9tQWZmaW5lIHZlcnNpb24gYWJvdmUpICovXG4gICAgICAgIC8vIGdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXkpe1xuICAgICAgICAvLyAgICAgcHVibGljX2tleSA9IHRvUHVibGljKHB1YmxpY19rZXkpXG4gICAgICAgIC8vICAgICB2YXIgUCA9IHB1YmxpY19rZXkuUS5tdWx0aXBseSggdGhpcy5kICk7XG4gICAgICAgIC8vICAgICB2YXIgUyA9IFAuYWZmaW5lWC50b0J1ZmZlcih7c2l6ZTogMzJ9KTtcbiAgICAgICAgLy8gICAgIC8vIEVDSUVTLCBhZGRzIGFuIGV4dHJhIHNoYTUxMlxuICAgICAgICAvLyAgICAgcmV0dXJuIGhhc2guc2hhNTEyKFMpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLyoqIEB0aHJvd3Mge0Vycm9yfSAtIG92ZXJmbG93IG9mIHRoZSBrZXkgY291bGQgbm90IGJlIGRlcml2ZWQgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hpbGQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQob2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnRvUHVibGljS2V5KCkudG9CdWZmZXIoKSwgb2Zmc2V0XSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBoYXNoLnNoYTI1NihvZmZzZXQpO1xuICAgICAgICAgICAgdmFyIGMgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIob2Zmc2V0KTtcblxuICAgICAgICAgICAgaWYgKGMuY29tcGFyZVRvKG4pID49IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG9mZnNldCB3ZW50IG91dCBvZiBib3VuZHMsIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICAgICAgdmFyIGRlcml2ZWQgPSB0aGlzLmQuYWRkKGMpOyAvLy5tb2QobilcblxuICAgICAgICAgICAgaWYgKGRlcml2ZWQuc2lnbnVtKCkgPT09IDApIHRocm93IG5ldyBFcnJvcihcIkNoaWxkIG9mZnNldCBkZXJpdmVkIHRvIGFuIGludmFsaWQga2V5LCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleShkZXJpdmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIDxoZWxwZXJfZnVuY3Rpb25zPiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CeXRlQnVmZmVyKCkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIDwvaGVscGVyX2Z1bmN0aW9ucz4gKi9cblxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIHBhcmFtdGVyIHRvIGJlIGEgQnVmZmVyIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMzIgIT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTjogRXhwZWN0aW5nIDMyIGJ5dGVzLCBpbnN0ZWFkIGdvdCAnICsgYnVmLmxlbmd0aCArICcsIHN0YWNrIHRyYWNlOicsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgYnVmZmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAYXJnIHtzdHJpbmd9IHNlZWQgLSBhbnkgbGVuZ3RoIHN0cmluZy4gIFRoaXMgaXMgcHJpdmF0ZSwgdGhlIHNhbWUgc2VlZCBwcm9kdWNlcyB0aGUgc2FtZSBwcml2YXRlIGtleSBldmVyeSB0aW1lLiAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVNlZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNlZWQoc2VlZCkge1xuICAgICAgICAgICAgLy8gZ2VuZXJhdGVfcHJpdmF0ZV9rZXlcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiBzZWVkID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihoYXNoLnNoYTI1NihzZWVkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7c3RyaW5nfSBXYWxsZXQgSW1wb3J0IEZvcm1hdCAoc3RpbGwgYSBzZWNyZXQsIE5vdCBlbmNyeXB0ZWQpICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21XaWYnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVdpZihfcHJpdmF0ZV93aWYpIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlX3dpZiA9IG5ldyBCdWZmZXIoZGVjb2RlKF9wcml2YXRlX3dpZikpO1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBwcml2YXRlX3dpZi5yZWFkVUludDgoMCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoMHg4MCwgdmVyc2lvbiwgJ0V4cGVjdGVkIHZlcnNpb24gJyArIDB4ODAgKyAnLCBpbnN0ZWFkIGdvdCAnICsgdmVyc2lvbik7XG4gICAgICAgICAgICAvLyBjaGVja3N1bSBpbmNsdWRlcyB0aGUgdmVyc2lvblxuICAgICAgICAgICAgdmFyIHByaXZhdGVfa2V5ID0gcHJpdmF0ZV93aWYuc2xpY2UoMCwgLTQpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gcHJpdmF0ZV93aWYuc2xpY2UoLTQpO1xuICAgICAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2guc2hhMjU2KHByaXZhdGVfa2V5KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IGhhc2guc2hhMjU2KG5ld19jaGVja3N1bSk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgaXNFcXVhbCA9IGRlZXBFcXVhbChjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tzdW0gZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaXZhdGVfa2V5ID0gcHJpdmF0ZV9rZXkuc2xpY2UoMSk7XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKHByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFByaXZhdGVLZXkuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgJ2hleCcpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQcml2YXRlS2V5O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXZhdGVLZXk7XG5cbnZhciB0b1B1YmxpYyA9IGZ1bmN0aW9uIHRvUHVibGljKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YSA9PSBudWxsID8gZGF0YSA6IGRhdGEuUSA/IGRhdGEgOiBQdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3coZGF0YSk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvUHJpdmF0ZUtleS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpLFxuICAgIFBvaW50ID0gX3JlcXVpcmUuUG9pbnQsXG4gICAgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ2JzNTgnKSxcbiAgICBlbmNvZGUgPSBfcmVxdWlyZTIuZW5jb2RlLFxuICAgIGRlY29kZSA9IF9yZXF1aXJlMi5kZWNvZGU7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG52YXIgQ2hhaW5Db25maWcgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL0NoYWluQ29uZmlnXCIpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG52YXIgRyA9IHNlY3AyNTZrMS5HLFxuICAgIG4gPSBzZWNwMjU2azEubjtcblxudmFyIFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKiBAcGFyYW0ge1BvaW50fSBwdWJsaWMga2V5ICovXG4gICAgZnVuY3Rpb24gUHVibGljS2V5KFEpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1YmxpY0tleSk7XG5cbiAgICAgICAgdGhpcy5RID0gUTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUHVibGljS2V5LCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLlEgPyB0aGlzLlEuY29tcHJlc3NlZCA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLlEgPT09IG51bGwpIHJldHVybiBuZXcgQnVmZmVyKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5RLmdldEVuY29kZWQoY29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvVW5jb21wcmVzc2VkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvVW5jb21wcmVzc2VkKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuUS5nZXRFbmNvZGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IFBvaW50LmRlY29kZUZyb20oc2VjcDI1NmsxLCBidWYpO1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tUG9pbnQocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIGJ0czo6YmxvY2tjaGFpbjo6YWRkcmVzcyAodW5pcXVlIGJ1dCBub3QgYSBmdWxsIHB1YmxpYyBrZXkpICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQmxvY2tjaGFpbkFkZHJlc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CbG9ja2NoYWluQWRkcmVzcygpIHtcbiAgICAgICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIHB1Yl9zaGEgPSBoYXNoLnNoYTUxMihwdWJfYnVmKTtcbiAgICAgICAgICAgIHJldHVybiBoYXNoLnJpcGVtZDE2MChwdWJfc2hhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBBbGlhcyBmb3Ige0BsaW5rIHRvUHVibGljS2V5U3RyaW5nfSAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUHVibGljS2V5U3RyaW5nKGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgRnVsbCBwdWJsaWMga2V5XG4gICAgICAgICAgICB7cmV0dXJufSBzdHJpbmdcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdWJsaWNLZXlTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXlTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9idWYpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBCdWZmZXIuY29uY2F0KFtwdWJfYnVmLCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgZW5jb2RlKGFkZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IHB1YmxpY19rZXkgLSBsaWtlIEdQSFh5ei4uLlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBhZGRyZXNzX3ByZWZpeCAtIGxpa2UgR1BIXG4gICAgICAgICAgICBAcmV0dXJuIFB1YmxpY0tleSBvciBgbnVsbGAgKGlmIHRoZSBwdWJsaWNfa2V5IHN0cmluZyBpcyBpbnZhbGlkKVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0FkZHJlc3NTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BZGRyZXNzU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgcHViX3NoYSA9IGhhc2guc2hhNTEyKHB1Yl9idWYpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBoYXNoLnJpcGVtZDE2MChwdWJfc2hhKTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKGFkZHkpO1xuICAgICAgICAgICAgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW2FkZHksIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc19wcmVmaXggKyBlbmNvZGUoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvUHRzQWRkeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B0c0FkZHkoKSB7XG4gICAgICAgICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGEyNTYocHViX2J1Zik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgICAgICAgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzB4MzhdKSwgYWRkeV0pOyAvL3ZlcnNpb24gNTYoZGVjaW1hbClcblxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoYWRkeSk7XG4gICAgICAgICAgICBjaGVja3N1bSA9IGhhc2guc2hhMjU2KGNoZWNrc3VtKTtcblxuICAgICAgICAgICAgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW2FkZHksIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlKGFkZHkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGlsZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChvZmZzZXQpIHtcblxuICAgICAgICAgICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihvZmZzZXQpLCBcIkJ1ZmZlciByZXF1aXJlZDogb2Zmc2V0XCIpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9mZnNldC5sZW5ndGgsIDMyLCBcIm9mZnNldCBsZW5ndGhcIik7XG5cbiAgICAgICAgICAgIG9mZnNldCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMudG9CdWZmZXIoKSwgb2Zmc2V0XSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBoYXNoLnNoYTI1NihvZmZzZXQpO1xuXG4gICAgICAgICAgICB2YXIgYyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihvZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoYy5jb21wYXJlVG8obikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IHdlbnQgb3V0IG9mIGJvdW5kcywgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICB2YXIgY0cgPSBHLm11bHRpcGx5KGMpO1xuICAgICAgICAgICAgdmFyIFFwcmltZSA9IHRoaXMuUS5hZGQoY0cpO1xuXG4gICAgICAgICAgICBpZiAoc2VjcDI1NmsxLmlzSW5maW5pdHkoUXByaW1lKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IGRlcml2ZWQgdG8gYW4gaW52YWxpZCBrZXksIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tUG9pbnQoUXByaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIDxIRVg+ICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CaW5hcnknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJpbmFyeShiaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGJpbiwgJ2JpbmFyeScpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci50b1N0cmluZygnaGV4JykgPT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSByZXR1cm4gbmV3IFB1YmxpY0tleShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KFBvaW50LmRlY29kZUZyb20oc2VjcDI1NmsxLCBidWZmZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVBvaW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocG9pbnQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUHVibGljS2V5U3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXlTdHJpbmcocHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21TdHJpbmdPclRocm93KHB1YmxpY19rZXksIGFkZHJlc3NfcHJlZml4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwdWJsaWNfa2V5IC0gbGlrZSBHUEhYeXouLi5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gYWRkcmVzc19wcmVmaXggLSBsaWtlIEdQSFxuICAgICAgICAgICAgQHRocm93cyB7RXJyb3J9IGlmIHB1YmxpYyBrZXkgaXMgaW52YWxpZFxuICAgICAgICAgICAgQHJldHVybiBQdWJsaWNLZXlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZ09yVGhyb3cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZ09yVGhyb3cocHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHB1YmxpY19rZXkuc2xpY2UoMCwgYWRkcmVzc19wcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGRyZXNzX3ByZWZpeCwgcHJlZml4LCAnRXhwZWN0aW5nIGtleSB0byBiZWdpbiB3aXRoICcgKyBhZGRyZXNzX3ByZWZpeCArICcsIGluc3RlYWQgZ290ICcgKyBwcmVmaXgpO1xuICAgICAgICAgICAgcHVibGljX2tleSA9IHB1YmxpY19rZXkuc2xpY2UoYWRkcmVzc19wcmVmaXgubGVuZ3RoKTtcblxuICAgICAgICAgICAgcHVibGljX2tleSA9IG5ldyBCdWZmZXIoZGVjb2RlKHB1YmxpY19rZXkpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwdWJsaWNfa2V5LnNsaWNlKC00KTtcbiAgICAgICAgICAgIHB1YmxpY19rZXkgPSBwdWJsaWNfa2V5LnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChwdWJsaWNfa2V5KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBpc0VxdWFsID0gZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKHB1YmxpY19rZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsICdoZXgnKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21QdWJsaWNLZXlTdHJpbmdIZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVB1YmxpY0tleVN0cmluZ0hleChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVB1YmxpY0tleVN0cmluZyhuZXcgQnVmZmVyKGhleCwgJ2hleCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIDwvSEVYPiAqL1xuXG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFB1YmxpY0tleTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQdWJsaWNLZXk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9QdWJsaWNLZXkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdiczU4JyksXG4gICAgZW5jb2RlID0gX3JlcXVpcmUuZW5jb2RlLFxuICAgIGRlY29kZSA9IF9yZXF1aXJlLmRlY29kZTtcblxudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG4vKiogQWRkcmVzc2VzIGFyZSBzaG9ydGVuZWQgbm9uLXJldmVyc2FibGUgaGFzaGVzIG9mIGEgcHVibGljIGtleS4gIFRoZSBmdWxsIFB1YmxpY0tleSBpcyBwcmVmZXJyZWQuXG4gICAgQGRlcHJlY2F0ZWRcbiovXG5cbnZhciBBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkZHJlc3MoYWRkeSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWRkcmVzcyk7XG5cbiAgICAgICAgdGhpcy5hZGR5ID0gYWRkeTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWRkcmVzcywgW3tcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGR5O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKHRoaXMuYWRkeSk7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTUxMihidWZmZXIpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBoYXNoLnJpcGVtZDE2MChfaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21TdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBzdHJpbmcuc2xpY2UoMCwgYWRkcmVzc19wcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGRyZXNzX3ByZWZpeCwgcHJlZml4LCAnRXhwZWN0aW5nIGtleSB0byBiZWdpbiB3aXRoICcgKyBhZGRyZXNzX3ByZWZpeCArICcsIGluc3RlYWQgZ290ICcgKyBwcmVmaXgpO1xuICAgICAgICAgICAgdmFyIGFkZHkgPSBzdHJpbmcuc2xpY2UoYWRkcmVzc19wcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIGFkZHkgPSBuZXcgQnVmZmVyKGRlY29kZShhZGR5KSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gYWRkeS5zbGljZSgtNCk7XG4gICAgICAgICAgICBhZGR5ID0gYWRkeS5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAoYWRkeSk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgaXNFcXVhbCA9IGRlZXBFcXVhbChjaGVja3N1bSwgbmV3X2NoZWNrc3VtKTsgLy8sICdJbnZhbGlkIGNoZWNrc3VtJ1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hlY2tzdW0gZGlkIG5vdCBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVB1YmxpYycsXG5cblxuICAgICAgICAvKiogQHJldHVybiBBZGRyZXNzIC0gQ29tcHJlc3NlZCBQVFMgZm9ybWF0IChieSBkZWZhdWx0KSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVB1YmxpYyhwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA1NjtcblxuICAgICAgICAgICAgdmFyIHNoYTIgPSBoYXNoLnNoYTI1NihwdWJsaWNfa2V5LnRvQnVmZmVyKGNvbXByZXNzZWQpKTtcbiAgICAgICAgICAgIHZhciByZXAgPSBoYXNoLnJpcGVtZDE2MChzaGEyKTtcbiAgICAgICAgICAgIHZhciB2ZXJzaW9uQnVmZmVyID0gbmV3IEJ1ZmZlcigxKTtcbiAgICAgICAgICAgIHZlcnNpb25CdWZmZXIud3JpdGVVSW50OCgweEZGICYgdmVyc2lvbiwgMCk7XG4gICAgICAgICAgICB2YXIgYWRkciA9IEJ1ZmZlci5jb25jYXQoW3ZlcnNpb25CdWZmZXIsIHJlcF0pO1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gaGFzaC5zaGEyNTYoYWRkcik7XG4gICAgICAgICAgICBjaGVjayA9IGhhc2guc2hhMjU2KGNoZWNrKTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFthZGRyLCBjaGVjay5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGhhc2gucmlwZW1kMTYwKGJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFkZHJlc3M7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWRkcmVzcztcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2FkZHJlc3MuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbnZhciBBRVMgPSByZXF1aXJlKFwiY3J5cHRvLWpzL2Flc1wiKTtcbnZhciBlbmNIZXggPSByZXF1aXJlKFwiY3J5cHRvLWpzL2VuYy1oZXhcIik7XG52YXIgZW5jQmFzZTY0ID0gcmVxdWlyZShcImNyeXB0by1qcy9lbmMtYmFzZTY0XCIpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCJieXRlYnVmZmVyXCIpLFxuICAgIExvbmcgPSBfcmVxdWlyZS5Mb25nO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xuXG4vKiogUHJvdmlkZXMgc3ltZXRyaWMgZW5jcnlwdCBhbmQgZGVjcnlwdCB2aWEgQUVTLiAqL1xuXG52YXIgQWVzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqIEBwcml2YXRlICovXG4gICAgZnVuY3Rpb24gQWVzKGl2LCBrZXkpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFlcyk7XG5cbiAgICAgICAgdGhpcy5pdiA9IGl2LCB0aGlzLmtleSA9IGtleTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyBpcyBhbiBleGNlbGxlbnQgd2F5IHRvIGVuc3VyZSB0aGF0IGFsbCByZWZlcmVuY2VzIHRvIEFlcyBjYW4gbm90IG9wZXJhdGUgYW55bW9yZSAoZXhhbXBsZTogYSB3YWxsZXQgYmVjb21lcyBsb2NrZWQpLiAgQW4gYXBwbGljYXRpb24gc2hvdWxkIGVuc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBBZXMgb2JqZWN0IGluc3RhbmNlIGZvciBhIGdpdmVuIHNlY3JldCBgc2VlZGAuICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBZXMsIFt7XG4gICAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdiA9IHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gc2VlZCAtIHNlY3JldCBzZWVkIG1heSBiZSB1c2VkIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9kZWNyeXB0X3dvcmRfYXJyYXlcIixcblxuXG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXIpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzLyNDdXN0b21fS2V5X2FuZF9JVlxuICAgICAgICAgICAgLy8gc2VlIHdhbGxldF9yZWNvcmRzLmNwcCBtYXN0ZXJfa2V5OjpkZWNyeXB0X2tleVxuICAgICAgICAgICAgcmV0dXJuIEFFUy5kZWNyeXB0KHsgY2lwaGVydGV4dDogY2lwaGVyLCBzYWx0OiBudWxsIH0sIHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfZW5jcnlwdF93b3JkX2FycmF5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5jcnlwdF93b3JkX2FycmF5KHBsYWludGV4dCkge1xuICAgICAgICAgICAgLy9odHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy9pc3N1ZXMvZGV0YWlsP2lkPTg1XG4gICAgICAgICAgICB2YXIgY2lwaGVyID0gQUVTLmVuY3J5cHQocGxhaW50ZXh0LCB0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNCYXNlNjQucGFyc2UoY2lwaGVyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVydGV4dFxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBiaW5hcnlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dCA9IG5ldyBCdWZmZXIoY2lwaGVydGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2lwaGVydGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQoY2lwaGVydGV4dCwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmRlY3J5cHRIZXgoY2lwaGVydGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gYmluYXJ5XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0KHBsYWludGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFpbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSBuZXcgQnVmZmVyKHBsYWludGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGxhaW50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYXNzZXJ0IHBsYWludGV4dCwgXCJNaXNzaW5nIHBsYWluIHRleHRcIlxuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLmVuY3J5cHRIZXgocGxhaW50ZXh0LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd8QnVmZmVyfSBwbGFpbnRleHRcbiAgICAgICAgICAgIEByZXR1cm4ge3N0cmluZ30gaGV4XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0VG9IZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRUb0hleChwbGFpbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGxhaW50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0ID0gbmV3IEJ1ZmZlcihwbGFpbnRleHQsICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBsYWludGV4dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2Fzc2VydCBwbGFpbnRleHQsIFwiTWlzc2luZyBwbGFpbiB0ZXh0XCJcbiAgICAgICAgICAgIC8vIGhleCBpcyB0aGUgb25seSBjb21tb24gZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0SGV4KHBsYWludGV4dC50b1N0cmluZygnaGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtzdHJpbmd9IGJpbmFyeSAoY291bGQgZWFzaWx5IGJlIHJlYWRhYmxlIHRleHQpXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWNyeXB0SGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0SGV4KGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNIZXguc3RyaW5naWZ5KHBsYWlud29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb0J1ZmZlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEhleFRvQnVmZmVyKGNpcGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0KGNpcGhlciwgXCJNaXNzaW5nIGNpcGhlciB0ZXh0XCIpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBkYXRhIGludG8gd29yZCBhcnJheXMgKHVzZWQgYnkgQ3J5cHRvKVxuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IGVuY0hleC5wYXJzZShjaXBoZXIpO1xuICAgICAgICAgICAgdmFyIHBsYWlud29yZHMgPSB0aGlzLl9kZWNyeXB0X3dvcmRfYXJyYXkoY2lwaGVyX2FycmF5KTtcbiAgICAgICAgICAgIHZhciBwbGFpbmhleCA9IGVuY0hleC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihwbGFpbmhleCwgJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gY2lwaGVyIC0gaGV4XG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IFtlbmNvZGluZyA9ICdiaW5hcnknXSAtIGEgdmFsaWQgQnVmZmVyIGVuY29kaW5nXG4gICAgICAgICAgICBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhUb1RleHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRIZXhUb1RleHQoY2lwaGVyKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdiaW5hcnknO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0SGV4VG9CdWZmZXIoY2lwaGVyKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBwbGFpbmhleCAtIGhleCBmb3JtYXRcbiAgICAgICAgICAgIEByZXR1cm4ge1N0cmluZ30gaGV4XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlbmNyeXB0SGV4XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNyeXB0SGV4KHBsYWluaGV4KSB7XG4gICAgICAgICAgICB2YXIgcGxhaW5fYXJyYXkgPSBlbmNIZXgucGFyc2UocGxhaW5oZXgpO1xuICAgICAgICAgICAgdmFyIGNpcGhlcl9hcnJheSA9IHRoaXMuX2VuY3J5cHRfd29yZF9hcnJheShwbGFpbl9hcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gZW5jSGV4LnN0cmluZ2lmeShjaXBoZXJfYXJyYXkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogXCJmcm9tU2VlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNlZWQoc2VlZCkge1xuICAgICAgICAgICAgaWYgKHNlZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNlZWQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTUxMihzZWVkKTtcbiAgICAgICAgICAgIF9oYXNoID0gX2hhc2gudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBmcm9tU2VlZCBfaGFzaCcsX2hhc2gpXG4gICAgICAgICAgICByZXR1cm4gQWVzLmZyb21TaGE1MTIoX2hhc2gpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZnJvbVNoYTUxMlwiLFxuXG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gaGFzaCAtIEEgMTI4IGJ5dGUgaGV4IHN0cmluZywgdHlwaWNhbGx5IG9uZSB3b3VsZCBjYWxsIHtAbGluayBmcm9tU2VlZH0gaW5zdGVhZC4gKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TaGE1MTIoaGFzaCkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGhhc2gubGVuZ3RoLCAxMjgsIFwiQSBTaGE1MTIgaW4gSEVYIHNob3VsZCBiZSAxMjggY2hhcmFjdGVycyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGhhc2gubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBpdiA9IGVuY0hleC5wYXJzZShoYXNoLnN1YnN0cmluZyg2NCwgOTYpKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBlbmNIZXgucGFyc2UoaGFzaC5zdWJzdHJpbmcoMCwgNjQpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWVzKGl2LCBrZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZnJvbUJ1ZmZlclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIGFzc2VydChCdWZmZXIuaXNCdWZmZXIoYnVmKSwgXCJFeHBlY3RpbmcgQnVmZmVyXCIpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY0LCBcIkEgU2hhNTEyIEJ1ZmZlciBzaG91bGQgYmUgNjQgY2hhcmFjdGVycyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGJ1Zi5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIEFlcy5mcm9tU2hhNTEyKGJ1Zi50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAdGhyb3dzIHtFcnJvcn0gLSBcIkludmFsaWQgS2V5LCAuLi5cIlxuICAgICAgICAgICAgQGFyZyB7UHJpdmF0ZUtleX0gcHJpdmF0ZV9rZXkgLSByZXF1aXJlZCBhbmQgdXNlZCBmb3IgZGVjcnlwdGlvblxuICAgICAgICAgICAgQGFyZyB7UHVibGljS2V5fSBwdWJsaWNfa2V5IC0gcmVxdWlyZWQgYW5kIHVzZWQgdG8gY2FsY3VhbHRlIHRoZSBzaGFyZWQgc2VjcmV0XG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IFtub25jZSA9IFwiXCJdIG9wdGlvbmFsIGJ1dCBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGFuZCBiZSB1bmlxdWUgd2hlbiByZS11c2luZyB0aGUgc2FtZSBwcml2YXRlL3B1YmxpYyBrZXlzIG1vcmUgdGhhbiBvbmNlLiAgVGhpcyBub25jZSBpcyBub3QgYSBzZWNyZXQuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd8QnVmZmVyfSBtZXNzYWdlIC0gRW5jcnlwdGVkIG1lc3NhZ2UgY29udGFpbmluZyBhIGNoZWNrc3VtXG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZWNyeXB0X3dpdGhfY2hlY2tzdW1cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRfd2l0aF9jaGVja3N1bShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBsZWdhY3kgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG5cbiAgICAgICAgICAgIC8vIFdhcm5pbmc6IERvIG5vdCBwdXQgYG5vbmNlID0gXCJcImAgaW4gdGhlIGFyZ3VtZW50cywgaW4gZXM2IHRoaXMgd2lsbCBub3QgY29udmVydCBcIm51bGxcIiBpbnRvIGFuIGVtdHB5IHN0cmluZ1xuICAgICAgICAgICAgaWYgKG5vbmNlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgbm9uY2UgPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICdoZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFMgPSBwcml2YXRlX2tleS5nZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5LCBsZWdhY3kpO1xuICAgICAgICAgICAgLy8gRCBFIEIgVSBHXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZGVjcnlwdF93aXRoX2NoZWNrc3VtJywge1xuICAgICAgICAgICAgLy8gICAgIHByaXZfdG9fcHViOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKCksXG4gICAgICAgICAgICAvLyAgICAgbm9uY2U6IG5vbmNlLFxuICAgICAgICAgICAgLy8gICAgIG1lc3NhZ2U6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAvLyB9KVxuXG4gICAgICAgICAgICB2YXIgYWVzID0gQWVzLmZyb21TZWVkKEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoXCJcIiArIG5vbmNlKSwgbmV3IEJ1ZmZlcihTLnRvU3RyaW5nKCdoZXgnKSldKSk7XG5cbiAgICAgICAgICAgIHZhciBwbGFuZWJ1ZmZlciA9IGFlcy5kZWNyeXB0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCEocGxhbmVidWZmZXIubGVuZ3RoID49IDQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXksIGNvdWxkIG5vdCBkZWNyeXB0IG1lc3NhZ2UoMSlcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGxhbmVidWZmZXInLHBsYW5lYnVmZmVyKVxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gcGxhbmVidWZmZXIuc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gcGxhbmVidWZmZXIuc2xpY2UoNCk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gY2hlY2tzdW0nLGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcuLi4gcGxhaW50ZXh0JyxwbGFpbnRleHQudG9TdHJpbmcoKSlcblxuICAgICAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2guc2hhMjU2KHBsYWludGV4dCk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICBuZXdfY2hlY2tzdW0gPSBuZXdfY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgICAgICAgICBpZiAoIShjaGVja3N1bS50b1N0cmluZygnaGV4JykgPT09IG5ld19jaGVja3N1bSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSwgY291bGQgbm90IGRlY3J5cHQgbWVzc2FnZSgyKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuY3J5cHRfd2l0aF9jaGVja3N1bVwiLFxuXG5cbiAgICAgICAgLyoqIElkZW50aWNhbCB0byB7QGxpbmsgZGVjcnlwdF93aXRoX2NoZWNrc3VtfSBidXQgdXNlZCB0byBlbmNyeXB0LiAgU2hvdWxkIG5vdCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gbWVzc2FnZSAtIEVuY3J5cHRlZCBtZXNzYWdlIHdoaWNoIGluY2x1ZGVzIGEgY2hlY2tzdW1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRfd2l0aF9jaGVja3N1bShwcml2YXRlX2tleSwgcHVibGljX2tleSwgbm9uY2UsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgLy8gV2FybmluZzogRG8gbm90IHB1dCBgbm9uY2UgPSBcIlwiYCBpbiB0aGUgYXJndW1lbnRzLCBpbiBlczYgdGhpcyB3aWxsIG5vdCBjb252ZXJ0IFwibnVsbFwiIGludG8gYW4gZW10cHkgc3RyaW5nXG5cbiAgICAgICAgICAgIGlmIChub25jZSA9PSBudWxsKSAvLyBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIG5vbmNlID0gXCJcIjtcblxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBTID0gcHJpdmF0ZV9rZXkuZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSk7XG5cbiAgICAgICAgICAgIC8vIEQgRSBCIFUgR1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VuY3J5cHRfd2l0aF9jaGVja3N1bScsIHtcbiAgICAgICAgICAgIC8vICAgICBwcml2X3RvX3B1YjogcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZygpXG4gICAgICAgICAgICAvLyAgICAgcHViOiBwdWJsaWNfa2V5LnRvUHVibGljS2V5U3RyaW5nKClcbiAgICAgICAgICAgIC8vICAgICBub25jZTogbm9uY2VcbiAgICAgICAgICAgIC8vICAgICBtZXNzYWdlOiBtZXNzYWdlLmxlbmd0aFxuICAgICAgICAgICAgLy8gICAgIFM6IFMudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAvLyB9KVxuXG4gICAgICAgICAgICB2YXIgYWVzID0gQWVzLmZyb21TZWVkKEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgLy8gQSBudWxsIG9yIGVtcHR5IHN0cmluZyBub25jZSB3aWxsIG5vdCBlZmZlY3QgdGhlIGhhc2hcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoXCJcIiArIG5vbmNlKSwgbmV3IEJ1ZmZlcihTLnRvU3RyaW5nKCdoZXgnKSldKSk7XG4gICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIFMnLFMudG9TdHJpbmcoJ2hleCcpKVxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYobWVzc2FnZSkuc2xpY2UoMCwgNCk7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoW2NoZWNrc3VtLCBtZXNzYWdlXSk7XG4gICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIHBheWxvYWQnLHBheWxvYWQudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIHJldHVybiBhZXMuZW5jcnlwdChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBZXM7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWVzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvYWVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7IC8vIGZyb20gZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLWxpYiBmcm9tIGdpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2VjZHNhXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnLi9oYXNoJyk7XG52YXIgZW5mb3JjZVR5cGUgPSByZXF1aXJlKCcuL2VuZm9yY2VfdHlwZXMnKTtcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG52YXIgRUNTaWduYXR1cmUgPSByZXF1aXJlKCcuL2Vjc2lnbmF0dXJlJyk7XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTc5I3NlY3Rpb24tMy4yXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljR2VuZXJhdGVLKGN1cnZlLCBoYXNoLCBkLCBjaGVja1NpZywgbm9uY2UpIHtcblxuICBlbmZvcmNlVHlwZSgnQnVmZmVyJywgaGFzaCk7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIGQpO1xuXG4gIGlmIChub25jZSkge1xuICAgIGhhc2ggPSBjcnlwdG8uc2hhMjU2KEJ1ZmZlci5jb25jYXQoW2hhc2gsIG5ldyBCdWZmZXIobm9uY2UpXSkpO1xuICB9XG5cbiAgLy8gc2FuaXR5IGNoZWNrXG4gIGFzc2VydC5lcXVhbChoYXNoLmxlbmd0aCwgMzIsICdIYXNoIG11c3QgYmUgMjU2IGJpdCcpO1xuXG4gIHZhciB4ID0gZC50b0J1ZmZlcigzMik7XG4gIHZhciBrID0gbmV3IEJ1ZmZlcigzMik7XG4gIHZhciB2ID0gbmV3IEJ1ZmZlcigzMik7XG5cbiAgLy8gU3RlcCBCXG4gIHYuZmlsbCgxKTtcblxuICAvLyBTdGVwIENcbiAgay5maWxsKDApO1xuXG4gIC8vIFN0ZXAgRFxuICBrID0gY3J5cHRvLkhtYWNTSEEyNTYoQnVmZmVyLmNvbmNhdChbdiwgbmV3IEJ1ZmZlcihbMF0pLCB4LCBoYXNoXSksIGspO1xuXG4gIC8vIFN0ZXAgRVxuICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgLy8gU3RlcCBGXG4gIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFsxXSksIHgsIGhhc2hdKSwgayk7XG5cbiAgLy8gU3RlcCBHXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICAvLyBTdGVwIEgxL0gyYSwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAvLyBTdGVwIEgyYlxuICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgdmFyIFQgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIodik7XG5cbiAgLy8gU3RlcCBIMywgcmVwZWF0IHVudGlsIFQgaXMgd2l0aGluIHRoZSBpbnRlcnZhbCBbMSwgbiAtIDFdXG4gIHdoaWxlIChULnNpZ251bSgpIDw9IDAgfHwgVC5jb21wYXJlVG8oY3VydmUubikgPj0gMCB8fCAhY2hlY2tTaWcoVCkpIHtcbiAgICBrID0gY3J5cHRvLkhtYWNTSEEyNTYoQnVmZmVyLmNvbmNhdChbdiwgbmV3IEJ1ZmZlcihbMF0pXSksIGspO1xuICAgIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICAgIC8vIFN0ZXAgSDEvSDJhLCBhZ2FpbiwgaWdub3JlZCBhcyB0bGVuID09PSBxbGVuICgyNTYgYml0KVxuICAgIC8vIFN0ZXAgSDJiIGFnYWluXG4gICAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gICAgVCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcih2KTtcbiAgfVxuXG4gIHJldHVybiBUO1xufVxuXG5mdW5jdGlvbiBzaWduKGN1cnZlLCBoYXNoLCBkLCBub25jZSkge1xuXG4gIHZhciBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGhhc2gpO1xuICB2YXIgbiA9IGN1cnZlLm47XG4gIHZhciBHID0gY3VydmUuRztcblxuICB2YXIgciwgcztcbiAgdmFyIGsgPSBkZXRlcm1pbmlzdGljR2VuZXJhdGVLKGN1cnZlLCBoYXNoLCBkLCBmdW5jdGlvbiAoaykge1xuICAgIC8vIGZpbmQgY2Fub25pY2FsbHkgdmFsaWQgc2lnbmF0dXJlXG4gICAgdmFyIFEgPSBHLm11bHRpcGx5KGspO1xuXG4gICAgaWYgKGN1cnZlLmlzSW5maW5pdHkoUSkpIHJldHVybiBmYWxzZTtcblxuICAgIHIgPSBRLmFmZmluZVgubW9kKG4pO1xuICAgIGlmIChyLnNpZ251bSgpID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBzID0gay5tb2RJbnZlcnNlKG4pLm11bHRpcGx5KGUuYWRkKGQubXVsdGlwbHkocikpKS5tb2Qobik7XG4gICAgaWYgKHMuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LCBub25jZSk7XG5cbiAgdmFyIE5fT1ZFUl9UV08gPSBuLnNoaWZ0UmlnaHQoMSk7XG5cbiAgLy8gZW5mb3JjZSBsb3cgUyB2YWx1ZXMsIHNlZSBiaXA2MjogJ2xvdyBzIHZhbHVlcyBpbiBzaWduYXR1cmVzJ1xuICBpZiAocy5jb21wYXJlVG8oTl9PVkVSX1RXTykgPiAwKSB7XG4gICAgcyA9IG4uc3VidHJhY3Qocyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEVDU2lnbmF0dXJlKHIsIHMpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnlSYXcoY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICB2YXIgbiA9IGN1cnZlLm47XG4gIHZhciBHID0gY3VydmUuRztcblxuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIDEuNC4xIEVuZm9yY2UgciBhbmQgcyBhcmUgYm90aCBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzEsIG4g4oiSIDFdXG4gIGlmIChyLnNpZ251bSgpIDw9IDAgfHwgci5jb21wYXJlVG8obikgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5zaWdudW0oKSA8PSAwIHx8IHMuY29tcGFyZVRvKG4pID49IDApIHJldHVybiBmYWxzZTtcblxuICAvLyBjID0gc14tMSBtb2QgblxuICB2YXIgYyA9IHMubW9kSW52ZXJzZShuKTtcblxuICAvLyAxLjQuNCBDb21wdXRlIHUxID0gZXNe4oiSMSBtb2QgblxuICAvLyAgICAgICAgICAgICAgIHUyID0gcnNe4oiSMSBtb2QgblxuICB2YXIgdTEgPSBlLm11bHRpcGx5KGMpLm1vZChuKTtcbiAgdmFyIHUyID0gci5tdWx0aXBseShjKS5tb2Qobik7XG5cbiAgLy8gMS40LjUgQ29tcHV0ZSBSID0gKHhSLCB5UikgPSB1MUcgKyB1MlFcbiAgdmFyIFIgPSBHLm11bHRpcGx5VHdvKHUxLCBRLCB1Mik7XG5cbiAgLy8gMS40LjUgKGNvbnQuKSBFbmZvcmNlIFIgaXMgbm90IGF0IGluZmluaXR5XG4gIGlmIChjdXJ2ZS5pc0luZmluaXR5KFIpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gMS40LjYgQ29udmVydCB0aGUgZmllbGQgZWxlbWVudCBSLnggdG8gYW4gaW50ZWdlclxuICB2YXIgeFIgPSBSLmFmZmluZVg7XG5cbiAgLy8gMS40LjcgU2V0IHYgPSB4UiBtb2QgblxuICB2YXIgdiA9IHhSLm1vZChuKTtcblxuICAvLyAxLjQuOCBJZiB2ID0gciwgb3V0cHV0IFwidmFsaWRcIiwgYW5kIGlmIHYgIT0gciwgb3V0cHV0IFwiaW52YWxpZFwiXG4gIHJldHVybiB2LmVxdWFscyhyKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5KGN1cnZlLCBoYXNoLCBzaWduYXR1cmUsIFEpIHtcbiAgLy8gMS40LjIgSCA9IEhhc2goTSksIGFscmVhZHkgZG9uZSBieSB0aGUgdXNlclxuICAvLyAxLjQuMyBlID0gSFxuICB2YXIgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihoYXNoKTtcbiAgcmV0dXJuIHZlcmlmeVJhdyhjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBRKTtcbn1cblxuLyoqXG4gICogUmVjb3ZlciBhIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAgKlxuICAqIFNlZSBTRUMgMTogRWxsaXB0aWMgQ3VydmUgQ3J5cHRvZ3JhcGh5LCBzZWN0aW9uIDQuMS42LCBcIlB1YmxpY1xuICAqIEtleSBSZWNvdmVyeSBPcGVyYXRpb25cIi5cbiAgKlxuICAqIGh0dHA6Ly93d3cuc2VjZy5vcmcvZG93bmxvYWQvYWlkLTc4MC9zZWMxLXYyLnBkZlxuICAqL1xuZnVuY3Rpb24gcmVjb3ZlclB1YktleShjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBpKSB7XG4gIGFzc2VydC5zdHJpY3RFcXVhbChpICYgMywgaSwgJ1JlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuXG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG5cbiAgYXNzZXJ0KHIuc2lnbnVtKCkgPiAwICYmIHIuY29tcGFyZVRvKG4pIDwgMCwgJ0ludmFsaWQgciB2YWx1ZScpO1xuICBhc3NlcnQocy5zaWdudW0oKSA+IDAgJiYgcy5jb21wYXJlVG8obikgPCAwLCAnSW52YWxpZCBzIHZhbHVlJyk7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBpICYgMTtcblxuICAvLyBUaGUgbW9yZSBzaWduaWZpY2FudCBiaXQgc3BlY2lmaWVzIHdoZXRoZXIgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgLy8gZmlyc3Qgb3Igc2Vjb25kIGNhbmRpZGF0ZSBrZXkuXG4gIHZhciBpc1NlY29uZEtleSA9IGkgPj4gMTtcblxuICAvLyAxLjEgTGV0IHggPSByICsgam5cbiAgdmFyIHggPSBpc1NlY29uZEtleSA/IHIuYWRkKG4pIDogcjtcbiAgdmFyIFIgPSBjdXJ2ZS5wb2ludEZyb21YKGlzWU9kZCwgeCk7XG5cbiAgLy8gMS40IENoZWNrIHRoYXQgblIgaXMgYXQgaW5maW5pdHlcbiAgdmFyIG5SID0gUi5tdWx0aXBseShuKTtcbiAgYXNzZXJ0KGN1cnZlLmlzSW5maW5pdHkoblIpLCAnblIgaXMgbm90IGEgdmFsaWQgY3VydmUgcG9pbnQnKTtcblxuICAvLyBDb21wdXRlIC1lIGZyb20gZVxuICB2YXIgZU5lZyA9IGUubmVnYXRlKCkubW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgdmFyIHJJbnYgPSByLm1vZEludmVyc2Uobik7XG5cbiAgdmFyIFEgPSBSLm11bHRpcGx5VHdvKHMsIEcsIGVOZWcpLm11bHRpcGx5KHJJbnYpO1xuICBjdXJ2ZS52YWxpZGF0ZShRKTtcblxuICByZXR1cm4gUTtcbn1cblxuLyoqXG4gICogQ2FsY3VsYXRlIHB1YmtleSBleHRyYWN0aW9uIHBhcmFtZXRlci5cbiAgKlxuICAqIFdoZW4gZXh0cmFjdGluZyBhIHB1YmtleSBmcm9tIGEgc2lnbmF0dXJlLCB3ZSBoYXZlIHRvXG4gICogZGlzdGluZ3Vpc2ggZm91ciBkaWZmZXJlbnQgY2FzZXMuIFJhdGhlciB0aGFuIHB1dHRpbmcgdGhpc1xuICAqIGJ1cmRlbiBvbiB0aGUgdmVyaWZpZXIsIEJpdGNvaW4gaW5jbHVkZXMgYSAyLWJpdCB2YWx1ZSB3aXRoIHRoZVxuICAqIHNpZ25hdHVyZS5cbiAgKlxuICAqIFRoaXMgZnVuY3Rpb24gc2ltcGx5IHRyaWVzIGFsbCBmb3VyIGNhc2VzIGFuZCByZXR1cm5zIHRoZSB2YWx1ZVxuICAqIHRoYXQgcmVzdWx0ZWQgaW4gYSBzdWNjZXNzZnVsIHB1YmtleSByZWNvdmVyeS5cbiAgKi9cbmZ1bmN0aW9uIGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtKGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lID0gcmVjb3ZlclB1YktleShjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBpKTtcblxuICAgIC8vIDEuNi4yIFZlcmlmeSBRXG4gICAgaWYgKFFwcmltZS5lcXVhbHMoUSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbTogY2FsY1B1YktleVJlY292ZXJ5UGFyYW0sXG4gIGRldGVybWluaXN0aWNHZW5lcmF0ZUs6IGRldGVybWluaXN0aWNHZW5lcmF0ZUssXG4gIHJlY292ZXJQdWJLZXk6IHJlY292ZXJQdWJLZXksXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICB2ZXJpZnlSYXc6IHZlcmlmeVJhd1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2VjZHNhLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7IC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliXG52YXIgZW5mb3JjZVR5cGUgPSByZXF1aXJlKCcuL2VuZm9yY2VfdHlwZXMnKTtcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbmZ1bmN0aW9uIEVDU2lnbmF0dXJlKHIsIHMpIHtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgcik7XG4gIGVuZm9yY2VUeXBlKEJpZ0ludGVnZXIsIHMpO1xuXG4gIHRoaXMuciA9IHI7XG4gIHRoaXMucyA9IHM7XG59XG5cbi8vIEltcG9ydCBvcGVyYXRpb25zXG5FQ1NpZ25hdHVyZS5wYXJzZUNvbXBhY3QgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIGFzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLCA2NSwgJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB2YXIgaSA9IGJ1ZmZlci5yZWFkVUludDgoMCkgLSAyNztcblxuICAvLyBBdCBtb3N0IDMgYml0c1xuICBhc3NlcnQuZXF1YWwoaSwgaSAmIDcsICdJbnZhbGlkIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgdmFyIGNvbXByZXNzZWQgPSAhIShpICYgNCk7XG5cbiAgLy8gUmVjb3ZlcnkgcGFyYW0gb25seVxuICBpID0gaSAmIDM7XG5cbiAgdmFyIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEsIDMzKSk7XG4gIHZhciBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgzMykpO1xuXG4gIHJldHVybiB7XG4gICAgY29tcHJlc3NlZDogY29tcHJlc3NlZCxcbiAgICBpOiBpLFxuICAgIHNpZ25hdHVyZTogbmV3IEVDU2lnbmF0dXJlKHIsIHMpXG4gIH07XG59O1xuXG5FQ1NpZ25hdHVyZS5mcm9tREVSID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgwKSwgMHgzMCwgJ05vdCBhIERFUiBzZXF1ZW5jZScpO1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgxKSwgYnVmZmVyLmxlbmd0aCAtIDIsICdJbnZhbGlkIHNlcXVlbmNlIGxlbmd0aCcpO1xuICBhc3NlcnQuZXF1YWwoYnVmZmVyLnJlYWRVSW50OCgyKSwgMHgwMiwgJ0V4cGVjdGVkIGEgREVSIGludGVnZXInKTtcblxuICB2YXIgckxlbiA9IGJ1ZmZlci5yZWFkVUludDgoMyk7XG4gIGFzc2VydChyTGVuID4gMCwgJ1IgbGVuZ3RoIGlzIHplcm8nKTtcblxuICB2YXIgb2Zmc2V0ID0gNCArIHJMZW47XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KG9mZnNldCksIDB4MDIsICdFeHBlY3RlZCBhIERFUiBpbnRlZ2VyICgyKScpO1xuXG4gIHZhciBzTGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAxKTtcbiAgYXNzZXJ0KHNMZW4gPiAwLCAnUyBsZW5ndGggaXMgemVybycpO1xuXG4gIHZhciByQiA9IGJ1ZmZlci5zbGljZSg0LCBvZmZzZXQpO1xuICB2YXIgc0IgPSBidWZmZXIuc2xpY2Uob2Zmc2V0ICsgMik7XG4gIG9mZnNldCArPSAyICsgc0xlbjtcblxuICBpZiAockxlbiA+IDEgJiYgckIucmVhZFVJbnQ4KDApID09PSAweDAwKSB7XG4gICAgYXNzZXJ0KHJCLnJlYWRVSW50OCgxKSAmIDB4ODAsICdSIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICB9XG5cbiAgaWYgKHNMZW4gPiAxICYmIHNCLnJlYWRVSW50OCgwKSA9PT0gMHgwMCkge1xuICAgIGFzc2VydChzQi5yZWFkVUludDgoMSkgJiAweDgwLCAnUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgfVxuXG4gIGFzc2VydC5lcXVhbChvZmZzZXQsIGJ1ZmZlci5sZW5ndGgsICdJbnZhbGlkIERFUiBlbmNvZGluZycpO1xuICB2YXIgciA9IEJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIockIpO1xuICB2YXIgcyA9IEJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIoc0IpO1xuXG4gIGFzc2VydChyLnNpZ251bSgpID49IDAsICdSIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG4gIGFzc2VydChzLnNpZ251bSgpID49IDAsICdTIHZhbHVlIGlzIG5lZ2F0aXZlJyk7XG5cbiAgcmV0dXJuIG5ldyBFQ1NpZ25hdHVyZShyLCBzKTtcbn07XG5cbi8vIEZJWE1FOiAweDAwLCAweDA0LCAweDgwIGFyZSBTSUdIQVNIXyogYm91bmRhcnkgY29uc3RhbnRzLCBpbXBvcnRpbmcgVHJhbnNhY3Rpb24gY2F1c2VzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeVxuRUNTaWduYXR1cmUucGFyc2VTY3JpcHRTaWduYXR1cmUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHZhciBoYXNoVHlwZSA9IGJ1ZmZlci5yZWFkVUludDgoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB2YXIgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuXG4gIGFzc2VydChoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0LCAnSW52YWxpZCBoYXNoVHlwZScpO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBFQ1NpZ25hdHVyZS5mcm9tREVSKGJ1ZmZlci5zbGljZSgwLCAtMSkpLFxuICAgIGhhc2hUeXBlOiBoYXNoVHlwZVxuICB9O1xufTtcblxuLy8gRXhwb3J0IG9wZXJhdGlvbnNcbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b0NvbXBhY3QgPSBmdW5jdGlvbiAoaSwgY29tcHJlc3NlZCkge1xuICBpZiAoY29tcHJlc3NlZCkgaSArPSA0O1xuICBpICs9IDI3O1xuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDY1KTtcbiAgYnVmZmVyLndyaXRlVUludDgoaSwgMCk7XG5cbiAgdGhpcy5yLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZmZlciwgMSk7XG4gIHRoaXMucy50b0J1ZmZlcigzMikuY29weShidWZmZXIsIDMzKTtcblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuRUNTaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gKCkge1xuICB2YXIgckJhID0gdGhpcy5yLnRvREVSSW50ZWdlcigpO1xuICB2YXIgc0JhID0gdGhpcy5zLnRvREVSSW50ZWdlcigpO1xuXG4gIHZhciBzZXF1ZW5jZSA9IFtdO1xuXG4gIC8vIElOVEVHRVJcbiAgc2VxdWVuY2UucHVzaCgweDAyLCByQmEubGVuZ3RoKTtcbiAgc2VxdWVuY2UgPSBzZXF1ZW5jZS5jb25jYXQockJhKTtcblxuICAvLyBJTlRFR0VSXG4gIHNlcXVlbmNlLnB1c2goMHgwMiwgc0JhLmxlbmd0aCk7XG4gIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHNCYSk7XG5cbiAgLy8gU0VRVUVOQ0VcbiAgc2VxdWVuY2UudW5zaGlmdCgweDMwLCBzZXF1ZW5jZS5sZW5ndGgpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHNlcXVlbmNlKTtcbn07XG5cbkVDU2lnbmF0dXJlLnByb3RvdHlwZS50b1NjcmlwdFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChoYXNoVHlwZSkge1xuICB2YXIgaGFzaFR5cGVCdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICBoYXNoVHlwZUJ1ZmZlci53cml0ZVVJbnQ4KGhhc2hUeXBlLCAwKTtcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy50b0RFUigpLCBoYXNoVHlwZUJ1ZmZlcl0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFQ1NpZ25hdHVyZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2Vjc2lnbmF0dXJlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuZm9yY2UodHlwZSwgdmFsdWUpIHtcbiAgLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmIChnZXROYW1lKHZhbHVlLmNvbnN0cnVjdG9yKSA9PT0gZ2V0TmFtZSh0eXBlKSkgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgJyArIChnZXROYW1lKHR5cGUpIHx8IHR5cGUpICsgJywgZ290ICcgKyB2YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBnZXROYW1lKGZuKSB7XG4gIC8vIFdoeSBub3QgZm4ubmFtZTogaHR0cHM6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczYvI2Z1bmN0aW9uX25hbWVfcHJvcGVydHlcbiAgdmFyIG1hdGNoID0gZm4udG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb24gKC4qPylcXCgvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvZW5mb3JjZV90eXBlcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoXCJjcmVhdGUtaGFzaFwiKTtcbnZhciBjcmVhdGVIbWFjID0gcmVxdWlyZShcImNyZWF0ZS1obWFjXCIpO1xuXG4vKiogQGFyZyB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgIEBhcmcge3N0cmluZ30gW2RpZ2VzdCA9IG51bGxdIC0gJ2hleCcsICdiaW5hcnknIG9yICdiYXNlNjQnXG4gICAgQHJldHVybiB7c3RyaW5nfEJ1ZmZlcn0gLSBCdWZmZXIgd2hlbiBkaWdlc3QgaXMgbnVsbCwgb3Igc3RyaW5nXG4qL1xuZnVuY3Rpb24gc2hhMShkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGEyNTYoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGE1MTIoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhNTEyJykudXBkYXRlKGRhdGEpLmRpZ2VzdChlbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIEhtYWNTSEEyNTYoYnVmZmVyLCBzZWNyZXQpIHtcbiAgICByZXR1cm4gY3JlYXRlSG1hYygnc2hhMjU2Jywgc2VjcmV0KS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKTtcbn1cblxuZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGRhdGEpLmRpZ2VzdCgpO1xufVxuXG4vLyBmdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuLy8gICByZXR1cm4gcmlwZW1kMTYwKHNoYTI1NihidWZmZXIpKVxuLy8gfVxuLy9cbi8vIGZ1bmN0aW9uIGhhc2gyNTYoYnVmZmVyKSB7XG4vLyAgIHJldHVybiBzaGEyNTYoc2hhMjU2KGJ1ZmZlcikpXG4vLyB9XG5cbi8vXG4vLyBmdW5jdGlvbiBIbWFjU0hBNTEyKGJ1ZmZlciwgc2VjcmV0KSB7XG4vLyAgIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgc2VjcmV0KS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoKVxuLy8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGExOiBzaGExLFxuICAgIHNoYTI1Njogc2hhMjU2LFxuICAgIHNoYTUxMjogc2hhNTEyLFxuICAgIEhtYWNTSEEyNTY6IEhtYWNTSEEyNTYsXG4gICAgcmlwZW1kMTYwOiByaXBlbWQxNjBcbiAgICAvLyBoYXNoMTYwOiBoYXNoMTYwLFxuICAgIC8vIGhhc2gyNTY6IGhhc2gyNTYsXG4gICAgLy8gSG1hY1NIQTUxMjogSG1hY1NIQTUxMlxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2hhc2guanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBlY2RzYSA9IHJlcXVpcmUoJy4vZWNkc2EnKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpLFxuICAgIGdldEN1cnZlQnlOYW1lID0gX3JlcXVpcmUuZ2V0Q3VydmVCeU5hbWU7XG5cbnZhciBzZWNwMjU2azEgPSBnZXRDdXJ2ZUJ5TmFtZSgnc2VjcDI1NmsxJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL1B1YmxpY0tleScpO1xuXG52YXIgU2lnbmF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpZ25hdHVyZShyMSwgczEsIGkxKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWduYXR1cmUpO1xuXG4gICAgICAgIHRoaXMuciA9IHIxO1xuICAgICAgICB0aGlzLnMgPSBzMTtcbiAgICAgICAgdGhpcy5pID0gaTE7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLnIgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLnMgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgICAgIGFzc2VydC5lcXVhbCh0aGlzLmkgIT0gbnVsbCwgdHJ1ZSwgJ01pc3NpbmcgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNpZ25hdHVyZSwgW3tcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYnVmO1xuICAgICAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcig2NSk7XG4gICAgICAgICAgICBidWYud3JpdGVVSW50OCh0aGlzLmksIDApO1xuICAgICAgICAgICAgdGhpcy5yLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZiwgMSk7XG4gICAgICAgICAgICB0aGlzLnMudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAzMyk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5RnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJQdWJsaWNLZXkoaGFzaC5zaGEyNTYoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY292ZXJQdWJsaWNLZXknLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcmV0dXJuIHtQdWJsaWNLZXl9XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KHNoYTI1Nl9idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBRID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgaSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoc2hhMjU2X2J1ZmZlcik7XG4gICAgICAgICAgICBpID0gdGhpcy5pO1xuICAgICAgICAgICAgaSAtPSAyNztcbiAgICAgICAgICAgIGkgPSBpICYgMztcbiAgICAgICAgICAgIFEgPSBlY2RzYS5yZWNvdmVyUHViS2V5KHNlY3AyNTZrMSwgZSwgdGhpcywgaSk7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChRKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndmVyaWZ5QnVmZmVyJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IHVuLWhhc2hlZFxuICAgICAgICAgICAgQHBhcmFtIHsuL1B1YmxpY0tleX1cbiAgICAgICAgICAgIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlCdWZmZXIoYnVmLCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTI1NihidWYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5SGFzaChfaGFzaCwgcHVibGljX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZlcmlmeUhhc2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SGFzaChoYXNoLCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaGFzaC5sZW5ndGgsIDMyLCBcIkEgU0hBIDI1NiBzaG91bGQgYmUgMzIgYnl0ZXMgbG9uZywgaW5zdGVhZCBnb3QgXCIgKyBoYXNoLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gZWNkc2EudmVyaWZ5KHNlY3AyNTZrMSwgaGFzaCwge1xuICAgICAgICAgICAgICAgIHI6IHRoaXMucixcbiAgICAgICAgICAgICAgICBzOiB0aGlzLnNcbiAgICAgICAgICAgIH0sIHB1YmxpY19rZXkuUSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG5cblxuICAgICAgICAvKiA8SEVYPiAqL1xuXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYjtcbiAgICAgICAgICAgIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J1ZmZlcigpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2ZXJpZnlIZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5SGV4KGhleCwgcHVibGljX2tleSkge1xuICAgICAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlCdWZmZXIoYnVmLCBwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmKSB7XG4gICAgICAgICAgICB2YXIgaSwgciwgcztcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChidWYubGVuZ3RoLCA2NSwgJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICAgICAgICAgICAgaSA9IGJ1Zi5yZWFkVUludDgoMCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaSAtIDI3LCBpIC0gMjcgJiA3LCAnSW52YWxpZCBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICByID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zi5zbGljZSgxLCAzMykpO1xuICAgICAgICAgICAgcyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWYuc2xpY2UoMzMpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMsIGkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduQnVmZmVyJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICAgICAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICAgICAgQHJldHVybiB7U2lnbmF0dXJlfVxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkJ1ZmZlcihidWYsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB2YXIgX2hhc2ggPSBoYXNoLnNoYTI1NihidWYpO1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyU2hhMjU2KF9oYXNoLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogU2lnbiBhIGJ1ZmZlciBvZiBleGFjdGFsbHkgMzIgYnl0ZXMgaW4gc2l6ZSAoc2hhMjU2KHRleHQpKVxuICAgICAgICAgICAgQHBhcmFtIHtCdWZmZXJ9IGJ1ZiAtIDMyIGJ5dGVzIGJpbmFyeVxuICAgICAgICAgICAgQHBhcmFtIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleVxuICAgICAgICAgICAgQHJldHVybiB7U2lnbmF0dXJlfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduQnVmZmVyU2hhMjU2JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25CdWZmZXJTaGEyNTYoYnVmX3NoYTI1NiwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIGlmIChidWZfc2hhMjU2Lmxlbmd0aCAhPT0gMzIgfHwgIUJ1ZmZlci5pc0J1ZmZlcihidWZfc2hhMjU2KSkgdGhyb3cgbmV3IEVycm9yKFwiYnVmX3NoYTI1NjogMzIgYnl0ZSBidWZmZXIgcmVxdXJlZFwiKTtcbiAgICAgICAgICAgIHZhciBkZXIsIGUsIGVjc2lnbmF0dXJlLCBpLCBsZW5SLCBsZW5TLCBub25jZTtcbiAgICAgICAgICAgIGkgPSBudWxsO1xuICAgICAgICAgICAgbm9uY2UgPSAwO1xuICAgICAgICAgICAgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZfc2hhMjU2KTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWNzaWduYXR1cmUgPSBlY2RzYS5zaWduKHNlY3AyNTZrMSwgYnVmX3NoYTI1NiwgcHJpdmF0ZV9rZXkuZCwgbm9uY2UrKyk7XG4gICAgICAgICAgICAgICAgZGVyID0gZWNzaWduYXR1cmUudG9ERVIoKTtcbiAgICAgICAgICAgICAgICBsZW5SID0gZGVyWzNdO1xuICAgICAgICAgICAgICAgIGxlblMgPSBkZXJbNSArIGxlblJdO1xuICAgICAgICAgICAgICAgIGlmIChsZW5SID09PSAzMiAmJiBsZW5TID09PSAzMikge1xuICAgICAgICAgICAgICAgICAgICBpID0gZWNkc2EuY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oc2VjcDI1NmsxLCBlLCBlY3NpZ25hdHVyZSwgcHJpdmF0ZV9rZXkudG9QdWJsaWNLZXkoKS5RKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0OyAvLyBjb21wcmVzc2VkXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjc7IC8vIGNvbXBhY3QgIC8vICAyNCBvciAyNyA6KCBmb3JjaW5nIG9kZC15IDJuZCBrZXkgY2FuZGlkYXRlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlICUgMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBcIiArIG5vbmNlICsgXCIgYXR0ZW1wdHMgdG8gZmluZCBjYW5vbmljYWwgc2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKGVjc2lnbmF0dXJlLnIsIGVjc2lnbmF0dXJlLnMsIGkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oc3RyaW5nLCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyKG5ldyBCdWZmZXIoc3RyaW5nKSwgcHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CdWZmZXIobmV3IEJ1ZmZlcihoZXgsIFwiaGV4XCIpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2lnbkhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduSGV4KGhleCwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICBidWYgPSBuZXcgQnVmZmVyKGhleCwgJ2hleCcpO1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5zaWduQnVmZmVyKGJ1ZiwgcHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNpZ25hdHVyZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9zaWduYXR1cmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduKHJlcXVpcmUoXCIuL2NoYWluXCIpLCByZXF1aXJlKFwiLi9lY2NcIiksIHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIikpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvLyBQcmltYXJ5IGNsYXNzIGZvciBjcmVhdGluZyBvcGVyYXRpb25zXG4gICAgU2VyaWFsaXplcjogcmVxdWlyZSgnLi9zcmMvc2VyaWFsaXplcicpLFxuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9ucyBmb3IgY3JlYXRpbmcgb3BlcmF0aW9uc1xuICAgIGZwOiByZXF1aXJlKCcuL3NyYy9GYXN0UGFyc2VyJyksXG5cbiAgICAvLyBMb3cgbGV2ZWwgdHlwZXNcbiAgICB0eXBlczogcmVxdWlyZSgnLi9zcmMvdHlwZXMnKSxcblxuICAgIC8vIEhpZ2hlciBsZXZlbCBvcGVyYXRpb25zIChtYWRlIG91dCBvZiBnZW5lcmljIHR5cGVzKVxuICAgIG9wczogcmVxdWlyZSgnLi9zcmMvb3BlcmF0aW9ucycpLFxuXG4gICAgLy8gVXRpbGl0eSB0aGF0IGdlbmVyYXRlcyBKU09OIGV4YW1wbGVzXG4gICAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc3JjL3RlbXBsYXRlJyksXG5cbiAgICAvLyBTZXJpYWxpemVyIHZhbGlkYXRpb25cbiAgICBTZXJpYWxpemVyVmFsaWRhdGlvbjogcmVxdWlyZSgnLi9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24nKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUHVibGljS2V5ID0gcmVxdWlyZShcIi4uLy4uL2VjYy9zcmMvUHVibGljS2V5XCIpO1xuXG52YXIgRmFzdFBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYXN0UGFyc2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmFzdFBhcnNlcik7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEZhc3RQYXJzZXIsIG51bGwsIFt7XG4gICAgICAgIGtleTogJ2ZpeGVkX2RhdGEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZml4ZWRfZGF0YShiLCBsZW4sIGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNsaWNlKDAsIGxlbikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIGIuYXBwZW5kKGRhdGEsICdiaW5hcnknKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobGVuLS0gPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIGxlbik7XG4gICAgICAgICAgICAgICAgYi5za2lwKGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHVibGljX2tleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdWJsaWNfa2V5KGIsIF9wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3B1YmxpY19rZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gX3B1YmxpY19rZXkudG9CdWZmZXIoKTtcbiAgICAgICAgICAgICAgICBiLmFwcGVuZChidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMzMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyaXBlbWQxNjAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmlwZW1kMTYwKGIsIF9yaXBlbWQpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcmlwZW1kKSB7XG4gICAgICAgICAgICAgICAgRmFzdFBhcnNlci5maXhlZF9kYXRhKGIsIDIwLCBfcmlwZW1kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0aW1lX3BvaW50X3NlYycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lX3BvaW50X3NlYyhiLCBlcG9jaCkge1xuICAgICAgICAgICAgaWYgKGVwb2NoKSB7XG4gICAgICAgICAgICAgICAgZXBvY2ggPSBNYXRoLmNlaWwoZXBvY2ggLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBiLndyaXRlSW50MzIoZXBvY2gpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXBvY2ggPSBiLnJlYWRJbnQzMigpOyAvLyBmYzo6dGltZV9wb2ludF9zZWNcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY2ggKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBGYXN0UGFyc2VyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhc3RQYXJzZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvRmFzdFBhcnNlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9teTtcbnZhciBpc19lbXB0eTtcbnZhciBpc19kaWdpdHM7XG52YXIgdG9fbnVtYmVyO1xudmFyIHJlcXVpcmVfbWF0Y2g7XG52YXIgcmVxdWlyZV9vYmplY3RfaWQ7XG52YXIgcmVxdWlyZV9vYmplY3RfdHlwZTtcbnZhciBnZXRfaW5zdGFuY2U7XG52YXIgcmVxdWlyZV9yZWxhdGl2ZV90eXBlO1xudmFyIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTtcbnZhciByZXF1aXJlX3Byb3RvY29sX3R5cGU7XG52YXIgZ2V0X3Byb3RvY29sX2luc3RhbmNlO1xudmFyIGdldF9wcm90b2NvbF90eXBlO1xudmFyIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZTtcbnZhciBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2U7XG52YXIgTG9uZyA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKS5Mb25nO1xuLy8gdmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKCdiaWdpJyk7XG5cbnZhciBjaGFpbl90eXBlcyA9IHJlcXVpcmUoJy4uLy4uL2NoYWluL3NyYy9DaGFpblR5cGVzJyk7XG5cbnZhciBNQVhfU0FGRV9JTlQgPSA5MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1JTl9TQUZFX0lOVCA9IC05MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAgICBNb3N0IHZhbGlkYXRpb25zIGFyZSBza2lwcGVkIGFuZCB0aGUgdmFsdWUgcmV0dXJuZWQgdW5jaGFuZ2VkIHdoZW4gYW4gZW1wdHkgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQgaXMgZW5jb3VudGVyZWQgKGV4Y2VwdCBcInJlcXVpcmVkXCIpLiBcbiAgICBWYWxpZGF0aW9ucyBzdXBwb3J0IGEgc3RyaW5nIGZvcm1hdCBmb3IgZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBfbXkgPSB7XG5cbiAgICBpc19lbXB0eTogaXNfZW1wdHkgPSBmdW5jdGlvbiBpc19lbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgcmVxdWlyZWQ6IGZ1bmN0aW9uIHJlcXVpcmVkKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgcmVxdWlyZWQgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVxdWlyZV9sb25nOiBmdW5jdGlvbiByZXF1aXJlX2xvbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9uZyB2YWx1ZSByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBzdHJpbmc6IGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcmVxdWlyZWQ6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbnVtYmVyOiBmdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIHJlcXVpcmVkOiAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHdob2xlX251bWJlcjogZnVuY3Rpb24gd2hvbGVfbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcLi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd2hvbGUgbnVtYmVyIHJlcXVpcmVkICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHVuc2lnbmVkOiBmdW5jdGlvbiB1bnNpZ25lZCh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC8tLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNpZ25lZCByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuXG4gICAgaXNfZGlnaXRzOiBpc19kaWdpdHMgPSBmdW5jdGlvbiBpc19kaWdpdHModmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1lcmljXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoL15bMC05XSskLy50ZXN0KHZhbHVlKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICB0b19udW1iZXI6IHRvX251bWJlciA9IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgX215Lm5vX292ZXJmbG93NTModmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICB2YXIgaW50X3ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gaW50X3ZhbHVlO1xuICAgIH0sXG5cbiAgICB0b19sb25nOiBmdW5jdGlvbiB0b19sb25nKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTG9uZy5pc0xvbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBfbXkubm9fb3ZlcmZsb3c2NCh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdG9fc3RyaW5nOiBmdW5jdGlvbiB0b19zdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBfbXkubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICd1bnN1cHBvcnRlZCB0eXBlICcgKyBmaWVsZF9uYW1lICsgJzogKCcgKyAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICsgJykgJyArIHZhbHVlO1xuICAgIH0sXG4gICAgcmVxdWlyZV90ZXN0OiBmdW5jdGlvbiByZXF1aXJlX3Rlc3QocmVnZXgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWF0Y2hlZCAnICsgcmVnZXggKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX21hdGNoOiByZXF1aXJlX21hdGNoID0gZnVuY3Rpb24gcmVxdWlyZV9tYXRjaChyZWdleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VubWF0Y2hlZCAnICsgcmVnZXggKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9LFxuXG4gICAgLy8gcmVxdWlyZV9vYmplY3RfaWQ6IHJlcXVpcmVfb2JqZWN0X2lkPWZ1bmN0aW9uKHZhbHVlLCBmaWVsZF9uYW1lKXtcbiAgICAvLyAgICAgcmV0dXJuIHJlcXVpcmVfbWF0Y2goXG4gICAgLy8gICAgICAgICAvXihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSQvLFxuICAgIC8vICAgICAgICAgdmFsdWUsXG4gICAgLy8gICAgICAgICBmaWVsZF9uYW1lXG4gICAgLy8gICAgICk7XG4gICAgLy8gfSxcblxuICAgIC8vIERvZXMgbm90IHN1cHBvcnQgb3ZlciA1MyBiaXRzXG4gICAgcmVxdWlyZV9yYW5nZTogZnVuY3Rpb24gcmVxdWlyZV9yYW5nZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBudW1iZXIgPSB0b19udW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0IG9mIHJhbmdlICcgKyB2YWx1ZSArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIHJlcXVpcmVfb2JqZWN0X3R5cGU6IHJlcXVpcmVfb2JqZWN0X3R5cGUgPSBmdW5jdGlvbiByZXF1aXJlX29iamVjdF90eXBlKCkge1xuICAgICAgICB2YXIgcmVzZXJ2ZWRfc3BhY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iamVjdF90eXBlID0gY2hhaW5fdHlwZXMub2JqZWN0X3R5cGVbdHlwZV07XG4gICAgICAgIGlmICghb2JqZWN0X3R5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBvYmplY3QgdHlwZTogJyArIHR5cGUgKyAnLCAnICsgZmllbGRfbmFtZSArICcsICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChyZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZSArICcuWzAtOV0rJCcpO1xuICAgICAgICBpZiAoIXJlLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyAnICsgdHlwZSArICcgaW4gZm9ybWF0ICcgKyAocmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGUgKyAnLlswLTldKyAnKSArICgnaW5zdGVhZCBvZiAnICsgdmFsdWUgKyAnICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9pbnN0YW5jZTogZ2V0X2luc3RhbmNlID0gZnVuY3Rpb24gZ2V0X2luc3RhbmNlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZV9vYmplY3RfdHlwZShyZXNlcnZlX3NwYWNlcywgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICAgIH0sXG5cbiAgICByZXF1aXJlX3JlbGF0aXZlX3R5cGU6IHJlcXVpcmVfcmVsYXRpdmVfdHlwZSA9IGZ1bmN0aW9uIHJlcXVpcmVfcmVsYXRpdmVfdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICByZXF1aXJlX29iamVjdF90eXBlKDAsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfcmVsYXRpdmVfaW5zdGFuY2U6IGdldF9yZWxhdGl2ZV9pbnN0YW5jZSA9IGZ1bmN0aW9uIGdldF9yZWxhdGl2ZV9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZV9vYmplY3RfdHlwZSgwLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gICAgfSxcblxuICAgIHJlcXVpcmVfcHJvdG9jb2xfdHlwZTogcmVxdWlyZV9wcm90b2NvbF90eXBlID0gZnVuY3Rpb24gcmVxdWlyZV9wcm90b2NvbF90eXBlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIHJlcXVpcmVfb2JqZWN0X3R5cGUoMSwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9wcm90b2NvbF9pbnN0YW5jZTogZ2V0X3Byb3RvY29sX2luc3RhbmNlID0gZnVuY3Rpb24gZ2V0X3Byb3RvY29sX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXF1aXJlX29iamVjdF90eXBlKDEsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgZ2V0X3Byb3RvY29sX3R5cGU6IGdldF9wcm90b2NvbF90eXBlID0gZnVuY3Rpb24gZ2V0X3Byb3RvY29sX3R5cGUodmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVpcmVfb2JqZWN0X2lkKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0b19udW1iZXIodmFsdWVzWzFdKTtcbiAgICB9LFxuXG4gICAgZ2V0X3Byb3RvY29sX3R5cGVfbmFtZTogZnVuY3Rpb24gZ2V0X3Byb3RvY29sX3R5cGVfbmFtZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVfaWQgPSBnZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjaGFpbl90eXBlcy5vYmplY3RfdHlwZSlbdHlwZV9pZF07XG4gICAgfSxcblxuXG4gICAgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl90eXBlOiByZXF1aXJlX2ltcGxlbWVudGF0aW9uX3R5cGUgPSBmdW5jdGlvbiByZXF1aXJlX2ltcGxlbWVudGF0aW9uX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgcmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0X2ltcGxlbWVudGF0aW9uX2luc3RhbmNlOiBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2UodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVpcmVfb2JqZWN0X3R5cGUoMiwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICAgIH0sXG5cbiAgICAvLyBzaWduZWQgLyB1bnNpZ25lZCBkZWNpbWFsXG4gICAgbm9fb3ZlcmZsb3c1MzogZnVuY3Rpb24gbm9fb3ZlcmZsb3c1Myh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhciBpbnQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIHR5cGVvZiB2YWx1ZS50b0ludCgpIGlzICdudW1iZXInXG4gICAgICAgICAgICBfbXkubm9fb3ZlcmZsb3c1Myh2YWx1ZS50b0ludCgpLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAndW5zdXBwb3J0ZWQgdHlwZSAnICsgZmllbGRfbmFtZSArICc6ICgnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSArICcpICcgKyB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICAvLyBzaWduZWQgLyB1bnNpZ25lZCB3aG9sZSBudW1iZXJzIG9ubHlcbiAgICBub19vdmVyZmxvdzY0OiBmdW5jdGlvbiBub19vdmVyZmxvdzY0KHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL0xvbmcuanMvaXNzdWVzLzIwXG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpZ0ludGVnZXIjaXNCaWdJbnRlZ2VyIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaS9pc3N1ZXMvMjBcbiAgICAgICAgaWYgKHZhbHVlLnQgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9teS5ub19vdmVyZmxvdzY0KHZhbHVlLnRvU3RyaW5nKCksIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVyb3MsIHdpbGwgY2F1c2UgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eMCsvLCAnJyk7XG4gICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIHdoaWxlICgvMCQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL1xcLiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIGRvdFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsb25nX3N0cmluZyA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChsb25nX3N0cmluZyAhPT0gdmFsdWUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdmVyZmxvdyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBNQVhfU0FGRV9JTlQgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgJ3Vuc3VwcG9ydGVkIHR5cGUgJyArIGZpZWxkX25hbWUgKyAnOiAoJyArICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgKyAnKSAnICsgdmFsdWU7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9TZXJpYWxpemVyVmFsaWRhdGlvbi5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqIEV4Y2VwdGlvbiBuZXN0aW5nLiAgKi9cbnZhciBFcnJvcldpdGhDYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFcnJvcldpdGhDYXVzZShtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXJyb3JXaXRoQ2F1c2UpO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGlmICh0eXBlb2YgY2F1c2UgIT09IFwidW5kZWZpbmVkXCIgJiYgY2F1c2UgIT09IG51bGwgPyBjYXVzZS5tZXNzYWdlIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcImNhdXNlXFx0XCIgKyBjYXVzZS5tZXNzYWdlICsgXCJcXHRcIiArIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFjayA9IFwiXCI7IC8vKG5ldyBFcnJvcikuc3RhY2tcbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLnN0YWNrIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFjayA9IFwiY2F1c2VkIGJ5XFxuXFx0XCIgKyBjYXVzZS5zdGFjayArIFwiXFx0XCIgKyBzdGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLm1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVycm9yV2l0aENhdXNlLCBudWxsLCBbe1xuICAgICAgICBrZXk6IFwidGhyb3dcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvdyhtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICAgICAgdmFyIG1zZyA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2UubWVzc2FnZSA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1zZyArPSBcIlxcdCBjYXVzZTogXCIgKyBjYXVzZS5tZXNzYWdlICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCJcXG4gc3RhY2s6IFwiICsgY2F1c2Uuc3RhY2sgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVycm9yV2l0aENhdXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yV2l0aENhdXNlO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL2Vycm9yX3dpdGhfY2F1c2UuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuLyoqXG4gICAgQ29udmVydCAxMi4zNCB3aXRoIGEgcHJlY2lzaW9uIG9mIDMgaW50byAxMjM0MFxuXG4gICAgQGFyZyB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIC0gVXNlIHN0cmluZ3MgZm9yIGxhcmdlIG51bWJlcnMuICBUaGlzIG1heSBjb250YWluIG9uZSBkZWNpbWFsIGJ1dCBubyBzaWduXG4gICAgQGFyZyB7bnVtYmVyfSBwcmVjaXNpb24gLSBudW1iZXIgb2YgaW1wbGllZCBkZWNpbWFsIHBsYWNlcyAodXN1YWxseSBjYXVzZXMgcmlnaHQgemVybyBwYWRkaW5nKVxuICAgIEByZXR1cm4ge3N0cmluZ30gLVxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRvSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIHRvSW1wbGllZERlY2ltYWwobnVtYmVyLCBwcmVjaXNpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyID09PSBcInN0cmluZ1wiLCBcIm51bWJlciBzaG91bGQgYmUgYW4gYWN0dWFsIG51bWJlciBvciBzdHJpbmc6IFwiICsgKHR5cGVvZiBudW1iZXIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihudW1iZXIpKSk7XG4gICAgICAgIG51bWJlciA9IG51bWJlci50cmltKCk7XG4gICAgICAgIGFzc2VydCgvXlswLTldKlxcLj9bMC05XSokLy50ZXN0KG51bWJlciksIFwiSW52YWxpZCBkZWNpbWFsIG51bWJlciBcIiArIG51bWJlcik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQgPSBudW1iZXIuc3BsaXQoXCIuXCIpLFxuICAgICAgICAgICAgX251bWJlciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbnVtYmVyJHNwbGl0LCAyKSxcbiAgICAgICAgICAgIF9udW1iZXIkc3BsaXQyJCA9IF9udW1iZXIkc3BsaXQyWzBdLFxuICAgICAgICAgICAgd2hvbGUgPSBfbnVtYmVyJHNwbGl0MiQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQsXG4gICAgICAgICAgICBfbnVtYmVyJHNwbGl0MiQyID0gX251bWJlciRzcGxpdDJbMV0sXG4gICAgICAgICAgICBkZWNpbWFsID0gX251bWJlciRzcGxpdDIkMiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDI7XG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwcmVjaXNpb24gLSBkZWNpbWFsLmxlbmd0aDtcbiAgICAgICAgYXNzZXJ0KHBhZGRpbmcgPj0gMCwgXCJUb28gbWFueSBkZWNpbWFsIGRpZ2l0cyBpbiBcIiArIG51bWJlciArIFwiIHRvIGNyZWF0ZSBhbiBpbXBsaWVkIGRlY2ltYWwgb2YgXCIgKyBwcmVjaXNpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGluZzsgaSsrKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFwiMFwiO1xuICAgICAgICB9d2hpbGUgKHdob2xlLmNoYXJBdCgwKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9cmV0dXJuIHdob2xlICsgZGVjaW1hbDtcbiAgICB9LFxuXG4gICAgZnJvbUltcGxpZWREZWNpbWFsOiBmdW5jdGlvbiBmcm9tSW1wbGllZERlY2ltYWwobnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGFzc2VydChudW1iZXIgPD0gOTAwNzE5OTI1NDc0MDk5MSwgXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICAgIG51bWJlciA9IFwiXCIgKyBudW1iZXI7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyLnRvU3RyaW5nKSBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKTtcblxuICAgICAgICB3aGlsZSAobnVtYmVyLmxlbmd0aCA8IHByZWNpc2lvbiArIDEpIHtcbiAgICAgICAgICAgIC8vIDAuMTIzXG4gICAgICAgICAgICBudW1iZXIgPSBcIjBcIiArIG51bWJlcjtcbiAgICAgICAgfSAvLyA0NDAwMCA9PiA0NC4wMDBcbiAgICAgICAgdmFyIGRlY19zdHJpbmcgPSBudW1iZXIuc3Vic3RyaW5nKG51bWJlci5sZW5ndGggLSBwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnN1YnN0cmluZygwLCBudW1iZXIubGVuZ3RoIC0gcHJlY2lzaW9uKSArIChkZWNfc3RyaW5nID8gXCIuXCIgKyBkZWNfc3RyaW5nIDogXCJcIik7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9udW1iZXJVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG52YXIgU2VyaWFsaXplckltcGwgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuXG52YXIgaW50MTYgPSB0eXBlcy5pbnQxNixcbiAgICB1aW50MTYgPSB0eXBlcy51aW50MTYsXG4gICAgdWludDMyID0gdHlwZXMudWludDMyLFxuICAgIGludDY0ID0gdHlwZXMuaW50NjQsXG4gICAgdWludDY0ID0gdHlwZXMudWludDY0LFxuICAgIHN0cmluZyA9IHR5cGVzLnN0cmluZyxcbiAgICBieXRlcyA9IHR5cGVzLmJ5dGVzLFxuICAgIGJvb2wgPSB0eXBlcy5ib29sLFxuICAgIGFycmF5ID0gdHlwZXMuYXJyYXksXG4gICAgZml4ZWRfYXJyYXkgPSB0eXBlcy5maXhlZF9hcnJheSxcbiAgICBvYmplY3RfaWRfdHlwZSA9IHR5cGVzLm9iamVjdF9pZF90eXBlLFxuICAgIHZvdGVfaWQgPSB0eXBlcy52b3RlX2lkLFxuICAgIHN0cmluZ19iaW5hcnkgPSB0eXBlcy5zdHJpbmdfYmluYXJ5LFxuICAgIGZ1dHVyZV9leHRlbnNpb25zID0gdHlwZXMuZnV0dXJlX2V4dGVuc2lvbnMsXG4gICAgaGFyZGZvcmtfdmVyc2lvbl92b3RlID0gdHlwZXMuaGFyZGZvcmtfdmVyc2lvbl92b3RlLFxuICAgIHZlcnNpb24gPSB0eXBlcy52ZXJzaW9uLFxuICAgIHN0YXRpY192YXJpYW50ID0gdHlwZXMuc3RhdGljX3ZhcmlhbnQsXG4gICAgbWFwID0gdHlwZXMubWFwLFxuICAgIHNldCA9IHR5cGVzLnNldCxcbiAgICBwdWJsaWNfa2V5ID0gdHlwZXMucHVibGljX2tleSxcbiAgICBhZGRyZXNzID0gdHlwZXMuYWRkcmVzcyxcbiAgICB0aW1lX3BvaW50X3NlYyA9IHR5cGVzLnRpbWVfcG9pbnRfc2VjLFxuICAgIG9wdGlvbmFsID0gdHlwZXMub3B0aW9uYWwsXG4gICAgYXNzZXQgPSB0eXBlcy5hc3NldDtcblxuZnV0dXJlX2V4dGVuc2lvbnMgPSB0eXBlcy52b2lkO1xuaGFyZGZvcmtfdmVyc2lvbl92b3RlID0gdHlwZXMudm9pZDtcbnZlcnNpb24gPSB0eXBlcy52b2lkO1xuXG4vLyBQbGFjZS1ob2xkZXIsIHRoZWlyIGFyZSBkZXBlbmRlbmNpZXMgb24gXCJvcGVyYXRpb25cIiAuLiBUaGUgZmluYWwgbGlzdCBvZlxuLy8gb3BlcmF0aW9ucyBpcyBub3QgYXZpYWxibGUgdW50aWwgdGhlIHZlcnkgZW5kIG9mIHRoZSBnZW5lcmF0ZWQgY29kZS5cbi8vIFNlZTogb3BlcmF0aW9uLnN0X29wZXJhdGlvbnMgPSAuLi5cbnZhciBvcGVyYXRpb24gPSBzdGF0aWNfdmFyaWFudCgpO1xubW9kdWxlLmV4cG9ydHNbXCJvcGVyYXRpb25cIl0gPSBvcGVyYXRpb247XG5cbi8vIEZvciBtb2R1bGUuZXhwb3J0c1xudmFyIFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiBTZXJpYWxpemVyKG9wZXJhdGlvbl9uYW1lLCBzZXJpbGl6YXRpb25fdHlwZXNfb2JqZWN0KSB7XG4gICAgdmFyIHMgPSBuZXcgU2VyaWFsaXplckltcGwob3BlcmF0aW9uX25hbWUsIHNlcmlsaXphdGlvbl90eXBlc19vYmplY3QpO1xuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1tvcGVyYXRpb25fbmFtZV0gPSBzO1xufTtcblxuLy8gQ3VzdG9tLXR5cGVzIGZvbGxvdyBHZW5lcmF0ZWQgY29kZTpcblxuLy8gIyMgIEdlbmVyYXRlZCBjb2RlIGZvbGxvd3Ncbi8vICMgbnBtIGkgLWcgZGVjYWZmZWluYXRlXG4vLyAjIHByb2dyYW1zL2pzX29wZXJhdGlvbl9zZXJpYWxpemVyID4gb3BzLmNvZmZlZSAmJiBkZWNhZmZlaW5hdGUgb3BzLmNvZmZlZVxuLy8gIyBvcGVuIG9wcy50eHQsIGNvcHkgdG8gQ2hhaW4vQ2hhaW5UeXBlcyBhbmQgb3BlcmF0aW9ucy5qc1xuLy8gIyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYmVuZWZpY2lhcmllcyA9IG5ldyBTZXJpYWxpemVyKFwiYmVuZWZpY2lhcmllc1wiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHdlaWdodDogdWludDE2XG59KTtcblxudmFyIGNvbW1lbnRfcGF5b3V0X2JlbmVmaWNpYXJpZXMgPSBuZXcgU2VyaWFsaXplcigwLCB7XG4gICAgYmVuZWZpY2lhcmllczogc2V0KGJlbmVmaWNpYXJpZXMpXG59KTtcblxudmFyIHNpZ25lZF90cmFuc2FjdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwic2lnbmVkX3RyYW5zYWN0aW9uXCIsIHtcbiAgICByZWZfYmxvY2tfbnVtOiB1aW50MTYsXG4gICAgcmVmX2Jsb2NrX3ByZWZpeDogdWludDMyLFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjLFxuICAgIG9wZXJhdGlvbnM6IGFycmF5KG9wZXJhdGlvbiksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKSxcbiAgICBzaWduYXR1cmVzOiBhcnJheShieXRlcyg2NSkpXG59KTtcblxudmFyIHNpZ25lZF9ibG9jayA9IG5ldyBTZXJpYWxpemVyKFwic2lnbmVkX2Jsb2NrXCIsIHtcbiAgICBwcmV2aW91czogYnl0ZXMoMjApLFxuICAgIHRpbWVzdGFtcDogdGltZV9wb2ludF9zZWMsXG4gICAgd2l0bmVzczogc3RyaW5nLFxuICAgIHRyYW5zYWN0aW9uX21lcmtsZV9yb290OiBieXRlcygyMCksXG4gICAgZXh0ZW5zaW9uczogc2V0KHN0YXRpY192YXJpYW50KFtmdXR1cmVfZXh0ZW5zaW9ucywgdmVyc2lvbiwgaGFyZGZvcmtfdmVyc2lvbl92b3RlXSkpLFxuICAgIHdpdG5lc3Nfc2lnbmF0dXJlOiBieXRlcyg2NSksXG4gICAgdHJhbnNhY3Rpb25zOiBhcnJheShzaWduZWRfdHJhbnNhY3Rpb24pXG59KTtcblxudmFyIGJsb2NrX2hlYWRlciA9IG5ldyBTZXJpYWxpemVyKFwiYmxvY2tfaGVhZGVyXCIsIHtcbiAgICBwcmV2aW91czogYnl0ZXMoMjApLFxuICAgIHRpbWVzdGFtcDogdGltZV9wb2ludF9zZWMsXG4gICAgd2l0bmVzczogc3RyaW5nLFxuICAgIHRyYW5zYWN0aW9uX21lcmtsZV9yb290OiBieXRlcygyMCksXG4gICAgZXh0ZW5zaW9uczogc2V0KHN0YXRpY192YXJpYW50KFtmdXR1cmVfZXh0ZW5zaW9ucywgdmVyc2lvbiwgaGFyZGZvcmtfdmVyc2lvbl92b3RlXSkpXG59KTtcblxudmFyIHNpZ25lZF9ibG9ja19oZWFkZXIgPSBuZXcgU2VyaWFsaXplcihcInNpZ25lZF9ibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2Z1dHVyZV9leHRlbnNpb25zLCB2ZXJzaW9uLCBoYXJkZm9ya192ZXJzaW9uX3ZvdGVdKSksXG4gICAgd2l0bmVzc19zaWduYXR1cmU6IGJ5dGVzKDY1KVxufSk7XG5cbnZhciB2b3RlID0gbmV3IFNlcmlhbGl6ZXIoXCJ2b3RlXCIsIHtcbiAgICB2b3Rlcjogc3RyaW5nLFxuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgd2VpZ2h0OiBpbnQxNlxufSk7XG5cbnZhciBjb21tZW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50XCIsIHtcbiAgICBwYXJlbnRfYXV0aG9yOiBzdHJpbmcsXG4gICAgcGFyZW50X3Blcm1saW5rOiBzdHJpbmcsXG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICB0aXRsZTogc3RyaW5nLFxuICAgIGJvZHk6IHN0cmluZyxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgdHJhbnNmZXIgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhbW91bnQ6IGFzc2V0LFxuICAgIG1lbW86IHN0cmluZ1xufSk7XG5cbnZhciB0cmFuc2Zlcl90b192ZXN0aW5nID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl90b192ZXN0aW5nXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhbW91bnQ6IGFzc2V0XG59KTtcblxudmFyIHdpdGhkcmF3X3Zlc3RpbmcgPSBuZXcgU2VyaWFsaXplcihcIndpdGhkcmF3X3Zlc3RpbmdcIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICB2ZXN0aW5nX3NoYXJlczogYXNzZXRcbn0pO1xuXG52YXIgbGltaXRfb3JkZXJfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJsaW1pdF9vcmRlcl9jcmVhdGVcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgb3JkZXJpZDogdWludDMyLFxuICAgIGFtb3VudF90b19zZWxsOiBhc3NldCxcbiAgICBtaW5fdG9fcmVjZWl2ZTogYXNzZXQsXG4gICAgZmlsbF9vcl9raWxsOiBib29sLFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjXG59KTtcblxudmFyIGxpbWl0X29yZGVyX2NhbmNlbCA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY2FuY2VsXCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIG9yZGVyaWQ6IHVpbnQzMlxufSk7XG5cbnZhciBwcmljZSA9IG5ldyBTZXJpYWxpemVyKFwicHJpY2VcIiwge1xuICAgIGJhc2U6IGFzc2V0LFxuICAgIHF1b3RlOiBhc3NldFxufSk7XG5cbnZhciBmZWVkX3B1Ymxpc2ggPSBuZXcgU2VyaWFsaXplcihcImZlZWRfcHVibGlzaFwiLCB7XG4gICAgcHVibGlzaGVyOiBzdHJpbmcsXG4gICAgZXhjaGFuZ2VfcmF0ZTogcHJpY2Vcbn0pO1xuXG52YXIgY29udmVydCA9IG5ldyBTZXJpYWxpemVyKFwiY29udmVydFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICByZXF1ZXN0aWQ6IHVpbnQzMixcbiAgICBhbW91bnQ6IGFzc2V0XG59KTtcblxudmFyIGF1dGhvcml0eSA9IG5ldyBTZXJpYWxpemVyKFwiYXV0aG9yaXR5XCIsIHtcbiAgICB3ZWlnaHRfdGhyZXNob2xkOiB1aW50MzIsXG4gICAgYWNjb3VudF9hdXRoczogbWFwKHN0cmluZywgdWludDE2KSxcbiAgICBrZXlfYXV0aHM6IG1hcChwdWJsaWNfa2V5LCB1aW50MTYpXG59KTtcblxudmFyIGFjY291bnRfY3JlYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X2NyZWF0ZVwiLCB7XG4gICAgZmVlOiBhc3NldCxcbiAgICBjcmVhdG9yOiBzdHJpbmcsXG4gICAgbmV3X2FjY291bnRfbmFtZTogc3RyaW5nLFxuICAgIG93bmVyOiBhdXRob3JpdHksXG4gICAgYWN0aXZlOiBhdXRob3JpdHksXG4gICAgcG9zdGluZzogYXV0aG9yaXR5LFxuICAgIG1lbW9fa2V5OiBwdWJsaWNfa2V5LFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG5cbnZhciBhY2NvdW50X3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICBvd25lcjogb3B0aW9uYWwoYXV0aG9yaXR5KSxcbiAgICBhY3RpdmU6IG9wdGlvbmFsKGF1dGhvcml0eSksXG4gICAgcG9zdGluZzogb3B0aW9uYWwoYXV0aG9yaXR5KSxcbiAgICBtZW1vX2tleTogcHVibGljX2tleSxcbiAgICBqc29uX21ldGFkYXRhOiBzdHJpbmdcbn0pO1xuXG52YXIgY2hhaW5fcHJvcGVydGllcyA9IG5ldyBTZXJpYWxpemVyKFwiY2hhaW5fcHJvcGVydGllc1wiLCB7XG4gICAgYWNjb3VudF9jcmVhdGlvbl9mZWU6IGFzc2V0LFxuICAgIG1heGltdW1fYmxvY2tfc2l6ZTogdWludDMyLFxuICAgIHNiZF9pbnRlcmVzdF9yYXRlOiB1aW50MTZcbn0pO1xuXG52YXIgd2l0bmVzc191cGRhdGUgPSBuZXcgU2VyaWFsaXplcihcIndpdG5lc3NfdXBkYXRlXCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGJsb2NrX3NpZ25pbmdfa2V5OiBwdWJsaWNfa2V5LFxuICAgIHByb3BzOiBjaGFpbl9wcm9wZXJ0aWVzLFxuICAgIGZlZTogYXNzZXRcbn0pO1xuXG52YXIgYWNjb3VudF93aXRuZXNzX3ZvdGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfd2l0bmVzc192b3RlXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgd2l0bmVzczogc3RyaW5nLFxuICAgIGFwcHJvdmU6IGJvb2xcbn0pO1xuXG52YXIgYWNjb3VudF93aXRuZXNzX3Byb3h5ID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3dpdG5lc3NfcHJveHlcIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICBwcm94eTogc3RyaW5nXG59KTtcblxudmFyIHBvdyA9IG5ldyBTZXJpYWxpemVyKFwicG93XCIsIHtcbiAgICB3b3JrZXI6IHB1YmxpY19rZXksXG4gICAgaW5wdXQ6IGJ5dGVzKDMyKSxcbiAgICBzaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgICB3b3JrOiBieXRlcygzMilcbn0pO1xuXG52YXIgY3VzdG9tID0gbmV3IFNlcmlhbGl6ZXIoXCJjdXN0b21cIiwge1xuICAgIHJlcXVpcmVkX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICBpZDogdWludDE2LFxuICAgIGRhdGE6IGJ5dGVzKClcbn0pO1xuXG52YXIgcmVwb3J0X292ZXJfcHJvZHVjdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwicmVwb3J0X292ZXJfcHJvZHVjdGlvblwiLCB7XG4gICAgcmVwb3J0ZXI6IHN0cmluZyxcbiAgICBmaXJzdF9ibG9jazogc2lnbmVkX2Jsb2NrX2hlYWRlcixcbiAgICBzZWNvbmRfYmxvY2s6IHNpZ25lZF9ibG9ja19oZWFkZXJcbn0pO1xuXG52YXIgZGVsZXRlX2NvbW1lbnQgPSBuZXcgU2VyaWFsaXplcihcImRlbGV0ZV9jb21tZW50XCIsIHtcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nXG59KTtcblxudmFyIGN1c3RvbV9qc29uID0gbmV3IFNlcmlhbGl6ZXIoXCJjdXN0b21fanNvblwiLCB7XG4gICAgcmVxdWlyZWRfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIHJlcXVpcmVkX3Bvc3RpbmdfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIGlkOiBzdHJpbmcsXG4gICAganNvbjogc3RyaW5nXG59KTtcblxudmFyIGNvbW1lbnRfb3B0aW9ucyA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9vcHRpb25zXCIsIHtcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIG1heF9hY2NlcHRlZF9wYXlvdXQ6IGFzc2V0LFxuICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogdWludDE2LFxuICAgIGFsbG93X3ZvdGVzOiBib29sLFxuICAgIGFsbG93X2N1cmF0aW9uX3Jld2FyZHM6IGJvb2wsXG4gICAgZXh0ZW5zaW9uczogc2V0KHN0YXRpY192YXJpYW50KFtjb21tZW50X3BheW91dF9iZW5lZmljaWFyaWVzXSkpXG59KTtcblxudmFyIHNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJzZXRfd2l0aGRyYXdfdmVzdGluZ19yb3V0ZVwiLCB7XG4gICAgZnJvbV9hY2NvdW50OiBzdHJpbmcsXG4gICAgdG9fYWNjb3VudDogc3RyaW5nLFxuICAgIHBlcmNlbnQ6IHVpbnQxNixcbiAgICBhdXRvX3Zlc3Q6IGJvb2xcbn0pO1xuXG52YXIgbGltaXRfb3JkZXJfY3JlYXRlMiA9IG5ldyBTZXJpYWxpemVyKFwibGltaXRfb3JkZXJfY3JlYXRlMlwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBvcmRlcmlkOiB1aW50MzIsXG4gICAgYW1vdW50X3RvX3NlbGw6IGFzc2V0LFxuICAgIGV4Y2hhbmdlX3JhdGU6IHByaWNlLFxuICAgIGZpbGxfb3Jfa2lsbDogYm9vbCxcbiAgICBleHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG5cbnZhciBjaGFsbGVuZ2VfYXV0aG9yaXR5ID0gbmV3IFNlcmlhbGl6ZXIoXCJjaGFsbGVuZ2VfYXV0aG9yaXR5XCIsIHtcbiAgICBjaGFsbGVuZ2VyOiBzdHJpbmcsXG4gICAgY2hhbGxlbmdlZDogc3RyaW5nLFxuICAgIHJlcXVpcmVfb3duZXI6IGJvb2xcbn0pO1xuXG52YXIgcHJvdmVfYXV0aG9yaXR5ID0gbmV3IFNlcmlhbGl6ZXIoXCJwcm92ZV9hdXRob3JpdHlcIiwge1xuICAgIGNoYWxsZW5nZWQ6IHN0cmluZyxcbiAgICByZXF1aXJlX293bmVyOiBib29sXG59KTtcblxudmFyIHJlcXVlc3RfYWNjb3VudF9yZWNvdmVyeSA9IG5ldyBTZXJpYWxpemVyKFwicmVxdWVzdF9hY2NvdW50X3JlY292ZXJ5XCIsIHtcbiAgICByZWNvdmVyeV9hY2NvdW50OiBzdHJpbmcsXG4gICAgYWNjb3VudF90b19yZWNvdmVyOiBzdHJpbmcsXG4gICAgbmV3X293bmVyX2F1dGhvcml0eTogYXV0aG9yaXR5LFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xuXG52YXIgcmVjb3Zlcl9hY2NvdW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJyZWNvdmVyX2FjY291bnRcIiwge1xuICAgIGFjY291bnRfdG9fcmVjb3Zlcjogc3RyaW5nLFxuICAgIG5ld19vd25lcl9hdXRob3JpdHk6IGF1dGhvcml0eSxcbiAgICByZWNlbnRfb3duZXJfYXV0aG9yaXR5OiBhdXRob3JpdHksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG5cbnZhciBjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwiY2hhbmdlX3JlY292ZXJ5X2FjY291bnRcIiwge1xuICAgIGFjY291bnRfdG9fcmVjb3Zlcjogc3RyaW5nLFxuICAgIG5ld19yZWNvdmVyeV9hY2NvdW50OiBzdHJpbmcsXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG5cbnZhciBlc2Nyb3dfdHJhbnNmZXIgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd190cmFuc2ZlclwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgc2JkX2Ftb3VudDogYXNzZXQsXG4gICAgc3RlZW1fYW1vdW50OiBhc3NldCxcbiAgICBlc2Nyb3dfaWQ6IHVpbnQzMixcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIGZlZTogYXNzZXQsXG4gICAganNvbl9tZXRhOiBzdHJpbmcsXG4gICAgcmF0aWZpY2F0aW9uX2RlYWRsaW5lOiB0aW1lX3BvaW50X3NlYyxcbiAgICBlc2Nyb3dfZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWNcbn0pO1xuXG52YXIgZXNjcm93X2Rpc3B1dGUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19kaXNwdXRlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyXG59KTtcblxudmFyIGVzY3Jvd19yZWxlYXNlID0gbmV3IFNlcmlhbGl6ZXIoXCJlc2Nyb3dfcmVsZWFzZVwiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYWdlbnQ6IHN0cmluZyxcbiAgICB3aG86IHN0cmluZyxcbiAgICByZWNlaXZlcjogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIHNiZF9hbW91bnQ6IGFzc2V0LFxuICAgIHN0ZWVtX2Ftb3VudDogYXNzZXRcbn0pO1xuXG52YXIgcG93Ml9pbnB1dCA9IG5ldyBTZXJpYWxpemVyKFwicG93Ml9pbnB1dFwiLCB7XG4gICAgd29ya2VyX2FjY291bnQ6IHN0cmluZyxcbiAgICBwcmV2X2Jsb2NrOiBieXRlcygyMCksXG4gICAgbm9uY2U6IHVpbnQ2NFxufSk7XG5cbnZhciBwb3cyID0gbmV3IFNlcmlhbGl6ZXIoXCJwb3cyXCIsIHtcbiAgICBpbnB1dDogcG93Ml9pbnB1dCxcbiAgICBwb3dfc3VtbWFyeTogdWludDMyXG59KTtcblxudmFyIGVxdWloYXNoX3Byb29mID0gbmV3IFNlcmlhbGl6ZXIoXCJlcXVpaGFzaF9wcm9vZlwiLCB7XG4gICAgbjogdWludDMyLFxuICAgIGs6IHVpbnQzMixcbiAgICBzZWVkOiBieXRlcygzMiksXG4gICAgaW5wdXRzOiBhcnJheSh1aW50MzIpXG59KTtcblxudmFyIGVxdWloYXNoX3BvdyA9IG5ldyBTZXJpYWxpemVyKFwiZXF1aWhhc2hfcG93XCIsIHtcbiAgICBpbnB1dDogcG93Ml9pbnB1dCxcbiAgICBwcm9vZjogZXF1aWhhc2hfcHJvb2YsXG4gICAgcHJldl9ibG9jazogYnl0ZXMoMjApLFxuICAgIHBvd19zdW1tYXJ5OiB1aW50MzJcbn0pO1xuXG52YXIgZXNjcm93X2FwcHJvdmUgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19hcHByb3ZlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIGFwcHJvdmU6IGJvb2xcbn0pO1xuXG52YXIgdHJhbnNmZXJfdG9fc2F2aW5ncyA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJfdG9fc2F2aW5nc1wiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHRvOiBzdHJpbmcsXG4gICAgYW1vdW50OiBhc3NldCxcbiAgICBtZW1vOiBzdHJpbmdcbn0pO1xuXG52YXIgdHJhbnNmZXJfZnJvbV9zYXZpbmdzID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl9mcm9tX3NhdmluZ3NcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICByZXF1ZXN0X2lkOiB1aW50MzIsXG4gICAgdG86IHN0cmluZyxcbiAgICBhbW91bnQ6IGFzc2V0LFxuICAgIG1lbW86IHN0cmluZ1xufSk7XG5cbnZhciBjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzID0gbmV3IFNlcmlhbGl6ZXIoXCJjYW5jZWxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgcmVxdWVzdF9pZDogdWludDMyXG59KTtcblxudmFyIGN1c3RvbV9iaW5hcnkgPSBuZXcgU2VyaWFsaXplcihcImN1c3RvbV9iaW5hcnlcIiwge1xuICAgIHJlcXVpcmVkX293bmVyX2F1dGhzOiBzZXQoc3RyaW5nKSxcbiAgICByZXF1aXJlZF9hY3RpdmVfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIHJlcXVpcmVkX3Bvc3RpbmdfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIHJlcXVpcmVkX2F1dGhzOiBhcnJheShhdXRob3JpdHkpLFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZGF0YTogYnl0ZXMoKVxufSk7XG5cbnZhciBkZWNsaW5lX3ZvdGluZ19yaWdodHMgPSBuZXcgU2VyaWFsaXplcihcImRlY2xpbmVfdm90aW5nX3JpZ2h0c1wiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIGRlY2xpbmU6IGJvb2xcbn0pO1xuXG52YXIgcmVzZXRfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwicmVzZXRfYWNjb3VudFwiLCB7XG4gICAgcmVzZXRfYWNjb3VudDogc3RyaW5nLFxuICAgIGFjY291bnRfdG9fcmVzZXQ6IHN0cmluZyxcbiAgICBuZXdfb3duZXJfYXV0aG9yaXR5OiBhdXRob3JpdHlcbn0pO1xuXG52YXIgc2V0X3Jlc2V0X2FjY291bnQgPSBuZXcgU2VyaWFsaXplcihcInNldF9yZXNldF9hY2NvdW50XCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgY3VycmVudF9yZXNldF9hY2NvdW50OiBzdHJpbmcsXG4gICAgcmVzZXRfYWNjb3VudDogc3RyaW5nXG59KTtcblxudmFyIGNsYWltX3Jld2FyZF9iYWxhbmNlID0gbmV3IFNlcmlhbGl6ZXIoXCJjbGFpbV9yZXdhcmRfYmFsYW5jZVwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHJld2FyZF9zdGVlbTogYXNzZXQsXG4gICAgcmV3YXJkX3NiZDogYXNzZXQsXG4gICAgcmV3YXJkX3Zlc3RzOiBhc3NldFxufSk7XG5cbnZhciBkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlcyA9IG5ldyBTZXJpYWxpemVyKFwiZGVsZWdhdGVfdmVzdGluZ19zaGFyZXNcIiwge1xuICAgIGRlbGVnYXRvcjogc3RyaW5nLFxuICAgIGRlbGVnYXRlZTogc3RyaW5nLFxuICAgIHZlc3Rpbmdfc2hhcmVzOiBhc3NldFxufSk7XG5cbnZhciBhY2NvdW50X2NyZWF0ZV93aXRoX2RlbGVnYXRpb24gPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfY3JlYXRlX3dpdGhfZGVsZWdhdGlvblwiLCB7XG4gICAgZmVlOiBhc3NldCxcbiAgICBkZWxlZ2F0aW9uOiBhc3NldCxcbiAgICBjcmVhdG9yOiBzdHJpbmcsXG4gICAgbmV3X2FjY291bnRfbmFtZTogc3RyaW5nLFxuICAgIG93bmVyOiBhdXRob3JpdHksXG4gICAgYWN0aXZlOiBhdXRob3JpdHksXG4gICAgcG9zdGluZzogYXV0aG9yaXR5LFxuICAgIG1lbW9fa2V5OiBwdWJsaWNfa2V5LFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZyxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxudmFyIGZpbGxfY29udmVydF9yZXF1ZXN0ID0gbmV3IFNlcmlhbGl6ZXIoXCJmaWxsX2NvbnZlcnRfcmVxdWVzdFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICByZXF1ZXN0aWQ6IHVpbnQzMixcbiAgICBhbW91bnRfaW46IGFzc2V0LFxuICAgIGFtb3VudF9vdXQ6IGFzc2V0XG59KTtcblxudmFyIGF1dGhvcl9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImF1dGhvcl9yZXdhcmRcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgc2JkX3BheW91dDogYXNzZXQsXG4gICAgc3RlZW1fcGF5b3V0OiBhc3NldCxcbiAgICB2ZXN0aW5nX3BheW91dDogYXNzZXRcbn0pO1xuXG52YXIgY3VyYXRpb25fcmV3YXJkID0gbmV3IFNlcmlhbGl6ZXIoXCJjdXJhdGlvbl9yZXdhcmRcIiwge1xuICAgIGN1cmF0b3I6IHN0cmluZyxcbiAgICByZXdhcmQ6IGFzc2V0LFxuICAgIGNvbW1lbnRfYXV0aG9yOiBzdHJpbmcsXG4gICAgY29tbWVudF9wZXJtbGluazogc3RyaW5nXG59KTtcblxudmFyIGNvbW1lbnRfcmV3YXJkID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X3Jld2FyZFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBwYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGxpcXVpZGl0eV9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImxpcXVpZGl0eV9yZXdhcmRcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgcGF5b3V0OiBhc3NldFxufSk7XG5cbnZhciBpbnRlcmVzdCA9IG5ldyBTZXJpYWxpemVyKFwiaW50ZXJlc3RcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgaW50ZXJlc3Q6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfdmVzdGluZ193aXRoZHJhdyA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF92ZXN0aW5nX3dpdGhkcmF3XCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgd2l0aGRyYXduOiBhc3NldCxcbiAgICBkZXBvc2l0ZWQ6IGFzc2V0XG59KTtcblxudmFyIGZpbGxfb3JkZXIgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfb3JkZXJcIiwge1xuICAgIGN1cnJlbnRfb3duZXI6IHN0cmluZyxcbiAgICBjdXJyZW50X29yZGVyaWQ6IHVpbnQzMixcbiAgICBjdXJyZW50X3BheXM6IGFzc2V0LFxuICAgIG9wZW5fb3duZXI6IHN0cmluZyxcbiAgICBvcGVuX29yZGVyaWQ6IHVpbnQzMixcbiAgICBvcGVuX3BheXM6IGFzc2V0XG59KTtcblxudmFyIHNodXRkb3duX3dpdG5lc3MgPSBuZXcgU2VyaWFsaXplcihcInNodXRkb3duX3dpdG5lc3NcIiwgeyBvd25lcjogc3RyaW5nIH0pO1xuXG52YXIgZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfdHJhbnNmZXJfZnJvbV9zYXZpbmdzXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhbW91bnQ6IGFzc2V0LFxuICAgIHJlcXVlc3RfaWQ6IHVpbnQzMixcbiAgICBtZW1vOiBzdHJpbmdcbn0pO1xuXG52YXIgaGFyZGZvcmsgPSBuZXcgU2VyaWFsaXplcihcImhhcmRmb3JrXCIsIHsgaGFyZGZvcmtfaWQ6IHVpbnQzMiB9KTtcblxudmFyIGNvbW1lbnRfcGF5b3V0X3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9wYXlvdXRfdXBkYXRlXCIsIHtcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nXG59KTtcblxudmFyIHJldHVybl92ZXN0aW5nX2RlbGVnYXRpb24gPSBuZXcgU2VyaWFsaXplcihcInJldHVybl92ZXN0aW5nX2RlbGVnYXRpb25cIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICB2ZXN0aW5nX3NoYXJlczogYXNzZXRcbn0pO1xuXG52YXIgY29tbWVudF9iZW5lZmFjdG9yX3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwiY29tbWVudF9iZW5lZmFjdG9yX3Jld2FyZFwiLCB7XG4gICAgYmVuZWZhY3Rvcjogc3RyaW5nLFxuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgcmV3YXJkOiBhc3NldFxufSk7XG5cbm9wZXJhdGlvbi5zdF9vcGVyYXRpb25zID0gW3ZvdGUsIGNvbW1lbnQsIHRyYW5zZmVyLCB0cmFuc2Zlcl90b192ZXN0aW5nLCB3aXRoZHJhd192ZXN0aW5nLCBsaW1pdF9vcmRlcl9jcmVhdGUsIGxpbWl0X29yZGVyX2NhbmNlbCwgZmVlZF9wdWJsaXNoLCBjb252ZXJ0LCBhY2NvdW50X2NyZWF0ZSwgYWNjb3VudF91cGRhdGUsIHdpdG5lc3NfdXBkYXRlLCBhY2NvdW50X3dpdG5lc3Nfdm90ZSwgYWNjb3VudF93aXRuZXNzX3Byb3h5LCBwb3csIGN1c3RvbSwgcmVwb3J0X292ZXJfcHJvZHVjdGlvbiwgZGVsZXRlX2NvbW1lbnQsIGN1c3RvbV9qc29uLCBjb21tZW50X29wdGlvbnMsIHNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlLCBsaW1pdF9vcmRlcl9jcmVhdGUyLCBjaGFsbGVuZ2VfYXV0aG9yaXR5LCBwcm92ZV9hdXRob3JpdHksIHJlcXVlc3RfYWNjb3VudF9yZWNvdmVyeSwgcmVjb3Zlcl9hY2NvdW50LCBjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudCwgZXNjcm93X3RyYW5zZmVyLCBlc2Nyb3dfZGlzcHV0ZSwgZXNjcm93X3JlbGVhc2UsIHBvdzIsIGVzY3Jvd19hcHByb3ZlLCB0cmFuc2Zlcl90b19zYXZpbmdzLCB0cmFuc2Zlcl9mcm9tX3NhdmluZ3MsIGNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MsIGN1c3RvbV9iaW5hcnksIGRlY2xpbmVfdm90aW5nX3JpZ2h0cywgcmVzZXRfYWNjb3VudCwgc2V0X3Jlc2V0X2FjY291bnQsIGNsYWltX3Jld2FyZF9iYWxhbmNlLCBkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlcywgYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uLCBmaWxsX2NvbnZlcnRfcmVxdWVzdCwgYXV0aG9yX3Jld2FyZCwgY3VyYXRpb25fcmV3YXJkLCBjb21tZW50X3Jld2FyZCwgbGlxdWlkaXR5X3Jld2FyZCwgaW50ZXJlc3QsIGZpbGxfdmVzdGluZ193aXRoZHJhdywgZmlsbF9vcmRlciwgc2h1dGRvd25fd2l0bmVzcywgZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MsIGhhcmRmb3JrLCBjb21tZW50X3BheW91dF91cGRhdGUsIHJldHVybl92ZXN0aW5nX2RlbGVnYXRpb24sIGNvbW1lbnRfYmVuZWZhY3Rvcl9yZXdhcmRdO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgU2VyaWFsaXplcihcInRyYW5zYWN0aW9uXCIsIHtcbiAgICByZWZfYmxvY2tfbnVtOiB1aW50MTYsXG4gICAgcmVmX2Jsb2NrX3ByZWZpeDogdWludDMyLFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjLFxuICAgIG9wZXJhdGlvbnM6IGFycmF5KG9wZXJhdGlvbiksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG5cbi8vIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyMgIEdlbmVyYXRlZCBjb2RlIGVuZCAgUyBUIE8gUFxuLy8jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQ3VzdG9tIFR5cGVzIChkbyBub3Qgb3Zlci13cml0ZSlcblxudmFyIGVuY3J5cHRlZF9tZW1vID0gbmV3IFNlcmlhbGl6ZXIoXCJlbmNyeXB0ZWRfbWVtb1wiLCB7IGZyb206IHB1YmxpY19rZXksXG4gICAgdG86IHB1YmxpY19rZXksXG4gICAgbm9uY2U6IHVpbnQ2NCxcbiAgICBjaGVjazogdWludDMyLFxuICAgIGVuY3J5cHRlZDogc3RyaW5nX2JpbmFyeSB9KTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9vcGVyYXRpb25zLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ5dGVCdWZmZXIgPSByZXF1aXJlKCdieXRlYnVmZmVyJyk7XG52YXIgRUMgPSByZXF1aXJlKCcuL2Vycm9yX3dpdGhfY2F1c2UnKTtcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxudmFyIFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplcihvcGVyYXRpb25fbmFtZSwgdHlwZXMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcmlhbGl6ZXIpO1xuXG4gICAgICAgIHRoaXMub3BlcmF0aW9uX25hbWUgPSBvcGVyYXRpb25fbmFtZTtcbiAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgICAgICBpZiAodGhpcy50eXBlcykgdGhpcy5rZXlzID0gT2JqZWN0LmtleXModGhpcy50eXBlcyk7XG5cbiAgICAgICAgU2VyaWFsaXplci5wcmludERlYnVnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2VyaWFsaXplciwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5vcGVyYXRpb25fbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHR5cGUub3BlcmF0aW9uX25hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMSA9IGIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzIgPSBiLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5vZmZzZXQgPSBvMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iLnJlc2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gYi5jb3B5KG8xLCBvMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJ1xcdCcsIF9iLnRvSGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFtmaWVsZF0gPSB0eXBlLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2VyaWFsaXplci5wcmludERlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyAnICsgdGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkICsgJyBpbiBkYXRhOicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIucHJpbnREZWJ1ZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FwcGVuZEJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB0eXBlLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0W2ZpZWxkXSksIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZlxuICAgICAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyBcIiA9IFwiICsgb2JqZWN0W2ZpZWxkXSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbU9iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tT2JqZWN0KHNlcmlhbGl6ZWRfb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAvL0RFQlVHIHZhbHVlID0gdmFsdWUucmVzb2x2ZSBpZiB2YWx1ZS5yZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiB2YWx1ZScsZmllbGQsdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB0eXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbZmllbGRdID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgRUMudGhyb3codGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy51c2VfZGVmYXVsdCA9IGZhbHNlXSAtIG1vcmUgdGVtcGxhdGUgZnJpZW5kbHlcbiAgICAgICAgICAgIEBhcmcge2Jvb2xlYW59IFtkZWJ1Zy5hbm5vdGF0ZSA9IGZhbHNlXSAtIGFkZCB1c2VyLWZyaWVuZGx5IGluZm9ybWF0aW9uXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRfb2JqZWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyB1c2VfZGVmYXVsdDogZmFsc2UsIGFubm90YXRlOiBmYWxzZSB9O1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZXMpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHR5cGUudG9PYmplY3QodHlwZW9mIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBudWxsID8gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdIDogdW5kZWZpbmVkLCBkZWJ1Zyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzX3ZhbHVlID0gdHlwZW9mIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIHNlcmlhbGl6ZWRfb2JqZWN0ICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc192YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlcmlhbGl6ZWRfb2JqZWN0W2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodGhpcy5vcGVyYXRpb25fbmFtZSArICcuJyArIGZpZWxkLCBiLnRvSGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBTb3J0IGJ5IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgb3BlcmF0aW9uICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBhcmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdF9rZXkgPSB0aGlzLmtleXNbMF07XG4gICAgICAgICAgICB2YXIgZmlyc3RfdHlwZSA9IHRoaXMudHlwZXNbZmlyc3Rfa2V5XTtcblxuICAgICAgICAgICAgdmFyIHZhbEEgPSBhW2ZpcnN0X2tleV07XG4gICAgICAgICAgICB2YXIgdmFsQiA9IGJbZmlyc3Rfa2V5XTtcblxuICAgICAgICAgICAgaWYgKGZpcnN0X3R5cGUuY29tcGFyZSkgcmV0dXJuIGZpcnN0X3R5cGUuY29tcGFyZSh2YWxBLCB2YWxCKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWxBID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWxCID09PSBcIm51bWJlclwiKSByZXR1cm4gdmFsQSAtIHZhbEI7XG5cbiAgICAgICAgICAgIHZhciBlbmNvZGluZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsQSkgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbEIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBiaW5hcnkgc3RyaW5nIGNvbXBhcmUgZG9lcyBub3Qgd29yay4gIElmIGxvY2FsZUNvbXBhcmUgaXMgd2VsbCBzdXBwb3J0ZWQgdGhhdCBjb3VsZCByZXBsYWNlIEhFWC4gIFBlcmZvcm1hbmFuY2UgaXMgdmVyeSBnb29kIHNvIGNvbXBhcmluZyBIRVggd29ya3MuXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBcImhleFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RyQSA9IHZhbEEudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgdmFyIHN0ckIgPSB2YWxCLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJBID4gc3RyQiA/IDEgOiBzdHJBIDwgc3RyQiA/IC0xIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDxoZWxwZXJfZnVuY3Rpb25zPlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICB2YXIgYiA9IEJ5dGVCdWZmZXIuZnJvbUhleChoZXgsIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBCeXRlQnVmZmVyLmZyb21CaW5hcnkoYnVmZmVyLnRvU3RyaW5nKFwiYmluYXJ5XCIpLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4KG9iamVjdCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMudG9CdWZmZXIob2JqZWN0KS50b1N0cmluZyhcImhleFwiKVxuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLnRvQnl0ZUJ1ZmZlcihvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIGIudG9IZXgoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcihvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gYi5jb3B5KDAsIGIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLnRvQnl0ZUJ1ZmZlcihvYmplY3QpLnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTZXJpYWxpemVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcmlhbGl6ZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvc2VyaWFsaXplci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqIENvbnNvbGUgcHJpbnQgYW55IHRyYW5zYWN0aW9uIG9iamVjdCB3aXRoIHplcm8gZGVmYXVsdCB2YWx1ZXMuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRlbXBsYXRlKG9wKSB7XG5cbiAgICB2YXIgb2JqZWN0ID0gb3AudG9PYmplY3Qodm9pZCAwLCB7IHVzZV9kZWZhdWx0OiB0cnVlLCBhbm5vdGF0ZTogdHJ1ZSB9KTtcblxuICAgIC8vIHZpc3VhbCAod2l0aCBkZXNjcmlwdGlvbnMpXG4gICAgY29uc29sZS5lcnJvcihKU09OLnN0cmluZ2lmeShvYmplY3QsIG51bGwsIDQpKTtcblxuICAgIC8vIHVzYWJsZSBpbiBhIGNvcHktcGFzdGVcblxuICAgIG9iamVjdCA9IG9wLnRvT2JqZWN0KHZvaWQgMCwgeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IGZhbHNlIH0pO1xuXG4gICAgLy8gY29weS1wYXN0ZSBvbmUtbGluZWVyXG4gICAgY29uc29sZS5lcnJvcihKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvdGVtcGxhdGUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLy8gTG93LWxldmVsIHR5cGVzIHRoYXQgbWFrZSB1cCBvcGVyYXRpb25zXG5cbnZhciB2ID0gcmVxdWlyZSgnLi9TZXJpYWxpemVyVmFsaWRhdGlvbicpO1xudmFyIGZwID0gcmVxdWlyZSgnLi9GYXN0UGFyc2VyJyk7XG5cbnZhciBDaGFpblR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpblR5cGVzXCIpO1xudmFyIE9iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9PYmplY3RJZFwiKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uLy4uL2VjY1wiKSxcbiAgICBQdWJsaWNLZXkgPSBfcmVxdWlyZS5QdWJsaWNLZXksXG4gICAgQWRkcmVzcyA9IF9yZXF1aXJlLkFkZHJlc3M7XG5cbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9udW1iZXJVdGlsc1wiKSxcbiAgICBmcm9tSW1wbGllZERlY2ltYWwgPSBfcmVxdWlyZTIuZnJvbUltcGxpZWREZWNpbWFsO1xuXG52YXIgVHlwZXMgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gVHlwZXM7XG5cbnZhciBIRVhfRFVNUCA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfX2dyYXBoZW5lX3NlcmlhbGl6ZXJfaGV4X2R1bXA7XG5cbi8qKlxuKiBBc3NldCBzeW1ib2xzIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvblxuKlxuKiAgNCBiaXQgUFJFQ0lTSU9OXG4qICA0IGJpdCBSRVNFUlZFRFxuKiAgQ0hBUls2XSB1cCB0byA2IHVwcGVyIGNhc2UgYWxwaGEgbnVtZXJpYyBhc2NpaSBjaGFyYWN0ZXJzLFxuKiAgY2hhciA9IFxcMCAgbnVsbCB0ZXJtaW5hdGVkXG4qXG4qICBJdCBpcyB0cmVhdGVkIGFzIGEgdWludDY0X3QgZm9yIGFsbCBpbnRlcm5hbCBvcGVyYXRpb25zLCBidXRcbiogIGlzIGVhc2lseSBjb252ZXJ0ZWQgdG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIGRpc3BsYXllZC5cbiovXG5UeXBlcy5hc3NldCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICB2YXIgYW1vdW50ID0gYi5yZWFkSW50NjQoKTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IGIucmVhZFVpbnQ4KCk7XG4gICAgICAgIHZhciBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgNyk7XG4gICAgICAgIHZhciBzeW1ib2wgPSBuZXcgQnVmZmVyKGJfY29weS50b0JpbmFyeSgpLCBcImJpbmFyeVwiKS50b1N0cmluZygpLnJlcGxhY2UoL1xceDAwL2csIFwiXCIpO1xuICAgICAgICBiLnNraXAoNyk7XG4gICAgICAgIC8vIFwiMS4wMDAgU1RFRU1cIiBhbHdheXMgd3JpdHRlbiB3aXRoIGZ1bGwgcHJlY2lzaW9uXG4gICAgICAgIHZhciBhbW91bnRfc3RyaW5nID0gZnJvbUltcGxpZWREZWNpbWFsKGFtb3VudCwgcHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIGFtb3VudF9zdHJpbmcgKyBcIiBcIiArIHN5bWJvbDtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdC50cmltKCk7XG4gICAgICAgIGlmICghL15bMC05XStcXC4/WzAtOV0qIFtBLVphLXowLTldKyQvLnRlc3Qob2JqZWN0KSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIGFtb3VudCBsaWtlICc5OS4wMDAgU1lNQk9MJywgaW5zdGVhZCBnb3QgJ1wiICsgb2JqZWN0ICsgXCInXCIpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0ID0gb2JqZWN0LnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICAgIF9vYmplY3Qkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX29iamVjdCRzcGxpdCwgMiksXG4gICAgICAgICAgICBhbW91bnQgPSBfb2JqZWN0JHNwbGl0MlswXSxcbiAgICAgICAgICAgIHN5bWJvbCA9IF9vYmplY3Qkc3BsaXQyWzFdO1xuXG4gICAgICAgIGlmIChzeW1ib2wubGVuZ3RoID4gNikgdGhyb3cgbmV3IEVycm9yKFwiU3ltYm9scyBhcmUgbm90IGxvbmdlciB0aGFuIDYgY2hhcmFjdGVycyBcIiArIHN5bWJvbCArIFwiLVwiICsgc3ltYm9sLmxlbmd0aCk7XG5cbiAgICAgICAgYi53cml0ZUludDY0KHYudG9fbG9uZyhhbW91bnQucmVwbGFjZShcIi5cIiwgXCJcIikpKTtcbiAgICAgICAgdmFyIGRvdCA9IGFtb3VudC5pbmRleE9mKFwiLlwiKTsgLy8gMC4wMDBcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IGRvdCA9PT0gLTEgPyAwIDogYW1vdW50Lmxlbmd0aCAtIGRvdCAtIDE7XG4gICAgICAgIGIud3JpdGVVaW50OChwcmVjaXNpb24pO1xuICAgICAgICBiLmFwcGVuZChzeW1ib2wudG9VcHBlckNhc2UoKSwgJ2JpbmFyeScpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDcgLSBzeW1ib2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGIud3JpdGVVaW50OCgwKTtcbiAgICAgICAgfXJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjAwMCBTVEVFTVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxufTtcblxuVHlwZXMudWludDggPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCAndWludDggJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50OChvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCAndWludDggJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRiwgb2JqZWN0LCAndWludDggJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQxNiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDE2KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVVaW50MTYob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCAndWludDE2ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRiwgb2JqZWN0LCAndWludDE2ICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG5UeXBlcy51aW50MzIgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQzMigpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgYi53cml0ZVVpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxudmFyIE1JTl9TSUdORURfMzIgPSAtMSAqIE1hdGgucG93KDIsIDMxKTtcbnZhciBNQVhfU0lHTkVEXzMyID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcblxuVHlwZXMudmFyaW50MzIgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFZhcmludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKE1JTl9TSUdORURfMzIsIE1BWF9TSUdORURfMzIsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLmludDE2ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRJbnQxNigpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgYi53cml0ZUludDE2KG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG5UeXBlcy5pbnQ2NCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkSW50NjQoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgYi53cml0ZUludDY0KHYudG9fbG9uZyhvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy51aW50NjQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ2NCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgYi53cml0ZVVpbnQ2NCh2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcodi51bnNpZ25lZChvYmplY3QpKTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi50b19sb25nKG9iamVjdCkudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy5zdHJpbmcgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYi5yZWFkVlN0cmluZygpLCAndXRmOCcpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBiLndyaXRlVlN0cmluZyhvYmplY3QudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIob2JqZWN0LCAndXRmOCcpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygndXRmOCcpO1xuICAgIH1cbn07XG5cblR5cGVzLnN0cmluZ19iaW5hcnkgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIGJfY29weTtcbiAgICAgICAgdmFyIGxlbiA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBsZW4pLCBiLnNraXAobGVuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgYi5hcHBlbmQob2JqZWN0LnRvU3RyaW5nKCdiaW5hcnknKSwgJ2JpbmFyeScpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfVxufTtcblxuVHlwZXMuYnl0ZXMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJfY29weTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKSwgYi5za2lwKGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIHNpemUpLCBiLnNraXAoc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBuZXcgQnVmZmVyKG9iamVjdCwgXCJoZXhcIik7XG5cbiAgICAgICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLmFwcGVuZChvYmplY3QudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKG9iamVjdCwgJ2hleCcpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgemVyb3MgPSBmdW5jdGlvbiB6ZXJvcyhudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShudW0pLmpvaW4oXCIwMFwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvcyhzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLmJvb2wgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZFVpbnQ4KCkgPT09IDE7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAvLyBzdXBwb3J0cyBib29sZWFuIG9yIGludGVnZXJcbiAgICAgICAgYi53cml0ZVVpbnQ4KEpTT04ucGFyc2Uob2JqZWN0KSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uob2JqZWN0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbn07XG5cblR5cGVzLnZvaWQgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiKHZvaWQpIHVuZGVmaW5lZCB0eXBlXCIpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfVxufTtcblxuVHlwZXMuYXJyYXkgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBzaXplID8gaSA8IHNpemUgOiBpID4gc2l6ZTsgMCA8IHNpemUgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24ocmVzdWx0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgb2JqZWN0ID0gc29ydE9wZXJhdGlvbihvYmplY3QsIHN0X29wZXJhdGlvbik7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N0X29wZXJhdGlvbi50b09iamVjdChvYmplY3QsIGRlYnVnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy50aW1lX3BvaW50X3NlYyA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gXCJudW1iZXJcIikgb2JqZWN0ID0gVHlwZXMudGltZV9wb2ludF9zZWMuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIGIud3JpdGVVaW50MzIob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcIm51bWJlclwiKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgIGlmIChvYmplY3QuZ2V0VGltZSkgcmV0dXJuIE1hdGguZmxvb3Iob2JqZWN0LmdldFRpbWUoKSAvIDEwMDApO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGUgdHlwZTogXCIgKyBvYmplY3QpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiICYmICEvWiQvLnRlc3Qob2JqZWN0KSkgb2JqZWN0ID0gb2JqZWN0ICsgXCJaXCI7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobmV3IERhdGUob2JqZWN0KS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHJldHVybiBuZXcgRGF0ZSgwKS50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgICAgIGlmIChvYmplY3QuZ2V0VGltZSkgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgdmFyIGludCA9IHBhcnNlSW50KG9iamVjdCk7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkZGRkZGLCBpbnQsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShpbnQgKiAxMDAwKS50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF07XG4gICAgfVxufTtcblxuVHlwZXMuc2V0ID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShhcnJheSkge1xuICAgICAgICAgICAgdmFyIGR1cF9tYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICBpZiAocmVmID0gdHlwZW9mIG8gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG8pLCBbJ3N0cmluZycsICdudW1iZXInXS5pbmRleE9mKHJlZikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHVwX21hcFtvXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkdXBsaWNhdGUgKHNldClcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZHVwX21hcFtvXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRPcGVyYXRpb24oYXJyYXksIHN0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICBpZiAoSEVYX0RVTVApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInZhcmludDMyIHNpemUgPSBcIiArIHNpemUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBzaXplID8gaSA8IHNpemUgOiBpID4gc2l6ZTsgMCA8IHNpemUgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy52YWxpZGF0ZShvYmplY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvLCBkZWJ1ZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBnbG9iYWxfcGFyYW1ldGVyc191cGRhdGVfb3BlcmF0aW9uIGN1cnJlbnRfZmVlc1xuVHlwZXMuZml4ZWRfYXJyYXkgPSBmdW5jdGlvbiAoY291bnQsIHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihyZXN1bHRzLCBzdF9vcGVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGksIGosIHJlZjtcbiAgICAgICAgICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmLCByZXN1bHRzO1xuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9iamVjdFtpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QsIGRlYnVnKSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgaywgcmVmLCByZWYxLCByZXN1bHRzLCByZXN1bHRzMTtcbiAgICAgICAgICAgIGlmIChkZWJ1ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVidWcgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdCh2b2lkIDAsIGRlYnVnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gY291bnQ7IGsgPCByZWYxOyBpID0gayArPSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czEucHVzaChzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0W2ldLCBkZWJ1ZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qIFN1cHBvcnRzIGluc3RhbmNlIG51bWJlcnMgKDExKSBvciBvYmplY3QgdHlwZXMgKDEuMi4xMSkuICBPYmplY3QgdHlwZVxudmFsaWRhdGlvbiBpcyBlbmZvcmNlZCB3aGVuIGFuIG9iamVjdCB0eXBlIGlzIHVzZWQuICovXG52YXIgaWRfdHlwZSA9IGZ1bmN0aW9uIGlkX3R5cGUocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSkge1xuICAgIHYucmVxdWlyZWQocmVzZXJ2ZWRfc3BhY2VzLCBcInJlc2VydmVkX3NwYWNlc1wiKTtcbiAgICB2LnJlcXVpcmVkKG9iamVjdF90eXBlLCBcIm9iamVjdF90eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb252ZXJ0IDEuMi5uIGludG8ganVzdCBuXG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKHYudG9fbnVtYmVyKG9iamVjdCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2LmlzX2RpZ2l0cyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYudG9fbnVtYmVyKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdi5nZXRfaW5zdGFuY2UocmVzZXJ2ZWRfc3BhY2VzLCBvYmplY3RfdHlwZSwgb2JqZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIG9iamVjdF90eXBlX2lkID0gY2hhaW5fdHlwZXMub2JqZWN0X3R5cGVbb2JqZWN0X3R5cGVdO1xuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc2VydmVkX3NwYWNlcyArICcuJyArIG9iamVjdF90eXBlX2lkICsgJy4wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL15bMC05XStcXC5bMC05XStcXC5bMC05XSskLy50ZXN0KG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGVfaWQgKyAnLicgKyBvYmplY3Q7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMucHJvdG9jb2xfaWRfdHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdi5yZXF1aXJlZChuYW1lLCBcIm5hbWVcIik7XG4gICAgcmV0dXJuIGlkX3R5cGUoY2hhaW5fdHlwZXMucmVzZXJ2ZWRfc3BhY2VzLnByb3RvY29sX2lkcywgbmFtZSk7XG59O1xuXG5UeXBlcy5vYmplY3RfaWRfdHlwZSA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0SWQuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3RJZC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5hcHBlbmRCeXRlQnVmZmVyKGIpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0SWQuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMC4wLjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3RJZC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy52b3RlX2lkID0geyBUWVBFOiAweDAwMDAwMEZGLFxuICAgIElEOiAweEZGRkZGRjAwLFxuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGIucmVhZFVpbnQzMigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUgJiB0aGlzLlRZUEUsXG4gICAgICAgICAgICBpZDogdmFsdWUgJiB0aGlzLklEXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT09IFwic3RyaW5nXCIpIG9iamVjdCA9IFR5cGVzLnZvdGVfaWQuZnJvbU9iamVjdChvYmplY3QpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5pZCA8PCA4IHwgb2JqZWN0LnR5cGU7XG4gICAgICAgIGIud3JpdGVVaW50MzIodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCwgXCIodHlwZSB2b3RlX2lkKVwiKTtcbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QudHlwZSwgXCJ0eXBlXCIpO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QuaWQsIFwiaWRcIik7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZV90ZXN0KC9eWzAtOV0rOlswLTldKyQvLCBvYmplY3QsICd2b3RlX2lkIGZvcm1hdCAnICsgb2JqZWN0KTtcblxuICAgICAgICB2YXIgX29iamVjdCRzcGxpdDMgPSBvYmplY3Quc3BsaXQoJzonKSxcbiAgICAgICAgICAgIF9vYmplY3Qkc3BsaXQ0ID0gX3NsaWNlZFRvQXJyYXkoX29iamVjdCRzcGxpdDMsIDIpLFxuICAgICAgICAgICAgdHlwZSA9IF9vYmplY3Qkc3BsaXQ0WzBdLFxuICAgICAgICAgICAgaWQgPSBfb2JqZWN0JHNwbGl0NFsxXTtcblxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZiwgdHlwZSwgJ3ZvdGUgdHlwZSAnICsgb2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4ZmZmZmZmLCBpZCwgJ3ZvdGUgaWQgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGlkOiBpZCB9O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMDowXCI7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdC50eXBlICsgXCI6XCIgKyBvYmplY3QuaWQ7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpICE9PSBcIm9iamVjdFwiKSBhID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KGEpO1xuICAgICAgICBpZiAoKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKSkgIT09IFwib2JqZWN0XCIpIGIgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3QoYik7XG4gICAgICAgIHJldHVybiBwYXJzZUludChhLmlkKSAtIHBhcnNlSW50KGIuaWQpO1xuICAgIH1cbn07XG5cblR5cGVzLm9wdGlvbmFsID0gZnVuY3Rpb24gKHN0X29wZXJhdGlvbikge1xuICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCBcInN0X29wZXJhdGlvblwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgaWYgKCEoYi5yZWFkVWludDgoKSA9PT0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMSk7XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICAvLyB0b09iamVjdCBpcyBvbmx5IG51bGwgc2F2ZSBpZiB1c2VfZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgICAgICB2YXIgcmVzdWx0X29iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi50b09iamVjdChvYmplY3QsIGRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy5hbm5vdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHJlc3VsdF9vYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHJlc3VsdF9vYmplY3QpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRfb2JqZWN0Ll9fb3B0aW9uYWwgPSBcInBhcmVudCBpcyBvcHRpb25hbFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF9vYmplY3QgPSB7IF9fb3B0aW9uYWw6IHJlc3VsdF9vYmplY3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0X29iamVjdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5zdGF0aWNfdmFyaWFudCA9IGZ1bmN0aW9uIChfc3Rfb3BlcmF0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vc29ydDogdHJ1ZSxcbiAgICAgICAgc3Rfb3BlcmF0aW9uczogX3N0X29wZXJhdGlvbnMsXG4gICAgICAgIG9wVHlwZUlkOiBmdW5jdGlvbiBvcFR5cGVJZCh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IDAsXG4gICAgICAgICAgICAgICAgdHlwZV9pZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHR5cGVfaWQgPSB2YWx1ZTtlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdGhpcy5zdF9vcGVyYXRpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5vcGVyYXRpb25fbmFtZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlX2lkID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlX2lkO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgdmFyIHN0X29wZXJhdGlvbiA9IHRoaXMuc3Rfb3BlcmF0aW9uc1t0eXBlX2lkXTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3N0YXRpY192YXJpYW50IGlkIDB4JyArIHR5cGVfaWQudG9TdHJpbmcoMTYpICsgJyAoJyArIHR5cGVfaWQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYildO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSB0aGlzLm9wVHlwZUlkKG9iamVjdFswXSk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKHR5cGVfaWQpO1xuICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0WzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciB0eXBlX2lkID0gdGhpcy5vcFR5cGVJZChvYmplY3RbMF0pO1xuICAgICAgICAgICAgdmFyIHN0X29wZXJhdGlvbiA9IHRoaXMuc3Rfb3BlcmF0aW9uc1t0eXBlX2lkXTtcbiAgICAgICAgICAgIHYucmVxdWlyZWQoc3Rfb3BlcmF0aW9uLCAnb3BlcmF0aW9uICcgKyB0eXBlX2lkKTtcbiAgICAgICAgICAgIHJldHVybiBbdHlwZV9pZCwgc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob2JqZWN0WzFdKV07XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5zdF9vcGVyYXRpb25zWzBdLm9wZXJhdGlvbl9uYW1lLCB0aGlzLnN0X29wZXJhdGlvbnNbMF0udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSB0aGlzLm9wVHlwZUlkKG9iamVjdFswXSk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFtzdF9vcGVyYXRpb24ub3BlcmF0aW9uX25hbWUsIHN0X29wZXJhdGlvbi50b09iamVjdChvYmplY3RbMV0sIGRlYnVnKV07XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ckNtcCh0aGlzLm9wVHlwZUlkKGFbMF0pLCB0aGlzLm9wVHlwZUlkKGJbMF0pKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5tYXAgPSBmdW5jdGlvbiAoa2V5X3N0X29wZXJhdGlvbiwgdmFsdWVfc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR1cF9tYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICBpZiAoIShvLmxlbmd0aCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0aW5nIHR3byBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9IF90eXBlb2Yob1swXSksIFsnbnVtYmVyJywgJ3N0cmluZyddLmluZGV4T2YocmVmKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBfbWFwW29bMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSAobWFwKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkdXBfbWFwW29bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihhcnJheSwga2V5X3N0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICB2YXIgZW5kID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgZW5kID8gaSA8IGVuZCA6IGkgPiBlbmQ7IDAgPCBlbmQgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSwgdmFsdWVfc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZShvYmplY3QpO1xuICAgICAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIGtleV9zdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvWzBdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZV9zdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9bMF0pLCB2YWx1ZV9zdF9vcGVyYXRpb24uZnJvbU9iamVjdChvWzFdKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUocmVzdWx0KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtba2V5X3N0X29wZXJhdGlvbi50b09iamVjdCh1bmRlZmluZWQsIGRlYnVnKSwgdmFsdWVfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleV9zdF9vcGVyYXRpb24udG9PYmplY3Qob1swXSwgZGVidWcpLCB2YWx1ZV9zdF9vcGVyYXRpb24udG9PYmplY3Qob1sxXSwgZGVidWcpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnB1YmxpY19rZXkgPSB7XG4gICAgdG9QdWJsaWM6IGZ1bmN0aW9uIHRvUHVibGljKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnJlc29sdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0LlEgPyBvYmplY3QgOiBQdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3cob2JqZWN0KTtcbiAgICB9LFxuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBmcC5wdWJsaWNfa2V5KGIpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBmcC5wdWJsaWNfa2V5KGIsIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5RKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlcy5wdWJsaWNfa2V5LnRvUHVibGljKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXggKyBcIjg1OWd4Zm5YeVVyaU1nVWVUaGgxZld2M29xY3BMRnlIYTNUZkZZQzRQSzJIcWhUb1ZNXCI7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0ckNtcChhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcblxuVHlwZXMuYWRkcmVzcyA9IHtcbiAgICBfdG9fYWRkcmVzczogZnVuY3Rpb24gX3RvX2FkZHJlc3Mob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5hZGR5KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZGRyZXNzLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICB9LFxuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhmcC5yaXBlbWQxNjAoYikpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgZnAucmlwZW1kMTYwKGIsIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KS50b0J1ZmZlcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCArIFwiNjY0S21IeFN1UXlEc2Z3bzRXRUp2V3B6ZzFRS2RnNjdTXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVzLmFkZHJlc3MuX3RvX2FkZHJlc3Mob2JqZWN0KS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgIC8vIHNvcnQgZGVjZW5kaW5nXG4gICAgICAgIHJldHVybiAtMSAqIHN0ckNtcChhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG4gICAgfVxufTtcblxudmFyIHN0ckNtcCA9IGZ1bmN0aW9uIHN0ckNtcChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbnZhciBmaXJzdEVsID0gZnVuY3Rpb24gZmlyc3RFbChlbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVsKSA/IGVsWzBdIDogZWw7XG59O1xudmFyIHNvcnRPcGVyYXRpb24gPSBmdW5jdGlvbiBzb3J0T3BlcmF0aW9uKGFycmF5LCBzdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLm5vc29ydCA/IGFycmF5IDogc3Rfb3BlcmF0aW9uLmNvbXBhcmUgPyBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBzdF9vcGVyYXRpb24uY29tcGFyZShmaXJzdEVsKGEpLCBmaXJzdEVsKGIpKTtcbiAgICB9KSA6IC8vIGN1c3RvbSBjb21wYXJlIG9wZXJhdGlvblxuICAgIGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmaXJzdEVsKGEpID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBmaXJzdEVsKGIpID09PSBcIm51bWJlclwiID8gZmlyc3RFbChhKSAtIGZpcnN0RWwoYikgOlxuICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiBQZXJmb3JtYW5hbmNlIGlzIHZlcnkgZ29vZCBzbyBIRVggaXMgdXNlZC4uICBsb2NhbGVDb21wYXJlIGlzIGFub3RoZXIgb3B0aW9uLlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIoZmlyc3RFbChhKSkgJiYgQnVmZmVyLmlzQnVmZmVyKGZpcnN0RWwoYikpID8gc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoXCJoZXhcIiksIGZpcnN0RWwoYikudG9TdHJpbmcoXCJoZXhcIikpIDogc3RyQ21wKGZpcnN0RWwoYSkudG9TdHJpbmcoKSwgZmlyc3RFbChiKS50b1N0cmluZygpKTtcbiAgICB9KTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvdHlwZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9ldmVudHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvaW5oZXJpdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgbG9uZy5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbG9uZy5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbXCJhbWRcIl0pXHJcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXHJcbiAgICAgICAgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGZhY3RvcnkoKTtcclxuICAgIC8qIEdsb2JhbCAqLyBlbHNlXHJcbiAgICAgICAgKGdsb2JhbFtcImRjb2RlSU9cIl0gPSBnbG9iYWxbXCJkY29kZUlPXCJdIHx8IHt9KVtcIkxvbmdcIl0gPSBmYWN0b3J5KCk7XHJcblxyXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cclxuICAgICAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gICAgICogQGV4cG9ydHMgTG9uZ1xyXG4gICAgICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4gICAgLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcclxuICAgIC8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4gICAgLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4gICAgLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcclxuICAgIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4gICAgLy9cclxuICAgIC8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcclxuICAgIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4gICAgLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbiAgICAvLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXHJcbiAgICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbiAgICAvLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICAvL1xyXG4gICAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbiAgICAvLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIExvbmcucHJvdG90eXBlLl9faXNMb25nX187XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwge1xyXG4gICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgICAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XHJcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICAgICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSlcclxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcclxuICAgICAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcclxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICAgICAgdmFyIHA7XHJcbiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICAgICAgZWxzZSBpZiAocCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFpFUk87XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XHJcbiAgICAgICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCAvKiBpcyBjb21wYXRpYmxlICovIGluc3RhbmNlb2YgTG9uZylcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwpO1xyXG4gICAgICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB2YWwudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuICAgIC8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcclxuICAgIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBaRVJPID0gZnJvbUludCgwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCB6ZXJvLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnNpZ25lZCB6ZXJvLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLlVaRVJPID0gVVpFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk9ORSA9IE9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnNpZ25lZCBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTkVHX09ORSA9IE5FR19PTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHhGRkZGRkZGRnwwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcclxuICAgICAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXHJcbiAgICAgICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICAgICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAgICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICAgICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXHJcblxyXG4gICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxyXG4gICAgICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuICAgICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcclxuICAgICAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXHJcbiAgICAgKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgICAgICByZXMgPSBVWkVSTztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xyXG4gICAgICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAgICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXHJcbiAgICAgICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXHJcbiAgICAgICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcclxuXHJcbiAgICAgICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XHJcbiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uKGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgbG8gICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDI0KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICBoaSAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMjQpICYgMHhmZlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAoaGkgPj4+IDI0KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgaGkgICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICBsbyAgICAgICAgICYgMHhmZlxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIExvbmc7XHJcbn0pO1xyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2xvbmcvZGlzdC9sb25nLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2xvbmcvZGlzdFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8vIGNvbnN0YW50cyB0YWJsZVxudmFyIHpsID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dXG5cbnZhciB6ciA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXVxuXG52YXIgc2wgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dXG5cbnZhciBzciA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl1cblxudmFyIGhsID0gWzB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdXG52YXIgaHIgPSBbMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF1cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzIChieXRlcykge1xuICB2YXIgd29yZHMgPSBbXVxuICBmb3IgKHZhciBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KSB7XG4gICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKVxuICB9XG4gIHJldHVybiB3b3Jkc1xufVxuXG5mdW5jdGlvbiB3b3Jkc1RvQnl0ZXMgKHdvcmRzKSB7XG4gIHZhciBieXRlcyA9IFtdXG4gIGZvciAodmFyIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOCkge1xuICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayAoSCwgTSwgb2Zmc2V0KSB7XG4gIC8vIHN3YXAgZW5kaWFuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGlcbiAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldXG5cbiAgICAvLyBTd2FwXG4gICAgTVtvZmZzZXRfaV0gPSAoXG4gICAgICAoKChNX29mZnNldF9pIDw8IDgpIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICAgIClcbiAgfVxuXG4gIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gIHZhciBhbCwgYmwsIGNsLCBkbCwgZWxcbiAgdmFyIGFyLCBiciwgY3IsIGRyLCBlclxuXG4gIGFyID0gYWwgPSBIWzBdXG4gIGJyID0gYmwgPSBIWzFdXG4gIGNyID0gY2wgPSBIWzJdXG4gIGRyID0gZGwgPSBIWzNdXG4gIGVyID0gZWwgPSBIWzRdXG5cbiAgLy8gY29tcHV0YXRpb25cbiAgdmFyIHRcbiAgZm9yIChpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB0ID0gKGFsICsgTVtvZmZzZXQgKyB6bFtpXV0pIHwgMFxuICAgIGlmIChpIDwgMTYpIHtcbiAgICAgIHQgKz0gZjEoYmwsIGNsLCBkbCkgKyBobFswXVxuICAgIH0gZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICB0ICs9IGYyKGJsLCBjbCwgZGwpICsgaGxbMV1cbiAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgdCArPSBmMyhibCwgY2wsIGRsKSArIGhsWzJdXG4gICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgIHQgKz0gZjQoYmwsIGNsLCBkbCkgKyBobFszXVxuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgIHQgKz0gZjUoYmwsIGNsLCBkbCkgKyBobFs0XVxuICAgIH1cbiAgICB0ID0gdCB8IDBcbiAgICB0ID0gcm90bCh0LCBzbFtpXSlcbiAgICB0ID0gKHQgKyBlbCkgfCAwXG4gICAgYWwgPSBlbFxuICAgIGVsID0gZGxcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxuICAgIGNsID0gYmxcbiAgICBibCA9IHRcblxuICAgIHQgPSAoYXIgKyBNW29mZnNldCArIHpyW2ldXSkgfCAwXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdCArPSBmNShiciwgY3IsIGRyKSArIGhyWzBdXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHQgKz0gZjQoYnIsIGNyLCBkcikgKyBoclsxXVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0ICs9IGYzKGJyLCBjciwgZHIpICsgaHJbMl1cbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdCArPSBmMihiciwgY3IsIGRyKSArIGhyWzNdXG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgdCArPSBmMShiciwgY3IsIGRyKSArIGhyWzRdXG4gICAgfVxuXG4gICAgdCA9IHQgfCAwXG4gICAgdCA9IHJvdGwodCwgc3JbaV0pXG4gICAgdCA9ICh0ICsgZXIpIHwgMFxuICAgIGFyID0gZXJcbiAgICBlciA9IGRyXG4gICAgZHIgPSByb3RsKGNyLCAxMClcbiAgICBjciA9IGJyXG4gICAgYnIgPSB0XG4gIH1cblxuICAvLyBpbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICB0ID0gKEhbMV0gKyBjbCArIGRyKSB8IDBcbiAgSFsxXSA9IChIWzJdICsgZGwgKyBlcikgfCAwXG4gIEhbMl0gPSAoSFszXSArIGVsICsgYXIpIHwgMFxuICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKSB8IDBcbiAgSFs0XSA9IChIWzBdICsgYmwgKyBjcikgfCAwXG4gIEhbMF0gPSB0XG59XG5cbmZ1bmN0aW9uIGYxICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKVxufVxuXG5mdW5jdGlvbiBmMiAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgJiAoeSkpIHwgKCh+eCkgJiAoeikpKVxufVxuXG5mdW5jdGlvbiBmMyAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgfCAofih5KSkpIF4gKHopKVxufVxuXG5mdW5jdGlvbiBmNCAoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgJiAoeikpIHwgKCh5KSAmICh+KHopKSkpXG59XG5cbmZ1bmN0aW9uIGY1ICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKCh5KSB8ICh+KHopKSkpXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiByaXBlbWQxNjAgKG1lc3NhZ2UpIHtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3NiwgMHhDM0QyRTFGMF1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ3V0ZjgnKVxuICB9XG5cbiAgdmFyIG0gPSBieXRlc1RvV29yZHMobWVzc2FnZSlcblxuICB2YXIgbkJpdHNMZWZ0ID0gbWVzc2FnZS5sZW5ndGggKiA4XG4gIHZhciBuQml0c1RvdGFsID0gbWVzc2FnZS5sZW5ndGggKiA4XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgbVtuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpXG4gIG1bKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcbiAgICAoKChuQml0c1RvdGFsIDw8IDgpIHwgKG5CaXRzVG90YWwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgKCgobkJpdHNUb3RhbCA8PCAyNCkgfCAobkJpdHNUb3RhbCA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBwcm9jZXNzQmxvY2soSCwgbSwgaSlcbiAgfVxuXG4gIC8vIHN3YXAgZW5kaWFuXG4gIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAvLyBzaG9ydGN1dFxuICAgIHZhciBIX2kgPSBIW2ldXG5cbiAgICAvLyBTd2FwXG4gICAgSFtpXSA9ICgoKEhfaSA8PCA4KSB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgfVxuXG4gIHZhciBkaWdlc3RieXRlcyA9IHdvcmRzVG9CeXRlcyhIKVxuICByZXR1cm4gbmV3IEJ1ZmZlcihkaWdlc3RieXRlcylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByaXBlbWQxNjBcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvcmlwZW1kMTYwL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbiFmdW5jdGlvbihnbG9iYWxzKXtcbid1c2Ugc3RyaWN0J1xuXG4vLyoqKiBVTUQgQkVHSU5cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7IC8vcmVxdWlyZS5qcyAvIEFNRFxuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWN1cmVSYW5kb21cbiAgfSlcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHsgLy9Db21tb25KU1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlY3VyZVJhbmRvbVxufSBlbHNlIHsgLy9zY3JpcHQgLyBicm93c2VyXG4gIGdsb2JhbHMuc2VjdXJlUmFuZG9tID0gc2VjdXJlUmFuZG9tXG59XG4vLyoqKiBVTUQgRU5EXG5cbi8vb3B0aW9ucy50eXBlIGlzIHRoZSBvbmx5IHZhbGlkIG9wdGlvblxuZnVuY3Rpb24gc2VjdXJlUmFuZG9tKGNvdW50LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt0eXBlOiAnQXJyYXknfVxuICAvL3dlIGNoZWNrIGZvciBwcm9jZXNzLnBpZCB0byBwcmV2ZW50IGJyb3dzZXJpZnkgZnJvbSB0cmlja2luZyB1c1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MucGlkID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5vZGVSYW5kb20oY291bnQsIG9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvXG4gICAgaWYgKCFjcnlwdG8pIHRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHdpbmRvdy5jcnlwdG8uXCIpXG4gICAgcmV0dXJuIGJyb3dzZXJSYW5kb20oY291bnQsIG9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbm9kZVJhbmRvbShjb3VudCwgb3B0aW9ucykge1xuICB2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgdmFyIGJ1ZiA9IGNyeXB0by5yYW5kb21CeXRlcyhjb3VudClcblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGJ1ZilcbiAgICBjYXNlICdCdWZmZXInOlxuICAgICAgcmV0dXJuIGJ1ZlxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGNvdW50KVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7IGFycltpXSA9IGJ1Zi5yZWFkVUludDgoaSkgfVxuICAgICAgcmV0dXJuIGFyclxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9ucy50eXBlICsgXCIgaXMgdW5zdXBwb3J0ZWQuXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJvd3NlclJhbmRvbShjb3VudCwgb3B0aW9ucykge1xuICB2YXIgbmF0aXZlQXJyID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpXG4gIHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0b1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycilcblxuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKG5hdGl2ZUFycilcbiAgICBjYXNlICdCdWZmZXInOlxuICAgICAgdHJ5IHsgdmFyIGIgPSBuZXcgQnVmZmVyKDEpIH0gY2F0Y2goZSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuIFVzZSBOb2RlLmpzIG9yIEJyb3dzZXJpZnkgZm9yIGJyb3dzZXIgc3VwcG9ydC4nKX1cbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKG5hdGl2ZUFycilcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICAgIHJldHVybiBuYXRpdmVBcnJcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG9wdGlvbnMudHlwZSArIFwiIGlzIHVuc3VwcG9ydGVkLlwiKVxuICB9XG59XG5cbnNlY3VyZVJhbmRvbS5yYW5kb21BcnJheSA9IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICByZXR1cm4gc2VjdXJlUmFuZG9tKGJ5dGVDb3VudCwge3R5cGU6ICdBcnJheSd9KVxufVxuXG5zZWN1cmVSYW5kb20ucmFuZG9tVWludDhBcnJheSA9IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICByZXR1cm4gc2VjdXJlUmFuZG9tKGJ5dGVDb3VudCwge3R5cGU6ICdVaW50OEFycmF5J30pXG59XG5cbnNlY3VyZVJhbmRvbS5yYW5kb21CdWZmZXIgPSBmdW5jdGlvbihieXRlQ291bnQpIHtcbiAgcmV0dXJuIHNlY3VyZVJhbmRvbShieXRlQ291bnQsIHt0eXBlOiAnQnVmZmVyJ30pXG59XG5cblxufSh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2VjdXJlLXJhbmRvbS9saWIvc2VjdXJlLXJhbmRvbS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zZWN1cmUtcmFuZG9tL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpXG4gIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fbGVuID0gMFxuICB0aGlzLl9zID0gMFxufVxuXG5IYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBlbmMgfHwgJ3V0ZjgnXG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGwgPSB0aGlzLl9sZW4gKz0gZGF0YS5sZW5ndGhcbiAgdmFyIHMgPSB0aGlzLl9zIHx8IDBcbiAgdmFyIGYgPSAwXG4gIHZhciBidWZmZXIgPSB0aGlzLl9ibG9ja1xuXG4gIHdoaWxlIChzIDwgbCkge1xuICAgIHZhciB0ID0gTWF0aC5taW4oZGF0YS5sZW5ndGgsIGYgKyB0aGlzLl9ibG9ja1NpemUgLSAocyAlIHRoaXMuX2Jsb2NrU2l6ZSkpXG4gICAgdmFyIGNoID0gKHQgLSBmKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaDsgaSsrKSB7XG4gICAgICBidWZmZXJbKHMgJSB0aGlzLl9ibG9ja1NpemUpICsgaV0gPSBkYXRhW2kgKyBmXVxuICAgIH1cblxuICAgIHMgKz0gY2hcbiAgICBmICs9IGNoXG5cbiAgICBpZiAoKHMgJSB0aGlzLl9ibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYnVmZmVyKVxuICAgIH1cbiAgfVxuICB0aGlzLl9zID0gc1xuXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgLy8gU3VwcG9zZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIE0sIGluIGJpdHMsIGlzIGxcbiAgdmFyIGwgPSB0aGlzLl9sZW4gKiA4XG5cbiAgLy8gQXBwZW5kIHRoZSBiaXQgMSB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZV0gPSAweDgwXG5cbiAgLy8gYW5kIHRoZW4gayB6ZXJvIGJpdHMsIHdoZXJlIGsgaXMgdGhlIHNtYWxsZXN0IG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGwgKyAxICsgaykgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplICsgMSlcblxuICBpZiAobCAlICh0aGlzLl9ibG9ja1NpemUgKiA4KSA+PSB0aGlzLl9maW5hbFNpemUgKiA4KSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIC8vIHRvIHRoaXMgYXBwZW5kIHRoZSBibG9jayB3aGljaCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIGwgd3JpdHRlbiBpbiBiaW5hcnlcbiAgLy8gVE9ETzogaGFuZGxlIGNhc2Ugd2hlcmUgbCBpcyA+IE1hdGgucG93KDIsIDI5KVxuICB0aGlzLl9ibG9jay53cml0ZUludDMyQkUobCwgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICB2YXIgaGFzaCA9IHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaykgfHwgdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFNIQSAoYWxnb3JpdGhtKSB7XG4gIGFsZ29yaXRobSA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIEFsZ29yaXRobSA9IGV4cG9ydHNbYWxnb3JpdGhtXVxuICBpZiAoIUFsZ29yaXRobSkgdGhyb3cgbmV3IEVycm9yKGFsZ29yaXRobSArICcgaXMgbm90IHN1cHBvcnRlZCAod2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMpJylcblxuICByZXR1cm4gbmV3IEFsZ29yaXRobSgpXG59XG5cbmV4cG9ydHMuc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJylcbmV4cG9ydHMuc2hhMjI0ID0gcmVxdWlyZSgnLi9zaGEyMjQnKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhMzg0JylcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMCwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgZGVyaXZlZCBmcm9tIHNoYTEuanMgb2YgdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gU0hBLTAgYW5kIFNIQS0xIGlzIGp1c3QgYSBiaXR3aXNlIHJvdGF0ZSBsZWZ0XG4gKiBvcGVyYXRpb24gd2FzIGFkZGVkLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyMjQgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyMjQsIFNoYTI1NilcblxuU2hhMjI0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHhjMTA1OWVkOFxuICB0aGlzLl9iID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jID0gMHgzMDcwZGQxN1xuICB0aGlzLl9kID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mID0gMHg2ODU4MTUxMVxuICB0aGlzLl9nID0gMHg2NGY5OGZhN1xuICB0aGlzLl9oID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTIyNC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigyOClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTIyNFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjI0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAweEQ4MDdBQTk4LCAweDEyODM1QjAxLCAweDI0MzE4NUJFLCAweDU1MEM3REMzLFxuICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAweDJERTkyQzZGLCAweDRBNzQ4NEFBLCAweDVDQjBBOURDLCAweDc2Rjk4OERBLFxuICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3QjcwQTg1LCAweDJFMUIyMTM4LCAweDREMkM2REZDLCAweDUzMzgwRDEzLFxuICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAweEQxOTJFODE5LCAweEQ2OTkwNjI0LCAweEY0MEUzNTg1LCAweDEwNkFBMDcwLFxuICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAweDc0OEY4MkVFLCAweDc4QTU2MzZGLCAweDg0Qzg3ODE0LCAweDhDQzcwMjA4LFxuICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDY0KVxuXG5mdW5jdGlvbiBTaGEyNTYgKCkge1xuICB0aGlzLmluaXQoKVxuXG4gIHRoaXMuX3cgPSBXIC8vIG5ldyBBcnJheSg2NClcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEyNTYsIEhhc2gpXG5cblNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYiA9IDB4YmI2N2FlODVcbiAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZSA9IDB4NTEwZTUyN2ZcbiAgdGhpcy5fZiA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faCA9IDB4NWJlMGNkMTlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBjaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAyIHwgeCA8PCAzMCkgXiAoeCA+Pj4gMTMgfCB4IDw8IDE5KSBeICh4ID4+PiAyMiB8IHggPDwgMTApXG59XG5cbmZ1bmN0aW9uIHNpZ21hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDYgfCB4IDw8IDI2KSBeICh4ID4+PiAxMSB8IHggPDwgMjEpIF4gKHggPj4+IDI1IHwgeCA8PCA3KVxufVxuXG5mdW5jdGlvbiBnYW1tYTAgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiA3IHwgeCA8PCAyNSkgXiAoeCA+Pj4gMTggfCB4IDw8IDE0KSBeICh4ID4+PiAzKVxufVxuXG5mdW5jdGlvbiBnYW1tYTEgKHgpIHtcbiAgcmV0dXJuICh4ID4+PiAxNyB8IHggPDwgMTUpIF4gKHggPj4+IDE5IHwgeCA8PCAxMykgXiAoeCA+Pj4gMTApXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuICB2YXIgZiA9IHRoaXMuX2YgfCAwXG4gIHZhciBnID0gdGhpcy5fZyB8IDBcbiAgdmFyIGggPSB0aGlzLl9oIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgNjQ7ICsraSkgV1tpXSA9IChnYW1tYTEoV1tpIC0gMl0pICsgV1tpIC0gN10gKyBnYW1tYTAoV1tpIC0gMTVdKSArIFdbaSAtIDE2XSkgfCAwXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgKytqKSB7XG4gICAgdmFyIFQxID0gKGggKyBzaWdtYTEoZSkgKyBjaChlLCBmLCBnKSArIEtbal0gKyBXW2pdKSB8IDBcbiAgICB2YXIgVDIgPSAoc2lnbWEwKGEpICsgbWFqKGEsIGIsIGMpKSB8IDBcblxuICAgIGggPSBnXG4gICAgZyA9IGZcbiAgICBmID0gZVxuICAgIGUgPSAoZCArIFQxKSB8IDBcbiAgICBkID0gY1xuICAgIGMgPSBiXG4gICAgYiA9IGFcbiAgICBhID0gKFQxICsgVDIpIHwgMFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxuICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gIHRoaXMuX2ggPSAoaCArIHRoaXMuX2gpIHwgMFxufVxuXG5TaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMzIpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjU2XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyNTYuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG5mdW5jdGlvbiBTaGEzODQgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbn1cblxuaW5oZXJpdHMoU2hhMzg0LCBTSEE1MTIpXG5cblNoYTM4NC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweGNiYmI5ZDVkXG4gIHRoaXMuX2JoID0gMHg2MjlhMjkyYVxuICB0aGlzLl9jaCA9IDB4OTE1OTAxNWFcbiAgdGhpcy5fZGggPSAweDE1MmZlY2Q4XG4gIHRoaXMuX2VoID0gMHg2NzMzMjY2N1xuICB0aGlzLl9maCA9IDB4OGViNDRhODdcbiAgdGhpcy5fZ2ggPSAweGRiMGMyZTBkXG4gIHRoaXMuX2hoID0gMHg0N2I1NDgxZFxuXG4gIHRoaXMuX2FsID0gMHhjMTA1OWVkOFxuICB0aGlzLl9ibCA9IDB4MzY3Y2Q1MDdcbiAgdGhpcy5fY2wgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2RsID0gMHhmNzBlNTkzOVxuICB0aGlzLl9lbCA9IDB4ZmZjMDBiMzFcbiAgdGhpcy5fZmwgPSAweDY4NTgxNTExXG4gIHRoaXMuX2dsID0gMHg2NGY5OGZhN1xuICB0aGlzLl9obCA9IDB4YmVmYTRmYTRcblxuICByZXR1cm4gdGhpc1xufVxuXG5TaGEzODQucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNDgpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMzg0XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTUxMiAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cblNoYTUxMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWggPSAweDZhMDllNjY3XG4gIHRoaXMuX2JoID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jaCA9IDB4M2M2ZWYzNzJcbiAgdGhpcy5fZGggPSAweGE1NGZmNTNhXG4gIHRoaXMuX2VoID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9maCA9IDB4OWIwNTY4OGNcbiAgdGhpcy5fZ2ggPSAweDFmODNkOWFiXG4gIHRoaXMuX2hoID0gMHg1YmUwY2QxOVxuXG4gIHRoaXMuX2FsID0gMHhmM2JjYzkwOFxuICB0aGlzLl9ibCA9IDB4ODRjYWE3M2JcbiAgdGhpcy5fY2wgPSAweGZlOTRmODJiXG4gIHRoaXMuX2RsID0gMHg1ZjFkMzZmMVxuICB0aGlzLl9lbCA9IDB4YWRlNjgyZDFcbiAgdGhpcy5fZmwgPSAweDJiM2U2YzFmXG4gIHRoaXMuX2dsID0gMHhmYjQxYmQ2YlxuICB0aGlzLl9obCA9IDB4MTM3ZTIxNzlcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICByZXR1cm4geiBeICh4ICYgKHkgXiB6KSlcbn1cblxuZnVuY3Rpb24gbWFqICh4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIHwgKHogJiAoeCB8IHkpKVxufVxuXG5mdW5jdGlvbiBzaWdtYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMjggfCB4bCA8PCA0KSBeICh4bCA+Pj4gMiB8IHggPDwgMzApIF4gKHhsID4+PiA3IHwgeCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE0IHwgeGwgPDwgMTgpIF4gKHggPj4+IDE4IHwgeGwgPDwgMTQpIF4gKHhsID4+PiA5IHwgeCA8PCAyMylcbn1cblxuZnVuY3Rpb24gR2FtbWEwICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3KVxufVxuXG5mdW5jdGlvbiBHYW1tYTBsICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDEgfCB4bCA8PCAzMSkgXiAoeCA+Pj4gOCB8IHhsIDw8IDI0KSBeICh4ID4+PiA3IHwgeGwgPDwgMjUpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMSAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMWwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTkgfCB4bCA8PCAxMykgXiAoeGwgPj4+IDI5IHwgeCA8PCAzKSBeICh4ID4+PiA2IHwgeGwgPDwgMjYpXG59XG5cbmZ1bmN0aW9uIGdldENhcnJ5IChhLCBiKSB7XG4gIHJldHVybiAoYSA+Pj4gMCkgPCAoYiA+Pj4gMCkgPyAxIDogMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYWggPSB0aGlzLl9haCB8IDBcbiAgdmFyIGJoID0gdGhpcy5fYmggfCAwXG4gIHZhciBjaCA9IHRoaXMuX2NoIHwgMFxuICB2YXIgZGggPSB0aGlzLl9kaCB8IDBcbiAgdmFyIGVoID0gdGhpcy5fZWggfCAwXG4gIHZhciBmaCA9IHRoaXMuX2ZoIHwgMFxuICB2YXIgZ2ggPSB0aGlzLl9naCB8IDBcbiAgdmFyIGhoID0gdGhpcy5faGggfCAwXG5cbiAgdmFyIGFsID0gdGhpcy5fYWwgfCAwXG4gIHZhciBibCA9IHRoaXMuX2JsIHwgMFxuICB2YXIgY2wgPSB0aGlzLl9jbCB8IDBcbiAgdmFyIGRsID0gdGhpcy5fZGwgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2VsIHwgMFxuICB2YXIgZmwgPSB0aGlzLl9mbCB8IDBcbiAgdmFyIGdsID0gdGhpcy5fZ2wgfCAwXG4gIHZhciBobCA9IHRoaXMuX2hsIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkgKz0gMikge1xuICAgIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICAgIFdbaSArIDFdID0gTS5yZWFkSW50MzJCRShpICogNCArIDQpXG4gIH1cbiAgZm9yICg7IGkgPCAxNjA7IGkgKz0gMikge1xuICAgIHZhciB4aCA9IFdbaSAtIDE1ICogMl1cbiAgICB2YXIgeGwgPSBXW2kgLSAxNSAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTAgPSBHYW1tYTAoeGgsIHhsKVxuICAgIHZhciBnYW1tYTBsID0gR2FtbWEwbCh4bCwgeGgpXG5cbiAgICB4aCA9IFdbaSAtIDIgKiAyXVxuICAgIHhsID0gV1tpIC0gMiAqIDIgKyAxXVxuICAgIHZhciBnYW1tYTEgPSBHYW1tYTEoeGgsIHhsKVxuICAgIHZhciBnYW1tYTFsID0gR2FtbWExbCh4bCwgeGgpXG5cbiAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICB2YXIgV2k3aCA9IFdbaSAtIDcgKiAyXVxuICAgIHZhciBXaTdsID0gV1tpIC0gNyAqIDIgKyAxXVxuXG4gICAgdmFyIFdpMTZoID0gV1tpIC0gMTYgKiAyXVxuICAgIHZhciBXaTE2bCA9IFdbaSAtIDE2ICogMiArIDFdXG5cbiAgICB2YXIgV2lsID0gKGdhbW1hMGwgKyBXaTdsKSB8IDBcbiAgICB2YXIgV2loID0gKGdhbW1hMCArIFdpN2ggKyBnZXRDYXJyeShXaWwsIGdhbW1hMGwpKSB8IDBcbiAgICBXaWwgPSAoV2lsICsgZ2FtbWExbCkgfCAwXG4gICAgV2loID0gKFdpaCArIGdhbW1hMSArIGdldENhcnJ5KFdpbCwgZ2FtbWExbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBXaTE2bCkgfCAwXG4gICAgV2loID0gKFdpaCArIFdpMTZoICsgZ2V0Q2FycnkoV2lsLCBXaTE2bCkpIHwgMFxuXG4gICAgV1tpXSA9IFdpaFxuICAgIFdbaSArIDFdID0gV2lsXG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDE2MDsgaiArPSAyKSB7XG4gICAgV2loID0gV1tqXVxuICAgIFdpbCA9IFdbaiArIDFdXG5cbiAgICB2YXIgbWFqaCA9IG1haihhaCwgYmgsIGNoKVxuICAgIHZhciBtYWpsID0gbWFqKGFsLCBibCwgY2wpXG5cbiAgICB2YXIgc2lnbWEwaCA9IHNpZ21hMChhaCwgYWwpXG4gICAgdmFyIHNpZ21hMGwgPSBzaWdtYTAoYWwsIGFoKVxuICAgIHZhciBzaWdtYTFoID0gc2lnbWExKGVoLCBlbClcbiAgICB2YXIgc2lnbWExbCA9IHNpZ21hMShlbCwgZWgpXG5cbiAgICAvLyB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbal0gKyBXW2pdXG4gICAgdmFyIEtpaCA9IEtbal1cbiAgICB2YXIgS2lsID0gS1tqICsgMV1cblxuICAgIHZhciBjaGggPSBDaChlaCwgZmgsIGdoKVxuICAgIHZhciBjaGwgPSBDaChlbCwgZmwsIGdsKVxuXG4gICAgdmFyIHQxbCA9IChobCArIHNpZ21hMWwpIHwgMFxuICAgIHZhciB0MWggPSAoaGggKyBzaWdtYTFoICsgZ2V0Q2FycnkodDFsLCBobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBjaGwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBjaGggKyBnZXRDYXJyeSh0MWwsIGNobCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBLaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBLaWggKyBnZXRDYXJyeSh0MWwsIEtpbCkpIHwgMFxuICAgIHQxbCA9ICh0MWwgKyBXaWwpIHwgMFxuICAgIHQxaCA9ICh0MWggKyBXaWggKyBnZXRDYXJyeSh0MWwsIFdpbCkpIHwgMFxuXG4gICAgLy8gdDIgPSBzaWdtYTAgKyBtYWpcbiAgICB2YXIgdDJsID0gKHNpZ21hMGwgKyBtYWpsKSB8IDBcbiAgICB2YXIgdDJoID0gKHNpZ21hMGggKyBtYWpoICsgZ2V0Q2FycnkodDJsLCBzaWdtYTBsKSkgfCAwXG5cbiAgICBoaCA9IGdoXG4gICAgaGwgPSBnbFxuICAgIGdoID0gZmhcbiAgICBnbCA9IGZsXG4gICAgZmggPSBlaFxuICAgIGZsID0gZWxcbiAgICBlbCA9IChkbCArIHQxbCkgfCAwXG4gICAgZWggPSAoZGggKyB0MWggKyBnZXRDYXJyeShlbCwgZGwpKSB8IDBcbiAgICBkaCA9IGNoXG4gICAgZGwgPSBjbFxuICAgIGNoID0gYmhcbiAgICBjbCA9IGJsXG4gICAgYmggPSBhaFxuICAgIGJsID0gYWxcbiAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgIGFoID0gKHQxaCArIHQyaCArIGdldENhcnJ5KGFsLCB0MWwpKSB8IDBcbiAgfVxuXG4gIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICB0aGlzLl9ibCA9ICh0aGlzLl9ibCArIGJsKSB8IDBcbiAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICB0aGlzLl9lbCA9ICh0aGlzLl9lbCArIGVsKSB8IDBcbiAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICB0aGlzLl9obCA9ICh0aGlzLl9obCArIGhsKSB8IDBcblxuICB0aGlzLl9haCA9ICh0aGlzLl9haCArIGFoICsgZ2V0Q2FycnkodGhpcy5fYWwsIGFsKSkgfCAwXG4gIHRoaXMuX2JoID0gKHRoaXMuX2JoICsgYmggKyBnZXRDYXJyeSh0aGlzLl9ibCwgYmwpKSB8IDBcbiAgdGhpcy5fY2ggPSAodGhpcy5fY2ggKyBjaCArIGdldENhcnJ5KHRoaXMuX2NsLCBjbCkpIHwgMFxuICB0aGlzLl9kaCA9ICh0aGlzLl9kaCArIGRoICsgZ2V0Q2FycnkodGhpcy5fZGwsIGRsKSkgfCAwXG4gIHRoaXMuX2VoID0gKHRoaXMuX2VoICsgZWggKyBnZXRDYXJyeSh0aGlzLl9lbCwgZWwpKSB8IDBcbiAgdGhpcy5fZmggPSAodGhpcy5fZmggKyBmaCArIGdldENhcnJ5KHRoaXMuX2ZsLCBmbCkpIHwgMFxuICB0aGlzLl9naCA9ICh0aGlzLl9naCArIGdoICsgZ2V0Q2FycnkodGhpcy5fZ2wsIGdsKSkgfCAwXG4gIHRoaXMuX2hoID0gKHRoaXMuX2hoICsgaGggKyBnZXRDYXJyeSh0aGlzLl9obCwgaGwpKSB8IDBcbn1cblxuU2hhNTEyLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2doLCB0aGlzLl9nbCwgNDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9oaCwgdGhpcy5faGwsIDU2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhNTEyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBXc1JwYyA9IHJlcXVpcmUoXCIuL1dlYlNvY2tldFJwY1wiKTtcbnZhciBTdGVlbUFwaSA9IHJlcXVpcmUoXCIuL1N0ZWVtQXBpXCIpO1xuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgdXJsOiBcIndzczovL25vZGUuc3RlZW0ud3NcIixcbiAgICB1c2VyOiBcIlwiLFxuICAgIHBhc3M6IFwiXCIsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGFwaXM6IFtcImRhdGFiYXNlX2FwaVwiLCBcIm5ldHdvcmtfYnJvYWRjYXN0X2FwaVwiLCBcImZvbGxvd19hcGlcIiwgXCJtYXJrZXRfaGlzdG9yeV9hcGlcIiwgXCJsb2dpbl9hcGlcIiwgXCJwcml2YXRlX21lc3NhZ2VfYXBpXCJdXG59O1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgYXBpSW5zdGFuY2U7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIGlmIChhcGlJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFwaUluc3RhbmNlID0gbmV3IEFwaUluc3RhbmNlKG9wdGlvbnMpO1xuICAgICAgICBhcGlJbnN0YW5jZS5jb25uZWN0KCk7XG5cbiAgICAgICAgcmV0dXJuIGFwaUluc3RhbmNlO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgaWYgKCFhcGlJbnN0YW5jZSkge1xuICAgICAgICAgICAgYXBpSW5zdGFuY2UgPSBuZXcgQXBpSW5zdGFuY2Uob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29ubmVjdCkge1xuICAgICAgICAgICAgYXBpSW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIGFwaUluc3RhbmNlLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcGlJbnN0YW5jZTtcbiAgICB9LFxuXG5cbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGFwaUluc3RhbmNlLmNsb3NlKCk7YXBpSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cbn07XG5cbnZhciBBcGlJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcGlJbnN0YW5jZShvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGlJbnN0YW5jZSk7XG5cbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YXR1c0NhbGxiYWNrID0gb3B0aW9ucy5zdGF0dXNDYWxsYmFjaztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXBpSW5zdGFuY2UsIFt7XG4gICAgICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9iamVjdEFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpOy8vT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hcGlzLmluZGV4T2YoXCJkYXRhYmFzZV9hcGlcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFwaXMudW5zaGlmdChcImRhdGFiYXNlX2FwaVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbm5lY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53c1JwYykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLndzUnBjID0gbmV3IFdzUnBjKHRoaXMub3B0aW9ucywgdGhpcy5vblJlY29ubmVjdC5iaW5kKHRoaXMpLCB0aGlzLm9uU3RhdHVzQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2luKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwid3NScGMgb3BlbiBlcnJvcjpcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImxvZ2luXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dpbigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRQcm9taXNlID0gdGhpcy53c1JwYy5sb2dpbih0aGlzLm9wdGlvbnMudXNlciwgdGhpcy5vcHRpb25zLnBhc3MpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcGlQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMub3B0aW9ucy5hcGlzLmZvckVhY2goZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1tcIl9cIiArIGFwaV0gPSBuZXcgU3RlZW1BcGkoX3RoaXMud3NScGMsIGFwaSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzW2FwaV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tcIl9cIiArIGFwaV07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFwaVByb21pc2VzLnB1c2goX3RoaXNbXCJfXCIgKyBhcGldLmluaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcGkgPT09IFwiZGF0YWJhc2VfYXBpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNbYXBpXSgpLmV4ZWMoXCJnZXRfY29uZmlnXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLlNURUVNSVRfQ0hBSU5fSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFpbklkID0gcmVzLlNURUVNSVRfQ0hBSU5fSUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbm5lY3RlZCB0byBcIiArIGFwaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29ubmVjdGVkIHRvIFwiICsgYXBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFwaVByb21pc2VzKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGNvbm5lY3QgdG9cIiwgdGhpcy5vcHRpb25zLnVybCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbm5lY3QgdG8gXCIgKyBfdGhpcy5vcHRpb25zLnVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm9uUmVjb25uZWN0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlY29ubmVjdCgpIHtcbiAgICAgICAgICAgIHRoaXMubG9naW4oKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm9uU3RhdHVzQ2hhbmdlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblN0YXR1c0NoYW5nZShlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjbG9zZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy53c1JwYykge1xuICAgICAgICAgICAgICAgIHRoaXMud3NScGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndzUnBjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBcGlJbnN0YW5jZTtcbn0oKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvQXBpSW5zdGFuY2UuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgU3RlZW1BcGkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFN0ZWVtQXBpKHdzUnBjLCBhcGlOYW1lKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZWVtQXBpKTtcblxuXHRcdHRoaXMud3NScGMgPSB3c1JwYztcblx0XHR0aGlzLmFwaU5hbWUgPSBhcGlOYW1lO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFN0ZWVtQXBpLCBbe1xuXHRcdGtleTogXCJpbml0XCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy53c1JwYy5nZXRBcGlCeU5hbWUodGhpcy5hcGlOYW1lKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXHRcdFx0XHRfdGhpcy5hcGlJZCA9IHJlc3BvbnNlO1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiZXhlY1wiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBleGVjKG1ldGhvZCwgcGFyYW1zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53c1JwYy5jYWxsKFt0aGlzLmFwaUlkLCBtZXRob2QsIHBhcmFtc10pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiQXBpIGVycm9yOlwiLCBtZXRob2QsIHBhcmFtcywgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcblx0XHRcdFx0dmFyIG5ld0VyciA9IG5ldyBFcnJvcihcIkFwaSBlcnJvcjpcIiArIG1ldGhvZCArIHBhcmFtcyArIEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG5cdFx0XHRcdG5ld0Vyci5vcmlnaW5hbCA9IGVycm9yO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2UuZXJyb3IgPSAxO1xuXHRcdFx0XHRsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlID0gZXJyb3IubWVzc2FnZT9lcnJvci5tZXNzYWdlLnNwbGl0KFwiXFxuXCIpWzFdOidDb25uZWN0aW9uIGxvc3QsIHJlY29ubmVjdGluZy4uLic7XG5cdFx0XHRcdHRocm93IG5ld0Vycjtcblx0XHRcdH0pO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTdGVlbUFwaTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGVlbUFwaTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvU3RlZW1BcGkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUldlYlNvY2tldCA9IHJlcXVpcmUoXCIuL3JlY29ubmVjdGluZy13ZWJzb2NrZXRcIik7XG5cbnZhciBXZWJTb2NrZXRScGMgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIFdlYlNvY2tldFJwYyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblxuXHRcdHZhciByY0NhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcblx0XHR2YXIgc3RhdHVzQ2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlNvY2tldFJwYyk7XG5cblx0XHR0aGlzLnJjQ2FsbGJhY2sgPSByY0NhbGxiYWNrO1xuXHRcdHRoaXMuc3RhdHVzQ2FsbGJhY2sgPSBzdGF0dXNDYWxsYmFjaztcblxuXHRcdGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRvcHRpb25zLldlYlNvY2tldCA9IFdlYlNvY2tldDtcblx0XHRcdG9wdGlvbnMuaWRsZVRyZXNob2xkID0gXCJpZGxlVHJlc2hvbGRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pZGxlVHJlc2hvbGQgOiA2MDAwMDsgLy8gT25seSB1c2UgaWRsZSB0aHJlc2hvbGQgaW4gYnJvd3NlcnNcblx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb25zLldlYlNvY2tldCA9IHJlcXVpcmUoXCJ3c1wiKTtcblx0XHRcdFx0b3B0aW9ucy5pZGxlVHJlc2hvbGQgPSAwOyAvLyBBbHdheXMgcmVjb25uZWN0IGluIG5vZGUuanNcblx0XHRcdH1cblx0XHRvcHRpb25zLnJlY29ubmVjdEludGVydmFsID0gMTAwMDtcblx0XHRvcHRpb25zLnJlY29ubmVjdERlY2F5ID0gMS4yO1xuXG5cdFx0dGhpcy53cyA9IG5ldyBSV2ViU29ja2V0KG9wdGlvbnMpO1xuXHRcdHRoaXMud3MudGltZW91dEludGVydmFsID0gMTUwMDA7XG5cblx0XHR2YXIgaW5pdGlhbENvbm5lY3QgPSB0cnVlO1xuXG5cdFx0dGhpcy5jb25uZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuXHRcdFx0X3RoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoX3RoaXMuc3RhdHVzQ2FsbGJhY2spIF90aGlzLnN0YXR1c0NhbGxiYWNrKFwib3BlblwiKTtcblx0XHRcdFx0aWYgKGluaXRpYWxDb25uZWN0KSB7XG5cdFx0XHRcdFx0aW5pdGlhbENvbm5lY3QgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKF90aGlzLnJjQ2FsbGJhY2spIF90aGlzLnJjQ2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0X3RoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0aWYgKF90aGlzLnN0YXR1c0NhbGxiYWNrKSBfdGhpcy5zdGF0dXNDYWxsYmFjayhcImVycm9yXCIpO1xuXHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdH07XG5cblx0XHRcdF90aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0ZGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiVW5hYmxlIHRvIHBhcnNlIEFQSSByZXNwb25zZTpcIiwgZSk7XG5cdFx0XHRcdFx0ZGF0YS5lcnJvciA9IFwiVW5hYmxlIHRvIHBhcnNlIHJlc3BvbnNlIFwiICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0X3RoaXMubGlzdGVuZXIoZGF0YSk7XG5cdFx0XHR9O1xuXG5cdFx0XHRfdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyB3ZWIgc29ja2V0IG1heSByZS1jb25uZWN0XG5cdFx0XHRcdF90aGlzLmNicy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdHZhbHVlLnJlamVjdCgnY29ubmVjdGlvbiBjbG9zZWQnKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0X3RoaXMubWV0aG9kQ2JzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFsdWUucmVqZWN0KCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfdGhpcy5jYnMuY2xlYXIoKTtcblx0XHRcdFx0X3RoaXMubWV0aG9kQ2JzLmNsZWFyKCk7XG5cdFx0XHRcdF90aGlzLmNiSWQgPSAwO1xuXG5cdFx0XHRcdGlmIChfdGhpcy5zdGF0dXNDYWxsYmFjaykgX3RoaXMuc3RhdHVzQ2FsbGJhY2soXCJjbG9zZWRcIik7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5jYklkID0gMDtcblx0XHR0aGlzLmNicyA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLm1ldGhvZENicyA9IG5ldyBNYXAoKTtcblxuXHRcdGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzLmNsb3NlKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhXZWJTb2NrZXRScGMsIFt7XG5cdFx0a2V5OiBcImxpc3RlbmVyXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVyKG1lc3NhZ2UpIHtcblx0XHRcdHZhciBjYWxsYmFjayA9IHRoaXMuY2JzLmdldChtZXNzYWdlLmlkKTtcblx0XHRcdHZhciBtZXRob2RDYWxsYmFjayA9IHRoaXMubWV0aG9kQ2JzLmdldChtZXNzYWdlLmlkKTtcblxuXHRcdFx0aWYgKG1ldGhvZENhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMubWV0aG9kQ2JzLmRlbGV0ZShtZXNzYWdlLmlkKTtcblx0XHRcdFx0aWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlICYmIFwicmVqZWN0XCIgaW4gbWV0aG9kQ2FsbGJhY2spIHtcblx0XHRcdFx0XHRtZXRob2RDYWxsYmFjay5yZWplY3QobWVzc2FnZS5lcnJvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXCJyZXNvbHZlXCIgaW4gbWV0aG9kQ2FsbGJhY2spIHtcblx0XHRcdFx0XHRtZXRob2RDYWxsYmFjay5yZXNvbHZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuY2JzLmRlbGV0ZShtZXNzYWdlLmlkKTtcblx0XHRcdFx0aWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sucmVqZWN0KG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrLnJlc29sdmUobWVzc2FnZS5yZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImNhbGxcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FsbChwYXJhbXMpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcmVxdWVzdCA9IHtcblx0XHRcdFx0bWV0aG9kOiBcImNhbGxcIixcblx0XHRcdFx0cGFyYW1zOiBwYXJhbXMsXG5cdFx0XHRcdGlkOiB0aGlzLmNiSWQrK1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblxuXHRcdFx0XHRfdGhpczIuY2JzLnNldChyZXF1ZXN0LmlkLCB7XG5cdFx0XHRcdFx0dGltZTogbmV3IERhdGUoKSxcblx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChyZXF1ZXN0LnBhcmFtc1sxXSA9PT0gXCJicm9hZGNhc3RfdHJhbnNhY3Rpb25fd2l0aF9jYWxsYmFja1wiICYmIHJlcXVlc3QucGFyYW1zWzJdWzBdKSB7XG5cdFx0XHRcdFx0X3RoaXMyLm1ldGhvZENicy5zZXQocmVxdWVzdC5pZCwgcmVxdWVzdC5wYXJhbXNbMl1bMF0pO1xuXHRcdFx0XHRcdHJlcXVlc3QucGFyYW1zWzJdWzBdID0gcmVxdWVzdC5wYXJhbXNbMl1bMF0ucmVzb2x2ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF90aGlzMi53cy5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRfdGhpczIud3Muc2VuZChKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiZ2V0QXBpQnlOYW1lXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEFwaUJ5TmFtZShhcGkpIHtcblx0XHRcdHJldHVybiB0aGlzLmNhbGwoWzEsIFwiZ2V0X2FwaV9ieV9uYW1lXCIsIFthcGldXSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiBcImxvZ2luXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxvZ2luKHVzZXIsIHBhc3N3b3JkKSB7XG5cdFx0XHR2YXIgX3RoaXMzID0gdGhpcztcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29ubmVjdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczMuY2FsbChbMSwgXCJsb2dpblwiLCBbdXNlciwgcGFzc3dvcmRdXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiY2xvc2VcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnY2xvc2luZyB3cycpO1xuXHRcdFx0aWYgKHRoaXMud3MpIHtcblx0XHRcdFx0dGhpcy53cy5vbmNsb3NlKCk7XG5cdFx0XHRcdHRoaXMud3MuY2xvc2UoKTtcblx0XHRcdFx0dGhpcy53cyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFdlYlNvY2tldFJwYztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRScGM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL1dlYlNvY2tldFJwYy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDbGllbnQgPSByZXF1aXJlKFwiLi9BcGlJbnN0YW5jZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdENsaWVudDogQ2xpZW50XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBNSVQgTGljZW5zZTpcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiwgSm9lIFdhbG5lc1xuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qKlxuICogVGhpcyBiZWhhdmVzIGxpa2UgYSBXZWJTb2NrZXQgaW4gZXZlcnkgd2F5LCBleGNlcHQgaWYgaXQgZmFpbHMgdG8gY29ubmVjdCxcbiAqIG9yIGl0IGdldHMgZGlzY29ubmVjdGVkLCBpdCB3aWxsIHJlcGVhdGVkbHkgcG9sbCB1bnRpbCBpdCBzdWNjZXNzZnVsbHkgY29ubmVjdHNcbiAqIGFnYWluLlxuICpcbiAqIEl0IGlzIEFQSSBjb21wYXRpYmxlLCBzbyB3aGVuIHlvdSBoYXZlOlxuICogICB3cyA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vLi4uLicpO1xuICogeW91IGNhbiByZXBsYWNlIHdpdGg6XG4gKiAgIHdzID0gbmV3IFJlY29ubmVjdGluZ1dlYlNvY2tldCgnd3M6Ly8uLi4uJyk7XG4gKlxuICogVGhlIGV2ZW50IHN0cmVhbSB3aWxsIHR5cGljYWxseSBsb29rIGxpa2U6XG4gKiAgb25jb25uZWN0aW5nXG4gKiAgb25vcGVuXG4gKiAgb25tZXNzYWdlXG4gKiAgb25tZXNzYWdlXG4gKiAgb25jbG9zZSAvLyBsb3N0IGNvbm5lY3Rpb25cbiAqICBvbmNvbm5lY3RpbmdcbiAqICBvbm9wZW4gIC8vIHNvbWV0aW1lIGxhdGVyLi4uXG4gKiAgb25tZXNzYWdlXG4gKiAgb25tZXNzYWdlXG4gKiAgZXRjLi4uXG4gKlxuICogSXQgaXMgQVBJIGNvbXBhdGlibGUgd2l0aCB0aGUgc3RhbmRhcmQgV2ViU29ja2V0IEFQSSwgYXBhcnQgZnJvbSB0aGUgZm9sbG93aW5nIG1lbWJlcnM6XG4gKlxuICogLSBgYnVmZmVyZWRBbW91bnRgXG4gKiAtIGBleHRlbnNpb25zYFxuICogLSBgYmluYXJ5VHlwZWBcbiAqXG4gKiBMYXRlc3QgdmVyc2lvbjogaHR0cHM6Ly9naXRodWIuY29tL2pvZXdhbG5lcy9yZWNvbm5lY3Rpbmctd2Vic29ja2V0L1xuICogLSBKb2UgV2FsbmVzXG4gKlxuICogU3ludGF4XG4gKiA9PT09PT1cbiAqIHZhciBzb2NrZXQgPSBuZXcgUmVjb25uZWN0aW5nV2ViU29ja2V0KHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAqXG4gKiBQYXJhbWV0ZXJzXG4gKiA9PT09PT09PT09XG4gKiB1cmwgLSBUaGUgdXJsIHlvdSBhcmUgY29ubmVjdGluZyB0by5cbiAqIHByb3RvY29scyAtIE9wdGlvbmFsIHN0cmluZyBvciBhcnJheSBvZiBwcm90b2NvbHMuXG4gKiBvcHRpb25zIC0gU2VlIGJlbG93XG4gKlxuICogT3B0aW9uc1xuICogPT09PT09PVxuICogT3B0aW9ucyBjYW4gZWl0aGVyIGJlIHBhc3NlZCB1cG9uIGluc3RhbnRpYXRpb24gb3Igc2V0IGFmdGVyIGluc3RhbnRpYXRpb246XG4gKlxuICogdmFyIHNvY2tldCA9IG5ldyBSZWNvbm5lY3RpbmdXZWJTb2NrZXQodXJsLCBudWxsLCB7IGRlYnVnOiB0cnVlLCByZWNvbm5lY3RJbnRlcnZhbDogNDAwMCB9KTtcbiAqXG4gKiBvclxuICpcbiAqIHZhciBzb2NrZXQgPSBuZXcgUmVjb25uZWN0aW5nV2ViU29ja2V0KHVybCk7XG4gKiBzb2NrZXQuZGVidWcgPSB0cnVlO1xuICogc29ja2V0LnJlY29ubmVjdEludGVydmFsID0gNDAwMDtcbiAqXG4gKiBkZWJ1Z1xuICogLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2Ugc2hvdWxkIGxvZyBkZWJ1ZyBtZXNzYWdlcy4gQWNjZXB0cyB0cnVlIG9yIGZhbHNlLiBEZWZhdWx0OiBmYWxzZS5cbiAqXG4gKiBhdXRvbWF0aWNPcGVuXG4gKiAtIFdoZXRoZXIgb3Igbm90IHRoZSB3ZWJzb2NrZXQgc2hvdWxkIGF0dGVtcHQgdG8gY29ubmVjdCBpbW1lZGlhdGVseSB1cG9uIGluc3RhbnRpYXRpb24uIFRoZSBzb2NrZXQgY2FuIGJlIG1hbnVhbGx5IG9wZW5lZCBvciBjbG9zZWQgYXQgYW55IHRpbWUgdXNpbmcgd3Mub3BlbigpIGFuZCB3cy5jbG9zZSgpLlxuICpcbiAqIHJlY29ubmVjdEludGVydmFsXG4gKiAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdC4gQWNjZXB0cyBpbnRlZ2VyLiBEZWZhdWx0OiAxMDAwLlxuICpcbiAqIG1heFJlY29ubmVjdEludGVydmFsXG4gKiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC4gQWNjZXB0cyBpbnRlZ2VyLiBEZWZhdWx0OiAzMDAwMC5cbiAqXG4gKiByZWNvbm5lY3REZWNheVxuICogLSBUaGUgcmF0ZSBvZiBpbmNyZWFzZSBvZiB0aGUgcmVjb25uZWN0IGRlbGF5LiBBbGxvd3MgcmVjb25uZWN0IGF0dGVtcHRzIHRvIGJhY2sgb2ZmIHdoZW4gcHJvYmxlbXMgcGVyc2lzdC4gQWNjZXB0cyBpbnRlZ2VyIG9yIGZsb2F0LiBEZWZhdWx0OiAxLjUuXG4gKlxuICogdGltZW91dEludGVydmFsXG4gKiAtIFRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkIGJlZm9yZSBjbG9zaW5nIGFuZCByZXRyeWluZy4gQWNjZXB0cyBpbnRlZ2VyLiBEZWZhdWx0OiAyMDAwLlxuICpcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWwuUmVjb25uZWN0aW5nV2ViU29ja2V0ID0gZmFjdG9yeSgpO1xuICAgIH1cbn0pKHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuXG4gICAgLy9pZiAoISgnV2ViU29ja2V0JyBpbiB3aW5kb3cpKSB7XG4gICAgLy8gICAgcmV0dXJuO1xuICAgIC8vfVxuXG4gICAgdmFyIFdlYlNvY2tldDtcblxuICAgIGZ1bmN0aW9uIFJlY29ubmVjdGluZ1dlYlNvY2tldChvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBzZXR0aW5nc1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG5cbiAgICAgICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgaW5zdGFuY2Ugc2hvdWxkIGxvZyBkZWJ1ZyBtZXNzYWdlcy4gKi9cbiAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcblxuICAgICAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSB3ZWJzb2NrZXQgc2hvdWxkIGF0dGVtcHQgdG8gY29ubmVjdCBpbW1lZGlhdGVseSB1cG9uIGluc3RhbnRpYXRpb24uICovXG4gICAgICAgICAgICBhdXRvbWF0aWNPcGVuOiB0cnVlLFxuXG4gICAgICAgICAgICAvKiogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LiAqL1xuICAgICAgICAgICAgcmVjb25uZWN0SW50ZXJ2YWw6IDIwMDAsXG4gICAgICAgICAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LiAqL1xuICAgICAgICAgICAgbWF4UmVjb25uZWN0SW50ZXJ2YWw6IDMwMDAwMCxcbiAgICAgICAgICAgIC8qKiBUaGUgcmF0ZSBvZiBpbmNyZWFzZSBvZiB0aGUgcmVjb25uZWN0IGRlbGF5LiBBbGxvd3MgcmVjb25uZWN0IGF0dGVtcHRzIHRvIGJhY2sgb2ZmIHdoZW4gcHJvYmxlbXMgcGVyc2lzdC4gKi9cbiAgICAgICAgICAgIHJlY29ubmVjdERlY2F5OiAxLjUsXG5cbiAgICAgICAgICAgIC8qKiBUaGUgbWF4aW11bSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciBhIGNvbm5lY3Rpb24gdG8gc3VjY2VlZCBiZWZvcmUgY2xvc2luZyBhbmQgcmV0cnlpbmcuICovXG4gICAgICAgICAgICB0aW1lb3V0SW50ZXJ2YWw6IDIwMDAsXG5cbiAgICAgICAgICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzIHRvIG1ha2UuIFVubGltaXRlZCBpZiBudWxsLiAqL1xuICAgICAgICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IDEwMCxcblxuICAgICAgICAgICAgLyoqIFRoZSBiaW5hcnkgdHlwZSwgcG9zc2libGUgdmFsdWVzICdibG9iJyBvciAnYXJyYXlidWZmZXInLCBkZWZhdWx0ICdibG9iJy4gKi9cbiAgICAgICAgICAgIGJpbmFyeVR5cGU6ICdhcnJheWJ1ZmZlcicsXG5cbiAgICAgICAgICAgIC8qKiBEb24ndCByZWNvbm5lY3QgaWYgaWRsZSAobm8gdXNlciBhY3Rpdml0eSBhZnRlciBpZGxlVHJlc2hvbGQpLCBwYXNzIDAgdG8gYWx3YXlzIHJlY29ubmVjdCAqKi9cbiAgICAgICAgICAgIGlkbGVUcmVzaG9sZDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIFdlYlNvY2tldCA9IG9wdGlvbnMuV2ViU29ja2V0O1xuICAgICAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuQ09OTkVDVElORyA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuT1BFTiA9IFdlYlNvY2tldC5PUEVOO1xuICAgICAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuQ0xPU0lORyA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuQ0xPU0VEID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgaWYgKCFjb25zb2xlLmRlYnVnKSBjb25zb2xlLmRlYnVnID0gY29uc29sZS5sb2c7XG5cbiAgICAgICAgLy8gT3ZlcndyaXRlIGFuZCBkZWZpbmUgc2V0dGluZ3Mgd2l0aCBvcHRpb25zIGlmIHRoZXkgZXhpc3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBzZXR0aW5nc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5IHByb3BlcnRpZXNcblxuICAgICAgICAvKiogVGhlIFVSTCBhcyByZXNvbHZlZCBieSB0aGUgY29uc3RydWN0b3IuIFRoaXMgaXMgYWx3YXlzIGFuIGFic29sdXRlIFVSTC4gUmVhZCBvbmx5LiAqL1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuXG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGF0dGVtcHRlZCByZWNvbm5lY3RzIHNpbmNlIHN0YXJ0aW5nLCBvciB0aGUgbGFzdCBzdWNjZXNzZnVsIGNvbm5lY3Rpb24uIFJlYWQgb25seS4gKi9cbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgKiBDYW4gYmUgb25lIG9mOiBXZWJTb2NrZXQuQ09OTkVDVElORywgV2ViU29ja2V0Lk9QRU4sIFdlYlNvY2tldC5DTE9TSU5HLCBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgICAgICAqIFJlYWQgb25seS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBzdWItcHJvdG9jb2wgdGhlIHNlcnZlciBzZWxlY3RlZDsgdGhpcyB3aWxsIGJlIG9uZSBvZlxuICAgICAgICAgKiB0aGUgc3RyaW5ncyBzcGVjaWZpZWQgaW4gdGhlIHByb3RvY29scyBwYXJhbWV0ZXIgd2hlbiBjcmVhdGluZyB0aGUgV2ViU29ja2V0IG9iamVjdC5cbiAgICAgICAgICogUmVhZCBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG5cbiAgICAgICAgLy8gUHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZXNcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB3cztcbiAgICAgICAgdmFyIGZvcmNlZENsb3NlID0gZmFsc2U7XG4gICAgICAgIHZhciB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0ge1xuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQubmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9OyAvL2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIC8vIFdpcmUgdXAgXCJvbipcIiBwcm9wZXJ0aWVzIGFzIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5vbm9wZW4oZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYub25jbG9zZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW5nJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9uY29ubmVjdGluZyhldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9ubWVzc2FnZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5vbmVycm9yKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRXhwb3NlIHRoZSBBUEkgcmVxdWlyZWQgYnkgRXZlbnRUYXJnZXRcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyLmJpbmQoZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZXZlbnRUYXJnZXQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50LmJpbmQoZXZlbnRUYXJnZXQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhbiBldmVudCB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBzdGFuZGFyZFxuICAgICAgICAgKiBjb21wbGlhbnQgYnJvd3NlcnMgYW5kIElFOSAtIElFMTFcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIHByZXZlbnQgdGhlIGVycm9yOlxuICAgICAgICAgKiBPYmplY3QgZG9lc24ndCBzdXBwb3J0IHRoaXMgYWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTkzNDUzOTIvd2h5LWFyZW50LW15LXBhcmFtZXRlcnMtZ2V0dGluZy1wYXNzZWQtdGhyb3VnaC10by1hLWRpc3BhdGNoZWQtZXZlbnQvMTkzNDU1NjMjMTkzNDU1NjNcbiAgICAgICAgICogQHBhcmFtIHMgU3RyaW5nIFRoZSBuYW1lIHRoYXQgdGhlIGV2ZW50IHNob3VsZCB1c2VcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgT2JqZWN0IGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IHRoZSBldmVudCB3aWxsIHVzZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVFdmVudChzLCBhcmdzKSB7XG4gICAgICAgICAgICAvL3ZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgLy9ldnQuaW5pdEN1c3RvbUV2ZW50KHMsIGZhbHNlLCBmYWxzZSwgYXJncyk7XG4gICAgICAgICAgICAvL3JldHVybiBldnQ7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBzIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5wZW5kaW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHNlbGYuaWRsZVNpbmNlID0gbmV3IERhdGUoKTtcblxuICAgICAgICBpZiAodGhpcy5pZGxlVHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQub25rZXlwcmVzcyA9IGRvY3VtZW50Lm9ubW91c2Vtb3ZlID0gZG9jdW1lbnQub25jbGljayA9IGRvY3VtZW50Lm9uc2Nyb2xsID0gZG9jdW1lbnQudG91Y2hzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pZGxlU2luY2UgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5wZW5kaW5nUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBlbmRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHNlbGYucmVjb25uZWN0SW50ZXJ2YWwgKiBNYXRoLnBvdyhzZWxmLnJlY29ubmVjdERlY2F5LCBzZWxmLnJlY29ubmVjdEF0dGVtcHRzKTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0ID4gc2VsZi5tYXhSZWNvbm5lY3RJbnRlcnZhbCA/IHNlbGYubWF4UmVjb25uZWN0SW50ZXJ2YWwgOiB0aW1lb3V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdXZWJTb2NrZXQ6IHdpbGwgdHJ5IHRvIHJlY29ubmVjdCBpbiAnICsgcGFyc2VJbnQodGltZW91dCAvIDEwMDApICsgJyBzZWMsIGF0dGVtcHQgIycgKyAoc2VsZi5yZWNvbm5lY3RBdHRlbXB0cyArIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICBzZWxmLm9wZW4odHJ1ZSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiAocmVjb25uZWN0QXR0ZW1wdCkge1xuICAgICAgICAgICAgaWYgKHJlY29ubmVjdEF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cyAmJiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID4gdGhpcy5tYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGdlbmVyYXRlRXZlbnQoJ2Nvbm5lY3RpbmcnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdXJsID0gc2VsZi51cmw7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLnVybCkpIHtcbiAgICAgICAgICAgICAgICBzdXJsID0gc2VsZi51cmxbdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyAlIHNlbGYudXJsLmxlbmd0aF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnY29ubmVjdGluZyB0bycsIHN1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3MgPSBuZXcgV2ViU29ja2V0KHN1cmwpO1xuICAgICAgICAgICAgd3MuYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVjb25uZWN0aW5nV2ViU29ja2V0JywgJ2F0dGVtcHQtY29ubmVjdCcsIHNlbGYudXJsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxvY2FsV3MgPSB3cztcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCcsICdjb25uZWN0aW9uLXRpbWVvdXQnLCBzZWxmLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2NhbFdzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGltZWRPdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sIHNlbGYudGltZW91dEludGVydmFsKTtcblxuICAgICAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnIHx8IFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQqKicsICdvbm9wZW4nLCBzZWxmLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYucHJvdG9jb2wgPSB3cy5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICBzZWxmLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGdlbmVyYXRlRXZlbnQoJ29wZW4nKTtcbiAgICAgICAgICAgICAgICBlLmlzUmVjb25uZWN0ID0gcmVjb25uZWN0QXR0ZW1wdDtcbiAgICAgICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29kZSAhPT0gMTAwMCAmJiBzZWxmLmRlYnVnKSBjb25zb2xlLmxvZygnV0FSTklORyEgd3MgY29ubmVjdGlvbicsIHN1cmwsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgd3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZWRDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGdlbmVyYXRlRXZlbnQoJ2Nsb3NlJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGdlbmVyYXRlRXZlbnQoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgZS5jb2RlID0gZXZlbnQuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgZS5yZWFzb24gPSBldmVudC5yZWFzb247XG4gICAgICAgICAgICAgICAgICAgIGUud2FzQ2xlYW4gPSBldmVudC53YXNDbGVhbjtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNvbm5lY3RBdHRlbXB0ICYmICF0aW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVjb25uZWN0aW5nV2ViU29ja2V0JywgJ29uY2xvc2UnLCBzZWxmLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGdlbmVyYXRlRXZlbnQoJ2Nsb3NlJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmlkbGVUcmVzaG9sZCB8fCBuZXcgRGF0ZSgpIC0gc2VsZi5pZGxlU2luY2UgPCBzZWxmLmlkbGVUcmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnaWRsZSAtIHdpbGwgcmVjb25uZWN0IGxhdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnBlbmRpbmdSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnIHx8IFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnb25tZXNzYWdlJywgc2VsZi51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZSA9IGdlbmVyYXRlRXZlbnQoJ21lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBlLmRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnIHx8IFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnb25lcnJvcicsIHNlbGYudXJsLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudChldmVudCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBjcmVhdGUgYSB3ZWJzb2NrZXQgdXBvbiBpbnN0YW50aWF0aW9uXG4gICAgICAgIGlmICh0aGlzLmF1dG9tYXRpY09wZW4gPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFuc21pdHMgZGF0YSB0byB0aGUgc2VydmVyIG92ZXIgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSBhIHRleHQgc3RyaW5nLCBBcnJheUJ1ZmZlciBvciBCbG9iIHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVjb25uZWN0aW5nV2ViU29ja2V0JywgJ3NlbmQnLCBzZWxmLnVybCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnSU5WQUxJRF9TVEFURV9FUlIgOiBQYXVzaW5nIHRvIHJlY29ubmVjdCB3ZWJzb2NrZXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIG9yIGNvbm5lY3Rpb24gYXR0ZW1wdCwgaWYgYW55LlxuICAgICAgICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBhbHJlYWR5IENMT1NFRCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgQ0xPU0VfTk9STUFMIGNvZGVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29kZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSAxMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yY2VkQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHdzKSB7XG4gICAgICAgICAgICAgICAgd3MuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBwdWJsaWMgQVBJIG1ldGhvZCB0byByZWZyZXNoIHRoZSBjb25uZWN0aW9uIGlmIHN0aWxsIG9wZW4gKGNsb3NlLCByZS1vcGVuKS5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBhcHAgc3VzcGVjdHMgYmFkIGRhdGEgLyBtaXNzZWQgaGVhcnQgYmVhdHMsIGl0IGNhbiB0cnkgdG8gcmVmcmVzaC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uJ3MgcmVhZHlTdGF0ZSBjaGFuZ2VzIHRvIE9QRU47XG4gICAgICogdGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyByZWFkeSB0byBzZW5kIGFuZCByZWNlaXZlIGRhdGEuXG4gICAgICovXG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHt9O1xuICAgIC8qKiBBbiBldmVudCBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24ncyByZWFkeVN0YXRlIGNoYW5nZXMgdG8gQ0xPU0VELiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge307XG4gICAgLyoqIEFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIGEgY29ubmVjdGlvbiBiZWdpbnMgYmVpbmcgYXR0ZW1wdGVkLiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25jb25uZWN0aW5nID0gZnVuY3Rpb24gKGV2ZW50KSB7fTtcbiAgICAvKiogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci4gKi9cbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge307XG4gICAgLyoqIEFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy4gKi9cbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHt9O1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbGwgaW5zdGFuY2VzIG9mIFJlY29ubmVjdGluZ1dlYlNvY2tldCBzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzLlxuICAgICAqIFNldHRpbmcgdGhpcyB0byB0cnVlIGlzIHRoZSBlcXVpdmFsZW50IG9mIHNldHRpbmcgYWxsIGluc3RhbmNlcyBvZiBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWcgdG8gdHJ1ZS5cbiAgICAgKi9cbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwgPSBmYWxzZTtcblxuICAgIHJldHVybiBSZWNvbm5lY3RpbmdXZWJTb2NrZXQ7XG59KTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvcmVjb25uZWN0aW5nLXdlYnNvY2tldC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbkR1cGxleC5wcm90b3R5cGUud3JpdGUgPSBXcml0YWJsZS5wcm90b3R5cGUud3JpdGU7XG5EdXBsZXgucHJvdG90eXBlLmVuZCA9IFdyaXRhYmxlLnByb3RvdHlwZS5lbmQ7XG5EdXBsZXgucHJvdG90eXBlLl93cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGU7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfSk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9wYXNzdGhyb3VnaC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IG4gPT09IG51bGwpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgIWVyKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHNldEltbWVkaWF0ZShlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgLy8gY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgZW1pdCByZW1vdmVzIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgdmFyIGVyckxpc3RlbmVycyA9IEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJyk7XG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBpZiAoZXJyTGlzdGVuZXJzID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIGRlc3Qub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdC5hcHBseShzZWxmLCBldiwgeCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3JlYWRhYmxlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleC5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvdHJhbnNmb3JtLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbnZhciBpc1VpbnQ4QXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5J1xuICB9XG47XG52YXIgaXNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIH1cbiAgOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInXG4gIH1cbjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtLkR1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgaXNVaW50OEFycmF5KGNodW5rKSlcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmspO1xuICBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShjaHVuaykpO1xuICBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgc3RhdGUubmVlZERyYWluID0gIXJldDtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHNldEltbWVkaWF0ZShjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3dyaXRhYmxlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWxcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5yZXF1aXJlKCcuL3Bvc3RzJylcbi8vcmVxdWlyZSgnc3RlZW1qcy1saWInKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfOGI5NDk2MGUuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcblx0YXBwLmNvbnN0YW50KCdBUElfRU5EX1BPSU5UJywnaHR0cDovL2FwaS5lc3RlZW0ud3M6ODA4MCcpO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Bvc3RzL2NvbmZpZy5qc1wiLFwiL3Bvc3RzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBwKSB7XG4vL2FuZ3VsYXIubW9kdWxlKCdzdGVlbS5jb250cm9sbGVycycsIFtdKVxuXG5hcHAuY29udHJvbGxlcignQXBwQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJGlvbmljTW9kYWwsICR0aW1lb3V0LCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY0hpc3RvcnksICRjb3Jkb3ZhU29jaWFsU2hhcmluZywgSW1hZ2VVcGxvYWRTZXJ2aWNlLCAkY29yZG92YUNhbWVyYSwgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZSwgJGlvbmljUGxhdGZvcm0sICRmaWx0ZXIsIEFQSXMsICR3aW5kb3csICRpb25pY1BvcG92ZXIpIHtcblxuICAkc2NvcGUubG9naW5EYXRhID0ge307XG5cbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvbG9naW4uaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgJHNjb3BlLmxvZ2luTW9kYWwgPSBtb2RhbDtcbiAgfSk7XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9wb3BvdmVyLmh0bWwnLCB7XG4gICAgc2NvcGU6ICRzY29wZSxcbiAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyID0gcG9wb3ZlcjtcbiAgfSk7XG5cbiAgJHNjb3BlLm9wZW5NZW51UG9wb3ZlciA9IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5zaG93KCRldmVudCk7XG4gIH07XG4gICRzY29wZS5jbG9zZU1lbnVQb3BvdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgfTtcblxuICAkcm9vdFNjb3BlLiRvbignY2xvc2U6cG9wb3ZlcicsIGZ1bmN0aW9uKCl7XG4gICAgY29uc29sZS5sb2coJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAkc2NvcGUubWVudXBvcG92ZXIuaGlkZSgpO1xuXG4gICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICB9KTtcbiAgICAvLyRzY29wZS5jbG9zZU1lbnVQb3BvdmVyKCk7XG4gICAgLy8kc2NvcGUuZmV0Y2hQb3N0cygpO1xuICB9KTtcblxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5yZW1vdmUoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLmNoYW5nZVVzZXJuYW1lID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lID0gYW5ndWxhci5sb3dlcmNhc2UoJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZSk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfVxuICAkc2NvcGUub3BlbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpdGVtLmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKGl0ZW0uanNvbl9tZXRhZGF0YSk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IGl0ZW07XG4gICAgLy9jb25zb2xlLmxvZyhpdGVtKTtcblxuICAgIC8vJHN0YXRlLmdvKCdhcHAuc2luZ2xlJyk7Ki9cbiAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0Jywge2NhdGVnb3J5OiBpdGVtLmNhdGVnb3J5LCBhdXRob3I6IGl0ZW0uYXV0aG9yLCBwZXJtbGluazogaXRlbS5wZXJtbGlua30pO1xuICB9O1xuXG4gICRyb290U2NvcGUuJG9uKCdvcGVuQ29tbWVudHMnLCBmdW5jdGlvbihlLCBhcmdzKSB7XG4gICAgJHNjb3BlLm9wZW4oYXJncy5kYXRhKTtcbiAgfSk7XG5cblxuICAkc2NvcGUuYWR2YW5jZWRDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbigkc2NvcGUubG9naW5EYXRhLmFkdmFuY2VkKSk7XG4gICAgaWYgKCRzY29wZS5sb2dpbkRhdGEuYWR2YW5jZWQpIHtcbiAgICAgICRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQgPSBudWxsO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuY2xvc2VMb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5sb2dpbk1vZGFsLmhpZGUoKTtcbiAgfTtcbiAgXG4gICRzY29wZS5vcGVuU2lnblVQID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLmNoYWludXJsID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbj09J3N0ZWVtJz8naHR0cHM6Ly9zdGVlbWl0LmNvbS9jcmVhdGVfYWNjb3VudCc6J2h0dHBzOi8vZ29sb3MuaW8vY3JlYXRlX2FjY291bnQnO1xuICAgIHdpbmRvdy5vcGVuKCRzY29wZS5jaGFpbnVybCwgJ19ibGFuaycsICdsb2NhdGlvbj15ZXMnKTtcbiAgICByZXR1cm4gZmFsc2U7ICBcbiAgfVxuICAkc2NvcGUub3BlbkxvZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UgPT0gJ3J1LVJVJykge1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IFwiZ29sb3NcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IFwic3RlZW1cIjtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5sb2dpbk1vZGFsLnNob3coKTtcbiAgICB9LCAxKTtcbiAgfTtcbiAgJHNjb3BlLmdvUHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICRzdGF0ZS5nbyhcImFwcC5wcm9maWxlXCIsIHt1c2VybmFtZTokcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9KTtcbiAgICAvLyRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICB9XG4gICRzY29wZS5zaGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBob3N0ID0gXCJcIjtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSAnc3RlZW0nKSB7XG4gICAgICBob3N0ID0gXCJodHRwczovL3N0ZWVtaXQuY29tL1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0ID0gXCJodHRwczovL2dvbG9zLmlvL1wiO1xuICAgIH1cbiAgICB2YXIgbGluayA9IGhvc3QrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5jYXRlZ29yeStcIi9AXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5hdXRob3IrXCIvXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGluaztcbiAgICB2YXIgbWVzc2FnZSA9IFwiSGV5ISBDaGVja291dCBibG9nIHBvc3Qgb24gU3RlZW0gXCIrbGluaztcbiAgICB2YXIgc3ViamVjdCA9IFwiVmlhIGVTdGVlbSBNb2JpbGVcIjtcbiAgICB2YXIgZmlsZSA9IG51bGw7XG4gICAgJGNvcmRvdmFTb2NpYWxTaGFyaW5nLnNoYXJlKG1lc3NhZ2UsIHN1YmplY3QsIGZpbGUsIGxpbmspIC8vIFNoYXJlIHZpYSBuYXRpdmUgc2hhcmUgc2hlZXRcbiAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIC8vIFN1Y2Nlc3MhXG4gICAgICAkcm9vdFNjb3BlLmxvZyhcInNoYXJlZFwiKTtcbiAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIC8vIEFuIGVycm9yIG9jY3VyZWQuIFNob3cgYSBtZXNzYWdlIHRvIHRoZSB1c2VyXG4gICAgICAkcm9vdFNjb3BlLmxvZyhcIm5vdCBzaGFyZWRcIik7XG4gICAgfSk7XG4gIH1cblxuXG4gICRzY29wZS5sb2dpbkNoYWluID0gZnVuY3Rpb24oeCl7XG4gICAgY29uc29sZS5sb2coeCk7XG4gICAgJHNjb3BlLmxvZ2luRGF0YS5jaGFpbiA9IHg7XG5cbiAgfVxuICBcbiAgJHNjb3BlLmRvTG9naW4gPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZygnRG9pbmcgbG9naW4nKTtcbiAgICBpZiAoJHNjb3BlLmxvZ2luRGF0YS5wYXNzd29yZCB8fCAkc2NvcGUubG9naW5EYXRhLnByaXZhdGVQb3N0aW5nS2V5KSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZSA9ICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUudHJpbSgpO1xuICAgICAgY29uc29sZS5sb2coJ2RvTG9naW4nKyRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUrJHNjb3BlLmxvZ2luRGF0YS5wYXNzd29yZCk7XG4gICAgICBcbiAgICAgIGlmICgkc2NvcGUubG9naW5EYXRhLmNoYWluICE9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuY2xvc2UoKTtcbiAgICAgICAgd2luZG93LkFwaSA9IG51bGw7XG4gICAgICAgIHdpbmRvdy5zdGVlbVJQQy5DbGllbnQuY2xvc2UoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHNjb3BlLmxvZ2luRGF0YS5jaGFpbl07XG4gICAgICAgIC8vY29uc29sZS5sb2coc29ja2V0VXJsKTtcblxuICAgICAgICB3aW5kb3cuQXBpID0gd2luZG93LnN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpzb2NrZXRVcmx9LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbWyRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWVdXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgICBkZCA9IGRkWzBdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGQpO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5pZCA9IGRkLmlkO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5vd25lciA9IGRkLm93bmVyO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5hY3RpdmUgPSBkZC5hY3RpdmU7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLnJlcHV0YXRpb24gPSBkZC5yZXB1dGF0aW9uO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5wb3N0aW5nID0gZGQucG9zdGluZztcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEubWVtb19rZXkgPSBkZC5tZW1vX2tleTtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEucG9zdF9jb3VudCA9IGRkLnBvc3RfY291bnQ7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLnZvdGluZ19wb3dlciA9IGRkLnZvdGluZ19wb3dlcjtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEud2l0bmVzc192b3RlcyA9IGRkLndpdG5lc3Nfdm90ZXM7XG4gICAgICAgICAgICAkc2NvcGUubG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLmxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRzY29wZS5sb2dpbkRhdGEucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiBkZC5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHNjb3BlLmxvZ2luRGF0YS5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmICghbG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTU1dPUkRfSU5DT1JSRUNUJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gJHNjb3BlLmxvZ2luRGF0YTtcbiAgICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YSA9IHt9O1xuICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2ID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vyc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmICh2LnVzZXJuYW1lID09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAmJiB2LmNoYWluID09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5jaGFpbil7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLnB1c2goJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKTsgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubXlsb2dpbiA9ICRzY29wZS5sb2dpbjtcbiAgICAgICAgICAgICAgQVBJcy51cGRhdGVTdWJzY3JpcHRpb24oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCB7ZGV2aWNlOiBpb25pYy5QbGF0Zm9ybS5wbGF0Zm9ybSgpLCB0aW1lc3RhbXA6ICRmaWx0ZXIoJ2RhdGUnKShuZXcgRGF0ZSgpLCAnbWVkaXVtJyksIGFwcHZlcnNpb246ICRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbn0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICRzY29wZS5sb2dpbk1vZGFsLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiAhPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluOyAgXG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZWRDaGFpbicpO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3ksIGVuZm9yY2U6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyx7cmVuZXc6dHJ1ZX0se3JlbG9hZDogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmZXRjaFBvc3RzJyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKmlmKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCA1MDApO1xuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5sb2dpbk1vZGFsLmhpZGUoKTtcbiAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0QWNjb3VudCA9IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSB1c2VyO1xuICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgIGRpc2FibGVCYWNrOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gIT09IHVzZXIuY2hhaW4pIHtcbiAgICAgICRzY29wZS5kYXRhID0ge307XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID0gdXNlci5jaGFpbjsgIFxuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ2hhaW4nKTtcbiAgICB9XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZEN1cnJlbmN5Jywge2N1cnJlbmN5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5LCBlbmZvcmNlOiB0cnVlfSk7XG4gICAgXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7ICBcbiAgICB9LCAxMDApO1xuICAgIFxuICAgIFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyx7cmVuZXc6dHJ1ZX0se3JlbG9hZDogdHJ1ZX0pO1xuICAgIH0sIDUwMCk7XG4gIH1cblxuICAkcm9vdFNjb3BlLiRvbigncmVmcmVzaExvY2FsVXNlckRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZygncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuY2hhaW4gPT0gJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbikge1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkFwaS5kYXRhYmFzZV9hcGkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbIFsgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lIF0gXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgICBkZCA9IGRkWzBdO1xuICAgICAgICAgICAgaWYgKGRkICYmIGRkLmpzb25fbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgZGQuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oZGQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmd1bGFyLm1lcmdlKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciwgZGQpO1xuXG4gICAgICAgICAgICAkc2NvcGUubWNzcyA9ICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpID8geydiYWNrZ3JvdW5kJzogJ3VybCgnKyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pXG5cbiAgJHNjb3BlLm9wZW5Qb3N0TW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycpO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnb3BlblBvc3RNb2RhbCcpO1xuICB9XG5cbiAgJHNjb3BlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbih2aWV3KSB7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3ID0gdmlldztcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZVZpZXcnKTtcbiAgfVxuICAkc2NvcGUuY2hhbmdlTGlnaHQgPSBmdW5jdGlvbihsaWdodCkge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGhlbWUgPSBsaWdodDtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZUxpZ2h0Jyk7XG4gIH1cblxuICAkc2NvcGUuJG9uKFwiJGlvbmljVmlldy5lbnRlclwiLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAkc2NvcGUudGhlbWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnRoZW1lO1xuICB9KTtcblxuICAvLyBnZXQgYXBwIHZlcnNpb25cbiAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKXtcbiAgICBpZiAod2luZG93LmNvcmRvdmEpIHtcbiAgICAgIGNvcmRvdmEuZ2V0QXBwVmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uID0gJzEuNC4xJztcbiAgICB9XG4gIH0pO1xuXG4gICRzY29wZS5sb2dvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHYgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzW2ldO1xuICAgICAgaWYgKHYuY2hhaW4gPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluICYmIHYudXNlcm5hbWUgPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMuc3BsaWNlKGksMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5sZW5ndGg+MSkge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vyc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gdW5kZWZpbmVkO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gbnVsbDtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubXlsb2dpbiA9IHVuZGVmaW5lZDtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubXlsb2dpbiA9IG51bGw7XG4gICAgfVxuICAgIC8vbWFrZSBzdXJlIHVzZXIgY3JlZGVudGlhbHMgY2xlYXJlZC5cbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkge1xuICAgICAgQVBJcy5kZWxldGVTdWJzY3JpcHRpb24oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnID0gdW5kZWZpbmVkO1xuXG4gICAgJGlvbmljSGlzdG9yeS5jbGVhckNhY2hlKCk7XG4gICAgJGlvbmljSGlzdG9yeS5jbGVhckhpc3RvcnkoKTtcbiAgfTtcbiAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvc2VhcmNoLmh0bWwnLCB7XG4gICAgc2NvcGU6ICRzY29wZSxcbiAgICBhbmltYXRpb246ICdzbGlkZS1pbi1kb3duJ1xuICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgJHNjb3BlLnNtb2RhbCA9IG1vZGFsO1xuICB9KTtcblxuICAvLyBUcmlnZ2VyZWQgaW4gdGhlIGxvZ2luIG1vZGFsIHRvIGNsb3NlIGl0XG4gICRzY29wZS5jbG9zZVNtb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5zbW9kYWwuaGlkZSgpO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gT3BlbiB0aGUgbG9naW4gbW9kYWxcbiAgJHNjb3BlLm9wZW5TbW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAvL2lmKCEkc2NvcGUuc21vZGFsKSByZXR1cm47XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5kYXRhLnR5cGU9XCJ0YWdcIjtcbiAgICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IFtdO1xuICAgICAgJHNjb3BlLnNtb2RhbC5zaG93KCk7XG4gICAgfSwgNSk7XG4gIH07XG4gICRzY29wZS5jbGVhclNlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgPSB1bmRlZmluZWQ7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZ2xpbWl0cyA9IHVuZGVmaW5lZDtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmZXRjaFBvc3RzJyk7XG4gICAgfVxuICB9O1xuICAkc2NvcGUuc2hvd01lRXh0cmEgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJHNjb3BlLnNob3dFeHRyYSkge1xuICAgICAgJHNjb3BlLnNob3dFeHRyYSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuc2hvd0V4dHJhID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgJHNjb3BlLnNlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKCdEb2luZyBzZWFyY2ggJyskc2NvcGUuZGF0YS5zZWFyY2gpO1xuICAgICRzY29wZS5kYXRhLnNlYXJjaCA9IGFuZ3VsYXIubG93ZXJjYXNlKCRzY29wZS5kYXRhLnNlYXJjaCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmICgkc2NvcGUuZGF0YS5zZWFyY2gubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoJHNjb3BlLmRhdGEudHlwZSA9PSBcInRhZ1wiKXtcbiAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF90cmVuZGluZ190YWdzXCIsIFskc2NvcGUuZGF0YS5zZWFyY2gsIDE1XSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgICAgICB2YXIgZWUgPSBbXTtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICAgICAgICAvKmlmIChyZXN1bHQpe1xuICAgICAgICAgICAgICAgIHZhciBsbCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxsIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0ubmFtZS5pbmRleE9mKCRzY29wZS5kYXRhLnNlYXJjaCkgPiAtMSl7XG4gICAgICAgICAgICAgICAgICAgIGVlLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gZWU7XG4gICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgPT0gXCJ1c2VyXCIpe1xuICAgICAgICAgIHZhciBlZSA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwibG9va3VwX2FjY291bnRzXCIsIFskc2NvcGUuZGF0YS5zZWFyY2gsIDE1XSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgICAgICBpZiAocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSwgNSk7XG5cbiAgfTtcbiAgJHNjb3BlLnR5cGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLmxvZyhcImNoYW5naW5nIHNlYXJjaCB0eXBlXCIpO1xuICB9XG4gICRzY29wZS5vcGVuVGFnID0gZnVuY3Rpb24oeHgsIHl5KSB7XG4gICAgJHJvb3RTY29wZS5sb2coXCJvcGVuaW5nIHRhZyBcIit4eCk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgPSB4eDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjcmVhdGVkJztcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZ2xpbWl0cyA9IHl5O1xuICAgIGlmICgkc2NvcGUuc21vZGFsLmlzU2hvd24oKSl7XG4gICAgICAkc2NvcGUuY2xvc2VTbW9kYWwoKTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAkc3RhdGUuZ28oXCJhcHAucG9zdHNcIiwge3RhZ3M6IHh4fSk7XG4gIH07XG4gICRzY29wZS5vcGVuVXNlciA9IGZ1bmN0aW9uKHh5KSB7XG4gICAgJHJvb3RTY29wZS5sb2coXCJvcGVuaW5nIHVzZXIgXCIreHkpO1xuICAgICRzY29wZS5jbG9zZVNtb2RhbCgpO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzdGF0ZS5nbyhcImFwcC5wcm9maWxlXCIsIHt1c2VybmFtZTogeHl9KTtcbiAgfTtcbiAgJHNjb3BlLnRlc3RmdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjY291bnRfaGlzdG9yeVwiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAtMSwgMjVdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzcG9uc2UpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn0pXG5cbmFwcC5jb250cm9sbGVyKCdTZW5kQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHJvb3RTY29wZSwgJHN0YXRlLCAkaW9uaWNQb3B1cCwgJGlvbmljUG9wb3ZlciwgJGludGVydmFsLCAkZmlsdGVyLCAkcSwgJHRpbWVvdXQsICRjb3Jkb3ZhQmFyY29kZVNjYW5uZXIsICRpb25pY1BsYXRmb3JtLCAkaW9uaWNNb2RhbCwgQVBJcykge1xuXG4gIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09IFwic3RlZW1cIikge1xuICAgICRzY29wZS5kYXRhID0ge3R5cGVzOiBbe3R5cGU6IFwic3RlZW1cIiwgbmFtZTpcIlN0ZWVtXCIsIGlkOjF9LHt0eXBlOiBcInNiZFwiLCBuYW1lOlwiU3RlZW0gRG9sbGFyXCIsIGlkOjJ9LCB7dHlwZTogXCJzcFwiLCBuYW1lOlwiU3RlZW0gUG93ZXJcIiwgaWQ6M31dLCB0eXBlOiBcInN0ZWVtXCIsIGFtb3VudDogMC4wMDEsIGV0eXBlczogW3t0eXBlOiBcImFwcHJvdmVcIiwgbmFtZTogJGZpbHRlcigndHJhbnNsYXRlJykoXCJBUFBST1ZFXCIpLCBpZDoxfSx7dHlwZTogXCJkaXNwdXRlXCIsIG5hbWU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKFwiRElTUFVURVwiKSwgaWQ6Mn0se3R5cGU6IFwicmVsZWFzZVwiLCBuYW1lOiAkZmlsdGVyKCd0cmFuc2xhdGUnKShcIlJFTEVBU0VcIiksIGlkOjN9XX07XG4gIH0gZWxzZSB7XG4gICAgJHNjb3BlLmRhdGEgPSB7dHlwZXM6IFt7dHlwZTogXCJnb2xvc1wiLCBuYW1lOiBcItCT0J7Qm9Ce0KFcIiwgaWQ6MX0se3R5cGU6IFwiZ2JnXCIsIG5hbWU6XCLQl9Ce0JvQntCi0J7QmVwiLCBpZDoyfSwge3R5cGU6IFwiZ29sb3NwXCIsIG5hbWU6XCLQodCY0JvQkCDQk9Ce0JvQntCh0JBcIiwgaWQ6M31dLCB0eXBlOiBcImdvbG9zXCIsIGFtb3VudDogMC4wMDEsIGV0eXBlczogW3t0eXBlOiBcImFwcHJvdmVcIiwgbmFtZTogJGZpbHRlcigndHJhbnNsYXRlJykoXCJBUFBST1ZFXCIpLCBpZDoxfSx7dHlwZTogXCJkaXNwdXRlXCIsIG5hbWU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKFwiRElTUFVURVwiKSwgaWQ6Mn0se3R5cGU6IFwicmVsZWFzZVwiLCBuYW1lOiAkZmlsdGVyKCd0cmFuc2xhdGUnKShcIlJFTEVBU0VcIiksIGlkOjN9XX07XG4gIH1cbiAgJHNjb3BlLnR0eXBlID0gJ3RyYW5zZmVyJztcbiAgJHNjb3BlLmNoYW5nZVRyYW5zZmVyID0gZnVuY3Rpb24odHlwZSl7XG4gICAgJHNjb3BlLnR0eXBlID0gdHlwZTtcbiAgICAkc2NvcGUuZGF0YS5hZHZhbmNlZCA9IGZhbHNlO1xuICB9XG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgnbXktbW9kYWwuaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlLFxuICAgIGFuaW1hdGlvbjogJ3NsaWRlLWluLXVwJ1xuICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgJHNjb3BlLm1vZGFsID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUub3BlblVNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tb2RhbC5zaG93KCk7XG4gIH07XG4gICRzY29wZS5jbG9zZVVNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gIH07XG4gIC8vIENsZWFudXAgdGhlIG1vZGFsIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tb2RhbC5yZW1vdmUoKTtcbiAgfSk7XG4gIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIGhpZGUgbW9kYWxcbiAgJHNjb3BlLiRvbignbW9kYWwuaGlkZGVuJywgZnVuY3Rpb24oKSB7XG4gICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgfSk7XG4gICRzY29wZS5zaG93TGlxdWlkID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnR5cGUgIT09ICRmaWx0ZXIoJ2xvd2VyY2FzZScpKCRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCk7XG4gIH1cbiAgJHNjb3BlLnNlYXJjaFVzZXIgPSBmdW5jdGlvbihxdWVyeSkge1xuICAgIHJldHVybiB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJsb29rdXBfYWNjb3VudHNcIiwgW3F1ZXJ5LCAxNV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAkc2NvcGUuc2VsZWN0QWdlbnQgPSBmdW5jdGlvbihhZ2VudCkge1xuICAgICRzY29wZS5kYXRhLmFnZW50ID0gYWdlbnQ7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUuY2xvc2VVTW9kYWwoKTtcbiAgfVxuICAkc2NvcGUuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24ocXVlcnkpe1xuICAgIHF1ZXJ5ID0gYW5ndWxhci5sb3dlcmNhc2UocXVlcnkpO1xuICAgICRzY29wZS5yZXMgPSBbXTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwibG9va3VwX2FjY291bnRfbmFtZXNcIiwgW1txdWVyeV1dKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXNwb25zZSlcbiAgICAgICAgdmFyIGRkID0gcmVzcG9uc2VbMF07XG4gICAgICAgIGlmIChkZCAmJiBkZC5qc29uX21ldGFkYXRhKSB7XG4gICAgICAgICAgdmFyIHZ2ID0gYW5ndWxhci5mcm9tSnNvbihkZC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICBpZiAodnYuZXNjcm93KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXNjcm93Jyk7XG4gICAgICAgICAgICAkc2NvcGUucmVzLnB1c2goe25hbWU6IHF1ZXJ5LCBlc2Nyb3c6IHZ2LmVzY3Jvd30pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm9lc2Nyb3cnKTtcbiAgICAgICAgICAgICRzY29wZS5yZXMucHVzaCh7bmFtZTogcXVlcnksIGVzY3Jvdzoge3Rlcm1zOiBcIi1cIiwgZmVlczoge1wiU1RFRU1cIjogMC4wMDEsIFwiU0JEXCI6IDAuMDAxLCBcIkdCR1wiOiAwLjAwMSwgXCJHT0xPU1wiOiAwLjAwMX19IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChxdWVyeSAmJiAkc2NvcGUucmVzKSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gJHNjb3BlLnJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSBbXTsgIFxuICAgICAgICB9XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMCk7ICAgXG4gICAgfVxuICB9XG4gICRzY29wZS5jaGFuZ2VVc2VybmFtZSA9IGZ1bmN0aW9uKHR5cGVkKSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ3NlYXJjaGluZycpO1xuICAgICRzY29wZS5kYXRhLnVzZXJuYW1lID0gYW5ndWxhci5sb3dlcmNhc2UoJHNjb3BlLmRhdGEudXNlcm5hbWUpO1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwibG9va3VwX2FjY291bnRfbmFtZXNcIiwgW1skc2NvcGUuZGF0YS51c2VybmFtZV1dKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgJHNjb3BlLnVzZXJzID0gcmVzcG9uc2VbMF07XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICRzY29wZS5xclNjYW4gPSBmdW5jdGlvbigpIHtcbiAgICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICRjb3Jkb3ZhQmFyY29kZVNjYW5uZXIuc2Nhbih7XG4gICAgICAgICAgXCJwcmVmZXJGcm9udENhbWVyYVwiIDogZmFsc2UsIC8vIGlPUyBhbmQgQW5kcm9pZFxuICAgICAgICAgIFwic2hvd0ZsaXBDYW1lcmFCdXR0b25cIiA6IGZhbHNlLCAvLyBpT1MgYW5kIEFuZHJvaWRcbiAgICAgICAgICBcInByb21wdFwiIDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1FSX1RFWFQnKSwgLy8gc3VwcG9ydGVkIG9uIEFuZHJvaWQgb25seVxuICAgICAgICAgIFwiZm9ybWF0c1wiIDogXCJRUl9DT0RFXCIgLy8gZGVmYXVsdDogYWxsIGJ1dCBQREZfNDE3IGFuZCBSU1NfRVhQQU5ERURcbiAgICAgICAgICAvL1wib3JpZW50YXRpb25cIiA6IFwibGFuZHNjYXBlXCIgLy8gQW5kcm9pZCBvbmx5IChwb3J0cmFpdHxsYW5kc2NhcGUpLCBkZWZhdWx0IHVuc2V0IHNvIGl0IHJvdGF0ZXMgd2l0aCB0aGUgZGV2aWNlXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oYmFyY29kZURhdGEpIHtcbiAgICAgICAgLy9hbGVydChiYXJjb2RlRGF0YSk7XG4gICAgICAgIGlmIChiYXJjb2RlRGF0YS50ZXh0LmluZGV4T2YoJz9hbW91bnQnKT4tMSkge1xuICAgICAgICAgIC8vc3RlZW0gZG9sbGFyOmJsb2NrdHJhZGVzP2Ftb3VudD0xMi4wODBcblxuICAgICAgICAgICRzY29wZS5kYXRhLnVzZXJuYW1lID0gYmFyY29kZURhdGEudGV4dC5zcGxpdCgnOicpWzFdLnNwbGl0KCc/JylbMF0udHJpbSgpO1xuICAgICAgICAgICRzY29wZS5kYXRhLmFtb3VudCA9IE51bWJlcihiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgIGlmIChiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMF09PT0nc3RlZW0gZG9sbGFyJykge1xuICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZSA9ICdzYmQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmFyY29kZURhdGEudGV4dC5zcGxpdCgnOicpWzBdPT09J3N0ZWVtJykge1xuICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZSA9ICdzdGVlbSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMF09PT0nc3RlZW0gcG93ZXInKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlID0gJ3NwJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkc2NvcGUuZGF0YS51c2VybmFtZSA9IGJhcmNvZGVEYXRhLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLmNoYW5nZVVzZXJuYW1lKCk7XG4gICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCdFcnJvcicsYW5ndWxhci50b0pzb24oZXJyb3IpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAkc2NvcGUuYWR2YW5jZWRFQ2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygnYWR2YW5jZWRFQ2hhbmdlJywgJHNjb3BlLmRhdGEuYWR2YW5jZWQpO1xuICAgICRzY29wZS5kYXRhLmV0eXBlID0gXCJcIjtcbiAgICAkc2NvcGUuZXNjcm93ID0ge307XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9XG4gICRzY29wZS5hY3Rpb25FQ2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygnYWN0aW9uRUNoYW5nZScsICRzY29wZS5kYXRhLmV0eXBlKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH1cblxuICAkc2NvcGUuZXNjcm93QWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygkc2NvcGUuZGF0YS5ldHlwZSk7XG4gICAgaWYgKCRzY29wZS5kYXRhLmV0eXBlICYmICRzY29wZS5lc2Nyb3cuZXNjcm93X2lkKSB7XG4gICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09ORklSTUFUSU9OJyksXG4gICAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgICB9KTtcbiAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcblxuICAgICAgICAgIHZhciBteWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICBteWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgdmFyIGxvZ2luU3VjY2Vzc3MgPSBteWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQsXG4gICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAobG9naW5TdWNjZXNzcykge1xuICAgICAgICAgICAgdmFyIHRyZSA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLmV0eXBlID09IFwiYXBwcm92ZVwiKSB7XG4gICAgICAgICAgICAgIHRyZS5hZGRfdHlwZV9vcGVyYXRpb24oXCJlc2Nyb3dfYXBwcm92ZVwiLCB7IFxuICAgICAgICAgICAgICAgIGZyb206ICRzY29wZS5lc2Nyb3cuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogJHNjb3BlLmVzY3Jvdy50byxcbiAgICAgICAgICAgICAgICBhZ2VudDogJHNjb3BlLmVzY3Jvdy5hZ2VudCxcbiAgICAgICAgICAgICAgICB3aG86ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBlc2Nyb3dfaWQ6ICRzY29wZS5lc2Nyb3cuZXNjcm93X2lkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmU6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRzY29wZS5kYXRhLmV0eXBlID09IFwiZGlzcHV0ZVwiKSB7XG4gICAgICAgICAgICAgIHRyZS5hZGRfdHlwZV9vcGVyYXRpb24oXCJlc2Nyb3dfZGlzcHV0ZVwiLCB7IFxuICAgICAgICAgICAgICAgIGZyb206ICRzY29wZS5lc2Nyb3cuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogJHNjb3BlLmVzY3Jvdy50byxcbiAgICAgICAgICAgICAgICBhZ2VudDogJHNjb3BlLmVzY3Jvdy5hZ2VudCxcbiAgICAgICAgICAgICAgICB3aG86ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBlc2Nyb3dfaWQ6ICRzY29wZS5lc2Nyb3cuZXNjcm93X2lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkc2NvcGUuZGF0YS5ldHlwZSA9PSBcInJlbGVhc2VcIikge1xuICAgICAgICAgICAgICB0cmUuYWRkX3R5cGVfb3BlcmF0aW9uKFwiZXNjcm93X3JlbGVhc2VcIiwge1xuICAgICAgICAgICAgICAgIGZyb206ICRzY29wZS5lc2Nyb3cuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogJHNjb3BlLmVzY3Jvdy50byxcbiAgICAgICAgICAgICAgICBhZ2VudDogJHNjb3BlLmVzY3Jvdy5hZ2VudCxcbiAgICAgICAgICAgICAgICB3aG86ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBlc2Nyb3dfaWQ6ICRzY29wZS5lc2Nyb3cuZXNjcm93X2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVyOiAkc2NvcGUuZXNjcm93LnJlY2VpdmVyLFxuICAgICAgICAgICAgICAgIHNiZF9hbW91bnQ6ICRzY29wZS5lc2Nyb3cuc2JkX2Ftb3VudCtcIiBcIithbmd1bGFyLnVwcGVyY2FzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQpLFxuICAgICAgICAgICAgICAgIHN0ZWVtX2Ftb3VudDogJHNjb3BlLmVzY3Jvdy5zdGVlbV9hbW91bnQrXCIgXCIrYW5ndWxhci51cHBlcmNhc2UoJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0KSBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICB0cmUucHJvY2Vzc190cmFuc2FjdGlvbihteWxvZ2luLCBudWxsLCB0cnVlKTsgIFxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTkZPJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdUWF9CUk9BRENBU1RFRCcpKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlPSRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW47XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5hbW91bnQ9IDAuMDAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gXG4gIH1cbiAgJHNjb3BlLmVzY3JvdyA9IHt9O1xuICAkc2NvcGUuc2VhcmNoRXNjcm93SUQgPSBmdW5jdGlvbihpZCl7XG4gICAgaWYgKGlkLmxlbmd0aD4zKXtcbiAgICAgIEFQSXMuc2VhcmNoRXNjcm93KGlkKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzLmRhdGEpO1xuICAgICAgICAkc2NvcGUuZXNjcm93ID0gcmVzLmRhdGFbMF07XG4gICAgICAgICRzY29wZS5lc2Nyb3cuanNvbl9tZXRhID0gYW5ndWxhci5mcm9tSnNvbigkc2NvcGUuZXNjcm93Lmpzb25fbWV0YSk7XG4gICAgICB9KTsgIFxuICAgIH1cbiAgfVxuICAkc2NvcGUudHJhbnNmZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgPT09ICdzYmQnIHx8ICRzY29wZS5kYXRhLnR5cGUgPT09ICdnYmcnKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5kYXRhLmFtb3VudCA+IE51bWJlcigkc2NvcGUuYmFsYW5jZS5zYmRfYmFsYW5jZS5zcGxpdChcIiBcIilbMF0pKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQkFMQU5DRV9URVhUJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUub2tiYWxhbmNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgPT09ICdzcCcgfHwgJHNjb3BlLmRhdGEudHlwZSA9PT0gJ3N0ZWVtJyB8fCAkc2NvcGUuZGF0YS50eXBlID09PSAnZ29sb3MnIHx8ICRzY29wZS5kYXRhLnR5cGUgPT09ICdnb2xvc3AnKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5kYXRhLmFtb3VudCA+IE51bWJlcigkc2NvcGUuYmFsYW5jZS5iYWxhbmNlLnNwbGl0KFwiIFwiKVswXSkpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCQUxBTkNFX1RFWFQnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5va2JhbGFuY2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISRzY29wZS51c2VycyB8fCAkc2NvcGUudXNlcnMubmFtZSAhPT0gJHNjb3BlLmRhdGEudXNlcm5hbWUpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTk9ORVhJU1RfVVNFUicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkc2NvcGUub2t1c2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNjb3BlLm9rYmFsYW5jZSAmJiAkc2NvcGUub2t1c2VyKSB7XG4gICAgICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT05GSVJNQVRJT04nKSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFJBTlNGRVJfVEVYVCcpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAodHlwZSA9PSAndHJhbnNmZXInKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgLy90cmFuc2ZlclxuICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLnR5cGUgIT09ICdzcCcgJiYgJHNjb3BlLmRhdGEudHlwZSAhPT0gJ2dvbG9zcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gJGZpbHRlcignbnVtYmVyJykoJHNjb3BlLmRhdGEuYW1vdW50LCAzKSArXCIgXCIrYW5ndWxhci51cHBlcmNhc2UoJHNjb3BlLmRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcInRyYW5zZmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdG86ICRzY29wZS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogdHQsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtbzogJHNjb3BlLmRhdGEubWVtbyB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0lORk8nKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1RYX0JST0FEQ0FTVEVEJykpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZT0kcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5hbW91bnQ9IDAuMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dCA9ICRmaWx0ZXIoJ251bWJlcicpKCRzY29wZS5kYXRhLmFtb3VudCwgMykgKyBcIiBcIiskZmlsdGVyKCd1cHBlcmNhc2UnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwidHJhbnNmZXJfdG9fdmVzdGluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZnJvbTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIHRvOiAkc2NvcGUuZGF0YS51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHR0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0lORk8nKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1RYX0JST0FEQ0FTVEVEJykpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZT0kcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5hbW91bnQ9IDAuMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnZXNjcm93Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KTtcblxuICAgICAgICAgICAgICAgIHZhciBteWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgICBteWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2Vzc3MgPSBteWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyZSA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgdmFyIGVzY3Jvd19pZCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSk+Pj4wO1xuICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gJGZpbHRlcignbnVtYmVyJykoJHNjb3BlLmRhdGEuYW1vdW50LCAzKSArXCIgXCIrYW5ndWxhci51cHBlcmNhc2UoJHNjb3BlLmRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc2JkID0gKCRzY29wZS5kYXRhLnR5cGU9PSdzYmQnfHwkc2NvcGUuZGF0YS50eXBlPT0nZ2JnJyk/dHQ6KFwiMC4wMDAgXCIrYW5ndWxhci51cHBlcmNhc2UoJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0KSk7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RlbSA9ICgkc2NvcGUuZGF0YS50eXBlPT0nc3RlZW0nfHwkc2NvcGUuZGF0YS50eXBlPT0nZ29sb3MnKT90dDooXCIwLjAwMCBcIithbmd1bGFyLnVwcGVyY2FzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQpKTtcbiAgICAgICAgICAgICAgICAgIHZhciBmZSA9ICRzY29wZS5kYXRhLmFnZW50LmVzY3Jvdy5mZWVzW2FuZ3VsYXIudXBwZXJjYXNlKCRzY29wZS5kYXRhLnR5cGUpXStcIiBcIithbmd1bGFyLnVwcGVyY2FzZSgkc2NvcGUuZGF0YS50eXBlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBydCA9IG5ldyBEYXRlKCRzY29wZS5kYXRhLnJhdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgICB2YXIgZXQgPSBuZXcgRGF0ZSgkc2NvcGUuZGF0YS5leHBpcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHZhciBqbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGVybXM6ICRzY29wZS5kYXRhLmFnZW50LmVzY3Jvdy50ZXJtcywgXG4gICAgICAgICAgICAgICAgICAgIG1lbW86ICgkc2NvcGUuZGF0YS5tZW1vfHxcIlwiKStcIiBcIitlc2Nyb3dfaWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRyZS5hZGRfdHlwZV9vcGVyYXRpb24oXCJlc2Nyb3dfdHJhbnNmZXJcIiwgeyBcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgdG86ICRzY29wZS5kYXRhLnVzZXJuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgYWdlbnQ6ICRzY29wZS5kYXRhLmFnZW50Lm5hbWUsIFxuICAgICAgICAgICAgICAgICAgICBlc2Nyb3dfaWQ6IGVzY3Jvd19pZCwgXG4gICAgICAgICAgICAgICAgICAgIHNiZF9hbW91bnQ6IHNiZCwgXG4gICAgICAgICAgICAgICAgICAgIHN0ZWVtX2Ftb3VudDogc3RlbSwgXG4gICAgICAgICAgICAgICAgICAgIGZlZTogZmUsIFxuICAgICAgICAgICAgICAgICAgICByYXRpZmljYXRpb25fZGVhZGxpbmU6IHJ0LCBcbiAgICAgICAgICAgICAgICAgICAgZXNjcm93X2V4cGlyYXRpb246IGV0LCBcbiAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhOiBhbmd1bGFyLnRvSnNvbihqbikgXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgLy90cmUucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAvL215bG9naW4uc2lnblRyYW5zYWN0aW9uKHRyZSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHRyZS5wcm9jZXNzX3RyYW5zYWN0aW9uKG15bG9naW4sIG51bGwsIHRydWUpOyAgXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLyp0cmUuZmluYWxpemUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyZS5zaWduKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NpZ25lZCcpO1xuICAgICAgICAgICAgICAgICAgICAgIHRyZS5icm9hZGNhc3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Jyb2FkY2FzdGVkJyk7XG4gICAgICAgICAgICAgICAgICB9KTsqL1xuXG5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0lORk8nKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1RYX0JST0FEQ0FTVEVEJykgKyBcIiBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVNDUk9XJykrXCIgXCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0lEJykrXCI6IFwiK2VzY3Jvd19pZCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEudHlwZT0kcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuYW1vdW50PSAwLjAwMTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICB9XG4gIH07XG5cblxuICAkc2NvcGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgWyBbICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSBdIF0pLnRoZW4oZnVuY3Rpb24oZGQpe1xuICAgICAgICAkc2NvcGUuYmFsYW5jZSA9IGRkWzBdO1xuICAgICAgICBjb25zb2xlLmxvZygkc2NvcGUuYmFsYW5jZSk7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgfVxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbIFsgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lIF0gXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICRzY29wZS5iYWxhbmNlID0gZGRbMF07XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG59KTtcbmFwcC5jb250cm9sbGVyKCdQb3N0c0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljUG9wdXAsICRpb25pY1BvcG92ZXIsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRpb25pY01vZGFsLCAkZmlsdGVyLCAkc3RhdGVQYXJhbXMsICRpb25pY1NsaWRlQm94RGVsZWdhdGUsICRpb25pY0FjdGlvblNoZWV0LCAkaW9uaWNQbGF0Zm9ybSwgJGNvcmRvdmFDYW1lcmEsIEltYWdlVXBsb2FkU2VydmljZSwgJGZpbHRlciwgJGlvbmljSGlzdG9yeSwgJHRpbWVvdXQsIEFQSXMsICR0cmFuc2xhdGUpIHtcblxuICB2YXIgZm9ybWF0VG9QZXJjZW50YWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJyUnO1xuICB9O1xuXG4gICRzY29wZS5wc2xpZGVyID0ge1xuICAgIHZhbHVlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGZsb29yOiAxLFxuICAgICAgY2VpbDogMTAwLFxuICAgICAgaGlkZUxpbWl0TGFiZWxzOiB0cnVlXG4gICAgICAvL3RyYW5zbGF0ZTogZm9ybWF0VG9QZXJjZW50YWdlLFxuICAgICAgLy9zaG93U2VsZWN0aW9uQmFyOiB0cnVlLFxuICAgIH1cbiAgfTtcblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclNsaWRlci5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwU2xpZGVyID0gcG9wb3ZlcjtcbiAgfSk7XG4gIFxuICAkc2NvcGUub3BlblNsaWRlciA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgICRzY29wZS52b3RpbmdQb3N0ID0gZDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS5yYW5nZVZhbHVlID0gJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0LzEwMDtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlci5zaG93KCRldmVudCk7XG4gIH07XG4gICRzY29wZS5kcmFnID0gZnVuY3Rpb24odikge1xuICAgIC8vY29uc29sZS5sb2codik7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gdioxMDA7XG4gIH1cbiAgJHNjb3BlLnZvdGVQb3N0UyA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyLmhpZGUoKTtcbiAgICAkc2NvcGUudm90ZVBvc3QoJHNjb3BlLnZvdGluZ1Bvc3QpO1xuICB9XG4gICRzY29wZS5jbG9zZVNsaWRlciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyLmhpZGUoKTtcbiAgfTtcblxuICAkc2NvcGUub3B0aW9ucyA9IHtcbiAgICBsb29wOiBmYWxzZSxcbiAgICBzcGVlZDogNTAwLFxuICAgIC8qcGFnaW5hdGlvbjogZmFsc2UsKi9cbiAgICBzaG93UGFnZXI6IGZhbHNlLFxuICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgc3BhY2VCZXR3ZWVuOiAyMCxcbiAgICBicmVha3BvaW50czoge1xuICAgICAgMTAyNDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDUsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNVxuICAgICAgfSxcbiAgICAgIDc2ODoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDQsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxMFxuICAgICAgfSxcbiAgICAgIDY0MDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiA1XG4gICAgICB9LFxuICAgICAgMzIwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDNcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gICRyb290U2NvcGUuJG9uKCdmaWx0ZXI6Y2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICRyb290U2NvcGUubG9nKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKTtcbiAgICB2YXIgdHlwZSA9ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyIHx8IFwidHJlbmRpbmdcIjtcbiAgICB2YXIgdGFnID0gJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgfHwgXCJcIjtcbiAgICBjb25zb2xlLmxvZyh0eXBlLCAkc2NvcGUubGltaXQsIHRhZyk7XG4gICAgJHNjb3BlLmZldGNoUG9zdHModHlwZSwgJHNjb3BlLmxpbWl0LCB0YWcpO1xuICB9KTtcblxuICAkc2NvcGUuZmlsdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZmlsID0gJHNjb3BlLm15bWVudVt0XS5jdXN0b207XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBmaWw7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRzY29wZS5teW1lbnUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB2ID0gJHNjb3BlLm15bWVudVtpXTtcbiAgICAgIGlmICh2LmN1c3RvbSA9PSBmaWwpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXJOYW1lID0gdi50ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICAkc2NvcGUuZGF0YSA9IFtdO1xuICAgICRzY29wZS5lcnJvciA9IGZhbHNlO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICB9XG4gICRzY29wZS5zaG93RmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlclNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6ICRzY29wZS5teW1lbnUsXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NPUlRfUE9TVF9CWScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAkc2NvcGUuZmlsdGVyQ2hhbmdlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclQuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICB9KTtcblxuICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICB2YXIgdHBwdiA9IE51bWJlcihkLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRwdiA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdGV4dGggPSBcIjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9URU5USUFMX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHB2LCAzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykocCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTVF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHB2LDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBVVRIT1JfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGFyLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDVVJBVElPTl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoY3JwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ3RpbWVhZ28nKShkLmNhc2hvdXRfdGltZSwgdHJ1ZSkrXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS50b29sdGlwLnNob3coJGV2ZW50KTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gIH07XG5cbiAgIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5yZW1vdmUoKTtcbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiBoaWRlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIuaGlkZGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgICAgJHNjb3BlLnRvb2x0aXBUZXh0ID0gdW5kZWZpbmVkO1xuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIHJlbW92ZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLnJlbW92ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICB9KTtcblxuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9zdG9yeS5odG1sJywgeyBzY29wZTogJHNjb3BlICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAkc2NvcGUubW9kYWxwID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUubGFzdEZvY3VzZWQ7XG5cbiAgJHJvb3RTY29wZS4kb24oJ29wZW5Qb3N0TW9kYWwnLCBmdW5jdGlvbigpIHtcblxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuXG4gICAgJHNjb3BlLnNwb3N0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zcG9zdCB8fCAkc2NvcGUuc3Bvc3Q7XG5cbiAgICBcblxuICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoISRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSkge1xuICAgICAgICAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGUgPSAnZGVmYXVsdCc7XG4gICAgICB9XG4gICAgICAkc2NvcGUudGFnc0NoYW5nZSgpO1xuXG4gICAgICAkc2NvcGUubW9kYWxwLnNob3coKTtcbiAgICAgIC8qYW5ndWxhci5lbGVtZW50KFwidGV4dGFyZWFcIikuZm9jdXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgICAgfSk7Ki9cbiAgICB9LCAxMCk7XG4gICAgLy8kc2NvcGUubW9kYWxwLnNob3coKTtcbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oJ2Nsb3NlUG9zdE1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFscC5oaWRlKCk7XG4gIH0pO1xuXG4gICRzY29wZS5jbG9zZVBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vJHNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAkc2NvcGUubW9kYWxwLmhpZGUoKTtcbiAgfTtcblxuXG4gICRzY29wZS5jZm9jdXMgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjQwODkvaW5zZXJ0aW5nLWEtdGV4dC13aGVyZS1jdXJzb3ItaXMtdXNpbmctamF2YXNjcmlwdC1qcXVlcnlcbiAgJHNjb3BlLmluc2VydFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIGlucHV0ID0gJHNjb3BlLmxhc3RGb2N1c2VkO1xuICAgIC8vY29uc29sZS5sb2coaW5wdXQpO1xuICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNjcm9sbFBvcyA9IGlucHV0LnNjcm9sbFRvcDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnJvd3NlciA9ICgoaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPT0gXCIwXCIpID9cbiAgICAgICAgICAgICAgICAgICBcImZmXCIgOiAoZG9jdW1lbnQuc2VsZWN0aW9uID8gXCJpZVwiIDogZmFsc2UgKSApO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHBvcyA9IHJhbmdlLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikgeyBwb3MgPSBpbnB1dC5zZWxlY3Rpb25TdGFydCB9O1xuXG4gICAgdmFyIGZyb250ID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICB2YXIgYmFjayA9IChpbnB1dC52YWx1ZSkuc3Vic3RyaW5nKHBvcywgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICBpbnB1dC52YWx1ZSA9IGZyb250K3RleHQrYmFjaztcbiAgICBwb3MgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoYnJvd3NlciA9PSBcImllXCIpIHtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgLWlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIHBvcyk7XG4gICAgICByYW5nZS5tb3ZlRW5kIChcImNoYXJhY3RlclwiLCAwKTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBwb3M7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBwb3M7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICBpbnB1dC5zY3JvbGxUb3AgPSBzY3JvbGxQb3M7XG4gICAgLy9jb25zb2xlLmxvZyhhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnZhbCgpKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnRyaWdnZXIoJ2lucHV0Jyk7XG4gIH1cblxuXG4gICRzY29wZS5zaG93SW1nID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgaGlkZVNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6IFtcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQVBUVVJFX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFTEVDVF9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnR0FMTEVSWScpIH1cbiAgICAgXSxcbiAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5TRVJUX1BJQ1RVUkUnKSxcbiAgICAgY2FuY2VsVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTkNFTCcpLFxuICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgfSxcbiAgICAgYnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgJHNjb3BlLmluc2VydEltYWdlKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgIH0pO1xuICB9O1xuICAkc2NvcGUuaW5zZXJ0SW1hZ2UgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlID09IDAgfHwgdHlwZSA9PSAxKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgIGVuY29kaW5nVHlwZTogQ2FtZXJhLkVuY29kaW5nVHlwZS5KUEVHLFxuICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgIC8vY29ycmVjdE9yaWVudGF0aW9uOnRydWVcbiAgICAgIH07XG4gICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlc3VsdC5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAvKmlmICgkc2NvcGUuc3Bvc3QuYm9keSkge1xuICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSArPSBmaW5hbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ID0gZmluYWw7XG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU1FUkFfQ0FOQ0VMTEVEJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IDIpe1xuICAgICAgJGlvbmljUG9wdXAucHJvbXB0KHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRElSRUNUX0xJTktfUElDVFVSRScpLFxuICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91ciB1cmwgaXMnICsgcmVzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHZhciB1cmwgPSByZXMudHJpbSgpO1xuICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ICs9IGZpbmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgIH0qL1xuICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICB2YXIgaW1ncyA9IHJlcy5kYXRhO1xuICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAkc2NvcGUuZ2FsbGVyeS5pbWFnZXMgPSBpbWdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5zaG93Z2FsbGVyeSA9IGZhbHNlO1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ05PX0lNQUdFJykpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAkc2NvcGUuY2xvc2VHYWxsZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSBmYWxzZTtcbiAgfVxuICAkc2NvcGUubWFuYWdlR2FsbGVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZVBvc3RNb2RhbCcpO1xuICAgICRzdGF0ZS5nbygnYXBwLmltYWdlcycpO1xuICB9XG4gIGZ1bmN0aW9uIHNsdWcodGV4dCkge1xuICAgIHJldHVybiBnZXRTbHVnKHRleHQsIHt0cnVuY2F0ZTogMTI4fSk7XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZVBlcm1saW5rKHRpdGxlKSB7XG4gICAgdmFyIHBlcm1saW5rO1xuICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZWZvcm1hdCA9IHQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKyh0LmdldE1vbnRoKCkrMSkudG9TdHJpbmcoKSt0LmdldERhdGUoKS50b1N0cmluZygpK1widFwiK3QuZ2V0SG91cnMoKS50b1N0cmluZygpK3QuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkrdC5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSt0LmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkrXCJ6XCI7XG4gICAgaWYgKHRpdGxlICYmIHRpdGxlLnRyaW0oKSAhPT0gJycpIHtcbiAgICAgIHZhciBzID0gc2x1Zyh0aXRsZSk7XG4gICAgICBwZXJtbGluayA9IHMudG9TdHJpbmcoKStcIi1cIit0aW1lZm9ybWF0O1xuICAgICAgaWYocGVybWxpbmsubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIC8vIFNURUVNSVRfTUFYX1BFUk1MSU5LX0xFTkdUSFxuICAgICAgICBwZXJtbGluayA9IHBlcm1saW5rLnN1YnN0cmluZyhwZXJtbGluay5sZW5ndGggLSAyNTUsIHBlcm1saW5rLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgbGV0dGVycyBudW1iZXJzIGFuZCBkYXNoZXMgc2hhbGwgc3Vydml2ZVxuICAgICAgcGVybWxpbmsgPSBwZXJtbGluay50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05LV0rL2csICcnKVxuICAgICAgcmV0dXJuIHBlcm1saW5rO1xuICAgIH1cbiAgfTtcbiAgLy8kc2NvcGUub3BlcmF0aW9uX3R5cGUgPSAnZGVmYXVsdCc7XG4gICRzY29wZS5zcG9zdCA9IHt9O1xuICAkc2NvcGUudGFnc0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKFwidGFnc0NoYW5nZVwiKTtcbiAgICAkc2NvcGUuc3Bvc3QudGFncyA9ICRmaWx0ZXIoJ2xvd2VyY2FzZScpKCRzY29wZS5zcG9zdC50YWdzKTtcbiAgICAkc2NvcGUuc3Bvc3QuY2F0ZWdvcnkgPSAkc2NvcGUuc3Bvc3QudGFncz8kc2NvcGUuc3Bvc3QudGFncy5zcGxpdChcIiBcIik6W107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRzY29wZS5zcG9zdC5jYXRlZ29yeS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHYgPSAkc2NvcGUuc3Bvc3QuY2F0ZWdvcnlbaV07XG4gICAgICBpZigvXlvQsC3Rj9GRXS8udGVzdCh2KSkge1xuICAgICAgICB2ID0gJ3J1LS0nICsgJGZpbHRlcignZGV0cmFuc2xpdGVyYXRlJykodiwgdHJ1ZSk7XG4gICAgICAgICRzY29wZS5zcG9zdC5jYXRlZ29yeVtpXSA9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZygkc2NvcGUuc3Bvc3QuY2F0ZWdvcnkpO1xuICAgIGlmICgkc2NvcGUuc3Bvc3QuY2F0ZWdvcnkubGVuZ3RoID4gNSkge1xuICAgICAgJHNjb3BlLmRpc2FibGVCdG4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuZGlzYWJsZUJ0biA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuY29udGVudENoYW5nZWQgPSBmdW5jdGlvbiAoZWRpdG9yLCBodG1sLCB0ZXh0KSB7XG4gICAgLy9jb25zb2xlLmxvZygkc2NvcGUuc3Bvc3QuYm9keSk7XG4gICAgLy9jb25zb2xlLmxvZygnZWRpdG9yOiAnLCBlZGl0b3IsICdodG1sOiAnLCBodG1sLCAndGV4dDonLCB0ZXh0KTtcbiAgfTtcblxuICAkc2NvcGUuc3VibWl0U3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5zcG9zdC5ib2R5KTtcbiAgICAkc2NvcGUudGFnc0NoYW5nZSgpO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgdmFyIHBlcm1saW5rID0gY3JlYXRlUGVybWxpbmsoJHNjb3BlLnNwb3N0LnRpdGxlKTtcbiAgICAgICAgdmFyIGpzb24gPSAkZmlsdGVyKFwibWV0YWRhdGFcIikoJHNjb3BlLnNwb3N0LmJvZHkpO1xuICAgICAgICBhbmd1bGFyLm1lcmdlKGpzb24sIHt0YWdzOiAkc2NvcGUuc3Bvc3QuY2F0ZWdvcnksIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfSk7XG5cbiAgICAgICAgaWYgKCEkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGUpIHtcbiAgICAgICAgICAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnTk9UIERlZmF1bHQnKTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICAgIHBhcmVudF9hdXRob3I6IFwiXCIsXG4gICAgICAgICAgICBwYXJlbnRfcGVybWxpbms6ICRzY29wZS5zcG9zdC5jYXRlZ29yeVswXSxcbiAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGVybWxpbms6IHBlcm1saW5rLFxuICAgICAgICAgICAgdGl0bGU6ICRzY29wZS5zcG9zdC50aXRsZSxcbiAgICAgICAgICAgIGJvZHk6ICRzY29wZS5zcG9zdC5ib2R5LFxuICAgICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93X3ZvdGVzOiB0cnVlLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogcGVybWxpbmssXG4gICAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGU9PT0nc3AnP1wiMTAwMDAwMC4wMDAgXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0OlwiMC4wMDAgXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0LFxuICAgICAgICAgICAgcGVyY2VudF9zdGVlbV9kb2xsYXJzOiAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGU9PT0nc3AnPzA6MTAwMDAsXG4gICAgICAgICAgICBleHRlbnNpb25zOiB7IFwiYmVuZWZpY2lhcmllc1wiOiB7IFwiYWNjb3VudFwiOlwiZXN0ZWVtYXBwXCIsIFwid2VpZ2h0XCI6MTAwIH0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RlZmF1bHQnKTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICAgIHBhcmVudF9hdXRob3I6IFwiXCIsXG4gICAgICAgICAgICBwYXJlbnRfcGVybWxpbms6ICRzY29wZS5zcG9zdC5jYXRlZ29yeVswXSxcbiAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGVybWxpbms6IHBlcm1saW5rLFxuICAgICAgICAgICAgdGl0bGU6ICRzY29wZS5zcG9zdC50aXRsZSxcbiAgICAgICAgICAgIGJvZHk6ICRzY29wZS5zcG9zdC5ib2R5LFxuICAgICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93X3ZvdGVzOiB0cnVlLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogcGVybWxpbmssXG4gICAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBcIjEwMDAwMDAuMDAwIFwiKyRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCxcbiAgICAgICAgICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogMTAwMDAsXG4gICAgICAgICAgICBleHRlbnNpb25zOiB7IFwiYmVuZWZpY2lhcmllc1wiOiB7IFwiYWNjb3VudFwiOlwiZXN0ZWVtYXBwXCIsIFwid2VpZ2h0XCI6MTAwIH0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vJHNjb3BlLmNsb3NlUG9zdE1vZGFsKCk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlUG9zdE1vZGFsJyk7XG5cbiAgICAgICAgICAgIC8vJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICAgICAgICAgJHNjb3BlLnNwb3N0ID0ge307XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgIC8vJHNjb3BlLmNsb3NlTWVudVBvcG92ZXIoKTtcbiAgICAgICAgICAgICRzdGF0ZS5nbyhcImFwcC5wcm9maWxlXCIsIHt1c2VybmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgfVxuICB9XG4gICRzY29wZS5zYXZlUG9zdCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCRzY29wZS5tb2RhbHApO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc3Bvc3QgPSAkc2NvcGUuc3Bvc3Q7XG4gICAgLy9hZGRkcmFmdFxuICAgIHZhciBkciA9IHt0aXRsZTokc2NvcGUuc3Bvc3QudGl0bGUsIGJvZHk6ICRzY29wZS5zcG9zdC5ib2R5LCB0YWdzOiAkc2NvcGUuc3Bvc3QudGFncywgcG9zdF90eXBlOiAkc2NvcGUuc3Bvc3Qub3BlcmF0aW9uX3R5cGV9O1xuICAgIEFQSXMuYWRkRHJhZnQoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBkcikudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpO1xuICAgICAgLy8kc2NvcGUuZHJhZnRzID0gcmVzLmRhdGE7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZVBvc3RNb2RhbCcpO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzY29wZS5tb2RhbHAuaGlkZSgpO1xuICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NBVkVEJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0xBVEVSJykpO1xuICB9XG4gICRzY29wZS5jbGVhclBvc3QgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNwb3N0ID0ge307XG4gICAgJHNjb3BlLnNwb3N0ID0ge307XG4gICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0xFQVJFRCcpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVCcpKTtcbiAgfVxuXG5cbiAgJHJvb3RTY29wZS4kb24oJ2ZldGNoUG9zdHMnLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5mZXRjaFBvc3RzKCk7XG4gIH0pO1xuXG4gICRyb290U2NvcGUuJG9uKCdmZXRjaENvbnRlbnQnLCBmdW5jdGlvbihldmVudCwgYXJncykge1xuICAgIHZhciBwb3N0ID0gYXJncy5hbnk7XG4gICAgLy9jb25zb2xlLmxvZyhwb3N0KTtcbiAgICAkc2NvcGUuZmV0Y2hDb250ZW50KHBvc3QuYXV0aG9yLCBwb3N0LnBlcm1saW5rKTtcbiAgfSk7XG5cbiAgJHNjb3BlLnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vwdm90ZScsICdmZXRjaENvbnRlbnQnKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5kb3dudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG5cbiAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGTEFHR0lOR19URVhUJylcbiAgICB9KTtcbiAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGlmKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ2Rvd252b3RlJywgJ2ZldGNoQ29udGVudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gICRzY29wZS51bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vudm90ZScsICdmZXRjaENvbnRlbnQnKTtcbiAgfTtcblxuXG4gICRyb290U2NvcGUuJG9uKFwidXNlcjpsb2dvdXRcIiwgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuZmV0Y2hQb3N0cygpO1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICB9KTtcblxuICAkc2NvcGUubG9hZE1vcmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgJHNjb3BlLmxpbWl0ICs9IDU7XG4gICAgLy9pZiAoISRzY29wZS5lcnJvcikge1xuICAgICRzY29wZS5mZXRjaFBvc3RzKG51bGwsICRzY29wZS5saW1pdCwgbnVsbCk7XG4gICAgLy99XG4gIH07XG4gICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUubGltaXQgPSAxMDtcbiAgICAvL2lmICghJHNjb3BlLmVycm9yKSB7XG4gICAgJHNjb3BlLmZldGNoUG9zdHMobnVsbCwgJHNjb3BlLmxpbWl0LCBudWxsKTtcbiAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLnJlZnJlc2hDb21wbGV0ZScpO1xuICB9XG5cbiAgJHNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3VjY2VzcycsIGZ1bmN0aW9uIChldiwgdG8sIHRvUGFyYW1zLCBmcm9tLCBmcm9tUGFyYW1zKSB7XG4gICAgY29uc29sZS5sb2coJ3N0YXRlQ2hhbmdlU3VjY2VzcycsICRzdGF0ZVBhcmFtcy5yZW5ldyk7XG4gICAgaWYgKGZyb20ubmFtZSA9PSAnYXBwLnBvc3RzJyAmJiB0by5uYW1lID09ICdhcHAucG9zdCcpIHtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZnJvbS5uYW1lID09ICdhcHAucG9zdCcgJiYgdG8ubmFtZSA9PSAnYXBwLnBvc3RzJykge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tLm5hbWUgIT09ICdhcHAucG9zdCcpIHtcbiAgICAgICAgaWYgKCRzdGF0ZVBhcmFtcy5yZW5ldykge1xuICAgICAgICAgICRzY29wZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAkc2NvcGUuZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgICRzY29wZS5sb2FkTW9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLm1vcmVEYXRhQ2FuQmVMb2FkZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhJHNjb3BlLmVycm9yO1xuICB9XG5cbiAgJHJvb3RTY29wZS4kb24oJ2NoYW5nZVZpZXcnLCBmdW5jdGlvbigpe1xuICAgIC8vJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5oaWRlKCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcgPT09ICdjYXJkJykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRzY29wZS5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gJHNjb3BlLmRhdGFbaV07XG4gICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAkcm9vdFNjb3BlLiRvbignY2hhbmdlTGlnaHQnLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5oaWRlKCk7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGFycmF5T2JqZWN0SW5kZXhPZihteUFycmF5LCBzZWFyY2hUZXJtLCBwcm9wZXJ0eSkge1xuICAgIHZhciBsbGVuID0gbXlBcnJheS5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxsZW47IGkrKykge1xuICAgICAgICBpZiAobXlBcnJheVtpXVtwcm9wZXJ0eV0gPT09IHNlYXJjaFRlcm0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgJHNjb3BlLmRhdGEgPSBbXTtcbiAgJHNjb3BlLnRlbXBEYXRhID0gW107XG5cbiAgJHNjb3BlLmRhdGFDaGFuZ2VkID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgIHZhciBsZW5uID0gbmV3VmFsdWUubGVuZ3RoO1xuICAgICAgdmFyIHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgfHwgbnVsbDtcbiAgICAgIHZhciB2aWV3ID0gJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3O1xuXG4gICAgICBpZiAodXNlcil7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVubjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldICYmIG5ld1ZhbHVlW2ldLmFjdGl2ZV92b3Rlcykge1xuICAgICAgICAgICAgdmFyIGxlbiA9IG5ld1ZhbHVlW2ldLmFjdGl2ZV92b3Rlcy5sZW5ndGgtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgIGlmIChuZXdWYWx1ZVtpXS5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlW2ldLmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgbmV3VmFsdWVbaV0uZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV3VmFsdWVbaV0uZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWV3ID09PSAnY2FyZCcpIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKXtcbiAgICAgICAgICAgICAgbmV3VmFsdWVbaV0uanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24obmV3VmFsdWVbaV0uanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmlldyA9PT0gJ2NhcmQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5uOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKXtcbiAgICAgICAgICAgICAgbmV3VmFsdWVbaV0uanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24obmV3VmFsdWVbaV0uanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLmZldGNoQ29udGVudCA9IGZ1bmN0aW9uKGF1dGhvciwgcGVybWxpbmspIHtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50XCIsIFthdXRob3IsIHBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICB2YXIgbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihyZXN1bHQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAkc2NvcGUuZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciB2ID0gJHNjb3BlLmRhdGFbaV07XG4gICAgICAgICAgaWYgKHYucGVybWxpbmsgPT09IHJlc3VsdC5wZXJtbGluaykge1xuICAgICAgICAgICAgJHNjb3BlLmRhdGFbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICRzY29wZS5pZkV4aXN0cyA9IGZ1bmN0aW9uKHh4KXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoJHNjb3BlLmRhdGFbaV0ucGVybWxpbmsgPT09IHh4KXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAkc2NvcGUuZmV0Y2hQb3N0cyA9IGZ1bmN0aW9uKHR5cGUsIGxpbWl0LCB0YWcpIHtcbiAgICB0eXBlID0gdHlwZSB8fCAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciB8fCBcInRyZW5kaW5nXCI7XG4gICAgdGFnID0gdGFnIHx8ICRyb290U2NvcGUuJHN0b3JhZ2UudGFnIHx8IFwiXCI7XG4gICAgbGltaXQgPSAxMDsvL2xpbWl0IHx8ICRzY29wZS5saW1pdCB8fCAxMDtcblxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0eXBlID09PSBcImZlZWRcIiAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgIHBhcmFtcyA9IHt0YWc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgbGltaXQ6IGxpbWl0LCBmaWx0ZXJfdGFnczpbXX07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gXCJmZWVkXCIpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBcInRyZW5kaW5nXCI7XG4gICAgICAgIHR5cGUgPSBcInRyZW5kaW5nXCI7XG4gICAgICB9XG4gICAgICBwYXJhbXMgPSB7dGFnOiB0YWcsIGxpbWl0OiBsaW1pdCwgZmlsdGVyX3RhZ3M6W119O1xuICAgIH1cbiAgICBpZiAoJHNjb3BlLmRhdGEgJiYgJHNjb3BlLmRhdGEubGVuZ3RoPjApIHtcbiAgICAgIHBhcmFtcy5zdGFydF9hdXRob3IgPSAkc2NvcGUuZGF0YVskc2NvcGUuZGF0YS5sZW5ndGgtMV0uYXV0aG9yO1xuICAgICAgcGFyYW1zLnN0YXJ0X3Blcm1saW5rID0gJHNjb3BlLmRhdGFbJHNjb3BlLmRhdGEubGVuZ3RoLTFdLnBlcm1saW5rO1xuICAgIH1cbiAgICBpZiAoJHNjb3BlLmVycm9yKSB7XG4gICAgICAvLyRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVRVUVTVF9MSU1JVF9URVhUJykpO1xuICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coXCJmZXRjaGluZy4uLlwiK3R5cGUrXCIgXCIrbGltaXQrXCIgXCIrdGFnKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLyp3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfc3RhdGVcIiwgW1wiL1wiK3R5cGVdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICB9KTsqL1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdnb2xvcycgJiYgdHlwZSA9PSAnZmVlZCcpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZWxlY3RfYXV0aG9ycyA9IFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWVdOyBcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudGFnczsgXG4gICAgICAgICAgfVxuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9kaXNjdXNzaW9uc19ieV9cIit0eXBlLCBbcGFyYW1zXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3BvbnNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VbaV0uanNvbl9tZXRhZGF0YSA9IHJlc3BvbnNlW2ldLmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbihyZXNwb25zZVtpXS5qc29uX21ldGFkYXRhKTpyZXNwb25zZVtpXS5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHZhciBwZXJtbGluayA9IHJlc3BvbnNlW2ldLnBlcm1saW5rO1xuICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLmlmRXhpc3RzKHBlcm1saW5rKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZXhpc3QnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlW2ldICYmIHJlc3BvbnNlW2ldLmFjdGl2ZV92b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSByZXNwb25zZVtpXS5hY3RpdmVfdm90ZXMubGVuZ3RoLTE7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlW2ldLmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbaV0uYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VbaV0udXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VbaV0uYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VbaV0uZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtpXS5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtpXS51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vaWYgKCEvYm0uKi8udGVzdChyZXNwb25zZVtpXS5jYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHVzaChyZXNwb25zZVtpXSk7XG4gICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmxvYWRlZCcsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxpbWl0ID0gMTA7XG4gICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl0gPSBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uudmlldykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3ID0gJ2NhcmQnO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IFwidHJlbmRpbmdcIjtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5BcGkpIHtcbiAgICAgIC8qaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLnRpbWVpbnQpKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKFwiQXBpIHJlYWR5OlwiICsgYW5ndWxhci50b0pzb24ocmVzcG9uc2UpKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllcyBcIisgcmVzcG9uc2UuaGVhZF9ibG9ja19udW1iZXIpO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibG9naW4gXCIrbG9naW5TdWNjZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMTUwMDApO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmV0Y2hQb3N0cycpO1xuICAgICAgICB9KTtcbiAgICAgIH0qL1xuICAgIH1cblxuICAgIC8qc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbWFpblNjcm9sbCcpLnNjcm9sbFRvcCgpO1xuICAgIH0sIDEwKTsqL1xuICB9KTtcbiAgXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS50aGVtZSA9ICRyb290U2NvcGUuJHN0b3JhZ2UudGhlbWU7XG4gICAgaWYgKCRzdGF0ZVBhcmFtcy50YWdzKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyA9ICRzdGF0ZVBhcmFtcy50YWdzO1xuICAgIH1cblxuICAgIGlmICghYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSkpIHtcbiAgICAgIGlmKHR5cGVvZiBuYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldFByZWZlcnJlZExhbmd1YWdlKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICR0cmFuc2xhdGUudXNlKChsYW5ndWFnZS52YWx1ZSkuc3BsaXQoXCItXCIpWzBdKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1VDQ0VTUyAtPiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9IGxhbmd1YWdlLnZhbHVlLnNwbGl0KCctJylbMF07XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SIC0+IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UgPSAnZW4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkdHJhbnNsYXRlLnVzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICAkc2NvcGUuYWN0aXZlTWVudSA9ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyIHx8IFwidHJlbmRpbmdcIjtcbiAgICAkc2NvcGUubXltZW51ID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID8gW3t0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRkVFRCcpLCBjdXN0b206J2ZlZWQnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdUUkVORElORycpLCBjdXN0b206J3RyZW5kaW5nJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSE9UJyksIGN1c3RvbTonaG90J30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTkVXJyksIGN1c3RvbTonY3JlYXRlZCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FDVElWRScpLCBjdXN0b206J2FjdGl2ZSd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1BST01PVEVEJyksIGN1c3RvbTogJ3Byb21vdGVkJ30sIHt0ZXh0OiRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdWT1RFUycpLCBjdXN0b206J3ZvdGVzJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09NTUVOVFMnKSwgY3VzdG9tOidjaGlsZHJlbid9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBWU9VVCcpLCBjdXN0b206ICdjYXNob3V0J31dIDogWyB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1RSRU5ESU5HJyksIGN1c3RvbTondHJlbmRpbmcnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdIT1QnKSwgY3VzdG9tOidob3QnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdORVcnKSwgY3VzdG9tOidjcmVhdGVkJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUNUSVZFJyksIGN1c3RvbTonYWN0aXZlJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKSwgY3VzdG9tOiAncHJvbW90ZWQnfSwge3RleHQ6JGZpbHRlcigndHJhbnNsYXRlJykoJ1ZPVEVTJyksIGN1c3RvbTondm90ZXMnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UUycpLCBjdXN0b206J2NoaWxkcmVuJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJyksIGN1c3RvbTogJ2Nhc2hvdXQnfV07XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRzY29wZS5teW1lbnUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB2ID0gJHNjb3BlLm15bWVudVtpXTtcbiAgICAgIGlmICh2LmN1c3RvbSA9PT0gJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXJOYW1lID0gdi50ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxufSlcblxuYXBwLmNvbnRyb2xsZXIoJ1Bvc3RDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRpb25pY01vZGFsLCAkZmlsdGVyLCAkaW9uaWNBY3Rpb25TaGVldCwgJGNvcmRvdmFDYW1lcmEsICRpb25pY1BvcHVwLCBJbWFnZVVwbG9hZFNlcnZpY2UsICRpb25pY1BsYXRmb3JtLCAkaW9uaWNTbGlkZUJveERlbGVnYXRlLCAkaW9uaWNQb3BvdmVyLCAkZmlsdGVyLCAkc3RhdGUsIEFQSXMsICRpb25pY0hpc3RvcnksICRpb25pY1Bvc2l0aW9uKSB7XG4gICRzY29wZS5wb3N0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbTtcbiAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgJHNjb3BlLnNwb3N0ID0ge307XG4gICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuXG4gICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyU2xpZGVyci5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwU2xpZGVyciA9IHBvcG92ZXI7XG4gIH0pO1xuICBcbiAgJHNjb3BlLm9wZW5TbGlkZXJyID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgJHNjb3BlLnZvdGluZ1Bvc3QgPSBkO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJHNjb3BlLnJhbmdlVmFsdWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwO1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyci5zaG93KCRldmVudCk7XG4gIH07XG4gICRzY29wZS52b3RlUG9zdFMgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuaGlkZSgpO1xuICAgICRzY29wZS51cHZvdGVQb3N0KCRzY29wZS52b3RpbmdQb3N0KTtcbiAgfVxuICAkc2NvcGUuZHJhZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvL2NvbnNvbGUubG9nKHYpO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCA9IHYqMTAwO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZVNsaWRlcnIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuaGlkZSgpO1xuICB9O1xuXG4gICRzY29wZS5pc0Jvb2ttYXJrZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9va20gPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrIHx8IHVuZGVmaW5lZDtcbiAgICBpZiAoYm9va20gJiYgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSkge1xuICAgICAgdmFyIGxlbiA9IGJvb2ttLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGJvb2ttW2ldICYmIGJvb2ttW2ldLnBlcm1saW5rID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLm9wdGlvbnMgPSB7XG4gICAgbG9vcDogZmFsc2UsXG4gICAgc3BlZWQ6IDUwMCxcbiAgICAvKnBhZ2luYXRpb246IGZhbHNlLCovXG4gICAgc2hvd1BhZ2VyOiBmYWxzZSxcbiAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgIHNwYWNlQmV0d2VlbjogMjAsXG4gICAgYnJlYWtwb2ludHM6IHtcbiAgICAgIDEwMjQ6IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiA1LFxuICAgICAgICAgIHNwYWNlQmV0d2VlbjogMTVcbiAgICAgIH0sXG4gICAgICA3Njg6IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiA0LFxuICAgICAgICAgIHNwYWNlQmV0d2VlbjogMTBcbiAgICAgIH0sXG4gICAgICA2NDA6IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgIHNwYWNlQmV0d2VlbjogNVxuICAgICAgfSxcbiAgICAgIDMyMDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAzXG4gICAgICB9XG4gICAgfVxuICB9XG4gICRzY29wZS5ib29rbWFyayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib29rID0gJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyaztcbiAgICBpZiAoJHNjb3BlLmlzQm9va21hcmtlZCgpKSB7XG4gICAgICB2YXIgbGVuID0gYm9vay5sZW5ndGg7XG4gICAgICB2YXIgaWQgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChib29rW2ldLnBlcm1saW5rID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rKSB7XG4gICAgICAgICAgaWQgPSBib29rW2ldLl9pZDtcbiAgICAgICAgICBib29rLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlkKXtcbiAgICAgICAgQVBJcy5yZW1vdmVCb29rbWFyayhpZCwkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrID0gYm9vaztcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX1VOQk9PS01BUksnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYm9vaykge1xuICAgICAgICB2YXIgb28gPSB7IGF1dGhvcjokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvcixwZXJtbGluazokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rfTtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyay5wdXNoKG9vKTtcbiAgICAgICAgQVBJcy5hZGRCb29rbWFyaygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIG9vICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfQk9PS01BUksnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9vID0geyBhdXRob3I6JHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5hdXRob3IscGVybWxpbms6JHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGlua307XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsgPSBbb29dO1xuXG4gICAgICAgIEFQSXMuYWRkQm9va21hcmsoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBvbyApLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX0JPT0tNQVJLJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9JU19CT09LTUFSSycpKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmxhc3RGb2N1c2VkO1xuXG5cbiAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjQwODkvaW5zZXJ0aW5nLWEtdGV4dC13aGVyZS1jdXJzb3ItaXMtdXNpbmctamF2YXNjcmlwdC1qcXVlcnlcbiAgJHNjb3BlLmluc2VydFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIGlucHV0ID0gJHNjb3BlLmxhc3RGb2N1c2VkO1xuICAgIC8vY29uc29sZS5sb2coaW5wdXQpO1xuICAgIGlmIChpbnB1dCA9PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNjcm9sbFBvcyA9IGlucHV0LnNjcm9sbFRvcDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnJvd3NlciA9ICgoaW5wdXQuc2VsZWN0aW9uU3RhcnQgfHwgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPT0gXCIwXCIpID9cbiAgICAgICAgICAgICAgICAgICBcImZmXCIgOiAoZG9jdW1lbnQuc2VsZWN0aW9uID8gXCJpZVwiIDogZmFsc2UgKSApO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHBvcyA9IHJhbmdlLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikgeyBwb3MgPSBpbnB1dC5zZWxlY3Rpb25TdGFydCB9O1xuXG4gICAgdmFyIGZyb250ID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICB2YXIgYmFjayA9IChpbnB1dC52YWx1ZSkuc3Vic3RyaW5nKHBvcywgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICBpbnB1dC52YWx1ZSA9IGZyb250K3RleHQrYmFjaztcbiAgICBwb3MgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoYnJvd3NlciA9PSBcImllXCIpIHtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgLWlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIHBvcyk7XG4gICAgICByYW5nZS5tb3ZlRW5kIChcImNoYXJhY3RlclwiLCAwKTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyID09IFwiZmZcIikge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBwb3M7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBwb3M7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgIH1cbiAgICBpbnB1dC5zY3JvbGxUb3AgPSBzY3JvbGxQb3M7XG4gICAgY29uc29sZS5sb2coYW5ndWxhci5lbGVtZW50KGlucHV0KS52YWwoKSk7XG4gICAgYW5ndWxhci5lbGVtZW50KGlucHV0KS50cmlnZ2VyKCdpbnB1dCcpO1xuICB9XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJUci5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcCA9IHBvcG92ZXI7XG4gICB9KTtcblxuICAgJHNjb3BlLm9wZW5Ub29sdGlwID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgdmFyIHRwcHYgPSBOdW1iZXIoZC5wZW5kaW5nX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgcCA9IE51bWJlcihkLnByb21vdGVkLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciB0cHYgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIGFyID0gTnVtYmVyKGQudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0tZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgY3JwID0gTnVtYmVyKGQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRleHRoID0gXCI8ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPVEVOVElBTF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHBwdiwgMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BST01PVEVEJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHAsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBU1RfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwdiwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVVUSE9SX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShhciwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ1VSQVRJT05fUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGNycCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCd0aW1lYWdvJykoZC5jYXNob3V0X3RpbWUsIHRydWUpK1wiPC9kaXY+PC9kaXY+XCI7XG4gICAgJHNjb3BlLnRvb2x0aXBUZXh0ID0gdGV4dGg7XG4gICAgJHNjb3BlLnRvb2x0aXAuc2hvdygkZXZlbnQpO1xuICAgfTtcblxuICAgJHNjb3BlLmNsb3NlVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvb2x0aXAuaGlkZSgpO1xuICAgfTtcblxuICAgLy9DbGVhbnVwIHRoZSBwb3BvdmVyIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b29sdGlwLnJlbW92ZSgpO1xuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIGhpZGUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5oaWRkZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gcmVtb3ZlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIucmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG5cbiAgJHNjb3BlLmlzSW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0pIHtcbiAgICAgIHZhciBsZW4gPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmpzb25fbWV0YWRhdGEuaW1hZ2U/JHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLmltYWdlLmxlbmd0aDowO1xuICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgJHNjb3BlLmltYWdlcyA9ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uanNvbl9tZXRhZGF0YS5pbWFnZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gICRzY29wZS56b29tTWluID0gMTtcbiAgJHNjb3BlLnNob3dJbWFnZXMgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICRzY29wZS5hY3RpdmVTbGlkZSA9IGluZGV4O1xuICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKCRzY29wZS5pbWFnZXNbaW5kZXhdKSk7XG4gICAgJHNjb3BlLnNob3dHYWxsZXJ5TW9kYWwoJ3RlbXBsYXRlcy9nYWxsZXJ5X2ltYWdlcy5odG1sJyk7XG4gIH07XG5cbiAgJHNjb3BlLnNob3dHYWxsZXJ5TW9kYWwgPSBmdW5jdGlvbih0ZW1wbGF0ZVVybCkge1xuICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCh0ZW1wbGF0ZVVybCwge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICAgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAgICRzY29wZS5tb2RhbGcgPSBtb2RhbDtcbiAgICAgICRzY29wZS5tb2RhbGcuc2hvdygpO1xuICAgIH0pO1xuICB9XG5cbiAgJHNjb3BlLmNsb3NlR2FsbGVyeU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFsZy5oaWRlKCk7XG4gICAgJHNjb3BlLm1vZGFsZy5yZW1vdmUoKVxuICB9O1xuXG4gICRzY29wZS51cGRhdGVTbGlkZVN0YXR1cyA9IGZ1bmN0aW9uKHNsaWRlKSB7XG4gICAgdmFyIHpvb21GYWN0b3IgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ3Njcm9sbEhhbmRsZScgKyBzbGlkZSkuZ2V0U2Nyb2xsUG9zaXRpb24oKS56b29tO1xuICAgIGlmICh6b29tRmFjdG9yID09ICRzY29wZS56b29tTWluKSB7XG4gICAgICAkaW9uaWNTbGlkZUJveERlbGVnYXRlLmVuYWJsZVNsaWRlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW9uaWNTbGlkZUJveERlbGVnYXRlLmVuYWJsZVNsaWRlKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLnNob3dJbWcgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgYnV0dG9uczogW1xuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBUFRVUkVfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9DVVNUT01fVVJMJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdHQUxMRVJZJykgfVxuICAgICBdLFxuICAgICB0aXRsZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTlNFUlRfUElDVFVSRScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAkc2NvcGUuaW5zZXJ0SW1hZ2UoaW5kZXgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfVxuICAgfSk7XG4gIH07XG4gICRzY29wZS5pbnNlcnRJbWFnZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmICgkc2NvcGUuZWRpdCkge1xuICAgICAgaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IDEpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgICBkZXN0aW5hdGlvblR5cGU6IENhbWVyYS5EZXN0aW5hdGlvblR5cGUuRklMRV9VUkksXG4gICAgICAgICAgc291cmNlVHlwZTogKHR5cGU9PT0wKT9DYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuQ0FNRVJBOkNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgICAgZW5jb2RpbmdUeXBlOiBDYW1lcmEuRW5jb2RpbmdUeXBlLkpQRUcsXG4gICAgICAgICAgcG9wb3Zlck9wdGlvbnM6IENhbWVyYVBvcG92ZXJPcHRpb25zLFxuICAgICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgICAgLy9jb3JyZWN0T3JpZW50YXRpb246dHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEltYWdlVXBsb2FkU2VydmljZS51cGxvYWRJbWFnZShpbWFnZURhdGEpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0LmltYWdlVXJsIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhmaW5hbCk7XG4gICAgICAgICAgICAgIC8qaWYgKCRzY29wZS5zcG9zdC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgKz0gZmluYWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgPSBmaW5hbDtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTUVSQV9DQU5DRUxMRUQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IDIpe1xuICAgICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1VSTCcpLFxuICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRElSRUNUX0xJTktfUElDVFVSRScpLFxuICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICAgIGlucHV0UGxhY2Vob2xkZXI6ICdodHRwOi8vZXhhbXBsZS5jb20vaW1hZ2UuanBnJ1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycgKyByZXMpO1xuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSByZXMudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgIC8qaWYgKCRzY29wZS5zcG9zdC5ib2R5KSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ICs9IGZpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgPSBmaW5hbDtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuZ2FsbGVyeSA9IFtdO1xuICAgICAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIHZhciBpbWdzID0gcmVzLmRhdGE7XG4gICAgICAgICAgaWYgKGltZ3MubGVuZ3RoPjApe1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5nYWxsZXJ5LmltYWdlcyA9IGltZ3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93Z2FsbGVyeSA9IGZhbHNlO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTk9fSU1BR0UnKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gaW1hZ2VzIGF2YWlsYWJsZScpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IDEpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgICBkZXN0aW5hdGlvblR5cGU6IENhbWVyYS5EZXN0aW5hdGlvblR5cGUuRklMRV9VUkksXG4gICAgICAgICAgc291cmNlVHlwZTogKHR5cGU9PT0wKT9DYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuQ0FNRVJBOkNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgICAgZW5jb2RpbmdUeXBlOiBDYW1lcmEuRW5jb2RpbmdUeXBlLkpQRUcsXG4gICAgICAgICAgcG9wb3Zlck9wdGlvbnM6IENhbWVyYVBvcG92ZXJPcHRpb25zLFxuICAgICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgICAgLy9jb3JyZWN0T3JpZW50YXRpb246dHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEltYWdlVXBsb2FkU2VydmljZS51cGxvYWRJbWFnZShpbWFnZURhdGEpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0LmltYWdlVXJsIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhmaW5hbCk7XG4gICAgICAgICAgICAgIC8qaWYgKCRzY29wZS5kYXRhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9IGZpbmFsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBmaW5hbDtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICRzY29wZS5pbnNlcnRUZXh0KGZpbmFsKTtcbiAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTUVSQV9DQU5DRUxMRUQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09IDIpe1xuICAgICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1VSTCcpLFxuICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRElSRUNUX0xJTktfUElDVFVSRScpLFxuICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICAgIGlucHV0UGxhY2Vob2xkZXI6ICdodHRwOi8vZXhhbXBsZS5jb20vaW1hZ2UuanBnJ1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycgKyByZXMpO1xuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSByZXMudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgIC8qaWYgKCRzY29wZS5kYXRhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCArPSBmaW5hbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBmaW5hbDtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuZ2FsbGVyeSA9IFtdO1xuICAgICAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIHZhciBpbWdzID0gcmVzLmRhdGE7XG4gICAgICAgICAgaWYgKGltZ3MubGVuZ3RoPjApe1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICRzY29wZS5nYWxsZXJ5LmltYWdlcyA9IGltZ3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5zaG93Z2FsbGVyeSA9IGZhbHNlO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTk9fSU1BR0UnKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gaW1hZ2VzIGF2YWlsYWJsZScpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvc3RvcnkuaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgJHNjb3BlLnBtb2RhbCA9IG1vZGFsO1xuICB9KTtcbiAgJHNjb3BlLm9wZW5Qb3N0TW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAvL2lmKCEkc2NvcGUucG1vZGFsKSByZXR1cm47XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5wbW9kYWwuc2hvdygpO1xuICAgICAgLyphbmd1bGFyLmVsZW1lbnQoXCJ0ZXh0YXJlYVwiKS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxhc3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgICAgfSk7Ki9cbiAgICB9LCAxMCk7XG4gIH07XG5cbiAgJHJvb3RTY29wZS4kb24oJ2Nsb3NlUG9zdE1vZGFsJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUucG1vZGFsLmhpZGUoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLmNsb3NlR2FsbGVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gIH1cbiAgJHNjb3BlLm1hbmFnZUdhbGxlcnkgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gICAgJHN0YXRlLmdvKCdhcHAuaW1hZ2VzJyk7XG4gIH1cbiAgdmFyIGRtcCA9IG5ldyB3aW5kb3cuZGlmZl9tYXRjaF9wYXRjaCgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKHRleHQxLCB0ZXh0Mikge1xuICAgICAgaWYgKCF0ZXh0MSAmJiB0ZXh0MSA9PT0gJycpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcGF0Y2hlcyA9IGRtcC5wYXRjaF9tYWtlKHRleHQxLCB0ZXh0Mik7XG4gICAgICB2YXIgcGF0Y2ggPSBkbXAucGF0Y2hfdG9UZXh0KHBhdGNoZXMpO1xuICAgICAgcmV0dXJuIHBhdGNoO1xuICB9XG4gICRzY29wZS5jZm9jdXMgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgJHNjb3BlLmRlbGV0ZVBvc3QgPSBmdW5jdGlvbih4eCkge1xuICAgICRyb290U2NvcGUubG9nKCdkZWxldGUgcG9zdCAnKyBhbmd1bGFyLnRvSnNvbih4eCkpO1xuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdERUxFVEVfQ09NTUVOVCcpXG4gICAgfSk7XG4gICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuXG4gICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiZGVsZXRlX2NvbW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgYXV0aG9yOiB4eC5hdXRob3IsXG4gICAgICAgICAgICAgICAgICBwZXJtbGluazogeHgucGVybWxpbmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUubG9nKG15X3B1YmtleXMpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0RFTEVURURfQ09NTUVOVCcpKTtcbiAgICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICB9XG4gICRzY29wZS5lZGl0ID0gZmFsc2U7XG4gICRzY29wZS5lZGl0UG9zdCA9IGZ1bmN0aW9uKHh4KSB7XG4gICAgJHNjb3BlLmVkaXQgPSB0cnVlO1xuICAgICRzY29wZS5vcGVuUG9zdE1vZGFsKCk7XG4gICAgYW5ndWxhci5lbGVtZW50KFwidGV4dGFyZWFcIikuZm9jdXMoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUubGFzdEZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgY29uc29sZS5sb2coZG9jdW1lbnQpO1xuICAgIH0pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISRzY29wZS5zcG9zdC5ib2R5KSB7XG4gICAgICAgICRzY29wZS5zcG9zdCA9IHh4O1xuICAgICAgICAkc2NvcGUucGF0Y2hib2R5ID0geHguYm9keTtcbiAgICAgIH1cbiAgICAgICRzY29wZS5zcG9zdC50YWdzID0gYW5ndWxhci5mcm9tSnNvbih4eC5qc29uX21ldGFkYXRhKS50YWdzLmpvaW4oKS5yZXBsYWNlKC9cXCwvZywnICcpO1xuICAgIH0sIDEwKTtcbiAgfVxuXG4gICRzY29wZS5zdWJtaXRTdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgIGlmICgkc2NvcGUuZWRpdCkge1xuICAgICAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2goJHNjb3BlLnBhdGNoYm9keSwgJHNjb3BlLnNwb3N0LmJvZHkpXG4gICAgICAvLyBQdXR0aW5nIGJvZHkgaW50byBidWZmZXIgd2lsbCBleHBhbmQgVW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlaXIgdHJ1ZSBsZW5ndGhcbiAgICAgIGlmIChwYXRjaCAmJiBwYXRjaC5sZW5ndGggPCBuZXcgQnVmZmVyKCRzY29wZS5zcG9zdC5ib2R5LCAndXRmLTgnKS5sZW5ndGgpIHtcbiAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkyID0gcGF0Y2g7XG4gICAgICB9XG4gICAgICAvLyRyb290U2NvcGUubG9nKHBhdGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnNwb3N0LmJvZHkyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgdmFyIHBlcm1saW5rID0gJHNjb3BlLnNwb3N0LnBlcm1saW5rO1xuICAgICAgICB2YXIgampzb24gPSAkZmlsdGVyKFwibWV0YWRhdGFcIikoJHNjb3BlLnNwb3N0LmJvZHkpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGpqc29uKTtcbiAgICAgICAgLy8kc2NvcGUuc3Bvc3QudGFncyA9ICRmaWx0ZXIoJ2xvd2VyY2FzZScpKCRzY29wZS5zcG9zdC50YWdzKTtcbiAgICAgICAgdmFyIGpzb24gPSBhbmd1bGFyLm1lcmdlKGpqc29uLCB7dGFnczogJHNjb3BlLnNwb3N0LnRhZ3Muc3BsaXQoXCIgXCIpLCBhcHA6ICdlc3RlZW0vJyskcm9vdFNjb3BlLiRzdG9yYWdlLmFwcHZlcnNpb24sIGZvcm1hdDogJ21hcmtkb3duK2h0bWwnIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGpzb24pO1xuICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICBwYXJlbnRfYXV0aG9yOiBcIlwiLFxuICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnNwb3N0LnBhcmVudF9wZXJtbGluayxcbiAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICBwZXJtbGluazogJHNjb3BlLnNwb3N0LnBlcm1saW5rLFxuICAgICAgICAgIHRpdGxlOiAkc2NvcGUuc3Bvc3QudGl0bGUsXG4gICAgICAgICAgYm9keTogJHNjb3BlLnNwb3N0LmJvZHkyIHx8ICRzY29wZS5zcG9zdC5ib2R5LFxuICAgICAgICAgIGpzb25fbWV0YWRhdGE6IGFuZ3VsYXIudG9Kc29uKGpzb24pXG4gICAgICAgIH0pO1xuICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgICAgICAgIGFsbG93X2N1cmF0aW9uX3Jld2FyZHM6IHRydWUsXG4gICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgcGVybWxpbms6ICRzY29wZS5zcG9zdC5wZXJtbGluayxcbiAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBcIjEwMDAwMDAuMDAwIFwiKyRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCxcbiAgICAgICAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6IDEwMDAwLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHsgXCJiZW5lZmljaWFyaWVzXCI6IHsgXCJhY2NvdW50XCI6XCJlc3RlZW1hcHBcIiwgXCJ3ZWlnaHRcIjoxMDAgfSB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyRyb290U2NvcGUubG9nKG15X3B1YmtleXMpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8kc2NvcGUuY2xvc2VQb3N0TW9kYWwoKTtcblxuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZVBvc3RNb2RhbCcpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QgPSB7fTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9TVUJNSVRURUQnKSk7XG4gICAgICAgICAgICAvLyRzY29wZS5jbG9zZVBvc3RQb3BvdmVyKCk7XG4gICAgICAgICAgICAgICRzdGF0ZS5nbyhcImFwcC5wcm9maWxlXCIsIHt1c2VybmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfSk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICB9XG4gIH1cbiAgJHNjb3BlLmFkZEltYWdlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgJHNjb3BlLmRhdGEuY29tbWVudCArPSAnICFbaW1hZ2VdKCcrdXJsKycpICc7XG4gIH1cbiAgJHNjb3BlLnJlcGx5ID0gZnVuY3Rpb24gKHh4KSB7XG4gICAgLy8kcm9vdFNjb3BlLmxvZyh4eCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICB2YXIgdGltZWZvcm1hdCA9IHQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpKyh0LmdldE1vbnRoKCkrMSkudG9TdHJpbmcoKSt0LmdldERhdGUoKS50b1N0cmluZygpK1widFwiK3QuZ2V0SG91cnMoKS50b1N0cmluZygpK3QuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkrdC5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSt0LmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCkrXCJ6XCI7XG4gICAgICAgICAgdmFyIGpzb24gPSB7dGFnczogYW5ndWxhci5mcm9tSnNvbigkc2NvcGUucG9zdC5qc29uX21ldGFkYXRhKS50YWdzWzBdIHx8IFtcImVzdGVlbVwiXSAsIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50XCIsIHtcbiAgICAgICAgICAgIHBhcmVudF9hdXRob3I6ICRzY29wZS5wb3N0LmF1dGhvcixcbiAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnBvc3QucGVybWxpbmssXG4gICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHBlcm1saW5rOiBcInJlLVwiKyRzY29wZS5wb3N0LmF1dGhvcitcIi1cIiskc2NvcGUucG9zdC5wZXJtbGluaytcIi1cIit0aW1lZm9ybWF0LFxuICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICBib2R5OiAkc2NvcGUuZGF0YS5jb21tZW50LFxuICAgICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICAgIGFsbG93X3ZvdGVzOiB0cnVlLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogXCJyZS1cIiskc2NvcGUucG9zdC5hdXRob3IrXCItXCIrJHNjb3BlLnBvc3QucGVybWxpbmsrXCItXCIrdGltZWZvcm1hdCwgIFxuICAgICAgICAgICAgbWF4X2FjY2VwdGVkX3BheW91dDogXCIxMDAwMDAwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQsXG4gICAgICAgICAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6IDEwMDAwLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogeyBcImJlbmVmaWNpYXJpZXNcIjogeyBcImFjY291bnRcIjpcImVzdGVlbWFwcFwiLCBcIndlaWdodFwiOjEwMCB9IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRzY29wZS5jbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTU1FTlRfU1VCTUlUVEVEJykpO1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudF9yZXBsaWVzXCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jb21tZW50cyA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAkcm9vdFNjb3BlLiRvbihcInVwZGF0ZTpjb250ZW50XCIsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS5sb2coXCJ1cGRhdGU6Y29udGVudFwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmdldENvbnRlbnQoJHNjb3BlLnBvc3QuYXV0aG9yLCAkc2NvcGUucG9zdC5wZXJtbGluayk7ICBcblxuICAgIC8qd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudF9yZXBsaWVzXCIsIFskc2NvcGUucG9zdC5hdXRob3IsICRzY29wZS5wb3N0LnBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvL3RvZG8gZml4IGFjdGl2ZV92b3Rlc1xuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgJHNjb3BlLmNvbW1lbnRzID0gcmVzdWx0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgIH0pO1xuICAgIH0pOyovXG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcblxuXG5cbiAgICB9LCAxMDApO1xuXG5cblxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gIH0pO1xuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9yZXBseS5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUubW9kYWwgPSBtb2RhbDtcbiAgfSk7XG5cbiAgJHNjb3BlLm9wZW5Nb2RhbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAvL2lmKCEkc2NvcGUubW9kYWwpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLm1vZGFsLnNob3coKTtcbiAgICB9LCA1KTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICRzY29wZS5tb2RhbC5oaWRlKCk7XG4gIH07XG5cbiAgJHNjb3BlLmlzcmVwbHlpbmcgPSBmdW5jdGlvbihjaG8sIHh4KSB7XG4gICAgJHNjb3BlLnJlcGx5aW5nID0geHg7XG4gICAgYW5ndWxhci5tZXJnZSgkc2NvcGUucG9zdCwgY2hvKTtcbiAgICBpZiAoeHgpIHtcbiAgICAgICRzY29wZS5vcGVuTW9kYWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5hY2NvdW50cyA9IHt9O1xuICAkc2NvcGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uKGF1dGhvciwgcGVybWxpbmspIHtcbiAgICAvL2NvbnNvbGUudGltZSgnc29tZUZ1bmN0aW9uMScpO1xuICAgIHZhciB1cmwgPSBcIi9cIiskc3RhdGVQYXJhbXMuY2F0ZWdvcnkrXCIvQFwiK2F1dGhvcitcIi9cIitwZXJtbGluaztcbiAgICAvL2NvbnNvbGUubG9nKHVybCk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudFwiLCBbYXV0aG9yLCBwZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB2YXIgbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cyAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cy5pbmRleE9mKHJlc3VsdC5hdXRob3IpID09IC0xKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHMucHVzaChyZXN1bHQuYXV0aG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24ocmVzdWx0Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAvLyRzY29wZS5wb3N0LmJvZHkgPSByZXN1bHQuYm9keTtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IHJlc3VsdDtcbiAgICAgICAgXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Bvc3RBY2NvdW50cycpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgXG4gICAgICAvKndpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9zdGF0ZVwiLCBbdXJsXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coZGQpO1xuICAgICAgICB2YXIgY29uID0gZGQuY29udGVudDtcbiAgICAgICAgdmFyIGFjb24gPSBkZC5hY2NvdW50cztcblxuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29uLCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgIHYuY29tbWVudHMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbiwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICB2YXIgdnBhcmVudCA9IHYucGFyZW50X2F1dGhvcj09XCJcIj92LmF1dGhvcjp2LnBhcmVudF9hdXRob3I7XG4gICAgICAgICAgdmFyIHZwZXJtID0gdi5wYXJlbnRfYXV0aG9yPT1cIlwiP3YucGVybWxpbms6di5wYXJlbnRfcGVybWxpbms7XG4gICAgICAgICAgdmFyIGtleXkgPSB2cGFyZW50K1wiL1wiK3ZwZXJtO1xuICAgICAgICAgIGlmICh2LmRlcHRoID4gNykge1xuICAgICAgICAgICAgdi5zaG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYucGFyZW50X3Blcm1saW5rIT09di5jYXRlZ29yeSkge1xuICAgICAgICAgICAgaWYgKGNvbltrZXl5XSkge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYpO1xuICAgICAgICAgICAgICB2YXIgbGxlbiA9IHYuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdmFyIGx1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICAgICAgICBpZiAobHVzZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqbCA9IGxsZW4gLSAxOyBqbCA+PSAwOyBqbC0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbamxdLnZvdGVyID09PSBsdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbamxdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LmFjdGl2ZV92b3Rlc1tqbF0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB2LnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uW2tleXldLmNvbW1lbnRzLnB1c2godik7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coYWNvbik7ICBcbiAgICAgICAgLy99LCAxKTtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGFjb24sIGZ1bmN0aW9uKHYsayl7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyh2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygdi5qc29uX21ldGFkYXRhID09PSAnc3RyaW5nJyB8fCB2Lmpzb25fbWV0YWRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh2Lmpzb25fbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YS5pbmRleE9mKFwiY3JlYXRlZF9hdFwiKT4tMSkge1xuICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oYW5ndWxhci50b0pzb24odi5qc29uX21ldGFkYXRhKSk7ICBcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29uW2F1dGhvcitcIi9cIitwZXJtbGlua107XG5cbiAgICAgICAgdmFyIGxlbiA9IHJlc3VsdC5hY3RpdmVfdm90ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgdXNlciA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcjtcbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gbGVuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnZvdGVyID09PSB1c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihyZXN1bHQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRzY29wZS5wb3N0ID0gcmVzdWx0O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gcmVzdWx0O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBhY2NvdW50cyA9IGFjb247XG5cbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfSovXG4gICAgfSk7XG4gIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgLy9jb25zb2xlLnRpbWVFbmQoJ3NvbWVGdW5jdGlvbjEnKTtcblxuICB9O1xuICBcbiAgJHNjb3BlLmZldGNoQ29tbWVudHMgPSBmdW5jdGlvbihhdXRob3IsIHBlcm1saW5rKXtcbiAgICAkcm9vdFNjb3BlLmZldGNoaW5nID0gdHJ1ZTtcbiAgICAvL2NvbnNvbGUubG9nKGF1dGhvcixwZXJtbGluayk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudF9yZXBsaWVzXCIsIFthdXRob3IsIHBlcm1saW5rXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgIC8qZm9yICh2YXIgaSA9IDA7IGkgPCBkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY3RpdmVfdm90ZXNcIiwgW2RkW2ldLmF1dGhvciwgZGRbaV0ucGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgICBkZFtpXS5hY3RpdmVfdm90ZXMgPSByZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0qL1xuICAgICAgICAkc2NvcGUuY29tbWVudHMgPSBkZDtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jb21tZW50cyA9IGRkO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGRkLmFjdGl2ZV92b3Rlcyk7XG4gICAgICAgICRyb290U2NvcGUuZmV0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHYgPSBkZFtpXTtcbiAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHMgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHMuaW5kZXhPZih2LmF1dGhvcikgPT0gLTEpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzLnB1c2godi5hdXRob3IpO1xuICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm15LWhhbmRsZScpO1xuICAgICAgICAgICRzY29wZS5xdW90ZVBvc2l0aW9uID0gJGlvbmljUG9zaXRpb24ucG9zaXRpb24oYW5ndWxhci5lbGVtZW50KHAyKSk7XG4gICAgICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtYWluU2Nyb2xsJykuc2Nyb2xsVG8oMCwkc2NvcGUucXVvdGVQb3NpdGlvbi50b3AsIHRydWUpOyAgXG4gICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Bvc3RBY2NvdW50cycpO1xuICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTApO1xuICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAkc2NvcGUuJG9uKCdwb3N0QWNjb3VudHMnLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzID0ge307XG4gICAgLy9jb25zb2xlLmxvZyh3aW5kb3cuQXBpKTtcbiAgICAvL3dpbmRvdy5BcGkgPSBzdGVlbVJQQy5DbGllbnQuZ2V0KHt1cmw6bG9jYWxTdG9yYWdlLnNvY2tldFVybH0sIHRydWUpO1xuXG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHYgPSByZXNbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB2Lmpzb25fbWV0YWRhdGEgPT09ICdzdHJpbmcnIHx8IHYuanNvbl9tZXRhZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICBpZiAodi5qc29uX21ldGFkYXRhLmluZGV4T2YoXCJjcmVhdGVkX2F0XCIpPi0xKSB7XG4gICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihhbmd1bGFyLnRvSnNvbih2Lmpzb25fbWV0YWRhdGEpKTsgIFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIga2V5ID0gdi5uYW1lO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBhY2NvdW50c1trZXldID0gdi5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmVudGVyJywgZnVuY3Rpb24oZXYpe1xuICAgIC8vY29uc29sZS5sb2coZXYpO1xuICAgIC8vaWYoZXYudGFyZ2V0U2NvcGUgIT09ICRzY29wZSlcbiAgICAvLyAgcmV0dXJuO1xuICAgICRyb290U2NvcGUubG9nKCdlbnRlciBwb3N0Y3RybCcpO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzID0gW107XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wYWNjb3VudHMgPSBbXTtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCRzdGF0ZVBhcmFtcy5jYXRlZ29yeSA9PT0gJzExMScpIHtcbiAgICAgIHZhciB0dGVtcCA9ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW07XG4gICAgICAkc2NvcGUucG9zdCA9IHR0ZW1wO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCd1cGRhdGU6Y29udGVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJHN0YXRlUGFyYW1zLmF1dGhvci5pbmRleE9mKCdAJyk+LTEpe1xuICAgICAgICAkc3RhdGVQYXJhbXMuYXV0aG9yID0gJHN0YXRlUGFyYW1zLmF1dGhvci5zdWJzdHIoMSk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnc29tZUZ1bmN0aW9uJyk7XG4gICAgICAkc2NvcGUuZ2V0Q29udGVudCgkc3RhdGVQYXJhbXMuYXV0aG9yLCAkc3RhdGVQYXJhbXMucGVybWxpbmspO1xuICAgIH1cbiAgfSk7XG4gIFxuICAkc2NvcGUudXB2b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1cHZvdGUnLCAnZ2V0Q29udGVudCcpO1xuICB9O1xuICAkcm9vdFNjb3BlLiRvbignZ2V0Q29udGVudCcsIGZ1bmN0aW9uKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuZ2V0Q29udGVudCgkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5wZXJtbGluayk7ICBcbiAgICB9LCAxMDApO1xuICB9KTtcbiAgJHNjb3BlLmRvd252b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGTEFHR0lOR19URVhUJylcbiAgICB9KTtcbiAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgIGlmKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ2Rvd252b3RlJywgJ2dldENvbnRlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gICRzY29wZS51bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vudm90ZScsICdnZXRDb250ZW50Jyk7XG4gIH07XG5cblxufSlcbmFwcC5jb250cm9sbGVyKCdCb29rbWFya0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJHN0YXRlLCBBUElzLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkZmlsdGVyKSB7XG5cbiAgJHNjb3BlLnJlbW92ZUJvb2ttYXJrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyaykge1xuICAgICAgQVBJcy5yZW1vdmVCb29rbWFyaygkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrW2luZGV4XS5faWQsJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsuc3BsaWNlKGluZGV4LDEpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX1VOQk9PS01BUksnKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgQVBJcy5nZXRCb29rbWFya3MoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrID0gcmVzLmRhdGE7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmFwcC5jb250cm9sbGVyKCdEcmFmdHNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRzdGF0ZSwgQVBJcywgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGZpbHRlcikge1xuICAvL0pTT04uc3RyaW5naWZ5KHtcbiAgJHNjb3BlLnJlbW92ZURyYWZ0ID0gZnVuY3Rpb24oX2lkKSB7XG4gICAgQVBJcy5yZW1vdmVEcmFmdChfaWQsJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICBBUElzLmdldERyYWZ0cygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAkc2NvcGUuZHJhZnRzID0gcmVzLmRhdGE7XG4gICAgICB9KTtcbiAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfVU5EUkFGVCcpKTtcbiAgICB9KTtcbiAgfTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICBBUElzLmdldERyYWZ0cygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICRzY29wZS5kcmFmdHMgPSByZXMuZGF0YTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ0ltYWdlc0N0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJHN0YXRlLCBBUElzLCAkaW50ZXJ2YWwsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkZmlsdGVyKSB7XG4gIC8vSlNPTi5zdHJpbmdpZnkoe1xuICAkc2NvcGUucmVtb3ZlSW1hZ2UgPSBmdW5jdGlvbihfaWQpIHtcbiAgICBBUElzLnJlbW92ZUltYWdlKF9pZCwkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgJHNjb3BlLmltYWdlcyA9IHJlcy5kYXRhO1xuICAgICAgfSk7XG4gICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTUFHRV9SRU1PVkVEJykpO1xuICAgIH0pO1xuICB9O1xuICAkc2NvcGUuY29weUltYWdlID0gZnVuY3Rpb24odXJsKXtcbiAgICBjb3Jkb3ZhLnBsdWdpbnMuY2xpcGJvYXJkLmNvcHkodXJsKTtcbiAgfTtcbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgQVBJcy5mZXRjaEltYWdlcygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICRzY29wZS5pbWFnZXMgPSByZXMuZGF0YTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ05vdGlmaWNhdGlvbnNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRzdGF0ZSwgQVBJcywgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuXG4gICRzY29wZS5yZW1vdmVOb3RpZmljYXRpb24gPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucy5zcGxpY2UoaW5kZXgsMSk7XG4gICAgfVxuICB9O1xufSlcbmFwcC5jb250cm9sbGVyKCdGb2xsb3dDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRzdGF0ZSwgQVBJcywgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSkge1xuICAkc2NvcGUuc2VhcmNodSA9IHt9O1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5hY3RpdmUgPSBcImZvbGxvd2Vyc1wiO1xuICAgICRzY29wZS5mb2xsb3dlcnMgPSBbXTtcbiAgICAkc2NvcGUuZm9sbG93aW5nID0gW107XG4gICAgJHNjb3BlLmxpbWl0ID0gMTAwO1xuICAgICRzY29wZS50dCA9IHtydXNlcjpcIlwiLCBkdXNlcjpcIlwifTtcblxuICAgICRzY29wZS5yZmV0Y2hpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZm9sbG93X2FwaSgpLmV4ZWMoXCJnZXRfZm9sbG93ZXJzXCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsICRzY29wZS50dC5ydXNlciwgXCJibG9nXCIsICRzY29wZS5saW1pdF0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGg9PT0kc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgICRzY29wZS50dC5ydXNlciA9IHJlc1tyZXMubGVuZ3RoLTFdLmZvbGxvd2VyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgdmFyIGxsID0gcmVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXS5pZCArPSAxO1xuICAgICAgICAgICAgJHNjb3BlLmZvbGxvd2Vycy5wdXNoKHJlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMubGVuZ3RoIDwgJHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCRzY29wZS5yZmV0Y2hpbmcsIDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLmRmZXRjaGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dpbmdcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgJHNjb3BlLnR0LmR1c2VyLCBcImJsb2dcIiwgJHNjb3BlLmxpbWl0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aD09PSRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgJHNjb3BlLnR0LmR1c2VyID0gcmVzW3Jlcy5sZW5ndGgtMV0uZm9sbG93aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGwgPSByZXMubGVuZ3RoO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGw7IGkrKykge1xuICAgICAgICAgICAgcmVzW2ldLmlkICs9IDE7XG4gICAgICAgICAgICAkc2NvcGUuZm9sbG93aW5nLnB1c2gocmVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGg8JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCRzY29wZS5kZmV0Y2hpbmcsIDUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHNjb3BlLnJmZXRjaGluZygpO1xuICAgICRzY29wZS5kZmV0Y2hpbmcoKTtcblxuICB9KTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmxlYXZlJywgZnVuY3Rpb24oKXtcbiAgICAvKmlmIChhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGZldGNoaW5nKSl7XG4gICAgICAkaW50ZXJ2YWwuY2FuY2VsKCRzY29wZS5kZmV0Y2hpbmcpO1xuICAgICAgJHNjb3BlLmRmZXRjaGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICRzY29wZS5mb2xsb3dpbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUucmZldGNoaW5nKSl7XG4gICAgICAkaW50ZXJ2YWwuY2FuY2VsKCRzY29wZS5yZmV0Y2hpbmcpO1xuICAgICAgJHNjb3BlLnJmZXRjaGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICRzY29wZS5mb2xsb3dlcnMgPSB1bmRlZmluZWQ7XG4gICAgfSovXG4gIH0pO1xuICAkc2NvcGUuaXNGb2xsb3dlZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbGVuID0gJHNjb3BlLmZvbGxvd2luZy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCRzY29wZS5mb2xsb3dpbmdbaV0uZm9sbG93aW5nID09IHgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgJHNjb3BlLmlzRm9sbG93aW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHZhciBsZW4gPSAkc2NvcGUuZm9sbG93ZXJzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoJHNjb3BlLmZvbGxvd2Vyc1tpXS5mb2xsb3dlciA9PSB4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gICRzY29wZS5jaGFuZ2UgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAkc2NvcGUuYWN0aXZlID0gdHlwZTtcbiAgICBjb25zb2xlLmxvZyh0eXBlKTtcblxuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdsaXN0U2Nyb2xsJykuc2Nyb2xsVG9wKCk7XG4gICAgLy8kc2NvcGUubG9hZE1vcmUodHlwZSk7XG4gIH1cblxuICAkc2NvcGUuJG9uKCdjdXJyZW50OnJlbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS5sb2coJ2N1cnJlbnQ6cmVsb2FkJyk7XG4gICAgLy8kc3RhdGUuZ28oJHN0YXRlLmN1cnJlbnQsIHt9LCB7cmVsb2FkOiB0cnVlfSk7XG4gICAgJHNjb3BlLmZvbGxvd2VycyA9IFtdO1xuICAgICRzY29wZS5mb2xsb3dpbmcgPSBbXTtcbiAgICAkc2NvcGUucmZldGNoaW5nKCk7XG4gICAgJHNjb3BlLmRmZXRjaGluZygpO1xuICB9KTtcblxuICAkc2NvcGUudW5mb2xsb3dVc2VyID0gZnVuY3Rpb24oeHgpe1xuICAgICRyb290U2NvcGUuZm9sbG93aW5nKHh4LCBcInVuZm9sbG93XCIpO1xuICB9O1xuICAkc2NvcGUuZm9sbG93VXNlciA9IGZ1bmN0aW9uKHh4KXtcbiAgICAkcm9vdFNjb3BlLmZvbGxvd2luZyh4eCwgXCJmb2xsb3dcIik7XG4gIH07XG4gICRzY29wZS5wcm9maWxlVmlldyA9IGZ1bmN0aW9uKHh4KXtcbiAgICAkc3RhdGUuZ28oJ2FwcC5wcm9maWxlJywge3VzZXJuYW1lOiB4eH0pO1xuICB9O1xuXG59KVxuXG5hcHAuY29udHJvbGxlcignUHJvZmlsZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJGlvbmljQWN0aW9uU2hlZXQsICRjb3Jkb3ZhQ2FtZXJhLCBJbWFnZVVwbG9hZFNlcnZpY2UsICRpb25pY1BvcHVwLCAkaW9uaWNTaWRlTWVudURlbGVnYXRlLCAkaW9uaWNIaXN0b3J5LCAkc3RhdGUsIEFQSXMsICRpb25pY1BvcG92ZXIsICRmaWx0ZXIsICRpb25pY01vZGFsKSB7XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJTbGlkZXJycC5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwU2xpZGVyID0gcG9wb3ZlcjtcbiAgfSk7XG4gIFxuICAkc2NvcGUub3BlblNsaWRlciA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgICRzY29wZS52b3RpbmdQb3N0ID0gZDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS5yYW5nZVZhbHVlID0gJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0LzEwMDtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlci5zaG93KCRldmVudCk7XG4gIH07XG5cbiAgJHNjb3BlLmRyYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgLy9jb25zb2xlLmxvZyh2KTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSB2KjEwMDtcbiAgfVxuICAkc2NvcGUudm90ZVBvc3RTID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuaGlkZSgpO1xuICAgICRzY29wZS51cHZvdGVQb3N0KCRzY29wZS52b3RpbmdQb3N0KTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2VTbGlkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcFNsaWRlci5oaWRlKCk7XG4gIH07XG5cbiAgJHNjb3BlLnRyYW5zbGF0aW9uRGF0YSA9IHsgcGxhdGZvcm1uYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSwgcGxhdGZvcm1wb3dlcjogJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyLCBwbGF0Zm9ybXN1bml0OlwiJDEuMDBcIiB9O1xuXG4gICRzY29wZS5nb0JhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmlld0hpc3RvcnkgPSAkaW9uaWNIaXN0b3J5LnZpZXdIaXN0b3J5KCk7XG4gICAgaWYgKCF2aWV3SGlzdG9yeS5iYWNrVmlldykge1xuICAgICAgJHNjb3BlLm9wZW5NZW51KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRpb25pY0hpc3RvcnkuZ29CYWNrKCk7XG4gICAgfVxuICB9O1xuICAkc2NvcGUuZm9sbG93VXNlciA9IGZ1bmN0aW9uKHh4KXtcbiAgICAkcm9vdFNjb3BlLmZvbGxvd2luZyh4eCwgXCJmb2xsb3dcIik7XG4gIH07XG4gICRzY29wZS51bmZvbGxvd1VzZXIgPSBmdW5jdGlvbih4eCl7XG4gICAgJHJvb3RTY29wZS5sb2coeHgpO1xuICAgICRyb290U2NvcGUuZm9sbG93aW5nKHh4LCBcInVuZm9sbG93XCIpO1xuICB9O1xuXG4gICRzY29wZS4kb24oJ2N1cnJlbnQ6cmVsb2FkJywgZnVuY3Rpb24oKXtcbiAgICAkc3RhdGUuZ28oJHN0YXRlLmN1cnJlbnQsIHt9LCB7cmVsb2FkOiB0cnVlfSk7XG4gIH0pO1xuXG4gICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyUFRyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwID0gcG9wb3ZlcjtcbiAgIH0pO1xuXG4gICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICB2YXIgdHBwdiA9IE51bWJlcihkLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRwdiA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdGV4dGggPSBcIjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9URU5USUFMX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHB2LCAzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykocCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTVF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHB2LDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBVVRIT1JfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGFyLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDVVJBVElPTl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoY3JwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ3RpbWVhZ28nKShkLmNhc2hvdXRfdGltZSwgdHJ1ZSkrXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICB9O1xuXG4gICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gICB9O1xuXG4gICAvL0NsZWFudXAgdGhlIHBvcG92ZXIgd2hlbiB3ZSdyZSBkb25lIHdpdGggaXQhXG4gICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvb2x0aXAucmVtb3ZlKCk7XG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gaGlkZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLmhpZGRlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiByZW1vdmUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5yZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgfSk7XG5cbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCdteS1lZGl0Lmh0bWwnLCB7XG4gICAgc2NvcGU6ICRzY29wZSxcbiAgICBhbmltYXRpb246ICdzbGlkZS1pbi11cCdcbiAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICRzY29wZS5tb2RhbEVkaXQgPSBtb2RhbDtcbiAgfSk7XG4gICRzY29wZS5jbG9zZUVkaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFsRWRpdC5oaWRlKCk7XG4gIH07XG4gIC8vIENsZWFudXAgdGhlIG1vZGFsIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tb2RhbEVkaXQucmVtb3ZlKCk7XG4gIH0pO1xuICAvLyBFeGVjdXRlIGFjdGlvbiBvbiBoaWRlIG1vZGFsXG4gICRzY29wZS4kb24oJ21vZGFsLmhpZGRlbicsIGZ1bmN0aW9uKCkge1xuICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gIH0pO1xuICAkc2NvcGUuZWRpdCA9IHt9O1xuICAkc2NvcGUuc2hvd0VkaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgLy9zaG93ZWRpdHNcbiAgICAkc2NvcGUuZWRpdCA9IHt9O1xuICAgICRzY29wZS5lZGl0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEgfHwge307XG4gICAgJHNjb3BlLm1vZGFsRWRpdC5zaG93KCk7XG4gIH1cbiAgJHNjb3BlLnNhdmVFZGl0ID0gZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygkc2NvcGUuZWRpdCk7XG4gICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgIHRlbXBsYXRlOiBcIlwiXG4gICAgfSk7XG4gICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBpZihyZXMpIHtcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRzY29wZS5lZGl0KTtcbiAgICAgICAgICBpZiAodXBkYXRlLnByb2ZpbGVQaWNVcmwpIHtkZWxldGUgdXBkYXRlLnByb2ZpbGVQaWNVcmw7fVxuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vdG9kbzogaWYganNvbl9tZXRhZGF0YSBhbHJlYWR5IGV4aXN0IG1ha2Ugc3VyZSB0byBrZWVwIGl0LlxuICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgICAgICAgICAgICAgIGFjY291bnQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBtZW1vX2tleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLm1lbW9fa2V5LFxuICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5tb2RhbEVkaXQuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLnNob3dQcm9maWxlID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgaGlkZVNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6IFtcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQVBUVVJFX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFTEVDVF9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgIF0sXG4gICAgIGRlc3RydWN0aXZlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFU0VUJyksXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ01PRElGWV9QSUNUVVJFJyksXG4gICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgIH0sXG4gICAgIGJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5jaGFuZ2VQcm9maWxlSW5mbyhpbmRleCwgJ3Byb2ZpbGUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgICB9LFxuICAgICBkZXN0cnVjdGl2ZUJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KXtcbiAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVNFVF9QSUNUVVJFX1RFWFQnKVxuICAgICAgfSk7XG4gICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0ge3Byb2ZpbGU6IHtwcm9maWxlX2ltYWdlOlwiXCJ9IH07XG4gICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5wcm9maWxlUGljVXJsKSB7ZGVsZXRlIHVwZGF0ZS5wcm9maWxlUGljVXJsO31cblxuICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUucHJvZmlsZV9pbWFnZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy90b2RvOiBpZiBqc29uX21ldGFkYXRhIGFscmVhZHkgZXhpc3QgbWFrZSBzdXJlIHRvIGtlZXAgaXQuXG4gICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJhY2NvdW50X3VwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBtZW1vX2tleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLm1lbW9fa2V5LFxuICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgIH0pO1xuICB9O1xuXG5cbiAgJHNjb3BlLmNoYW5nZVByb2ZpbGVJbmZvID0gZnVuY3Rpb24odHlwZSwgd2hpY2gpIHtcbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICB0YXJnZXRXaWR0aDogd2hpY2g9PT0ncHJvZmlsZSc/NTAwOjEwMDAsXG4gICAgICAgICAgdGFyZ2V0SGVpZ2h0OiA1MDAsXG4gICAgICAgICAgcG9wb3Zlck9wdGlvbnM6IENhbWVyYVBvcG92ZXJPcHRpb25zLFxuICAgICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgICAgLy9jb3JyZWN0T3JpZW50YXRpb246dHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlc3VsdC5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSB7IHByb2ZpbGU6IHsgY292ZXJfaW1hZ2U6IFwiXCIsIHByb2ZpbGVfaW1hZ2U6IFwiXCJ9IH07XG4gICAgICAgICAgICBpZiAod2hpY2ggPT09ICdwcm9maWxlJykge1xuICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAodXBkYXRlLnByb2ZpbGVQaWNVcmwpIHtkZWxldGUgdXBkYXRlLnByb2ZpbGVQaWNVcmw7fVxuICAgICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5wcm9maWxlX2ltYWdlID0gdXJsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUuY292ZXJfaW1hZ2UgPSB1cmw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1lbW9fa2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIubWVtb19rZXksXG4gICAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuXG4gICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1KTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgIGlmICghaW9uaWMuUGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTUVSQV9DQU5DRUxMRUQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGlvbmljUG9wdXAucHJvbXB0KHtcbiAgICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9VUkwnKSxcbiAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RJUkVDVF9MSU5LX1BJQ1RVUkUnKSxcbiAgICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBpbnB1dFBsYWNlaG9sZGVyOiAnaHR0cDovL2V4YW1wbGUuY29tL2ltYWdlLmpwZydcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91ciB1cmwgaXMnKyByZXMpO1xuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSB7IHByb2ZpbGU6IHsgcHJvZmlsZV9pbWFnZTogXCJcIiwgY292ZXJfaW1hZ2U6XCJcIiB9IH07XG4gICAgICAgICAgICBpZiAod2hpY2g9PT1cInByb2ZpbGVcIikge1xuICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAodXBkYXRlLnByb2ZpbGVQaWNVcmwpIHtkZWxldGUgdXBkYXRlLnByb2ZpbGVQaWNVcmw7fVxuICAgICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5wcm9maWxlX2ltYWdlID0gcmVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUuY292ZXJfaW1hZ2UgPSByZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1lbW9fa2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIubWVtb19rZXksXG4gICAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLnJlZnJlc2hMb2NhbFVzZXJEYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuc2hvd0NvdmVyID0gZnVuY3Rpb24oKSB7XG4gICB2YXIgaGlkZVNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgIGJ1dHRvbnM6IFtcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQVBUVVJFX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFTEVDVF9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgIF0sXG4gICAgIGRlc3RydWN0aXZlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFU0VUJyksXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ01PRElGWV9DT1ZFUl9QSUNUVVJFJyksXG4gICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgIH0sXG4gICAgIGJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5jaGFuZ2VQcm9maWxlSW5mbyhpbmRleCwgJ2NvdmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfSxcbiAgICAgZGVzdHJ1Y3RpdmVCdXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCl7XG4gICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUJylcbiAgICAgIH0pO1xuICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHtwcm9maWxlOiB7Y292ZXJfaW1hZ2U6XCJcIn0gfTtcbiAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICB1cGRhdGUucHJvZmlsZS5jb3Zlcl9pbWFnZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy90b2RvOiBpZiBqc29uX21ldGFkYXRhIGFscmVhZHkgZXhpc3QgbWFrZSBzdXJlIHRvIGtlZXAgaXQuXG4gICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJhY2NvdW50X3VwZGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBtZW1vX2tleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLm1lbW9fa2V5LFxuICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3JlZnJlc2hMb2NhbFVzZXJEYXRhJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgIH0pO1xuICB9O1xuXG5cbiAgJHJvb3RTY29wZS4kb24oJ3Byb2ZpbGVSZWZyZXNoJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUucmVmcmVzaCgpO1xuICB9KTtcbiAgJHNjb3BlLnVwdm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndXB2b3RlJywgJ3Byb2ZpbGVSZWZyZXNoJyk7XG4gIH07XG4gICRzY29wZS5kb3dudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRkxBR0dJTkdfVEVYVCcpXG4gICAgfSk7XG4gICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICBpZihyZXMpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICdkb3dudm90ZScsICdwcm9maWxlUmVmcmVzaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndW52b3RlJywgJ3Byb2ZpbGVSZWZyZXNoJyk7XG4gIH07XG5cbiAgJHNjb3BlLmlzQW1Gb2xsb3dpbmcgPSBmdW5jdGlvbih4eCkge1xuICAgIGlmICgkc2NvcGUuZm9sbG93aW5nICYmICRzY29wZS5mb2xsb3dpbmcuaW5kZXhPZih4eCkhPT0tMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIC8qJHNjb3BlLiR3YXRjaCgnZm9sbG93aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ2hleSwgbXlWYXIgaGFzIGNoYW5nZWQhJyk7XG4gIH0pOyovXG4gICRzY29wZS5pZkV4aXN0cyA9IGZ1bmN0aW9uKHh4KXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8ICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZGF0YS5wcm9maWxlW2ldLnBlcm1saW5rID09PSB4eCl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgJHNjb3BlLmVuZCA9IGZhbHNlO1xuICAkc2NvcGUuY2xlbiA9IDIwO1xuICAkc2NvcGUubW9yZURhdGFDYW5CZUxvYWRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICgkc2NvcGUuZGF0YS5wcm9maWxlICYmICRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoPjApICYmICEkc2NvcGUuZW5kO1xuICB9XG5cbiAgJHNjb3BlLmxvYWRtb3JlID0gZnVuY3Rpb24oKSB7XG4gICAgLy9jb25zb2xlLmxvZygnbG9hZG1vcmUnKTtcbiAgICB2YXIgcGFyYW1zID0ge3RhZzogJHN0YXRlUGFyYW1zLnVzZXJuYW1lLCBsaW1pdDogMjAsIGZpbHRlcl90YWdzOltdfTtcbiAgICB2YXIgbGVuID0gJHNjb3BlLmRhdGEucHJvZmlsZT8kc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aDowO1xuXG4gICAgLy9jb25zb2xlLmxvZygkc2NvcGUuZGF0YS5wcm9maWxlKTtcblxuICAgIGlmIChsZW4+MCkge1xuICAgICAgZGVsZXRlIHBhcmFtcy5saW1pdDtcbiAgICAgIHBhcmFtcy5zdGFydF9hdXRob3IgPSAkc2NvcGUuZGF0YS5wcm9maWxlW2xlbi0xXS5hdXRob3I7XG4gICAgICBwYXJhbXMuc3RhcnRfcGVybWxpbmsgPSAkc2NvcGUuZGF0YS5wcm9maWxlW2xlbi0xXS5wZXJtbGluaztcblxuICAgICAgaWYgKCRzY29wZS5lbmQpIHtcbiAgICAgICAgLy8kcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFUVVFU1RfTElNSVRfVEVYVCcpKTtcbiAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Njcm9sbC5pbmZpbml0ZVNjcm9sbENvbXBsZXRlJyk7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHBhcmFtcyk7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2coXCJmZXRjaGluZyBwcm9maWxlLi4uYmxvZyAyMCBcIik7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkFwaS5kYXRhYmFzZV9hcGkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCRzY29wZS5hY3RpdmUgPT0gJ2Jsb2cnKSB7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdnb2xvcycpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2VsZWN0X2F1dGhvcnMgPSBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRhZ3M7ICAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2Rpc2N1c3Npb25zX2J5X2Jsb2dcIiwgW3BhcmFtc10pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3BvbnNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVzcG9uc2Vbal07XG4gICAgICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IHYuanNvbl9tZXRhZGF0YT9hbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk6di5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAhJHNjb3BlLiQkcGhhc2U/JHNjb3BlLiRhcHBseSgpOmNvbnNvbGUubG9nKCdwaGFzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAkc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkID09PSB2LmlkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCwgdi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHJvZmlsZS5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRzY29wZS5hY3RpdmUgPT0gJ3Bvc3RzJykge1xuICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZGlzY3Vzc2lvbnNfYnlfY29tbWVudHNcIiwgW3BhcmFtc10pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3BvbnNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVzcG9uc2Vbal07XG4gICAgICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IHYuanNvbl9tZXRhZGF0YT9hbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk6di5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAhJHNjb3BlLiQkcGhhc2U/JHNjb3BlLiRhcHBseSgpOmNvbnNvbGUubG9nKCdwaGFzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAkc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkID09PSB2LmlkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCwgdi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHJvZmlsZS5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRzY29wZS5hY3RpdmUgPT0gJ3JlY2VudC1yZXBsaWVzJykge1xuICAgICAgICAgICAgICB2YXIgcHAgPSBbJHNjb3BlLmRhdGEucHJvZmlsZVskc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aC0xXS5hdXRob3IsICRzY29wZS5kYXRhLnByb2ZpbGVbJHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGgtMV0ucGVybWxpbmssIDIwXTtcbiAgICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3JlcGxpZXNfYnlfbGFzdF91cGRhdGVcIiwgW3BwXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlc3BvbnNlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVzcG9uc2Vbal07XG4gICAgICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IHYuanNvbl9tZXRhZGF0YT9hbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk6di5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAhJHNjb3BlLiQkcGhhc2U/JHNjb3BlLiRhcHBseSgpOmNvbnNvbGUubG9nKCdwaGFzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAkc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2NvcGUuZGF0YS5wcm9maWxlW2ldLmlkID09PSB2LmlkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCwgdi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHJvZmlsZS5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUucHJvZmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUudXNlciA9IHt1c2VybmFtZTogJHN0YXRlUGFyYW1zLnVzZXJuYW1lfTtcbiAgICAkc2NvcGUuZm9sbG93ZXIgPSBbXTtcbiAgICAkc2NvcGUuZm9sbG93aW5nID0gW107XG4gICAgJHNjb3BlLmxpbWl0ID0gMTAwO1xuICAgICRzY29wZS50dCA9IHtkdXNlcjogXCJcIiwgcnVzZXI6IFwiXCJ9O1xuXG4gICAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJHNjb3BlLmFjdGl2ZSkge1xuICAgICAgICAkc2NvcGUuYWN0aXZlID0gXCJibG9nXCI7XG4gICAgICB9XG4gICAgICBpZiAoJHNjb3BlLmFjdGl2ZSAhPSBcImJsb2dcIikge1xuICAgICAgICAkc2NvcGUucmVzdCA9IFwiL1wiKyRzY29wZS5hY3RpdmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUucmVzdCA9IFwiXCI7XG4gICAgICB9XG5cbiAgICAgICRzY29wZS5ub25leGlzdCA9IGZhbHNlO1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9zdGF0ZVwiLCBbXCIvQFwiKyRzdGF0ZVBhcmFtcy51c2VybmFtZSskc2NvcGUucmVzdF0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAkc2NvcGUuZGF0YSA9IHtwcm9maWxlOiBbXX07XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXMuY29udGVudCkubGVuZ3RoPjApIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXMuY29udGVudCwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gdi5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTp2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpe1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09IHYuYXV0aG9yKSB7XG4gICAgICAgICAgICAgICAgICB2LnJlYmxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHJvZmlsZS5wdXNoKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAkc2NvcGUuZGZldGNoaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd2luZ1wiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAkc2NvcGUudHQuZHVzZXIsIFwiYmxvZ1wiLCAkc2NvcGUubGltaXRdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoPT09JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICAkc2NvcGUudHQuZHVzZXIgPSByZXNbcmVzLmxlbmd0aC0xXS5mb2xsb3dpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW4gPSByZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICRzY29wZS5mb2xsb3dpbmcucHVzaChyZXNbaV0uZm9sbG93aW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGg8JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgkc2NvcGUuZGZldGNoaW5nLCA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAkc2NvcGUucmZldGNoaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd2Vyc1wiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAkc2NvcGUudHQucnVzZXIsIFwiYmxvZ1wiLCAkc2NvcGUubGltaXRdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoPT09JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICAkc2NvcGUudHQucnVzZXIgPSByZXNbcmVzLmxlbmd0aC0xXS5mb2xsb3dlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgJHNjb3BlLmZvbGxvd2VyLnB1c2gocmVzW2ldLmZvbGxvd2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGg8JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgkc2NvcGUucmZldGNoaW5nLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJHNjb3BlLmdldEZvbGxvd3MgPSBmdW5jdGlvbihyLGQpIHsgICAgICBcbiAgICAgIGlmIChyKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKFwicmZldGNoaW5nXCIpO1xuICAgICAgICAkc2NvcGUucmZldGNoaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoZCkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImRmZXRjaGluZ1wiKTtcbiAgICAgICAgJHNjb3BlLmRmZXRjaGluZygpO1xuICAgICAgfVxuICAgIH07XG4gICAgJHNjb3BlLmdldE90aGVyVXNlcnNEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImdldE90aGVyVXNlcnNEYXRhXCIpO1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbWyRzdGF0ZVBhcmFtcy51c2VybmFtZV1dKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgICBkZCA9IGRkWzBdO1xuICAgICAgICAgIGlmIChkZCAmJiBkZC5qc29uX21ldGFkYXRhKSB7XG4gICAgICAgICAgICBkZC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihkZC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUudXNlciwgZGQpO1xuICAgICAgICAgIC8vY29uc29sZS5sb2coYW5ndWxhci50b0pzb24oJHNjb3BlLnVzZXIpKTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSk7XG5cbiAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAkc2NvcGUuY3NzID0gKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSA9PT0gJHNjb3BlLnVzZXIudXNlcm5hbWUgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSsnKScsICdiYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLCAnYmFja2dyb3VuZC1wb3NpdGlvbic6J2ZpeGVkJ30gOiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSAkc2NvcGUudXNlci51c2VybmFtZSAmJiAoJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YSAmJiAkc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpKSA/IHsnYmFja2dyb3VuZCc6ICd1cmwoJyskc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLmNzcyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5BcGkuZm9sbG93X2FwaSgpLmV4ZWMoXCJnZXRfZm9sbG93X2NvdW50XCIsIFskc3RhdGVQYXJhbXMudXNlcm5hbWVdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgICRzY29wZS5mb2xsb3dkZXRhaWxzID0gcmVzO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgJHNjb3BlLmdldEZvbGxvd3MobnVsbCwgXCJkXCIpO1xuICAgICAgaWYoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkc2NvcGUucmVmcmVzaCgpO1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09ICRzdGF0ZVBhcmFtcy51c2VybmFtZSkge1xuICAgICAgICAkc2NvcGUuZ2V0T3RoZXJVc2Vyc0RhdGEoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJnZXQgZm9sbG93cyBjb3VudHNcIik7XG4gICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd19jb3VudFwiLCBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgICAgICRzY29wZS5mb2xsb3dkZXRhaWxzID0gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkc3RhdGVQYXJhbXMudXNlcm5hbWUpIHtcbiAgICAgICAgJHNjb3BlLmdldE90aGVyVXNlcnNEYXRhKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmNzcyA9ICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXImJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgPT09ICRzY29wZS51c2VyLnVzZXJuYW1lICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSsnKScsICdiYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLCAnYmFja2dyb3VuZC1wb3NpdGlvbic6J2ZpeGVkJ30gOiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gJHNjb3BlLnVzZXIudXNlcm5hbWUgJiYgKCRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEgJiYgJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmICRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSkpID8geydiYWNrZ3JvdW5kJzogJ3VybCgnKyRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSsnKScsICdiYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLCAnYmFja2dyb3VuZC1wb3NpdGlvbic6J2ZpeGVkJ30gOiBudWxsO1xuICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUuY3NzKTtcbiAgICAvL30sIDEpO1xuXG4gIH0pO1xuICAkc2NvcGUub3Blbk1lbnUgPSBmdW5jdGlvbigpIHtcbiAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgfVxuICAkc2NvcGUuY2hhbmdlID0gZnVuY3Rpb24odHlwZSl7XG4gICAgJHNjb3BlLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgY29uc29sZS5sb2codHlwZSk7XG4gICAgJHNjb3BlLmRhdGEgPSB7cHJvZmlsZTogW119O1xuICAgICRzY29wZS5hY2NvdW50cyA9IFtdO1xuICAgICRzY29wZS5hY3RpdmUgPSB0eXBlO1xuICAgICRzY29wZS5lbmQgPSBmYWxzZTtcbiAgICBcbiAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9IFwiYmxvZ1wiKSB7XG4gICAgICAkc2NvcGUucmVzdCA9IFwiL1wiK3R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5yZXN0ID0gXCJcIjtcbiAgICB9XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfc3RhdGVcIiwgW1wiL0BcIiskc3RhdGVQYXJhbXMudXNlcm5hbWUrJHNjb3BlLnJlc3RdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgaWYgKHJlcy5jb250ZW50KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcy5jb250ZW50KS5sZW5ndGg+MCkge1xuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKHJlcy5jb250ZW50LCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcil7XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gdi5hdXRob3IpIHtcbiAgICAgICAgICAgICAgICAgIHYucmVibG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHYuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gbGVuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wcm9maWxlLnB1c2godik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICRzY29wZS5ub25leGlzdCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZT09PVwidHJhbnNmZXJzXCIgfHwgdHlwZT09PVwicGVybWlzc2lvbnNcIikge1xuICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHJlcy5hY2NvdW50cykge1xuICAgICAgICAgICAgaWYgKHJlcy5hY2NvdW50cy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmFjY291bnRzID0gcmVzLmFjY291bnRzW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMuYWNjb3VudHNbcHJvcGVydHldLnRyYW5zZmVyX2hpc3RvcnkpKTtcblxuICAgICAgICAgICAgICAkc2NvcGUudHJhbnNmZXJzID0gcmVzLmFjY291bnRzW3Byb3BlcnR5XS50cmFuc2Zlcl9oaXN0b3J5O1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS50cmFuc2ZlcnMpO1xuICAgICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn0pXG5cbmFwcC5jb250cm9sbGVyKCdFeGNoYW5nZUN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSkge1xuICAkc2NvcGUudXNlcm5hbWUgPSAkc3RhdGVQYXJhbXMudXNlcm5hbWU7XG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmFjdGl2ZSA9ICdidXknO1xuICAgICRzY29wZS5vcmRlcnMgPSBbXTtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9vcmRlcl9ib29rXCIsIFsxNV0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgJHNjb3BlLm9yZGVycyA9IHJlcztcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHNjb3BlLmNoYW5nZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgJHNjb3BlLmFjdGl2ZSA9IHR5cGU7XG4gICAgICBpZiAodHlwZSA9PSBcIm9wZW5cIil7XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9vcGVuX29yZGVyc1wiLCBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgJHNjb3BlLm9wZW5vcmRlcnMgPSByZXM7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSBcImhpc3RvcnlcIil7XG4gICAgICAgICRzY29wZS5oaXN0b3J5ID0gW107XG4gICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgIHdpbmRvdy5BcGkubWFya2V0X2hpc3RvcnlfYXBpKCkuZXhlYyhcImdldF9yZWNlbnRfdHJhZGVzXCIsIFsxNV0pLnRoZW4oZnVuY3Rpb24ocil7XG4gICAgICAgICAgICAkc2NvcGUucmVjZW50X3RyYWRlcyA9IHI7XG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5cbn0pO1xuYXBwLmNvbnRyb2xsZXIoJ01hcmtldEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljUG9wb3ZlciwgJGlvbmljUG9wdXAsICRmaWx0ZXIsICR0cmFuc2xhdGUsICRpb25pY1BsYXRmb3JtLCAkd2luZG93KSB7XG5cbiAgJHNjb3BlLnJlcXVlc3RBcHAgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobmFtZSA9PSAnTmV3Jykge1xuICAgICAgICB3aW5kb3cub3BlbihcIm1haWx0bzppbmZvQGVzdGVlbS53cz9zdWJqZWN0PVN1Z2dlc3RpbmclMjBOZXclMjBBcHAlMjBmb3IlMjBNYXJrZXQlMjBQbGFjZSZib2R5PUhlbGxvISUwRCUwQSUwRCUwQUFwcE5hbWU6JTBEJTBBQXBwQXV0aG9yOiUwRCUwQUFwcExpbms6JTBEJTBBJTBEJTBBXCIsIFwiX3N5c3RlbVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpIHx8IGlvbmljLlBsYXRmb3JtLmlzSVBhZCgpKSB7XG4gICAgICAgIGlmIChuYW1lID09ICdTdGVlbU1vbml0b3InKSB7XG4gICAgICAgICAgLy9jb3Jkb3ZhLnBsdWdpbnMubWFya2V0Lm9wZW4oJ2lkMTE1ODkxODY5MCcpO1xuICAgICAgICAgIHdpbmRvdy5vcGVuKFwiaXRtcy1hcHBzOi8vaXR1bmVzLmFwcGxlLmNvbS9hcHAvaWQxMTU4OTE4NjkwXCIsIFwiX3N5c3RlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1GZXN0Jykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdpZDExNzEzNzE3MDgnKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihcIml0bXMtYXBwczovL2l0dW5lcy5hcHBsZS5jb20vYXBwL2lkMTE3MTM3MTcwOFwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuYW1lID09ICdTdGVlbU1vbml0b3InKSB7XG4gICAgICAgICAgLy9jb3Jkb3ZhLnBsdWdpbnMubWFya2V0Lm9wZW4oJ2NvbS5uZXRzb2x1dGlvbnMuZXN0ZWVtd2l0bmVzcycpO1xuICAgICAgICAgIHdpbmRvdy5vcGVuKFwibWFya2V0Oi8vZGV0YWlscz9pZD1jb20ubmV0c29sdXRpb25zLmVzdGVlbXdpdG5lc3NcIiwgXCJfc3lzdGVtXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09ICdTdGVlbUZlc3QnKSB7XG4gICAgICAgICAgLy9jb3Jkb3ZhLnBsdWdpbnMubWFya2V0Lm9wZW4oJ2NvbS5uZXRzb2x1dGlvbnMuc3RlZW1mZXN0Jyk7XG4gICAgICAgICAgd2luZG93Lm9wZW4oXCJtYXJrZXQ6Ly9kZXRhaWxzP2lkPWNvbS5uZXRzb2x1dGlvbnMuc3RlZW1mZXN0XCIsIFwiX3N5c3RlbVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn0pO1xuXG5hcHAuY29udHJvbGxlcignU2V0dGluZ3NDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRpb25pY0hpc3RvcnksICRzdGF0ZSwgJGlvbmljUG9wb3ZlciwgJGlvbmljUG9wdXAsIEFQSXMsICRmaWx0ZXIsICR0cmFuc2xhdGUsICR3aW5kb3csICRpb25pY1NpZGVNZW51RGVsZWdhdGUpIHtcblxuICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXIuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICAgfSk7XG4gICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSAnc3RlZW0nKXtcbiAgICAkc2NvcGUub3B0aW9ucyA9IFsnd3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tJywgJ3dzczovL25vZGUuc3RlZW0ud3MnXTsgXG4gICB9IGVsc2Uge1xuICAgICRzY29wZS5vcHRpb25zID0gWyd3c3M6Ly93cy5nb2xvcy5pbycsICd3c3M6Ly9ub2RlLmdvbG9zLndzJ107XG4gICB9XG4gICBcblxuICAgJHNjb3BlLm9wZW5Ub29sdGlwID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgICB2YXIgdGV4dGggPSBkO1xuICAgICAgJHNjb3BlLnRvb2x0aXBUZXh0ID0gdGV4dGg7XG4gICAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICB9O1xuXG4gIGZ1bmN0aW9uIGdldERhdGUoeHgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdiA9ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llc1tpXTtcbiAgICAgIGlmICh2LmlkID09IHh4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaE9iaihuYW1lS2V5LCBteUFycmF5KSB7XG4gICAgZm9yICh2YXIgaT0wOyBpIDwgbXlBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobXlBcnJheVtpXS5pZCA9PT0gbmFtZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG15QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAkc2NvcGUuY2hhbmdlQ3VycmVuY3kgPSBmdW5jdGlvbih4eCwgaWdub3JlKSB7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6IHh4LCBlbmZvcmNlOiBpZ25vcmV9KTtcbiAgfVxuICAkc2NvcGUuY2hhbmdlQ2hhaW4gPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUucmVzdGFydCA9IHRydWU7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwiU3RlZW0gUG93ZXJcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXIgPSBcIlN0ZWVtIERvbGxhclwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJTQkRcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCA9IFwiU1RFRU1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0c3RlZW0gPSBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiO1xuICAgICAgJHNjb3BlLnNvY2tldCA9IFwid3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCLQk9Ce0JvQntChXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXN1bml0ID0gXCLQk9C+0LvQvtGBXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyID0gXCLQl9Ce0JvQntCi0J7QmVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJHQkdcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiR09MT1NQXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQgPSBcIkdPTE9TXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldGdvbG9zID0gXCJ3c3M6Ly93cy5nb2xvcy5pby9cIjtcbiAgICAgIC8vJHNjb3BlLnNvY2tldCA9IFwid3NzOi8vZ29sb3Muc3RlZW0ud3NcIjtcbiAgICAgICRzY29wZS5zb2NrZXQgPSBcIndzczovL3dzLmdvbG9zLmlvL1wiO1xuICAgIH1cbiAgICB3aW5kb3cuZWpzLkNoYWluQ29uZmlnLnNldENoYWluSWQobG9jYWxTdG9yYWdlWyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJJZFwiXSk7XG5cbiAgICAkc2NvcGUuY2hhbmdlQ3VycmVuY3koJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSwgdHJ1ZSk7XG4gIH1cbiAgJHNjb3BlLnJlc3RhcnQgPSBmYWxzZTtcbiAgJHNjb3BlLmNsb3NlVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwLmhpZGUoKTtcbiAgfTtcblxuICAvL0NsZWFudXAgdGhlIHBvcG92ZXIgd2hlbiB3ZSdyZSBkb25lIHdpdGggaXQhXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXAucmVtb3ZlKCk7XG4gIH0pO1xuXG4gICRzY29wZS5jaGFuZ2VMYW5ndWFnZSA9IGZ1bmN0aW9uKGxvY2FsZSl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsb2NhbGUgPT0gJ2FyLVNBJyB8fCBsb2NhbGUgPT0gJ2hlLUlMJyB8fCBsb2NhbGUgPT0gJ2ZhLUlSJykge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRpciA9ICdydGwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kaXIgPSAnbHRyJztcbiAgICAgIH1cbiAgICAgICR0cmFuc2xhdGUudXNlKGxvY2FsZSk7XG4gICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSwgMSk7XG4gIH1cbiAgJHNjb3BlLmRyYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gdioxMDA7XG4gIH1cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dID0gbG9jYWxTdG9yYWdlLnNvY2tldFVybDtcbiAgICAkc2NvcGUuZGF0YSA9IHt9O1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0KXtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCA9IDEwMDAwO1xuICAgICAgJHNjb3BlLnZ2YWx1ZSA9IDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnZ2YWx1ZSA9ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDA7XG4gICAgfVxuICAgIGlmKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgIFxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcbiAgICAgICRzY29wZS5kYXRhID0ge3BpbjogdHJ1ZX07XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5kYXRhID0ge3BpbjogZmFsc2V9O1xuICAgIH1cblxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkge1xuICAgICAgQVBJcy5nZXRTdWJzY3JpcHRpb25zKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzLmRhdGEpKTtcbiAgICAgICAgdmFyIGQgPSByZXMuZGF0YTtcbiAgICAgICAgLy9hbmd1bGFyLmZvckVhY2goZCwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgdiA9IGRbaV07XG4gICAgICAgICAgaWYgKHYudXNlcm5hbWUgPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICBhbmd1bGFyLm1lcmdlKCRzY29wZS5kYXRhLCB7dm90ZTogdi5zdWJzY3JpcHRpb24udm90ZSwgZm9sbG93OiB2LnN1YnNjcmlwdGlvbi5mb2xsb3csIGNvbW1lbnQ6IHYuc3Vic2NyaXB0aW9uLmNvbW1lbnQsIG1lbnRpb246IHYuc3Vic2NyaXB0aW9uLm1lbnRpb24sIHJlc3RlZW06IHYuc3Vic2NyaXB0aW9uLnJlc3RlZW19KTsgICAgXG4gICAgICAgICAgfSAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH0pO1xuXG4gICRzY29wZS5ub3RpZmljYXRpb25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnN1YnNjcmlwdGlvbiA9IHtcbiAgICAgIHZvdGU6ICRzY29wZS5kYXRhLnZvdGUsXG4gICAgICBjb21tZW50OiAkc2NvcGUuZGF0YS5jb21tZW50LFxuICAgICAgZm9sbG93OiAkc2NvcGUuZGF0YS5mb2xsb3csXG4gICAgICBtZW50aW9uOiAkc2NvcGUuZGF0YS5tZW50aW9uLFxuICAgICAgcmVzdGVlbTogJHNjb3BlLmRhdGEucmVzdGVlbSxcbiAgICAgIGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSxcbiAgICAgIHRpbWVzdGFtcDogJGZpbHRlcignZGF0ZScpKG5ldyBEYXRlKCksICdtZWRpdW0nKSxcbiAgICAgIGFwcHZlcnNpb246ICcxLjMuOSdcbiAgICB9XG4gICAgQVBJcy51cGRhdGVTdWJzY3JpcHRpb24oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnN1YnNjcmlwdGlvbikudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgY29uc29sZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgfSk7XG5cbiAgfVxuXG4gICRzY29wZS5waW5DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhcInBpbkNoYW5nZVwiKTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46Y2hlY2tcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpuZXdcIik7XG4gICAgfVxuICB9XG5cbiAgJHJvb3RTY29wZS4kb24oXCJwaW46Y29ycmVjdFwiLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUubG9nKFwicGluOmNvcnJlY3QgXCIgKyAkc2NvcGUuZGF0YS5waW4pO1xuICAgIGlmICghJHNjb3BlLmRhdGEucGluKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgJHNjb3BlLmRhdGEucGluID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmRhdGEucGluID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oXCJwaW46ZmFpbGVkXCIsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS5sb2coXCJwaW46ZmFpbGVkXCIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAgICRzY29wZS5kYXRhLnBpbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuZGF0YS5waW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSwgMTApO1xuXG4gIH0pO1xuICAkc2NvcGUubG9nb3V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSBudWxsO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UubXlsb2dpbiA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm15bG9naW4gPSBudWxsO1xuICAgIC8vbWFrZSBzdXJlIHVzZXIgY3JlZGVudGlhbHMgY2xlYXJlZC5cbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkge1xuICAgICAgQVBJcy5kZWxldGVTdWJzY3JpcHRpb24oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gdW5kZWZpbmVkO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnID0gdW5kZWZpbmVkO1xuXG4gICAgJGlvbmljSGlzdG9yeS5jbGVhckNhY2hlKCk7XG4gICAgJGlvbmljSGlzdG9yeS5jbGVhckhpc3RvcnkoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaW9uaWMuUGxhdGZvcm0uZXhpdEFwcCgpOyAvLyBzdG9wcyB0aGUgYXBwXG4gICAgfSwgMTAwKTtcbiAgfTtcbiAgJHNjb3BlLnNvY2tldCA9ICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXTtcbiAgJHNjb3BlLnNvY2tldENoYW5nZSA9IGZ1bmN0aW9uKHh4KXtcbiAgICBjb25zb2xlLmxvZyh4eCk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dID0geHg7XG4gICAgbG9jYWxTdG9yYWdlLnNvY2tldFVybCA9IHh4O1xuICAgICRzY29wZS5yZXN0YXJ0ID0gdHJ1ZTtcbiAgfVxuICAkc2NvcGUuc2F2ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYgKCRzY29wZS5yZXN0YXJ0KSB7XG4gICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlQnKVxuICAgICAgfSk7XG4gICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl07XG4gICAgICAgICAgLy8kc2NvcGUubG9nb3V0cygpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aW5kb3cuQXBpLmNsb3NlKCk7XG4gICAgICAgICAgICB3aW5kb3cuQXBpID0gbnVsbDtcbiAgICAgICAgICAgIHdpbmRvdy5zdGVlbVJQQy5DbGllbnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHZhciBzb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl07XG4gICAgICAgICAgICB3aW5kb3cuQXBpID0gd2luZG93LnN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpzb2NrZXRVcmx9LCB0cnVlKTtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuY2hhaW4gIT0gJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vyc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodi5jaGFpbiA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKXtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCA1MDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRUSU5HU19VUERBVEVEJykpO1xuICAgICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpOyAgXG4gICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycse3JlbmV3OnRydWV9LHtyZWxvYWQ6IHRydWV9KTtcbiAgICB9XG4gIH07XG5cbn0pO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3Bvc3RzL2NvbnRyb2xsZXJzLmpzXCIsXCIvcG9zdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cblxudmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdzdGVlbScsIFtcblx0J2lvbmljJyxcblx0J25nU3RvcmFnZScsXG5cdCduZ0NvcmRvdmEnLFxuICAnaW9uLWZsb2F0aW5nLW1lbnUnLFxuICAncGFzY2FscHJlY2h0LnRyYW5zbGF0ZScsXG4gICdqYS5xcicsXG4gICdpb24tZGF0ZXRpbWUtcGlja2VyJ1xuXSk7XG5cbmlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNvY2tldFVybFwiKSA9PT0gbnVsbCkge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNvY2tldFVybFwiLCBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiKTtcbn0gZWxzZSBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzb2NrZXRVcmxcIikgPT0gXCJ3c3M6Ly9zdGVlbWl0LmNvbS93c3BhXCIpIHtcbiAgbG9jYWxTdG9yYWdlLnNvY2tldFVybD1cIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiO1xufVxuXG5sb2NhbFN0b3JhZ2UuZ29sb3NJZCA9IFwiNzgyYTMwMzliNDc4YzgzOWU0Y2IwYzk0MWZmNGVhZWI3ZGY0MGJkZDY4YmQ0NDFhZmQ0NDRiOWRhNzYzZGUxMlwiO1xubG9jYWxTdG9yYWdlLnN0ZWVtSWQgPSBcIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblxud2luZG93LnN0ZWVtUlBDID0gcmVxdWlyZShcInN0ZWVtLXJwY1wiKTtcbndpbmRvdy5BcGkgPSB3aW5kb3cuc3RlZW1SUEMuQ2xpZW50LmdldCh7dXJsOmxvY2FsU3RvcmFnZS5zb2NrZXRVcmx9LCB0cnVlKTtcbi8vd2luZG93LnN0ZWVtSlMgPSByZXF1aXJlKFwic3RlZW1qcy1saWJcIik7XG5cbndpbmRvdy5lanMgPSByZXF1aXJlKFwiZXN0ZWVtLWxpYlwiKTtcblxuLy93aW5kb3cuZ29sb3NKUyA9IHJlcXVpcmUoXCJnb2xvc2pzLWxpYlwiKTtcbndpbmRvdy5kaWZmX21hdGNoX3BhdGNoID0gcmVxdWlyZSgnZGlmZi1tYXRjaC1wYXRjaCcpO1xud2luZG93LmdldFN5bWJvbCA9IHJlcXVpcmUoJ2N1cnJlbmN5LXN5bWJvbC1tYXAnKTtcblxucmVxdWlyZSgnLi9jb25maWcnKShhcHApO1xucmVxdWlyZSgnLi9zZXJ2aWNlcycpKGFwcCk7XG5yZXF1aXJlKCcuL2NvbnRyb2xsZXJzJykoYXBwKTtcblxuXG5hcHAuY29uZmlnKGZ1bmN0aW9uKCRzdGF0ZVByb3ZpZGVyLCAkdXJsUm91dGVyUHJvdmlkZXIsICRpb25pY0NvbmZpZ1Byb3ZpZGVyLCAkc2NlRGVsZWdhdGVQcm92aWRlciwgJGxvZ1Byb3ZpZGVyLCAkY29tcGlsZVByb3ZpZGVyLCAkYW5pbWF0ZVByb3ZpZGVyLCAkdHJhbnNsYXRlUHJvdmlkZXIpIHtcbiAgJHN0YXRlUHJvdmlkZXJcblxuICAuc3RhdGUoJ2FwcCcsIHtcbiAgICB1cmw6ICcvYXBwJyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogXCI8aW9uLXNpZGUtbWVudXMgZW5hYmxlLW1lbnUtd2l0aC1iYWNrLXZpZXdzPVxcXCJ0cnVlXFxcIiB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCI+XFxuICA8aW9uLXNpZGUtbWVudS1jb250ZW50IGRyYWctY29udGVudD1cXFwiZmFsc2VcXFwiPlxcbiAgICA8aW9uLW5hdi1iYXIgY2xhc3M9XFxcImJhci1wb3NpdGl2ZVxcXCI+XFxuICAgICAgPGlvbi1uYXYtYmFjay1idXR0b24+XFxuICAgICAgPC9pb24tbmF2LWJhY2stYnV0dG9uPlxcbiAgICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT1cXFwibGVmdFxcXCI+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1uYXZpY29uXFxcIiBtZW51LXRvZ2dsZT1cXFwibGVmdFxcXCI+XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG4gICAgPC9pb24tbmF2LWJhcj5cXG4gICAgPGlvbi1uYXYtdmlldyBuYW1lPVxcXCJtZW51Q29udGVudFxcXCI+PC9pb24tbmF2LXZpZXc+XFxuICA8L2lvbi1zaWRlLW1lbnUtY29udGVudD5cXG4gIDxpb24tc2lkZS1tZW51IHNpZGU9XFxcImxlZnRcXFwiPlxcbiAgICA8IS0tPGlvbi1oZWFkZXItYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgPGgxIGNsYXNzPVxcXCJ0aXRsZSBjZW50ZXJcXFwiPmVTdGVlbTwvaDE+XFxuICAgIDwvaW9uLWhlYWRlci1iYXI+LS0+XFxuICAgIDxpb24tY29udGVudD5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8cD5cXG4gICAgICAgICAgICA8aW1nIG5nLXNyYz1cXFwiaW1nL2VzdGVlbS5wbmdcXFwiIHdpZHRoPVxcXCIxNTBcXFwiIC8+XFxuICAgICAgICAgIDwvcD5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiIG5nLXN0eWxlPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSA/IG1jc3MgOiBudWxsXFxcIj5cXG4gICAgICA8YnI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8YSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL3Byb2ZpbGUve3skcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfX1cXFwiIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIml0ZW0tbXlhdmF0YXJcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UgJiYgISRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2VcXFwiPjxpbWcgc3JjPVxcXCJpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgfHwgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2V9fVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS51c2VyX2ltYWdlIHx8ICRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2VcXFwiIC8+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPGRpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoNFxcXCI+QHt7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLnJlcHV0YXRpb258cmVwdXRhdGlvbjp0cnVlfG51bWJlcjoxfX08L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IG5nLWNsaWNrPVxcXCJzaG93TWVFeHRyYSgpXFxcIiBjbGFzcz1cXFwicGFkZGluZ1xcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtbGlzdFxcXCI+PC9pPiZuYnNwO3t7JHJvb3QuJHN0b3JhZ2UudXNlci5wb3N0X2NvdW50fX0mbmJzcDsmbmJzcDs8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZ3JhcGgtdXAtcmlnaHRcXFwiPjwvaT4mbmJzcDt7eyRyb290LiRzdG9yYWdlLnVzZXIudm90aW5nX3Bvd2VyLzEwMHxudW1iZXI6Mn19IDxpIGNsYXNzPVxcXCJpY29uIHB1bGwtcmlnaHRcXFwiIG5nLWNsYXNzPVxcXCJ7J2lvbi1hcnJvdy1kb3duLWInOiFzaG93RXh0cmEsICdpb24tYXJyb3ctdXAtYic6c2hvd0V4dHJhfVxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgbmctaWY9XFxcInNob3dFeHRyYVxcXCI+XFxuICAgICAgICA8aW9uLWxpc3Q+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJzXFxcIiBuZy1yZXBlYXQ9XFxcInVzZXIgaW4gJHJvb3QuJHN0b3JhZ2UudXNlcnNcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RBY2NvdW50KHVzZXIpXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOiAodXNlci51c2VybmFtZT09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSYmdXNlci5jaGFpbj09JHJvb3QuJHN0b3JhZ2UudXNlci5jaGFpbikgfVxcXCI+XFxuICAgICAgICAgICAgPGltZyBjbGFzcz1cXFwiaWNvbiBsb2dvc1xcXCIgbmctc3JjPVxcXCJ7eydpbWcvJyt1c2VyLmNoYWluKydfaWNvbi5wbmcnfX1cXFwiIC8+XFxuICAgICAgICAgICAge3t1c2VyLnVzZXJuYW1lfX1cXG4gICAgICAgICAgICA8IS0tPHNwYW4gY2xhc3M9XFxcImJhZGdlIGJhZGdlLWFzc2VydGl2ZVxcXCI+e3t1c2VyLmNoYWlufX08L3NwYW4+LS0+XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJvcGVuTG9naW4oKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLXBsdXMtcm91bmRcXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydBRERfQUNDT1VOVCd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgbmctY2xpY2s9XFxcIm9wZW5Qb3N0TW9kYWwoKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtY3JlYXRlXFxcIj48L2k+XFxuICAgICAgICAgICAge3snU1VCTUlUX0FfU1RPUlknfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL3Byb2ZpbGUve3skcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfX1cXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1wZXJzb25cXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydQUk9GSUxFJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9mb2xsb3dcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1wZXJzb24tc3RhbGtlclxcXCI+PC9pPlxcbiAgICAgICAgICAgIHt7J0ZPTExPVyd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgbmctY2xpY2s9XFxcImxvZ291dCgpXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbG9nLW91dFxcXCI+PC9pPlxcbiAgICAgICAgICAgIHt7J0xPR09VVCd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDwvaW9uLWxpc3Q+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGlvbi1saXN0PlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgbmctY2xpY2s9XFxcIm9wZW5Mb2dpbigpXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1sb2ctaW5cXFwiPjwvaT5cXG4gICAgICAgICAge3snTE9HSU4nfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvcG9zdHMvXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taG9tZVxcXCI+PC9pPlxcbiAgICAgICAgICB7eydIT01FJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL2Jvb2ttYXJrXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWJvb2ttYXJrXFxcIj48L2k+XFxuICAgICAgICAgIHt7J0JPT0tNQVJLUyd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9kcmFmdHNcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tY29tcG9zZVxcXCI+PC9pPlxcbiAgICAgICAgICB7eydEUkFGVFMnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPCEtLTxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL25vdGlmaWNhdGlvbnNcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMgJiYgJHJvb3QuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucy5sZW5ndGg+MFxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1ib29rbWFya1xcXCI+PC9pPlxcbiAgICAgICAgICB7eydOT1RJRklDQVRJT05TJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT4tLT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL3NlbmRcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1zZW5kXFxcIj48L2k+XFxuICAgICAgICAgIHt7J1RSQU5TRkVSJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL2V4Y2hhbmdlL3t7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXN3YXBcXFwiPjwvaT5cXG4gICAgICAgICAge3snRVhDSEFOR0UnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvbWFya2V0XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tY3ViZVxcXCI+PC9pPlxcbiAgICAgICAgICB7eydNQVJLRVRQTEFDRSd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9zZXR0aW5nc1xcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtc2V0dGluZ3NcXFwiPjwvaT5cXG4gICAgICAgICAge3snU0VUVElOR1MnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvYWJvdXRcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1pbmZvcm1hdGlvblxcXCI+PC9pPlxcbiAgICAgICAgICB7eydBQk9VVCd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgPC9pb24tbGlzdD5cXG4gICAgPC9pb24tY29udGVudD5cXG4gICAgPCEtLSBhbGlnbiB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlIC0tPlxcbiAgICA8ZGl2IHN0eWxlPVxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogMHB4OyB3aWR0aDogMTAwJVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLmFwcHZlcnNpb25cXFwiPlxcbiAgICAgICAgPGRpdiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyOyBjb2xvcjojY2NjO1xcXCI+XFxuICAgICAgICAgIDxwPnt7JHJvb3QuJHN0b3JhZ2UuYXBwdmVyc2lvbn19PC9wPlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tc2lkZS1tZW51PlxcbjwvaW9uLXNpZGUtbWVudXM+XFxuXCIsXG4gICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9tZW51Lmh0bWwnLFxuICAgIGNvbnRyb2xsZXI6ICdBcHBDdHJsJ1xuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLnNldHRpbmdzJywge1xuICAgIHVybDogJy9zZXR0aW5ncycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9zZXR0aW5ncy5odG1sJ1xuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J1NFVFRJTkdTJ3x0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLWhlYWRlciBzZXR0aW5nc1xcXCI+XFxuICAgIDxici8+XFxuICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1kaXZpZGVyXFxcIj5cXG4gICAgICB7eydTRUNVUklUWSd8dHJhbnNsYXRlfX1cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiUElOX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snUElOX0NPREUnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEucGluXFxcIiBuZy1jaGFuZ2U9XFxcInBpbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tZGl2aWRlclxcXCI+XFxuICAgICAge3snTk9USUZJQ0FUSU9OUyd8dHJhbnNsYXRlfX1cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiVk9URV9URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiZuYnNwO3t7J1ZPVEUnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEudm90ZVxcXCIgbmctY2hhbmdlPVxcXCJub3RpZmljYXRpb25DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkNPTU1FTlRfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydDT01NRU5UJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLmNvbW1lbnRcXFwiIG5nLWNoYW5nZT1cXFwibm90aWZpY2F0aW9uQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCJ7e1xcXCJGT0xMT1dfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydGT0xMT1cnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEuZm9sbG93XFxcIiBuZy1jaGFuZ2U9XFxcIm5vdGlmaWNhdGlvbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiTUVOVElPTlNfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydNRU5USU9OUyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5tZW50aW9uXFxcIiBuZy1jaGFuZ2U9XFxcIm5vdGlmaWNhdGlvbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiUkVTVEVFTV9URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiZuYnNwO3t7J1JFU1RFRU0nfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEucmVzdGVlbVxcXCIgbmctY2hhbmdlPVxcXCJub3RpZmljYXRpb25DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWRpdmlkZXJcXFwiPlxcbiAgICAgIHt7J0NPTkZJR1VSQVRJT05TJ3x0cmFuc2xhdGV9fVxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiVk9USU5HX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snVk9USU5HJ3x0cmFuc2xhdGV9fSAoJSk8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3MgPSBcXFwiaXRlbSByYW5nZSByYW5nZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgICB7e3Z2YWx1ZX19IDxpbnB1dCB0eXBlPVxcXCJyYW5nZVxcXCIgbmFtZT1cXFwicmFuZ2UxXFxcIiBtaW49XFxcIjFcXFwiIG1heD1cXFwiMTAwXFxcIiBuZy1tb2RlbD1cXFwidnZhbHVlXFxcIiBuZy1jaGFuZ2U9XFxcImRyYWcodnZhbHVlKVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCJ7e1xcXCJMQU5HVUFHRVNfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydMQU5HVUFHRVMnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCIkcm9vdC4kc3RvcmFnZS5sYW5ndWFnZVxcXCIgbmctY2hhbmdlPSdjaGFuZ2VMYW5ndWFnZSgkcm9vdC4kc3RvcmFnZS5sYW5ndWFnZSknPlxcbiAgICAgICAgICA8b3B0aW9uIG5nLXJlcGVhdD1cXFwib3B0aW9uIGluICRyb290LiRzdG9yYWdlLmxhbmd1YWdlc1xcXCIgdmFsdWU9XFxcInt7b3B0aW9uLmlkfX1cXFwiPnt7b3B0aW9uLm5hbWV9fTwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY2FwaXRhbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5sYW5ndWFnZX19IDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9kaXY+PC9kaXY+LS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiQ1VSUkVOQ1lfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydDVVJSRU5DWSd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XFxcIiRyb290LiRzdG9yYWdlLmN1cnJlbmN5XFxcIiBuZy1jaGFuZ2U9J2NoYW5nZUN1cnJlbmN5KCRyb290LiRzdG9yYWdlLmN1cnJlbmN5KSc+XFxuICAgICAgICAgIDxvcHRpb24gbmctcmVwZWF0PVxcXCJvcHRpb24gaW4gJHJvb3QuJHN0b3JhZ2UuY3VycmVuY2llc1xcXCIgdmFsdWU9XFxcInt7b3B0aW9uLmlkfX1cXFwiPnt7b3B0aW9uLm5hbWV9fTwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY2FwaXRhbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5sYW5ndWFnZX19IDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9kaXY+PC9kaXY+LS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiQ0hBSU5fVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydDSEFJTid8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XFxcIiRyb290LiRzdG9yYWdlLmNoYWluXFxcIiBuZy1jaGFuZ2U9J2NoYW5nZUNoYWluKCRyb290LiRzdG9yYWdlLmNoYWluKSc+XFxuICAgICAgICAgIDxvcHRpb24gbmctcmVwZWF0PVxcXCJvcHRpb24gaW4gJHJvb3QuJHN0b3JhZ2UuY2hhaW5zXFxcIiB2YWx1ZT1cXFwie3tvcHRpb24uaWR9fVxcXCI+e3tvcHRpb24ubmFtZX19PC9vcHRpb24+XFxuICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgIDwhLS08ZGl2IGNsYXNzPVxcXCJjYXBpdGFsXFxcIj57eyRyb290LiRzdG9yYWdlLmxhbmd1YWdlfX0gPGRpdiBjbGFzcz1cXFwicHVsbC1yaWdodFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWNoZXZyb24tcmlnaHRcXFwiPjwvaT48L2Rpdj48L2Rpdj4tLT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCI8c3BhbiBjbGFzcz1cXFxcXFxcImJvbGRcXFxcXFxcIj57e1xcXCJTRVJWRVJfVEVYVFxcXCJ8dHJhbnNsYXRlfX06PC9zcGFuPjxicj48c3BhbiBjbGFzcz1cXFxcXFxcIndyYXBcXFxcXFxcIj5bc3RlZW1pdF0gd3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tPC9zcGFuPjxici8+PGJyLz48c3BhbiBjbGFzcz1cXFxcXFxcIndyYXBcXFxcXFxcIj5bc3RlZW0ud3NdIHdzczovL25vZGUuc3RlZW0ud3M8L3NwYW4+PGJyLz48YnIvPjxzcGFuIGNsYXNzPVxcXFxcXFwid3JhcFxcXFxcXFwiPltwaXN0b25dIHdzczovL3RoaXMucGlzdG9uLnJvY2tzPC9zcGFuPjxici8+PGJyLz48c3BhbiBjbGFzcz1cXFxcXFxcIndyYXBcXFxcXFxcIj5bZ29sb3NdIHdzczovL3dzLmdvbG9zLmlvPC9zcGFuPjxici8+PGJyLz48c3BhbiBjbGFzcz1cXFxcXFxcIndyYXBcXFxcXFxcIj5bZ29sb3Mud3NdIHdzczovL25vZGUuZ29sb3Mud3M8L3NwYW4+XFxuICAgICAgICBcXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydTRVJWRVInfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8IS0tPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJTZXJ2ZXJcXFwiIG5nLW1vZGVsPVxcXCJzb2NrZXRcXFwiIHN0eWxlPVxcXCJ3aWR0aDoxMDAlO1xcXCIgbmctY2hhbmdlPVxcXCJzb2NrZXRDaGFuZ2Uoc29ja2V0KVxcXCI+LS0+XFxuICAgICAgICA8c2VsZWN0LWlucHV0IG5nLW1vZGVsPVxcXCJzb2NrZXRcXFwiIHNlbGVjdC1vcHRpb25zPVxcXCJvcHRpb25zXFxcIiA+PC9zZWxlY3QtaW5wdXQ+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8IS0tPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlTGFuZ3VhZ2UoJ3J1JylcXFwiPkNoYW5nZSBSVTwvYnV0dG9uPi0tPlxcbiAgICA8YnIvPlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXIuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXc+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWJpbmQtaHRtbD1cXFwidG9vbHRpcFRleHRcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICBcXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0Y2VudGVyXFxcIj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwic2F2ZSgpXFxcIj57eydTQVZFX0NIQU5HRVMnfHRyYW5zbGF0ZX19PC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnU2V0dGluZ3NDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5hYm91dCcsIHtcbiAgICB1cmw6ICcvYWJvdXQnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydBQk9VVCcgfCB0cmFuc2xhdGV9fSAtIHZ7eyRyb290LiRzdG9yYWdlLmFwcHZlcnNpb259fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICA8Y2VudGVyPjxpbWcgc3JjPVxcXCJpbWcvYWJvdXQucG5nXFxcIj48L2NlbnRlcj5cXG4gICAgPHA+PGI+ZVN0ZWVtPC9iPiB7eydBQk9VVF8yJ3x0cmFuc2xhdGV9fSA8ZGl2IG5nLWJpbmQtaHRtbD1cXFwiJ0FCT1VUXzExJ3x0cmFuc2xhdGVcXFwiPjwvZGl2PlxcbiAgICA8L3A+XFxuICAgIDxwIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj57e1xcXCJGT1VOREVSXFxcInx0cmFuc2xhdGV9fSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZ29vZC1rYXJtYVxcXCI+Z29vZC1rYXJtYTwvYT48L3A+XFxuICAgIDxkaXYgY2xhc3M9XFxcInRjZW50ZXJcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj48c3BhbiBuZy1pZj1cXFwiISRyb290LmlzV2l0bmVzc1ZvdGVkKClcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCIkcm9vdC52b3RlV2l0bmVzcygpXFxcIj57eydBQk9VVF84J3x0cmFuc2xhdGV9fTwvYnV0dG9uPjwvc3Bhbj48L2Rpdj5cXG4gICAgPHA+XFxuICAgIDxiPjx1Pnt7J0FCT1VUXzknfHRyYW5zbGF0ZX19PC91PjwvYj5cXG4gICAgPGJyPjxhIGhyZWY9XFxcIm1haWx0bzppbmZvQGVzdGVlbS53cz9TdWJqZWN0PUZlZWRiYWNrXFxcIj5pbmZvQGVzdGVlbS53czwvYT5cXG4gICAgPGJyPjxhIGhyZWY9XFxcImh0dHA6Ly9lc3RlZW0ud3NcXFwiPmh0dHA6Ly9lc3RlZW0ud3M8L2E+XFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgICAgICA8Yj48dT57eydUUkFOU0xBVElPTlMnfHRyYW5zbGF0ZX19PC91PjwvYj48YnI+XFxuICAgICAgICDQoNGD0YHRgdC60LjQuSAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS90ZXN0elxcXCI+dGVzdHo8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvb24wdG9sZVxcXCI+b24wdG9sZTwvYT48YnI+XFxuICAgICAgICBEZXV0c2NoIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2RlejEzMzdcXFwiPmRlejEzMzc8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvaG9tb3NhcGllbnNcXFwiPmhvbW9zYXBpZW5zPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3V3ZWxhbmdcXFwiPnV3ZWxhbmc8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYWxleHBmZWlmZmVyXFxcIj5hbGV4cGZlaWZmZXI8L2E+PGJyPlxcbiAgICAgICAgRnJhbsOnYWlzIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3BpY2tvdW1cXFwiPnBpY2tvdW08L2E+PGJyPlxcbiAgICAgICAgRXNwYcOxb2wgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZHJlc2RlblxcXCI+ZHJlc2RlbjwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9wZ2FyY2dvXFxcIj5wZ2FyY2dvPC9hPjxicj5cXG4gICAgICAgIM6VzrvOu863zr3Ouc66zqwgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvbGlvbmRhbmlcXFwiPmxpb25kYW5pPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3N0ZWVteWNoaWNrZW4xXFxcIj5zdGVlbXljaGlja2VuMTwvYT48YnI+XFxuICAgICAgICDQkdGK0LvQs9Cw0YDRgdC60LggLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvcm9zc2VucGF2bG92XFxcIj5yb3NzZW5wYXZsb3Y8L2E+PGJyPlxcbiAgICAgICAgTmVkZXJsYW5kcyAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9tYXhzZVxcXCI+bWF4c2U8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZWRqZVxcXCI+ZWRqZTwvYT48YnI+XFxuICAgICAgICBNYWd5YXIgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdGlib25vdmFcXFwiPnRpYm9ub3ZhPC9hPjxicj5cXG4gICAgICAgIMSMZcWhdGluYSAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS92YWx0clxcXCI+dmFsdHI8L2E+PGJyPlxcbiAgICAgICAg16LXkdeo15nXquKAjiAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9ib3NyYWRcXFwiPmJvc3JhZDwvYT48YnI+XFxuICAgICAgICBQb2xza2kgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUva25pdHR5YnluYXR1cmVcXFwiPmtuaXR0eWJ5bmF0dXJlPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2d0Z1xcXCI+Z3RnPC9hPjxicj5cXG4gICAgICAgIFBvcnR1Z3XDqnMgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYWxhbXlyanVuaW9yXFxcIj5hbGFteXJqdW5pb3I8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvY2hhcmxpZTc3N3B0XFxcIj5jaGFybGllNzc3cHQ8L2E+PGJyPlxcbiAgICAgICAgUG9ydHVndcOqcyBCUiAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9jaGFybGllNzc3cHRcXFwiPmNoYXJsaWU3NzdwdDwvYT48YnI+XFxuICAgICAgICBCYWhhc2EgSW5kb25lc2lhIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2xldnljb3JlXFxcIj5sZXZ5Y29yZTwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9oYXBweXBob2VuaXhcXFwiPmhhcHB5cGhvZW5peDwvYT48YnI+XFxuICAgICAgICDnuYHpq5TkuK3mlocgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZGVhbmxpdVxcXCI+ZGVhbmxpdTwvYT48YnI+XFxuICAgICAgICDnroDkvZPkuK3mlocgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvaHVhbmdkYXNodWFuZ1xcXCI+aHVhbmdkYXNodWFuZzwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9vZmx5aGlnaFxcXCI+b2ZseWhpZ2g8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvbHVjaWRcXFwiPmx1Y2lkPC9hPjxicj5cXG4gICAgICAgIERvbGFuIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL21heHNlXFxcIj5tYXhzZTwvYT48YnI+XFxuICAgICAgICBTdmVuc2sgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYWNpZHlvXFxcIj5hY2lkeW88L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdGhlLWVnby15b3VcXFwiPnRoZS1lZ28taXMteW91PC9hPjxicj5cXG4gICAgICAgINCj0LrRgNCw0ZfQvdGB0YzQutCwIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2VyaWthZmx5bm5cXFwiPmVyaWthZmx5bm48L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYXJ0ZW0tc29rb2xvZmZcXFwiPmFydGVtLXNva29sb2ZmPC9hPjxicj5cXG4gICAgICAgIEJhaGFzYSBNZWxheXUgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUva2V2aW53b25nXFxcIj5rZXZpbndvbmc8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUva2lsbHVtaW5hdGljXFxcIj5raWxsdW1pbmF0aWM8L2E+PGJyPlxcbiAgICAgICAgSHJ2YXRza2kgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZmlicmE1OVxcXCI+ZmlicmE1OTwvYT48YnI+XFxuICAgICAgICBGxIFyc2kgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvbWV5c2FtXFxcIj5tZXlzYW08L2E+PGJyPlxcbiAgICAgICAgSXRhbGlhbm8gLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYmh1elxcXCI+Ymh1ejwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9kdXJhbnpvODlcXFwiPmR1cmFuem84OTwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9zaWx2aWFiZW5lZm9ydGlcXFwiPnNpbHZpYWJlbmVmb3J0aTwvYT48YnI+XFxuICAgICAgICBXaWthbmcgRmlsaXBpbm8gLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdGhlbWFudWFsYm90XFxcIj50aGVtYW51YWxib3Q8L2E+PGJyPlxcbiAgICAgICAg2LnZjtix2Y7YqNmQ2YrZkSAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9iYmtvb3BzdGFcXFwiPmJia29vcHN0YTwvYT48YnI+XFxuICAgICAgICBcXG4gICAgICAgIDwhLS1cXG4gICAgICAgIG1hbGF5LWtpbGx1bWluYXRpY1xcbiAgICAgICAgV2lrYW5nIEZpbGlwaW5vIC0gdGhlbWFudWFsYm90XFxuICAgICAgICAtLT5cXG4gICAgPC9wPlxcbiAgICA8cD5cXG4gICAgPGI+PHU+e3snQUJPVVRfMTAnfHRyYW5zbGF0ZX19PC91PjwvYj5cXG4gICAgPGJyPjxhIGhyZWY9XFxcImh0dHBzOi8vc3RlZW0uaW9cXFwiPmh0dHBzOi8vc3RlZW0uaW88L2E+XFxuICAgIDxicj48YSBocmVmPVxcXCJodHRwczovL2dvbG9zLmlvXFxcIj5odHRwczovL2dvbG9zLmlvPC9hPlxcbiAgICA8L3A+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cblx0LnN0YXRlKCdhcHAubWFya2V0Jywge1xuXHRcdHVybDogJy9tYXJrZXQnLFxuXHRcdHZpZXdzOiB7XG5cdFx0XHQnbWVudUNvbnRlbnQnOiB7XG5cdFx0XHRcdC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcblx0XHRcdFx0dGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydNQVJLRVRQTEFDRScgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICA8aDQ+e3snRVhURVJOQUxfQVBQUyd8dHJhbnNsYXRlfX08L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctY2xpY2s9XFxcInJlcXVlc3RBcHAoJ1N0ZWVtTW9uaXRvcicpXFxcIj5cXG4gICAgICAgIDxjZW50ZXI+XFxuICAgICAgICAgIDxpbWcgc3JjPVxcXCJpbWcvbG9nb19zdGVlbW1vbml0b3IucG5nXFxcIiBhbHQ9XFxcIlN0ZWVtIE1vbml0b3JcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMTAwJTtcXFwiPlxcbiAgICAgICAgICA8Yj5TdGVlbSBNb25pdG9yPC9iPlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiZ3JheVxcXCI+e3snQlknfHRyYW5zbGF0ZX19IDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9nb29kLWthcm1hXFxcIj5GZXJ1ejwvYT48L3A+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWNsaWNrPVxcXCJyZXF1ZXN0QXBwKCdTdGVlbUZlc3QnKVxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiaW1nL2xvZ29fc3RlZW1mZXN0LnBuZ1xcXCIgYWx0PVxcXCJTdGVlbSBGZXN0XFxcIiBzdHlsZT1cXFwid2lkdGg6IDEwMCU7XFxcIj5cXG4gICAgICAgICAgPGI+U3RlZW0gRmVzdDwvYj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImdyYXlcXFwiPnt7J0JZJ3x0cmFuc2xhdGV9fSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZ29vZC1rYXJtYVxcXCI+RmVydXo8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvcm9lbGFuZHBcXFwiPlJvZWxhbmQ8L2E+ICZhbXA7IDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9jYXNzXFxcIj5DYXNzPC9hPjwvcD5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj48YnIvPlxcbiAgICA8aDQ+e3snUExVR0lOUyd8dHJhbnNsYXRlfX08L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBpdGFsaWNcXFwiPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAge3snQ09NSU5HX1NPT04nfHRyYW5zbGF0ZX19Li4uXFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxici8+XFxuICAgIDxoND57eydTVUdHRVNUJ3x0cmFuc2xhdGV9fTwvaDQ+PGJyLz5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWNsaWNrPVxcXCJyZXF1ZXN0QXBwKCdOZXcnKVxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiaW1nL3BsdXMucG5nXFxcIiBhbHQ9XFxcIlN1Z2dlc3QgTmV3XFxcIiBzdHlsZT1cXFwid2lkdGg6IDEwMCU7XFxcIj5cXG4gICAgICAgICAgPGI+e3snTkVXJ3x0cmFuc2xhdGV9fTwvYj5cXG4gICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuXHRcdFx0XHRjb250cm9sbGVyOiAnTWFya2V0Q3RybCdcblx0XHRcdH1cblx0XHR9XG5cdH0pXG5cbiAgLnN0YXRlKCdhcHAuc2VuZCcsIHtcbiAgICB1cmw6ICcvc2VuZCcsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9zZXR0aW5ncy5odG1sJ1xuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J1RSQU5TRkVSJ3x0cmFuc2xhdGV9fVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJ0YWJzLXN0cmlwZWQgdGFicy10b3AgdGFicy1iYWNrZ3JvdW5kLXBvc2l0aXZlIHRhYnMtY29sb3ItbGlnaHRcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJzXFxcIj5cXG4gICAgICA8YSBjbGFzcz1cXFwidGFiLWl0ZW1cXFwiIGhyZWYgbmctY2xpY2s9XFxcImNoYW5nZVRyYW5zZmVyKCd0cmFuc2ZlcicpXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOiB0dHlwZT09J3RyYW5zZmVyJ31cXFwiPlxcbiAgICAgICAge3tcXFwiVFJBTlNGRVJcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgPC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJ0YWItaXRlbVxcXCIgaHJlZiBuZy1jbGljaz1cXFwiY2hhbmdlVHJhbnNmZXIoJ2VzY3JvdycpXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOiB0dHlwZT09J2VzY3Jvdyd9XFxcIj5cXG4gICAgICAgIHt7XFxcIkVTQ1JPV1xcXCJ8dHJhbnNsYXRlfX1cXG4gICAgICA8L2E+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLXRhYnMtdG9wXFxcIj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGlzdFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0IGl0ZW0taWNvbi1yaWdodFxcXCIgbmctaWY9XFxcIiFkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snVE8nfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnVzZXJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwie3snVE9fREVTQyd8dHJhbnNsYXRlfX1cXFwiIG5nLWNoYW5nZT1cXFwiY2hhbmdlVXNlcm5hbWUoKVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJvZmZcXFwiIHNwZWxsY2hlY2s9XFxcImZhbHNlXFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtY2FtZXJhLW91dGxpbmVcXFwiIG5nLWNsaWNrPVxcXCJxclNjYW4oKVxcXCIgbmctaWY9XFxcInR0eXBlPT0ndHJhbnNmZXInXFxcIj48L2k+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdycmJiFkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57e1xcXCJFU0NST1dfQUdFTlRcXFwifHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcmVhZG9ubHk9XFxcInJlYWRvbmx5XFxcIiBwbGFjZWhvbGRlcj1cXFwie3snVVNFUk5BTUUnfHRyYW5zbGF0ZX19XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5hZ2VudC5uYW1lXFxcIiBuZy1jbGljaz1cXFwib3BlblVNb2RhbChkYXRhLmFnZW50KVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJvZmZcXFwiIHNwZWxsY2hlY2s9XFxcImZhbHNlXFxcIi8+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXQgaXRlbS1pY29uLXJpZ2h0XFxcIiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnJiZkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snRVNDUk9XJ3x0cmFuc2xhdGV9fSB7eydJRCd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcImRhdGEuZXNjcm93X2lkXFxcIiBwbGFjZWhvbGRlcj1cXFwie3snU0VBUkNIJ3x0cmFuc2xhdGV9fVxcXCIgbmctY2hhbmdlPVxcXCJzZWFyY2hFc2Nyb3dJRChkYXRhLmVzY3Jvd19pZClcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXQgaXRlbS1zZWxlY3RcXFwiIG5nLWlmPVxcXCJkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snT1BUSU9OUyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCJkYXRhLmV0eXBlXFxcIiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnXFxcIiBuZy1vcHRpb25zPVxcXCJpdGVtLnR5cGUgYXMgaXRlbS5uYW1lIGZvciBpdGVtIGluIGRhdGEuZXR5cGVzIHRyYWNrIGJ5IGl0ZW0uaWRcXFwiIG5nLWNoYW5nZT1cXFwiYWN0aW9uRUNoYW5nZSgpXFxcIj48L3NlbGVjdD5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0IGl0ZW0tc2VsZWN0XFxcIiBuZy1pZj1cXFwiZGF0YS5hZHZhbmNlZCYmZGF0YS5ldHlwZT09J3JlbGVhc2UnXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snUkVDRUlWRVInfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiZXNjcm93LnJlY2VpdmVyXFxcIj5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwie3tlc2Nyb3cudG99fVxcXCIgbmctaWY9XFxcImVzY3Jvdy50byE9JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tlc2Nyb3cudG99fTwvb3B0aW9uPlxcbiAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2VzY3Jvdy5mcm9tfX1cXFwiIG5nLWlmPVxcXCJlc2Nyb3cuZnJvbSE9JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tlc2Nyb3cuZnJvbX19PC9vcHRpb24+XFxuICAgICAgICA8L3NlbGVjdD5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0IGl0ZW0tc2VsZWN0XFxcIiBuZy1pZj1cXFwiIWRhdGEuYWR2YW5jZWRcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydBU1NFVCd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCJkYXRhLnR5cGVcXFwiIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdydcXFwiIG5nLW9wdGlvbnM9XFxcIml0ZW0udHlwZSBhcyBpdGVtLm5hbWUgZm9yIGl0ZW0gaW4gZGF0YS50eXBlcyB8IGZpbHRlcjpzaG93TGlxdWlkIHRyYWNrIGJ5IGl0ZW0uaWRcXFwiPjwvc2VsZWN0PlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiZGF0YS50eXBlXFxcIiBuZy1pZj1cXFwidHR5cGU9PSd0cmFuc2ZlcidcXFwiIG5nLW9wdGlvbnM9XFxcIml0ZW0udHlwZSBhcyBpdGVtLm5hbWUgZm9yIGl0ZW0gaW4gZGF0YS50eXBlcyB0cmFjayBieSBpdGVtLmlkXFxcIj48L3NlbGVjdD5cXG4gICAgICA8L2xhYmVsPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIiBuZy1pZj1cXFwiIWRhdGEuYWR2YW5jZWRcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydBTU9VTlQnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcIm51bWJlclxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J0FNT1VOVCd8dHJhbnNsYXRlfX1cXFwiIHN0ZXA9XFxcIjAuMDAxXFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5hbW91bnRcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCIgbmctaWY9XFxcImRhdGEudHlwZSAhPSAnc3AnJiZkYXRhLnR5cGUgIT0gJ2dvbG9zcCcgJiYgIWRhdGEuYWR2YW5jZWRcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydNRU1PJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDx0ZXh0YXJlYSBuZy1tb2RlbD1cXFwiZGF0YS5tZW1vXFxcIiByb3dzPVxcXCIzXFxcIiBwbGFjZWhvbGRlcj1cXFwie3snUFVCTElDX01FTU8nfHRyYW5zbGF0ZX19XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBpb24tZGF0ZXRpbWUtcGlja2VyIG5nLW1vZGVsPVxcXCJkYXRhLnJhdGlmaWNhdGlvblxcXCIgb25seS12YWxpZD1cXFwieydhZnRlcic6ICd0b2RheScsICdpbmNsdXNpdmUnOiB0cnVlfVxcXCIgbmctaWY9XFxcInR0eXBlPT0nZXNjcm93JyYmIWRhdGEuYWR2YW5jZWRcXFwiPnt7J1JBVElGSUNBVElPTl9ERUFETElORSd8dHJhbnNsYXRlfX06IHt7ZGF0YS5yYXRpZmljYXRpb258IGRhdGU6IFxcXCJ5eXl5LU1NLWRkIEg6bW06c3NcXFwifX08L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBpb24tZGF0ZXRpbWUtcGlja2VyIG5nLW1vZGVsPVxcXCJkYXRhLmV4cGlyYXRpb25cXFwiIG9ubHktdmFsaWQ9XFxcInsnYWZ0ZXInOiAndG9kYXknLCAnaW5jbHVzaXZlJzogZmFsc2V9XFxcIiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnJiYhZGF0YS5hZHZhbmNlZFxcXCI+e3snRVNDUk9XX0VYUElSQVRJT04nfHRyYW5zbGF0ZX19OiB7e2RhdGEuZXhwaXJhdGlvbnwgZGF0ZTogXFxcInl5eXktTU0tZGQgSDptbTpzc1xcXCJ9fTwvZGl2PlxcbiAgICAgIDxpb24tdG9nZ2xlIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdydcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLmFkdmFuY2VkXFxcIiB0b2dnbGUtY2xhc3M9XFxcInRvZ2dsZS1jYWxtXFxcIiBuZy1jaGFuZ2U9XFxcImFkdmFuY2VkRUNoYW5nZSgpXFxcIj57eydBRFZBTkNFRCd8dHJhbnNsYXRlfX08L2lvbi10b2dnbGU+XFxuICAgICAgPHAgY2xhc3M9XFxcIml0ZW1cXFwiIG5nLWlmPVxcXCJiYWxhbmNlICYmICFkYXRhLmFkdmFuY2VkXFxcIj57eydBVkFJTEFCTEUnfHRyYW5zbGF0ZX19OiB7e2JhbGFuY2UuYmFsYW5jZX19LCB7e2JhbGFuY2Uuc2JkX2JhbGFuY2V9fSA8aSBjbGFzcz1cXFwiaWNvbiBpb24tcmVmcmVzaCBwdWxsLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwicmVmcmVzaCgpXFxcIj48L2k+PC9wPlxcbiAgICAgIDxicj5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdycgJiYgZGF0YS5hZHZhbmNlZCAmJiBlc2Nyb3cuZXNjcm93X2lkXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e1xcXCJGUk9NXFxcInx0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LmZyb219fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7XFxcIlRPXFxcInx0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LnRvfX08L2Rpdj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e1xcXCJFU0NST1dfQUdFTlRcXFwifHRyYW5zbGF0ZX19OjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tlc2Nyb3cuYWdlbnR9fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7XFxcIkVTQ1JPV19GRUVcXFwifHRyYW5zbGF0ZX19OjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tlc2Nyb3cuZmVlfX0ge3tlc2Nyb3cuZmVlX3N5bWJvbH19PC9kaXY+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snUkFUSUZJQ0FUSU9OX0RFQURMSU5FJ3x0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LnJhdGlmaWNhdGlvbl9kZWFkbGluZXxkYXRlOidzaG9ydCd9fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J0VTQ1JPV19FWFBJUkFUSU9OJ3x0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LmVzY3Jvd19leHBpcmF0aW9ufGRhdGU6J3Nob3J0J319PC9kaXY+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tcXFwiRVNDUk9XX1RFUk1TXFxcInx0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93Lmpzb25fbWV0YS50ZXJtc319PC9kaXY+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snTUVNTyd8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy5qc29uX21ldGEubWVtb319PC9kaXY+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGNlbnRlciBuZy1pZj1cXFwidHR5cGU9PSd0cmFuc2ZlcidcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJ0cmFuc2ZlcigndHJhbnNmZXInKVxcXCI+XFxuICAgICAgICB7eydTRU5EJ3x0cmFuc2xhdGV9fVxcbiAgICAgIDwvYnV0dG9uPjwvY2VudGVyPlxcbiAgICAgIDxjZW50ZXIgbmctaWY9XFxcInR0eXBlPT0nZXNjcm93JyYmIWRhdGEuYWR2YW5jZWRcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJ0cmFuc2ZlcignZXNjcm93JylcXFwiPlxcbiAgICAgICAge3snU0VORCd8dHJhbnNsYXRlfX1cXG4gICAgICA8L2J1dHRvbj48L2NlbnRlcj5cXG4gICAgICA8Y2VudGVyIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdycmJmRhdGEuYWR2YW5jZWRcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJlc2Nyb3dBY3Rpb24oKVxcXCI+XFxuICAgICAgICB7eydTVUJNSVQnfHRyYW5zbGF0ZX19XFxuICAgICAgPC9idXR0b24+PC9jZW50ZXI+XFxuICAgICAgPGJyPlxcbiAgICAgIDxjZW50ZXIgbmctaWY9XFxcInR0eXBlPT0ndHJhbnNmZXInXFxcIj48cXIgdGV4dD1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+PC9xcj48L2NlbnRlcj5cXG4gICAgICA8Y2VudGVyIG5nLWlmPVxcXCJ0dHlwZT09J3RyYW5zZmVyJ1xcXCI+PGkgY2xhc3M9XFxcIml0YWxpY1xcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfX08L2k+PC9jZW50ZXI+XFxuICAgIDwvZGl2PlxcbiAgPC9pb24tY29udGVudD5cXG4gIDxzY3JpcHQgaWQ9XFxcIm15LW1vZGFsLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICA8aW9uLW1vZGFsLXZpZXc+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYmFyIGJhci1oZWFkZXIgYmFyLXBvc2l0aXZlIGl0ZW0taW5wdXQtaW5zZXRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtLWlucHV0LXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLXNlYXJjaCBwbGFjZWhvbGRlci1pY29uXFxcIj48L2k+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJzZWFyY2hcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydTRUFSQ0gnfHRyYW5zbGF0ZX19XFxcIiBuZy1jaGFuZ2U9XFxcImdldFVzZXJBZ2VudChkYXRhLnF1ZXJ5KVxcXCIgbmctbW9kZWw9XFxcImRhdGEucXVlcnlcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1jbGVhciBidXR0b24tb3V0bGluZVxcXCIgbmctY2xpY2s9XFxcImNsb3NlVU1vZGFsKClcXFwiPlxcbiAgICAgICAgICB7e1xcXCJDQU5DRUxcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibGlzdFxcXCIgbmctaWY9XFxcImRhdGEuc2VhcmNoUmVzdWx0Lmxlbmd0aD4wXFxcIj5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcIml0ZW1cXFwiIG5nLXJlcGVhdD1cXFwieCBpbiBkYXRhLnNlYXJjaFJlc3VsdFxcXCIgbmctY2xpY2s9XFxcInNlbGVjdEFnZW50KHgpXFxcIj5cXG4gICAgICAgICAgICA8aDI+e3snRVNDUk9XX0FHRU5UJ3x0cmFuc2xhdGV9fToge3t4Lm5hbWV9fTwvaDI+XFxuICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwieC5lc2Nyb3dcXFwiIGNsYXNzPVxcXCJ3cmFwXFxcIj57eydFU0NST1dfVEVSTVMnfHRyYW5zbGF0ZX19OiB7e3guZXNjcm93LnRlcm1zfX08L2Rpdj5cXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwid3JhcFxcXCI+e3snRVNDUk9XX0ZFRSd8dHJhbnNsYXRlfX06IHt7eC5lc2Nyb3cuZmVlc1skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0XX19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdH19IC8ge3t4LmVzY3Jvdy5mZWVzWyRyb290LiRzdG9yYWdlLnBsYXRmb3JtZHVuaXRdfX0ge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0fX1cXG4gICAgICAgICAgICA8L3A+XFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGNlbnRlciBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctaWY9XFxcImRhdGEuc2VhcmNoUmVzdWx0Lmxlbmd0aD09MFxcXCI+XFxuICAgICAgICAgIHt7XFxcIlVTRVJfTk9URk9VTkRcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2lvbi1jb250ZW50PlxcbiAgICA8L2lvbi1tb2RhbC12aWV3PlxcblxcbiAgPC9zY3JpcHQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1NlbmRDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5mb2xsb3cnLCB7XG4gICAgdXJsOiAnL2ZvbGxvdycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9mb2xsb3cuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCIgdmlldy10aXRsZT1cXFwie3snRk9MTE9XJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwicGFkZGluZyBoYXMtZm9vdGVyXFxcIiBkZWxlZ2F0ZS1oYW5kbGU9XFxcImxpc3RTY3JvbGxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGxpc3QtaW5zZXRcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dlcnMnXFxcIj5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tc2VhcmNoIHBsYWNlaG9sZGVyLWljb25cXFwiPjwvaT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic2VhcmNodS5mb2xsb3dlclxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1NFQVJDSF9GT0xMT1dFUlMnIHwgdHJhbnNsYXRlfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3QgbGlzdC1pbnNldFxcXCIgbmctaWY9XFxcImFjdGl2ZT09J2ZvbGxvd2luZydcXFwiPlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1zZWFyY2ggcGxhY2Vob2xkZXItaWNvblxcXCI+PC9pPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJzZWFyY2h1LmZvbGxvd2luZ1xcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1NFQVJDSF9GT0xMT1dJTkcnIHwgdHJhbnNsYXRlfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3RcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dlcnMnICYmIGZvbGxvd2Vycy5sZW5ndGg+MFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJ1dHRvbi1yaWdodFxcXCIgbmctcmVwZWF0PVxcXCJmIGluIGZvbGxvd2VycyB8IGZpbHRlcjpzZWFyY2h1ICB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gbmctY2xpY2s9XFxcInByb2ZpbGVWaWV3KGYuZm9sbG93ZXIpXFxcIj57e2YuZm9sbG93ZXJ9fTwvc3Bhbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgYnV0dG9uLW91dGxpbmVcXFwiIG5nLWlmPVxcXCIhaXNGb2xsb3dlZChmLmZvbGxvd2VyKVxcXCIgbmctY2xpY2s9XFxcImZvbGxvd1VzZXIoZi5mb2xsb3dlcilcXFwiPlxcbiAgICAgICAge3snRk9MTE9XX0JBQ0snIHwgdHJhbnNsYXRlfX1cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctaWY9XFxcImlzRm9sbG93ZWQoZi5mb2xsb3dlcilcXFwiIG5nLWNsaWNrPVxcXCJ1bmZvbGxvd1VzZXIoZi5mb2xsb3dlcilcXFwiPlxcbiAgICAgICAge3snRk9MTE9XRUQnIHwgdHJhbnNsYXRlfX1cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGlzdFxcXCIgbmctaWY9XFxcImFjdGl2ZT09J2ZvbGxvd2luZycgJiYgZm9sbG93aW5nLmxlbmd0aD4wXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYnV0dG9uLXJpZ2h0XFxcIiBuZy1yZXBlYXQ9XFxcImYgaW4gZm9sbG93aW5nIHwgZmlsdGVyOnNlYXJjaHUgIHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuICAgICAgICA8c3BhbiBuZy1jbGljaz1cXFwicHJvZmlsZVZpZXcoZi5mb2xsb3dpbmcpXFxcIj57e2YuZm9sbG93aW5nfX08L3NwYW4+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlIGJ1dHRvbi1vdXRsaW5lXFxcIiBuZy1pZj1cXFwiIWlzRm9sbG93aW5nKGYuZm9sbG93aW5nKVxcXCIgbmctY2xpY2s9XFxcInVuZm9sbG93VXNlcihmLmZvbGxvd2luZylcXFwiPlxcbiAgICAgICAge3snVU5GT0xMT1cnIHwgdHJhbnNsYXRlfX1cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctaWY9XFxcImlzRm9sbG93aW5nKGYuZm9sbG93aW5nKVxcXCI+XFxuICAgICAgICB7eydGT0xMT1dJTkcnIHwgdHJhbnNsYXRlfX1cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPCEtLTxpb24taW5maW5pdGUtc2Nyb2xsIG9uLWluZmluaXRlPVxcXCJsb2FkTW9yZSgpXFxcIiBuZy1pZj1cXFwibGFzdGRcXFwiIGRpc3RhbmNlPVxcXCIyJVxcXCI+PC9pb24taW5maW5pdGUtc2Nyb2xsPi0tPlxcbiAgPC9pb24tY29udGVudD5cXG4gIDxkaXYgY2xhc3M9XFxcImJhciBwcm9maWxlIGJhci1mb290ZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tYmFyXFxcIj5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1sYXJnZSBidXR0b24tcm95YWwgaWNvbiBpb24taW9zLXBlb3BsZVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdmb2xsb3dlcnMnfVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZSgnZm9sbG93ZXJzJylcXFwiPiB7eydGT0xMT1dFUlMnIHwgdHJhbnNsYXRlfX0gPHNwYW4gbmctaWY9XFxcImZvbGxvd2Vycy5sZW5ndGg+MFxcXCI+KHt7Zm9sbG93ZXJzLmxlbmd0aH19KTwvc3Bhbj48L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcm95YWwgaWNvbiBpb24tcGVyc29uLWFkZFxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdmb2xsb3dpbmcnfVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZSgnZm9sbG93aW5nJylcXFwiPiB7eydGT0xMT1dFRCcgfCB0cmFuc2xhdGV9fSA8c3BhbiBuZy1pZj1cXFwiZm9sbG93aW5nLmxlbmd0aD4wXFxcIj4oe3tmb2xsb3dpbmcubGVuZ3RofX0pPC9zcGFuPjwvYT5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnRm9sbG93Q3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cblxuICAuc3RhdGUoJ2FwcC5leGNoYW5nZScsIHtcbiAgICB1cmw6ICcvZXhjaGFuZ2UvOnVzZXJuYW1lJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgXHR0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J01BUktFVF9WSUVXJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwicGFkZGluZyBoYXMtZm9vdGVyIGV4Y2hhbmdlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nYnV5J1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGhlYWRlclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1BSSUNFJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J0FNT1VOVCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydUT1RBTCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctcmVwZWF0PVxcXCIoa2V5LCBmKSBpbiBvcmRlcnMuYmlkc1xcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5yZWFsX3ByaWNlfG51bWJlcjo0fX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLm9yZGVyX3ByaWNlLnF1b3RlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLm9yZGVyX3ByaWNlLmJhc2V9fTwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nc2VsbCdcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBoZWFkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydQUklDRScgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydBTU9VTlQnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snVE9UQUwnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIG5nLXJlcGVhdD1cXFwiKGtleSwgZikgaW4gb3JkZXJzLmFza3NcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YucmVhbF9wcmljZXxudW1iZXI6NH19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5vcmRlcl9wcmljZS5xdW90ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5vcmRlcl9wcmljZS5iYXNlfX08L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlxcXCIgbmctaWY9XFxcImFjdGl2ZT09J29wZW4nXFxcIj5cXG4gICAgICA8cCBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctaWY9XFxcIm9wZW5vcmRlcnMubGVuZ3RoPDFcXFwiPlxcbiAgICAgICAge3snTk9PUkRFUlMnIHwgdHJhbnNsYXRlfX0gQHt7dXNlcm5hbWV9fVxcbiAgICAgIDwvcD5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJvcGVub3JkZXJzLmxlbmd0aD4wXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBoZWFkZXJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1BSSUNFJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snQU1PVU5UJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snVE9UQUwnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiBuZy1yZXBlYXQ9XFxcIihrZXksIGYpIGluIG9wZW5vcmRlcnNcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5yZWFsX3ByaWNlfG51bWJlcjo0fX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwiZi5zZWxsZXI9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7Zi5zZWxsX3ByaWNlLnF1b3RlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwiZi5zZWxsZXI9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7Zi5zZWxsX3ByaWNlLmJhc2V9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWlmPVxcXCJmLmJ1eWVyPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj57e2YuYnV5X3ByaWNlLnF1b3RlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwiZi5idXllcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tmLmJ1eV9wcmljZS5iYXNlfX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0naGlzdG9yeSdcXFwiPlxcbiAgICAgIDwhLS08cCBjbGFzcz1cXFwicGFkZGluZ1xcXCI+Tm90aGluZyBoZXJlLCB5ZXQuLi48L3A+LS0+XFxuICAgICAgPGRpdiBuZy1pZj1cXFwicmVjZW50X3RyYWRlcy5sZW5ndGg+MFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgaGVhZGVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydEQVRFJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snUFJJQ0UnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eyRyb290LiRzdG9yYWdlLnBsYXRmb3Jtc3VuaXR9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXJ9fTwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIG5nLXJlcGVhdD1cXFwiKGtleSwgZikgaW4gcmVjZW50X3RyYWRlc1xcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLmRhdGV8dGltZWFnb319PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLmN1cnJlbnRfcGF5cy5zcGxpdChcXFwiIFxcXCIpWzBdL2Yub3Blbl9wYXlzLnNwbGl0KFxcXCIgXFxcIilbMF18bnVtYmVyOjZ9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5jdXJyZW50X3BheXMuc3BsaXQoXFxcIiBcXFwiKVswXXxudW1iZXI6M319PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLm9wZW5fcGF5cy5zcGxpdChcXFwiIFxcXCIpWzBdfG51bWJlcjozfX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlIGJhciBiYXItZm9vdGVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uLWJhclxcXCI+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tbGFyZ2UgYnV0dG9uLXJveWFsIGljb24gaW9uLWFycm93LWRvd24tYVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdidXknfVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZSgnYnV5JylcXFwiPiB7eydCVVknIHwgdHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcm95YWwgaWNvbiBpb24tYXJyb3ctdXAtYVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdzZWxsJ31cXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ3NlbGwnKVxcXCI+IHt7J1NFTEwnIHwgdHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcm95YWwgaWNvbiBpb24tZmxhZ1xcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdvcGVuJ31cXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ29wZW4nKVxcXCI+e3snT1BFTicgfCB0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1pb3MtY2xvY2tcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0naGlzdG9yeSd9XFxcIiAgbmctY2xpY2s9XFxcImNoYW5nZSgnaGlzdG9yeScpXFxcIj57eydISVNUT1JZJyB8IHRyYW5zbGF0ZX19PC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvZXhjaGFuZ2UuaHRtbCcsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdFeGNoYW5nZUN0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLnByb2ZpbGUnLCB7XG4gICAgdXJsOiAnL3Byb2ZpbGUvOnVzZXJuYW1lJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Byb2ZpbGUuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJcXFwiIGhpZGUtbmF2LWJhcj1cXFwidHJ1ZVxcXCIgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiPjwhLS1uZy1jbGFzcz1cXFwieydtcGInOiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlfVxcXCItLT5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWZvb3RlclxcXCIgb3ZlcmZsb3ctc2Nyb2xsPVxcXCJ0cnVlXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYmFyIGJhci1zdWJoZWFkZXIgbXlzdWJoZWFkZXIgYmFyLXBvc2l0aXZlXFxcIiBuZy1zdHlsZT1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPSB1c2VyLnVzZXJuYW1lP2NzczptY3NzXFxcIj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1pb3MtYXJyb3ctYmFjayBwcm9maWxlYnRuXFxcIiBvbi10YXA9XFxcImdvQmFjaygpXFxcIj48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLW91dGxpbmUgYnV0dG9uLWxpZ2h0IHByb2ZpbGVidG5fZm9sbG93XFxcIiBvbi10YXA9XFxcImZvbGxvd1VzZXIodXNlci51c2VybmFtZSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyICYmICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT0gdXNlci51c2VybmFtZSAmJiAhaXNBbUZvbGxvd2luZyh1c2VyLnVzZXJuYW1lKVxcXCI+PCEtLTxpIGNsYXNzPVxcXCJmYSBmYS11c2VyLXBsdXMgZmEtbGdcXFwiPjwvaT4tLT57eydGT0xMT1cnfHRyYW5zbGF0ZX19PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1jbGVhciBwcm9maWxlYnRuX2VkaXQgYnV0dG9uLWljb24gaW9uLWlvcy1jb21wb3NlLW91dGxpbmVcXFwiIG9uLXRhcD1cXFwic2hvd0VkaXRzKClcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyICYmICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgPT09IHVzZXIudXNlcm5hbWVcXFwiPjwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tY2xlYXIgcHJvZmlsZWJ0bl9mb2xsb3cgYnV0dG9uLWljb24gaW9uLWNhbWVyYVxcXCIgb24tdGFwPVxcXCJzaG93Q292ZXIoKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIgJiYgJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSA9PT0gdXNlci51c2VybmFtZVxcXCI+PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1vdXRsaW5lIGJ1dHRvbi1saWdodCBwcm9maWxlYnRuX2ZvbGxvd1xcXCIgb24tdGFwPVxcXCJ1bmZvbGxvd1VzZXIodXNlci51c2VybmFtZSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyICYmICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT0gdXNlci51c2VybmFtZSAmJiBpc0FtRm9sbG93aW5nKHVzZXIudXNlcm5hbWUpXFxcIj48IS0tYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyPGkgY2xhc3M9XFxcImZhIGZhLXVzZXItdGltZXMgZmEtbGdcXFwiPjwvaT4tLT57eydVTkZPTExPVyd8dHJhbnNsYXRlfX08L2J1dHRvbj4mbmJzcDtcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lID09IHVzZXIudXNlcm5hbWVcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiISgkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlfHwkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSlcXFwiPjxpbWcgc3JjPVxcXCJpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXCIgb24tdGFwPVxcXCJzaG93UHJvZmlsZSgpXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZX19XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UgfHwgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZVxcXCIgb24tdGFwPVxcXCJzaG93UHJvZmlsZSgpXFxcIiAvPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rwcm9maWxlaW5mb1xcXCI+XFxuICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcImNlbnRlclxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJsaWdodFxcXCI+QHt7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLnJlcHV0YXRpb258cmVwdXRhdGlvbn19XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPC9oND5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImFib3V0XFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmFib3V0fX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1saXN0XFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UudXNlci5wb3N0X2NvdW50fX0mbmJzcDtcXG4gICAgICAgICAgICAgICAgfCZuYnNwO1xcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZ3JhcGgtdXAtcmlnaHRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS51c2VyLnZvdGluZ19wb3dlci8xMDB8bnVtYmVyOjJ9fSZuYnNwO1xcbiAgICAgICAgICAgICAgICB8Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1wZW9wbGVcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2VyX2NvdW50fX0mbmJzcDtcXG4gICAgICAgICAgICAgICAgfCZuYnNwOzxpIGNsYXNzPVxcXCJpb24tcGVyc29uLWFkZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7e2ZvbGxvd2RldGFpbHMuZm9sbG93aW5nX2NvdW50fX1cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPHA+PHNwYW4gbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmICRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmxvY2F0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxvY2F0aW9uXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUubG9jYXRpb259fVxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj4mbmJzcDtcXG4gICAgICAgICAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxpbmtcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAgPGEgb24tdGFwPVxcXCJ3aW5kb3cub3Blbigne3skcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlfX0nLCAnX3N5c3RlbScpO1xcXCIgc3R5bGU9XFxcImNvbG9yOndoaXRlIWltcG9ydGFudDt0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXFwiPldlYlNpdGU8L2E+XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPHNwYW4gbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuY3JlYXRlZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1jYWxlbmRhclxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLnVzZXIuY3JlYXRlZHxkYXRlfX1cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09IHVzZXIudXNlcm5hbWVcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiISh1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlfHx1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSlcXFwiPjxpbWcgc3JjPVxcXCJpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXCIgLz48L3NwYW4+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7dXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCB1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZX19XFxcIiBuZy1pZj1cXFwidXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZSB8fCB1c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZVxcXCIgLz5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb290cHJvZmlsZWluZm9cXFwiPlxcbiAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJjZW50ZXJcXFwiPjxzcGFuIGNsYXNzPVxcXCJsaWdodFxcXCI+QHt7dXNlci51c2VybmFtZX19PC9zcGFuPiZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7dXNlci5yZXB1dGF0aW9ufHJlcHV0YXRpb259fTwvZGl2PjwvaDQ+XFxuICAgICAgICAgICAgICA8cD57e3VzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmFib3V0fX08L3A+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1saXN0XFxcIj48L2k+Jm5ic3A7e3t1c2VyLnBvc3RfY291bnR9fSZuYnNwO3wmbmJzcDs8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZ3JhcGgtdXAtcmlnaHRcXFwiPjwvaT4mbmJzcDt7e3VzZXIudm90aW5nX3Bvd2VyLzEwMHxudW1iZXI6Mn19Jm5ic3A7fCZuYnNwOzxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtcGVvcGxlXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICB7e2ZvbGxvd2RldGFpbHMuZm9sbG93ZXJfY291bnR9fSZuYnNwO1xcbiAgICAgICAgICAgICAgfCZuYnNwOzxpIGNsYXNzPVxcXCJpb24tcGVyc29uLWFkZFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2luZ19jb3VudH19PC9kaXY+XFxuICAgICAgICAgICAgICA8cD48c3BhbiBuZy1pZj1cXFwidXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgdXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUubG9jYXRpb25cXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbG9jYXRpb25cXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3t1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5sb2NhdGlvbn19XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPiZuYnNwO1xcbiAgICAgICAgICAgICAgPHNwYW4gbmctaWY9XFxcInVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmIHVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLndlYnNpdGVcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbGlua1xcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICA8YSBvbi10YXA9XFxcIndpbmRvdy5vcGVuKCd7e3VzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLndlYnNpdGV9fScsICdfc3lzdGVtJyk7XFxcIiBzdHlsZT1cXFwiY29sb3I6d2hpdGUhaW1wb3J0YW50O3RleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcXCI+V2ViU2l0ZTwvYT5cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgICA8c3BhbiBuZy1pZj1cXFwidXNlci5jcmVhdGVkXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWNhbGVuZGFyXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7dXNlci5jcmVhdGVkfGRhdGV9fVxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj48L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaGFzLW15c3ViaGVhZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBibHVlXFxcIiBuZy1pZj1cXFwiYWN0aXZlIT0nd2FsbGV0J3x8YWN0aXZlIT0ncGVybWlzc2lvbnMnXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWlmPVxcXCJub25leGlzdFxcXCI+e3snTk9USElOR19IRVJFJ3x0cmFuc2xhdGV9fTwvcD5cXG4gICAgICAgICAgPGlvbi1saXN0PlxcbiAgICAgICAgICAgIDwhLS08ZGl2IG5nLXJlcGVhdD1cXFwiKGtleSwgcGxheWxpc3QpIGluIHByb2ZpbGVcXFwiIGNsYXNzPVxcXCJpdGVtIHdyYXBcXFwiIG9uLXRhcD1cXFwib3BlbihwbGF5bGlzdClcXFwiPlxcbiAgICAgICAgICAgIDxoMyBjbGFzcz1cXFwiYm9sZFxcXCI+e3twbGF5bGlzdC5yb290X3RpdGxlfX08L2gzPlxcbiAgICAgICAgICAgIDxzcGFuIG5nLWJpbmQtaHRtbD1cXFwicGxheWxpc3QuYm9keS5zdWJzdHJpbmcoMCwxMDApfHBhcnNlVXJsXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+LS0+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgbmctcmVwZWF0PVxcXCJwbGF5bGlzdCBpbiBkYXRhLnByb2ZpbGUgfCBvcmRlckJ5OictY3JlYXRlZCcgfCBsaW1pdFRvOjI1IHRyYWNrIGJ5ICRpbmRleFxcXCIgbmctY2xhc3M9XFxcInsnaXRlbS10aHVtYm5haWwtbGVmdCc6IHBsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2V9XFxcIj5cXG4gICAgICAgICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7e3BsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2VbMF19fVxcXCIgb24tdGFwPVxcXCJvcGVuKHBsYXlsaXN0KVxcXCIgbmctaWY9XFxcInBsYXlsaXN0Lmpzb25fbWV0YWRhdGEuaW1hZ2VcXFwiIG9uZXJyb3I9XFxcInRoaXMuc3JjPSdpbWcvbm9pbWFnZS5wbmcnXFxcIi8+XFxuICAgICAgICAgICAgICAgIDxkaXYgb24tdGFwPVxcXCJvcGVuKHBsYXlsaXN0KVxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIndyYXBcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxoMj48aSBjbGFzcz1cXFwiZmEgZmEtbW9uZXkgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC5wcm9tb3RlZC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj48L2k+IDxpIGNsYXNzPVxcXCJmYSBmYS1maXJlIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwicGxheWxpc3QucGVyY2VudF9zdGVlbV9kb2xsYXJzID09PSAwXFxcIj48L2k+e3twbGF5bGlzdC5yb290X3RpdGxlfX08L2gyPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPHAgbmctYmluZC1odG1sPVxcXCJwbGF5bGlzdC5ib2R5fGxpbWl0VG86NTB8bGRvdHN8cGFyc2VVcmxcXFwiIG5nLWlmPVxcXCJhY3RpdmUhPSdibG9nJ1xcXCI+PC9wPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwb3N0ZGV0YWlsc1xcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiZuYnNwO3t7cGxheWxpc3QuY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWSd8dHJhbnNsYXRlfX0mbmJzcDs8aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1wZXJzb25cXFwiPjwvaT4mbmJzcDt7e3BsYXlsaXN0LmF1dGhvcn19Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3twbGF5bGlzdC5hdXRob3JfcmVwdXRhdGlvbnxyZXB1dGF0aW9ufG51bWJlcjowfX08L2Rpdj48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBncmF5IHByb2ZpbGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJwbGF5bGlzdC5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG9uLXRhcD1cXFwidXB2b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCIhcGxheWxpc3QudXB2b3RlZFxcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcigkZXZlbnQsIHBsYXlsaXN0KVxcXCI+PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KHBsYXlsaXN0KVxcXCIgbmctaWY9XFxcInBsYXlsaXN0LnVwdm90ZWRcXFwiPjwvaT4mbmJzcDsmbmJzcDs8c3BhbiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKHBsYXlsaXN0KVxcXCI+e3twbGF5bGlzdC5uZXRfdm90ZXN9fTwvc3Bhbj4mbmJzcDsmbmJzcDtcXG4gICAgICAgICAgICAgICAgICAgPCEtLTxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1kb3duIGZhLWxnXFxcIiBvbi10YXA9XFxcImRvd252b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCIhcGxheWxpc3QuZG93bnZvdGVkXFxcIj48L2k+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLWRvd24gZmEtbGcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC5kb3dudm90ZWRcXFwiPjwvaT4tLT48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LHBsYXlsaXN0KVxcXCI+Jm5ic3A7IDxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcInBsYXlsaXN0Lm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSA9PT0gJzAuMDAwJ1xcXCI+PGRlbD57e3BsYXlsaXN0IHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJwbGF5bGlzdC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPnt7cGxheWxpc3QgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj4mbmJzcDsgPGkgY2xhc3M9XFxcImljb24gaW9uLWNoYXRidWJibGVzXFxcIj48L2k+Jm5ic3A7e3twbGF5bGlzdC5jaGlsZHJlbn19PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwicGxheWxpc3QuYXV0aG9yIT09dXNlci51c2VybmFtZSAmJiBhY3RpdmUhPT0ncmVjZW50LXJlcGxpZXMnXFxcIj4mbmJzcDsgPGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9pb24tbGlzdD5cXG4gICAgICAgICAgPGlvbi1pbmZpbml0ZS1zY3JvbGwgb24taW5maW5pdGU9XFxcImxvYWRtb3JlKClcXFwiIG5nLWlmPVxcXCJtb3JlRGF0YUNhbkJlTG9hZGVkKClcXFwiIGRpc3RhbmNlPVxcXCIxNSVcXFwiPjwvaW9uLWluZmluaXRlLXNjcm9sbD5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctaWY9XFxcImFjdGl2ZT09J3RyYW5zZmVycydcXFwiPlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiYm9sZCB1cHBlcmNhc2VcXFwiPlxcbiAgICAgICAgICAgIHt7J0JBTEFOQ0VTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC02N1xcXCI+XFxuICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybW5hbWV9fSA8YnI+PHNwYW4gY2xhc3M9XFxcImdyYXkgd3JhcFxcXCI+e3snUFJPRklMRV8xJ3x0cmFuc2xhdGU6dHJhbnNsYXRpb25EYXRhIH19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7YWNjb3VudHMuYmFsYW5jZSB8IHN0IHwgbnVtYmVyfX0ge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0fX1cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC02N1xcXCI+XFxuICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfMid8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7YWNjb3VudHMudmVzdGluZ19zaGFyZXMgfCBzcCB8IG51bWJlcn19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXJ9fSA8YnI+PHNwYW4gY2xhc3M9XFxcImdyYXkgd3JhcFxcXCI+e3snUFJPRklMRV8zJ3x0cmFuc2xhdGU6dHJhbnNsYXRpb25EYXRhfX08L3NwYW4+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgICAgICAge3thY2NvdW50cy5zYmRfYmFsYW5jZSB8IHNiZCB8IG51bWJlcn19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7J0VTVElNQVRFRF9WQUxVRSd8dHJhbnNsYXRlfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfNCd8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fSB7e2FjY291bnRzLnZlc3Rpbmdfc2hhcmVzIHwgc2Q6YWNjb3VudHMuYmFsYW5jZTphY2NvdW50cy5zYmRfYmFsYW5jZSB8IG51bWJlcn19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiYm9sZFxcXCI+e3snVFJBTlNBQ1RJT05fSElTVE9SWSd8dHJhbnNsYXRlfX08L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxpc3QgbGlzdC1pbnNldFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgbmctcmVwZWF0PVxcXCJ0ciBpbiB0cmFuc2ZlcnMgfCBvcmRlckJ5OictWzBdJyB8IGxpbWl0VG86MTUgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgICAgICAgIDxzcGFuPnt7dHJbMV0udGltZXN0YW1wIHwgdGltZWFnb319IC0ge3t0clsxXS5vcFswXX19PC9zcGFuPlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdjb21tZW50X3Jld2FyZCdcXFwiPnt7dHJbMV0ub3BbMV0uc2JkX3BheW91dH19IHwge3t0clsxXS5vcFsxXS52ZXN0aW5nX3BheW91dH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2F1dGhvcl9yZXdhcmQnXFxcIiBjbGFzcz1cXFwid3JhcFxcXCI+e3t0clsxXS5vcFsxXS5zYmRfcGF5b3V0fX0gfCB7e3RyWzFdLm9wWzFdLnN0ZWVtX3BheW91dH19IHwge3t0clsxXS5vcFsxXS52ZXN0aW5nX3BheW91dH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2N1cmF0aW9uX3Jld2FyZCdcXFwiPnt7dHJbMV0ub3BbMV0ucmV3YXJkfX0gfCB7e3RyWzFdLm9wWzFdLnZlc3RpbmdfcGF5b3V0fX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0ndHJhbnNmZXInXFxcIj57e3RyWzFdLm9wWzFdLmFtb3VudH19IHwge3t0clsxXS5vcFsxXS5tZW1vfX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0naW50ZXJlc3QnXFxcIj57e3RyWzFdLm9wWzFdLmludGVyZXN0fX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0ndHJhbnNmZXJfdG9fdmVzdGluZydcXFwiPnt7dHJbMV0ub3BbMV0uYW1vdW50fX0gfCB7e3RyWzFdLm9wWzFdLm1lbW99fTwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd3aXRoZHJhd192ZXN0aW5nJ1xcXCI+e3t0clsxXS5vcFsxXS52ZXN0aW5nX3NoYXJlc319IHwge3t0clsxXS5vcFsxXS5tZW1vfX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxwIG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2NvbW1lbnRfcmV3YXJkJ1xcXCI+QHt7dHJbMV0ub3BbMV0uYXV0aG9yfX0ve3t0clsxXS5vcFsxXS5wZXJtbGlua319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nYXV0aG9yX3Jld2FyZCdcXFwiIGNsYXNzPVxcXCJ3cmFwXFxcIj5Ae3t0clsxXS5vcFsxXS5hdXRob3J9fS97e3RyWzFdLm9wWzFdLnBlcm1saW5rfX08L3A+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdjdXJhdGlvbl9yZXdhcmQnXFxcIiBjbGFzcz1cXFwid3JhcFxcXCI+QHt7dHJbMV0ub3BbMV0uY29tbWVudF9hdXRob3J9fS97e3RyWzFdLm9wWzFdLmNvbW1lbnRfcGVybWxpbmt9fTwvcD5cXG4gICAgICAgICAgICAgIDxwIG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3RyYW5zZmVyJ1xcXCI+e3t0clsxXS5vcFsxXS5mcm9tfX0ge3snVE8nfHRyYW5zbGF0ZX19ICB7e3RyWzFdLm9wWzFdLnRvfX08L3A+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd0cmFuc2Zlcl90b192ZXN0aW5nJ1xcXCI+IHt7dHJbMV0ub3BbMV0uZnJvbX19IHt7J1RPJ3x0cmFuc2xhdGV9fSAge3t0clsxXS5vcFsxXS50b319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nd2l0aGRyYXdfdmVzdGluZydcXFwiPnt7dHJbMV0ub3BbMV0uYWNjb3VudH19PC9wPlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm94IHBpbmtcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdwZXJtaXNzaW9ucydcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGNhcmRcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgPGgyPjxkaXYgY2xhc3M9XFxcImJvbGRcXFwiPnt7J1BPU1RJTkcnfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNbMF1bMF19fTwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYm9keVxcXCI+XFxuICAgICAgICAgICAgICA8Y2VudGVyPjxxcmNvZGUgY2xhc3M9XFxcImZ1bGwtaW1hZ2VcXFwiIHRleHQ9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1swXVswXX19XFxcIj48L3FyY29kZT48L2NlbnRlcj5cXG4gICAgICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgICAgICB7eydQUk9GSUxFXzUnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCI+XFxuICAgICAgICAgICAgICA8aDI+PGRpdiBjbGFzcz1cXFwiYm9sZFxcXCI+e3snT1dORVInfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIub3duZXIua2V5X2F1dGhzWzBdWzBdfX08L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgPGNlbnRlcj48cXJjb2RlIGNsYXNzPVxcXCJmdWxsLWltYWdlXFxcIiB0ZXh0PVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIub3duZXIua2V5X2F1dGhzWzBdWzBdfX1cXFwiPjwvcXJjb2RlPjwvY2VudGVyPlxcbiAgICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICAgIHt7J1BST0ZJTEVfNid8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIj5cXG4gICAgICAgICAgICAgIDxoMj48ZGl2IGNsYXNzPVxcXCJib2xkXFxcIj57eydBQ1RJVkUnfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1swXVswXX19PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgIDxjZW50ZXI+PHFyY29kZSBjbGFzcz1cXFwiZnVsbC1pbWFnZVxcXCIgdGV4dD1cXFwie3skcm9vdC4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNbMF1bMF19fVxcXCI+PC9xcmNvZGU+PC9jZW50ZXI+XFxuICAgICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgICAge3snUFJPRklMRV83J3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgPGgyPjxkaXYgY2xhc3M9XFxcImJvbGRcXFwiPnt7J01FTU8nfHRyYW5zbGF0ZX19PC9kaXY+PC9oMj5cXG4gICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJ3cmFwXFxcIj57eyRyb290LiRzdG9yYWdlLnVzZXIubWVtb19rZXl9fTwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYm9keVxcXCI+XFxuICAgICAgICAgICAgICA8Y2VudGVyPjxxcmNvZGUgY2xhc3M9XFxcImZ1bGwtaW1hZ2VcXFwiIHRleHQ9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5tZW1vX2tleX19XFxcIj48L3FyY29kZT48L2NlbnRlcj5cXG4gICAgICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgICAgICB7eydQUk9GSUxFXzgnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJQVHIuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkUG9zdFxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWJpbmQtaHRtbD1cXFwidG9vbHRpcFRleHRcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJTbGlkZXJycC5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRTbGlkZVxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3RTKClcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcyA9IFxcXCJpdGVtIHJhbmdlIHJhbmdlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICAgICAge3tyYW5nZVZhbHVlfX0gPGlucHV0IHR5cGU9XFxcInJhbmdlXFxcIiBuYW1lPVxcXCJyYW5nZTJcXFwiIG1pbj1cXFwiMVxcXCIgbWF4PVxcXCIxMDBcXFwiIG5nLW1vZGVsPVxcXCJyYW5nZVZhbHVlXFxcIiBuZy1jaGFuZ2U9XFxcImRyYWcocmFuZ2VWYWx1ZSlcXFwiPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMFxcXCI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGlvbi1jbG9zZS1yb3VuZFxcXCIgbmctY2xpY2s9XFxcImNsb3NlU2xpZGVyKClcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlIGJhciBiYXItZm9vdGVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uLWJhclxcXCI+XFxuICAgICAgPCEtLTxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWxhcmdlIGJ1dHRvbi1wb3NpdGl2ZSBpY29uIGlvbi1pb3MtaGVhcnRcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nZmVlZCd9XFxcIiBvbi10YXA9XFxcImNoYW5nZSgnZmVlZCcpXFxcIj4mbmJzcDtGZWVkczwvYT4tLT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1sYXJnZSBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24tY29tcG9zZVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdibG9nJ31cXFwiIG9uLXRhcD1cXFwiY2hhbmdlKCdibG9nJylcXFwiPiZuYnNwO3t7J0JMT0cnfHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlIGljb24gaW9uLWRvY3VtZW50LXRleHRcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ncG9zdHMnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ3Bvc3RzJylcXFwiPiZuYnNwO3t7J1BPU1RTJ3x0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBpY29uIGlvbi1jaGF0YnViYmxlc1xcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdyZWNlbnQtcmVwbGllcyd9XFxcIiBvbi10YXA9XFxcImNoYW5nZSgncmVjZW50LXJlcGxpZXMnKVxcXCI+Jm5ic3A7e3snUkVQTElFUyd8dHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24tY2FyZFxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSd0cmFuc2ZlcnMnfVxcXCIgIG9uLXRhcD1cXFwiY2hhbmdlKCd0cmFuc2ZlcnMnKVxcXCI+Jm5ic3A7e3snV0FMTEVUJ3x0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8IS0tPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcm95YWwgaWNvbiBpb24tbG9jay1jb21iaW5hdGlvblxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzphY3RpdmU9PSdwZXJtaXNzaW9ucyd9XFxcIiBvbi10YXA9XFxcImNoYW5nZSgncGVybWlzc2lvbnMnKVxcXCI+S2V5czwvYT4tLT5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxzY3JpcHQgaWQ9XFxcIm15LWVkaXQuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgIDxpb24tbW9kYWwtdmlldz5cXG4gICAgICA8aW9uLWhlYWRlci1iYXIgY2xhc3M9J2Jhci1wb3NpdGl2ZSc+XFxuICAgICAgICAgPGgxIGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3tcXFwiRURJVFxcXCJ8dHJhbnNsYXRlfX08L2gxPlxcbiAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tY2xlYXIgYnV0dG9uLW91dGxpbmVcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZUVkaXRzKClcXFwiPlxcbiAgICAgICAgICB7e1xcXCJDQU5DRUxcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2lvbi1oZWFkZXItYmFyPlxcbiAgICAgIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWRpdmlkZXJcXFwiPlxcbiAgICAgICAgICAgIHt7XFxcIlBST0ZJTEVcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydBQk9VVCd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgPHRleHRhcmVhIHBsYWNlaG9sZGVyPVxcXCJ7eydBQk9VVCd8dHJhbnNsYXRlfX1cXFwiIG5nLW1vZGVsPVxcXCJlZGl0LnByb2ZpbGUuYWJvdXRcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0xPQ0FUSU9OJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J0xPQ0FUSU9OJ3x0cmFuc2xhdGV9fVxcXCIgbmctbW9kZWw9XFxcImVkaXQucHJvZmlsZS5sb2NhdGlvblxcXCI+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0RJU1BMQVlfTkFNRSd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydESVNQTEFZX05BTUUnfHRyYW5zbGF0ZX19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5wcm9maWxlLm5hbWVcXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydXRUJTSVRFJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1dFQlNJVEUnfHRyYW5zbGF0ZX19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5wcm9maWxlLndlYnNpdGVcXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tZGl2aWRlclxcXCI+XFxuICAgICAgICAgICAge3tcXFwiRVNDUk9XXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snRVNDUk9XX1RFUk1TJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J0VTQ1JPV19URVJNUyd8dHJhbnNsYXRlfX1cXFwiIG5nLW1vZGVsPVxcXCJlZGl0LmVzY3Jvdy50ZXJtc1xcXCI+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0VTQ1JPV19GRUUnfHRyYW5zbGF0ZX19IDwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdH19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5lc2Nyb3cuZmVlc1skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0XVxcXCI+XFxuICAgICAgICAgIDwvbGFiZWw+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0VTQ1JPV19GRUUnfHRyYW5zbGF0ZX19IDwvc3Bhbj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdH19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5lc2Nyb3cuZmVlc1skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0XVxcXCI+XFxuICAgICAgICAgIDwvbGFiZWw+PGJyPlxcbiAgICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWNsaWNrPVxcXCJzYXZlRWRpdCgpXFxcIj5cXG4gICAgICAgICAgICB7eydTQVZFX0NIQU5HRVMnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDwvY2VudGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgIDwvaW9uLW1vZGFsLXZpZXc+XFxuXFxuICA8L3NjcmlwdD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiBcIlByb2ZpbGVDdHJsXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAucG9zdHMnLCB7XG4gICAgdXJsOiAnL3Bvc3RzLzp0YWdzLzpyZW5ldycsXG4gICAgcGFyYW1zOiB7cmVuZXc6IHRydWV9LFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcG9zdHMuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCI+XFxuXFx0PGlvbi1uYXYtYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiPlxcblxcdFxcdDxpb24tbmF2LWJhY2stYnV0dG9uPlxcbiAgXFx0XFx0PC9pb24tbmF2LWJhY2stYnV0dG9uPlxcblxcdCAgICA8aW9uLW5hdi1idXR0b25zIHNpZGU9XFxcImxlZnRcXFwiPlxcblxcdCAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXIgaW9uLW5hdmljb25cXFwiIG5nLWlmPVxcXCIhJHJvb3Qudm9pY2VPdmVyXFxcIiBtZW51LXRvZ2dsZT1cXFwibGVmdFxcXCI+PC9idXR0b24+XFxuXFx0ICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tbmF2aWNvblxcXCIgbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPnt7J01FTlUnfHRyYW5zbGF0ZX19PC9hPlxcblxcdCAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG5cXHQgICAgPGlvbi1uYXYtdGl0bGUgb24tdGFwPVxcXCJzaG93RmlsdGVyKClcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLXRpdGxlXFxcIj57eyRyb290LiRzdG9yYWdlLmZpbHRlck5hbWV9fSB7eyRyb290LiRzdG9yYWdlLnRhZ319ICZlbXNwOyA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctZG93bi1iXFxcIj48L2k+PC9kaXY+XFxuICAgICAgICA8L2lvbi1uYXYtdGl0bGU+XFxuXFx0ICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT1cXFwicmlnaHRcXFwiPlxcblxcdCAgICAgIDwhLS08YnV0dG9uIGNsYXNzPVxcXCJidXR0b25cXFwiIG9uLXRhcD1cXFwidGVzdGZ1bmN0aW9uKClcXFwiPlRlc3Q8L2J1dHRvbj4tLT5cXG5cXHQgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gaW9uLW1vcmVcXFwiIG5nLWlmPVxcXCIhJHJvb3Qudm9pY2VPdmVyXFxcIiBvbi10YXA9XFxcIm9wZW5NZW51UG9wb3ZlcigkZXZlbnQpXFxcIj48L2J1dHRvbj5cXG5cXHQgICAgICA8YSBocmVmIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gaW9uLW1vcmVcXFwiIG9uLXRhcD1cXFwib3Blbk1lbnVQb3BvdmVyKCRldmVudClcXFwiIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPnt7J09QVElPTlMnfHRyYW5zbGF0ZX19PC9hPlxcblxcdCAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG5cXHQ8L2lvbi1uYXYtYmFyPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIiBzY3JvbGw9XFxcInRydWVcXFwiIGRlbGVnYXRlLWhhbmRsZT1cXFwibWFpblNjcm9sbFxcXCIgb3ZlcmZsb3ctc2Nyb2xsPVxcXCJ0cnVlXFxcIiBuZy1jbGFzcz1cXFwieyd0aGVtZS1kYXJrJzokcm9vdC4kc3RvcmFnZS50aGVtZSA9PSAnbmlnaHQnfVxcXCI+XFxuXFx0XFx0PGlvbi1yZWZyZXNoZXIgcHVsbGluZy10ZXh0PVxcXCJ7eydQVUxMX0RPV05fVE9fUkVGUkVTSCd8dHJhbnNsYXRlfX1cXFwiIG9uLXJlZnJlc2g9XFxcInJlZnJlc2goKVxcXCI+XFxuICBcXHQ8L2lvbi1yZWZyZXNoZXI+XFxuICBcXHRcXHQ8ZGl2IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS52aWV3PT0nY29tcGFjdCcgJiYgZGF0YS5sZW5ndGg+MFxcXCIgY2xhc3M9XFxcIm1hc29ucnktbGF5b3V0XFxcIj5cXG5cXHQgICAgXFx0PGRpdiBuZy1yZXBlYXQ9XFxcImQgaW4gZGF0YSB8IHJlZ2V4OidjYXRlZ29yeSc6J2JtLionIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcIm1hc29ucnktbGF5b3V0X19wYW5lbFxcXCI+XFxuXFx0ICAgIFxcdCAgIDxkaXYgY2xhc3M9XFxcImxpc3QgbWFzb25yeS1sYXlvdXRfX3BhbmVsLWNvbnRlbnRcXFwiIG5nLWNsYXNzPVxcXCJ7J3RoZW1lLWRhcmsnOiRyb290LiRzdG9yYWdlLnRoZW1lID09ICduaWdodCd9XFxcIj5cXG5cXHRcXHQgICAgXFx0PGRpdiBjbGFzcz1cXFwiaXRlbVxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgb24tdGFwPVxcXCJvcGVuKGQpXFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgPHNwYW4gbmctaWY9XFxcImQucmVibG9nZ2VkX2J5Lmxlbmd0aD4wXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctcmV0dXJuLXJpZ2h0XFxcIj48L2k+IHt7J1JFU1RFRU1FRF9CWSd8dHJhbnNsYXRlfX0ge3tkLnJlYmxvZ2dlZF9ieX19PC9zcGFuPlxcblxcdFxcdFxcdFxcdCAgICA8cD48aDIgY2xhc3M9XFxcIndyYXB3b3JkXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbW9uZXkgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJkLnByb21vdGVkLnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPjwvaT4gPGkgY2xhc3M9XFxcImZhIGZhLWZpcmUgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJkLnBlcmNlbnRfc3RlZW1fZG9sbGFycyA9PT0gMFxcXCI+PC9pPiB7e2QudGl0bGV9fTwvaDI+PC9wPlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgd3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7ZC5jcmVhdGVkfHRpbWVhZ299fSZuYnNwO3t7J0JZJ3x0cmFuc2xhdGV9fSZuYnNwOzxiPnt7ZC5hdXRob3J9fTwvYj4mbmJzcDs8ZGl2IGNsYXNzPVxcXCJyZXB1dGF0aW9uXFxcIj57e2QuYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+IHt7J0lOJ3x0cmFuc2xhdGV9fSB7e2QuY2F0ZWdvcnl8ZGV0cmFuc2xpdGVyYXRlOmZhbHNlfX0gJm1pZGRvdDsge3tkLmJvZHl8cmVhZGluZ3RpbWV9fSB7eydNSU5fUkVBRCd8dHJhbnNsYXRlfX08L2Rpdj48L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWQudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ2b3RlUG9zdChkKVxcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcigkZXZlbnQsIGQpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImQuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBuZy1pZj1cXFwiIWQuaW52b3RpbmdcXFwiPjwvaT48L2E+PGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCJkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChkKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+MC4wMDA8L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XFxcImQubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj57e2QgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9zcGFuPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgICAgICA8c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcIiFkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZClcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50LCBkKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+e3snVVBWT1RFJ3x0cmFuc2xhdGV9fTwvYT48YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcImQudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KGQpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImQuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiIWQuaW52b3RpbmdcXFwiPjwvaT57eydVTlZPVEUnfHRyYW5zbGF0ZX19PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+e3tkIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJkLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPjwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKGQpXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uLXN0YWxrZXJcXFwiPjwvaT4mbmJzcDt7e2QubmV0X3ZvdGVzfX08L2E+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiPjwvaT4mbmJzcDt7e2QuY2hpbGRyZW59fTwvYT5cXG5cXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwIHRyaWdodFxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG9uLXRhcD1cXFwiJHJvb3QucmVCbG9nKHMuYXV0aG9yLCBzLnBlcm1saW5rKVxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiZuYnNwOzwvYT5cXG5cXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHQgICAgPC9kaXY+XFxuXFx0XFx0XFx0ICBcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQgIDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnZpZXc9PSdjYXJkJyAmJiBkYXRhLmxlbmd0aD4wXFxcIiBjbGFzcz1cXFwibWFzb25yeS1sYXlvdXRcXFwiPlxcblxcdFxcdFxcdDxkaXYgbmctcmVwZWF0PVxcXCJkcyBpbiBkYXRhIHwgcmVnZXg6J2NhdGVnb3J5JzonYm0uKicgdHJhY2sgYnkgJGluZGV4XFxcIiBjbGFzcz1cXFwibWFzb25yeS1sYXlvdXRfX3BhbmVsXFxcIj5cXG5cXHQgICAgXFx0ICAgPGRpdiBjbGFzcz1cXFwibGlzdCBjYXJkIG1hc29ucnktbGF5b3V0X19wYW5lbC1jb250ZW50XFxcIiBuZy1pZj1cXFwiZHNcXFwiIG5nLWNsYXNzPVxcXCJ7J3RoZW1lLWRhcmsnOiRyb290LiRzdG9yYWdlLnRoZW1lID09ICduaWdodCd9XFxcIj5cXG5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIiBvbi10YXA9XFxcIm9wZW4oZHMpXFxcIiBuZy1jbGFzcz1cXFwieyd0aGVtZS1kYXJrJzokcm9vdC4kc3RvcmFnZS50aGVtZSA9PSAnbmlnaHQnfVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PHNwYW4gbmctaWY9XFxcImRzLnJlYmxvZ2dlZF9ieS5sZW5ndGg+MFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiB7eydSRVNURUVNRURfQlknfHRyYW5zbGF0ZX19IHt7ZHMucmVibG9nZ2VkX2J5fX08L3NwYW4+XFxuXFx0XFx0XFx0XFx0ICAgIDxoMiBjbGFzcz1cXFwid3JhcHdvcmRcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1tb25leSBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcImRzLnByb21vdGVkLnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPjwvaT4gPGkgY2xhc3M9XFxcImZhIGZhLWZpcmUgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJkcy5wZXJjZW50X3N0ZWVtX2RvbGxhcnMgPT09IDBcXFwiPjwvaT4ge3tkcy50aXRsZX19PC9oMj5cXG5cXHRcXHRcXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2RzLmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7e3snQlknfHRyYW5zbGF0ZX19Jm5ic3A7PGI+e3tkcy5hdXRob3J9fTwvYj4mbmJzcDs8ZGl2IGNsYXNzPVxcXCJyZXB1dGF0aW9uXFxcIj57e2RzLmF1dGhvcl9yZXB1dGF0aW9ufHJlcHV0YXRpb258bnVtYmVyOjB9fTwvZGl2PiB7eydJTid8dHJhbnNsYXRlfX0ge3tkcy5jYXRlZ29yeXxkZXRyYW5zbGl0ZXJhdGU6ZmFsc2V9fSAmbWlkZG90OyB7e2RzLmJvZHl8cmVhZGluZ3RpbWV9fSB7eydNSU5fUkVBRCd8dHJhbnNsYXRlfX08L2Rpdj48L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpdGVtLWJvZHlcXFwiPlxcblxcdFxcdFxcdFxcdCAgICA8aW1nIGNsYXNzPVxcXCJmdWxsLWltYWdlXFxcIiBuZy1zcmM9XFxcInt7ZHMuanNvbl9tZXRhZGF0YS5pbWFnZVswXX19XFxcIiBvbi10YXA9XFxcIm9wZW4oZHMpXFxcIiBuZy1pZj1cXFwiZHMuanNvbl9tZXRhZGF0YS5pbWFnZVswXVxcXCIgb25lcnJvcj1cXFwidGhpcy5zcmM9J2ltZy9ub2ltYWdlLnBuZydcXFwiLz5cXG5cXHRcXHRcXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8c3BhbiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCIhZHMudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ2b3RlUG9zdChkcylcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50LCBkcylcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZHMuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBuZy1pZj1cXFwiIWRzLmludm90aW5nXFxcIj48L2k+PC9hPjxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiZHMudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KGRzKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkcy5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhZHMuaW52b3RpbmdcXFwiPjwvaT48L2E+Jm5ic3A7PHNwYW4gY2xhc3M9XFxcImdyYXlcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LGRzKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZHMubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdID09PSAnMC4wMDAnXFxcIj48ZGVsPnt7ZHMgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XFxcImRzLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkcyB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZHMpXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVyKCRldmVudCwgZHMpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImRzLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgbmctaWY9XFxcIiFkcy5pbnZvdGluZ1xcXCI+PC9pPnt7J1VQVk9URSd8dHJhbnNsYXRlfX08L2E+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCJkcy51cHZvdGVkXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QoZHMpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImRzLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcIiFkcy5pbnZvdGluZ1xcXCI+PC9pPnt7J1VOVk9URSd8dHJhbnNsYXRlfX08L2E+Jm5ic3A7PHNwYW4gY2xhc3M9XFxcImdyYXlcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LGRzKVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiA8c3BhbiBuZy1pZj1cXFwiZHMubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdID09PSAnMC4wMDAnXFxcIj48ZGVsPjAuMDAwPC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJkcy5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPnt7ZHMgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTI1IHRyaWdodFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG9uLXRhcD1cXFwiJHJvb3Qub3BlbkluZm8oZHMpXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uLXN0YWxrZXJcXFwiPjwvaT4mbmJzcDt7e2RzLm5ldF92b3Rlc319PC9hPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMjUgdHJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWNoYXRidWJibGVzXFxcIj48L2k+Jm5ic3A7e3tkcy5jaGlsZHJlbn19PC9hPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTAgdHJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgb24tdGFwPVxcXCIkcm9vdC5yZUJsb2coZHMuYXV0aG9yLCBkcy5wZXJtbGluaylcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiPjwvaT4mbmJzcDs8L2E+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuICAgIDxpb24taW5maW5pdGUtc2Nyb2xsIG5nLWlmPVxcXCJtb3JlRGF0YUNhbkJlTG9hZGVkKClcXFwiIG9uLWluZmluaXRlPVxcXCJsb2FkTW9yZSgpXFxcIiBkaXN0YW5jZT1cXFwiMTUlXFxcIj48L2lvbi1pbmZpbml0ZS1zY3JvbGw+XFxuICAgIDxicj5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyVC5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRQb3N0XFxcIj5cXG4gICAgICAgIDxpb24tY29udGVudD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctYmluZC1odG1sPVxcXCJ0b29sdGlwVGV4dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3ZlclNsaWRlci5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRTbGlkZVxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgICAgIFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTBcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgb24tdGFwPVxcXCJ2b3RlUG9zdFMoKVxcXCI+PC9idXR0b24+PC9kaXY+XFxuICAgICAgICAgIFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICAgIFxcdFxcdFxcdDxkaXYgY2xhc3MgPSBcXFwiaXRlbSByYW5nZSByYW5nZS1wb3NpdGl2ZVxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAge3tyYW5nZVZhbHVlfX0gPGlucHV0IHR5cGU9XFxcInJhbmdlXFxcIiBuYW1lPVxcXCJyYW5nZTFcXFwiIG1pbj1cXFwiMVxcXCIgbWF4PVxcXCIxMDBcXFwiIG5nLW1vZGVsPVxcXCJyYW5nZVZhbHVlXFxcIiBuZy1jaGFuZ2U9XFxcImRyYWcocmFuZ2VWYWx1ZSlcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcbiAgICAgICAgICBcXHRcXHQ8L2Rpdj5cXG4gICAgICAgICAgXFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMFxcXCI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGlvbi1jbG9zZS1yb3VuZFxcXCIgbmctY2xpY2s9XFxcImNsb3NlU2xpZGVyKClcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICBcXHQ8L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1Bvc3RzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAuYm9va21hcmsnLCB7XG4gICAgdXJsOiAnL2Jvb2ttYXJrJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydCT09LTUFSS1MnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIj5cXG5cXHQ8aW9uLWxpc3QgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLmJvb2ttYXJrXFxcIiBjYW4tc3dpcGU9XFxcInRydWVcXFwiPlxcbiAgXFx0XFx0PGlvbi1pdGVtIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiAkcm9vdC4kc3RvcmFnZS5ib29rbWFya1xcXCIgbmctY2xpY2s9XFxcIiRyb290LmdldENvbnRlbnRBbmRPcGVuKGl0ZW0pXFxcIj5cXG5cXHRcXHQgICAgPHA+PGgyPnt7aXRlbS5hdXRob3J9fTwvaDI+PC9wPlxcbiAgICAgICAgPHA+e3tpdGVtLnBlcm1saW5rfX08L3A+XFxuXFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB0d3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7aXRlbS5jcmVhdGVkfHRpbWVhZ299fTwvZGl2PjwvZGl2PlxcblxcdFxcdCAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1hc3NlcnRpdmVcXFwiIG5nLWNsaWNrPVxcXCJyZW1vdmVCb29rbWFyaygkaW5kZXgpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheSBwYWRkaW5nXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UuYm9va21hcmsubGVuZ3RoPjBcXFwiPnt7J1NXSVBFX0xFRlQnfHRyYW5zbGF0ZX19PC9wPlxcbiAgICA8cCBjbGFzcz1cXFwidGNlbnRlciBncmF5IHBhZGRpbmdcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ib29rbWFyay5sZW5ndGg9PTBcXFwiPnt7J05PVEhJTkdfSEVSRSd8dHJhbnNsYXRlfX08L3A+XFxuXFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdCb29rbWFya0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cdC5zdGF0ZSgnYXBwLmRyYWZ0cycsIHtcbiAgICB1cmw6ICcvZHJhZnRzJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydEUkFGVFMnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIj5cXG5cXHQ8aW9uLWxpc3QgbmctaWY9XFxcImRyYWZ0c1xcXCIgY2FuLXN3aXBlPVxcXCJ0cnVlXFxcIj5cXG4gIFxcdFxcdDxpb24taXRlbSBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gZHJhZnRzXFxcIiBuZy1jbGljaz1cXFwiJHJvb3Qub3BlbkRyYWZ0KGl0ZW0pXFxcIj5cXG5cXHRcXHQgICAgPHA+PGgyPnt7aXRlbS50aXRsZX19PC9oMj48L3A+XFxuXFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB0d3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7aXRlbS5jcmVhdGVkfHRpbWVhZ299fSZuYnNwO3t7J1RBR1MnIHwgdHJhbnNsYXRlfX06Jm5ic3A7PGI+e3tpdGVtLnRhZ3N9fTwvYj48L2Rpdj48L2Rpdj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlRHJhZnQoaXRlbS5faWQpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheVxcXCIgbmctaWY9XFxcImRyYWZ0cy5sZW5ndGg+MFxcXCI+e3snU1dJUEVfTEVGVCd8dHJhbnNsYXRlfX08L3A+XFxuICAgIDxwIGNsYXNzPVxcXCJ0Y2VudGVyIGdyYXlcXFwiIG5nLWlmPVxcXCJkcmFmdHMubGVuZ3RoPT0wXFxcIj57eydOT1RISU5HX0hFUkUnfHRyYW5zbGF0ZX19PC9wPlxcblxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnRHJhZnRzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cblx0LnN0YXRlKCdhcHAuaW1hZ2VzJywge1xuICAgIHVybDogJy9pbWFnZXMnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcG9zdC5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctdGl0bGU9XFxcInt7J01BTkFHRScgfCB0cmFuc2xhdGV9fSB7eydHQUxMRVJZJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCJpbWFnZXNcXFwiIGNhbi1zd2lwZT1cXFwidHJ1ZVxcXCI+XFxuICBcXHRcXHQ8aW9uLWl0ZW0gbmctcmVwZWF0PVxcXCJpdGVtIGluIGltYWdlc1xcXCIgY2xhc3M9XFxcIml0ZW0tdGh1bWJuYWlsLWxlZnRcXFwiPlxcbiAgICAgICAgPGltZyBuZy1zcmM9XFxcInt7aXRlbS51cmx9fVxcXCIvPlxcbiAgICAgICAgPHA+PGgyPnt7aXRlbS51cmx9fTwvaDI+PC9wPlxcblxcdFxcdFxcdCAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHR3cmFwXFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4ge3tpdGVtLmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7PC9kaXY+PC9kaXY+XFxuICAgICAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1hc3NlcnRpdmVcXFwiIG5nLWNsaWNrPVxcXCJyZW1vdmVJbWFnZShpdGVtLl9pZClcXFwiPnt7J1JFTU9WRScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcblxcdFxcdCAgICA8aW9uLW9wdGlvbi1idXR0b24gY2xhc3M9XFxcImJ1dHRvbi1jYWxtXFxcIiBuZy1jbGljaz1cXFwiY29weUltYWdlKGl0ZW0udXJsKVxcXCI+e3snQ09QWScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1pdGVtPlxcbiAgICA8L2lvbi1saXN0PlxcbiAgICA8cCBjbGFzcz1cXFwidGNlbnRlciBncmF5XFxcIiBuZy1pZj1cXFwiaW1hZ2VzLmxlbmd0aD4wXFxcIj57eydTV0lQRV9MRUZUJ3x0cmFuc2xhdGV9fTwvcD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheVxcXCIgbmctaWY9XFxcImltYWdlcy5sZW5ndGg9PTBcXFwiPnt7J05PVEhJTkdfSEVSRSd8dHJhbnNsYXRlfX08L3A+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdJbWFnZXNDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5ub3RpZmljYXRpb25zJywge1xuICAgIHVybDogJy9ub3RpZmljYXRpb25zJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydOT1RJRklDQVRJT05TJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zXFxcIiBjYW4tc3dpcGU9XFxcInRydWVcXFwiPlxcbiAgXFx0XFx0PGlvbi1pdGVtIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiAkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zIHwgb3JkZXJCeTogJy1jcmVhdGVkJyBcXFwiIG5nLWNsaWNrPVxcXCIkcm9vdC5nZXRDb250ZW50QW5kT3BlbihpdGVtKVxcXCI+XFxuXFx0XFx0ICAgIDxwPjxoMj57e2l0ZW0udGl0bGV9fTwvaDI+PC9wPlxcblxcdFxcdCAgICA8c3Bhbj57e2l0ZW0ubWVzc2FnZX19PC9zcGFuPlxcblxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgdHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2l0ZW0uY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWScgfCB0cmFuc2xhdGV9fSZuYnNwOzxiPnt7aXRlbS5hdXRob3J9fSZuYnNwOzwvYj48L2Rpdj48L2Rpdj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlTm90aWZpY2F0aW9uKCRpbmRleClcXFwiPnt7J1JFTU9WRScgfCB0cmFuc2xhdGV9fVxcblxcdFxcdCAgICA8L2lvbi1vcHRpb24tYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1pdGVtPlxcbiAgICA8L2lvbi1saXN0PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnTm90aWZpY2F0aW9uc0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cbiAgLnN0YXRlKCdhcHAucG9zdCcsIHtcbiAgICB1cmw6ICcvcG9zdC86Y2F0ZWdvcnkvOmF1dGhvci86cGVybWxpbmsnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvcG9zdC5odG1sJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctdGl0bGU9XFxcIlxcXCI+XFxuXFx0PGlvbi1uYXYtYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiPlxcblxcdFxcdCAgPGlvbi1uYXYtYmFjay1idXR0b24+XFxuICAgIFxcdDwvaW9uLW5hdi1iYWNrLWJ1dHRvbj5cXG5cXHQgICAgPGlvbi1uYXYtYnV0dG9ucyBzaWRlPSdsZWZ0Jz5cXG5cXHQgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1uYXZpY29uXFxcIiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGlvbi1tb3JlXFxcIiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIiBtZW51LXRvZ2dsZT1cXFwibGVmdFxcXCI+e3snTUVOVSd8dHJhbnNsYXRlfX08L2E+XFxuXFx0ICAgIDwvaW9uLW5hdi1idXR0b25zPlxcbiAgICAgIDxpb24tbmF2LXRpdGxlPlxcbiAgICAgIDwvaW9uLW5hdi10aXRsZT5cXG5cXHQgICAgPGlvbi1uYXYtYnV0dG9ucyBzaWRlPSdyaWdodCc+XFxuICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhclxcXCIgb24tdGFwPVxcXCJib29rbWFyaygpXFxcIj48aSBjbGFzcz1cXFwiaWNvblxcXCIgbmctY2xhc3M9XFxcInsnaW9uLWlvcy1ib29rbWFya3MnOmlzQm9va21hcmtlZCgpLCAnaW9uLWlvcy1ib29rbWFya3Mtb3V0bGluZSc6IWlzQm9va21hcmtlZCgpfVxcXCI+PC9pPjwvYnV0dG9uPiAmbmJzcDsgXFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tYW5kcm9pZC1zaGFyZS1hbHRcXFwiIG9uLXRhcD1cXFwic2hhcmUoKVxcXCI+PC9idXR0b24+XFxuICAgICAgPC9zcGFuPlxcbiAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPlxcbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhclxcXCIgb24tdGFwPVxcXCJib29rbWFyaygpXFxcIj48aSBjbGFzcz1cXFwiaWNvblxcXCIgbmctY2xhc3M9XFxcInsnaW9uLWlvcy1ib29rbWFya3MnOmlzQm9va21hcmtlZCgpLCAnaW9uLWlvcy1ib29rbWFya3Mtb3V0bGluZSc6IWlzQm9va21hcmtlZCgpfVxcXCI+PC9pPnt7J0JPT0tNQVJLJ3x0cmFuc2xhdGV9fTwvYT4gJm5ic3A7IFxcbiAgICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tYW5kcm9pZC1zaGFyZS1hbHRcXFwiIG9uLXRhcD1cXFwic2hhcmUoKVxcXCI+e3snU0hBUkUnfHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDwvc3Bhbj5cXG5cXHQgICAgPC9pb24tbmF2LWJ1dHRvbnM+XFxuXFx0PC9pb24tbmF2LWJhcj5cXG4gIDxpb24tZmxvYXRpbmctbWVudSBtZW51LWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBtZW51LW9wZW4tY29sb3I9XFxcIiMzODdlZjVcXFwiIGhhcy1mb290ZXI9XFxcInRydWVcXFwiPlxcbiAgICA8aW9uLWZsb2F0aW5nLWl0ZW0gaWNvbj1cXFwiaW9uLWNoYXRidWJibGVzXFxcIiBjbGljaz1cXFwiaXNyZXBseWluZygkcm9vdC4kc3RvcmFnZS5zaXRlbSwgdHJ1ZSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIiBidXR0b24tY29sb3I9XFxcIiMzODdlZjVcXFwiIGljb24tY29sb3I9XFxcIiNmZmZcXFwiIHRleHQ9XFxcInt7J1JFUExZJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGVcXFwiIGNsaWNrPVxcXCJ1cHZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgYnV0dG9uLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBpY29uLWNvbG9yPVxcXCIjZmZmXFxcIiB0ZXh0PVxcXCJ7eydVUFZPVEUnfHRyYW5zbGF0ZX19XFxcIiB0ZXh0LWNsYXNzPVxcXCJ0ZXh0LWNsYXNzXFxcIj48L2lvbi1mbG9hdGluZy1pdGVtPlxcbiAgICA8aW9uLWZsb2F0aW5nLWl0ZW0gaWNvbj1cXFwiaW9uLWVkaXRcXFwiIGNsaWNrPVxcXCJlZGl0UG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3I9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snRURJVCd8dHJhbnNsYXRlfX1cXFwiIHRleHQtY2xhc3M9XFxcInRleHQtY2xhc3NcXFwiPjwvaW9uLWZsb2F0aW5nLWl0ZW0+XFxuICAgIDxpb24tZmxvYXRpbmctaXRlbSBpY29uPVxcXCJpb24taW1hZ2VcXFwiIGNsaWNrPVxcXCJzaG93SW1hZ2VzKDApXFxcIiBuZy1pZj1cXFwiaXNJbWFnZXMoKVxcXCIgYnV0dG9uLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBpY29uLWNvbG9yPVxcXCIjZmZmXFxcIiB0ZXh0PVxcXCJ7eydHQUxMRVJZJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSAkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3JcXFwiIGNsaWNrPVxcXCIkcm9vdC5yZUJsb2coJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLCAkcm9vdC4kc3RvcmFnZS5zaXRlbS5wZXJtbGluaylcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snUkVCTE9HJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gIDwvaW9uLWZsb2F0aW5nLW1lbnU+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLWhlYWRlclxcXCIgZGVsZWdhdGUtaGFuZGxlPVxcXCJtYWluU2Nyb2xsXFxcIiBvdmVyZmxvdy1zY3JvbGw9XFxcInRydWVcXFwiIG5nLWNsYXNzPVxcXCJ7J3RoZW1lLWRhcmsnOiRyb290LiRzdG9yYWdlLnRoZW1lID09ICduaWdodCd9XFxcIj48IS0tLS0+XFxuICAgIDxkaXYgbmctaWY9JyRyb290LiRzdG9yYWdlLnNpdGVtJz5cXG4gICAgICA8cCBjbGFzcz1cXFwidGl0bGUgaDNcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5yb290X3RpdGxlICYmICRyb290LiRzdG9yYWdlLnNpdGVtLnRpdGxlPT0nJ1xcXCI+PGEgaHJlZj1cXFwiIy9hcHAvcG9zdHt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udXJsLnNwbGl0KCcjJylbMF19fVxcXCI+e3tcXFwiVklFV19DT05URVhUXFxcInx0cmFuc2xhdGV9fTwvYT48L3A+XFxuICAgIFxcdDxwIGNsYXNzPVxcXCJ0aXRsZSBoM1xcXCI+e3skcm9vdC4kc3RvcmFnZS5zaXRlbS50aXRsZX19PC9wPlxcbiAgICBcXHQ8ZGl2IGNsYXNzPVxcXCJzdGl0bGUgcm93IGdyYXlcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8aW1nIGNsYXNzPVxcXCJyb3VuZC1hdmF0YXJcXFwiIHNyYz1cXFwiaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFwiIG5nLXNyYz1cXFwie3skcm9vdC4kc3RvcmFnZS5wYWNjb3VudHNbJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yXS51c2VyX2ltYWdlfHwkcm9vdC4kc3RvcmFnZS5wYWNjb3VudHNbJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yXS5wcm9maWxlLnByb2ZpbGVfaW1hZ2V9fVxcXCIgb25lcnJvcj1cXFwidGhpcy5zcmM9XFxcXCdpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXFwnXFxcIiBvbmFib3J0PVxcXCJ0aGlzLnNyYz1cXFxcJ2ltZy91c2VyX3Byb2ZpbGUucG5nXFxcXCdcXFwiIC8+IDxiPjxhIGhyZWY9XFxcIiMvYXBwL3Byb2ZpbGUve3skcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3J9fVxcXCI+e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3J9fTwvYT48L2I+Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3JfcmVwdXRhdGlvbnxyZXB1dGF0aW9ufG51bWJlcjowfX08L2Rpdj4mbWlkZG90O3t7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uY3JlYXRlZHx0aW1lYWdvfX0ge3snSU4nfHRyYW5zbGF0ZX19Jm5ic3A7e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5jYXRlZ29yeXxkZXRyYW5zbGl0ZXJhdGU6ZmFsc2V9fTwvZGl2PjxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxzcGFuIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1mbGFnXFxcIiBvbi10YXA9XFxcImRvd252b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uZG93bnZvdGVkXFxcIj57eydET1dOVk9URSd8dHJhbnNsYXRlfX08L2k+PGkgY2xhc3M9XFxcImZhIGZhLWZsYWcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5kb3dudm90ZWRcXFwiPnt7J1VOVk9URV9ET1dOVk9URUQnfHRyYW5zbGF0ZX19PC9pPjwvc3Bhbj48c3BhbiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWZsYWdcXFwiIG9uLXRhcD1cXFwiZG93bnZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiEkcm9vdC4kc3RvcmFnZS5zaXRlbS5kb3dudm90ZWRcXFwiPjwvaT48aSBjbGFzcz1cXFwiZmEgZmEtZmxhZyBwb3NpdGl2ZVxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLmRvd252b3RlZFxcXCI+PC9pPjwvc3Bhbj48L2Rpdj48L2Rpdj5cXG4gICAgXFx0PGJyPjwhLS0tLT5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJib2R5dGV4dCBzZWxlY3RhYmxlXFxcIiBuZy1iaW5kLWh0bWw9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLmJvZHkgfCBwYXJzZVVybCBcXFwiPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgbmctaWY9JyRyb290LiRzdG9yYWdlLnNpdGVtLmpzb25fbWV0YWRhdGEudGFncycgY2xhc3M9XFxcInRhZ3NcXFwiPlxcbiAgICAgICAgPGRpdiBuZy1yZXBlYXQ9J3RhZyBpbiAkcm9vdC4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLnRhZ3MnPlxcbiAgICAgICAgICA8c3Bhbj48ZGl2IGNsYXNzPVxcXCJ0YWdcXFwiIG9uLXRhcD1cXFwib3BlblRhZyh0YWcsIDUpXFxcIj57e3RhZ3xkZXRyYW5zbGl0ZXJhdGU6ZmFsc2V9fTwvZGl2PjwvbGk+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgZ3JheVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgb24tdGFwPVxcXCJ1cHZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiEkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkICYmICEkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcnIoJGV2ZW50LCAkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPjwvaT48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkICYmICEkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCI+PC9pPiZuYnNwOyZuYnNwOyZuYnNwOzxzcGFuIG9uLXRhcD1cXFwiJHJvb3Qub3BlbkluZm8oJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIj57eyRyb290LiRzdG9yYWdlLnNpdGVtLm5ldF92b3Rlc319PC9zcGFuPjwvZGl2PlxcblxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCIgbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG4gICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGVcXFwiIG9uLXRhcD1cXFwidXB2b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udXB2b3RlZFxcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcnIoJGV2ZW50LCAkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPnt7J1VQVk9URSd8dHJhbnNsYXRlfX08L2k+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtYXJyb3ctZHJvcHVwLWNpcmNsZSBwb3NpdGl2ZVxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnNpdGVtLnVwdm90ZWRcXFwiPnt7J1VOVk9URV9VUFZPVEVEJ3x0cmFuc2xhdGV9fTwvaT4mbmJzcDsmbmJzcDsmbmJzcDs8c3BhbiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCI+e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5uZXRfdm90ZXN9fTwvc3Bhbj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiIG9uLXRhcD1cXFwib3BlblRvb2x0aXAoJGV2ZW50LCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCI+PGI+e3skcm9vdC4kc3RvcmFnZS5jdXJyZW5jeXxnZXRDdXJyZW5jeVN5bWJvbH19PC9iPiB7eyRyb290LiRzdG9yYWdlLnNpdGVtIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG9uLXRhcD1cXFwiaXNyZXBseWluZygkcm9vdC4kc3RvcmFnZS5zaXRlbSwgdHJ1ZSlcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1yZXBseVxcXCI+PC9pPiB7eyRyb290LiRzdG9yYWdlLnNpdGVtLmNoaWxkcmVufX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgb24tdGFwPVxcXCJlZGl0UG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5hdXRob3I9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPjxpIGNsYXNzPVxcXCJmYSAgZmEtcGVuY2lsLXNxdWFyZS1vXFxcIj48L2k+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG9uLXRhcD1cXFwiZGVsZXRlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5uZXRfdm90ZXM9PTAgJiYgJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtb1xcXCI+PC9pPjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxjZW50ZXI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBidXR0b24tb3V0bGluZSBidXR0b24taWNvbiBpb24tcmVmcmVzaCBpY29uLXJpZ2h0XFxcIiBvbi10YXA9XFxcImZldGNoQ29tbWVudHMoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLCAkcm9vdC4kc3RvcmFnZS5zaXRlbS5wZXJtbGluaylcXFwiPjxpb24tc3Bpbm5lciBjbGFzcz1cXFwic3Bpbm5lci1wb3NpdGl2ZVxcXCIgbmctaWY9XFxcIiRyb290LmZldGNoaW5nXFxcIj48L2lvbi1zcGlubmVyPiB7e1xcXCJDT01NRU5UU1xcXCJ8dHJhbnNsYXRlfX08L2J1dHRvbj48L2NlbnRlcj5cXG4gICAgICA8YnI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibXktaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICBcXG4gICAgICA8aW9uLXRocmVhZCBjb21tZW50cz1cXFwiY29tbWVudHNcXFwiPjwvaW9uLXRocmVhZD5cXG4gICAgPC9kaXY+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3ZlclRyLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3IGNsYXNzPVxcXCJkZXRhaWxlZFBvc3RcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1iaW5kLWh0bWw9XFxcInRvb2x0aXBUZXh0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgXFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyU2xpZGVyci5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRTbGlkZVxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmdcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMFxcXCI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBvbi10YXA9XFxcInZvdGVQb3N0UygpXFxcIj48L2J1dHRvbj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcXFwiaXRlbSByYW5nZSByYW5nZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgICAgIHt7cmFuZ2VWYWx1ZX19IDxpbnB1dCB0eXBlPVxcXCJyYW5nZVxcXCIgbmFtZT1cXFwicmFuZ2UyXFxcIiBtaW49XFxcIjFcXFwiIG1heD1cXFwiMTAwXFxcIiBuZy1tb2RlbD1cXFwicmFuZ2VWYWx1ZVxcXCIgbmctY2hhbmdlPVxcXCJkcmFnKHJhbmdlVmFsdWUpXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTBcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tY2xvc2Utcm91bmRcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVNsaWRlcnIoKVxcXCI+PC9idXR0b24+PC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnUG9zdEN0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgLy8gaWYgbm9uZSBvZiB0aGUgYWJvdmUgc3RhdGVzIGFyZSBtYXRjaGVkLCB1c2UgdGhpcyBhcyB0aGUgZmFsbGJhY2tcbiAgJHVybFJvdXRlclByb3ZpZGVyLm90aGVyd2lzZSgnL2FwcC9wb3N0cy8vdHJ1ZScpO1xuICAkaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnbGVmdCcpXG4gICRpb25pY0NvbmZpZ1Byb3ZpZGVyLmJhY2tCdXR0b24udGV4dCgnJykuaWNvbignaW9uLWNoZXZyb24tbGVmdCcpO1xuICAkaW9uaWNDb25maWdQcm92aWRlci52aWV3cy5zd2lwZUJhY2tFbmFibGVkKGZhbHNlKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIudmlld3MubWF4Q2FjaGUoMyk7XG5cbiAgJGFuaW1hdGVQcm92aWRlci5jbGFzc05hbWVGaWx0ZXIoIC9cXGJhbmltYXRlZFxcYi8gKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIuc2Nyb2xsaW5nLmpzU2Nyb2xsaW5nKGZhbHNlKTtcblxuICBpZiAod2luZG93LmNvcmRvdmEpIHtcbiAgICAgICRsb2dQcm92aWRlci5kZWJ1Z0VuYWJsZWQoZmFsc2UpO1xuICAgICAgJGNvbXBpbGVQcm92aWRlci5kZWJ1Z0luZm9FbmFibGVkKGZhbHNlKTtcbiAgfVxuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2VuLVVTJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2VuJykpOyAvL0VuZ2xpc2hcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygncnUtUlUnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvcnUtUlUnKSk7IC8vUnVzc2lhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdkZS1ERScsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9kZS1ERScpKTsgLy9HZXJtYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZnItRlInLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvZnItRlInKSk7IC8vRnJlbmNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2VzLUVTJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2VzLUVTJykpOyAvL1NwYW5pc2hcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZWwtR1InLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvZWwtR1InKSk7IC8vR3JlZWtcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnYmctQkcnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvYmctQkcnKSk7IC8vQnVsZ2FyaWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ25sLU5MJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L25sLU5MJykpOyAvL0R1dGNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2h1LUhVJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2h1LUhVJykpOyAvL0h1bmdhcmlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdjcy1DWicsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9jcy1DWicpKTsgLy9DemVjaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdoZS1JTCcsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9oZS1JTCcpKTsgLy9IZWJyZXdcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygncGwtUEwnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvcGwtUEwnKSk7IC8vUG9saXNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3B0LVBUJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3B0LVBUJykpOyAvL1BvcnR1Z3Vlc2VcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygncHQtQlInLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvcHQtQlInKSk7IC8vUG9ydHVndWVzZSBCcmF6aWxcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnaWQtSUQnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvaWQtSUQnKSk7IC8vSW5kb25lc2lhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCd6aC1UVycsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS96aC1UVycpKTsgLy9DaGluZXNlIHRyYWRpdGlvbmFsXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3poLUNOJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3poLUNOJykpOyAvL0NoaW5lc2Ugc2ltcGxpZmllZFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdkb2xhbicsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9kb2xhbicpKTsgLy9Eb2xhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdzdi1TRScsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9zdi1TRScpKTsgLy9DaGluZXNlIHNpbXBsaWZpZWRcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygndWstVUEnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvdWstVUEnKSk7IC8vVWtyYWluaWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ21zLU1ZJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L21zLU1ZJykpOyAvL01hbGF5XG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2hyLUhSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2hyLUhSJykpOyAvL0Nyb2F0aWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2ZhLUlSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2ZhLUlSJykpOyAvL1BlcnNpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnaXQtSVQnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvaXQtSVQnKSk7IC8vSXRhbGlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdmaWwtUEgnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvZmlsLVBIJykpOyAvL0ZpbGlwaW5vXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2FyLVNBJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2FyLVNBJykpOyAvL0FyYWJpY1xuXG4gICR0cmFuc2xhdGVQcm92aWRlci51c2VTYW5pdGl6ZVZhbHVlU3RyYXRlZ3kobnVsbCk7XG5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnByZWZlcnJlZExhbmd1YWdlKCdlbi1VUycpO1xuICAkdHJhbnNsYXRlUHJvdmlkZXIuZmFsbGJhY2tMYW5ndWFnZSgnZW4tVVMnKTtcblxufSk7XG5cbmFwcC5ydW4oZnVuY3Rpb24oJGlvbmljUGxhdGZvcm0sICRyb290U2NvcGUsICRsb2NhbFN0b3JhZ2UsICRpbnRlcnZhbCwgJGlvbmljUG9wdXAsICRpb25pY0xvYWRpbmcsICRjb3Jkb3ZhU3BsYXNoc2NyZWVuLCAkaW9uaWNNb2RhbCwgJHRpbWVvdXQsICRjb3Jkb3ZhVG9hc3QsIEFQSXMsICRzdGF0ZSwgJGxvZywgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRmaWx0ZXIsICR0cmFuc2xhdGUpIHtcbiAgJHJvb3RTY29wZS4kc3RvcmFnZSA9ICRsb2NhbFN0b3JhZ2U7XG4gICRyb290U2NvcGUubG9nID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICRsb2cuaW5mbyhtZXNzYWdlKTtcbiAgfTtcblxuICAkaW9uaWNQbGF0Zm9ybS5yZWdpc3RlckJhY2tCdXR0b25BY3Rpb24oZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICggKCRzdGF0ZS4kY3VycmVudC5uYW1lPT1cImFwcC5wb3N0c1wiKSApe1xuICAgICAgICAgIC8vIEgvVyBCQUNLIGJ1dHRvbiBpcyBkaXNhYmxlZCBmb3IgdGhlc2Ugc3RhdGVzICh0aGVzZSB2aWV3cylcbiAgICAgICAgICAvLyBEbyBub3QgZ28gdG8gdGhlIHByZXZpb3VzIHN0YXRlIChvciB2aWV3KSBmb3IgdGhlc2Ugc3RhdGVzLiBcbiAgICAgICAgICAvLyBEbyBub3RoaW5nIGhlcmUgdG8gZGlzYWJsZSBIL1cgYmFjayBidXR0b24uXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZvciBhbGwgb3RoZXIgc3RhdGVzLCB0aGUgSC9XIEJBQ0sgYnV0dG9uIGlzIGVuYWJsZWRcbiAgICAgICAgICBuYXZpZ2F0b3IuYXBwLmJhY2tIaXN0b3J5KCk7XG4gICAgICB9XG4gIH0sIDEwMCk7XG4gICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIC8vIEhpZGUgdGhlIGFjY2Vzc29yeSBiYXIgYnkgZGVmYXVsdCAocmVtb3ZlIHRoaXMgdG8gc2hvdyB0aGUgYWNjZXNzb3J5IGJhciBhYm92ZSB0aGUga2V5Ym9hcmRcbiAgICAvLyBmb3IgZm9ybSBpbnB1dHMpXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5oaWRlS2V5Ym9hcmRBY2Nlc3NvcnlCYXIodHJ1ZSk7XG4gICAgICBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuZGlzYWJsZVNjcm9sbCh0cnVlKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TdGF0dXNCYXIpIHtcbiAgICAgIC8vIG9yZy5hcGFjaGUuY29yZG92YS5zdGF0dXNiYXIgcmVxdWlyZWRcbiAgICAgIFN0YXR1c0Jhci5zdHlsZURlZmF1bHQoKTtcbiAgICB9XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzID0gW107XG4gICAgfVxuICAgIFxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS50aGVtZSkge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS50aGVtZSA9ICdkYXknO1xuICAgIH1cblxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRnb2xvcylcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0Z29sb3MgPSBcIndzczovL3dzLmdvbG9zLmlvL1wiO1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRzdGVlbSlcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0c3RlZW0gPSBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiO1xuXG4gICAgd2luZG93LmVqcy5DaGFpbkNvbmZpZy5zZXRDaGFpbklkKGxvY2FsU3RvcmFnZVskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSWRcIl0pO1xuXG4gICAgaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlKSkge1xuICAgICAgaWYodHlwZW9mIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0UHJlZmVycmVkTGFuZ3VhZ2UoZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgJHRyYW5zbGF0ZS51c2UobGFuZ3VhZ2UudmFsdWUpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTVUNDRVNTIC0+IFwiICsgZGF0YSk7XG4gICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UudmFsdWUuaW5kZXhPZihcImVuXCIpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9ICdlbic7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlID0gbGFuZ3VhZ2UudmFsdWU7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVSUk9SIC0+IFwiICsgZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UgPSAnZW4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkdHJhbnNsYXRlLnVzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlKTtcbiAgICB9XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKXtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCJTdGVlbVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyID0gXCJTdGVlbSBQb3dlclwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXN1bml0ID0gXCJTdGVlbVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhciA9IFwiU3RlZW0gRG9sbGFyXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQgPSBcIlNCRFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXB1bml0ID0gXCJTUFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0ID0gXCJTVEVFTVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9IFwic3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kgPSBcInVzZFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgPSAxO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlcyA9IFtcbiAgICAgIHtpZDonZW4nLCBuYW1lOiAnRW5nbGlzaCd9LCBcbiAgICAgIHtpZDonZXMtRVMnLCBuYW1lOiAnRXNwYcOxb2wnfSwgXG4gICAgICB7aWQ6J2VsLUdSJywgbmFtZTogJ86VzrvOu863zr3Ouc66zqwnfSwgXG4gICAgICB7aWQ6J2ZyLUZSJywgbmFtZTogJ0ZyYW7Dp2Fpcyd9LCBcbiAgICAgIHtpZDonZGUtREUnLCBuYW1lOiAnRGV1dHNjaCd9LCBcbiAgICAgIHtpZDoncnUtUlUnLCBuYW1lOiAn0KDRg9GB0YHQutC40LknfSwgXG4gICAgICB7aWQ6J2JnLUJHJywgbmFtZTogJ9CR0YrQu9Cz0LDRgNGB0LrQuCd9LCBcbiAgICAgIHtpZDonbmwtTkwnLCBuYW1lOiAnTmVkZXJsYW5kcyd9LCBcbiAgICAgIHtpZDonaHUtSFUnLCBuYW1lOiAnTWFneWFyJ30sIFxuICAgICAge2lkOidjcy1DWicsIG5hbWU6ICfEjGXFoXRpbmEnfSwgXG4gICAgICB7aWQ6J2hlLUlMJywgbmFtZTogJ9ei15HXqNeZ16rigI4nfSwgXG4gICAgICB7aWQ6J3BsLVBMJywgbmFtZTogJ1BvbHNraeKAjid9LCBcbiAgICAgIHtpZDoncHQtUFQnLCBuYW1lOiAnUG9ydHVndcOqcyd9LCBcbiAgICAgIHtpZDoncHQtQlInLCBuYW1lOiAnUG9ydHVndcOqcyBCUid9LFxuICAgICAge2lkOidzdi1TRScsIG5hbWU6ICdTdmVuc2snfSxcbiAgICAgIHtpZDonaWQtSUQnLCBuYW1lOiAnQmFoYXNhIEluZG9uZXNpYSd9LCBcbiAgICAgIHtpZDonemgtQ04nLCBuYW1lOiAn57mB6auU5Lit5paHJ30sIFxuICAgICAge2lkOid6aC1UVycsIG5hbWU6ICfnroDkvZPkuK3mlocnfSxcbiAgICAgIHtpZDonZG9sYW4nLCBuYW1lOiAnRG9sYW4nfSxcbiAgICAgIHtpZDondWstVUEnLCBuYW1lOiAn0KPQutGA0LDRl9C90YHRjNC60LAnfSxcbiAgICAgIHtpZDonbXMtTVknLCBuYW1lOiAnQmFoYXNhIE1lbGF5dSd9LFxuICAgICAge2lkOidoci1IUicsIG5hbWU6ICdIcnZhdHNraSd9LFxuICAgICAge2lkOidmYS1JUicsIG5hbWU6ICdGxIFyc2knfSxcbiAgICAgIHtpZDonaXQtSVQnLCBuYW1lOiAnSXRhbGlhbm8nfSxcbiAgICAgIHtpZDonZmlsLVBIJywgbmFtZTogJ1dpa2FuZyBGaWxpcGlubyd9LFxuICAgICAge2lkOidhci1TQScsIG5hbWU6ICfYudmO2LHZjtio2ZDZitmRJ31cbiAgICAgIFxuICAgIF07XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmRpcikge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kaXIgPSAnbHRyJztcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbnMgPSBbe2lkOidzdGVlbScsIG5hbWU6ICdTdGVlbSd9LCB7aWQ6J2dvbG9zJywgbmFtZTogJ0dvbG9zJ31dO1xuXG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcyA9IFtcbiAgICAgICAge2lkOididGMnLCBuYW1lOiAnQlRDJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDondXNkJywgbmFtZTogJ1VTRCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2V1cicsIG5hbWU6ICdFVVInLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidydWInLCBuYW1lOiAnUlVCJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonZ2JwJywgbmFtZTogJ0dCUCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2pweScsIG5hbWU6ICdKUFknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidrcncnLCBuYW1lOiAnS1JXJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonaW5yJywgbmFtZTogJ0lOUicsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2NueScsIG5hbWU6ICdDTlknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOid1YWgnLCBuYW1lOiAnVUFIJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDonc2VrJywgbmFtZTogJ1NFSycsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J3RyeScsIG5hbWU6ICdUUlknLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J2NhZCcsIG5hbWU6ICdDQUQnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J2NoZicsIG5hbWU6ICdDSEYnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J2F1ZCcsIG5hbWU6ICdBVUQnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J25vaycsIG5hbWU6ICdOT0snLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J3BsbicsIG5hbWU6ICdQTE4nLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICB7aWQ6J3BocCcsIG5hbWU6ICdQSFAnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9XG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UuYWRkaXRpb24pIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5hZGRpdGlvbiA9IFtcbiAgICAgICAgICB7aWQ6J2NhZCcsIG5hbWU6ICdDQUQnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICAgIHtpZDonY2hmJywgbmFtZTogJ0NIRicsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sXG4gICAgICAgICAge2lkOidhdWQnLCBuYW1lOiAnQVVEJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAgICB7aWQ6J25vaycsIG5hbWU6ICdOT0snLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICAgIHtpZDoncGxuJywgbmFtZTogJ1BMTicsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sXG4gICAgICAgICAge2lkOidwaHAnLCBuYW1lOiAnUEhQJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifV07XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcyA9ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5jb25jYXQoJHJvb3RTY29wZS4kc3RvcmFnZS5hZGRpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJUGFkKCkgfHwgaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgICBNb2JpbGVBY2Nlc3NpYmlsaXR5LmlzVm9pY2VPdmVyUnVubmluZyhmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJTY3JlZW4gcmVhZGVyOiBPTlwiKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBib29sO1xuICAgICAgICAgICAgICAvLyRpb25pY0NvbmZpZ1Byb3ZpZGVyLm5hdkJhci5hbGlnblRpdGxlKCdjZW50ZXInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNjcmVlbiByZWFkZXI6IE9GRlwiKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBib29sO1xuICAgICAgICAgICAgICAvLyRpb25pY0NvbmZpZ1Byb3ZpZGVyLm5hdkJhci5hbGlnblRpdGxlKCdsZWZ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uudmlldykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3ID0gJ2NvbXBhY3QnO1xuICAgIH1cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IFwidHJlbmRpbmdcIjtcbiAgICB9XG4gICAgaWYgKG5hdmlnYXRvci5zcGxhc2hzY3JlZW4pIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG5hdmlnYXRvci5zcGxhc2hzY3JlZW4uaGlkZSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgICRyb290U2NvcGUubG9nKFwiYXBwIHN0YXJ0IHJlYWR5XCIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSB0cnVlO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46Y2hlY2tcIik7XG4gICAgICB9XG4gICAgfSwgMTAwMCk7XG4gICAgJHJvb3RTY29wZS5zaG93QWxlcnQgPSBmdW5jdGlvbih0aXRsZSwgbXNnKSB7XG4gICAgICB2YXIgYWxlcnRQb3B1cCA9ICRpb25pY1BvcHVwLmFsZXJ0KHtcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZW1wbGF0ZTogbXNnXG4gICAgICB9KTtcbiAgICAgIGlmIChtc2cuaW5kZXhPZihcImVycm9yXCIpPi0xKSB7XG4gICAgICAgIC8vd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKFwiYnJvYWRjYXN0IGVycm9yXCIpO1xuICAgICAgICAvL30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsZXJ0UG9wdXAvKi50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnVGhhbmsgeW91IC4uLicpO1xuICAgICAgfSk7Ki9cbiAgICB9O1xuICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UgPSBmdW5jdGlvbih0aXRsZSwgbXNnKSB7XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgICAgJGNvcmRvdmFUb2FzdC5zaG93TG9uZ0JvdHRvbSh0aXRsZStcIjogXCIrbXNnKS50aGVuKGZ1bmN0aW9uKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwidG9hc3RcIitzdWNjZXNzKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInRvYXN0XCIrZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KHRpdGxlLCBtc2cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLiRvbignc2hvdzpsb2FkaW5nJywgZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgICAgJHJvb3RTY29wZS5sb2coJ3Nob3c6bG9hZGluZycpO1xuICAgICAgJGlvbmljTG9hZGluZy5zaG93KHtcbiAgICAgICAgbm9CYWNrZHJvcCA6IHRydWUsXG4gICAgICAgIHRlbXBsYXRlOiAnPGlvbi1zcGlubmVyIGljb249XCJyaXBwbGVcIiBjbGFzcz1cInNwaW5uZXItZW5lcmdpemVkXCI+PC9pb24tc3Bpbm5lcj4nXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLiRvbignaGlkZTpsb2FkaW5nJywgZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgICAgJHJvb3RTY29wZS5sb2coJ2hpZGU6bG9hZGluZycpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJGlvbmljTG9hZGluZy5oaWRlKCk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9KTtcblxuICAgICRyb290U2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdGFydCcsIGZ1bmN0aW9uKGV2ZW50LCB0b1N0YXRlLCB0b1BhcmFtcywgZnJvbVN0YXRlLCBmcm9tUGFyYW1zKXtcbiAgICAgICRyb290U2NvcGUubG9nKFwiZnJvbSBcIitmcm9tU3RhdGUubmFtZStcIiB0byBcIit0b1N0YXRlLm5hbWUpO1xuICAgIH0pO1xuXG4gICAgJGlvbmljUGxhdGZvcm0ub24oJ3Jlc3VtZScsIGZ1bmN0aW9uKCl7XG4gICAgICAkcm9vdFNjb3BlLmxvZyhcImFwcCByZXN1bWVcIik7XG4gICAgICB2YXIgc3RlZW1SUEMgPSByZXF1aXJlKFwic3RlZW0tcnBjXCIpO1xuICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic29ja2V0VXJsXCIpID09PSBudWxsKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic29ja2V0VXJsXCIsIFwid3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LkFwaSA9IHN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsfSwgdHJ1ZSk7XG4gICAgICAvL3dpbmRvdy5zdGVlbUpTID0gcmVxdWlyZShcInN0ZWVtanMtbGliXCIpO1xuICAgICAgLy93aW5kb3cuZ29sb3NKUyA9IHJlcXVpcmUoXCJnb2xvc2pzLWxpYlwiKTtcblxuICAgICAgLy9pZiAoIWFuZ3VsYXIuaXNEZWZpbmVkKCRyb290U2NvcGUudGltZWludCkpIHtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIkFwaSByZWFkeSBzdGF0ZSBjaGFuZ2U6IFwiK2FuZ3VsYXIudG9Kc29uKHJlc3BvbnNlKSk7XG4gICAgICAgICRyb290U2NvcGUudGltZWludCA9ICRpbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzXCIsIFtdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXMgXCIgKyByZXNwb25zZS5oZWFkX2Jsb2NrX251bWJlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDE1MDAwKTtcbiAgICAgIH0pO1xuICAgICAgLy99XG4gICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5vbk5vdGlmaWNhdGlvbk9wZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihkYXRhKSk7XG4gICAgICAgIGlmKGRhdGEudGFwKXtcbiAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgb24gZGV2aWNlIHRyYXkgYW5kIHRhcHBlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgICBpZiAoZGF0YS5hdXRob3IgJiYgZGF0YS5wZXJtbGluaykge1xuICAgICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcblxuICAgICAgICAgICAgICB2YXIgYWxlcnRQb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhLmJvZHkgKyAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnT1BFTklOR19QT1NUJylcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgYWxlcnRQb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdUaGFuayB5b3UgZm9yIHNlZWluZyBhbGVydCBmcm9tIHRyYXknKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6ZGF0YS5hdXRob3IsIHBlcm1saW5rOmRhdGEucGVybWxpbmt9KTtcbiAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJub3Qgc3VyZSB0byBvcGVuIGFsZXJ0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZEYXRhID0ge3RpdGxlOmRhdGEudGl0bGUsIGJvZHk6IGRhdGEuYm9keSwgYXV0aG9yOiBkYXRhLmF1dGhvciwgcGVybWxpbms6IGRhdGEucGVybWxpbmt9O1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBpbiBmb3JlZ3JvdW5kLiBNYXliZSB0aGUgdXNlciBuZWVkcyB0byBiZSBub3RpZmllZC5cbiAgICAgICAgICAvL2FsZXJ0KCBKU09OLnN0cmluZ2lmeShkYXRhKSApO1xuICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keStcIiBcIitkYXRhLnBlcm1saW5rKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH0pOyovXG5cbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcbiAgICAgICAgJHJvb3RTY29wZS5waW5jaGVjayA9IHRydWU7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpjaGVja1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lQYWQoKSB8fCBpb25pYy5QbGF0Zm9ybS5pc0lPUygpKSB7XG5cbiAgICAgICAgICBNb2JpbGVBY2Nlc3NpYmlsaXR5LmlzVm9pY2VPdmVyUnVubmluZyhmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICBpZiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiU2NyZWVuIHJlYWRlcjogT05cIik7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBib29sO1xuICAgICAgICAgICAgICAgIC8vJGlvbmljQ29uZmlnUHJvdmlkZXIubmF2QmFyLmFsaWduVGl0bGUoJ2NlbnRlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNjcmVlbiByZWFkZXI6IE9GRlwiKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnZvaWNlT3ZlciA9IGJvb2w7XG4gICAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnbGVmdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICAkaW9uaWNQbGF0Zm9ybS5vbigncGF1c2UnLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5sb2coXCJhcHAgcGF1c2VcIik7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS50aW1laW50KSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImNhbmNlbCBpbnRlcnZhbFwiKTtcbiAgICAgICAgJGludGVydmFsLmNhbmNlbCgkcm9vdFNjb3BlLnRpbWVpbnQpO1xuICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdpbmRvdy5BcGkuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICRpb25pY1BsYXRmb3JtLm9uKCdvZmZsaW5lJywgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUubG9nKFwiYXBwIG9mZmxpbmVcIik7XG4gICAgfSk7XG5cbiAgICAkcm9vdFNjb3BlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSBcIlwiO1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5hZGQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9IFwiXCI7XG4gICAgICBpZigkcm9vdFNjb3BlLnBhc3Njb2RlLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9ICRyb290U2NvcGUucGFzc2NvZGUgKyB2YWx1ZTtcbiAgICAgICAgaWYoJHJvb3RTY29wZS5wYXNzY29kZS5sZW5ndGggPT0gNCkge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJQSU4gXCIrJHJvb3RTY29wZS5wYXNzY29kZSk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50eXBlID09IDMpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9PSAkcm9vdFNjb3BlLnBhc3Njb2RlKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGludHJ5ICs9IDE7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT1RfTUFUQ0gnKStcIihcIiskcm9vdFNjb3BlLnBpbnRyeStcIilcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50cnk+Mykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50cnkgPSAwO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwicGluOmZhaWxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuY2xvc2VQaW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnR5cGUgPT0gMCkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInR5cGUgMDogc2V0IHBpblwiKTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpjaGVja1wiKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmNsb3NlUGluKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID0gJHJvb3RTY29wZS5wYXNzY29kZTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTkZJUk1fUElOJyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50eXBlID0gMztcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbnRyeSA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInR5cGUgMTogY2hlY2sgcGluXCIpO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlID09ICRyb290U2NvcGUucGFzc2NvZGUpe1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncGluOmNvcnJlY3QnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBhc3Njb2RlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmNsb3NlUGluKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50cnkgKz0gMTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVycm9yID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0lOQ09SUkVDVCcpK1wiKFwiKyRyb290U2NvcGUucGludHJ5K1wiKVwiO1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLnBpbnRyeT4zKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLiRyZXNldCgpO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLnBpbmVycm9yID0gXCJcIjtcbiAgICAgIGlmKCRyb290U2NvcGUucGFzc2NvZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAkcm9vdFNjb3BlLnBhc3Njb2RlID0gJHJvb3RTY29wZS5wYXNzY29kZS5zdWJzdHJpbmcoMCwgJHJvb3RTY29wZS5wYXNzY29kZS5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9waW5jb2RlLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHJvb3RTY29wZVxuICAgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAgICRyb290U2NvcGUucGlubW9kYWwgPSBtb2RhbDtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLmNsb3NlUGluID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLnBpbm1vZGFsLmhpZGUoKTtcbiAgICAgIGlmICgkcm9vdFNjb3BlLnBpbmVuYWJsZWQpIHtcbiAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZEYXRhKSB7XG4gICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgIHRpdGxlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS50aXRsZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS5ib2R5ICsgJGZpbHRlcigndHJhbnNsYXRlJykoJ09QRU5JTkdfUE9TVCcpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWxlcnRQb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSBmb3Igc2VlaW5nIGFsZXJ0IGZyb20gdHJheScpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6JHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEuYXV0aG9yLCBwZXJtbGluazokcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YS5wZXJtbGlua30pO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgJHJvb3RTY29wZS5vcGVuUGluID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICBpZiAodHlwZSA9PSAwKSB7XG4gICAgICAgICRyb290U2NvcGUucGludHlwZSA9IDA7XG4gICAgICAgICRyb290U2NvcGUucGludGl0bGUgPSAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1BJTicpO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9QSU4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09IDEpIHtcbiAgICAgICAgJHJvb3RTY29wZS5waW50eXBlID0gMTtcbiAgICAgICAgJHJvb3RTY29wZS5waW50cnkgPSAwO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0VOVEVSX1BJTicpO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnN1YnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ0VOVEVSX1BJTicpO1xuICAgICAgfVxuICAgICAgJHJvb3RTY29wZS5waW5tb2RhbC5zaG93KCk7XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLiRvbihcInBpbjpuZXdcIiwgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSBmYWxzZTtcbiAgICAgICRyb290U2NvcGUub3BlblBpbigwKTtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLiRvbihcInBpbjpjaGVja1wiLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5waW5jaGVjayA9IHRydWU7XG4gICAgICAkcm9vdFNjb3BlLm9wZW5QaW4oMSk7XG4gICAgfSk7XG5cblxuICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL2luZm8uaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkcm9vdFNjb3BlXG4gICAgICAvL2FuaW1hdGlvbjogXCJudWxsXCJcbiAgICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAkcm9vdFNjb3BlLmluZm9tb2RhbCA9IG1vZGFsO1xuICAgIH0pO1xuICAgICRyb290U2NvcGUub3BlbkluZm8gPSBmdW5jdGlvbih4eCkge1xuICAgICAgaWYgKHh4LmFjdGl2ZV92b3Rlcy5sZW5ndGg9PTApIHtcbiAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjdGl2ZV92b3Rlc1wiLCBbeHguYXV0aG9yLCB4eC5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24oZGQpe1xuICAgICAgICAgIHh4LmFjdGl2ZV92b3RlcyA9IGRkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgICRyb290U2NvcGUudm90ZXJzID0geHg7XG4gICAgICAkcm9vdFNjb3BlLmluZm9tb2RhbC5zaG93KCk7XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuY2xvc2VJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLmluZm9tb2RhbC5oaWRlKCk7XG4gICAgICAvLyRyb290U2NvcGUuaW5mb21vZGFsLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBdD1mdW5jdGlvbihpbmRleCwgY2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnN0cigwLCBpbmRleCkgKyBjaGFyYWN0ZXIgKyB0aGlzLnN1YnN0cihpbmRleCtjaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICB9XG5cdFx0JHJvb3RTY29wZS5vcGVuRHJhZnQgPSBmdW5jdGlvbihpdGVtKXtcblx0XHRcdGl0ZW0ub3BlcmF0aW9uX3R5cGUgPSBpdGVtLnBvc3RfdHlwZTtcblx0XHRcdCRyb290U2NvcGUuJHN0b3JhZ2Uuc3Bvc3QgPSBpdGVtO1xuXHRcdFx0JHN0YXRlLmdvKCdhcHAucG9zdHMnKTtcblx0XHRcdCRyb290U2NvcGUuJGJyb2FkY2FzdCgnb3BlblBvc3RNb2RhbCcpO1xuXHRcdH1cbiAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuID0gZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2NvbnRlbnRcIiwgW2l0ZW0uYXV0aG9yLCBpdGVtLnBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgIHZhciBfbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IF9sZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHJlc3VsdC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICB2YXIgaXRlbSA9IHJlc3VsdDtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gaXRlbTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8kc3RhdGUuZ28oJ2FwcC5wb3N0Jyk7XG4gICAgICAgICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0Jywge2NhdGVnb3J5OiBpdGVtLmNhdGVnb3J5LCBhdXRob3I6IGl0ZW0uYXV0aG9yLCBwZXJtbGluazogaXRlbS5wZXJtbGlua30pO1xuXG4gICAgICAgICAgfSwgNSk7XG5cbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLnJlQmxvZyA9IGZ1bmN0aW9uKGF1dGhvciwgcGVybWxpbmspIHtcbiAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRUJMT0dfVEVYVCcpXG4gICAgICB9KTtcbiAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRyb290U2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIganNvbjtcblxuICAgICAgICAgICAgICAgIGpzb24gPSBbXCJyZWJsb2dcIix7YWNjb3VudDokcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIGF1dGhvcjphdXRob3IsIHBlcm1saW5rOnBlcm1saW5rfV07XG5cbiAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjdXN0b21fanNvblwiLCB7XG4gICAgICAgICAgICAgICAgICBpZDogJ2ZvbGxvdycsXG4gICAgICAgICAgICAgICAgICByZXF1aXJlZF9wb3N0aW5nX2F1dGhzOiBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXSxcbiAgICAgICAgICAgICAgICAgIGpzb246IEpTT04uc3RyaW5naWZ5KGpzb24pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRyb290U2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVCTE9HX1RFWFQnKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8kc2NvcGUucmVmcmVzaEZvbGxvd2VycygpO1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRUJMT0dHRURfUE9TVCcpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgICRyb290U2NvcGUudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0LCB0eXBlLCBhZnRlcndhcmQpIHtcbiAgICAgIHBvc3QuaW52b3RpbmcgPSB0cnVlO1xuICAgICAgdmFyIHR0ID0gMTtcbiAgICAgIGlmICh0eXBlID09PSBcInVwdm90ZVwiKSB7XG4gICAgICAgIHR0ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcImRvd252b3RlXCIpIHtcbiAgICAgICAgdHQgPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcInVudm90ZVwiKSB7XG4gICAgICAgIHR0ID0gMDtcbiAgICAgIH1cbiAgICAgICRyb290U2NvcGUubG9nKCd2b3RpbmcgJyt0dCk7XG4gICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIkFwaSByZWFkeTpcIiArIGFuZ3VsYXIudG9Kc29uKHJlc3BvbnNlKSk7XG4gICAgICAgICAgdmFyIG15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgIG15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpO1xuICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSBteWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJ2b3RlXCIsIHtcbiAgICAgICAgICAgICAgICB2b3RlcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcjogcG9zdC5hdXRob3IsXG4gICAgICAgICAgICAgICAgcGVybWxpbms6IHBvc3QucGVybWxpbmssXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQqdHQgfHwgMTAwMDAqdHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24obXlsb2dpbiwgbnVsbCwgdHJ1ZSk7ICBcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcG9zdC5pbnZvdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR0PjApe1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zdC51cHZvdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHR0PDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc3QuZG93bnZvdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zdC51cHZvdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3N0LmRvd252b3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXJ3YXJkID09PSAnZmV0Y2hDb250ZW50Jykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KGFmdGVyd2FyZCwgeyBhbnk6IHthdXRob3I6IHBvc3QuYXV0aG9yLCBwZXJtbGluazogcG9zdC5wZXJtbGlua30gfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChhZnRlcndhcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuXG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgcG9zdC5pbnZvdGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICBwb3N0Lmludm90aW5nID0gZmFsc2U7XG4gICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLmlzV2l0bmVzc1ZvdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci53aXRuZXNzX3ZvdGVzLmluZGV4T2YoXCJnb29kLWthcm1hXCIpPi0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgJHJvb3RTY29wZS52b3RlV2l0bmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1ZPVEVfRk9SX1dJVE5FU1MnKStcIiBAZ29vZC1rYXJtYVwiXG4gICAgICAgIH0pO1xuICAgICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJhY3RpdmVcIl0pO1xuICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkcm9vdFNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfd2l0bmVzc192b3RlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICB3aXRuZXNzOiBcImdvb2Qta2FybWFcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuXG4gICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRyb290U2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8kc2NvcGUucmVmcmVzaEZvbGxvd2VycygpO1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVk9URURfRk9SX1dJVE5FU1MnKSsnIEBnb29kLWthcm1hJyk7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLmZvbGxvd2luZyA9IGZ1bmN0aW9uKHh4LCBtdHlwZSkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICRyb290U2NvcGUubG9nKHh4KTtcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICRyb290U2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHJvb3RTY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICB2YXIganNvbjtcbiAgICAgICAgICAgIGlmIChtdHlwZSA9PT0gXCJmb2xsb3dcIikge1xuICAgICAgICAgICAgICBqc29uID0gWydmb2xsb3cnLHtmb2xsb3dlcjokcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIGZvbGxvd2luZzp4eCwgd2hhdDogW1wiYmxvZ1wiXX1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAganNvbiA9IFsnZm9sbG93Jyx7Zm9sbG93ZXI6JHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBmb2xsb3dpbmc6eHgsIHdoYXQ6IFtdfV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImN1c3RvbV9qc29uXCIsIHtcbiAgICAgICAgICAgICAgaWQ6ICdmb2xsb3cnLFxuICAgICAgICAgICAgICByZXF1aXJlZF9wb3N0aW5nX2F1dGhzOiBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXSxcbiAgICAgICAgICAgICAganNvbjogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHJvb3RTY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vJHNjb3BlLnJlZnJlc2hGb2xsb3dlcnMoKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2N1cnJlbnQ6cmVsb2FkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICB9XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZmVlZF9oaXN0b3J5XCIsIFtdKS50aGVuKGZ1bmN0aW9uKHIpe1xuICAgICAgICAvLyRyb290U2NvcGUubG9nKHIpO1xuICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYmFzZSA9IHIuY3VycmVudF9tZWRpYW5faGlzdG9yeS5iYXNlLnNwbGl0KFwiIFwiKVswXTtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllc1wiLCBbXSkudGhlbihmdW5jdGlvbihyKXtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKHIpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zdGVlbV9wZXJfbXZlc3RzID0gKE51bWJlcihyLnRvdGFsX3Zlc3RpbmdfZnVuZF9zdGVlbS5zdWJzdHJpbmcoMCwgci50b3RhbF92ZXN0aW5nX2Z1bmRfc3RlZW0ubGVuZ3RoIC0gNikpIC8gTnVtYmVyKHIudG90YWxfdmVzdGluZ19zaGFyZXMuc3Vic3RyaW5nKDAsIHIudG90YWxfdmVzdGluZ19zaGFyZXMubGVuZ3RoIC0gNikpKSAqIDFlNjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCAxMCk7XG4gICAgaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kb24oJ2NoYW5nZWRDaGFpbicsIGZ1bmN0aW9uKCl7XG4gICAgICBjb25zb2xlLmxvZygnY2hhaW4gZGlmZmVycycpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNvY2tldFVybCA9ICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXTtcbiAgICAgIHdpbmRvdy5lanMuQ2hhaW5Db25maWcuc2V0Q2hhaW5JZChsb2NhbFN0b3JhZ2VbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIklkXCJdKTtcbiAgICAgIHdpbmRvdy5BcGkuY2xvc2UoKTtcbiAgICAgIHdpbmRvdy5BcGkgPSB3aW5kb3cuc3RlZW1SUEMuQ2xpZW50LmdldCh7dXJsOiBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsfSwgdHJ1ZSk7XG4gICAgICBcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkgeyAgXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaCgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgIGlmICh2LmNoYWluID09ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIFxuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCJTdGVlbVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcIlN0ZWVtIFBvd2VyXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhciA9IFwiU3RlZW0gRG9sbGFyXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCA9IFwiU0JEXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0ID0gXCJTVEVFTVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldHN0ZWVtID0gXCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1uYW1lID0gXCLQk9Ce0JvQntChXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwi0KHQmNCb0JAg0JPQntCb0J7QodCQXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwi0JPQvtC70L7RgVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyID0gXCLQl9Ce0JvQntCi0J7QmVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQgPSBcIkdCR1wiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcHVuaXQgPSBcIkdPTE9TUFwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQgPSBcIkdPTE9TXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0Z29sb3MgPSBcIndzczovL3dzLmdvbG9zLmlvL1wiO1xuICAgICAgICAvLyRzY29wZS5zb2NrZXQgPSBcIndzczovL2dvbG9zLnN0ZWVtLndzXCI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY2hlY2tEYXRlKGRhdGUsIGlnbm9yZSkge1xuICAgICAgdmFyIGVvbGQgPSA4NjQwMDAwMDsgLy8xICogMjQgKiA2MCAqIDYwICogMTAwMDsgLy8xIGRheSBvbGRcbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBvbGQgPSBuZXcgRGF0ZShkYXRlKS5nZXRUaW1lKCk7XG4gICAgICByZXR1cm4gaWdub3JlfHxub3ctb2xkPj1lb2xkO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRvbignY2hhbmdlZEN1cnJlbmN5JywgZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgICAgdmFyIHh4ID0gYXJncy5jdXJyZW5jeTtcbiAgICAgIHZhciBpZ25vcmUgPSBhcmdzLmVuZm9yY2U7XG4gICAgICBjb25zb2xlLmxvZyh4eCk7XG4gICAgICB2YXIgcmVzdWx0T2JqZWN0ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jaWVzLmZpbHRlcihmdW5jdGlvbiAoIG9iaiApIHtcbiAgICAgICAgICByZXR1cm4gb2JqLmlkID09PSB4eDtcbiAgICAgIH0pWzBdO1xuICAgICAgLy9zZWFyY2hPYmooeHgsICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcyk7XG4gICAgICBpZiAoY2hlY2tEYXRlKHJlc3VsdE9iamVjdC5kYXRlLCBpZ25vcmUpKSB7XG4gICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdzdGVlbScpe1xuICAgICAgICAgIEFQSXMuZ2V0Q3VycmVuY3lSYXRlKFwiVVNEXCIsIHh4ICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgPSBOdW1iZXIocmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLlJhdGUpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jaWVzLmZpbHRlcihmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgICBpZiAob2JqLmlkID09IHh4KSB7XG4gICAgICAgICAgICAgICAgb2JqLnJhdGUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICBvYmouZGF0ZSA9IHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5EYXRlPT09XCJOL0FcIj9uZXcgRGF0ZSgpIDogcmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLkRhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFQSXMuZ2V0Q3VycmVuY3lSYXRlKFwiWEFVXCIsIHh4ICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgLy9YQVUgLSAzMS4xMDM0NzY4Z1xuICAgICAgICAgICAgLy9HQkcgcmF0ZSBpbiBtZy4gc28gZXhjaGFuZ2VSYXRlLzMxMTAzLjQ3NjhcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gTnVtYmVyKHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5SYXRlKS8zMTEwMy40NzY4O1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jaWVzLmZpbHRlcihmdW5jdGlvbihvYmope1xuICAgICAgICAgICAgICBpZiAob2JqLmlkID09IHh4KSB7XG4gICAgICAgICAgICAgICAgb2JqLnJhdGUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICBvYmouZGF0ZSA9IHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5EYXRlPT09XCJOL0FcIj9uZXcgRGF0ZSgpIDogcmVzLmRhdGEucXVlcnkucmVzdWx0cy5yYXRlLkRhdGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gcmVzdWx0T2JqZWN0LnJhdGU7XG4gICAgICB9XG4gICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzV2luZG93c1Bob25lKCkpIHtcbiAgICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzSU9TKCkgfHwgaW9uaWMuUGxhdGZvcm0uaXNJUGFkKCkpIHtcbiAgICAgICAgICAvL3dpbmRvdy5GaXJlYmFzZVBsdWdpbi5ncmFudFBlcm1pc3Npb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qd2luZG93LkZpcmViYXNlUGx1Z2luLmdldFRva2VuKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAvLyBzYXZlIHRoaXMgc2VydmVyLXNpZGUgYW5kIHVzZSBpdCB0byBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2VcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiZGV2aWNlIFwiK3Rva2VuKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQgPSB0b2tlbjtcbiAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgQVBJcy5zYXZlU3Vic2NyaXB0aW9uKHRva2VuLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIHsgZGV2aWNlOiBpb25pYy5QbGF0Zm9ybS5wbGF0Zm9ybSgpIH0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBBUElzLnNhdmVTdWJzY3JpcHRpb24odG9rZW4sIFwiXCIsIHsgZGV2aWNlOiBpb25pYy5QbGF0Zm9ybS5wbGF0Zm9ybSgpIH0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7Ki9cblxuICAgICAgICBGQ01QbHVnaW4uZ2V0VG9rZW4oZnVuY3Rpb24odG9rZW4pe1xuICAgICAgICAgIC8vIHNhdmUgdGhpcyBzZXJ2ZXItc2lkZSBhbmQgdXNlIGl0IHRvIHB1c2ggbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZVxuICAgICAgICAgICRyb290U2NvcGUubG9nKFwiZGV2aWNlIFwiK3Rva2VuKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkID0gdG9rZW47XG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgQVBJcy5zYXZlU3Vic2NyaXB0aW9uKHRva2VuLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIHsgZGV2aWNlOiBpb25pYy5QbGF0Zm9ybS5wbGF0Zm9ybSgpIH0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQVBJcy5zYXZlU3Vic2NyaXB0aW9uKHRva2VuLCBcIlwiLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5vblRva2VuUmVmcmVzaChmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgIEFQSXMudXBkYXRlVG9rZW4oJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCwgdG9rZW4pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcykpO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCA9IHRva2VuICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7Ki9cbiAgICAgICAgRkNNUGx1Z2luLm9uVG9rZW5SZWZyZXNoKGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgICAgICBBUElzLnVwZGF0ZVRva2VuKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQsIHRva2VuKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQgPSB0b2tlbiAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qd2luZG93LkZpcmViYXNlUGx1Z2luLm9uTm90aWZpY2F0aW9uT3BlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihkYXRhKSk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuXG4gICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucy5wdXNoKHt0aXRsZTpkYXRhLnRpdGxlLCBtZXNzYWdlOiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rLCBjcmVhdGVkOiBuZXcgRGF0ZSgpfSk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEudGFwKXtcbiAgICAgICAgICAgICAgLy9Ob3RpZmljYXRpb24gd2FzIHJlY2VpdmVkIG9uIGRldmljZSB0cmF5IGFuZCB0YXBwZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhLmJvZHkgKyAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnT1BFTklOR19QT1NUJylcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBhbGVydFBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdUaGFuayB5b3UgZm9yIHNlZWluZyBhbGVydCBmcm9tIHRyYXknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6ZGF0YS5hdXRob3IsIHBlcm1saW5rOmRhdGEucGVybWxpbmt9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJub3Qgc3VyZSB0byBvcGVuIGFsZXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHt0aXRsZTpkYXRhLnRpdGxlLCBib2R5OiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rfTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBpbiBmb3JlZ3JvdW5kLiBNYXliZSB0aGUgdXNlciBuZWVkcyB0byBiZSBub3RpZmllZC5cbiAgICAgICAgICAgICAgLy9hbGVydCggSlNPTi5zdHJpbmdpZnkoZGF0YSkgKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keStcIiBcIitkYXRhLnBlcm1saW5rKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgKi9cblxuICAgICAgICAvL0ZDTVBsdWdpbi5vbk5vdGlmaWNhdGlvbiggb25Ob3RpZmljYXRpb25DYWxsYmFjayhkYXRhKSwgc3VjY2Vzc0NhbGxiYWNrKG1zZyksIGVycm9yQ2FsbGJhY2soZXJyKSApXG4gICAgICAgIC8vSGVyZSB5b3UgZGVmaW5lIHlvdXIgYXBwbGljYXRpb24gYmVoYXZpb3VyIGJhc2VkIG9uIHRoZSBub3RpZmljYXRpb24gZGF0YS5cbiAgICAgICAgRkNNUGx1Z2luLm9uTm90aWZpY2F0aW9uKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKGRhdGEpKTtcblxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhbmd1bGFyLnRvSnNvbihkYXRhKSk7XG5cbiAgICAgICAgICAgIC8vJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZmljYXRpb25zLnB1c2goe3RpdGxlOmRhdGEudGl0bGUsIG1lc3NhZ2U6IGRhdGEuYm9keSwgYXV0aG9yOiBkYXRhLmF1dGhvciwgcGVybWxpbms6IGRhdGEucGVybWxpbmssIGNyZWF0ZWQ6IG5ldyBEYXRlKCl9KTtcblxuICAgICAgICAgICAgaWYoZGF0YS53YXNUYXBwZWQpe1xuICAgICAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgb24gZGV2aWNlIHRyYXkgYW5kIHRhcHBlZCBieSB0aGUgdXNlci5cbiAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuXG4gICAgICAgICAgICAgICAgICB2YXIgYWxlcnRQb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRhdGEuYm9keSArICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdPUEVOSU5HX1BPU1QnKVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGFsZXJ0UG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSBmb3Igc2VlaW5nIGFsZXJ0IGZyb20gdHJheScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2hhaW4gIT09ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPSBkYXRhLmNoYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ2hhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZEN1cnJlbmN5Jywge2N1cnJlbmN5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5LCBlbmZvcmNlOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmdldENvbnRlbnRBbmRPcGVuKHthdXRob3I6ZGF0YS5hdXRob3IsIHBlcm1saW5rOmRhdGEucGVybWxpbmt9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJub3Qgc3VyZSB0byBvcGVuIGFsZXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHt0aXRsZTpkYXRhLnRpdGxlLCBib2R5OiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rfTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBpbiBmb3JlZ3JvdW5kLiBNYXliZSB0aGUgdXNlciBuZWVkcyB0byBiZSBub3RpZmllZC5cbiAgICAgICAgICAgICAgLy9hbGVydCggSlNPTi5zdHJpbmdpZnkoZGF0YSkgKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keStcIiBcIitkYXRhLnBlcm1saW5rKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKGRhdGEudGl0bGUsIGRhdGEuYm9keSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSk7XG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9wb3N0cy9pbmRleC5qc1wiLFwiL3Bvc3RzXCIpIiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCLYp9mE2LXZgdit2Kkg2KfZhNix2KbZitiz2YrYqVwiLFxuXHRcIkxPR0lOXCI6IFwi2KrYs9is2YrZhCDYp9mE2K/YrtmI2YRcIixcblx0XCJMT0dPVVRcIjogXCLYqtiz2KzZitmEINin2YTYrtix2YjYrFwiLFxuXHRcIlBST0ZJTEVcIjogXCLYp9mE2LXZgdit2Kkg2KfZhNi02K7YtdmK2KlcIixcblx0XCJGT0xMT1dcIjogXCLYqtin2KjYuVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcItmF2KTYtNix2KfYqlwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi2KrYrdmI2YrZhFwiLFxuXHRcIk1BUktFVFwiOiBcItin2YTYs9mI2YJcIixcblx0XCJTRVRUSU5HU1wiOiBcItil2LnYr9in2K/Yp9iqXCIsXG5cdFwiQUJPVVRcIjogXCLYudmGXCIsXG5cdFwiQUJPVVRfMVwiOiBcItit2YrYqyDZitiz2KrYt9mK2Lkg2KfZiiDYtNiu2LUg2KfZhNit2LXZiNmEINi52YTZiiDZhdmD2KfZgdim2KfYqiDZhdmC2KfYqNmEINin2YTZhdit2KrZiNmKINin2YTYrtin2LUg2KjZh1wiLFxuXHRcIkFCT1VUXzJcIjogXCLZhdiv2LnZiNmFINmF2YYgeyB9INmF2YbYtdipLiBcIixcblx0XCJBQk9VVF8zXCI6IFwi2YjZh9mIINmF2YHYqtmI2K0g2KfZhNmF2LXYr9ix2Iwg2LDYp9iqINiq2LXZhdmK2YUg2KXYrNiq2YXYp9i52Yog2YXYtdmF2YUg2YTZhNmH2YjYp9iq2YEg2KfZhNmG2YLYp9mE2KkuINmIINmK2YjZgdixINin2YTZiNi12YjZhCDYpdmE2Ykg2KfZhNmF2K3YqtmI2Ykg2YTZhNmC2LHYp9ih2KnYjCDYp9mE2KrYudmE2YrZgtiMINmI2KfZhNiq2LXZiNmK2KrYjCDZiNin2YTYqtiv2YjZitmG2Iwg2YbZgtmEINin2YTYo9ix2KjYp9it2Iwg2KXZhNiuINin2YTZhdmK2LLYp9iqINin2YTYqtmKINiq2KrZitit2YfYpyDYs9mE2LPZhNipINin2YTZg9iq2YQge3twbGF0Zm9ybW5hbWV9fSDZiCB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcItmE2KdcIixcblx0XCJBQk9VVF81XCI6IFwiMi4g2KfZhNiq2LfYqNmK2YIg2YrZiNmB2LEg2YbZhdmI2LDYrCDYo9mF2YYg2YXZhtit2KfYsiDZhNmE2LnZhdmK2YTYjCDZhdi5INin2YTZhdmB2KfYqtmK2K0g2KfZhNiu2KfYtdipINil2LPYqti22KfZgdiqINmF2K3ZhNmK2Kcg2Ygg2YTZhiDYqtix2LPZhCDYo9io2K/YpyDYpdmE2Ykg2KPZitipINiu2YjYp9iv2YUuXCIsXG5cdFwiQUJPVVRfNlwiOiBcItmK2YLYr9mFINin2YTYqti32KjZitmCINmI2KfYrNmH2KfYqiDYp9mE2YXYs9iq2K7Yr9mFINio2LPZiti32KnYjCDYrNiw2KfYqNipINmI2KrYqNin2K/ZhCDYp9mE2K7YqNix2KfYqiBcIixcblx0XCJBQk9VVF83XCI6IFwi2YTYpyDZiti32YTYqCDYp9mE2KrYt9io2YrZgiDZhdmGINin2YTZhdiz2KrYrtiv2YXZitmGINin2K/Yrtin2YQg2YXYudmE2YjZhdin2KrZh9mFINin2YTYtNiu2LXZitipXCIsXG5cdFwiQUJPVVRfOFwiOiBcIti12YjYqiDZhCBnb29kLWthcm1hINmD2LTYp9mH2K9cIixcblx0XCJBQk9VVF85XCI6IFwi2YTZhNiq2YjYp9i12YQvINmF2YTYp9it2LjYp9iqXCIsXG5cdFwiQUJPVVRfMTBcIjogXCLZhNmE2YXYstmK2K8g2YXZhiDYp9mE2YXYudmE2YjZhdin2KpcIixcblx0XCJSRU1PVkVcIjogXCLYrdiw2YFcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIti52LHYtiDYp9mE2LPZiNmCXCIsXG5cdFwiUFJJQ0VcIjogXCLYp9mE2LPYudixXCIsXG5cdFwiQU1PVU5UXCI6IFwi2YPZhdmK2KlcIixcblx0XCJUT1RBTFwiOiBcItmF2KzZhdmI2LlcIixcblx0XCJOT09SREVSU1wiOiBcItmE2Kcg2KrZiNis2K8g2LfZhNio2KfYqlwiLFxuXHRcIkRBVEVcIjogXCLYp9mE2KrYp9ix2YrYrlwiLFxuXHRcIkJVWVwiOiBcIti02LHYp9ihXCIsXG5cdFwiU0VMTFwiOiBcItio2YrYuVwiLFxuXHRcIk9QRU5cIjogXCLZhdmB2KrZiNitXCIsXG5cdFwiSElTVE9SWVwiOiBcItin2YTYqtin2LHZitiuXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLZhdiq2KfYqNi52KlcIixcblx0XCJGT0xMT1dFRFwiOiBcItin2YTZhdiq2KfYqNi52KlcIixcblx0XCJVTkZPTExPV1wiOiBcItin2YTYutin2KEg2KfZhNmF2KrYp9io2LnYqVwiLFxuXHRcIkZPTExPV0lOR1wiOiBcItiq2YUg2KfZhNmF2KrYp9io2LnYqVwiLFxuXHRcIkZPTExPV0VSU1wiOiBcItmF2KrYp9io2LnZiNmGXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcItin2KjYrdirINmB2Yog2KfZhNmF2KrYp9io2LnZiNmGXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcItin2KjYrdirINmB2Yog2KfZhNmF2KrYqNi52YjZhlwiLFxuXHRcIkJZXCI6IFwi2KjZiNin2LPYt9ipXCIsXG5cdFwiSU5cIjogXCLZgdmJXCIsXG5cdFwiTUVOVVwiOiBcItin2YTZgtin2KbZhdipXCIsXG5cdFwiQk9PS01BUktcIjogXCLYp9mE2YXZgdi22YTYqVwiLFxuXHRcIlJFQkxPR1wiOiBcIti02KfYsdmDXCIsXG5cdFwiVVBWT1RFXCI6IFwi2KfZhNiq2LXZiNmK2Kog2YTZhNij2LnZhNmKXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLYp9mE2KrYtdmI2YrYqiDZhNmE2KPYs9mB2YRcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwi2YTYp9iz2KrYsdis2KfYuSDYp9mE2KrYtdmI2YrYqiDZhNmE2KPYs9mB2YRcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcItmE2KfYs9iq2LHYrNin2Lkg2KfZhNiq2LXZiNmK2Kog2YTZhNij2LnZhNmKXCIsXG5cdFwiUkVQTFlcIjogXCLZhNmE2KrYudmE2YrZglwiLFxuXHRcIkVESVRcIjogXCLYqti52K/ZitmEXCIsXG5cdFwiUE9TVF8xXCI6IFwi2KXYs9it2Kgg2KfZhNiq2LnZhNmK2YLYp9iqINmE2YTZitiz2KfYsSDZhNmF2LTYp9mH2K/YqSDYp9mE2K7Zitin2LHYp9iqXCIsXG5cdFwiUE9TVF8yXCI6IFwi2KfYtti62Lcg2LnZhNmJINiq2LnZhNmK2YLYp9iqINmE2YXYtNin2YfYr9ipINin2YTYqti52YTZitmC2KfYqiDYp9mE2YHYsdi52YrYqVwiLFxuXHRcIk9QVElPTlNcIjogXCLYp9mE2K7Zitin2LHYp9iqXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi2KrZhdiqINmF2LTYp9ix2YPYqtmHINmF2YZcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLZhNinINmK2YjYrNivINi02KYg2YfZhtinINit2KrZiSDYp9mE2KfZhlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwi2KfZhNit2LPYp9io2KfYqlwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX3YjCDYp9mE2LHZhdmI2LIg2KfZhNmC2KfYqNmE2Kkg2YTZhNiq2K/Yp9mI2YQg2KfZhNiq2Yog2YrZhdmD2YYg2YbZgtmE2YfYpyDZgdmKINij2Yog2YjZgtiqLiDZiNmK2YXZg9mGINiq2K3ZiNmK2YTZh9inIHt7cGxhdGZvcm1uYW1lfX0g2KXZhNmJIHt7cGxhdGZvcm1wb3dlcn19INmB2Yog2LnZhdmE2YrYqSDYqtiz2YXZiSDYsdmB2Lkg2KfZhNi32KfZgtipLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn192Iwg2LHZhdmI2LIg2KfZhNiq2KPYq9mK2LEg2KfZhNmF2YXZitiy2Kkg2KfZhNiq2Yog2KrZg9iz2Kgg2KfZhNmF2LLZitivINmF2YYg2KfZhNiz2YTYt9ipINmE2LnZgtivINi32YjZitmEINin2YTYo9is2YTYjCDZiNin2YTYqti12YjZitiqINi52YTZiSDYp9mE2YXZiNin2LbZiti5LiDZg9mE2YXYpyDYp9mE2YXYsdihINmK2K3ZhdmEINij2YPYq9ixINmD2YTZhdinINmK2KPYq9ixINij2YPYq9ixINi52YTZiSDZhdmD2KfZgdii2Kog2KfZhNii2K7YsdmK2YYg2Ygg2YrZg9iz2Kgg2YXZg9in2YHYotiqINmE2YTYqti12YjZitiq2KfYqiDYr9mC2YrZgtipLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcItin2YTYudmF2YTYp9iqINin2YTYsdmF2LLZitipINiq2LXZhCDZgtmK2YXYqtmH2Kcg2KXZhNmJINit2YjYp9mE2Yoge3twbGF0Zm9ybXN1bml0fX0ge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLYp9mE2YLZitmF2Ycg2KfZhNmF2KrZiNmC2LnZh1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcItin2YTZgtmK2YXZhyDYp9mE2YXYqtmI2YLYudmHINiq2LPYqtmG2K/YudmE2Ykg2YXYqtmI2LPYtyDZgtmK2YXYqTcg2KPZitin2YVcIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi2KrYp9ix2YrYriDYp9mE2KrYrdmI2YrZhNin2KpcIixcblx0XCJQT1NUSU5HXCI6IFwi2KXYsdiz2KfZhFwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcItmF2YHYqtin2K0g2KfZhNmG2LTYsSDZitiz2KrYrtiv2YUg2YTZhNmG2LTYsSDZiCDYp9mE2KrYtdmI2YrYqi4g2YrZhtio2LrZiiDYo9mGINmK2YPZiNmGINmF2K7YqtmE2YEg2LnZhiDYp9mE2YXZgdin2KrZititINin2YTZhti02LfYqSDZiCDYp9mE2YXYp9mE2YMuXCIsXG5cdFwiT1dORVJcIjogXCLYp9mE2YXYp9mE2YNcIixcblx0XCJQUk9GSUxFXzZcIjogXCLZhdmB2KrYp9itINin2YTZhdin2YTZgyDZh9mIINin2YTZhdmB2KrYp9itINin2YTYsdim2YrYs9mKINmE2YTYrdiz2KfYqCDZiCDYp9mE2YXYt9mE2YjYqCDZhNiq2LrZitmK2LEg2YXZgdin2KrZititINij2K7YsdmJLiDYp9mE2YXZgdiq2KfYrSDYp9mE2K7Yp9i1INij2Ygg2YPZhNmF2Kkg2YXYsdmI2LEg2YTZhdmB2KrYp9itINmF2KfZhNmDINmK2YbYqNi62Yog2KPZhiDYqti42YQg2K/ZiNmGINin2KrYtdin2YQg2YLYr9ixINin2YTYpdmF2YPYp9mGLlwiLFxuXHRcIkFDVElWRVwiOiBcItmG2LTYt1wiLFxuXHRcIlBST0ZJTEVfN1wiOiBcItmK2KrZhSDYp9iz2KrYrtiv2KfZhSDYp9mE2YXZgdiq2KfYrSDYp9mE2YbYtNi3INmE2KrYrdmI2YrZhCDYp9mE2KPZhdmI2KfZhCDZiNmI2LbYuSDYp9mE2KPZiNin2YXYsSDZgdmKINin2YTYs9mI2YIg2KfZhNiv2KfYrtmE2YrYqS5cIixcblx0XCJNRU1PXCI6IFwi2YXZgdmD2LHZh1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcItmF2YHYqtin2K0g2KfZhNmF2LDZg9ix2Kkg2YrYs9iq2K7Yr9mFINmE2KXZhti02KfYoSDZiCDZgtix2KfYodipINin2YTZhdiw2YPYsdin2KouXCIsXG5cdFwiQkxPR1wiOiBcItmF2K/ZiNmG2YdcIixcblx0XCJQT1NUU1wiOiBcItin2YTZhdmI2KfYttmK2LlcIixcblx0XCJSRVBMSUVTXCI6IFwi2KfZhNix2K/ZiNivXCIsXG5cdFwiV0FMTEVUXCI6IFwi2KfZhNmF2K3Zgdi42YdcIixcblx0XCJUQUdcIjogXCLYtNin2LHYqVwiLFxuXHRcIlVTRVJcIjogXCLYp9mE2YXYs9iq2K7Yr9mFXCIsXG5cdFwiQ0xPU0VcIjogXCLYpdi62YTYp9mCXCIsXG5cdFwiVE9cIjogXCLYpdmE2YlcIixcblx0XCJBU1NFVFwiOiBcItmF2YTZg9mK2YdcIixcblx0XCJTRU5EXCI6IFwi2KXYsdiz2KfZhFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi2KfZhNij2YXYp9mGXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi2YXYqtin2K1cIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcItmF2YHZg9ix2KnYudin2YXZh1wiLFxuXHRcIlRPX0RFU0NcIjogXCLYp9mE2YXYs9iq2K7Yr9mFINmF2KvZhNinIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcItin2YTYsdmC2YUg2KfZhNiz2LHZilwiLFxuXHRcIlBJTl9URVhUXCI6IFwi2YrYs9in2LnYr9mDINix2YXYsiBQSU4g2YTYqtij2YXZitmGINin2YTYqti32KjZitmCINmI2KfZhNio2YrYp9mG2KfYqiDYp9mE2K7Yp9i12Kkg2KjZgy4gPGJyLz4gPGJyLz4gPGI+2YXZhNin2K3YuNipOjwvYj4g2KjZhdis2LHYryDYp9mE2KrZhdmD2YrZhtiMINmE2K/ZitmDINmD2K3YryDYo9mC2LXZiSA0INmF2K3Yp9mI2YTYp9iqINmE2YTZgdiq2K3YjCDYpdiw2Kcg2YPZhtiqINmC2K8g2YbYs9mK2Kog2LHZgtmFIHBpbiDYo9mIINiq2YHYtNmE2Iwg2LPZitiq2YUg2KXYstin2YTYqSDYqNmK2KfZhtin2Kog2KrYs9is2YrZhCDYp9mE2YXYs9iq2K7Yr9mFINmF2YYg2KfZhNiq2LfYqNmK2YIuINmK2YXZg9mG2YMg2KXYudin2K/YqSDYp9mE2K/YrtmI2YQg2YjYp9mE2KfYs9iq2YXYsdin2LEg2YHZiiDYp9iz2KrYrtiv2KfZhSDYp9mE2KrYt9io2YrZgi5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi2KfZhNil2LTYudin2LHYp9iqXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi2LPZiNmBINiq2K3YtdmEINi52YTZiSDYpdi02LnYp9ixINi52YbYr9mF2Kcg2LTYrti1INmF2Kcg2LXZiNiqINmE2YTZhdit2KrZiNmJINin2YTYrtin2LUg2KjZgyEgPGJyLz4gPC9iPtmF2YTYp9it2LjYqTovYj4g2KrYtNmF2YQg2KfZhNil2LTYudin2LHYp9iqINmI2LLZhiDYp9mE2KrYtdmI2YrYqtiMINmI2YPYsNmE2YMg2YHZiiDYsdiz2KfZhNipINin2YTYqtmG2KjZitmHLiAo2LPZiNin2KEg2YPYp9mGINin2YTYqti12YjZitiqINij2LnZhNmJ2Iwg2Ygg2KfZhNiq2LXZiNmK2Kog2YTZhNij2LPZgdmE2Iwg2YbYsti5INin2YTYqti12YjZitiqKS5cIixcblx0XCJWT1RFXCI6IFwi2LXZiNiqXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi2LPZiNmBINiq2K3YtdmEINi52YTZiSDYpdi02LnYp9ixINi52YbYr9mF2Kcg2LTYrti1INmF2Kcg2YrYudmE2YIg2LnZhNmJINin2YTZhdi02KfYsdmD2KfYqiDYo9mIINin2YTYqti52YTZitmC2KfYqiDYp9mE2K7Yp9i12Kkg2KjZgyEgPGJyLz4gPGI+2YXZhNin2K3YuNipOjwvYj4g2KrYtNmF2YQg2KfZhNil2LTYudin2LHYp9iqINi52YbYr9mF2Kcg2KfZhNij2LTYrtin2LUg2YrZgtmI2YXZiNinIDxiPtio2KrYudiv2YrZhDwvYj4g2KrYudmE2YrZgtin2KrZh9mFINmD2LDZhNmDLlwiLFxuXHRcIkNPTU1FTlRcIjogXCLYqti52YTZitmCXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLYs9mI2YEg2KrYs9iq2YLYqNmEINin2LTYudin2LEg2LnZhtiv2YXYpyDZitiq2KjYudmDINi02K7YtSDYo9mIINmK2YTYutmKINmF2KrYp9io2LnYqtmDIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwi2YXYsNmD2YjYsVwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLYs9mI2YEg2KrYs9iq2YLYqNmEINin2LTYudin2LEg2LnZhtiv2YXYpyDZitiw2YPYsSDYtNiu2LUg2YHZiiDYqti52YTZitmC2Ycv2YXZiNi22YjYudmHIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLYtNin2LHZg1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcItiz2YrYqtmFINil2LTYudin2LHZgyDYudmG2K/ZhdinINmK2KrZhSDZhdi02KfYsdmD2Kkg2YXZiNi22YjYudmDINmF2YYg2LfYsdmBINi02K7YtSDZhdinIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi2KfZhNi22KjYt1wiLFxuXHRcIlZPVElOR1wiOiBcItiq2LXZiNmK2KpcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcItmI2LLZhiDYp9mE2KrYtdmI2YrYqiDYo9mIINin2YTZhtiz2KjYqSDYp9mE2YXYptmI2YrYqSDZitik2KvYsdin2YYg2LnZhNmJINmC2YjYqSDYp9mE2KrYtdmI2YrYqiDZgdmKINin2YTYqti32KjZitmC2Iwg2K3ZitirINmK2YXZg9mG2YMg2KrZhti42YrZhSDZhdmD2KfZgdij2Kkg2KfZhNiq2LXZiNmK2Kog2KfZhNiu2KfYtSDYqNmDLiA8YnIvPiA8YnIvPiA8Yj7ZhdmE2KfYrdi42Kk6PC9iPiDYs9mK2KTYr9mKINiw2YTZgyDYpdmE2Ykg2KrYutmK2YrYsSDYp9mE2YjYstmGL9mG2LPYqNipINix2YHYtiDYqti12YjZitiqINmB2Yog2YPZhCDZhdmD2KfZhiDZgdmKINin2YTYqti32KjZitmCXCIsXG5cdFwiU0VSVkVSXCI6IFwi2K7Yp9iv2YVcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcItin2YTZhdix2LTYrVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItin2K3Zgdi4INin2YTYqti62YrZitix2KfYqlwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwi2YXYudmE2YjZhdin2Kog2LnZhiDYp9mE2YXYtdmI2KrZitmGXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwi2YXYsdit2KjYpyDYqNi52YjYr9iq2YNcIixcblx0XCJMT0dJTl8xXCI6IFwi2YLZhSDYqNiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINio2KPYs9mFINin2YTZhdiz2KrYrtiv2YUg2YjZg9mE2YXYqSDYp9mE2LPYsSDZhNmE2KPYs9iq2YXYsdin2LFcIixcblx0XCJMT0dJTl8yXCI6IFwi2YrYs9iq2K7Yr9mFINmD2YjYryDYp9mE2KrYr9mI2YrZhiDZgdmKINin2YTZhti02LEg2YjYp9mE2KrYudmE2YrZgiDYudmE2Ykg2KfZhNmF2YjYp9i22YrYuSDZg9mF2Kcg2KPZhiDYo9mK2LbYpyDZitiz2KrYrtiv2YUg2KPZiti22Kcg2YTZhNiq2LXZiNmK2Kog2LnZhNmJINin2YTZhdmG2LTZiNix2KfYqiDZiNmF2KrYp9io2LnYqSDYp9mE2YXYr9mI2YbZitmGINin2YTZhdmB2LbZhNmK2YYuXCIsXG5cdFwiTE9HSU5fM1wiOiBcItmK2LPYqtiu2K/ZhSDZg9mI2K8g2KfZhNmB2LnYp9mEINmB2Yog2KXYsdiz2KfZhCDYp9mE2KPZhdmI2KfZhCDZiNiq2LrZitmK2LEg2KfZhNi12YjYsdipINin2YTYtNiu2LXZitipLlwiLFxuXHRcIkxPR0lOXzRcIjogXCLZitiq2YUg2KfZhNil2K3YqtmB2KfYuCDYqNio2YrYp9mG2KfYqiDYp9mE2YXYs9iq2K7Yr9mFINmF2K3ZhNmK2Kcg2LnZhNmJINin2YTYrNmH2KfYsi4g2KrYqtmFINil2LLYp9mE2Kkg2KfZhNio2YrYp9mG2KfYqiDYudmG2K8g2KrYs9is2YrZhCDYp9mE2K7YsdmI2KwhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi2YTYpyDYqtmF2YTZgyDYrdiz2KfYqFwiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwi2YLZhSDYqNin2YTYqtiz2KzZitmEINin2YTYp9mGXCIsXG5cdFwiQ0FOQ0VMXCI6IFwi2KXZhNi62KfYoVwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi2YXYqtmC2K/ZhVwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLZg9mI2K8g2KfZhNmB2LnYp9mEINin2YTYrtin2LVcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcItmG2LTYsSDYp9mE2YXZgdiq2KfYrSDYp9mE2K7Yp9i1XCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCLZg9mE2YXYqSDYp9mE2YXYsdmI2LEg2KfZhNix2KbZitiz2YrYqVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwi2KfYs9mFINin2YTZhdiz2KrYrtiv2YVcIixcblx0XCJDQVJEX1ZJRVdcIjogXCLYudix2LYg2KfZhNio2LfYp9mC2KlcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLYqNit2KtcIixcblx0XCJTRUFSQ0hcIjogXCLYp9mE2KjYrdirXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCLYp9iv2K7Yp9mEINin2YTZhdi02KfYsdmD2KlcIixcblx0XCJSRVBMWVRPXCI6IFwi2KfZg9iq2Kgg2LHYs9in2YTYqVwiLFxuXHRcIlBPU1RcIjogXCLYo9mG2LTYsVwiLFxuXHRcIlBSRVZJRVdcIjogXCLYudix2LYg2YXYs9io2YJcIixcblx0XCJERUZBVUxUXCI6IFwi2KfZhNin2YHYqtix2KfYttmKIDUwJS81MCVcIixcblx0XCJQT1dFUlVQXCI6IFwi2LHZgdi5INin2YTYt9in2YLYqSAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLYsdmB2LYg2K/Zgdi5INin2YTYqti52YjZiti22KfYqlwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi2KfYrdmB2Lgg2YTZiNmC2Kog2YTYp9it2YJcIixcblx0XCJDTEVBUlwiOiBcItmI2KfYttitXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi2YXYrdiq2YjZiSDYp9mE2KrYr9mI2YrZhtmK2KkgXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi2YXYrdiq2YjZiSDYp9mE2KrYudmE2YrZglwiLFxuXHRcIlRJVExFXCI6IFwi2LnZhtmI2KfZhlwiLFxuXHRcIlRBR1NcIjogXCLYtNin2LHYp9iqXCIsXG5cdFwiTk9UX01BVENIXCI6IFwi2LrZitixINmF2KrYt9in2KjZglwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi2KPZg9ivINin2YTYsdmF2LIg2KfZhNiz2LHZilwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIti62YrYsSDYtdit2YrYrVwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcItiq2K/ZiNmK2YbZitipINmF2YHYqtmI2K3YqSBcIixcblx0XCJTRVRfUElOXCI6IFwi2KzYr9ivINin2YTYsdmF2LIg2KfZhNiz2LHZilwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcItin2K/YrtmEINin2YTYsdmF2LJcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLZh9mEINij2YbYqiDZiNin2KvZgtifXCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLYsdmK2LPYqtmK2YUg2YTYpyDYsdis2LnYqSDZgdmK2YfYjCDZh9mEINiq2LHZitivINin2YTZhdiq2KfYqNi52KlcIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLYrti32KPYjCDYp9mE2YXYsdis2Ygg2KfZhNmF2K3Yp9mI2YTYqSDZhdix2Kkg2KPYrtix2YkhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcItmF2YjZgdmCXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLYqtiv2YjZitmG2Kkg2YXYtNin2LHZg9ipIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLZgdi02YQg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQhINin2YTYsdis2KfYoSDYp9mE2KrYo9mD2K8g2KXZhiDZg9mG2Kog2YLYryDZgtmF2Kog2KjYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNin2LPYqtiu2K/Yp9mFINmD2YTZhdipINmF2LHZiNix2YMg2KfZhNix2KbZitiz2YrYqSDYo9mIINiq2YjZgdmK2LEg2YPZiNivINin2YTZhti02LEg2KfZhNiu2KfYtSDYudmE2Ykg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KXYsNinINil2K7Yqtix2Kog2KfZhNmI2LbYuSDYp9mE2YXYqtmC2K/ZhS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLZgdi02YQg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQhINin2YTYsdis2KfYoSDYp9mE2KrYo9mD2K8g2KXZhiDZg9mG2Kog2YLYryDZgtmF2Kog2KjYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNin2LPYqtiu2K/Yp9mFINmD2YTZhdipINmF2LHZiNixINix2KbZitiz2YrYqSDYo9mIINiq2YjZgdmK2LEg2YPZiNivINin2YTZhti02LEg2KfZhNiu2KfYtSDYudmE2Ykg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KXYsNinINil2K7Yqtix2Kog2KfZhNmI2LbYuSDYp9mE2YXYqtmC2K/ZhS5cIixcblx0XCJXQVJOSU5HXCI6IFwi2KrYrdiw2YrYsVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLYp9mE2KrYtdmI2YrYqiDZhNmE2LTYp9mH2K9cIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcItiq2YUg2KfZhNiq2LXZiNmK2Kog2YTZhNi02KfZh9ivXCIsXG5cdFwiQUdPXCI6IFwi2YXZhtiwXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLZhdmGINin2YTYo9mGXCIsXG5cdFwiU0VDU1wiOiBcItir2YjYp9mG2YpcIixcblx0XCJBX01JTlwiOiBcItiv2YLZitmC2Kkg2YjYp9it2K/YqVwiLFxuXHRcIk1JTlNcIjogXCLYr9mC2KfYptmCXCIsXG5cdFwiQU5fSE9VUlwiOiBcItiz2KfYudipINmI2KfYrdiv2KlcIixcblx0XCJIT1VSU1wiOiBcItiz2KfYudin2KpcIixcblx0XCJBX0RBWVwiOiBcItmK2YjZhVwiLFxuXHRcIkRBWVNcIjogXCLYo9mK2KfZhVwiLFxuXHRcIkFfTU9OVEhcIjogXCLYtNmH2LFcIixcblx0XCJNT05USFNcIjogXCLYo9i02YfYsVwiLFxuXHRcIkFfWUVBUlwiOiBcItiz2YbYqVwiLFxuXHRcIllFQVJTXCI6IFwi2LPZhtmI2KfYqlwiLFxuXHRcIk1JTl9SRUFEXCI6IFwi2K/ZgtmK2YLYqSDZgtix2KfYodipXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIti12YjYqiDZhNmE2KPYs9mB2YQg2KPZiCDYudmE2YVcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCLYo9mE2KrZgti3INi12YjYsdipXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLYrdiv2ZDZkdivINi12YjYsdipINis2K/Zitiv2KlcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIti52YrZhiDYsdin2KjYtyDYrtin2LVcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcItij2K/YrtmEINi12YjYsdipXCIsXG5cdFwiRVJST1JcIjogXCLYrti32KNcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLYrti32KMg2YHZiiDYudmF2YTZitipINin2YTYsdmB2LlcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi2KPZhNi62YrYqiDYp9mE2YPYp9mF2YrYsdinXCIsXG5cdFwiU0VUX1VSTFwiOiBcItij2LbYqNi3INin2YTYsdin2KjYt1wiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLYsdin2KjYtyDZhdio2KfYtNixINmE2YTYtdmI2LHYqVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwi2KrZhSDYpdi22KfZgdipINin2YTYqti52YTZitmCIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi2YTYpyDZitmF2YPZhtmDINin2YTYsdis2YjYuSDYudmGINit2LDZgSDYp9mE2KrYudmE2YrZgtin2KouLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCLYo9it2LDZgSDYqti52YTZitmCXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLYrNin2LHZiiDYsdmB2Lkg2KfZhNi12YjYsdipXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcItiq2YUg2KfZhNix2YHYuSDYqNmG2KzYp9itXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcItmB2LTZhCDYudmF2YTZitipINin2YTYsdmB2LlcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLZitmI2KzYryDYrti32KfYoSDZgdmKINij2LPZhSDYp9mE2YXYs9iq2K7Yr9mFINij2Ygg2YPZhNmF2Kkg2KfZhNiz2LFcIixcblx0XCJJTkZPXCI6IFwi2YTZhNmF2LnZhNmI2YXYp9iqXCIsXG5cdFwiUVJfVEVYVFwiOiBcIti22Lkg2LHZhdiyINin2YTYp9iz2KrYrNin2KjYqSDYp9mE2LPYsdmK2LnYqSDYr9in2K7ZhCDZhdmG2LfZgtipINin2YTZhdiz2K0g2KfZhNi22YjYptmKXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi2KfZhNmF2LHYrNmIINin2YTYqtij2YPYryDZhdmGINin2YTYqtmI2YHYsSDYudmE2Ykg2LHYtdmK2K8g2YPYp9mB2Yog2YTYpdis2LHYp9ihINin2YTYudmF2YTZitipXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcItin2YTZhdiz2KrYrtiv2YUg2KfZhNiw2Yog2KrYrdin2YjZhCDYpdix2LPYp9mEINin2YTYsdi12YrYryDZhNmH2Iwg2LrZitixINmF2YjYrNmI2K8hXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcItmH2YQg2KPZhtiqINmF2KrYo9mD2K8g2YXZhiDYp9mE2KrYrdmI2YrZhCDYn1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcItiq2KPZg9mK2K9cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcItiq2YUg2KXYsdiz2KfZhCDYp9mE2LHYtdmK2K9cIixcblx0XCJGRUVEXCI6IFwi2KfZhNix2KbZitiz2YrZkdipIFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwi2LTYp9im2LlcIixcblx0XCJIT1RcIjogXCLYp9mE2LPYp9iu2YbYqVwiLFxuXHRcIk5FV1wiOiBcItis2K/ZitivXCIsXG5cdFwiUFJPTU9URURcIjogXCLZhdix2YjYrCDZhNmHXCIsXG5cdFwiVk9URVNcIjogXCLYudiv2K8g2KfZhNij2LXZiNin2KogXCIsXG5cdFwiUEFZT1VUXCI6IFwi2K/Zgdi5INin2YTYqti52YjZiti22KfYqlwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi2KfZhNiq2LnZhNmK2YLYp9iqXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCLZhdi02YfZiNixINmE2KvZhNin2KvZiNmGINmK2YjZhdinXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi2LHYqtioINin2YTZhdmI2KfYttmK2Lkg2KjYrdiz2KhcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLYr9mI2LHYqSDZhdi12LHZgdmK2KlcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi2KfZhNi52KfYptiv2KfYqiDYp9mE2YXYrdiq2YXZhNipXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLYp9mE2KrYudmI2YrYttin2Kog2KfZhNiz2KfYqNmC2KlcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwi2KrYudmI2YrYttin2Kog2KfZhNmD2KfYqtioIFwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIti52KfYptiv2KfYqiDYp9mE2KrZgtmK2YrZhVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi2KrZhSDYp9iv2K7Yp9mEINin2YTYqtiv2YjZitmG2YrYqSDYqNmG2KzYp9itXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcItij2YbYtNixINmE2KrZgtiv2YrZhdmH2Kcg2YTYp9it2YLYpyFcIixcblx0XCJTQVZFRFwiOiBcItiq2YUg2KfZhNit2YHYuFwiLFxuXHRcIkNMRUFSRURcIjogXCLYqtmFINin2YTZhdiz2K1cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwi2YjYtti5INi52YTYp9mF2KfYqiDYudmE2Ykg2YXZiNi22YjYuSDZitmF2YPZhiDYpdiy2KfZhNipINin2YTZhdmD2KfZgdii2Kog2YjYrNi52YQg2YfYsNmHINin2YTZhdmI2KfYryDYo9mC2YQg2LjZh9mI2LHYpyDZhNmE2LnZitin2YYuIDxicj48YnI+2KfZhNi52YTZhSDZitmG2KjYutmKINij2YYg2KrYs9iq2K7Yr9mFINmE2YXYpyDZitmE2Yo6IDx1bD48bGk+2KfZhNi62LQg2KPZiCDYp9mE2KfZhtiq2K3Yp9mEPC9saT4gPGxpPtiu2LfYp9ioINin2YTZg9ix2KfZh9mK2Kkg2KPZiCDYp9mE2KrYtdmK2K88L2xpPiA8bGk+2LPZiNihINin2YTYqti12YbZitmBINin2YTZhdiq2LnZhdivINmE2YTZhdit2KrZiNmJINij2Ygg2KfZhNix2LPYp9im2YQg2KfZhNmF2LLYudis2Kk8L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi2KrZhSDYp9mE2YjYtdmI2YQg2YTYo9mC2LXZiiDYrdivINmE2YTYt9mE2KjYp9iqLiDYp9mB2K3YtSDYtNin2KbYuS/YtNin2LHYqSDYo9iu2LHZiiFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLYqtmFINit2LDZgSDYp9mE2YXZiNi22YjYuSDZhdmGINin2YTZhdmB2LbZhNipIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLYqtmFINin2LbYp9mB2Kkg2KfZhNmF2YjYttmI2Lkg2YTZhNmF2YHYttmE2KkhXCIsXG5cdFwiUkVTRVRcIjogXCLYp9mE2YjYtti5INin2YTYs9in2KjZglwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi2KrYrdiv2YrYqyDYp9mE2LXZiNix2Kkg2KfZhNi02K7YtdmK2KlcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItiq2K3Yr9mK2Ksg2LXZiNix2Kkg2KfZhNi62YTYp9mBXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi2KfZhNix2KzYp9ihINiq2YLYr9mK2YUg2KfZhNmF2YHYqtin2K0g2KfZhNiu2KfYtSDYp9mE2YbYtNi3INil2LDYpyDZgtmF2Kog2KjYpdiu2KrZitin2LEg2YjYtti52YrYqSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYp9mE2YXYqtmC2K/ZhdipIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcItiw2YTZgyDYs9mI2YEg2KjYudmK2K8g2KfZhNi12YjYsdipINin2YTYtNiu2LXZitipINmE2YTZiNi22Lkg2KfZhNiz2KfYqNmCXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi2LDZhNmDINiz2YjZgSDYqNi52YrYryDYtdmI2LHYqSDYp9mE2LrZhNin2YEg2YTZhNmI2LbYuSDYp9mE2LPYp9io2YJcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcItmE2KrYrdiv2YrYqyDYp9mE2LPZitix2YHYsSDZitmG2KjYutmKINin2LnYp9iv2Kkg2KfZhNiq2LTYutmK2YQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcItiq2YUg2KrYrdiv2YrYqyDYp9mE2LbYqNi3XCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi2KfZhNmE2LrYp9iqXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLZhdmGINmH2YbYpyDZitmF2YPZhtmDINiq2LrZitixINmE2LrYqSDYp9mE2KrYt9io2YrZglwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLYqtiq2LfZhNioINmH2LDZhyDYp9mE2LnZhdmE2YrYqSDYp9mE2YXYs9iq2K7Yr9mFINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINio2YPZhNmF2Kkg2KfZhNmF2LHZiNixINin2YTYsdim2YrYs9mK2KnYjCDZhdmB2KrYp9itINmG2LTYty/Yp9mE2YbYtNixLiDYp9mE2LHYrNin2KEg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2YjYp9mE2YXYrdin2YjZhNipINmF2LHYqSDYo9iu2LHZiS5cIixcblx0XCJHQUxMRVJZXCI6IFwi2KfZhNi12YjYsVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcItin2YTZgtin2KbZhdmI2YYg2LnZhNmKINin2YTYqtix2KzZhdipXCIsXG5cdFwiU0hBUkVcIjogXCLZhdi02KfYsdmD2KlcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcItin2YTYs9mI2YJcIixcblx0XCJFWENIQU5HRVwiOiBcItiq2KjYp9iv2YRcIixcblx0XCJEUkFGVFNcIjogXCLZhdiz2YjYr9in2KpcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLYqtmFINit2LDZgSDYp9mE2YXZiNi22YjYuSDZhdmGINin2YTZhdiz2YjYr9in2KohXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcItiq2YUg2KXYttin2YHYqSDYp9mE2YXZiNi22YjYuSDZhNmE2YXYs9mI2K/Yp9iqIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLYpdiz2K3YqCDZhNmE2YrYs9in2LEg2YTZhdi02KfZh9iv2Kkg2KfZhNiu2YrYp9ix2KfYqlwiLFxuXHRcIk1BTkFHRVwiOiBcItil2K/Yp9ix2KkgXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcItiq2YUg2YXYs9itINin2YTYtdmI2LHYqVwiLFxuXHRcIkNPUFlcIjogXCLYo9mG2LPYrlwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi2YTZhSDYqtmC2YUg2KjYqtit2YXZitmEINij2Yog2LXZiNix2KkhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLYpdiz2K3YqCDYo9iz2YHZhCDZhNmE2KrYrdiv2YrYq1wiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLYqti32KjZitmC2KfYqiDYpdi22KfZgdmK2KlcIixcblx0XCJQTFVHSU5TXCI6IFwi2KXYttin2YHYp9iqXCIsXG5cdFwiU1VHR0VTVFwiOiBcItin2YLYqtix2KfYrdin2KpcIixcblx0XCJDT01JTkdfU09PTlwiOiBcItmC2LHZitio2KdcIixcblx0XCJDSEFJTlwiOiBcItiz2YTYs9mE2KlcIixcblx0XCJDSEFJTl9URVhUXCI6IFwi2YfZhtinINmK2YXZg9mG2YMg2KrYutmK2YrYsSDYp9mE2YXZhti12Kkg2KfZhNin2YHYqtix2KfYttmK2Kkg2KPZiCDYs9mE2LPZhNipINin2YTZg9iq2YQuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLYp9mE2LnZhdmE2KlcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi2YfZhtinINmK2YXZg9mG2YMg2KrYutmK2YrYsSDYp9mE2LnZhdmE2Kkg2KfZhNin2YHYqtix2KfYttmK2Kkg2KfZhNiu2KfYtdipINio2YMuINiz2KrYtNin2YfYryDZgtmK2YXYqSDYp9mE2YXZg9in2YHYo9ipINin2YTZhdmI2LbZiNi5L9in2YTYqti52YTZitmCINio2YfYsNmHINin2YTYudmF2YTYqS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxiPjxicj7Zgtin2KbZhdipINin2YTZhdmK2LLYp9iqPGJyPjwvYj4tINmK2YXZg9mG2YMg2KfZhNiv2K7ZiNmEINil2YTZiSDYp9mE2YXZgtin2YTYp9iqINmB2Yog2KPZiiDZhdmI2LbZiNi5INiq2LHYutioINmB2Yog2YLYsdin2KHYqtmHLjxicj4tINin2YTYqtmB2KfYudmEINmF2Lkg2KfZhNmF2KTZhNmB2YrZhiDZhdmGINiu2YTYp9mEINin2YTYqti52YTZitmCINmI2YXZhtin2YLYtNipINin2YTZhdmI2LbZiNi52KfYqi48YnI+LSDYp9mE2KrYtdmI2YrYqiDYudmE2Ykg2KfZhNmF2LTYp9ix2YPYp9iqINmE2YXZg9in2YHYo9ipINin2YTZhdik2YTZgSDZgdi22YTYpyDYudmGINmD2LPYqCDZhdmD2KfZgdij2Kkg2KfZhNiq2KPZhNmK2YEuPGJyPi0g2YbYtNixINmF2YLYp9mE2KfYqtmD2Iwg2KfZhNiq2K/ZiNmK2YYg2YjYp9iz2KrYttin2YHYqSDZhNmH2YUg2YXYrNin2YbYpyDZiNmD2LPYqCDYp9mE2YXZg9in2YHYotiqINmF2YYg2K7ZhNin2YQg2KXYtNix2KfZgyDZiNmD2LPYqCDZhdiq2KfYqNi52YrZhi48YnI+LSDZg9iq2KfYqNipINmF2YLYp9mE2KfYqiDYudmE2Ykg2KfZhNiw2YfYp9io2Iwg2YjYrdmB2Lgg2YXYs9mI2K/Yp9iqINmF2KrYudiv2K/YqSDZhdmGINmI2LjZitmB2Kkg2YTZhti02LEg2YHZiiDZiNmC2Kog2YTYp9it2YIuPGJyPi0g2YrZhdmD2YbZgyDZiNi22Lkg2KXYtNin2LHYqSDZhdix2KzYudmK2Kkg2LnZhNmJINmF2YLYp9mE2KfYqtmDINin2YTZhdmB2LbZhNipINmE2YLYsdin2KHYqtmH2Kcg2YTYp9it2YLYpy48YnI+LSDZitmF2YPZhtmDINiq2KjYp9iv2YQg2KPYsdio2KfYrdmDINij2Ygg2YbZgtmI2K/Zh9inLjxicj4tINil2LHYs9in2YQg2KPZhdmI2KfZhNmDINil2YTZiSDYo9mKINmF2KTZhNmB2YrZhiDYo9mIINmF2LPYqtiu2K/ZhdmK2YYg2KPZiCDYo9i12K/Zgtin2KEg2KPZiCDZhdiq2KfYqNi52YrZhiDYo9mIINi62YrYsdmH2YUgPGJyPi0g2YXYqtin2KjYudipINin2YTZhdik2YTZgdmK2YYg2KfZhNmF2KvZitix2YrZhiDZiNin2YTZhdiv2YjZhtmK2YYuIDxicj4gLSDYp9io2K3YqyDYudmGINmF2KrYp9io2LnZitmDINmI2YXYpNmE2YHZitmDINin2YTYsNmK2YYg2KrYqtin2KjYudmH2YUuPGJyPi0g2KfYrdi12YQg2LnZhNmJINil2LTYudin2LHYp9iqINmE2YTYqNmC2KfYoSDYudmE2Ykg2KfYqti12KfZhCDZhdi5INmF2KrYp9io2LnZitmDINmI2YXZhtin2YLYtNin2KrZgyDYp9mE2KrZiiDYqti02KfYsdmDINmB2YrZh9inLjxicj4tINin2KjYrdirINi52YYg2LnZhNin2YXYp9iqINmF2KvZitix2Kkg2YTZhNin2YfYqtmF2KfZhSAvINmB2KbYp9iqINin2YTZhdmC2KfZhNin2Kog2YjYp9mE2YXYpNmE2YHZitmGLjxicj4tINiq2K7YtdmK2LUg2YXZhNmB2YMg2KfZhNi02K7YtdmKLjxicj4tINin2YTZhdiy2YrYryDZhdmGINin2YTZhdmK2LLYp9iqINin2YTZgtin2K/ZhdipLjxiPjxicj48YnI+INin2YTYo9mF2KfZhjxicj48L2I+LiDYp9mE2KrYt9io2YrZgiDZhNinINmK2YXZg9mG2Ycg2KfZhNmI2LXZiNmEINij2Ygg2KfZhNiq2YXYs9mDINio2KPZhdmI2KfZhCDYp9mE2YXYs9iq2K7Yr9mFLjxicj4uINmK2YLYr9mFINin2YTYqti32KjZitmCINmG2YXZiNiw2Kwg2KPZhdin2YYg2YXZhiDYrNin2YbYqCDYp9mE2LnZhdmK2YTYjCDZhdi5INin2LPYqti22KfZgdipINmF2YHYp9iq2YrYrSDYrtin2LXYqSDZhdit2YTZitinINmI2LnYr9mFINil2LHYs9in2YTZh9inINmF2LfZhNmC2Kcg2KXZhNmJINij2Yog2K7ZiNin2K/ZhdiMINmB2KPZhtiqINmF2LPYpNmI2YQg2LnZhiDYp9mE2KfYrdiq2YHYp9i4INio2YbYs9iu2Kkg2KfYrdiq2YrYp9i32YrYqSDZhdmGINmD2YTZhdin2Kog2KfZhNmF2LHZiNixLjxicj4uINin2YTYqti32KjZitmCINmK2YjZgdixINmI2KfYrNmH2KfYqiDYp9mE2YXYs9iq2K7Yr9mFINio2LPZiti32Kkg2YjYrNiw2KfYqNipINmIINiq2KzYp9ix2Kg8YnI+LiDZitmI2YHYsSDYp9mE2KrYt9io2YrZgiDYt9io2YLYqSDYpdi22KfZgdmK2Kkg2YXZhiDYp9mE2KPZhdin2YYg2YXYuSDYsdmF2LIg2KfZhNij2YXYp9mGPGJyPjxicj7Ypdiz2KrZitmFINmK2K/YudmFINmG2LjYp9mF2Yog2LPYqtmK2YUg2Ygg2LrZiNmE2YjYsy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcItin2YTZhdik2LPYsyDZiNin2YTZhdi32YjYsSDYp9mE2LHYptmK2LPZilwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwi2KXYttin2YHYqSDYrdiz2KfYqFwiLFxuXHRcIlBMQVRGT1JNXCI6IFwi2KfZhNmF2YbYtdipXCIsXG5cdFwiRVNDUk9XXCI6IFwi2KfZhNi22YXYp9mGXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwi2YjZg9mK2YQg2KfZhNi22YXYp9mGXCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwi2KfZhNmF2YjYudivINin2YTZhtmH2KfYptmKINmE2YTZhdi12KfYr9mC2KlcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcItin2YbYqtmH2KfYoSDYtdmE2KfYrdmK2Kkg2KfZhNi22YXYp9mGXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcItix2LPZiNmFINin2YTYttmF2KfZhlwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIti02LHZiNi3INin2YTYttmF2KfZhlwiLFxuXHRcIk5JR0hUX01PREVcIjogXCLYp9mE2YjYtti5INin2YTZhNmK2YTZilwiLFxuXHRcIkRBWV9NT0RFXCI6IFwi2KfZhNmI2LbYuSDYp9mE2YrZiNmF2YpcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCLYudix2LYg2KfZhNmF2K3YqtmI2Ykg2KfZhNmD2KfZhdmEXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcItin2YTZhdiz2KrYrtiv2YUg2LrZitixINmF2YjYrNmI2K9cIixcblx0XCJBUFBST1ZFXCI6IFwi2YXZiNin2YHZgtipXCIsXG5cdFwiRElTUFVURVwiOiBcItin2YTYrtmE2KfZgVwiLFxuXHRcIlJFTEVBU0VcIjogXCLYpdi12K/Yp9ixXCIsXG5cdFwiRlJPTVwiOiBcItmF2YZcIixcblx0XCJJRFwiOiBcItmF2LnYsdmBXCIsXG5cdFwiU1VCTUlUXCI6IFwi2KXZitiv2KfYuVwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwi2KfZhNmF2LPYqtmC2KjZhFwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwi2KfZhNi52YbZiNin2YZcIixcblx0XCJXRUJTSVRFXCI6IFwi2KfZhNmF2YjZgti5XCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwi2KXYs9mFINin2YTZhdiz2KrYrtiv2YVcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi0J3QsNGH0LDQu9C+XCIsXG5cdFwiTE9HSU5cIjogXCLQktGF0L7QtFwiLFxuXHRcIkxPR09VVFwiOiBcItCe0YLQv9C40YHQstCw0L3QtVwiLFxuXHRcIlBST0ZJTEVcIjogXCLQn9GA0L7RhNC40LtcIixcblx0XCJGT0xMT1dcIjogXCLQodC70LXQtNCy0LDQvdC1XCIsXG5cdFwiQk9PS01BUktTXCI6IFwi0JvRjtCx0LjQvNC4XCIsXG5cdFwiVFJBTlNGRVJcIjogXCLQotGA0LDQvdGB0YTQtdGAXCIsXG5cdFwiTUFSS0VUXCI6IFwi0J/QsNC30LDRgFwiLFxuXHRcIlNFVFRJTkdTXCI6IFwi0J3QsNGB0YLRgNC+0LnQutC4XCIsXG5cdFwiQUJPVVRcIjogXCLQl9CwINC/0YDQuNC70L7QttC10L3QuNC10YLQvlwiLFxuXHRcIkFCT1VUXzFcIjogXCLQktGB0LXQutC4INC80L7QttC1INC00LAg0L/QtdGH0LXQu9C4INC+0YIg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQvdCwINGB0YLQsNGC0LjQuCFcIixcblx0XCJBQk9VVF8yXCI6IFwi0LUg0YHQvtGG0LjQsNC70L3QsCDQvNGA0LXQttCwLCDQutC+0Y/RgtC+INCy0Lgg0LLRitC20LzQsNCz0YDQsNC20LTQsNCy0LAg0LfQsCDQv9GD0LHQu9C40LrQsNGG0LjQuCwg0LrQvtC80LXQvdGC0LDRgNC4INC4INC60YPRgNCw0YLQvtGA0YHRgtCy0L4uXCIsXG5cdFwiQUJPVVRfM1wiOiBcItC4INC1INC80L7QsdC40LvQvdC+INC/0YDQuNC70L7QttC10L3QuNC1INGBINC+0YLQstC+0YDQtdC9INC60L7QtC4g0JjQvNCw0YLQtSDRgdCy0L7QsdC+0LTQtdC9INC00L7RgdGC0YrQvyDQtNC+INGB0YrQtNGK0YDQttCw0L3QuNC1INC30LAg0YfQtdGC0LXQvdC1LCDQutC+0LzQtdC90YLQsNGA0LgsINCz0LvQsNGB0YPQstCw0L3QtSwg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSwg0YPQv9GA0LDQstC70LXQvdC40LUg0L3QsCDQv9GA0LjRhdC+0LTQuCDQt9CwINGC0YDQsNC90YHRhNC10YAg0Lgg0YIu0L0uINGE0YPQvdC60YbQuNC4LCDQv9GA0LXQtNC70LDQs9Cw0L3QuCDQvtGCIHt7cGxhdGZvcm1uYW1lfX0g0LHQu9C+0LrRh9C10LnQvdCwINC90LAge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC90Y/QvNCwINC00LjRgNC10LrRgtC10L0g0LTQvtGB0YLRitC/INC00L4g0YHRgNC10LTRgdGC0LLQsNGC0LAg0L3QsCDQv9C+0YLRgNC10LHQuNGC0LXQu9GPLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC/0YDQtdC00LvQsNCz0LAg0LzQvtC00LXQuyDQvdCwINGB0LjQs9GD0YDQvdC+0YHRgiDQt9CwINGB0YLRgNCw0L3QsCDQvdCwINC60LvQuNC10L3RgtCwLCDRgSDRh9Cw0YHRgtC90Lgg0LrQu9GO0YfQvtCy0LUsINGB0YrRhdGA0LDQvdC10L3QuCDRgdCw0LzQviDQstGK0LIg0LLQsNGI0LXRgtC+INGD0YHRgtGA0L7QudGB0YLQstC+INC4INC90LjQutC+0LPQsCDQvdC1INGB0LUg0LjQt9C/0YDQsNGJ0LDRgiDQtNC+INGB0YrRgNCy0YrRgNC4LlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC/0YDQtdC00LvQsNCz0LAg0L/RgNC+0YHRgiDQuCDQsNGC0YDQsNC60YLQuNCy0LXQvSDQv9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQuCDQuNC90YLQtdGA0YTQtdC50YEuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L3QuNC60L7Qs9CwINC90LUg0LjQt9C40YHQutCy0LAg0L7RgiDQv9C+0YLRgNC10LHQuNGC0LXQu9GP0YIg0LTQsCDQstGK0LLQtdC20LTQsCDQu9C40YfQvdC4INC00LDQvdC90LguXCIsXG5cdFwiQUJPVVRfOFwiOiBcItCT0LvQsNGB0YPQstCw0LnRgtC1INC30LAgZ29vZC1rYXJtYS5cIixcblx0XCJBQk9VVF85XCI6IFwi0JrQvtC90YLQsNC60YIg0Lgg0L7QsdGA0LDRgtC90LAg0LLRgNGK0LfQutCwOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi0J7RidC1INC40L3RhNC+0YDQvNCw0YbQuNGPXCIsXG5cdFwiUkVNT1ZFXCI6IFwi0J/RgNC10LzQsNGF0L3QuFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwi0JjQt9Cz0LvQtdC0INC90LAg0L/QsNC30LDRgNCwXCIsXG5cdFwiUFJJQ0VcIjogXCLQptC10L3QsFwiLFxuXHRcIkFNT1VOVFwiOiBcItCh0YPQvNCwXCIsXG5cdFwiVE9UQUxcIjogXCLQntCx0YnQvlwiLFxuXHRcIk5PT1JERVJTXCI6IFwi0J3Rj9C80LAg0L7RgtCy0L7RgNC10L3QuCDQt9Cw0Y/QstC60LhcIixcblx0XCJEQVRFXCI6IFwi0JTQsNGC0LBcIixcblx0XCJCVVlcIjogXCLQmtGD0L/QuFwiLFxuXHRcIlNFTExcIjogXCLQn9GA0L7QtNCw0LlcIixcblx0XCJPUEVOXCI6IFwi0J7RgtCy0L7RgNC4XCIsXG5cdFwiSElTVE9SWVwiOiBcItCY0YHRgtC+0YDQuNGPXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLQodC70LXQtNCy0LDQvdC1INC+0LHRgNCw0YLQvdC+XCIsXG5cdFwiRk9MTE9XRURcIjogXCLQodC70LXQtNCy0LDQvVwiLFxuXHRcIlVORk9MTE9XXCI6IFwi0KHQv9GA0LXRgtC1INGB0LvQtdC00LXQvdC10YLQvlwiLFxuXHRcIkZPTExPV0lOR1wiOiBcItCh0LvQtdC00LLQsNC90LVcIixcblx0XCJGT0xMT1dFUlNcIjogXCLQn9C+0YHQu9C10LTQvtCy0LDRgtC10LvQuFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLQotGK0YDRgdC4INC/0L7RgdC70LXQtNC+0LLQsNGC0LXQu9C4XCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcItCi0YrRgNGB0Lgg0YHQu9C10LTQstCw0L3QuFwiLFxuXHRcIkJZXCI6IFwi0L7RglwiLFxuXHRcIklOXCI6IFwi0LJcIixcblx0XCJNRU5VXCI6IFwi0JzQtdC90Y5cIixcblx0XCJCT09LTUFSS1wiOiBcItCb0Y7QsdC40LzQuFwiLFxuXHRcIlJFQkxPR1wiOiBcItCg0LXQsdC70L7Qs1wiLFxuXHRcIlVQVk9URVwiOiBcItCT0LvQsNGBXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLQndC10LPQsNGC0LjQstC10L0g0LPQu9Cw0YFcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwi0J7RgtC60LDQttC4INC90LXQs9Cw0YLQuNCy0L3QuNGPINCz0LvQsNGBXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLQntGC0LrQsNC20Lgg0LPQu9Cw0YHQsFwiLFxuXHRcIlJFUExZXCI6IFwi0J7RgtCz0L7QstC+0YBcIixcblx0XCJFRElUXCI6IFwi0KDQtdC00LDQutGC0LjRgNCw0L3QtVwiLFxuXHRcIlBPU1RfMVwiOiBcItCf0LvRitC30L3QtdGC0LUg0L3QsCDQu9GP0LLQviwg0LfQsCDQtNCwINCy0LjQtNC40YLQtSDQvtC/0YbQuNC40YLQtVwiLFxuXHRcIlBPU1RfMlwiOiBcItCY0LfQsdC10YDQtdGC0LUg0L3Rj9C60L7QuSDQutC+0LzQtdC90YLQsNGALCDQt9CwINC00LAg0LLQuNC00LjRgtC1INC/0L7QtC3QutC+0LzQtdC90YLQsNGA0Lgg0LrRitC8INGC0Y/RhS5cIixcblx0XCJPUFRJT05TXCI6IFwi0J3QsNGB0YLRgNC+0LnQutC4XCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi0J/RgNC10L/RgNCw0YLQtdC90L4g0L7RglwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcItCS0YHQtSDQvtGJ0LUg0L3QuNGJ0L4uLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcItCR0LDQu9Cw0L3RgdC4INC/0L4g0YHQvNC10YLQutCwXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSDQtSDRgNCw0LfQvNC10L3Rj9C10LzQsCDQutGA0LjQv9GC0L7QstCw0LvRg9GC0LAsINC60L7Rj9GC0L4g0LzQvtC20LUg0LTQsCDQsdGK0LTQtSDRgtGA0LDQvdGB0YTQtdGA0LjRgNCw0L3QsCDQstGK0LIg0LLRgdC10LrQuCDQtdC00LjQvSDQvNC+0LzQtdC90YIuIHt7cGxhdGZvcm1uYW1lfX0g0LzQvtC20LUg0LTQsCDQsdGK0LTQtSDQvtCx0YrRgNC90LDRgtCwINCyIHt7cGxhdGZvcm1wb3dlcn19INGH0YDQtdC3INC/0YDQvtGG0LXRgSDQvdCw0YDRh9C10L0g0JfQsNGF0YDQsNC90LLQsNC90LUuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0g0LLQu9C40Y/QtSDQstGK0YDRhdGDINC/0LXRh9Cw0LvQsdC40YLQtS4g0JrQvtC70LrQvtGC0L4g0L/QvtCy0LXRh9C1INC40LzQsCDQv9C+0YLRgNC10LHQuNGC0LXQu9GPLCDRgdC40YHRgtC10LzQsNGC0LAg0LPQviDQvdCw0LPRgNCw0LbQtNCw0LLQsCDQv9C+0LLQtdGH0LUg0LrQvtCz0LDRgtC+INCz0LvQsNGB0YPQstCwINC4INC/0YPQsdC70LjQutGD0LLQsC5cIixcblx0XCJQUk9GSUxFXzNcIjogXCLQntC60L7Qu9C+IHt7cGxhdGZvcm1zdW5pdH19INC90LAge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLQn9GA0LjQsdC70LjQt9C40YLQtdC70L3QsCDRgdGC0L7QudC90L7RgdGCXCIsXG5cdFwiUFJPRklMRV80XCI6IFwi0J/RgNC40LHQu9C40LfQuNGC0LXQu9C90LDRgtCwINGB0YLQvtC50L3QvtGB0YIg0YHQtSDQvtGG0LXQvdGP0LLQsCDQvdCwIDcg0LTQvdC4INC+0YIg0YHRgNC10LTQvdCwINGB0YLQvtC50L3QvtGB0YIg0L3QsCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCLQmNGB0YLQvtGA0LjRjyDQvdCwINGC0YDQsNC90LfQsNC60YbQuNC50YLQtVwiLFxuXHRcIlBPU1RJTkdcIjogXCLQn9GD0LHQu9C40LrRg9Cy0LDQvdC1XCIsXG5cdFwiUFJPRklMRV81XCI6IFwi0JrQu9GO0YfRitGCINC30LAg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDRgdC1INC40LfQv9C+0LvQt9Cy0LAg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1INC4INCz0LvQsNGB0YPQstCw0L3QtS4g0KLRgNGP0LHQstCwINC00LAg0LHRitC00LUg0YDQsNC30LvQuNGH0LXQvSDQvtGCINCQ0LrRgtC40LLQvdC40Y8g0Lgg0KHQvtCx0YHRgtCy0LXQvdC40Y8g0LrQu9GO0YcuXCIsXG5cdFwiT1dORVJcIjogXCLQodC+0LHRgdGC0LLQtdC90LjQulwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcItCh0L7QsdGB0YLQstC10L3QuNGP0YIg0LrQu9GO0Ycg0LUg0L7RgdC90L7QstC90LjRj9GCINC60LvRjtGHINC90LAg0L/RgNGE0LjQu9CwINC4INC1INC90LXQvtCx0YXQvtC00LjQvCDQt9CwINC/0YDQvtC80Y/QvdCwINC90LAg0LTRgNGD0LPQuNGC0LUg0LrQu9GO0YfQvtCy0LUuINCb0LjRh9C90LjRj9GCINC60LvRjtGHINC40LvQuCDQv9Cw0YDQvtC70LAg0LfQsCDQutC70Y7Rh9CwINC90LAg0YHQvtCx0YHRgtCy0LXQvdC40LrQsCDRgtGA0Y/QsdCy0LAg0YHQtSDRgdGK0YXRgNCw0L3Rj9Cy0LAg0L3QsCDRgdC40LPRg9GA0L3QviDQvNGP0YHRgtC+LlwiLFxuXHRcIkFDVElWRVwiOiBcItCQ0LrRgtC40LLQvdC4XCIsXG5cdFwiUFJPRklMRV83XCI6IFwi0JDQutGC0LjQstC90LjRj9GCINC60LvRjtGHINGB0LUg0LjQt9C/0L7Qu9C30LLQsCwg0LfQsCDRgtGA0LDQvdGB0YTQtdGA0Lgg0Lgg0LTQsNCy0LDQvdC1INC/0L7RgNGK0YfQutC4INCyINGA0LDQvNC60LjRgtC1INC90LAg0LLRitGC0YDQtdGI0L3QuNGPINC/0LDQt9Cw0YAuXCIsXG5cdFwiTUVNT1wiOiBcItCR0LXQu9C10LbQutCwXCIsXG5cdFwiUFJPRklMRV84XCI6IFwi0JrQu9GO0YfRitGCINC30LAg0LHQtdC70LXQttC60LAg0YHQtSDQuNC30L/QvtC70LfQstCwINC30LAg0YHRitC30LTQsNCy0LDQvdC1INC4INGH0LXRgtC10L3QtSDQvdCwINCx0LXQu9C10LbQutC4LlwiLFxuXHRcIkJMT0dcIjogXCLQkdC70L7Qs1wiLFxuXHRcIlBPU1RTXCI6IFwi0KHRgtCw0YLQuNC4XCIsXG5cdFwiUkVQTElFU1wiOiBcItCe0YLQs9C+0LLQvtGA0LhcIixcblx0XCJXQUxMRVRcIjogXCLQn9C+0YDRgtGE0LXQudC7XCIsXG5cdFwiVEFHXCI6IFwi0KLQsNCzXCIsXG5cdFwiVVNFUlwiOiBcItCf0L7RgtGA0LXQsdC40YLQtdC7XCIsXG5cdFwiQ0xPU0VcIjogXCLQl9Cw0YLQstCw0YDRj9C90LVcIixcblx0XCJUT1wiOiBcItCX0LBcIixcblx0XCJBU1NFVFwiOiBcItCQ0LrRgtC40LJcIixcblx0XCJTRU5EXCI6IFwi0J/RgNCw0YLQuFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi0KHQuNCz0YPRgNC90L7RgdGCXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi0J3QsNC70LjRh9C90L7RgdGCXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLQn9GD0LHQu9C40YfQvdCwINCx0LXQu9C10LbQutCwXCIsXG5cdFwiVE9fREVTQ1wiOiBcItCf0L7RgtGA0LXQsdC40YLQtdC7LCDQvdCw0L/RgNC40LzQtdGAIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcItCf0LjQvS3QutC+0LRcIixcblx0XCJQSU5fVEVYVFwiOiBcItCf0LjQvS3QutC+0LTRitGCINC+0LHQtdC30L7Qv9Cw0YHRj9Cy0LAg0LTQsNC90L3QuNGC0LUg0LLQuCDQsiDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L4uIDxici8+PGJyLz7QktC10LTQvdGK0LYg0LDQutGC0LjQstC40YDQsNC9LCDQuNC80LDRgtC1INGB0LDQvNC+IDQg0L7Qv9C40YLQsCDQt9CwINC00LAg0LPQviDQvtGC0LrQu9GO0YfQuNGC0LUsINCw0LrQviDRgdGC0LUg0LfQsNCx0YDQsNCy0LjQu9C4INGB0LLQvtGC0Y8g0L/QuNC9LdC60L7QtCDQuNC70Lgg0L3QtSDRgdGC0LUg0LPQviDQstGK0LLQtdC70Lgg0L/RgNCw0LLQuNC70L3Qviwg0LDQv9C70LjQutCw0YbQuNGP0YLQsCDRidC1INC/0YDQtdC80LDRhdC90LUg0LTQsNC90L3QuNGC0LUg0L3QsCDQv9C+0YLRgNC10LHQuNGC0LXQu9GPINC/0YDQuCDQstC70LjQt9Cw0L3QtS4g0JzQvtC20LXRgtC1INC/0L7QstGC0L7RgNC90L4g0LTQsCDQstC70LXQt9C90LXRgtC1INC4INC/0YDQvtC00YrQu9C20LjRgtC1INC00LAg0LjQt9C/0L7Qu9C30LLQsNGC0LUg0L/RgNC40LvQvtC20LXQvdC40LXRgtC+LlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLQmNC30LLQtdGB0YLQuNGPXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INCz0LvQsNGB0YPQstCwINC30LAg0LLQsNGI0LAg0YHRgtCw0YLQuNGPLiA8YnIvPtCj0LLQtdC00L7QvNC70LXQvdC40Y/RgtCwINCy0LrQu9GO0YfQstCw0YIg0KHQuNC70LAg0L3QsCDQs9C70LDRgSDQutCw0LrRgtC+INC4INC/0YDQtdC00YPQv9GA0LXQtNC40YLQtdC70L3QuCDRgdGK0L7QsdGJ0LXQvdC40Y8uXCIsXG5cdFwiVk9URVwiOiBcItCT0LvQsNGBXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INC60L7QvNC10L3RgtC40YDQsCDQstCw0YjQuNGC0LUg0L/Rg9Cx0LvQuNC60LDRhtC40Lgg0LjQu9C4INC60L7QvNC10L3RgtCw0YDQuCE8YnIvPiDQmNC30LLQtdGB0YLQuNGP0YLQsCDRgdGK0YnQviDQstC60LvRjtGH0LLQsNGCINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INGA0LXQtNCw0LrRgtC40YDQsCDRgdCy0L7QuNGC0LUg0LrQvtC80LXQvdGC0LDRgNC4LlwiLFxuXHRcIkNPTU1FTlRcIjogXCLQmtC+0LzQtdC90YLQsNGAXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLQqdC1INC/0L7Qu9GD0YfQuNGC0LUg0LjQt9Cy0LXRgdGC0LjQtSwg0LrQvtCz0LDRgtC+INC90Y/QutC+0Lkg0LLQuCDRgdC70LXQtNC4INC40LvQuCDRidC1INGB0L/RgNC1INC00LAg0LLQuCDRgdC70LXQtNC4IVwiLFxuXHRcIk1FTlRJT05TXCI6IFwi0KHQv9C+0LzQtdC90LDQstCw0L3QuNGPXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQstC4INGB0L/QvtC80LXQvdC1INCyINGB0LLQvtGPINC/0YPQsdC70LjQutCw0YbQuNGPINC40LvQuCDQutC+0LzQtdC90YLQsNGAIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLQodC/0L7QtNC10LvRj9C90LVcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLQqdC1INC/0L7Qu9GD0YfQuNGC0LUg0LjQt9Cy0LXRgdGC0LjQtSwg0LrQvtCz0LDRgtC+INC90Y/QutC+0Lkg0YHQv9C+0LTQtdC70Lgg0LLQsNGIINC/0L7RgdGCIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi0J3QsNGB0YLRgNC+0LnQutC4XCIsXG5cdFwiVk9USU5HXCI6IFwi0JPQu9Cw0YHRg9Cy0LDQvdC1XCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLQmNC30LHQtdGA0LXRgtC1INCyINC/0YDQvtGG0LXQvdGC0Lgg0YHQuNC70LDRgtCwINC90LAg0LPQu9Cw0YHQsCDQstC4LlxcbiA8YnIvPjxici8+0KLQvtCy0LAg0YnQtSDQvtC/0YDQtdC00LXQu9C4INGA0LDQt9C80LXRgNCwINCy0YrQttC90LDQs9GA0LDQttC00LXQvdC40Y8gLCDQutC+0LjRgtC+INC/0L7Qu9GD0YfQsNCy0LDRgiDRgdGC0LDRgtC40LjRgtC1LCDQt9CwINC60L7QuNGC0L4g0LPQu9Cw0YHRg9Cy0LDRgtC1LlwiLFxuXHRcIlNFUlZFUlwiOiBcItCh0YrRgNCy0YrRgFwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwi0J/RgNC10L/QvtGA0YrRh9C40YLQtdC70L3QvlwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItCX0LDQv9Cw0LfQuFwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwi0JjQvdGE0L7RgNC80LDRhtC40Y8g0LfQsCDQs9C70LDRgdGD0LLQsNC70LjRgtC1XCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwi0JfQtNGA0LDQstC10LksINC+0YLQvdC+0LLQviFcIixcblx0XCJMT0dJTl8xXCI6IFwi0JLQu9C10LfRgtC1INGBINC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC+INC40LzQtSDQuCDQv9Cw0YDQvtC70LAg0LfQsCDQtNCwINC/0YDQvtC00YrQu9C20LjRgtC1LlwiLFxuXHRcIkxPR0lOXzJcIjogXCLQmtC70Y7Rh9GK0YIg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1INGB0LUg0LjQt9C/0L7Qu9C30LLQsCDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LUsINC60L7QvNC10L3RgtC40YDQsNC90LUsINCz0LvQsNGB0YPQstCw0L3QtSDQuCDRgdC70LXQtNC10L3QtS5cIixcblx0XCJMT0dJTl8zXCI6IFwi0JDQutGC0LjQstC90LjRj9GCINC60LvRjtGHINGB0LUg0LjQt9C/0L7Qu9C30LLQsCDQt9CwINGC0YDQsNC90YHRhNC10YDQuCDQuCDQvtCx0L3QvtCy0LvQtdC90LjQtSDQvdCwINC/0YDQvtGE0LjQu9C90LAg0YHQvdC40LzQutCwLlwiLFxuXHRcIkxPR0lOXzRcIjogXCLQn9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQuCDQuNC00LXQvdGC0LjRhNC40LrQsNGG0LjQvtC90L3QuCDQtNCw0L3QvdC4INGB0LUg0YHRitGF0YDQsNC90Y/QstCw0YIg0LvQvtC60LDQu9C90L4g0L3QsCDRg9GB0YLRgNC+0LnRgdGC0LLQsNGC0LAg0LLQuC4g0J/RgNC4INC40LfRhdC+0LQg0L/RitC70L3QvtC80L7RidC40Y/RgtCwINGB0LUg0L7RgtGB0YLRgNCw0L3Rj9Cy0LDRgiFcIixcblx0XCJET05UX0hBVkVcIjogXCLQndGP0LzQsNGC0LUg0L/RgNC+0YTQuNC7P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwi0KDQtdCz0LjRgdGC0YDQuNGA0LDQudGC0LUg0YHQtSDRgdC10LPQsCFcIixcblx0XCJDQU5DRUxcIjogXCLQntGC0LrQsNC3XCIsXG5cdFwiQURWQU5DRURcIjogXCLQoNCw0LfRiNC40YDQtdC9INGA0LXQttC40LxcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwi0JDQutGC0LjQstC10L0g0LvQuNGH0LXQvSDQutC70Y7Rh1wiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi0JvQuNGH0LXQvSDQutC70Y7RhyDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LVcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcItCe0YHQvdC+0LLQvdCwINC/0LDRgNC+0LvQsFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwi0J/QvtGC0YDQtdCx0LjRgtC10LvRgdC60L4g0LjQvNC1XCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi0JrQsNGA0YLQuNGH0LrQuFwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcItCh0L/QuNGB0YrRhtC4XCIsXG5cdFwiU0VBUkNIXCI6IFwi0KLRitGA0YHQuFwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi0J/Rg9Cx0LvQuNC60YPQstCw0LnRgtC1INC90LXRidC+XCIsXG5cdFwiUkVQTFlUT1wiOiBcItCe0YLQs9C+0LLQvtGAINC90LBcIixcblx0XCJQT1NUXCI6IFwi0J/Rg9Cx0LvQuNC60YPQstCw0L3QtVwiLFxuXHRcIlBSRVZJRVdcIjogXCLQn9GA0LXQs9C70LXQtFwiLFxuXHRcIkRFRkFVTFRcIjogXCI1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwi0JfQsNGF0YDQsNC90LLQsNC90LUgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwi0J7RgtC60LDQtyDQvdCwINCy0YrQt9C90LDQs9GA0LDQttC00LXQvdC40LVcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcItCX0LDQv9Cw0LfQstCw0L3QtSDQt9CwINC/0L4t0LrRitGB0L3QvlwiLFxuXHRcIkNMRUFSXCI6IFwi0JjQt9GH0LjRgdGC0LLQsNC90LVcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCLQmtC+0LzQtdC90YLQsNGAXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi0KHRitC00YrRgNC20LDQvdC40LUg0L3QsCDQutC+0LzQtdC90YLQsNGA0LBcIixcblx0XCJUSVRMRVwiOiBcItCX0LDQs9C70LDQstC40LVcIixcblx0XCJUQUdTXCI6IFwi0KLQsNCz0L7QstC1XCIsXG5cdFwiTk9UX01BVENIXCI6IFwi0J3QtSDRgdGK0LLQv9Cw0LTQsFwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0L/QuNC9LdC60L7QtNCwXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi0JPRgNC10YjQvdC+XCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi0J7RgtCy0LDRgNCw0L3QtSDQvdCwINGB0YLQsNGC0LjRjy5cIixcblx0XCJTRVRfUElOXCI6IFwi0JfQsNC00LDQudGC0LUg0L/QuNC9LdC60L7QtC5cIixcblx0XCJFTlRFUl9QSU5cIjogXCLQktGK0LLQtdC00LXRgtC1INC/0LjQvS3QutC+0LQuXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwi0KHQuNCz0YPRgNC90Lgg0LvQuCDRgdGC0LU/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLQodC/0L7QtNC10LvRj9C90LXRgtC+INC1INC90LXQvtCx0YDQsNGC0LjQvNC+LCDQuNGB0LrQsNGC0LUg0LvQuCDQtNCwINC/0YDQvtC00YrQu9C20LjRgtC1P1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcItCT0YDQtdGI0LrQsCDQv9GA0Lgg0YHQstGK0YDQt9Cy0LDQvdC1LCDQvtC/0LjRgtCw0LnRgtC1INC+0YLQvdC+0LLQviFcIixcblx0XCJTVUNDRVNTXCI6IFwi0KPRgdC/0LXRhSFcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcItCh0L/QvtC00LXQu9C10L3QsCDQv9GD0LHQu9C40LrQsNGG0LjRjyFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwi0J3QtdGD0YHQv9C10YjQvdC+INCy0LvQuNC30LDQvdC1ISDQnNC+0LvRjywg0YPQstC10YDQtdGC0LUg0YHQtSwg0YfQtSDRgdGC0LUg0LLQu9C10LfQu9C4INCyINGB0LjRgdGC0LXQvNCw0YLQsCDRgSDQs9C70LDQstC90LDRgtCwINC/0LDRgNC+0LvQsCDQuNC70Lgg0YEg0YfQsNGB0YLQtdC9INC60LvRjtGHINC30LAg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQv9GA0Lgg0LLQu9C40LfQsNC90LUsINCw0LrQviDRgdGC0LUg0LjQt9Cx0YDQsNC70Lgg0KDQsNC30YjQuNGA0LXQvSDRgNC10LbQuNC8LlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcItCd0LXRg9GB0L/QtdGI0L3QviDQstC70LjQt9Cw0L3QtSEg0JzQvtC70Y8sINGD0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0YHRgtC1INCy0LvQtdC30LvQuCDQsiDRgdC40YHRgtC10LzQsNGC0LAg0YEg0LPQu9Cw0LLQvdCw0YLQsCDQv9Cw0YDQvtC70LAg0LjQu9C4INGBINCQ0LrRgtC40LLQvdC40Y8g0YfQsNGB0YLQtdC9INC60LvRjtGHINC/0YDQuCDQstC70LjQt9Cw0L3QtSwg0LDQutC+INGB0YLQtSDQuNC30LHRgNCw0LvQuCDQoNCw0LfRiNC40YDQtdC9INGA0LXQttC40LwuXCIsXG5cdFwiV0FSTklOR1wiOiBcItCS0L3QuNC80LDQvdC40LVcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwi0JPQu9Cw0YHRg9Cy0LDQvdC1INC30LAgd2l0bmVzc1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwi0JPQu9Cw0YHRg9Cy0LDQvdC+INC30LAgd2l0bmVzc1wiLFxuXHRcIkFHT1wiOiBcIi1cIixcblx0XCJGUk9NX05PV1wiOiBcItC+0YLQv9GA0LXQtNC4XCIsXG5cdFwiU0VDU1wiOiBcItGB0LXQulwiLFxuXHRcIkFfTUlOXCI6IFwi0LzQuNC9XCIsXG5cdFwiTUlOU1wiOiBcItC80LjQvVwiLFxuXHRcIkFOX0hPVVJcIjogXCLRh9Cw0YFcIixcblx0XCJIT1VSU1wiOiBcItGH0LDRgdCwXCIsXG5cdFwiQV9EQVlcIjogXCLQtNC10L1cIixcblx0XCJEQVlTXCI6IFwi0LTQvdC4XCIsXG5cdFwiQV9NT05USFwiOiBcItC80LXRgdC10YZcIixcblx0XCJNT05USFNcIjogXCLQvNC10YHQtdGG0LBcIixcblx0XCJBX1lFQVJcIjogXCLQs9C+0LTQuNC90LBcIixcblx0XCJZRUFSU1wiOiBcItCz0L7QtNC40L3QuFwiLFxuXHRcIk1JTl9SRUFEXCI6IFwiLdC80LjQvdGD0YLQvdC+INGH0LXRgtC10L3QtS5cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwi0J7RgtGA0LjRhtCw0YLQtdC70LXQvSDQs9C70LDRgSDQuNC70Lgg0YHQu9Cw0LPQsNC90LUg0L3QsCDRhNC70LDQsy5cIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCLQodC90LjQvNC60LBcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcItCY0LfQsdC10YDQtdGC0LUg0YHQvdC40LzQutCwXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLQl9Cw0LTQsNC50YLQtSBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcItCU0L7QsdCw0LLQtdGC0LUg0YHQvdC40LzQutCwXCIsXG5cdFwiRVJST1JcIjogXCLQk9GA0LXRiNC60LBcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLQk9GA0LXRiNC60LAg0L/RgNC4INC60LDRh9Cy0LDQvdC1XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcItCd0Y/QvNCwINC00L7RgdGC0YrQvyDQtNC+INC60LDQvNC10YDQsNGC0LAuXCIsXG5cdFwiU0VUX1VSTFwiOiBcItCh0LvQvtC20LXRgtC1IFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLQlNC40YDQtdC60YLQvdCwINCy0YDRitC30LrQsCDQutGK0Lwg0YHQvdC40LzQutCw0YLQsFwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwi0JrQvtC80LXQvdGC0LDRgNGK0YIg0LUg0L/Rg9Cx0LvQuNC60YPQstCw0L0hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCLQmNC30YLRgNC40LLQsNC90LXRgtC+INC90LAg0LrQvtC80LXQvdGC0LDRgNC4INC1INC90LXQvtCx0YDQsNGC0LjQvNC+XCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi0JjQt9GC0YDQuNGCINC60L7QvNC10L3RgtCw0YBcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcItCa0LDRh9Cy0LDQvdC1INC90LAg0YHQvdC40LzQutCwXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcItCa0LDRh9Cy0LDQvdC10YLQviDQv9GA0LjQutC70Y7Rh9C4XCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcItCT0YDQtdGI0LrQsCDQv9GA0Lgg0LrQsNGH0LLQsNC90LVcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLQn9Cw0YDQvtC70LDRgtCwINC40LvQuCDQv9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQvtGC0L4g0LjQvNC1INGB0LAg0LPRgNC10YjQvdC4XCIsXG5cdFwiSU5GT1wiOiBcItCY0L3RhNC+0YDQvNCw0YbQuNGPXCIsXG5cdFwiUVJfVEVYVFwiOiBcItCf0L7RgdGC0LDQstC10YLQtSDQvdCwIFFSINC60L7QtCDQsiDQv9C+0LvQtdGC0L4g0LfQsCDRgdC60LDQvdC40YDQsNC90LVcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCLQo9Cy0LXRgNC10YLQtSDRgdC1LCDRh9C1INC40LzQsNGC0LUg0LTQvtGB0YLQsNGC0YrRh9C90LAg0YHRg9C80LAg0LfQsCDRgtGA0LDQvdGB0YTQtdGAIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLQn9C+0YLRgNC10LHQuNGC0LXQu9GP0YIg0LrRitC8LCDQutC+0LPQvtGC0L4g0YHQtSDQvtC/0LjRgtCy0LDRgtC1INC00LAg0L/RgNC10YXQstGK0YDQu9C40YLQtSDRgdGD0LzQsNGC0LAg0L3QtSDRgdGK0YnQtdGB0YLQstGD0LLQsCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwi0KHQuNCz0YPRgNC90Lgg0LvQuCDRgdGC0LUsINGH0LUg0LjRgdC60LDRgtC1INC00LAg0L/RgNC10LLQtdC00LXRgtC1INGB0YPQvNCw0YLQsD9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLQn9C+0YLQstGK0YDQttC00LDQstCw0L3QtVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi0KLRgNCw0L3Qt9Cw0LrRhtC40Y/RgtCwINGB0LUg0LjQt9C70YrRh9Cy0LAuLi5cIixcblx0XCJGRUVEXCI6IFwi0J/QvtGC0L7QulwiLFxuXHRcIlRSRU5ESU5HXCI6IFwi0KLQtdC90LTQtdC90YbQuNC4XCIsXG5cdFwiSE9UXCI6IFwi0JPQvtGA0LXRidC4XCIsXG5cdFwiTkVXXCI6IFwi0J3QvtCy0LhcIixcblx0XCJQUk9NT1RFRFwiOiBcItCf0YDQvtC80L7RgtC40YDQsNC90LhcIixcblx0XCJWT1RFU1wiOiBcItCT0LvQsNGB0L7QstC1XCIsXG5cdFwiUEFZT1VUXCI6IFwi0JjQt9C/0LvQsNGJ0LDQvdC1XCIsXG5cdFwiQ09NTUVOVFNcIjogXCLQmtC+0LzQtdC90YLQsNGA0LhcIixcblx0XCJUUkVORElOR18zMFwiOiBcItCi0LXQvdC00LXQvdGG0LjQuCDQt9CwINC/0L7RgdC70LXQtNC90LjRgtC1IDMwINC00L3QuFwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItCh0L7RgNGC0LjRgNCw0L3QtSDQv9C+OlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcItCm0LjQutGK0Lsg0L3QsCDQuNC30L/Qu9Cw0YnQsNC90LVcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi0J/QvtGC0LXQvdGG0LjQsNC70L3QviDQuNC30L/Qu9Cw0YnQsNC90LVcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcItCf0L7RgdC70LXQtNC90L4g0LjQt9C/0LvQsNGJ0LDQvdC1XCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcItCQ0LLRgtC+0YDRgdC60L4g0LLRitC30L3QsNCz0YDQsNC20LTQtdC90LjQtVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcItCS0YrQt9C90LDQs9GA0LDQttC00LXQvdC40Y8g0L7RgiDQutGD0YDQsNGC0L7RgNGB0YLQstC+XCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLQodGC0LDRgtC40Y/RgtCwINC1INC/0YPQsdC70LjQutGD0LLQsNC90LBcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwi0J/Rg9Cx0LvQuNC60YPQstCw0LnRgtC1INC/0L4t0LrRitGB0L3QviFcIixcblx0XCJTQVZFRFwiOiBcItCX0LDQv9Cw0LfQtdC90L5cIixcblx0XCJDTEVBUkVEXCI6IFwi0JjQt9GH0LjRgdGC0LXQvdC+XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcItCh0LvQsNCz0LDQvdC10YLQviDQvdCwINGE0LvQsNCzINC80L7QttC1INC00LAg0L3QsNC80LDQu9C4INC90LDQs9GA0LDQtNC40YLQtSDQuCDQtNCwINGB0LLQsNC70Lgg0YHRgtCw0YLQuNGP0YLQsCDQvtGCINC/0YDQtdC00L3QuNGC0LUg0YDQtdC00LjRhtC4Ljxicj48YnI+0KTQu9Cw0LPRitGCINCx0LjQstCwINC00LAg0YHQtSDQv9C+0LvQt9Cy0LAg0L/RgNC4INC40LfQvNCw0LzQuCDQuNC70Lgg0L/Qu9Cw0LPRj9GC0YHRgtCy0L4sINC+0LzRgNCw0LfQvdCwINGA0LXRhywg0LjQvdGC0LXRgNC90LXRgiDRgtGA0L7Qu9C4LCDRg9C80LjRiNC70LXQvdC+INC90LXQv9GA0LDQstC40LvQvdC+INC60LDRgtC10LPQvtGA0LjQt9C40YDQsNC90L4g0YHRitC00YrRgNC20LDQvdC40LUg0Lgg0YHQv9Cw0LwuXCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi0JvQuNC80LjRgiDQt9CwINC30LDRj9Cy0LrQsCDQtSDQtNC+0YHRgtC40LPQvdCw0YIuINCg0LDQt9Cz0LvQtdC00LDQudGC0LUg0LTRgNGD0LPQuCDRgtC10L3QtNC10L3RhtC40Lgv0YLQsNCz0L7QstC1IVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcItCh0YLQsNGC0LjRj9GC0LAg0LUg0L/RgNC10LzQsNGF0L3QsNGC0LAg0L7RgiDQu9GO0LHQuNC80LghXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcItCh0YLQsNGC0LjRj9GC0LAg0LUg0LTQvtCx0LDQstC10L3QsCDQsiDQm9GO0LHQuNC80LghXCIsXG5cdFwiUkVTRVRcIjogXCLQmNC30YfQuNGB0YLQstCw0L3QtVwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi0J/RgNC+0LzRj9C90LAg0L3QsCDQv9GA0L7RhNC40LvQvdCwINGB0L3QuNC80LrQsFwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwi0J/RgNC+0LzRj9C90LAg0L3QsCDRiNCw0LHQu9C+0L3QvdCw0YLQsCDRgdC90LjQvNC60LBcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCLQnNC+0LvRjywg0L/RgNC10LTRgdGC0LDQstC10YLQtSDQkNC60YLQuNCy0LXQvSDRh9Cw0YHRgtC10L0g0LrQu9GO0YcsINCw0LrQviDRgdGC0LUg0LjQt9Cx0YDQsNC70Lgg0KDQsNC30YjQuNGA0LXQvSDRgNC10LbQuNC8INC30LAg0LLRhdC+0LQhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwi0KLQvtCy0LAg0YnQtSDQv9GA0LXQvNCw0YXQvdC1INC/0YDQvtGE0LjQu9C90LDRgtCwINGB0L3QuNC60LzQutCwXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi0KLQvtCy0LAg0YnQtSDQv9GA0LXQvNCw0YXQvdC1INGI0LDQsdC70L7QvdC90LDRgtCwINGB0L3QuNC60LzQutCwXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLQndGD0LbQtdC9INC1INGA0LXRgdGC0LDRgNGCINC90LAg0YHRitGA0LLRitGA0LAhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcItCd0LDRgdGC0YDQvtC50LrQuNGC0LUg0YHQsCDQvtCx0L3QvtCy0LXQvdC4IVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcItCV0LfQuNC6XCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLQntGCINGC0YPQuiDRgdC1INGB0LzQtdC90Y/RgiDQtdC30LjRhtC40YLQtSDQvdCwINCw0L/Qu9C40LrQsNGG0LjRj9GC0LAuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcItCi0LDQt9C4INC+0L/QtdGA0LDRhtC40Y8g0LjQt9C40YHQutCy0LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjyDQtNCwINCy0LvQtdC30LXRgtC1INCyINC/0YDQvtGE0LjQu9CwINGBINC+0YHQvdC+0LLQvdCwINC/0LDRgNC+0LvQsCwg0YEg0LDQutGC0LjQstC10L0v0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQutC70Y7Rhy4g0JzQvtC70Y8sINCy0LvQtdC30YLQtSDQuCDQvtC/0LjRgtCw0LnRgtC1INC+0YLQvdC+0LLQvi5cIixcblx0XCJHQUxMRVJZXCI6IFwi0JPQsNC70LXRgNC40Y9cIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLQn9GA0LXQstC+0LTQsNGH0LhcIixcblx0XCJTSEFSRVwiOiBcItCh0L/QvtC00LXQu9C4XCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLQkdC+0YDRgdCwXCIsXG5cdFwiRVhDSEFOR0VcIjogXCLQntCx0LzRj9C90LBcIixcblx0XCJEUkFGVFNcIjogXCLQp9C10YDQvdC+0LLQuFwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcItCh0YLQsNGC0LjRj9GC0LAg0LUg0L/RgNC10LzQsNGF0L3QsNGC0LAg0L7RgiDRh9C10YDQvdC+0LLQuNGC0LUhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcItCh0YLQsNGC0LjRj9GC0LAg0LUg0LTQvtCx0LDQstC10L3QsCDQsiDRh9C10YDQvdC+0LLQuNGC0LUhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcItCf0YrQu9C30L3QtdGC0LUg0L3QsNC70Y/QstC+INC30LAg0L7Qv9GG0LjQuFwiLFxuXHRcIk1BTkFHRVwiOiBcItCj0L/RgNCw0LLQu9C10L3QuNC1XCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcItCh0L3QuNC80LrQsNGC0LAg0LUg0L/RgNC10LzQsNGF0L3QsNGC0LBcIixcblx0XCJDT1BZXCI6IFwi0JrQvtC/0LjRgNCw0L3QtVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi0JLRgdC1INC+0YnQtSDQvdC1INGB0YLQtSDQutCw0YfQuNC70Lgg0YHQvdC40LzQutCwIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwi0J/Qu9GK0LfQvdC10YLQtSDQvdCw0LTQvtC70YMg0LfQsCDQvtC/0YDQtdGB0L3Rj9Cy0LDQvdC1XCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcItCS0YrQvdGI0L3QuCDQsNC/0LvQuNC60LDRhtC40LhcIixcblx0XCJQTFVHSU5TXCI6IFwi0JTQvtCx0LDQstC60LhcIixcblx0XCJTVUdHRVNUXCI6IFwi0J/RgNC10LTQu9C+0LbQtdGC0LVcXG5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcItCe0YfQsNC60LLQsNC50YLQtSDRgdC60L7RgNC+XCIsXG5cdFwiQ0hBSU5cIjogXCLQkdC70L7QutGH0LXQudC9XCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcItCe0YIg0YLRg9C6INGB0LUg0LjQt9Cx0LjRgNCwINCx0LvQvtC60YfQtdC50L0g0LjQu9C4INCx0LDQt9C+0LLQsNGC0LAg0L/Qu9Cw0YLRhNC+0YDQvNCwLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi0JLQsNC70YPRgmFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi0KLRg9C6INC80L7QttC10YLQtSDQtNCwINC/0YDQvtC80LXQvdC40YLQtSDQstCw0LvRg9GC0LDRgtCwINCyINC60L7Rj9GC0L4g0LjRgdC60LDRgtC1INC00LAg0LLQuNC20LTQsNGC0LUg0LLRitC30L3QsNCz0YDQsNC20LTQtdC90LjRj9GC0LAuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+0KTRg9C90LrRhtC40Lgg0LIgZVN0ZWVtPC9iPjxicj4t0JTQvtGB0YLRitC/INC00L4g0YPQvdC40LrQsNC70L3QuCDRgdGC0LDRgtC40Lgg0L3QsCDQstGB0Y/QutCw0LrQstC4INGC0LXQvNC4LCDQutC+0LjRgtC+INCy0Lgg0LjQvdGC0LXRgNC10YHRg9Cy0LDRgi4gPGJyPi3QkNCy0YLQvtGC0LjRgtC1INC/0L7Qu9GD0YfQsNCy0LDRgiDQstGK0LfQvdCw0LPRgNCw0LbQtdC90LjRjyDQsdC70LDQs9C+0LTQsNGA0LXQvdC40LUg0L3QsCDQs9C70LDRgdC+0LLQtdGC0LUg0L7RgiDQutGD0YDQsNGC0L7RgNC40YLQtSwg0LrQvtC40YLQviDRgdGK0YnQviDQv9C+0LvRg9GH0LDQstCw0YIg0LTRj9C7INC+0YIg0L/QtdGH0LDQu9Cx0LjRgtC1Ljxicj4t0J/QtdGH0LXQu9C40YLQtSDQvtGCINCz0LvQsNGB0L7QstC10YLQtSwg0LrQvtC40YLQviDQv9C+0LvRg9GH0LDQstCw0YIg0LLQsNGI0LjRgtC1INGB0YLQsNGC0LjQuCwg0LrQsNC60YLQviDQuCDQvtGCINC60YPRgNCw0YLQvtGA0YHRgtCy0L4uINCU0LDQstCw0LnQutC4INGB0LLQvtGPINCz0LvQsNGBINC90LAg0LTRgNGD0LPQuCDQsNCy0YLQvtGA0Lgg0YHRitGJ0L4g0L/QtdGH0LXQu9C40YLQtSDQstGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1Ljxicj4t0J/Rg9Cx0LvQuNC60YPQstCw0LnRgtC1INCy0LDRiNC40YLQtSDRgdGC0LDRgtC40Lgg0Lgg0LPQuCDRgdGK0YXRgNCw0L3Rj9Cy0LDQudGC0LUg0LHQtdC30L/Qu9Cw0YLQvW8uINCf0LXRh9C10LvQtdGC0LUg0LLRitC30L3QsNCz0YDQsNC20LTQtdC90LjRjyDQvtGCINCy0LDRiNC40Y8g0LHQu9C+0LMuPGJyPi3Qn9C40YjQtdGC0LUg0YHRgtCw0YLQuNC5INCyINC00LLQuNC20LXQvdC40LUuINCY0LzQsNGC0LUg0L7Qv9GG0LjRjyDQt9CwINC30LDQv9Cw0LfQstCw0L3QtSDQvdCwINC90Y/QutC+0LvQutC+INGH0LXRgNC90L7QstC4INC30LAg0L/Qvi3QutGK0YHQvdC+INC/0YPQsdC70LjQutGD0LLQsNC90LUuPGJyPi3Ql9Cw0L/QsNC30LXRgtC1INGB0YLQsNGC0LjQuCDQsiBcXFwi0JvRjtCx0LjQvNC4XFxcIiwg0LfQsCDQtNCwINCz0Lgg0L/RgNC+0YfQtdGC0LXRgtC1INC/0L4t0LrRitGB0L3Qvi48YnI+LdCR0L7RgNGB0LAg0Lgg0YLQtdCz0LvQtdC90LUg0L3QsCDQv9GA0LjRhdC+0LTQuC48YnI+LdCY0LfQv9GA0LDRidCw0L3QtSDQvdCwINGB0YDQtdC00YHRgtCy0LAg0LrRitC8INC60L7Qs9C+0YLQviDQuCDQtNCwINC1INCw0LLRgtC+0YAsINC/0L7RgtGA0LXQsdC40YLQtdC7LCDQv9GA0LjRj9GC0LXQuywg0L/QvtGB0LvQtdGE0L7QstCw0YLQtdC7INC4INGC0L0uPGJyPi3QodC70LXQtNCy0LDQudGC0LUg0LjQvdGC0LXRgNC10YHQvdC4INCx0LvQvtCz0YrRgNC4Ljxicj4t0J3QsNC80LXRgNC10YLQtSDQstCw0YjQuNGC0LUg0L/QvtGB0LvQtdC00L7QstCw0YLQtdC70Lgg0Lgg0YXQvtGA0LAsINC60L7QuNGC0L4g0YHQu9C10LTQuNGC0LUuPGJyPi3Qn9C+0LvRg9GH0LDQstCw0L3QtSDQvdCwINC40LfQstCw0YHRgtC40Y8uINCf0L7QtNGK0YDQttCw0LnRgtC1INCy0YDRitC30LrQsCDRgdGK0YEg0YHQstC+0LjRgtC1INC/0L7RgdC70LXQtNC+0LLQsNGC0LXQu9C4LCDRgdC70LXQtNC10YLQtSDQtNC40YHQutGD0YHRgtC40LgsINCyINC60L7QuNGC0L4g0YPRh9Cw0YHRgtCy0LDRgtC1Ljxicj4t0KLRitGA0YHQtdC90LUg0L3QsCDQuNC90YLQtdGA0LXRgdC90Lgg0YLQsNCz0L7QstC1L9C60LDRgtC10LPQvtGA0LjQuCDQuCDQsNCy0YLQvtGA0LguIDxicj4gLdCf0LXRgNGB0L7QvdCw0LvQuNC30LjRgNCw0L3QtSDQvdCwINCy0LDRiNC40Y8g0L/RgNC+0YTQuNC7LiA8YnI+0JzQvdC+0LPQviDRhNGD0L3QutGG0LjQuCDRidC1INCx0YrQtNCw0YIg0LTQvtCx0LDQstC10L3QuC4gPGJyPjxicj48Yj7QodC40LPRg9GA0L3QvtGB0YI8L2I+IDxicj4xLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC90Y/QvNCwINC00LjRgNC10LrRgtC10L0g0LTQvtGB0YLRitC/INC60YrQvCDQstCw0YjQuNGC0LUg0YHRgNC10LTRgdGC0LLQsC4gPGJyPjIuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQvNC+0LTQtdC7INC30LAg0YHQuNCz0YPRgNC90L7RgdGCINC+0YIg0YHRgtGA0LDQvdCwINC90LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjy4g0KfQsNGB0YLQvdC40YLQtSDQutC70Y7Rh9C+0LLQtSDRgdC1INGB0YrRhdGA0LDQvdGP0LLQsNGCINC70L7QutCw0LvQvdC+INC4INC90LjQutC+0LPQsCDQvdC1INGB0LUg0LjQt9C/0YDQsNGJ0LDRgiDQutGK0Lwg0YHRitGA0LLRitGA0LguINCS0LjQtSDRgdGC0LUg0L7RgtCz0L7QstC+0YDQvdC4INC30LAg0LfQsNC/0LDQt9Cy0LDQvdC10YLQviDQuCDRgdGK0YXRgNCw0L3QsNC90LjQtdGC0L4g0L3QsCDQstCw0YjQuNGC0LUg0L/QsNGA0L7Qu9C4LiA8YnI+My4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQv9GA0LXQtNC70LDQs9CwINC+0L/RgNC+0YHRgtC10L0g0Lgg0L/RgNC40LLQu9C10LrQsNGC0LXQu9C10L0g0L/QvtGC0YDQtdCx0LjRgtC10LvRgdC60Lgg0LjQvdGC0LXRgNGE0LXQudGBLiA8YnI+NC4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQv9GA0LXQtNC70LDQs9CwINC00L7Qv9GK0LvQvdC40YLQtdC70L3QviDQvdC40LLQviDQvdCwINGB0LjQs9GD0YDQvdC+0YHRgiDRgSDQv9C40L0t0LrQvtC0IDxicj48YnI+ZVN0ZWVtINC/0L7QtNGK0YDQttCwINC/0LvQsNGC0YTQvtGA0LzQuNGC0LUgU3RlZW0g0LggR29sb3MuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLQntGB0L3QvtCy0LDRgtC10Lsg0Lgg0LPQu9Cw0LLQtdC9INC/0YDQvtCz0YDQsNC80LjRgdGCXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCLQlNC+0LHQsNCy0Y/QvdC1INC90LAg0LTQvtC/0YrQu9C90LjRgtC10LvQtdC9INC/0YDQvtGE0LjQu1wiLFxuXHRcIlBMQVRGT1JNXCI6IFwi0J/Qu9Cw0YLRhNC+0YDQvNCwXCIsXG5cdFwiRVNDUk9XXCI6IFwi0JXRgdC60YDQvtGDXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93INCw0LPQtdC90YJcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCLQmtGA0LDQtdC9INGB0YDQvtC6INC30LAg0YDQsNGC0LjRhNC40YbQuNGA0LDQvdC1XCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCLQmNC30YLQuNGH0LDQvdC1INC90LAgRXNjcm93XCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkVzY3JvdyDRgtCw0LrRgdCwXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93INC/0YDQsNCy0LjQu9CwXCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcItCd0L7RidC10L0g0YDQtdC20LjQvFwiLFxuXHRcIkRBWV9NT0RFXCI6IFwi0JTQvdC10LLQtdC9INGA0LXQttC40LxcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCLQn9C+0LrQsNC20Lgg0YbQtdC70LjRjyDQutC+0L3RgtC10LrRgdGCXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcItCf0L7RgtGA0LXQsdC40YLQtdC70Y/RgiDQvdC1INC1INC90LDQvNC10YDQtdC9XCIsXG5cdFwiQVBQUk9WRVwiOiBcItCe0LTQvtCx0YDQuFwiLFxuXHRcIkRJU1BVVEVcIjogXCLQodC/0L7RgFwiLFxuXHRcIlJFTEVBU0VcIjogXCLQn9GD0YHQutCw0L3QtVwiLFxuXHRcIkZST01cIjogXCJP0YJcIixcblx0XCJJRFwiOiBcItCY0LTQtdC90YLQuNGE0LjQutCw0YbQuNGPXCIsXG5cdFwiU1VCTUlUXCI6IFwi0JjQt9C/0YDQsNGJ0LDQvdC1XCIsXG5cdFwiUkVDRUlWRVJcIjogXCLQn9C+0LvRg9GH0LDRgtC10LtcIixcblx0XCJMT0NBVElPTlwiOiBcItCc0LXRgdGC0L7Qv9C+0LvQvtC20LXQvdC40LVcIixcblx0XCJXRUJTSVRFXCI6IFwi0KHRgtGA0LDQvdC40YbQsFwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcItCY0LzQtVwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJEb23Fr1wiLFxuXHRcIkxPR0lOXCI6IFwiUMWZaWhsw6HFoWVuw61cIixcblx0XCJMT0dPVVRcIjogXCJPZGhsw6HFoWVuw61cIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiTsOhc2xlZHVqXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiWsOhbG/Fvmt5XCIsXG5cdFwiVFJBTlNGRVJcIjogXCJQxZlldm9kXCIsXG5cdFwiTUFSS0VUXCI6IFwiVHJoXCIsXG5cdFwiU0VUVElOR1NcIjogXCJOYXN0YXZlbsOtXCIsXG5cdFwiQUJPVVRcIjogXCJPIG7DoXNcIixcblx0XCJBQk9VVF8xXCI6IFwia2RlIGtkb2tvbGl2IG3Fr8W+ZSB6w61za2F0IG9kbcSbbnUgemEgc3bFr2ogb2JzYWghXCIsXG5cdFwiQUJPVVRfMlwiOiBcImplIHBvc3RhdmVuIG5hIHt7cGxhdGZvcm1uYW1lfX0gcGxhdGZvcm3Emy4gQXBsaWthY2kgdnl0dm/FmWlsXCIsXG5cdFwiQUJPVVRfM1wiOiBcImEgamUgdG8ga29tdW5pdG7DrSwgb3Blbi1zb3VyY2UgbW9iaWxuw60gcHJvamVrdC4gTmFiw616w60gcMWZw61zdHVwIGsgb2JzYWh1IHBybyDEjXRlbsOtLCBrb21lbnRvdsOhbsOtLCBobGFzb3bDoW7DrSwgdnlzdGF2b3bDoW7DrSBwxZnDrXNwxJt2a8WvLCBwxZlldm9kIHbDvWTEm2xrxa8gYXRkLiBwb3NreXRvdmFuw6kge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluZW0gYSB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIEFwbGlrYWNlIG5lbcOhIHDFmcOtc3R1cCBrIHXFvml2YXRlbG92w71tIGZvbmTFr20gYW5pIGplIG5pa2R5IG5ldmxhc3Ruw60uXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEFwbGlrYWNlIG5hYsOtesOtIGJlenBlxI1ub3N0bsOtIG1vZGVsIG5hIHN0cmFuxJsga2xpZW50YS4gUHJpdsOhdG7DrSBrbMOtxI1lIGpzb3UgZHLFvmVueSBsb2vDoWxuxJsgYSBuaWtkeSBuZWpzb3UgcG9zw61sw6FueSDFvsOhZG7DvW0gc2VydmVyxa9tLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBcGxpa2FjZSBuYWLDrXrDrSBqZWRub2R1Y2jDoSwgYXRyYWt0aXZuw60gdcW+aXZhdGVsc2vDoSByb3pocmFuw60gYSB6w6HFvml0a3kuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIEFwbGlrYWNlIHBvIHXFvml2YXRlbMOtY2ggbmlrZHkgbmVwb8W+YWR1amUgxb7DoWRuw6kgb3NvYm7DrSBpbmZvcm1hY2UuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIkhsYXN1anRlIHBybyBzdsSbZGthIGdvb2Qta2FybWFcIixcblx0XCJBQk9VVF85XCI6IFwiS29udGFrdC9acMSbdG7DoSB2YXpiYTpcIixcblx0XCJBQk9VVF8xMFwiOiBcIlbDrWNlIGluZm9ybWFjw606XCIsXG5cdFwiUkVNT1ZFXCI6IFwiT2RzdHJhbml0XCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJab2JyYXplbsOtIHRyaHVcIixcblx0XCJQUklDRVwiOiBcIkNlbmFcIixcblx0XCJBTU9VTlRcIjogXCJTdW1hXCIsXG5cdFwiVE9UQUxcIjogXCJDZWxrZW1cIixcblx0XCJOT09SREVSU1wiOiBcIsW9w6FkbsOpIG90ZXbFmWVuw6kgb2JqZWRuw6F2a3kgcHJvXCIsXG5cdFwiREFURVwiOiBcIkRhdHVtXCIsXG5cdFwiQlVZXCI6IFwiTsOha3VwXCIsXG5cdFwiU0VMTFwiOiBcIlByb2RlalwiLFxuXHRcIk9QRU5cIjogXCJPdGV2xZllbm9cIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaWVcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlNsZWRvdmF0XCIsXG5cdFwiRk9MTE9XRURcIjogXCJTbGVkb3bDoW5cIixcblx0XCJVTkZPTExPV1wiOiBcIlDFmWVzdGF0IHNsZWRvdmF0XCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiU2xlZG92YW7DrVwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIlNsZWR1asOtY8OtXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIkhsZWRlaiBzbGVkdWrDrWPDrVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJIbGVkZWogc2xlZG92YW7DqVwiLFxuXHRcIkJZXCI6IFwia8O9bVwiLFxuXHRcIklOXCI6IFwidlwiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJaw6Fsb8W+a2FcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJIbGFzdWp0ZSBwcm9cIixcblx0XCJET1dOVk9URVwiOiBcIkhsYXN1anRlIHByb3RpXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlZyYcWldGUgaGxhcyBwcm90aVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiVnJhxaV0ZSBobGFzIHByb1wiLFxuXHRcIlJFUExZXCI6IFwiT2Rwb3bEm3p0ZVwiLFxuXHRcIkVESVRcIjogXCJVcHJhdnRlXCIsXG5cdFwiUE9TVF8xXCI6IFwiUHJvIHpvYnJhemVuw60gdm9sZWIgcMWZZWplxI8gdmxldm8gbmEga29tZW50w6HFmWVcIixcblx0XCJQT1NUXzJcIjogXCJQcm8gem9icmF6ZW7DrSBzdWJrb21lbnTDocWZxa8ga2xlcG7Em3RlIG5hIGtvbWVudMOhxZllXCIsXG5cdFwiT1BUSU9OU1wiOiBcIlZvbGJ5XCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVzdGVlbW92w6FubyBrw71tXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiUMWZaXByYXZ1amUgc2VcIixcblx0XCJCQUxBTkNFU1wiOiBcIlrFr3N0YXRreVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIG9iY2hvZG92YXRlbG7DqSB0b2tlbnksIGt0ZXLDqSBtb2hvdSBiw710IGtkeWtvbGl2IHDFmWV2ZWRlbnkuIHt7cGxhdGZvcm1uYW1lfX0gbW9ob3UgYsO9dCBwxZlldmVkZW55IG5hIHt7cGxhdGZvcm1wb3dlcn19IHYgcHJvY2VzdSB6dmFuw6ltIHBvd2VyaW5nIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCB2bGl2b3bDqSB0b2tlbnksIGt0ZXLDqSBwb3NpbHVqw60gcMWZaSBkbG91aG9kb2LDqW0gZHLFvmVuw60gYSBobGFzb3bDoW7DrSBvIHDFmcOtc3DEm3Zjw61jaC4gxIzDrW0gdsOtY2UgamljaCBuxJtrZG8gZHLFvsOtLCB0w61tIHbDrWNlIG3Fr8W+ZSBvdmxpdm5pdCBvZG3Em255IGRydWjDvWNoIGEgc8OhbSB6w61za2F0IG9kbcSbbnUgemEgc3Byw6F2bsOpIGhsYXNvdsOhbsOtLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VueSB2IGNlbsSbIG9rb2xvIHt7cGxhdGZvcm1zdW5pdH19IHYge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJPxI1la8OhdmFuw6EgY2VuYVwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIk/EjWVrw6F2YW7DoSBjZW5hIGplIHphbG/FvmVuYSBuYSA3IGRlbm7DrSBwcsWvbcSbcm7DqSBjZW7EmyB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJIaXN0b3JpZSB0cmFuc2FrY8OtXCIsXG5cdFwiUE9TVElOR1wiOiBcIk9kZXPDrWzDoW7DrVwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIk9kZXPDrWxhY8OtIGtsw63EjSBqZSBwb3XFvsOtdsOhbiBwcm8gb2Rlc8OtbMOhbsOtIHDFmcOtc3DEm3Zrxa8gYSBobGFzb3bDoW7DrS4gTcSbbCBieSBiw710IHJvemTDrWxuw70gb2QgYWt0aXZuw61obyBhIHZsYXN0bmlja8OpaG8ga2zDrcSNZS5cIixcblx0XCJPV05FUlwiOiBcIlZsYXN0bsOta1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIlZsYXN0bmlja8O9IGtsw63EjSBqZSBobGF2bsOtIGtsw63EjSDDusSNdHUgYSBqZSBwb8W+YWRvdsOhbiBwcm8gem3Em251IG9zdGF0bsOtY2ggw7rEjXTFry4gUHJpdsOhdG7DrSBrbMOtxI0gbmVibyBoZXNsbyBwcm8gdmxhc3RuaWNrw70ga2zDrcSNIGJ5IG3Em2x5IGLDvXQgZHLFvmVueSBwb2t1ZCBtb8W+bm8gY28gbmVqdsOtY2Ugb2ZmbGluZS5cIixcblx0XCJBQ1RJVkVcIjogXCJBa3Rpdm7DrVwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkFrdGl2bsOtIGtsw63EjSBzZSBwb3XFvsOtdsOhIHBybyBwxZlldm9keSBhIHphZMOhbsOtIG9iamVkbsOhdmVrIG5hIHZuaXTFmW7DrW0gdHJodS5cIixcblx0XCJNRU1PXCI6IFwiUG96bsOhbWthXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiUG96bsOhbWtvdsO9IGtsw63EjSBzZSBwb3XFvsOtdsOhIHBybyB0dm9yYnUgYSDEjXRlbsOtIHBvem7DoW1lay5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiUMWZw61zcMSbdmt5XCIsXG5cdFwiUkVQTElFU1wiOiBcIk9kcG92xJtkaVwiLFxuXHRcIldBTExFVFwiOiBcIlBlbsSbxb5lbmthXCIsXG5cdFwiVEFHXCI6IFwixaB0w610ZWtcIixcblx0XCJVU0VSXCI6IFwiVcW+aXZhdGVsXCIsXG5cdFwiQ0xPU0VcIjogXCJaYXbFmcOtdFwiLFxuXHRcIlRPXCI6IFwiZG9cIixcblx0XCJBU1NFVFwiOiBcIkFrdGl2dW1cIixcblx0XCJTRU5EXCI6IFwiUG9zbGF0XCIsXG5cdFwiU0VDVVJJVFlcIjogXCJaYWJlenBlxI1lbsOtXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiRG9zdHVwbsO9XCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJWZcWZZWpuw6EgcG96bsOhbWthXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlXFvml2YXRlbCBuYXDFmS4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUGluIGvDs2RcIixcblx0XCJQSU5fVEVYVFwiOiBcIlBJTiBrw7NkIHBvbcOhaMOhIHphYmV6cGXEjWl0IGFwbGlrYWNpIGEgZGF0YS4gPGJyLz48YnIvPjxiPlBvem7DoW1rYTo8L2I+IEpha21pbGUgamUgYWt0aXZuw60sIG3DoXRlIG1heGltw6FsbsSbIDQgcG9rdXN5IG5hIG9kZW3EjWVuw60uIFBva3VkIHBpbiB6YXBvbWVuZXRlIG5lYm8gbmV1c3DEm2pldGUsIGFwbGlrYWNlIG9kc3RyYW7DrSB1xb5pdmF0ZWxza8OhIGRhdGEgdG9ob3RvIHDFmWlobMOhxaFlbsOtLiBNxa/FvmV0ZSBzZSBvcMSbdCBwxZlpaGzDoXNpdCBhIHBva3JhxI1vdmF0IHYgcHLDoWNpLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJPem7DoW1lbsOtXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiUG9rdWQgbsSba2RvIGhsYXN1amUgcHJvIFbDocWhIHDFmcOtc3DEm3Zlaywgb2JkcsW+w610ZSB1cG96b3JuxJtuw60hIDxici8+IDxiPlBvem7DoW1rYTo8L2I+IFRhdG8gb3puw6FtZW7DrSBvYnNhaHVqw60gdsOhaHUgaGxhc3UgKGHFpSB1xb4gamUgdG8gaGxhcyBwcm8sIHByb3RpLCBuZWJvIG9kdm9sw6Fuw60gaGxhc292w6Fuw60pLlwiLFxuXHRcIlZPVEVcIjogXCJIbGFzdWp0ZVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlBva3VkIG7Em2tkbyBrb21lbnR1amUgVsOhxaEgcMWZw61zcMSbdmVrIG5lYm8ga29tZW50w6HFmSwgb2JkcsW+w610ZSBvem7DoW1lbsOtISA8YnIvPiA8Yj5Qb3puw6Fta2E6PC9iPiBVcG96b3JuxJtuw60gamUgemFzbMOhbm8gdMOpxb4gcG9rdWQgbsSba2RvIDxiPmVkaXR1amU8L2I+IHN2xa9qIGtvbWVudMOhxZkuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIlBvem7DoW1rYVwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiT2JkcsW+w610ZSB1cG96b3JuxJtuw60ga2R5xb4gdsOhcyBuxJtrZG8gemHEjW5lIHNsZWRvdmF0LCBuZWJvIHNsZWRvdsOhbsOtIHpydcWhw60hXCIsXG5cdFwiTUVOVElPTlNcIjogXCJabcOtbmt5XCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlBva3VkIHbDoXMgbsSba2RvIHptw61uw60gdiBwxZnDrXNwxJt2a3Uva29tZW50w6HFmWksIG9iZHLFvsOtdGUgdXBvem9ybsSbbsOtIVwiLFxuXHRcIlJFU1RFRU1cIjogXCJSZWJsb2dcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJQb2t1ZCBuxJtrZG8gcmVzdGVlbXVqZSB2w6HFoSBwxZnDrXNwxJt2ZWssIGRvc3RhbmV0ZSBvem7DoW1lbsOtIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiS29uZmlndXJhY2VcIixcblx0XCJWT1RJTkdcIjogXCJIbGFzb3bDoW7DrVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiVsOhaGEgaGxhc3UgbmVibyBwcm9jZW50byBvdmxpdsWIdWplIGhsYXNvdmFjw60gc8OtbHUgYXBsaWthY2UsIHRha8W+ZSBtxa/FvmV0ZSByZWd1bG92YXQgdsO9xaFpIG9kbcSbbnkgdmHFoWVobyBobGFzb3bDoW7DrS4gPGJyLz48YnIvPjxiPlBvem7DoW1rYTo8L2I+IFRvIG92bGl2bsOtIHbDoWh1IGhsYXN1L3Byb2NlbnRvIGkgcMWZaSBobGFzb3bDoW7DrSBwcm90aSBhIGplIHRvIHBsYXRuw6kgdiBjZWzDqSBhcGxpa2FjaS5cIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIkRvcG9ydcSNZW7DqVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlVsb8W+aXQgem3Em255XCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvcm1hY2UgbyB2b2xpxI1pXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiVsOtdGVqdGUgenDEm3QhXCIsXG5cdFwiTE9HSU5fMVwiOiBcIlBybyBwb2tyYcSNb3bDoW7DrSBzZSBwxZlpaGxhxaF0ZSBzdsO9bSB1xb5pdmF0ZWxza8O9bSBqbcOpbmVtIGEgaGVzbGVtLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJPZGVzw61sYWPDrSBrbMOtxI0gamUgdXLEjWVuIHBybyB2eXN0YXZvdmFuw60gcMWZw61zcMSbdmvFrywga29tZW50w6HFmWUsIGhsYXNvdsOhbsOtLCBzbGVkb3bDoW7DrS5cIixcblx0XCJMT0dJTl8zXCI6IFwiQWt0aXZuw60ga2zDrcSNIGplIHVyxI1lbiBwcm8gcMWZZXZvZHkgYSBha3R1YWxpemFjaSBwcm9maWxvdsOpaG8gb2Jyw6F6a3UuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIlXFvml2YXRlbG92eSBwxZlpaGxhxaFvdmFjw60gw7pkYWplIGpzb3UgZHLFvmVueSBsb2vDoWxuxJsgdiBwxZnDrXN0cm9qaS4gUG8gb2RobMOhxaFlbsOtIGpzb3Ugb2RzdHJhbsSbbnkhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTmVtw6F0ZSDDusSNZXQ/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJaxZlpxI90ZSBzaSDDusSNZXRcIixcblx0XCJDQU5DRUxcIjogXCJacnXFoWl0XCIsXG5cdFwiQURWQU5DRURcIjogXCJQb2tyb8SNaWzDvVwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJBa3Rpdm7DrSBzb3Vrcm9tw70ga2zDrcSNXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJPZGVzw61sYWPDrSBzb3Vrcm9tw70ga2zDrcSNXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJIbGF2bsOtIGhlc2xvXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJVxb5pdmF0ZWxza8OpIGptw6lub1wiLFxuXHRcIkNBUkRfVklFV1wiOiBcIlpvYnJhemVuw60ga2FydGFcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJab2JyYXplbsOtIGtvbXBha3RcIixcblx0XCJTRUFSQ0hcIjogXCJIbGVkYXRcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIlZsb8W+IMSNbMOhbmVrXCIsXG5cdFwiUkVQTFlUT1wiOiBcIk9kcG92xJt6dGVcIixcblx0XCJQT1NUXCI6IFwiT2Rlc2xhdFwiLFxuXHRcIlBSRVZJRVdcIjogXCJOw6FobGVkXCIsXG5cdFwiREVGQVVMVFwiOiBcIk5hc3RhdmVuw60gNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIjEwMCUgU3RlZW0gUG93ZXJcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIk9kbcOtdG5vdSB2w71wbGF0dVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiVXNjaG92YXQgbmEgcG96ZMSbamlcIixcblx0XCJDTEVBUlwiOiBcIlZ5xI1pc3RpdFwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIk9kZXNsYXQgb2JzYWhcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJLb21lbnRvdmF0IG9ic2FoXCIsXG5cdFwiVElUTEVcIjogXCJOYWRwaXNcIixcblx0XCJUQUdTXCI6IFwixaB0w610a3lcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJOZXNob2R1amUgc2VcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlBvdHZyxI90ZSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJOZXNwcsOhdm7DvVwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIsO6dm9kbsOtIHDFmcOtc3DEm3Zla1wiLFxuXHRcIlNFVF9QSU5cIjogXCJOYXN0YXZ0ZSBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJWbG/FvnRlIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIlVyxI1pdMSbP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVibG9nIGplIG5ldnJhdG7DvSwgcMWZZWpldGUgc2kgcG9rcmHEjW92YXQ/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiQ2h5YmEgb2Rlc2zDoW7DrSwgemt1c3RlIHpub3Z1IVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLDmnNwxJtjaFwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUmVibG9nb3ZhbsO9IHDFmcOtc3DEm3ZlayFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiUMWZaWhsw6HFoWVuw60gc2VsaGFsbyEgVWppc3TEm3RlIHNlLCDFvmUganN0ZSBzZSBwxZlpaGzDoXNpbGkgaGxhdm7DrW0gaGVzbGVtLCBuZWJvIMW+ZSBqc3RlIHDFmWkgcMWZaWhsw6HFoWVuw60gemFkYWxpIE9kZXPDrWxhY8OtIGtsw63EjSwgcG9rdWQganN0ZSB6dm9saWxpIFBva3JvxI1pbMO9IHJlxb5pbS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJQxZlpaGzDocWhZW7DrSBzZWxoYWxvISBVamlzdMSbdGUgc2UsIMW+ZSBqc3RlIHNlIHDFmWlobMOhc2lsaSBobGF2bsOtbSBoZXNsZW0sIG5lYm8gxb5lIGpzdGUgcMWZaSBwxZlpaGzDocWhZW7DrSB6YWRhbGkgQWt0aXZuw60ga2zDrcSNLCBwb2t1ZCBqc3RlIHp2b2xpbGkgUG9rcm/EjWlsw70gcmXFvmltLlwiLFxuXHRcIldBUk5JTkdcIjogXCJWw71zdHJhaGFcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiSGxhc292w6Fuw60gbyBzdsSbZGPDrWNoXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJIbGFzb3ZhbCBwcm8gc3bEm2RrYVwiLFxuXHRcIkFHT1wiOiBcInDFmWVkXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJvZCB0ZcSPXCIsXG5cdFwiU0VDU1wiOiBcInZ0ZcWZaW55XCIsXG5cdFwiQV9NSU5cIjogXCJtaW51dGFcIixcblx0XCJNSU5TXCI6IFwibWludXR5XCIsXG5cdFwiQU5fSE9VUlwiOiBcImhvZGluYVwiLFxuXHRcIkhPVVJTXCI6IFwiaG9kaW55XCIsXG5cdFwiQV9EQVlcIjogXCJkZW5cIixcblx0XCJEQVlTXCI6IFwiZG55XCIsXG5cdFwiQV9NT05USFwiOiBcIm3Em3PDrWNcIixcblx0XCJNT05USFNcIjogXCJtxJtzw61jZVwiLFxuXHRcIkFfWUVBUlwiOiBcInJva1wiLFxuXHRcIllFQVJTXCI6IFwicm9reVwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWludXQgxI10ZW7DrVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJIbGFzdWp0ZSBwcm90aSBuZWJvIG96bmHEjXRlIGpha28gesOhdmFkbsOpXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiWmFjaHnFpXRlIG9icsOhemVrXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJWeWJlcnRlIG9icsOhemVrXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJOYXN0YXZ0ZSB6w6FrYXpuaWNrw6kgVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJWbG/FvnRlIG9icsOhemVrXCIsXG5cdFwiRVJST1JcIjogXCJDaHliYVwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIk5haHJhanRlIGNoeWJ1XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkZvdG9hcGFyw6F0IHpydcWhZW5cIixcblx0XCJTRVRfVVJMXCI6IFwiTmFzdGF2dGUgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIlDFmcOtbcO9IG9ka2F6IG5hIG9icsOhemVrXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJLb21lbnTDocWZIHZsb8W+ZW4hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJNYXrDoW7DrSBrb21lbnTDocWZZSBqZSBuZXZyYXRuw6kuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJPZHN0cmFuxJtuw70ga29tZW50w6HFmVwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiTmFocsOhdsOhbsOtIG9icsOhemt1XCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIk5haHLDoXbDoW7DrSBob3Rvdm9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiTmFocsOhdsOhbsOtIHNlbGhhbG9cIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJIZXNsbyBuZWJvIGptw6lubyDDusSNdHUgYnlsbyBuZXNwcsOhdm7DqVwiLFxuXHRcIklORk9cIjogXCJJbmZvcm1hY2VcIixcblx0XCJRUl9URVhUXCI6IFwiUVIga8OzZCB1bcOtc3TEm3RlIGRvIG9ibGFzdGkgcHJvIHNrZW5cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJVamlzdMSbdGUgc2UsIMW+ZSBtw6F0ZSBkb3N0YXRlxI1uw70gesWvc3RhdGVrIHBybyB0cmFuc2FrY2khXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlXFvml2YXRlbCwga3RlcsOpbXUgc2Ugc25hxb7DrXRlIHDFmWV2w6lzdCBmb25keSBuZWV4aXN0dWplIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJKc3RlIHNpIGppc3RpLCDFvmUgc2kgcMWZZWpldGUgcHJvdsOpc3QgcMWZZXZvZD9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJQb3R2cnplbsOtXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJUcmFuc2FrY2UgamUgb2Rlc8OtbMOhbmFcIixcblx0XCJGRUVEXCI6IFwiWmRyb2pcIixcblx0XCJUUkVORElOR1wiOiBcIlYgdHJlbmR1XCIsXG5cdFwiSE9UXCI6IFwixb1oYXbDqVwiLFxuXHRcIk5FV1wiOiBcIk5vdsOpXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9wYWdvdmFuw6lcIixcblx0XCJWT1RFU1wiOiBcIkhsYXN5XCIsXG5cdFwiUEFZT1VUXCI6IFwiVsO9cGxhdGFcIixcblx0XCJDT01NRU5UU1wiOiBcIktvbWVudMOhxZllXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJWIHRyZW5kdSBwbyAzMCBkbsOtXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiUm96dMWZw61kaXQgcMWZw61zcMSbdmt5IGRsZVwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkN5a2x1cyB2w71wbGF0eVwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQb3RlbmNpw6FsbsOtIHbDvXBsYXRhXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJNaW51bMOhIHbDvXBsYXRhXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIkF1dG9yc2vDoSBvZG3Em25hXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiS3Vyw6F0b3Jza8OhIG9kbcSbbmFcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIsSMbMOhbmVrIGplIG9kZXNsw6FuIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJVc2Nob3ZhdCBwcm8gcG96ZMSbasWhw60gb2Rlc2zDoW7DrSFcIixcblx0XCJTQVZFRFwiOiBcIlVsb8W+ZW7DvVwiLFxuXHRcIkNMRUFSRURcIjogXCJWecSNacWhdMSbbm9cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiT3puYcSNZW7DrSBwxZnDrXNwxJt2a3UgemEgesOhdmFkbsO9IG3Fr8W+ZSBvZGVicmF0IG9kbcSbbnkgYSB1xI1pbml0IHRlbnRvIG1hdGVyacOhbCBtw6luxJsgdmlkaXRlbG7DvW0uPGJyPjxicj5Ub3RvIG96bmHEjWVuw60gYnkgbcSbbG8gYsO9dCBwb3XFvml0byBuYSBuw6FzbGVkdWrDrWPDrTogPHVsPjxsaT5wb2R2b2QgbmVibyBwbGFnacOhdG9yc3R2w608L2xpPjxsaT5wcm9qZXZ5IG5lbsOhdmlzdGkgbmVibyBpbnRlcm5ldG92w6kgdHJvbG92w6Fuw608L2xpPjxsaT56w6FtxJtybsSbIGNoeWJuw6Ega2F0ZWdvcml6YWNlIG9ic2FodSBuZWJvIHNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTGltaXQgcG/FvmFkYXZrxa8gZG9zYcW+ZW4uIFprb250cm9sdWp0ZSBvc3RhdG7DrSB0cmVuZHkvxaF0w610a3khXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiUMWZw61zcMSbdmVrIGplIG9kc3RyYW7Em24gemUgesOhbG/FvmVrIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQxZnDrXNwxJt2ZWsgamUgcMWZaWTDoW4gZG8gesOhbG/FvmVrIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVzZXRvdmF0XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJVcHJhdml0IHByb2ZpbG92w70gb2Jyw6F6ZWtcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIlVwcmF2aXQgdGl0dWxuw60gb2Jyw6F6ZWtcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJaYWRlanRlIEFrdGl2bsOtIHNvdWtyb23DvSBrbMOtxI0sIHBva3VkIGpzdGUgdnlicmFsaSBwb2tyb8SNaWzDvSBtw7NkIHDFmcOtc3R1cHUhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiVMOtbXRvIHJlc2V0dWpldGUgcHJvZmlsb3bDvSBvYnLDoXplayB1xb5pdmF0ZWxlIVwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIlTDrW10byByZXNldHVqZXRlIHRpdHVsbsOtIG9icsOhemVrIHXFvml2YXRlbGUhXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBa3R1YWxpemFjZSBzZXJ2ZXJ1IHZ5xb5hZHVqZSByZXN0YXJ0IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJOYXN0YXZlbsOtIGpzb3UgYWt0dWFsaXpvdsOhbmEuXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiSmF6eWt5XCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJaZGUgbcWvxb5ldGUgem3Em25pdCBqYXp5ayBhcGxpa2FjZS5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiVGF0byBvcGVyYWNlIHZ5xb5hZHVqZSBwxZlpaGzDocWhZW7DrSB1xb5pdmF0ZWxlIGhsYXZuw61tIGhlc2xlbSwgQWt0aXZuw61tL09kZXPDrWxhY8OtbSBrbMOtxI1lbS4gUHJvc8OtbSBwxZlpaGxhxaF0ZSBzZSBhIG9wYWt1anRlIHBva3VzLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxlcmllXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiUMWZZWxvxb5pbGlcIixcblx0XCJTSEFSRVwiOiBcIkFrY2llXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJUcmhcIixcblx0XCJFWENIQU5HRVwiOiBcIkJ1cnphXCIsXG5cdFwiRFJBRlRTXCI6IFwiS29uY2VwdHlcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQxZnDrXNwxJt2ZWsgamUgeiBrb25jZXB0xa8gb2RzdHJhbsSbbiAhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlDFmcOtc3DEm3ZlayBqZSBwxZlpZMOhbiBkbyBrb25jZXB0xa8hXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIlBybyB6b2JyYXplbsOtIG1vxb5ub3N0w60gcMWZZWplxI8gdmxldm9cIixcblx0XCJNQU5BR0VcIjogXCJTcHJhdm92YXRcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiT2JyYXogamUgb2RzdHJhbsSbblwiLFxuXHRcIkNPUFlcIjogXCJLb3DDrXJvdmF0XCIsXG5cdFwiTk9fSU1BR0VcIjogXCJEb3N1ZCBqc3RlIG5lbmFocsOhbCDFvsOhZG7DvSBvYnJhei5cIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlBybyBvYm5vdmVuw60gemF0w6FobmkgZG9sxa9cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiRXh0ZXJuw60gYXBsaWthY2VcIixcblx0XCJQTFVHSU5TXCI6IFwiUMWZw61kYXZuw6kgbW9kdWx5XCIsXG5cdFwiU1VHR0VTVFwiOiBcIk7DoXZyaFwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiSmnFviBicnp5IGNoeXN0w6FtZVwiLFxuXHRcIkNIQUlOXCI6IFwiQ2hhaW5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiWmRlIG3Fr8W+ZXRlIHptxJtuaXQgYmxvY2tjaGFpbiBuZWJvIHbDvWNob3rDrSBwbGF0Zm9ybXUuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJNxJtuYVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJaZGUgbcWvxb5ldGUgem3Em25pdCBzdm9qaSB2w71jaG96w60gbcSbbnUuIFYgdMOpdG8gbcSbbsSbIHNlIHBvdMOpIGJ1ZG91IHpvYnJhem92YXQgb2RtxJtueSB6YSBwxZnDrXNwxJt2a3kva29tZW50w6HFmWUuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+U2V6bmFtIGZ1bmtjw608L2I+IDxicj4tUMWZw61zdHVwIGsgamVkaW5lxI1uw71tIMSNbMOhbmvFr20gdiBrYcW+ZMOpbSB0w6ltYXR1LCBrdGVyw70ganNvdSB6YWrDrW1hdsOpIGtlIMSNdGVuw608YnI+QW5nYcW+b3bDoW7DrSBzZSBzIGF1dG9yeSBrb21lbnRvdsOhbsOtbSBhIGRpc2t1dG92w6Fuw61tIHTDqW1hdC48YnI+SGxhc292w6Fuw61tIHDFmcOtc3DEm3Zrxa8gb2RtxJvFiG92YXQgYXV0b3J5IHN0ZWpuxJsgdGFrIGpha28gesOtc2vDoXZhdCBrdXLDoXRvcnNrw6kgb2RtxJtueS4gPGJyPlB1Ymxpa292YXQgxI1sw6Fua3ksIHDFmcOtc3DEm3ZreSBkbyBibG9ndSBhIGhvc3RvdmF0IGplIHpkYXJtYSwgZG9zdMOhdmF0IG9kbcSbbnkgemEgcHVibGlrb3bDoW7DrSBhIHrDrXNrw6F2YXQgc3RvdXBlbmNlLiA8YnI+UHPDoXQgxI1sw6Fua3kga2Rla29saXYgYSBrZHlrb2xpdiBhIG3DrXQgbW/Fvm5vc3QgdWxvxb5pdCBqZWppY2gga29uY2VwdHkgcHJvIHBvemTEm2rFocOtIHB1Ymxpa2FjaS4gPGJyPlVsb8W+aXQgc2kgb2Jsw61iZW7DqSDEjWzDoW5reSBkbyB6w6Fsb8W+ZWsgcHJvIHBvemTEm2rFocOtIHDFmWXEjXRlbsOtLiA8YnI+VsO9bcSbbmEgbmVibyBwcm9wbGFjZW7DrSB2YcWhZWhvIHbDvWTEm2xrdS4gPGJyPk1vxb5ub3N0IHBvc2xhdCB2YcWhZSBwcm9zdMWZZWRreSBqYWvDqW11a29saXYgYXV0b3JvdmksIHXFvml2YXRlbG92aSwgcMWZw610ZWxpLCBzdG91cGVuY8WvbSBhdGQuPGJyPk7DoXNsZWRvdmF0IHphasOtbWF2w6kgYXV0b3J5LCBibG9nZ2VyeS4gPGJyPlByb2hsw63FvmV0IHNpIHDFmcOtc3DEm3ZreSBzdG91cGVuY8WvIGEgYXV0b3LFrywga3RlcsOpIHNsZWR1amV0ZS4gPGJyPkRvc3TDoXZhdCBvem7DoW1lbsOtLCBhYnlzdGUgesWvc3RhbGkgdiBrb250YWt0dSBzZSBzdsO9bWkgc3RvdXBlbmNpIGEgZGlza3V6ZW1pLCB2ZSBrdGVyw71jaCBqc3RlIHphcG9qZW48YnI+UHJvaGxlZMOhdmF0IHphasOtbWF2w6kgdGFneS9rYXRlZ29yaWUgxI1sw6Fua8WvIGEgemFqw61tYXbDqSBhdXRvcnkuIDxicj5QxZlpenDFr3NvYnRlIHNpIHN2xa9qIHByb2ZpbC4gPGJyPkEgbW5vaGVtIHbDrWNlIGZ1bmtjw60sIGt0ZXLDqSBwxZlpamRvdSA8YnI+PGJyPjxiPkJlenBlxI1ub3N0PC9iPiA8YnI+MS4gQXBsaWthY2UgbmVtw6EgcMWZw61zdHVwIGFuaSBuZWRyxb7DrSBwZW7Em8W+bsOtIHByb3N0xZllZGt5IHXFvml2YXRlbMWvLiA8YnI+Mi4gQXBsaWthY2UgbmFiw616w60gbW9kZWwgemFiZXpwZcSNZW7DrSBuYSBzdHJhbsSbIGtsaWVudGEgc2Ugc291a3JvbcO9bWkga2zDrcSNaSB1bcOtc3TEm27DqSBsb2vDoWxuxJsgYSBuaWtkeSBqZSBuZW9kZXPDrWzDoSBuYSBzZXJ2ZXIsIGpzdGUgc2FtaSB6b2Rwb3bEm2Ruw60gemEgesOhbG9ob3bDoW7DrSBWYcWhaWNoIGhlc2VsLiA8YnI+My4gQXBsaWthY2UgbmFiw616w60gamVkbm9kdWNow6ksIGF0cmFrdGl2bsOtIHXFvml2YXRlbHNrw6kgcm96aHJhbsOtLiA8YnI+NC4gQXBsaWthY2UgbmFiw616w60gZGFsxaHDrSB2cnN0dnUgemFiZXpwZcSNZW7DrSBwb21vY8OtIHBpbi1rw7NkdSA8YnI+PGJyPmVTdGVlbSBwb2Rwb3J1amUgcGxhdGZvcm15IFN0ZWVtIGEgR29sb3MuIDxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiWmFrbGFkYXRlbCBhIGhsYXZuw60gdsO9dm9qw6HFmVwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiUMWZaWRhdCDDusSNZXRcIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtYVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkVzY3JvdyB6cHJvc3TFmWVka292YXRlbFwiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIktvbmXEjW7DvSB0ZXJtw61uIHJhdGlmaWthY2VcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyBleHBpcmFjZVwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgcG9wbGF0ZWtcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgcG9kbcOtbmt5XCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIk5vxI1uw60gcmXFvmltXCIsXG5cdFwiREFZX01PREVcIjogXCJEZW5uw60gcmXFvmltXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiWm9icmF6aXQgcGxuw70ga29udGV4dFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJVxb5pdmF0ZWwgbmVuYWxlemVuXCIsXG5cdFwiQVBQUk9WRVwiOiBcIlNjaHbDoWxpdFwiLFxuXHRcIkRJU1BVVEVcIjogXCJPZHBvcm92YXRcIixcblx0XCJSRUxFQVNFXCI6IFwiVnlkYXRcIixcblx0XCJGUk9NXCI6IFwiT2RcIixcblx0XCJJRFwiOiBcImlkXCIsXG5cdFwiU1VCTUlUXCI6IFwiT2Rlc2xhdFwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiUMWZw61qZW1jZVwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiVW3DrXN0xJtuw61cIixcblx0XCJXRUJTSVRFXCI6IFwiV2ViXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiWm9icmF6b3ZhbsOpIGptw6lub1wiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJTdGFydHNlaXRlXCIsXG5cdFwiTE9HSU5cIjogXCJBbm1lbGRlblwiLFxuXHRcIkxPR09VVFwiOiBcIkFibWVsZGVuXCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbFwiLFxuXHRcIkZPTExPV1wiOiBcIkZvbGdlblwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIkxlc2V6ZWljaGVuXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLDnGJlcnRyYWdlblwiLFxuXHRcIk1BUktFVFwiOiBcIk1hcmt0XCIsXG5cdFwiU0VUVElOR1NcIjogXCJFaW5zdGVsbHVuZ2VuXCIsXG5cdFwiQUJPVVRcIjogXCJJbmZvXCIsXG5cdFwiQUJPVVRfMVwiOiBcImRpZSBQbGF0dGZvcm0sIGJlaSBkZXIgamVkZXIgZsO8ciBzZWluZSBJbmhhbHRlIHZlcmfDvHRldCB3aXJkIVwiLFxuXHRcIkFCT1VUXzJcIjogXCJ3aXJkIHVudGVyc3TDvHR6dCBkdXJjaCBkaWUge3twbGF0Zm9ybW5hbWV9fSBQbGF0dGZvcm0uIEFud2VuZHVuZyBlcnN0ZWxsdCB2b25cIixcblx0XCJBQk9VVF8zXCI6IFwidW5kIGlzdCBlaW5lIG1vYmlsZSBPcGVuIFNvdXJjZSBBbndlbmR1bmcsIGRpZSBkdXJjaCBkaWUgQ29tbXVuaXR5IHVudGVyc3TDvHR6dCB3aXJkLiBEaWUgQW53ZW5kdW5nIGVybGF1YnQgZGVuIFp1Z3JpZmYgYXVmIGRpZSBJbmhhbHRlIGbDvHIgZGFzIExlc2VuLCBLb21tZW50aWVyZW4sIEFic3RpbW1lbiwgUG9zdGVuLCDDnGJlcnRyYWdlbiB2b24gRWlua8O8bmZ0ZW4gZXRjLiBEaWUgRnVua3Rpb25lbiB3ZXJkZW4gZHVyY2ggZGllIHt7cGxhdGZvcm1uYW1lfX0gQmxvY2tjaGFpbiB1bmQge3tzaXRlbmFtZX19IGJlcmVpdGdlc3RlbGx0LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBEaWUgQW53ZW5kdW5nIGdyZWlmdCBuaWVtYWxzIGF1ZiBJaHJlIE1pdHRlbCB6dS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gRGllIEFud2VuZHVuZyBudXR6dCBlaW4gQ2xpZW50LWJhc2llcnRlcyBTaWNoZXJoZWl0c2tvbnplcHQsIGRhc3MgYXVmIFNjaGzDvHNzZWxuIGJhc2llcnQsIGRpZSBsb2thbCB2b3JoYW5kZW4gc2luZCB1bmQgbmllbWFscyBhbiBlaW5lbiBTZXJ2ZXIgw7xiZXJ0cmFnZW4gd2VyZGVuLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBEaWUgQW53ZW5kdW5nIGJpZXRldCBlaW4gc2ltcGxlcywgYXR0cmFrdGl2ZXMgSW50ZXJmYWNlLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBEaWUgQW53ZW5kdW5nIGZyYWd0IG5pZW1hbHMgbmFjaCBwZXJzw7ZubGljaGVuIERhdGVuLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJHb29kLUthcm1hIGFscyBaZXVnZSBhYnN0aW1tZW5cIixcblx0XCJBQk9VVF85XCI6IFwiS29udGFrdC9GZWVkYmFjazpcIixcblx0XCJBQk9VVF8xMFwiOiBcIldlaXRlcmUgSW5mb3JtYXRpb25lbjpcIixcblx0XCJSRU1PVkVcIjogXCJFbnRmZXJuZW5cIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIk1hcmt0YW5zaWNodFwiLFxuXHRcIlBSSUNFXCI6IFwiUHJlaXNcIixcblx0XCJBTU9VTlRcIjogXCJNZW5nZVwiLFxuXHRcIlRPVEFMXCI6IFwiR2VzYW10XCIsXG5cdFwiTk9PUkRFUlNcIjogXCJLZWluZSBvZmZlbmVuIE9yZGVyXCIsXG5cdFwiREFURVwiOiBcIkRhdHVtXCIsXG5cdFwiQlVZXCI6IFwiS2F1ZmVuXCIsXG5cdFwiU0VMTFwiOiBcIlZlcmthdWZlblwiLFxuXHRcIk9QRU5cIjogXCJPZmZlblwiLFxuXHRcIkhJU1RPUllcIjogXCJIaXN0b3JpZVwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiRWJlbmZhbGxzIGZvbGdlblwiLFxuXHRcIkZPTExPV0VEXCI6IFwiU2llIGZvbGdlbiBudW4gZGllc2VtIE51dHplclwiLFxuXHRcIlVORk9MTE9XXCI6IFwiTmljaHQgbWVociBmb2xnZW5cIixcblx0XCJGT0xMT1dJTkdcIjogXCJTaWUgZm9sZ2VuIGRpZXNlbSBOdXR6ZXJcIixcblx0XCJGT0xMT1dFUlNcIjogXCJQZXJzb25lbiwgZGllIElobmVuIGZvbGdlblwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJEdXJjaHN1Y2hlbiBkZXIgTnV0emVyLCBkaWUgSWhuZW4gZm9sZ2VuXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIkR1cmNoc3VjaGVuIGRlciBOdXR6ZXIsIGRlbmVuIFNpZSBmb2xnZW5cIixcblx0XCJCWVwiOiBcInZvblwiLFxuXHRcIklOXCI6IFwiaW5cIixcblx0XCJNRU5VXCI6IFwiTWVuw7xcIixcblx0XCJCT09LTUFSS1wiOiBcIkxlc2V6ZWljaGVuXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVibG9nXCIsXG5cdFwiVVBWT1RFXCI6IFwiVXB2b3RlXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJEb3dudm90ZVwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJEb3dudm90ZSBlbnRmZXJuZW5cIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlVwdm90ZSBlbnRmZXJuZW5cIixcblx0XCJSRVBMWVwiOiBcIkFudHdvcnRlblwiLFxuXHRcIkVESVRcIjogXCJFZGl0aWVyZW5cIixcblx0XCJQT1NUXzFcIjogXCJOYWNoIGxpbmtzIHdpc2NoZW4gdW0gS29tbWVudGFyZSB6dSBzZWhlblwiLFxuXHRcIlBPU1RfMlwiOiBcIkF1ZiBLb21tZW50YXJlIHRpcHBlbiB1bSBkZXNzZW4gQW50d29ydGVuIHp1IHNlaGVuXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wdGlvbmVuXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVzdGVlbWVkIHZvblwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIkhpZXIgZ2lidCBlcyBub2NoIG5pY2h0cyB6dSBzZWhlbi4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiS29udG9zdGFuZFwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIGhhbmRlbGJhcmUgVG9rZW5zIGRpZSB6dSBqZWRlciBaZWl0IMO8YmVydHJhZ2VuIHdlcmRlbiBrw7ZubmVuLiB7e3BsYXRmb3JtbmFtZX19IGthbm4gaW4ge3twbGF0Zm9ybXBvd2VyfX0ga29udmVydGllcnQgd2VyZGVuLiBEaWVzZXIgUHJvemVzcyBoZWnDn3QgXFxcInBvd2VyaW5nIHVwXFxcIi5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgdG9rZW5zIGRpZSBzaWNoIGF1dG9tYXRpc2NoIHZlcm1laHJlbiwgd2VubiBTaWUgYmVzZXNzZW4gd2VyZGVuIHVuZCBiZWVpbmZsdXNzZW4sIHdpZSB2aWVsIElocmUgU3RpbW1lIHdlcnQgaXN0LiBEZXN0byBtZWhyIFNpZSBiZXNpdHplbiwgZGVzdG8gbWVociBFaW5mbHVzcyBoYXQgSWhyZSBTdGltbWUuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW5zIG1pdCBlaW5lbSBXZXJ0IHZvbiBldHdhIHt7cGxhdGZvcm1zdW5pdH19IGluIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiR2VzY2jDpHR6dGVyIFdlcnRcIixcblx0XCJQUk9GSUxFXzRcIjogXCJEZXIgZ2VzY2jDpHR6dGUgV2VydCBiYXNpZXJ0IGF1ZiBlaW5lbSA3LVRhZ2UtRHVyY2hzY2huaXR0c3dlcnQgdm9uIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlRyYW5zYWt0aW9ucyBIaXN0b3JpZVwiLFxuXHRcIlBPU1RJTkdcIjogXCJCZWl0cmFnXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiRGVyIFxcXCJwb3N0aW5nIGtleVxcXCIgd2lyZCBmw7xyIGRhcyBWZXLDtmZmZW50bGljaGVuIHVuZCBBYnN0aW1tZW4gYmVuw7Z0aWd0LiBFciBzb2xsdGUgc2ljaCB2b20gXFxcImFjdGl2ZSBrZXlcXFwiIHVuZCB2b20gXFxcIm93bmVyIGtleVxcXCIgdW50ZXJzY2hlaWRlbi5cIixcblx0XCJPV05FUlwiOiBcIkJlc2l0emVyXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiRGVyIFxcXCJvd25lciBrZXlcXFwiIGlzdCBkZXIgSGF1cHRzY2hsw7xzc2VsIGbDvHIgZGVuIEFjY291bnQgdW5kIHdpcmQgYmVuw7Z0aWd0LCB1bSBhbmRlcmUgU2NobMO8c3NlbCB6dSDDpG5kZXJuLiBEZXIgXFxcInByaXZhdGUga2V5XFxcIiBvZGVyIGRhcyBQYXNzd29ydCBzb2xsdGVuIG51ciBvZmZsaW5lIHZlcmbDvGdiYXIgc2Vpbi5cIixcblx0XCJBQ1RJVkVcIjogXCJBa3RpdlwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkRlciBcXFwiYWN0aXZlIGtleVxcXCIgd2lyZCBiZW51dHp0LCB1bSDDnGJlcnRyYWd1bmdlbiBkdXJjaHp1ZsO8aHJlbiBvZGVyIEdlYm90ZSBhdWYgZGVtIE1hcmt0IHp1IHBsYXR6aWVyZW4uXCIsXG5cdFwiTUVNT1wiOiBcIk5vdGl6XCIsXG5cdFwiUFJPRklMRV84XCI6IFwiRGVyIFxcXCJtZW1vIGtleVxcXCIgd2lyZCBiZW7DtnRpZ3QsIHVtIE1lbW9zIHp1IGxlc2VuIHVuZCB6dSBzcGVpY2hlcm4uXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIkJlaXRyw6RnZVwiLFxuXHRcIlJFUExJRVNcIjogXCJBbnR3b3J0ZW5cIixcblx0XCJXQUxMRVRcIjogXCJCcmllZnRhc2NoZVwiLFxuXHRcIlRBR1wiOiBcIlRhZ1wiLFxuXHRcIlVTRVJcIjogXCJCZW51dHplclwiLFxuXHRcIkNMT1NFXCI6IFwiU2NobGllw59lblwiLFxuXHRcIlRPXCI6IFwiRW1wZsOkbmdlclwiLFxuXHRcIkFTU0VUXCI6IFwiWnVzYXR6XCIsXG5cdFwiU0VORFwiOiBcIlNlbmRlblwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU2ljaGVyaGVpdFwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIlZlcmbDvGdiYXJcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIsOWZmZlbnRsaWNoZSBOb3RpelwiLFxuXHRcIlRPX0RFU0NcIjogXCJCZW51dHplciB6LkIuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpblwiLFxuXHRcIlBJTl9URVhUXCI6IFwiRGVyIFBJTiBkaWVudCBkZXIgU2ljaGVyaGVpdCBkZXIgQW53ZW5kdW5nLCBzb3dpZSBkZXJlbiBEYXRlbi4gPGJyLz48YnIvPjxiPkhpbndlaXM6PC9iPiBOYWNoIEFrdGl2aWVydW5nIHN0ZWhlbiBtYXhpbWFsIDQgQW5tZWxkZXZlcnN1Y2hlIHp1ciBWZXJmw7xndW5nLiBEYW5hY2ggd2VyZGVuIGRpZSBEYXRlbiBkZXMgYWt0dWVsbCBhbmdlbWVsZGV0ZW4gTnV0emVycyBnZWzDtnNjaHQgdW5kIGRpZSBBbndlbmR1bmcga2FubiB3aWVkZXIgbm9ybWFsIGdlbnV0enQgd2VyZGVuLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJCZW5hY2hyaWNodGlndW5nZW5cIixcblx0XCJWT1RFX1RFWFRcIjogXCJTaWUgd2VyZGVuIGluZm9ybWllcnQsIHNvYmFsZCBqZW1hbmQgZsO8ciBJaHJlIEJlaXRyw6RnZSBhYmdlc3RpbW10IGhhdCEgPGJyLz4gPGI+SGlud2Vpczo8L2I+IERpZSBOb3RpZmlrYXRpb24gZ2lidCBhdWZzY2hsdXNzIMO8YmVyIGRpZSBBcnQgZGVyIEFic3RpbW11bmcgKFBvc2l0aXYsIE5lZ2F0aXYsIHdpZWRlciBlbnRmZXJudCkgdW5kIGRpZSBHZXdpY2h0dW5nIGRlciBTdGltbWUuXCIsXG5cdFwiVk9URVwiOiBcIkFic3RpbW1lblwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlNpZSB3ZXJkZW4gaW5mb3JtaWVydCwgc29iYWxkIGplbWFuZCBhdWYgSWhyZSBCZWl0csOkZ2Ugb2RlciBLb21tZW50YXJlIGFudHdvcnRldCE8YnIvPiA8Yj5IaW53ZWlzOjwvYj4gU2llIHdlcmRlbiBhdWNoIGJlaW0gw4RuZGVybiBlaW5lcyBCZWl0cmFncy9Lb21tZW50YXJzIGVybmV1dCBpbmZvcm1pZXJ0LlwiLFxuXHRcIkNPTU1FTlRcIjogXCJLb21tZW50YXJcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIlNpZSB3ZXJkZW4gYmVuYWNocmljaHRpZ3QsIHNvYmFsZCBJaG5lbiBqZW1hbmQgZm9sZ3Qgb2RlciBuaWNodCBtZWhyIGZvbGd0IVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiRXJ3w6RobnVuZ2VuXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlNpZSB3ZXJkZW4gYmVuYWNocmljaHRpZ3QsIHNvYmFsZCBTaWUgdm9uIGplbWFuZGVuIGluIEtvbW1lbnRhcmVuIG9kZXIgQmVpdHJhZ2VuIGVyd8OkaG50IHdlcmRlbiFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiU2llIHdlcmRlbiBiZW5hY2hyaWNodGlndCBzb2JhbGQgamVtYW5kIElocmVuIFBvc3QgZXJuZXV0IHZlcsO2ZmZlbnRsaWNodCBoYXQhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJFaW5zdGVsbHVuZ2VuXCIsXG5cdFwiVk9USU5HXCI6IFwiQWJzdGltbXVuZ1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiRGFzIEdld2ljaHQgLyBkZXIgcHJvemVudHVhbGUgQW50ZWlsIGRlciBTdGltbWUgYmVlaW5mbHVzc3QgZGllIE1lbmdlIGRlciBWZXJnw7x0dW5nIGbDvHIgZGVuIEF1dG9yLiA8YnIvPjxici8+PGI+SGlud2Vpczo8L2I+IERpZXNlIEVpbnN0ZWxsdW5nIMOkbmRlcnQgYXVjaCBkaWUgR2V3aWNodHVuZy8gZGVuIHByb3plbnR1YWxlbiBBbnRlaWwgZsO8ciBuZWdhdGl2ZSBTdGltbWVuLiBEaWVzZSBFaW5zdGVsbHVuZyB3aXJkIGluIGRlciBnZXNhbXRlbiBBbndlbmR1bmcgdmVyd2VuZGV0LlwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiRW1wZm9obGVuXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiw4RuZGVydW5nZW4gc3BlaWNoZXJuXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJBYnN0aW1tdW5nc2luZm9ybWF0aW9uZW5cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJXaWxsa29tbWVuIHp1csO8Y2shXCIsXG5cdFwiTE9HSU5fMVwiOiBcIk1lbGRlbiBTaWUgc2ljaCBtaXQgSWhyZW0gQmVudXR6ZXJuYW1lbiB1bmQgUGFzc3dvcnQgYW4sIHVtIGZvcnR6dWZhaHJlbi5cIixcblx0XCJMT0dJTl8yXCI6IFwiRGVyIFxcXCJQb3N0aW5nIGtleVxcXCIgd2lyZCBmw7xyIGRhcyBWZXLDtmZmZW50bGljaGVuIHZvbiBCZWl0cmFnZW4sIEtvbW1lbnRhcmVuIHVuZCBBYnN0aW1tdW5nZW4sIHNvd2llIGRlbSBGb2xnZW4gdm9uIE51dHplcm4gYmVuw7Z0aWd0LlwiLFxuXHRcIkxPR0lOXzNcIjogXCJEZXIgXFxcIkFjdGl2ZSBrZXlcXFwiIHdpcmQgZsO8ciBkaWUgw5xiZXJ0cmFndW5nIHVuZCBkYXMgYWt0dWFsaXNpZXJlbiBkZXMgUHJvZmlsYmlsZHMgYmVuw7Z0aWd0LlwiLFxuXHRcIkxPR0lOXzRcIjogXCJadWdhbmdzZGF0ZW4gd2VyZGVuIGxvY2FsIGltIEdlcsOkdCBnZXNwZWljaGVydCB1bmQgbmFjaCBkZW0gTG9nb3V0IGdlbMO2c2NodCFcIixcblx0XCJET05UX0hBVkVcIjogXCJOb2NoIGtlaW5lbiBBY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiSmV0enQgcmVnaXN0cmllcmVuXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQWJicmVjaGVuXCIsXG5cdFwiQURWQU5DRURcIjogXCJFcndlaXRlcnRcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQWt0aXZlciBwcml2YXRlciBadWdhbmdzc2NobMO8c3NlbFwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUHJpdmF0ZXIgWnVnYW5nc3NjaGzDvHNzZWwgZsO8ciBkYXMgVmVyw7ZmZmVudGxpY2hlbiB2b24gSW5oYWx0ZW5cIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIk1hc3Rlci0gL0hhdXB0LVBhc3N3b3J0XCIsXG5cdFwiVVNFUk5BTUVcIjogXCJCZW51dHplcm5hbWVcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJLYXJ0ZW4tQW5zaWNodFwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIktvbXBha3RhbnNpY2h0XCIsXG5cdFwiU0VBUkNIXCI6IFwiU3VjaGVuXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJCZWl0cmFnIGVyc3RlbGxlblwiLFxuXHRcIlJFUExZVE9cIjogXCJBbnR3b3J0ZW5cIixcblx0XCJQT1NUXCI6IFwiVmVyw7ZmZmVudGxpY2hlblwiLFxuXHRcIlBSRVZJRVdcIjogXCJWb3JzY2hhdVwiLFxuXHRcIkRFRkFVTFRcIjogXCJTdGFuZGFyZCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgZXJow7ZoZW4gbWl0IDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIkF1ZiBkaWUgQXVzemFobHVuZyB2ZXJ6aWNodGVuXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJGw7xyIGVpbmVuIHNww6R0ZXJlbiBaZWl0cHVua3Qgc3BlaWNoZXJuXCIsXG5cdFwiQ0xFQVJcIjogXCJMw5ZTQ0hFTlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIkluaGFsdCB2ZXLDtmZmZW50bGljaGVuXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiSW5oYWx0IGtvbW1lbnRpZXJlblwiLFxuXHRcIlRJVExFXCI6IFwiVGl0ZWxcIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIktFSU5FIMOcQkVSRUlOU1RJTU1VTkdcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlBJTiBiZXN0w6R0aWdlblwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIkZBTFNDSFwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIsO2ZmZuZSBCZWl0cmFnXCIsXG5cdFwiU0VUX1BJTlwiOiBcIlNldHplbiBTaWUgSWhyZW4gUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiQml0dGUgZ2ViZW4gU2llIElocmVuIFBJTiBlaW5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJTaW5kIFNpZSBzaWNoZXI/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJEYXMgbmV1IHZlcsO2ZmZlbnRsaWNoZW4ga2FubiBuaWNodCByw7xja2fDpG5naWcgZ2VtYWNodCB3ZXJkZW4sIHdvbGxlbiBTaWUgd2VpdGVyIG1hY2hlbj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJGZWhsZXIgYmVpbSB2ZXLDtmZmZW50bGljaGVuLCBiaXR0ZSB2ZXJzdWNoZW4gU2llIGVzIGVybmV1dCFcIixcblx0XCJTVUNDRVNTXCI6IFwiRXJmb2xncmVpY2hcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIk5ldSB2ZXLDtmZmZW50bGljaHQhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkFubWVsZHVuZyBmZWhsZ2VzY2hsYWdlbiEgQml0dGUgc3RlbGxlbiBTaWUgc2ljaCBzaWNoZXIsIGRhc3MgU2llIGRhcyBNYXN0ZXItUGFzc3dvcnQgb2RlciwgZsO8ciBkZW4gZXJ3ZWl0ZXJ0ZW4gQW5tZWxkZS1Nb2R1cywgZGVuIGJlcmVpdGdlc3RlbGx0ZW4gXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgdmVyd2VuZGVuLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkFubWVsZHVuZyBmZWhsZ2VzY2hsYWdlbiEgQml0dGUgc3RlbGxlbiBTaWUgc2ljaCBzaWNoZXIsIGRhc3MgU2llIGRhcyBNYXN0ZXItUGFzc3dvcnQgb2RlciwgZsO8ciBkZW4gZXJ3ZWl0ZXJ0ZW4gQW5tZWxkZS1Nb2R1cywgZGVuIGJlcmVpdGdlc3RlbGx0ZW4gXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgdmVyd2VuZGVuLlwiLFxuXHRcIldBUk5JTkdcIjogXCJXYXJudW5nXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIkbDvHIgZWluZW4gV2l0bmVzcyBhYnN0aW1tZW5cIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIkVyZm9sZ3JlaWNoIGbDvHIgZWluZW4gV2l0bmVzcyBhYmdlc3RpbW10XCIsXG5cdFwiQUdPXCI6IFwic2VpdFwiLFxuXHRcIkZST01fTk9XXCI6IFwiYWIgamV0enRcIixcblx0XCJTRUNTXCI6IFwiU2VrdW5kZW5cIixcblx0XCJBX01JTlwiOiBcImVpbmUgTWludXRlXCIsXG5cdFwiTUlOU1wiOiBcIk1pbnV0ZW5cIixcblx0XCJBTl9IT1VSXCI6IFwiZWluZSBTdHVuZGVcIixcblx0XCJIT1VSU1wiOiBcIlN0dW5kZW5cIixcblx0XCJBX0RBWVwiOiBcImVpbmVuIFRhZ1wiLFxuXHRcIkRBWVNcIjogXCJUYWdlXCIsXG5cdFwiQV9NT05USFwiOiBcImVpbmVuIE1vbmF0XCIsXG5cdFwiTU9OVEhTXCI6IFwiTW9uYXRlXCIsXG5cdFwiQV9ZRUFSXCI6IFwiZWluIEphaHJcIixcblx0XCJZRUFSU1wiOiBcIkphaHJlXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4uIGxlc2VuXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIk5lZ2F0aXYgYmV3ZXJ0ZW4gb2RlciBtYXJraWVyZW5cIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJCaWxkIGF1Zm5laG1lblwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiQmlsZCBhdXN3w6RobGVuXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJFaWdlbmUgVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJCaWxkIGVpbmbDvGdlblwiLFxuXHRcIkVSUk9SXCI6IFwiRmVobGVyXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiVXBsb2FkIGZlaGxnZXNjaGxhZ2VuXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkthbWVyYSBnZXNjaGxvc3NlblwiLFxuXHRcIlNFVF9VUkxcIjogXCJVUkwgc2V0emVuXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkRpcmVrdGVyIExpbmsgenVtIEJpbGRcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIktvbW1lbnRhciBhYmdlZ2ViZW4hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJHZWzDtnNjaHRlIEtvbW1lbnRhcmUga8O2bm5lbiBuaWNodCB3aWRlcmhlcmdlc3RlbGx0IHdlcmRlbi4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIktvbW1lbnRhciBnZWzDtnNjaHRcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIkJpbGQgd2lyZCBob2NoZ2VsYWRlblwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJIb2NobGFkZW4gYWJnZXNjaGxvc3NlblwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJIb2NobGFkZW4gZmVobGdlc2NobGFnZW5cIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJQYXNzd29ydCBvZGVyIEJlbnV0emVybmFtZSBuaWNodCBrb3JyZWt0XCIsXG5cdFwiSU5GT1wiOiBcIkluZm9ybWF0aW9uXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBsYXR6aWVyZW4gU2llIGVpbmVuIFFSIGNvZGUgaW5uZXJoYWxiIGRlcyBCZXJlaWNoc1wiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIlN0ZWxsZW4gU2llIHNpY2hlciwgZGFzcyBTaWUgw7xiZXIgYXVzcmVpY2hlbmRlIE1pdHRlbCB2ZXJmw7xnZW4hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlNpZSB2ZXJmw7xnZW4gbmljaHQgw7xiZXIgYXVzcmVpY2hlbmRlIE1pdHRlbCBmw7xyIGRpZXNlIEFrdGlvbiFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiV29sbGVuIFNpZSB3aXJrbGljaCDDvGJlcnRyYWdlbj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJCZXN0w6R0aWd1bmdlblwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiRGllIFRyYW5zYWt0aW9uIHd1cmRlIMO8YmVydHJhZ2VuXCIsXG5cdFwiRkVFRFwiOiBcIkZlZWRcIixcblx0XCJUUkVORElOR1wiOiBcIkltIFRyZW5kXCIsXG5cdFwiSE9UXCI6IFwiQmVsaWVidFwiLFxuXHRcIk5FV1wiOiBcIk5ldVwiLFxuXHRcIlBST01PVEVEXCI6IFwiQmV3b3JiZW5cIixcblx0XCJWT1RFU1wiOiBcIlN0aW1tZW5cIixcblx0XCJQQVlPVVRcIjogXCJBdXN6YWhsdW5nXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJLb21tZW50YXJlXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJTZWl0IDMwIFRhZ2VuIGltIFRyZW5kXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiU29ydGllcmVuIGRlciBQb3N0cyBuYWNoOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkF1c3phaGx1bmdza3JlaXNsYXVmXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlZvcmF1c3NpY2h0bGljaGUgQXVzemFobHVuZ2VuXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJWZXJnYW5nZW5lIEF1c3phaGx1bmdlblwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJBdXN6YWhsdW5nIGFuIGRlbiBBdXRvclwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkt1cmF0aW9uc2F1c3phaGx1bmdlblwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUG9zdCB3dXJkZSB2ZXLDtmZmZW50bGljaHQhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlBvc3RzIHp1ciBzcMOkdGVyZW4gVmVyw7ZmZmVudGxpY2h1bmchXCIsXG5cdFwiU0FWRURcIjogXCJHZXNwZWljaGVydFwiLFxuXHRcIkNMRUFSRURcIjogXCJHZWxlZXJ0XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkRhcyBtYXJraWVyZW4gZWluZXMgUG9zdHMga2FubiB6dW0gVmVybHVzdCBkZXIgVmVyZ8O8dHVuZyBmw7xocmVuIHVuZCB2ZXJyaW5nZXJ0IGRpZSBTaWNodGJhcmtlaXQgZGVzIFBvc3RzLjxicj48YnI+U2llIHNvbGx0ZW4gUG9zdHMgbnVyIHVudGVyIG1hcmtpZXJlbiwgd2VubiBlaW5lciBkZXIgZm9sZ2VuZGVuIFB1bmt0ZSB6dXRyaWZmdDogPHVsPjxsaT5CZXRydWcgb2RlciBQbGFnaWF0PC9saT48bGk+VnVsZ8OkcmUgQXVzZHJ1Y2tlIG9kZXIgXFxcIlRyb2xsaW5nXFxcIjwvbGk+PGxpPk11dHdpbGxpZyBmYWxzY2gga2F0ZWdvcmlzaWVydCBvZGVyIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTWF4aW1hbGUgQW56YWhsIHZvbiBBbmZyYWdlbiBlcnJlaWNodC4gQml0dGUgc2NoYXVlbiBTaWUgc2ljaCBhbmRlcmUgdHJlbmQvdGFncyBhbiFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0IHZvbiBkZW4gTGVzZXplaWNoZW4gZW50ZmVybnQhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3QgenUgZGVuIExlc2V6ZWljaGVuIGhpbnp1Z2Vmw7xndCFcIixcblx0XCJSRVNFVFwiOiBcIlp1csO8Y2tzZXR6ZW5cIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIlByb2ZpbGJpbGQgw6RuZGVyblwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiVGl0ZWxiaWxkIMOkbmRlcm5cIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJCaXR0ZSB0cmFnZW4gU2llIGRlbiBcXFwiQWN0aXZlIHByaXZhdGUga2V5XFxcIiBlaW4sIHdlbm4gU2llIGRlbiBlcndlaXRlcnRlbiBMb2dpbiBNb2R1cyBnZXfDpGhsdCBoYWJlbiFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJadXLDvGNrc2V0emVuIGRlcyBQcm9maWxiaWxkc1wiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIlp1csO8Y2tzZXR6ZW4gZGVzIFRpdGVsYmlsZHMuXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBdWZncnVuZCBlaW5lcyBTZXJ2ZXJ1cGRhdGVzIG11c3MgZWluIGRpZSBBbndlbmR1bmcgbmV1Z2VzdGFydGV0IHdlcmRlbiFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiRWluc3RlbGx1bmdlbiBha3R1YWxpc2llcnQhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiU3ByYWNoZW5cIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkhpZXIga2FubiBkaWUgU3ByYWNoZSBkZXIgQW53ZW5kdW5nIGdlw6RuZGVydCB3ZXJkZW4uXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIkbDvHIgZGllIGdld8O8bnNjaHRlIE9wZXJhdGlvbiBtw7xzc2VuIFNpZSBhbmdlbWVsZGV0IHNlaW4uIEJpdHRlIG1lbGRlbiBTaWUgc2ljaCBtaXQgSWhyZW0gUGFzc3dvcnQgb2RlciBkZW0gXFxcImFjdGl2ZS9wb3N0aW5nXFxcIi1TY2hsw7xzc2VsIHNlaW5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyaWVcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJNaXR3aXJrZW5kZSBhbiBkZXIgw5xiZXJzZXR6dW5nXCIsXG5cdFwiU0hBUkVcIjogXCJUZWlsZW5cIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1hcmt0cGxhdHpcIixcblx0XCJFWENIQU5HRVwiOiBcIkLDtnJzZVwiLFxuXHRcIkRSQUZUU1wiOiBcIkVudHfDvHJmZVwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIkJlaXRyYWcgYXVzIEVudHfDvHJmZW4gZW50ZmVybnQhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIkJlaXRyYWcgenUgRW50d8O8cmZlbiBoaW56dWdlZsO8Z3QhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkxpbmtzIHdpc2NoZW4gZsO8ciBPcHRpb25lblwiLFxuXHRcIk1BTkFHRVwiOiBcIlZlcndhbHRlblwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJCaWxkIGVudGZlcm50XCIsXG5cdFwiQ09QWVwiOiBcIktvcGllcmVuXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJTaWUgaGFiZW4gbm9jaCBrZWluIEZvdG8gaG9jaGdlbGFkZW4hXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJOYWNoIHVudGVuIHppZWhlbiB6dW0gYWt0dWFsaXNpZXJlblwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJFeHRlcm5lIEFwcHNcIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Zy1JbnNcIixcblx0XCJTVUdHRVNUXCI6IFwiVm9yc2NobGFnZW5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcIktvbW10IGJhbGRcIixcblx0XCJDSEFJTlwiOiBcIkNoYWluXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkhpZXIga2FubnN0IGR1IGRpZSBCbG9ja2NoYWluIG9kZXIgZGllIFN0YW5kYXJkcGxhdHRmb3JtIHdlY2hzZWxuLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiV8OkaHJ1bmdcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiSGllciBrw7ZubmVuIFNpZSBJaHJlIFN0YW5kYXJkd8OkaHJ1bmcgw6RuZGVybi4gU2llIHNlaGVuIGFsbCBJaHJlIFZlcmRpZW5zdGUgZsO8ciBCZWl0csOkZ2UgLyBLb21tZW50YXJlIGluIGRpZXNlciBTdGFuZGFyZHfDpGhydW5nLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkZlYXR1cmUgTGlzdGU8L2I+PGJyPi0gWnVnYW5nIGVyaGFsdGVuIHp1IGVpbnppZ2FydGlnZW4gQXJ0aWtlbG4gYWxsIGRlciBUaGVtZW5nZWJpZXRlLCBkaWUgU2llIGdlcm5lIGxlc2VuIG3DtmNodGVuLjxicj4tIEludGVyYWdpZXJlbiBTaWUgbWl0IGRlbiBBdXRvcmVuLCBpbiBkZW0gU2llIGRpZSBCZWl0csOkZ2Uga29tbWVudGllcmVuIHVuZCBtaXQgYW5kZXJlbiBkaXNrdXRpZXJlbi48YnI+LSBTdGltbWVuIFNpZSBmw7xyIEFydGlrZWwgdW0gQXV0b3JlbiB6dSBiZWxvaG5lbiB1bmQgc2VsYnN0IEN1cmF0aW9uIFJld2FyZHMgenUgdmVyZGllbmVuLjxicj4tIFZlcsO2ZmZlbnRsaWNoZW4gU2llIElocmUgQXJ0aWtlbCwgQmxvZyBQb3N0cywgZGllIGtvc3RlbmxvcyBnZWhvc3RlZCB3ZXJkZW4gdW5kIGVyaGFsdGVuIFNpZSBFbnRnZWx0IGbDvHIgSW50ZXJhZ2llcmVuIHVuZCBnZXdpbm5lbiBTaWUgenVzw6R0emxpY2ggQW5ow6RuZ2VyIGbDvHIgSWhyZSBJbmhhbHRlLjxicj4tIFNjaHJlaWJlbiBTaWUgQXJ0aWtlbCB2b24gdW50ZXJ3ZWdzLiBTcGVpY2hlcm4gU2llIGVpbmUgVmllbHphaGwgdm9uIEVudHfDvHJmZW4gdW0gZGllc2Ugc3DDpHRlciB6dSB2ZXLDtmZmZW50bGljaGVuLjxicj4tIEJvb2ttYXJrZW4gU2llIElocmUgTGllYmxpbmdzYXJ0aWtlbCwgdW0gZGllc2Ugc3DDpHRlciB6dSBsZXNlbi48YnI+LSBFaW5uYWhtZW4gdGF1c2NoZW4gb2RlciBhdXN6YWhsZW4uPGJyPi0gw5xiZXJ3ZWlzZW4gU2llIEd1dGhhYmVuIGFuIEF1dG9yZW4sIE51dHplciwgRnJldW5kZSwgQW5ow6RuZ2VyLCBldGMuPGJyPi0gRm9sZ2VuIFNpZSBpbnRlcmVzc2FudGVuIEF1dG9yZW4sIEJsb2dnZXJuLjxicj4tIER1cmNoc3VjaGVuIFNpZSBJbmhhbHRlIElocmVyIEZvbGxvd2VyIHVuZCBBdXRvcmVuLjxicj4tIEVyaGFsdGVuIFNpZSBCZW5hY2hyaWNodGlndW5nZW4gdm9uIElocmVuIEZvbGxvd2VyIHVuZCBEaXNrdXNzaW9uZW4sIGFuIGRlbmVuIFNpZSB0ZWlsZ2Vub21tZW4gaGFiZW4uPGJyPi0gU3VjaGVuIFNpZSBpbnRlcmVzc2FudGUgVGFncyAvIEthdGVnb3JpZW4gYWxsZXIgQXJ0aWtlbCB1bmQgQXV0b3Jlbi48YnI+LSBQZXJzb25hbGlzaWVyZW4gU2llIElocmUgUHJvZmlsLjxicj4tIFZpZWxlIG5ldWUgRmVhdHVyZXMgd2VyZGVuIGRlbW7DpGNoc3Qgdm9yZ2VzdGVsbHQuPGJyPjxicj48Yj5TaWNoZXJoZWl0PC9iPjxicj4xLiBBcHAgaGF0IGtlaW5lbiBadWdyaWZmIGF1ZiBJaHJlIEVpbm5haG1lbi48YnI+Mi4gQXBwIGJpZXRlbiBlaW5mbGllw590LXNpZGUgU2ljaGVyaGVpdHMtTW9kZWxsIG1pdCBwcml2YXRlbiBTY2hsw7xzc2VsbiwgZGllIGxva2FsIGdlaG9zdGV0IHVuZCBuaWVtYWxzIGFuIGFuZGVyZSBTZXJ2ZXIgZ2VzY2hpY2t0IHdlcmRlbi4gU2llIHNpbmQgbGVkaWdsaWNoIGRhZsO8ciB2ZXJhbnR3b3J0bGljaCBJaHJlIFBhc3N3b3J0IHp1IHNpY2hlcm4uPGJyPjMuIERpZSBBcHAgYmlldGV0IHNpbXBsZXMgTnV0emVyIEludGVyZmFjZSB1bmQgYXR0cmFrdGl2ZSBVc2VyIEVyZmFocnVuZ2VuPGJyPjQuIERpZSBBcHAgYmVpbmhhbHRldCBlaW5lIHp1c8OkdHpsaWNoZSBTaWNoZXJoZWl0c2ViZW5lIGR1cmNoIGVpbmVuIFBpbi1Db2RlPGJyPjxicj5lU3RlZW0gdW50ZXJzdMO8dHogZGllIFBsYXR0Zm9ybWVuIFN0ZWVtIHNvd2llIEdvbG9zLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiR3LDvG5kZXIgdW5kIGxlaXRlbmRlciBFbnR3aWNrbGVyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBY2NvdW50IGhpbnp1ZsO8Z2VuXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0dGZvcm1cIixcblx0XCJFU0NST1dcIjogXCJUcmV1aGFuZHNlcnZpY2VcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgQWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJSYXRpZml6aWVydW5nc2ZyaXN0XCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgQWJsYXVmZGF0dW1cIixcblx0XCJFU0NST1dfRkVFXCI6IFwiRXNjcm93IEdlYsO8aHJcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgQmVkaW5ndW5nZW5cIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTmFjaHRtb2R1c1wiLFxuXHRcIkRBWV9NT0RFXCI6IFwiVGFnbW9kdXNcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJEZW4gZ2FuemVuIEFydGlrZWwgYW5zZWhlblwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJCZW51dHplciBuaWNodCBnZWZ1bmRlblwiLFxuXHRcIkFQUFJPVkVcIjogXCJadXN0aW1tZW5cIixcblx0XCJESVNQVVRFXCI6IFwiQW5mZWNodGVuXCIsXG5cdFwiUkVMRUFTRVwiOiBcIlZlcsO2ZmZlbnRsaWNodW5nXCIsXG5cdFwiRlJPTVwiOiBcIlZvblwiLFxuXHRcIklEXCI6IFwiaURcIixcblx0XCJTVUJNSVRcIjogXCJTZW5kZW5cIixcblx0XCJSRUNFSVZFUlwiOiBcIkVtcGbDpG5nZXJcIixcblx0XCJMT0NBVElPTlwiOiBcIlBvc2l0aW9uXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYnNlaXRlXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiQW5nZXplaWd0ZXIgTmFtZVwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJob21cIixcblx0XCJMT0dJTlwiOiBcImxnaW5cIixcblx0XCJMT0dPVVRcIjogXCJsZ29vdHVcIixcblx0XCJQUk9GSUxFXCI6IFwicG9yZmxpXCIsXG5cdFwiRk9MTE9XXCI6IFwiZmx1d1wiLFxuXHRcIkJPT0tNQVJLU1wiOiBcImJrdW1ha3J6XCIsXG5cdFwiVFJBTlNGRVJcIjogXCJ0YXJuc2VmclwiLFxuXHRcIk1BUktFVFwiOiBcIm1yYWt0ZVwiLFxuXHRcIlNFVFRJTkdTXCI6IFwic3RldGlnbnpcIixcblx0XCJBQk9VVFwiOiBcImFidXRcIixcblx0XCJBQk9VVF8xXCI6IFwid2VyIGFueW9uIGNuYSBlcmFuIHJ3YXJkeiBmZXIgdGhpciBjbnRudCFcIixcblx0XCJBQk9VVF8yXCI6IFwiaXogcHdlcmVkIGJpIHt7cGxhdGZvcm1uYW1lfX0gcGFsdGZyb20uIGFwcCBpeiBjcmF0ZWQgYmlcIixcblx0XCJBQk9VVF8zXCI6IFwiYW5kIGl0IGl6IG9wbi1zcmMsIGNtb3VudGkgZGlydm5lIG1iaWwgcHJqY3QuIGl0IG9mZmV6ciBjbnRudCBhY2NlenMgZmVyIHJkbmcsIGNvZW1udG5nLCB2dG9pZ24sIHBzdG5nLCB0YXJuc2VmciBlcmFuaWdueiwgZXRjLiBmdHJ6IG9mZmVyZWQgYmkge3twbGF0Zm9ybW5hbWV9fSBibGNrY2hpbiBhbmQge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBhcHAgbnZlciBhY2NlenMgb3IgaGxvZCBvdG5vIHVlc3IgZm5kei5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gYXBwIG9mZmV6ciBhIGNsbnQtc2lkIHNjZXVydGkgbWRlbCwgd3RpaCBwaXJ2dGEga3lleiBoc290ZGUgbGNvYWlsIGFuZCBudmVyIHNuZXQgdHUgYW5pIHNydnJ6LlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBhcHAgb2ZmZXpyIHNtcGwsIGF0cnRhY2l2IHVlc3IgaW5ldHJmY3ogYW5kIGV4cHJuY3ouXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIGFwcCBudmVyIHJxZXVyaSB1c3J6IHR1IGlucHQgYW5pIHByZXNvYW5sIGluZnJtYXRuLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJ2b3QgZ29vZC1rYXJtYSBheiB3aXRuc2V6XCIsXG5cdFwiQUJPVVRfOVwiOiBcImtvbnRha3QvZmVkYmFrOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwibXVyIGluZjpcIixcblx0XCJSRU1PVkVcIjogXCJybW92XCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJtcmFrdGUgdmVpd1wiLFxuXHRcIlBSSUNFXCI6IFwicGlyY1wiLFxuXHRcIkFNT1VOVFwiOiBcImFvbXV0blwiLFxuXHRcIlRPVEFMXCI6IFwidHRhbFwiLFxuXHRcIk5PT1JERVJTXCI6IFwibm8gb2VwbiBvZHJlenIgZmVyXCIsXG5cdFwiREFURVwiOiBcImRhdFwiLFxuXHRcIkJVWVwiOiBcImJ1aVwiLFxuXHRcIlNFTExcIjogXCJzZWxcIixcblx0XCJPUEVOXCI6IFwib2VwblwiLFxuXHRcIkhJU1RPUllcIjogXCJoc3RyXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJmbHV3IGJha1wiLFxuXHRcIkZPTExPV0VEXCI6IFwiZmxvd2VkXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJ1bmZvbG93XCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiZmxvb3duaWdcIixcblx0XCJGT0xMT1dFUlNcIjogXCJmbG9vd3JlelwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJzYWVyaGMgZmxvb3dyZXpcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwic2FlcmhjIGZsb293bmlnXCIsXG5cdFwiQllcIjogXCJiaVwiLFxuXHRcIk1FTlVcIjogXCJtbmV1XCIsXG5cdFwiQk9PS01BUktcIjogXCJia21ya1wiLFxuXHRcIlJFQkxPR1wiOiBcInJiZWxnb1wiLFxuXHRcIlVQVk9URVwiOiBcInVwdnRcIixcblx0XCJET1dOVk9URVwiOiBcImR3bnZvdFwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJ1bnZ0IGRvbnd2b2VkXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJ1bnZ0IHVwdm9lZFwiLFxuXHRcIlJFUExZXCI6IFwicnBsaVwiLFxuXHRcIkVESVRcIjogXCJlaWR0XCIsXG5cdFwiUE9TVF8xXCI6IFwic2l3cCBsZmV0IG9uIGNtZW50eiB0dSBjIG9wdGluelwiLFxuXHRcIlBPU1RfMlwiOiBcInRhcCBvbiBjbWVudHogdHUgYyBzdWItY21udHpcIixcblx0XCJPUFRJT05TXCI6IFwib3B0aW56XCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwicnNldGVlbWQgYmlcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJudGhuZyBoaXIsIHlldC4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiYmxhbmN6XCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgdHJhZWRiYWwgJCQgZGF0IGNuIGIgdHJuc2ZyZWQgYW55dGllbS4ge3twbGF0Zm9ybW5hbWV9fSBjbiBiIGNvdm5lcmVkIDIge3twbGF0Zm9ybXBvd2VyfX0gaW4gYSBwcmNzeiBjbGVkIHB3b2VybmlnIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBpZm5sdW5lYyAkJCBkYXQgZXJuIG11ciBwd2VyIGZlciBobGRuZyBsbm9nIHRpZW0gYW5kIHZvdGlnbiBvbiBwb3N0ei4gdGVoIG11ciB1IGhvbGR6IHRlaCBtdXIgdSBjbmEgaWZubHVuZWMgb3RoZXJ6IHJ3YXJkeiBhbmQgZXJuIHJ3YXJkeiBmZXIgYWNjdXJhdCB2b3RpZ24uXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiJCQgd3J0aCBhYnV0IHt7cGxhdGZvcm1zdW5pdH19IG9mIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiZXNpdG1hZWQgdmxhdVwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcInRlaCBlc2l0bWFlZCB2bGF1IGl6IGJzZWQgb24gYSA3IGRhaSBhZXZyZ2EgdmxhdSBvZiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJ0cmFuc2FjdG4gaHN0clwiLFxuXHRcIlBPU1RJTkdcIjogXCJwc3RuZ1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcInRlaCBwc3RuZyBrZWkgaXogdWVzZCBmZXIgcHN0bmcgYW5kIHZ0b2lnbi4gaXQgc29odWRsIGIgZGlmZmVybnQgZnJ1bSB0ZWggYWN0diBhbmQgb3duciBreWV6LlwiLFxuXHRcIk9XTkVSXCI6IFwib3duclwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcInRlaCBvd25yIGtlaSBpeiB0ZWggbXNhdHJlIGtlaSBmZXIgdGVoIGFjY29udCBhbmQgaXogcnFldWllcmQgdHUgY2huZyB0ZWggb3RociBreWV6LiB0ZWggcGlydnRhIGtlaSBvciBwc2Fzd3JvZCBmZXIgdGVoIG93bnIga2VpIHNvaHVkbCBiIGtwZXQgb2ZmbG5pIGF6IG1jdWggYXogcHNzYmwuXCIsXG5cdFwiQUNUSVZFXCI6IFwiYWN0dlwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcInRlaCBhY3R2IGtlaSBpeiB1ZXNkIHR1IG1hZWsgdHJuYXNmcnogYW5kIHBhbGMgb2RyZXpyIGluIHRlaCBpdG5lcmFubCBtcmFrdGUuXCIsXG5cdFwiTUVNT1wiOiBcIm1tZW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJ0ZWggbW1lbyBrZWkgaXogdWVzZCB0dSBjcmF0IGFuZCByYWVkIG1tb3ouXCIsXG5cdFwiQkxPR1wiOiBcImJvbGdcIixcblx0XCJQT1NUU1wiOiBcInBzdHpcIixcblx0XCJSRVBMSUVTXCI6IFwicnBsaWVzXCIsXG5cdFwiV0FMTEVUXCI6IFwid2xldFwiLFxuXHRcIlRBR1wiOiBcInRhZ2dcIixcblx0XCJVU0VSXCI6IFwidWVzclwiLFxuXHRcIkNMT1NFXCI6IFwiY29sc1wiLFxuXHRcIlRPXCI6IFwidG9cIixcblx0XCJBU1NFVFwiOiBcImFzc3RcIixcblx0XCJTRU5EXCI6IFwic25kXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJzY2V1cnRpXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiYWF2aWxiYWxcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcInBidWxjaSBtbWVvXCIsXG5cdFwiVE9fREVTQ1wiOiBcInVlc3IgZS5nLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJwaW4gY29kXCIsXG5cdFwiUElOX1RFWFRcIjogXCJwaW4gY29kIGhscHogeXUgdHUgc2N1ciBhcHAgYW5kIHVyIGR0YWEuIDxici8+PGJyLz48Yj5ub3RlOjwvYj4gb25jIGVuYmxlZCwgeXUgaGV2IG1heCA0IHRpcnogdHUgdW5saywgaWYgeXUgZnJndCBwaW4gb3IgZmlhbCwgYXBwIHdpbCBybW92IGxnb2dkZSBpbiB1ZXNyIGR0YWEuIHl1IGNuYSByLWVsb2lnbiBhbmQgY250biB1c25nIGFwcC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwibm90aWZpa2F0aW9uelwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcInl1IHdpbCBnZXQgbm90ZmlrYXRpbiB3ZWhuIHNtb2VubyB2dG96IHVyIGNudG50ISA8YnIvPiA8Yj5udDo8L2I+IG5vdGlmaWthdGlvbnogaWNubGR1IHZ0b2lnbiB3aWVndGggYXogd2VsIGluIGFscnQgbWVzc2lnLiAoYiBpdCB1cHZ0LCBkd252b3QsIHVudnQpLlwiLFxuXHRcIlZPVEVcIjogXCJ2b3RcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJ5dSB3aWwgZ2V0IG5vdGZpa2F0aW4gd2VobiBzbW9lbm8gY21lbnR6IG9uIHVyIHBzdHogb3Iga29tZW50cyE8YnIvPiA8Yj5udDo8L2I+IG5vdGlmaWthdGlvbnogaWNubGR1IHdlaG4gc21vZW5vIDxiPmR0czwvYj4gdGhpciBjbWVudHogYXogd2VsLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJjbW9ldG5cIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcInl1IHdpbCBnZXQgbm90ZmlrYXRpbiB3ZWhuIHNtb2VubyBmbHV3IG9yIHVuZm9sb3cgeXUhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJtbmV0aW5velwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJ5dSB3aWwgZ2V0IG5vdGZpa2F0aW4gd2VobiBzbW9lbm8gbW5ldGlub3ogeXUgaW4gdGhpciBwc3QvY21udCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcImtvbmZndXJhdG9uelwiLFxuXHRcIlZPVElOR1wiOiBcInZ0b2lnblwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwidm90IHdpZWd0aCBvciBwZWNyZW5hZyBhZmZlY3R6IHZ0b2lnbiBwd2VyIG9uIGFwcCwgc28geXUgY25hIHJndWxhdCB1ciB2dG9pZ24gcndlYWRyLiA8YnIvPjxici8+PGI+bm90ZTo8L2I+IGRpeiB3aWwgY2huZyB2dG9pZ24gd2VpZ2h0L3BlcmNlbnRhZyBmZXIgZHdudnRpbmcgYXogd2VsIGFuZCBpdCBpeiBldnJleXdlciBvbiBhcHBcIixcblx0XCJTRVJWRVJcIjogXCJzcmV2cmVcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcInJjbW5kZWRcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJzYXYgY2FobnpnXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJ2dG9lenIgaWZub1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIndsY3VtIGJhayFcIixcblx0XCJMT0dJTl8xXCI6IFwic2dpbiBpbiB3dGloIHVyIHVzcm5hbSBhbmQgcHNhc3dyb2QgdHUgY250bi5cIixcblx0XCJMT0dJTl8yXCI6IFwicHN0bmcga2VpIGl6IHVlc2QgZmVyIHBzb3QsIGNtb2V0biwgdm90LCBmbHV3LlwiLFxuXHRcIkxPR0lOXzNcIjogXCJhY3R2IGtlaSBpeiB1ZXNkIGZlciB0cm5hc2ZyeiBhbmQgcG9yZmxpIHBjaXRydSB1cGR0LlwiLFxuXHRcIkxPR0lOXzRcIjogXCJ1ZXNyIGNyZG50YWx6IGFyIGtwZXQgbGNvYWlsIG9uIHRlaCBkdmljLiB1b3BuIGxnb290dSBjcmRudGFseiBhciBybW92ZWQhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiZG50IGhldiBhbiBhY2NvbnQ/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJzZ2luIHVwIG5vd1wiLFxuXHRcIkNBTkNFTFwiOiBcImNuYWNsZVwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiYXZkYW5lY2RcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiYWN0diBwaXJ2dGEga2VpXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJwc3RuZyBwaXJ2dGEga2VpXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJtYXN0ci9tYW4gcHNhc3dyb2RcIixcblx0XCJVU0VSTkFNRVwiOiBcInVzcm5hbVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcImNyYWQgdmVpd1wiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcImNtcGN0IHZlaXdcIixcblx0XCJTRUFSQ0hcIjogXCJzYWVyaGNcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcInNidW10aSBhIHN0cmlcIixcblx0XCJSRVBMWVRPXCI6IFwicnBsaSB0dVwiLFxuXHRcIlBPU1RcIjogXCJwc290XCIsXG5cdFwiUFJFVklFV1wiOiBcInBydmV3XCIsXG5cdFwiREVGQVVMVFwiOiBcImRmYWx0IDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJwd2VyIHVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcImRjZWxuaSBweWFvdHVcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcInNhdiBmZXIgbHRlclwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcInBzb3QgY250bnRcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJjbW9ldG4gY250bnRcIixcblx0XCJUSVRMRVwiOiBcInR0aWxcIixcblx0XCJUQUdTXCI6IFwidGVnelwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIm5vdCBtdGNoXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJjbmZybSBwaW5cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJvcG5uZyBwc290XCIsXG5cdFwiU0VUX1BJTlwiOiBcInNldCBwaW5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJlbnRyIHBpblwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcImFyIHl1IHN1cj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJicmFvZGNzdCBlb3JyLCB0cmkgYWduIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJzY2NzelwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwicmVsYm9nZWQgcHNvdCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwibGdpbiBmaWFsZGUhIHBseiBtYWVrIHN1ciB5dSBoZXYgbGdvZ2RlIGluIHd0aWggbXNhdHJlIHBzYXN3cm9kIG9yIHBvcnZpZWRkIHBzdG5nIHBpcnZ0YSBrZWkgb24gbGdpbiBpZiB5dSBoZXYgY3Voc2RlIGF2ZGFuZWNkIG1vZC5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJsZ2luIGZpYWxkZSEgcGx6IG1hZWsgc3VyIHl1IGhldiBsZ29nZGUgaW4gd3RpaCBtc2F0cmUgcHNhc3dyb2Qgb3IgcG9ydmllZGQgYWN0diBwaXJ2dGEga2VpIG9uIGxnaW4gaWYgeXUgaGV2IGNvaHNuZSBhdmRhbmVjZCBtb2QuXCIsXG5cdFwiV0FSTklOR1wiOiBcIndybm5nXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcInZ0b2lnbiBmZXIgd3Ruc3pcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcInZ0ZWQgZmVyIHd0bnN6XCIsXG5cdFwiRlJPTV9OT1dcIjogXCJmcnVtIG5vd1wiLFxuXHRcIlNFQ1NcIjogXCJzZWN6XCIsXG5cdFwiTUlOU1wiOiBcIm1pbnpcIixcblx0XCJBTl9IT1VSXCI6IFwiYW4gaHJ6XCIsXG5cdFwiSE9VUlNcIjogXCJocnpcIixcblx0XCJBX0RBWVwiOiBcImEgZGFpXCIsXG5cdFwiREFZU1wiOiBcImR5YXpcIixcblx0XCJBX01PTlRIXCI6IFwiYSBtbnRoXCIsXG5cdFwiTU9OVEhTXCI6IFwibW5vdHpoXCIsXG5cdFwiQV9ZRUFSXCI6IFwiYSB5YWVyXCIsXG5cdFwiWUVBUlNcIjogXCJ5YXJ6XCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gcmFlZFwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJkd252b3Qgb3IgZmFsZ1wiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcImNwYXRydSBwY2l0dXJcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcInNpbGVjdCBwY2l0dXJcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcInNldCBjc3V0bW8gdXJsXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJpc25ldHIgcGNpdHJ1XCIsXG5cdFwiRVJST1JcIjogXCJlb3JyXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwidWxwb2RhIGVvcnJcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiY21hZWFyIGNuYWNlZWxkXCIsXG5cdFwiU0VUX1VSTFwiOiBcInNldCB1cmxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiZHJpZXRjIHdlYiBsbmlrIGZlciB0ZWggcGNpdHJ1XCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJjbW9ldG4gaXogc3VtYml0ZWQhXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJkbGVldG5pZyBjbWVudHogYXIgaXJ2cnNibC4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcImRsZXRlZCBjbW9ldG5cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcInVwb2xhZG5nIHBjaXRydVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJ1bHBvZGEgY29wbWxlZWRcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwidWxwb2RhIGZpYWxkZVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcInRlaCBwc2Fzd3JvZCBvciBhY2NvbnQgbmFtIHdheiBpY25vcmNldFwiLFxuXHRcIklORk9cIjogXCJpZm5vXCIsXG5cdFwiUVJfVEVYVFwiOiBcInBhbGMgYSBxciBjb2QgaW5zZCB0ZWggc2FjbiBhZXJhXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwibWFlayBzdXIgeXUgaGV2IGVvbnVoZyAkJCBmZXIgdHJhbnNhY3RuIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJ1ZXNyIHl1IGFyIHR5cmlnbiB0dSB0YXJuc2VmciAkJCwgZHNuJ3QgZXhzdCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiYXIgeXUgc3VyIHl1IHdhbmFuIHR1IHRhcm5zZWZyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcImtvbmZybWF0aW5cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcInRyYW5zYWN0biBpeiBicmFkY2FzdGRcIixcblx0XCJGRUVEXCI6IFwiZmVkXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJ0ZXJuZG5pZ1wiLFxuXHRcIkhPVFwiOiBcImhvdFwiLFxuXHRcIk5FV1wiOiBcIm5ld1wiLFxuXHRcIlBST01PVEVEXCI6IFwicG9ybW9ldGRcIixcblx0XCJWT1RFU1wiOiBcInZ0b3pcIixcblx0XCJQQVlPVVRcIjogXCJweWFvdHVcIixcblx0XCJDT01NRU5UU1wiOiBcImNtZW50elwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwidGVybmRuaWcgZmVyIDMwIGR5YXpcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJzcm90IHBzdHogYnk6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwicHlhb3R1IGNjeWxcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwicG9ldG50YWwgcHlhb3R1XCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJwc2F0IHB5YW90dVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJhdHVocm8gcHlhb3R1XCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiY3J1YXRvaW4gcHlhb3R1XCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJwc290IGl6IHN1bWJpdGVkIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJwc290IGZlciBsdGVyIHNibXNzb24hXCIsXG5cdFwiU0FWRURcIjogXCJzdmVkXCIsXG5cdFwiQ0xFQVJFRFwiOiBcImNsYXJlZFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJmYWxnZ25pZyBhIHBzb3QgY25hIHJtb3YgcndhcmR6IGFuZCBtYWVrIGRpeiBtdGFlcmFpbCBsc2V6IHZpc2libGUuPGJyPjxicj50aCBmYWxnIHNvaHVkbCBiIHVlc2QgZmVyIHRlaCBmb29sd2lnOiA8dWw+PGxpPmZyYXV0IG9yIHBsYWdpYXJpc208L2xpPjxsaT5oYXQgc3BjaCBvciBpdG5lcmVudCB0cm9saW5nPC9saT48bGk+aW50ZW50aW9uYWwgbXNrYXRlZ29yemVkIGNudG50IG9yIHNwYW08L2w+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJycXVzdCBsbWl0IHJjaGVkLiBjZWhrIG91dCBvdGhyIHRybmQvdGVneiFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJwc290IGl6IHJtb3ZlZCBmcnVtIGJrdW1ha3J6IVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJwc290IGl6IGFkZGQgdHUgYmt1bWFrcnohXCIsXG5cdFwiUkVTRVRcIjogXCJyc2V0XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJjaG5nIHBvcmZsaSBwY2l0cnVcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcImNobmcgY3ZlciBwY2l0cnVcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJwbHogcG9ydmRpIGFjdHYgcGlydnRhIGtlaSBpZiB5dSBoZXYgY29oc25lIGF2ZGFuZWNkIGxnaW4gbW9kIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcImRpeiB3aWwgcnNldCB1ZXNyIHBvcmZsaSBwY2l0cnVcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJkaXogd2lsIHJzZXQgdWVzciBjdmVyIHBjaXRydVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwic3JldnJlIHVwZHQgcnF1cnogcnN0cnQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcInN0ZXRpZ256IGFyIHVwZGF0ZWQhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwibG5hZ3VnYXpcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcImhpciB5dSBjbmEgY2huZyBsbmdhZyBvZiB0ZWggYXBwLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJkaXogb3ByZWF0b24gcnF1cnogdWVzciB0dSBiIGxnb2dkZSBpbiB3dGloIG1pYW4gcHNhc3dyb2QsIGFrdHZlL3Bvc3RuZyBrZWkuIHBseiBsZ2luIGFuZCB0cmkgYWduLlwiLFxuXHRcIkdBTExFUllcIjogXCJnbGFlaXJcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJ0cmFuc2xhdG4ga29udHJidXRyelwiLFxuXHRcIlNIQVJFXCI6IFwic2hyZVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwibXJha3RlIHBhbGNcIixcblx0XCJFWENIQU5HRVwiOiBcImV4Y2huZ1wiLFxuXHRcIkRSQUZUU1wiOiBcImRhcmZ6dFwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcInBzb3QgaXogcm1vdmVkIGZydW0gZGFyZnp0IVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJwc290IGl6IGFkZGQgdHUgZGFyZnp0IVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJzaXdwIGxmZXQgdHUgYyBvcHRpbnpcIixcblx0XCJNQU5BR0VcIjogXCJtbmFnXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcImlhbWcgaXogcm1vdmVkXCIsXG5cdFwiQ09QWVwiOiBcImNwb2lcIixcblx0XCJOT19JTUFHRVwiOiBcInl1IGhldiBub3QgdWxwb2FlZGQgYW5pIGlhbWcsIHlldCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcInB1bCBkd29uIHR1IHJmcnNoXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcImV0eGVyYW5sIGFwcHpcIixcblx0XCJQTFVHSU5TXCI6IFwicGxnbnpcIixcblx0XCJTVUdHRVNUXCI6IFwic2dnc3RcIixcblx0XCJDT01JTkdfU09PTlwiOiBcImNtb2lnbiBzdW5cIixcblx0XCJDSEFJTlwiOiBcImNoaW5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiaGlyIHl1IGNuYSBjaG5nIGJsY2tjaGluIG9yIGRmYWx0IHBhbHRmcm9tLlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCLOkc+Bz4fOuc66zq5cIixcblx0XCJMT0dJTlwiOiBcIs6Vzq/Pg86/zrTOv8+CXCIsXG5cdFwiTE9HT1VUXCI6IFwizpHPgM6/z4PPjc69zrTOtc+DzrdcIixcblx0XCJQUk9GSUxFXCI6IFwizqDPgc6/z4bOr867XCIsXG5cdFwiRk9MTE9XXCI6IFwizpHOus6/zrvOv8+NzrjOt8+DzrVcIixcblx0XCJCT09LTUFSS1NcIjogXCLOo861zrvOuc60zr/OtM61zq/Ous+EzrXPglwiLFxuXHRcIlRSQU5TRkVSXCI6IFwizpzOtc+EzrHPhs6/z4HOrFwiLFxuXHRcIk1BUktFVFwiOiBcIs6Rzr3PhM6xzrvOsc66z4TOrs+BzrnOv1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwizqHPhc64zrzOr8+DzrXOuc+CXCIsXG5cdFwiQUJPVVRcIjogXCLOo8+HzrXPhM65zrrOrFwiLFxuXHRcIkFCT1VUXzFcIjogXCLPjM+Azr/PhSDOvyDOus6xzrjOrc69zrHPgiDOvM+Azr/Pgc61zq8gzr3OsSDOus61z4HOtM6vz4POtc65IM6xz4DOv867zrHOss6tz4IgzrHPgM+MIM+Ezr8gz4DOtc+BzrnOtc+Hz4zOvM61zr3PjCDPhM6/z4UhXCIsXG5cdFwiQUJPVVRfMlwiOiBcIs61zq/Ovc6xzrkgzrLOsc+DzrnPg868zq3Ovc6/IM+Dz4TOt869IM+AzrvOsc+Ez4bPjM+BzrzOsSB7e3BsYXRmb3JtbmFtZX19LiDOlM63zrzOuc6/z4XPgc6zzq/OsSDOtc+GzrHPgc68zr/Os86uz4IgzrHPgM+MXCIsXG5cdFwiQUJPVVRfM1wiOiBcIs66zrHOuSDOtc6vzr3Osc65IM6xzr3Ov865z4fPhM+Mz4IgzrrPjs60zrnOus6xz4IsIM66zrHPhM61z4XOuM+Fzr3PjM68zrXOvc6/z4IgzrHPgM+MIM+EzrfOvSDOus6/zrnOvc+Mz4TOt8+EzrEuzqDPgc6/z4PPhs6tz4HOtc65LCDPgM+Bz4zPg86yzrHPg863IM+DzrUgz4DOtc+BzrnOtc+Hz4zOvM61zr3OvyDOs865zrEgzrHOvc6szrPOvc+Jz4POtywgz4PPh86/zrvOuc6xz4POvM+MLCDPiM6uz4bOuc+DzrcsIM6xzr3OrM+Bz4TOt8+DzrcsIM68zrXPhM6xz4bOv8+BzqwgzrHPgM6/zrvOsc6yz47OvSwgzrrPhM67LiDOtM+Fzr3Osc+Ez4zPhM63z4TOtc+CIM+EzrnPgiDOv8+Azr/Or861z4Igz4DPgc6/z4PPhs6tz4HOtc65IM+Ezr8ge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIM66zrHOuSDPhM6/IHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gzpcgzrXPhs6xz4HOvM6/zrPOriDOtM61zr0gzq3Ph861zrkgz4DOv8+Ezq0gz4DPgc+Mz4POss6xz4POtyDOv8+Nz4TOtSDOus+BzrHPhM6szrXOuSDPhM6xIM66zrXPhs6szrvOsc65zrEgz4TPic69IM+Hz4HOt8+Dz4TPjs69LlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOrc69zrEgzrzOv869z4TOrc67zr8gzrHPg8+GzrHOu861zq/Osc+CIM6xz4DPjCDPhM63zr0gz4DOu861z4XPgc6sIM+Ezr/PhSDPhM61z4HOvM6xz4TOuc66zr/PjSDPhM6/z4Ugz4fPgc6uz4PPhM63LCDOvM61IM+EzrEgzrnOtM65z4nPhM65zrrOrCDOus67zrXOuc60zrnOrCDOvc6xIFxcXCLPhs65zrvOv86+zrXOvc6/z43Ovc+EzrHOuVxcXCIgz4TOv8+AzrnOus6sIM+Hz4nPgc6vz4Igz4DOv8+Ezq0gzr3OsSDOsc+Azr/Pg8+Ezq3Ou867zr/Ovc+EzrHOuSDPg861IM6/z4DOv865zr/OtM6uz4DOv8+EzrUgzrTOuc6xzrrOv868zrnPg8+Ezq4uXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIM6XIM61z4bOsc+BzrzOv86zzq4gz4DPgc6/z4PPhs6tz4HOtc65IM6xz4DOu8+MIM66zrHOuSDOtc67zrrPhc+Dz4TOuc66z4wgz4DOtc+BzrnOss6szrvOu86/zr0gz4fPgc6uz4POt8+CIM66zrHOuSDOtc68z4DOtc65z4HOr86xz4IuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQsIM6XIM61z4bOsc+BzrzOv86zzq4gzrTOtc69IM64zrEgzrbOt8+Ezq7Pg861zrkgz4DOv8+Ezq0gz4DPgc6/z4PPic+AzrnOus6tz4Igz4DOu863z4HOv8+Gzr/Pgc6vzrXPgi5cIixcblx0XCJBQk9VVF84XCI6IFwizqjOrs+GzrnPg861IGdvb2Qta2FybWEgzrPOuc6xIHdpdG5lc3NcIixcblx0XCJBQk9VVF85XCI6IFwizpXPgM65zrrOv865zr3Pic69zq/OsS/OoM6xz4HOsc+EzrfPgc6uz4POtc65z4JcIixcblx0XCJBQk9VVF8xMFwiOiBcIs6gzrXPgc65z4PPg8+Mz4TOtc+BzrXPgiDPgM67zrfPgc6/z4bOv8+Bzq/Otc+COlwiLFxuXHRcIlJFTU9WRVwiOiBcIs6Rz4DOv868zqzOus+Bz4XOvc+DzrdcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIs6Vz4DOv8+Az4TOtc6vzrEgzpHOs86/z4HOrM+CXCIsXG5cdFwiUFJJQ0VcIjogXCLOpM65zrzOrlwiLFxuXHRcIkFNT1VOVFwiOiBcIs6gzr/Pg8+MXCIsXG5cdFwiVE9UQUxcIjogXCLOo8+Nzr3Ov867zr9cIixcblx0XCJOT09SREVSU1wiOiBcIs6UzrXOvSDPhc+AzqzPgc+Hzr/Phc69IM6xzr3Ov865z4fPhM6tz4IgzrXOvc+Ezr/Ou86tz4IgzrPOuc6xXCIsXG5cdFwiREFURVwiOiBcIs6XzrzOtc+Bzr/OvM63zr3Or86xXCIsXG5cdFwiQlVZXCI6IFwizpHOs86/z4HOrFwiLFxuXHRcIlNFTExcIjogXCLOoM+OzrvOt8+DzrdcIixcblx0XCJPUEVOXCI6IFwizobOvc6/zrnOs868zrFcIixcblx0XCJISVNUT1JZXCI6IFwizpnPg8+Ezr/Pgc65zrrPjFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwizpHOvc6xz4POus+Mz4DOt8+DzrdcIixcblx0XCJGT0xMT1dFRFwiOiBcIs6RzrrOv867zr/Phc64zrXOr8+CXCIsXG5cdFwiVU5GT0xMT1dcIjogXCLOnM63IM6xzrrOv867zr/Phc64zrXOr8+CXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwizpHOus6/zrvOv8+FzrjOtc6vz4JcIixcblx0XCJGT0xMT1dFUlNcIjogXCLOo861IM6xzrrOv867zr/Phc64zr/Pjc69XCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIs6ozqzOvs61IM+Azr/Ouc6/zrkgz4POtSDOsc66zr/Ou86/z4XOuM6/z43OvVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCLOqM6szr7OtSDPgM6/zrnOv8+Fz4IgzrHOus6/zrvOv8+FzrjOtc6vz4JcIixcblx0XCJCWVwiOiBcIs6xz4DPjFwiLFxuXHRcIklOXCI6IFwiz4POtVwiLFxuXHRcIk1FTlVcIjogXCLOms6xz4TOrM67zr/Os86/z4IgzrXPgM65zrvOv86zz47OvVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwizqPOtc67zrnOtM6/zrTOtc6vzrrPhM63z4JcIixcblx0XCJSRUJMT0dcIjogXCLOkc69zrHOtM63zrzOv8+Dzq/Otc+Fz4POt1wiLFxuXHRcIlVQVk9URVwiOiBcIs6YzrXPhM65zrrOriDPiM6uz4bOv8+CXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLOkc+Bzr3Ot8+EzrnOus6uIM+Izq7Phs6/z4JcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwizpXPgM6xzr3Orc+GzrXPgc61IM6Rz4HOvc63z4TOuc66zqwtz4jOt8+GzrnPg868zq3Ovc6/XCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLOlc+AzrHOvc6tz4bOtc+BzrUgzpjOtc+EzrnOus6sLc+IzrfPhs65z4POvM6tzr3Ov1wiLFxuXHRcIlJFUExZXCI6IFwizpHPgM6szr3PhM63z4POt1wiLFxuXHRcIkVESVRcIjogXCLOlc+AzrXOvs61z4HOs86xz4POr86xXCIsXG5cdFwiUE9TVF8xXCI6IFwizqPPjc+BzrUgzrHPgc65z4PPhM61z4HOrCDPhM6xIM+Dz4fPjM67zrnOsSDOs865zrEgzr3OsSDOtM61zrnPgiDOtc+AzrnOu86/zrPOrc+CXCIsXG5cdFwiUE9TVF8yXCI6IFwizpHOus6/z43OvM+AzrEgz4TOsSDPg8+Hz4zOu865zrEgzrPOuc6xIM69zrEgzrTOtc65z4Igz4XPgM+MLc+Dz4fPjM67zrnOsVwiLFxuXHRcIk9QVElPTlNcIjogXCLOlc+AzrnOu86/zrPOrc+CXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwizpHOvc6xzrTOt868zr/Pg86vzrXPhc+DzrcgzrHPgM+MXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwizqTOr8+Azr/PhM6xIM61zrTPjiwgzrHOus+MzrzOsS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwizpTOuc6xzrjOrc+DzrnOvM6xXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgzrTOuc6xz4DPgc6xzrPOvM6xz4TOtc+Nz4POuc68zrXPgiDOvM6sz4HOus61z4IsIM+Azr/PhSDOvM+Azr/Pgc6/z43OvSDOvc6xIM68zrXPhM6xz4bOtc+BzrjOv8+Nzr0gzr/PgM6/zrnOsc60zq7PgM6/z4TOtSDPg8+EzrnOs868zq4uIHt7cGxhdGZvcm1uYW1lfX0gzrzPgM6/z4HOv8+Nzr0gzr3OsSDOvM61z4TOsc+Ez4HOsc+Azr/Pjc69IM+DzrUge3twbGF0Zm9ybXBvd2VyfX0gzrzOrc+Dz4kgzrzOr86xz4IgzrTOuc6xzrTOuc66zrHPg86vzrHPgiDPgM6/z4Ugzr/Ovc6/zrzOrM62zrXPhM6xzrkgcG93ZXJpbmcgdXAuIFwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCDOvM6sz4HOus61z4IgzrXPgM65z4HPgc6/zq7PgiDPgM6/z4UgzrzPgM6/z4HOv8+Nzr0gzr3OsSDOsc+Azr/Ous+Ezq7Pg86/z4XOvSDPgM61z4HOuc+Dz4PPjM+EzrXPgc63IM60z43Ovc6xzrzOtywgzrrPgc6xz4TPjs69z4TOsc+CIM+EzrnPgiDOvM6xzrrPgc6/z4DPgc+MzrjOtc+DzrzOsSDOus6xzrkgz4jOt8+Gzq/Ots6/zr3PhM6xz4IgzrHOvc6xz4HPhM6uz4POtc65z4IuIM6Mz4POtc+CIM+AzrXPgc65z4PPg8+Mz4TOtc+BzrXPgiDOrc+HzrXOuSDPg8+EzrfOvSDOus6xz4TOv8+Hzq4gz4TOv8+FIM66zqzPgM6/zrnOv8+CLCDPhM+Mz4POvyDPgM61z4HOuc+Dz4PPjM+EzrXPgc6/IM68z4DOv8+BzrXOryDOvc6xIM61z4DOt8+BzrXOrM+DzrXOuSDPhM65z4IgzrHOvM6/zrnOss6tz4IgzqzOu867z4nOvSDOrM67zrvOsSDOus6xzrkgz4TOuc+CIM60zrnOus6tz4Igz4TOv8+FLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIs6czqzPgc66zrXPgiDOsc6+zq/Osc+CIM+AzrXPgc6vz4DOv8+FIHt7cGxhdGZvcm1zdW5pdH19IM+Ezr/PhSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIs6Rzr7Or86xIM66zrHPhM6sIM61zrrPhM6vzrzOt8+DzrcgXCIsXG5cdFwiUFJPRklMRV80XCI6IFwizpcgzrHOvs6vzrEgzrrOsc+EzqwgzrXOus+Ezq/OvM63z4POtyDOtc6vzr3Osc65IM6yzrHPg865z4POvM6tzr3OtyDPg8+Ezr/OvSDOtc6yzrTOv868zrHOtM65zrHOr86/IM68zq3Pg86/IM+Mz4HOvyDPhM6/z4V7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCLOmc+Dz4TOv8+BzrnOus+MIM6jz4XOvc6xzrvOu86xzrPPjs69XCIsXG5cdFwiUE9TVElOR1wiOiBcIs6Rzr3OrM+Bz4TOt8+DzrdcIixcblx0XCJQUk9GSUxFXzVcIjogXCLOnyDOus+JzrTOuc66z4zPgiDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrTOt868zr/Pg865zrXPjc+DzrXOuc+CIM66zrHOuSDPhM63zr0gzrTPhc69zrHPhM+Mz4TOt8+EzrEgzrHPgM+MzrTOv8+DzrfPgiDPiM6uz4bOv8+FLiDOmM6xIM+Az4HOrc+AzrXOuSDOvc6xIM61zq/Ovc6xzrkgzrTOuc6xz4bOv8+BzrXPhM65zrrPjM+CIM6xz4DPjCDPhM6/zr0gXFxcIs61zr3Otc+BzrPPjFxcXCIgzrrPic60zrnOus+MIM66zrHOuSDPhM6/IM66z4nOtM65zrrPjCBcXFwizrnOtM65zr/Ous+EzrfPg86vzrHPglxcXCIuXCIsXG5cdFwiT1dORVJcIjogXCLOmc60zrnOv866z4TOrs+EzrfPglwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIs6kzr8gzrrOu861zrnOtM6vIM65zrTOuc6/zrrPhM63z4POr86xz4IgzrXOr869zrHOuSDPhM6/IM66zrXOvc+Ez4HOuc66z4wgzrrOu861zrnOtM6vIM+Ezr/PhSDOu86/zrPOsc+BzrnOsc+DzrzOv8+NIM66zrHOuSDOsc+AzrHOuc+EzrXOr8+EzrHOuSDOs865zrEgzr3OsSDOsc67zrvOrM6+zrXOuSDPjM67zrEgz4TOsSDPhc+Az4zOu86/zrnPgM6xIM66zrvOtc65zrTOuc6sLiDOmM6xIM+Az4HOrc+AzrXOuSDOvc6xIM66z4HOsc+EzqzPhM61IM61zrrPhM+Mz4Igz4PPjc69zrTOtc+DzrfPgiDPhM6/IM65zrTOuc+Jz4TOuc66z4wgzrrOu861zrnOtM6vIM6uIM66z4nOtM65zrrPjCDPhM6/z4UgzrrOu861zrnOtM65zr/PjSDOuc60zrnOv866z4TOt8+Dzq/Osc+CIM+Mz4POvyDOsc+Fz4TPjCDOtc6vzr3Osc65IM60z4XOvc6xz4TPjM69LlwiLFxuXHRcIkFDVElWRVwiOiBcIs6Vzr3Otc+BzrPPjFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIs6kzr8gzrXOvc61z4HOs8+MIM66zrvOtc65zrTOryDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xIM61zrzOss6sz4POvM6xz4TOsSDOus6xzrkgzrXOvc+Ezr/Ou86tz4IgzrHOs86/z4HOsc+Az4nOu863z4POuc+Ozr0gz4PPhM6/IM61z4PPic+EzrXPgc65zrrPjCDOsc69z4TOsc67zrvOsc66z4TOrs+BzrnOvy5cIixcblx0XCJNRU1PXCI6IFwizprOu861zrnOtM65IC0gzpzOt869z4XOvM6sz4TPic69XCIsXG5cdFwiUFJPRklMRV84XCI6IFwizqTOvyDOms67zrXOuc60zq8gzpzOt869z4XOvM6sz4TPic69IM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrTOt868zrnOv8+Fz4HOs86vzrEgzrrOsc65IM6xzr3OrM6zzr3Pic+DzrcgzrzOt869z4XOvM6sz4TPic69LlwiLFxuXHRcIkJMT0dcIjogXCLOmc+Dz4TOv867z4zOs865zr9cIixcblx0XCJQT1NUU1wiOiBcIs6Rzr3Osc+Bz4TOrs+DzrXOuc+CXCIsXG5cdFwiUkVQTElFU1wiOiBcIs6Rz4DOsc69z4TOrs+DzrXOuc+CXCIsXG5cdFwiV0FMTEVUXCI6IFwizqDOv8+Bz4TOv8+Gz4zOu865XCIsXG5cdFwiVEFHXCI6IFwizpXPhM65zrrOrc+EzrFcIixcblx0XCJVU0VSXCI6IFwizqfPgc6uz4PPhM63z4JcIixcblx0XCJDTE9TRVwiOiBcIs6azrvOtc6vz4POuc68zr9cIixcblx0XCJUT1wiOiBcIs6jzrVcIixcblx0XCJBU1NFVFwiOiBcIs6azrXPhs6szrvOsc65zr9cIixcblx0XCJTRU5EXCI6IFwizpHPgM6/z4PPhM6/zrvOrlwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwizpHPg8+GzqzOu861zrnOsVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIs6UzrnOsc64zq3Pg865zrzOv1wiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwizpTOt868z4zPg865zr8gzrzOrs69z4XOvM6xXCIsXG5cdFwiVE9fREVTQ1wiOiBcIs6nz4HOrs+Dz4TOt8+CIM+ALs+HIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIs6az4nOtM65zrrPjM+CIFBJTlwiLFxuXHRcIlBJTl9URVhUXCI6IFwizprPic60zrnOus+Mz4IgUElOIM+DzrUgzrLOv863zrjOrM61zrkgzr3OsSDOsc+Dz4bOsc67zq/Pg861zrnPgiDPhM63zr0gzrXPhs6xz4HOvM6/zrPOriDOus6xzrkgz4TOsSDOtM61zrTOv868zq3Ovc6xIM+Dzr/PhS4gPGJyLz48YnIvPjxiPs6jzrfOvM61zq/Pic+Dzrc6PC9iPiDOhs+AzrHOviDOus6xzrkgzrXOvc61z4HOs86/z4DOv865zrfOuM61zq8sIM6tz4fOtc65z4IgbWF4IDQgz4DPgc6/z4PPgM6szrjOtc65zrXPgiDOs865zrEgzr7Otc66zrvOtc6vzrTPic68zrEuIM6Rzr0gzr7Otc+HzqzPg861zrnPgiDPhM6/zr0gzrrPic60zrnOus+MIFBJTiDOriDOsc+Azr/PhM+Nz4fOtc65z4IsIM63IM61z4bOsc+BzrzOv86zzq4gzrjOsSDOus6xz4TOsc+BzrPOrs+DzrXOuSDPhM6xIM+Dz4TOv865z4fOtc6vzrEgzrXOuc+Dz4zOtM6/z4Ugz4TOv8+FIM+Hz4HOrs+Dz4TOty7OnM+Azr/Pgc61zq/PgiDOvc6xIM6+zrHOvc6sIM+Dz4XOvc60zrXOuM61zq/PgiDOus6xzrkgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861zrnPgiDOvc6xIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+CIM+EzrfOvSDOtc+GzrHPgc68zr/Os86uLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLOlc65zrTOv8+Azr/Ouc6uz4POtc65z4JcIixcblx0XCJWT1RFX1RFWFRcIjogXCLOmM6xIM67zqzOss61zrnPgiDOtc65zrTOv8+Azr/Or863z4POtyDPjM+EzrHOvSDOus6sz4DOv865zr/PgiDPiM63z4bOr8+DzrXOuSDPhM63zr0gzrHOvc6sz4HPhM63z4POtyDPg86/z4UuIDxici8+IDxiPs6jzrfOvM61zq/Pic+Dzrc6PC9iPiDOn865IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDPg8+FzrzPgM61z4HOuc67zrHOvM6yzqzOvc6/z4XOvSDPhM63zr0gzrLOsc+Bz43PhM63z4TOsSDPhM63z4Igz4jOrs+Gzr/PhSDOus6xzrjPjs+CIM61z4DOr8+DzrfPgiDPg861IM6tzrrPhM6xzrrPhM6xIM68zrfOvc+NzrzOsc+EzrEuICjOuM61z4TOuc66zq4gz4jOrs+Gzr8sIM6xz4HOvc63z4TOuc66zq4gz4jOrs+Gzr8sIM6xz4DPjC3PiM6uz4bOuc+DzrcpLlwiLFxuXHRcIlZPVEVcIjogXCLOqM6uz4bPic69XCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4Igz4PPh86/zrvOuc6sz4POtc65IM6xzr3Osc+Bz4TOrs+DzrXOuc+CIM63IM+Dz4fPjM67zrnOsSDPg86/z4UhPGJyLz4gPGI+zqPOt868zrXOr8+Jz4POtzo8L2I+IM6fzrkgzrXOuc60zr/PgM6/zrnOrs+DzrXOuc+CIM+Dz4XOvM+AzrXPgc65zrvOsc68zrLOrM69zr/Ovc+EzrHOuSDOsc66z4zOvM6xIM66zrHOuSDPjM+EzrHOvSDOus6sz4DOv865zr/PgiA8Yj7Otc+AzrXOvs61z4HOs86xz4PPhM61zq88L2I+IM+EzrEgz4PPh8+MzrvOuc6xIM+Ezr/PhS5cIixcblx0XCJDT01NRU5UXCI6IFwizqPPh86/zrvOr8+Jzr1cIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIs6YzrEgzrvOrM6yzrXOuc+CIM61zrnOtM6/z4DOv86vzrfPg863IM+Mz4TOsc69IM66zqzPgM6/zrnOv8+CIM+DzrUgzrHOus6/zrvOv8+FzrjOrs+DzrXOuSDOriDPgM6sz4jOtc65IM69zrEgz4POtSDOsc66zr/Ou86/z4XOuM61zq8uXCIsXG5cdFwiTUVOVElPTlNcIjogXCLOlc+AzrnPg863zrzOrM69z4POtc+Jzr1cIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4Igz4POtSDOsc69zrHPhs6tz4HOtc65IM+DzrUgzrHOvc6sz4HPhM63z4POty/Pg8+Hz4zOu865z4wgz4TOv8+FLlwiLFxuXHRcIlJFU1RFRU1cIjogXCLOkc69zrHOtM63zrzOv8+DzrnOtc+Nz4POtc+Jzr1cIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLOmM6xIM67zqzOss61zrnPgiDOtc65zrTOv8+Azr/Or863z4POtyDPjM+EzrHOvSDOus6sz4DOv865zr/PgiDOsc69zrHOtM63zrzOv8+DzrnOtc+Nz4POtc65IM6xzr3OrM+Bz4TOt8+Dzq4gz4POv8+FLlwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwizqHPhc64zrzOr8+DzrXOuc+CXCIsXG5cdFwiVk9USU5HXCI6IFwizqjOt8+Gzr/Phs6/z4HOr86xXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJcXFwizpLOrM+Bzr/PglxcXCIgz4jOrs+Gzr/PhSDOriDPgM6/z4POv8+Dz4TPjCDOtc+AzrfPgc61zqzOts61zrkgz4TOt869IM65z4PPh8+Nz4Igz4jOrs+Gzr/PhSDPg8+EzrfOvSDOtc+GzrHPgc68zr/Os86uLCDPjs+Dz4TOtSDOvc6xIM+Bz4XOuM68zq/Ots61zrnPgiDPhM65z4IgzrHPgM6/zrvOsc6yzq3PgiDPiM6uz4bPic69IDxici8+PGJyLz48Yj7Oo863zrzOtc6vz4nPg863OjwvYj4gzpHPhc+Ez4wgzrjOsSDOsc67zrvOrM6+zrXOuSDPhM6/IFxcXCLOss6sz4HOv8+CXFxcIi/PgM6/z4POv8+Dz4TPjCDPiM6uz4bOv8+FIM6zzrnOsSDOvc6xIM+IzrfPhs6vz4POtc65z4IgzrXPgM6vz4POt8+CIM6xz4HOvc63z4TOuc66zqwgzrrOsc65IM64zrEgzrnPg8+Hz43Otc65IM+AzrHOvc+Ezr/PjSDPg8+EzrfOvSDOtc+GzrHPgc68zr/Os86uXCIsXG5cdFwiU0VSVkVSXCI6IFwizpTOuc6xzrrOv868zrnPg8+Ezq7PglwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwizqDPgc6/z4TOtc65zr3PjM68zrXOvc6xXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwizpHPgM6/zrjOrs66zrXPhc+DzrcgzpHOu867zrHOs8+Ozr1cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIs6gzrvOt8+Bzr/Phs6/z4HOr861z4Igz4jOt8+Gzr/Phs+Mz4HOv8+FXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwizprOsc67z47PgiDOrs+BzrjOtc+CIM6+zrHOvc6sIVwiLFxuXHRcIkxPR0lOXzFcIjogXCLOo8+Fzr3OtM6tz4POv8+FIM68zrUgz4TOvyDPjM69zr/OvM6xIM+Hz4HOrs+Dz4TOtyDOus6xzrkgzrrPic60zrnOus+MIM6zzrnOsSDOvc6xIM+Dz4XOvc61z4fOr8+DzrXOuc+CLlwiLFxuXHRcIkxPR0lOXzJcIjogXCLOpM6/IM66zrvOtc65zrTOryDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrHOvc6sz4HPhM63z4POtywgz4PPh86/zrvOuc6xz4POvM+MLCDPiM6uz4bOvyDOus6xzrkgz4TOt869IM60z4XOvc6xz4TPjM+EzrfPhM6xIM69zrEgzrHOus6/zrvOv8+FzrjOrs+DzrXOuc+CIM66zqzPgM6/zrnOv869LlwiLFxuXHRcIkxPR0lOXzNcIjogXCLOpM6/IM61zr3Otc+BzrPPjCDOus67zrXOuc60zq8gz4fPgc63z4POuc68zr/PgM6/zrnOtc6vz4TOsc65IM6zzrnOsSDOvM61z4TOsc+Gzr/Pgc6tz4IgzrrOsc65IM6xzrvOu86xzrPOriDPhs+Jz4TOv86zz4HOsc+Gzq/Osc+CIM+Ezr/PhSDPgM+Bzr/Phs6vzrsuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIs6kzrEgz4PPhM6/zrnPh861zq/OsSDPh8+Bzq7Pg8+EzrcgzrHPgM6/zrjOt866zrXPjc6/zr3PhM6xzrkgz4PPhM63IM+Dz4XPg866zrXPhc6uIM+Ezr/PgM65zrrOrC4gzprOsc+Ezqwgz4TOt869IM60zrnOrM+BzrrOtc65zrEgzrHPgM6/z4PPjc69zrTOtc+DzrfPgiDPhM6xIM+Dz4TOv865z4fOtc6vzrEgzrTOuc6xzrPPgc6sz4bOv869z4TOsc65LlwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIs6UzrXOvSDOrc+HzrXOuc+CIM67zr/Os86xz4HOuc6xz4POvM+MP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwizprOrM69zrUgzrXOs86zz4HOsc+Gzq4gz4TPjs+BzrFcIixcblx0XCJDQU5DRUxcIjogXCLOkc66z43Pgc+Jz4POt1wiLFxuXHRcIkFEVkFOQ0VEXCI6IFwizpPOuc6xIM+Az4HOv8+Hz4nPgc63zrzOrc69zr/Phc+CXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIs6Vzr3Otc+BzrPPjCDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOr1wiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwizpnOtM65z4nPhM65zrrPjCDOus67zrXOuc60zq8gzrTOt868zr/Pg86vzrXPhc+DzrfPglwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwizprPhc+Bzq/Pic+CL86gz4HPic+EzrXPjc+Jzr0gzrrPic60zrnOus+Mz4JcIixcblx0XCJVU0VSTkFNRVwiOiBcIs6Mzr3Ov868zrEgzqfPgc63z4PPhM63XCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwizqDPgc6/zrLOv867zq4gz4POtSDOms6xz4HPhM6tzrvOtc+CXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwizqPPhc69zrXPgM+Ez4XOs868zq3Ovc63IM6gz4HOv86yzr/Ou86uXCIsXG5cdFwiU0VBUkNIXCI6IFwizpHOvc6xzrbOrs+EzrfPg863XCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCLOns61zrrOr869zrEgzrHOvc6sz4HPhM63z4POt1wiLFxuXHRcIlJFUExZVE9cIjogXCLOkc+AzqzOvc+EzrfPg861IM+DzrVcIixcblx0XCJQT1NUXCI6IFwizpHOvc6sz4HPhM63z4POtVwiLFxuXHRcIlBSRVZJRVdcIjogXCLOoM+Bzr/Otc+AzrnPg866z4zPgM63z4POt1wiLFxuXHRcIkRFRkFVTFRcIjogXCLOoM+Bzr/Otc+AzrnOu86/zrPOriA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwizpHPjc6+zrfPg863IM6Zz4PPh8+Nzr/PgiAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLOkc+Az4zPgc+BzrnPiM63IM6Rz4DOv867zrHOss+Ozr1cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIs6RzqDOn86YzonOms6VzqXOo86VIM6TzpnOkSDOkc6hzpPOn86kzpXOoc6RXCIsXG5cdFwiQ0xFQVJcIjogXCLOms6RzpjOkc6hzpnOo86czpFcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCLOkc69zqzPgc+EzrfPg863IM+AzrXPgc65zrXPh86/zrzOrc69zr/PhVwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIs6jz4fOv867zq/Osc+DzrUgz4DOtc+BzrnOtc+Hz4zOvM61zr3Ov1wiLFxuXHRcIlRJVExFXCI6IFwizqTOr8+EzrvOv8+CXCIsXG5cdFwiVEFHU1wiOiBcIs6Vz4TOuc66zq3PhM61z4JcIixcblx0XCJOT1RfTUFUQ0hcIjogXCLOlM6VIM6jzqXOnM6gzorOoM6kzpXOmVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwizpXPgM65zrLOtc6yzrHOr8+Jz4POtSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCLOm86Rzp3OmM6RzqPOnM6Vzp3On1wiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIs6Gzr3Ov865zr7OtSDOkc69zqzPgc+EzrfPg863XCIsXG5cdFwiU0VUX1BJTlwiOiBcIs6Mz4HOuc+DzrUgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwizpXOuc+DzrHOs8+JzrPOriBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLOlc6vz4POsc65IM+Dzq/Os86/z4XPgc6/z4I/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLOlyDOsc69zrHOtM63zrzOv8+Dzq/Otc+Fz4POtyDOtc6vzr3Osc65IM68zrcgzrHOvc6xz4PPhM+Bzq3PiM65zrzOtywgzrjOrc67zrXOuc+CIM69zrEgz4PPhc69zrXPh86vz4POtc65z4I/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwizpvOrM64zr/PgiDOvM61z4TOrM60zr/Pg863z4IsIM+Az4HOv8+Dz4DOrM64zrfPg861IM6+zrHOvc6sIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLOlc+AzrnPhM+Fz4fOrc+CXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLOkc69zrHOtM63zrzOv8+DzrnOtc+FzrzOrc69zrcgzrHOvc6sz4HPhM63z4POtyFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwizpcgz4PPjc69zrTOtc+DzrcgzrHPgM6tz4TPhc+HzrUhIM6gzrHPgc6xzrrOsc67z44gzrXOvs6xzrrPgc65zrLPjs+Dz4TOtSDOsc69IM+Dz4XOvc60zrXOuM6uzrrOsc+EzrUgzrzOtSDPhM6/zr0gzrrPhc+Bzq/Pic+CIM66z4nOtM65zrrPjCDOriDOtM+Oz4POsc+EzrUgz4TOvyDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOryDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Mz4TOsc69IM61z4DOuc67zq3Ovs6xz4TOtSDPg8+Nzr3OtM61z4POtyDOs865zrEgz4DPgc6/z4fPic+BzrfOvM6tzr3Ov8+Fz4IuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwizpcgz4PPjc69zrTOtc+DzrcgzrHPgM6tz4TPhc+HzrUhIM6gzrHPgc6xzrrOsc67z44gzrXOvs6xzrrPgc65zrLPjs+Dz4TOtSDOsc69IM+Dz4XOvc60zrXOuM6uzrrOsc+EzrUgzrzOtSDPhM6/zr0gzrrPhc+Bzq/Pic+CIM66z4nOtM65zrrPjCDOriDOtM+Oz4POsc+EzrUgz4TOvyDOtc69zrXPgc6zz4wgzrrOu861zrnOtM6vIM60zrfOvM6/z4POr861z4XPg863z4Igz4zPhM6xzr0gzrXPgM65zrvOrc6+zrHPhM61IM+Dz43Ovc60zrXPg863IM6zzrnOsSDPgM+Bzr/Ph8+Jz4HOt868zq3Ovc6/z4XPgi5cIixcblx0XCJXQVJOSU5HXCI6IFwizqDPgc6/zrXOuc60zr/PgM6/zq/Ot8+DzrdcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwizqjOrs+GzrnPg861IM6zzrnOsSB3aXRuZXNzXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCLOqM63z4bOr8+Dz4TOt866zrUgzrPOuc6xIHdpdG5lc3NcIixcblx0XCJBR09cIjogXCLPgM+BzrnOvVwiLFxuXHRcIkZST01fTk9XXCI6IFwizrHPgM+MIM+Ez47Pgc6xXCIsXG5cdFwiU0VDU1wiOiBcIs60zrXPhc+ELlwiLFxuXHRcIkFfTUlOXCI6IFwiz4TOvyDOu861z4DPhM+MXCIsXG5cdFwiTUlOU1wiOiBcIs67zrXPgM+EzqxcIixcblx0XCJBTl9IT1VSXCI6IFwizrzOr86xIM+Oz4HOsVwiLFxuXHRcIkhPVVJTXCI6IFwiz47Pgc61z4JcIixcblx0XCJBX0RBWVwiOiBcIs68zq/OsSDOt868zq3Pgc6xXCIsXG5cdFwiREFZU1wiOiBcIs68zq3Pgc61z4JcIixcblx0XCJBX01PTlRIXCI6IFwizq3Ovc6xIM68zq7Ovc6xXCIsXG5cdFwiTU9OVEhTXCI6IFwizrzOrs69zrXPglwiLFxuXHRcIkFfWUVBUlwiOiBcIs6tzr3OsSDPh8+Bz4zOvc6/XCIsXG5cdFwiWUVBUlNcIjogXCLPh8+Bz4zOvc65zrFcIixcblx0XCJNSU5fUkVBRFwiOiBcIs67zrXPgM+EzqwgzrHOvc6szrPOvc+Jz4POt8+CXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIs6ozq7Phs65z4POtSDOsc+Bzr3Ot8+EzrnOus6sIM6uIM66zqzOvc61IEZsYWdcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCLOkc+Azr/OuM6xzr3OrM+EzrnPg861IM6mz4nPhM6/zrPPgc6xz4bOr86xXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLOlc+Azq3Ou861zr7OtSDOps+Jz4TOv86zz4HOsc+Gzq/OsVwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwizprOsc64z4zPgc65z4POtSDPgM+Bzr/Pg86xz4HOvM6/z4POvM6tzr3OvyBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIs6VzrnPg86uzrPOsc6zzrUgzqbPic+Ezr/Os8+BzrHPhs6vzrFcIixcblx0XCJFUlJPUlwiOiBcIs6bzqzOuM6/z4JcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLOm86szrjOv8+CIM6xz4DOv8+Dz4TOv867zq7PglwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCLOms6szrzOtc+BzrEgzpHOus+Fz4HPjs64zrfOus61XCIsXG5cdFwiU0VUX1VSTFwiOiBcIs6azrHOuM+Mz4HOuc+DzrUgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIs6GzrzOtc+Dzr/PgiDPg8+Nzr3OtM61z4POvM6/z4IgzrPOuc6xIM+EzrfOvSDPhs+Jz4TOv86zz4HOsc+Gzq/OsVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwizqTOvyDPg8+Hz4zOu865zr8gz4XPgM6/zrLOu86uzrjOt866zrUhXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCLOlyDOtM65zrHOs8+BzrHPhs6uIM+Dz4fOv867zq/Pic69IM61zq/Ovc6xzrkgzrzOtyDOsc69zrHPg8+Ez4HOrc+IzrnOvM63Li4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwizpTOuc6xzrPPgc6xzrzOvM6tzr3OvyDPg8+Hz4zOu865zr9cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIs6Rz4DOv8+Dz4TOv867zq4gzqbPic+Ezr/Os8+BzrHPhs6vzrHPglwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLOkc+Azr/Pg8+Ezr/Ou86uIM6fzrvOv866zrvOt8+Bz47OuM63zrrOtVwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLOkc+Azr/Pg8+Ezr/Ou86uIM6Rz4DOrc+Ez4XPh861XCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwizp8gzrrPic60zrnOus+Mz4Igzq4gz4TOvyDPjM69zr/OvM6xIM67zr/Os86xz4HOuc6xz4POvM6/z40gzq7PhM6xzr0gzrvOsc69zrjOsc+DzrzOrc69zr9cIixcblx0XCJJTkZPXCI6IFwizqDOu863z4HOv8+Gzr/Pgc6vzrXPglwiLFxuXHRcIlFSX1RFWFRcIjogXCLOpM6/z4DOv864zq3PhM63z4POtSDOrc69zrEgUVIgzrrPic60zrnOus+MIM+Dz4TOt869IM+Ezr/PgM6/zrjOtc+Dzq/OsSDPg86sz4HPic+DzrfPglwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIs6Vzr7Osc66z4HOr86yz4nPg861IM+Mz4TOuSDOrc+HzrXOuc+CIM60zrnOsc64zq3Pg865zrzOsSDOus61z4bOrM67zrHOuc6xIM6zzrnOsSDPg8+Fzr3Osc67zrvOsc6zzq4hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIs6fIM+Hz4HOrs+Dz4TOt8+CIM+Azr/PhSDPgM+Bzr/Pg8+AzrHOuM61zq/PgiDOvc6xIM68zrXPhM6xz4bOrc+BzrXOuc+CIM66zrXPhs6szrvOsc65zrEsIM60zrXOvSDPhc+AzqzPgc+HzrXOuSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwizpXOr8+Dz4TOtSDPg86vzrPOv8+Fz4HOv8+CIM+Mz4TOuSDOuM6tzrvOtc+EzrUgzr3OsSDOus6szr3Otc+EzrUgzrzOtc+EzrHPhs6/z4HOrD9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLOlc+AzrnOss61zrLOsc6vz4nPg863XCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLOlyDPg8+Fzr3Osc67zrvOsc6zzq4gzrzOtc+EzrHOtM+MzrjOt866zrVcIixcblx0XCJGRUVEXCI6IFwizpHOvc6xz4HPhM6uz4POtc65z4IgzrHPgM+MIM+Hz4HOrs+Dz4TOtc+CIM+Azr/PhSDOsc66zr/Ou86/z4XOuM61zq/PglwiLFxuXHRcIlRSRU5ESU5HXCI6IFwizpTOt868zr/Phs65zrvOrc+Dz4TOtc+BzrXPgiDOsc69zrHPgc+Ezq7Pg861zrnPglwiLFxuXHRcIkhPVFwiOiBcIs6Rzr3Osc+Bz4TOrs+DzrXOuc+CIM68zrUgz4XPiM63zrvOriDOtM+BzrHPg8+EzrfPgc65z4zPhM63z4TOsVwiLFxuXHRcIk5FV1wiOiBcIs6gz4HPjM+Dz4bOsc+EzrXPgiDOsc69zrHPgc+Ezq7Pg861zrnPglwiLFxuXHRcIlBST01PVEVEXCI6IFwizqDPgc6/z4nOuM6/z43OvM61zr3OsVwiLFxuXHRcIlZPVEVTXCI6IFwizpLOrM+Dzrcgz4jOrs+Gz4nOvVwiLFxuXHRcIlBBWU9VVFwiOiBcIs6SzqzPg863IM6xz4DOv860zr/Ph8+Ozr1cIixcblx0XCJDT01NRU5UU1wiOiBcIs6SzqzPg863IM+Dz4fOv867zq/Pic69XCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCLOlM63zrzOv8+GzrnOu86tz4PPhM61z4HOtc+CIM6xzr3Osc+Bz4TOrs+DzrXOuc+CIDMwIM63zrzOtc+Bz47OvVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIs6kzrHOvs65zr3PjM68zrfPg863IM6yzqzPg863OlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIs6az43Ous67zr/PgiDPgM67zrfPgc+JzrzOrs+CXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIs6gzrnOuM6xzr3Orc+CIM6Rz4DOv860zr/Ph86tz4JcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIs6gzrHOu86xzrnPjM+EzrXPgc61z4IgzpHPgM6/zrTOv8+Hzq3PglwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLOkc+Azr/OtM6/z4fOrc+CIM6jz4XOs86zz4HOsc+Gzq3OsVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIs6Rz4DOv860zr/Ph86tz4IgzrHPgM+MIEN1cmF0aW9uXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLOlyDOsc69zqzPgc+EzrfPg863IM+Fz4DOv86yzrvOrs64zrfOus61IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLOkc69zqzPgc+EzrfPg863IM6zzrnOsSDOvM61zrvOu86/zr3PhM65zrrOriDOus6/zrnOvc6/z4DOv86vzrfPg863IVwiLFxuXHRcIlNBVkVEXCI6IFwizpHPgM6/zrjOt866zrXPjc+EzrfOus61XCIsXG5cdFwiQ0xFQVJFRFwiOiBcIs6jzrLOrs+Dz4TOt866zrVcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwizprOsc+EzrHPiM63z4bOr862zr/Ovc+EzrHPgiDOvM65zrEgzrHOvc6sz4HPhM63z4POtyDOvM+Azr/Pgc61zq8gzr3OsSDPhM63z4IgzrHPhs6xzrnPgc6tz4POtc65IM6xzrzOv865zrLOrc+CIM66zrHOuSDOvc6xIM+EzrfOvSDOus6szr3Otc65IM67zrnOs8+Mz4TOtc+Bzr8gzr/Pgc6xz4TOri48YnI+PGJyPiDOlyDOus6xz4TOsc+Izq7Phs65z4POtyDOuM6xIM6tz4DPgc61z4DOtSDOvc6xIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrE6IDx1bD48bGk+zpHPgM6sz4TOtyDOriDOus67zr/PgM6uIM+Azr3Otc+FzrzOsc+EzrnOus+Ozr0gzrTOuc66zrHOuc+OzrzOsc+Ez4nOvTwvbGk+PGxpPs6lzrLPgc65z4PPhM65zrrOriDOs867z47Pg8+DzrEgzrrOsc65IFRyb2xsaW5nPC9saT48bGk+zpXPg866zrXOvM68zq3Ovc63IM+Ezr/PgM6/zrjOrc+EzrfPg863IM+DzrUgzrvOrM64zr/PgiDOus6xz4TOt86zzr/Pgc6vzrEgz4DOtc+BzrnOtc+Hzr/OvM6tzr3Ov8+FIM6uIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwizqTOvyDOsc6vz4TOt868zrEgzq3Phs+EzrHPg861IM+Dz4TOvyDPjM+BzrnOvyDPhM6/z4UuIM6VzrvOrc6zzr7PhM61IM6szrvOu861z4IgzrXPhM65zrrOrc+EzrXPgi/Ous6xz4TOt86zzr/Pgc6vzrXPglwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIs6XIM6xzr3OrM+Bz4TOt8+DzrcgzrHPgM6/zrzOsc66z4HPjc69zrjOt866zrUgzrHPgM+MIM+Ezr/Phc+CIM+DzrXOu865zrTOv860zrXOr866z4TOtc+CIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLOlyDOsc69zqzPgc+EzrfPg863IM+Az4HOv8+Dz4TOrc64zrfOus61IM+Dz4TOv8+Fz4Igz4POtc67zrnOtM6/zrTOtc6vzrrPhM61z4IhXCIsXG5cdFwiUkVTRVRcIjogXCLOlc+AzrHOvc6xz4bOv8+BzqwgzrHPgc+HzrnOus+Ozr0gz4HPhc64zrzOr8+DzrXPic69XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLOlc+AzrXOvs61z4HOs86xz4POr86xIM6mz4nPhM6/zrPPgc6xz4bOr86xz4IgzqDPgc6/z4bOr867XCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCLOlc+AzrXOvs61z4HOs86xz4POr86xIM+Gz4nPhM6/zrPPgc6xz4bOr86xz4Igz4DPgc6/z4bOr867XCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwizqDOsc+BzrHOus6xzrvPjiDOtM+Oz4POtSDOlc69zrXPgc6zz4wvQWN0aXZlIM65zrTOuc+Jz4TOuc66z4wgzrrOu861zrnOtM6vIM61zqzOvSDOtc+Azq3Ou861zr7Otc+CIM+Dz43Ovc60zrXPg863IM6zzrnOsSDPgM+Bzr/Ph8+Jz4HOt868zq3Ovc6/z4XPgiFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCLOkc+Fz4TPjCDOuM6xIM66zqzOvc61zrkgzrXPgM6xzr3Osc+Gzr/Pgc6sIM+EzrfPgiDPhs+Jz4TOv86zz4HOsc+Gzq/Osc+CIM+Ezr/PhSDPgM+Bzr/Phs6vzrtcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCLOkc+Fz4TPjCDOuM6xIM61z4DOsc69zrHPhs6tz4HOtc65IM+EzrfOvSDOtc65zrrPjM69zrEgz4fPgc6uz4PPhM63XCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLOlyDOsc69zrHOss6szrjOvM65z4POtyDPhM6/z4UgzrTOuc6xzrrOv868zrnPg8+Ezq4gzrHPgM6xzrnPhM61zq8gzrXPgM6xzr3Otc66zrrOr869zrfPg863IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCLOn865IM+Bz4XOuM68zq/Pg861zrnPgiDOtc69zrXPgc6zzr/PgM6/zrnOrs64zrfOus6xzr0hXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwizpPOu8+Oz4PPg861z4JcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIs6VzrTPjiDOvM+Azr/Pgc61zq/PgiDOvc6xIM6xzrvOu86szr7Otc65z4Igz4TOt869IM6zzrvPjs+Dz4POsSDPhM63z4IgzrXPhs6xz4HOvM6/zrPOrs+CLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLOkc+Fz4TOriDOtyDOu861zrnPhM6/z4XPgc6zzq/OsSDOsc+AzrHOuc+EzrXOryDOvyDPh8+Bzq7Pg8+EzrfPgiDOvc6xIM61zq/Ovc6xzrkgz4PPhc69zrTOtc60zrXOvM6tzr3Ov8+CIM68zrUgz4TOv869IM66z4XPgc65z47PgiDOus+JzrTOuc66z4wgYWN0aXZlL3Bvc3Rpbmcga2V5Ls6gzrHPgc6xzrrOsc67z44gz4PPhc69zrTOrc+Dzr/PhSDOus6xzrkgz4DPgc6/z4PPgM6szrjOt8+DzrUgzr7Osc69zqwuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIs6IzrrOuM61z4POt1wiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIs6jz4XOvc+EzrXOu861z4PPhM6tz4IgzrzOtc+EzqzPhs+BzrHPg863z4JcIixcblx0XCJTSEFSRVwiOiBcIs6czr/Ouc+BzqzPg86/z4VcXG5cIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIs6RzrPOv8+BzqxcIixcblx0XCJFWENIQU5HRVwiOiBcIs6Rzr3PhM6xzrvOu86xzrrPhM6uz4HOuc6/XCIsXG5cdFwiRFJBRlRTXCI6IFwizqDPgc+Mz4fOtc65z4HOsVwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIs6XIM60zrfOvM6/z4POr861z4XPg863IM6xz4bOsc65z4HOrc64zrfOus61IM6xz4DPjCDPhM6/IM+Az4HPjM+HzrXOuc+Bzr9cIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwizpcgzrTOt868zr/Pg86vzrXPhc+Dzrcgz4DPgc6/z4PPhM6tzrjOt866zrUgz4PPhM6/IM+Az4HPjM+HzrXOuc+Bzr9cIixcblx0XCJTV0lQRV9MRUZUXCI6IFwizqPPjc+BzrUgzrHPgc65z4PPhM6tz4HOsSDOs865zrEgzr3OsSDOtM61zrnPgiDPhM65z4IgzrXPgM65zrvOv86zzq3PglwiLFxuXHRcIk1BTkFHRVwiOiBcIs6UzrnOsc+HzrXOr8+BzrfPg863XCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIs6XIM61zrnOus+Mzr3OsSDOsc+GzrHOuc+Bzq3OuM63zrrOtVwiLFxuXHRcIkNPUFlcIjogXCLOkc69z4TOuc6zz4HOsc+Gzq5cIixcblx0XCJOT19JTUFHRVwiOiBcIs6UzrXOvSDOrc+HzrXOuc+CIM6xzr3Otc6yzqzPg861zrkgzrXOuc66z4zOvc6xIM6xzrrPjM68zrFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIs6jz43Pgc+EzrUgz4DPgc6/z4Igz4TOsSDOus6sz4TPiSDOs865zrEgzrHOvc6xzr3Orc+Jz4POt1wiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLOlc6+z4nPhM61z4HOuc66zq3PgiDOtc+GzrHPgc68zr/Os86tz4JcIixcblx0XCJQTFVHSU5TXCI6IFwizqDPgc+Mz4POuM61z4TOsVwiLFxuXHRcIlNVR0dFU1RcIjogXCLOoM+Bz4zPhM61zrnOvc61XCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCLOiM+Bz4fOtc+EzrHOuSDPg8+Nzr3PhM6/zrzOsVwiLFxuXHRcIkNIQUlOXCI6IFwizpHOu8+Fz4POr860zrFcIixcblx0XCJDSEFJTl9URVhUXCI6IFwizpXOtM+OIM68z4DOv8+BzrXOr8+CIM69zrEgzrHOu867zqzOvs61zrnPgiDPhM63zr0gzrHOu8+Fz4POr860zrEgz4TPic69IM68z4DOu86/zrogzq4gz4TOt869IM+Az4HOv861z4DOuc67zrXOs868zq3Ovc63IM+AzrvOsc+Ez4bPjM+BzrzOsS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIs6dz4zOvM65z4POvM6xXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIs6VzrTPjiDOvM+Azr/Pgc61zq/PhM61IM69zrEgzrHOu867zqzOvs61z4TOtSDPhM6/IM+Az4HOv861z4DOuc67zrXOs868zq3Ovc6/IM+DzrHPgiDOvc+MzrzOuc+DzrzOsS4gzpjOsSDOtM61zq/PhM61IM+EzrfOvSDOsc69z4TOsc68zr/Ouc6yzq4gz4TOt8+CIM6xzr3OrM+Bz4TOt8+DzrfPgi/Pg8+Hzr/Ou86vzr/PhSDPg86xz4Igz4POtSDOsc+Fz4TPjCDPhM6/IM69z4zOvM65z4POvM6xLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPs6bzq/Pg8+EzrEgzrzOtSDPhM6xIM+HzrHPgc6xzrrPhM63z4HOuc+Dz4TOuc66zqw8L2I+IDxicj4tzqDPgc+Mz4POss6xz4POtyDPg861IM68zr/Ovc6xzrTOuc66zqwgzqzPgc64z4HOsSDPg861IM6/z4DOv865zr/OtM6uz4DOv8+EzrUgzrjOrc68zrEgz4POsc+CIM61zr3OtM65zrHPhs6tz4HOtc65LiA8YnI+IC1cXFwizqDOu863z4POr86xz4POtVxcXCIgz4PPhc6zzrPPgc6xz4bOtc6vz4Igz4PPh86/zrvOuc6szrbOv869z4TOsc+CIM66zrHOuSDPg8+FzrbOt8+Ez47Ovc+EzrHPgiDOuM6tzrzOsc+EzrEuIDxicj4tzqjOrs+GzrnPg861IM6xzr3Osc+Bz4TOrs+DzrXOuc+CIM+Oz4PPhM61IM69zrEgzrHOvc+EzrHOvM61zrnPhs64zr/Pjc69IM+Dz4XOs86zz4HOsc+GzrXOr8+CIM66zrHOuSDOus6tz4HOtM65z4POtSDOsc69z4TOsc68zr/Ouc6yzq3PgiDOtc+AzrnOvM6tzrvOtc65zrHPgi4gPGJyPi3OlM63zrzOv8+Dzq/Otc+Fz4POtSDPhM6xIM6sz4HOuM+BzrEgz4POv8+FLCDOsc69zqzPgc+EzrfPg861IM+Azr/Pg8+EIM66zrHOuSDPhs65zrvOv86+zq3Ovc63z4POtSDPhM6xIM60z4nPgc61zqzOvSDOus6xzrjPjs+CIM61z4DOr8+DzrfPgiDOu86szrLOtSDOsc69z4TOsc68zr/Ouc6yzq3PgiDPg8+FzrzOvM61z4TOrc+Hzr/Ovc+EzrHPgiDOus6xzrkgzrHPgM6/zrrPhM+Ozr3PhM6xz4Igzr/PgM6xzrTOv8+Nz4IuIDxicj4tzpPPgc6sz4jOtSDOrM+BzrjPgc6xIM+Az4HOv8+Hz4nPgc+Ozr3PhM6xz4IgzrrOsc65IM6xz4DOv864zq7Ous61z4XPg861IM+Azr/Ou867zrHPgM67zqwgz4DPgc+Mz4fOtc65z4HOsSDPgM6/z4PPhCwgzq3PhM6/zrnOvM6xIM6zzrnOsSDOvM61zrvOu86/zr3PhM65zrrOriDOtM63zrzOv8+Dzq/Otc+Fz4POty4gPGJyPi3Oks6szrvOtSDPg861zrvOuc60zr/OtM61zq/Ous+EzrXPgiDPg861IM6xzrPOsc+AzrfOvM6tzr3OsSDOrM+BzrjPgc6xIM6zzrnOsSDOvc6xIM+EzrEgzrTOuc6xzrLOrM+DzrXOuc+CIM6xz4HOs8+Mz4TOtc+BzrEuIDxicj4tzpHOvc+EzqzOu867zrHOvs61IM6uIM61zr7Osc+BzrPPjc+Bz4nPg861IM+EzrEgzrrOrc+BzrTOtyDPg86/z4UuIDxicj4tzqPPhM61zq/Ou861IM+Hz4HOrs68zrHPhM6xIM+DzrUgzr/PgM6/zrnOv860zq7PgM6/z4TOtSDPg8+FzrPOs8+BzrHPhs6tzrEsIM+Hz4HOrs+Dz4TOtywgz4bOr867zr8sIM6xzr3Osc6zzr3Pjs+Dz4TOtyDOus67z4AgPGJyPi3Okc66zr/Ou86/z43OuM63z4POtSDOtc69zrTOuc6xz4bOrc+Bzr/Ovc+EzrXPgiDPg8+FzrPOs8+BzrHPhs61zq/PgiwgYmxvZ2dlcnMuIDxicj4gLc6Sz4HOtc+CIM+Ezr/Phc+CIM6xzr3Osc6zzr3Pjs+Dz4TOtc+CIM66zrHOuSDPg8+FzrPOs8+BzrHPhs61zq/PgiDPgM6/z4Ugz4POtSDOsc66zr/Ou86/z4XOuM6/z43OvS4gPGJyPi3Om86szrLOtc+EzrUgzrXOuc60zr/PgM6/zrnOrs+DzrXOuc+CIM6zzrnOsSDOvc6xIM68zrXOr869zrXPhM61IM+DzrUgzrXPgM6xz4bOriDOvM61IM+Ezr/Phc+CIM6xzr3Osc6zzr3Pjs+Dz4TOtc+CIM+DzrHPgiDOus6xzrkgz4TOuc+CIM+Dz4XOts63z4TOrs+DzrXOuc+CIM+Azr/PhSDPg8+FzrzOvM61z4TOrc+HzrXPhM61LiA8YnI+Lc6ozqzOvs61IM61zr3OtM65zrHPhs6tz4HOv8+Fz4POtc+CIM61z4TOuc66zq3PhM61z4IvzrrOsc+EzrfOs86/z4HOr861z4IgzqzPgc64z4HPic69LCDPg8+Fzr3PhM6xzrrPhM+Ozr0uIDxicj4gLc6Vzr7Osc+Ezr/OvM6vzrrOtc+Fz4POtSDPhM6/IM+Az4HOv8+Gzq/OuyDPg86/z4UuIDxicj4tzqDOv867zrvOrCDPgM61z4HOuc+Dz4PPjM+EzrXPgc6xIM+HzrHPgc6xzrrPhM63z4HOuc+Dz4TOuc66zqwgz4DPgc+MzrrOtc65z4TOsc65IM69zrEgzrHOus6/zrvOv8+FzrjOrs+Dzr/Phc69LiA8YnI+PGJyPjxiPs6Rz4PPhs6szrvOtc65zrE8L2I+IDxicj4xLiDOlyDOtc+GzrHPgc68zr/Os86uIM60zrXOvSDOrc+HzrXOuSDPgM6/z4TOrSDPgM+Bz4zPg86yzrHPg863IM6uIM6/z4DOv865zrHOtM6uz4DOv8+EzrUgzrHOvc6szrzOuc6+zrcgz4PPhM6xIM66zrXPhs6szrvOsc65zrEgz4TOv8+FIM+Hz4HOrs+Dz4TOty4gPGJyPjIuIM6XIM61z4bOsc+BzrzOv86zzq4gz4DPgc6/z4PPhs6tz4HOtc65IM6tzr3OsSDOvM6/zr3PhM6tzrvOvyDOsc+Dz4bOsc67zrXOr86xz4IgzrHPgM+MIM+EzrfOvSDPgM67zrXPhc+Bzqwgz4TOv8+FIM+Az4HOv86zz4HOrM68zrzOsc+Ezr/Pgi3PgM61zrvOrM+EzrcsIM68zrUgz4TOsSDOuc60zrnPic+EzrnOus6sIM66zrvOtc65zrTOuc6sIM69zrEgz4bOuc67zr/Ovs61zr3Ov8+Nzr3PhM6xzrkgz4TOv8+AzrnOus6sIM+Hz4nPgc6vz4Igzr3OsSDOsc+Azr/Pg8+Ezq3Ou867zr/Ovc+EzrHOuSDPgM6/z4TOrSDPg861IM6/z4DOv865zr/OtM6uz4DOv8+EzrUgzrTOuc6xzrrOv868zrnPg8+Ezq4sIM61z4PPjSDOtc6vz4POsc65IM+Fz4DOtc+NzrjPhc69zr/PgiDOs865zrEgz4TOtyDOtM63zrzOuc6/z4XPgc6zzq/OsSDOsc69z4TOuc6zz4HOrM+Gz4nOvSDOsc+Dz4bOsc67zrXOr86xz4Igz4TPic69IM66z4nOtM65zrrPjs69IM+Az4HPjM+DzrLOsc+DzrfPgiDPg86/z4UuIDxicj4zLiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOsc+AzrvPjCDOus6xzrkgzrXOu866z4XPg8+EzrnOus+MIM+AzrXPgc65zrLOrM67zrvOv869IM+Hz4HOrs+DzrfPgiDOus6xzrkgzrXOvM+AzrXOuc+Bzq/Osc+CIDxicj40LiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOtc+AzrnPgM67zq3Ov869IM+Dz4TPgc+OzrzOsSDPhM63z4IgzrHPg8+GzqzOu861zrnOsc+CIM68zrUgzrrPic60zrnOus+MIHBpbiA8YnI+PGJyPs61zrrPhM6vzrzOt8+Dzrcgz4XPgM6/z4PPhM63z4HOr862zrXOuSDPgM67zrHPhM+Gz4zPgc68zrXPgiBTdGVlbSDOus6xzrkgR29sb3MuIDxicj5cIixcblx0XCJGT1VOREVSXCI6IFwizpnOtM+Bz4XPhM6uz4IgzrrOsc65IM61z4DOuc66zrXPhs6xzrvOrs+CIM+Az4HOv86zz4HOsc68zrzOsc+EzrnPg8+Ezq7PglwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwizqDPgc6/z4POuM6uzrrOtyDOu86/zrPOsc+BzrnOsc+DzrzOv8+NXCIsXG5cdFwiUExBVEZPUk1cIjogXCLOoM67zrHPhM+Gz4zPgc68zrFcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiSG9tZVwiLFxuXHRcIkxPR0lOXCI6IFwiTG9naW5cIixcblx0XCJMT0dPVVRcIjogXCJMb2dvdXRcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsZVwiLFxuXHRcIkZPTExPV1wiOiBcIkZvbGxvd1wiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIkJvb2ttYXJrc1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwiVHJhbnNmZXJcIixcblx0XCJNQVJLRVRcIjogXCJNYXJrZXRcIixcblx0XCJTRVRUSU5HU1wiOiBcIlNldHRpbmdzXCIsXG5cdFwiQUJPVVRcIjogXCJBYm91dFwiLFxuXHRcIkFCT1VUXzFcIjogXCJ3aGVyZSBhbnlvbmUgY2FuIGVhcm4gcmV3YXJkcyBmb3IgdGhlaXIgY29udGVudCFcIixcblx0XCJBQk9VVF8yXCI6IFwiaXMgc29jaWFsIGFwcGxpY2F0aW9uIHdoZXJlIHlvdSBnZXQgcGFpZCBmb3IgYmxvZ2dpbmcsIGNvbW1lbnRpbmcgYW5kIGN1cmF0aW5nLlwiLFxuXHRcIkFCT1VUXzNcIjogXCJhbmQgaXQgaXMgb3Blbi1zb3VyY2UsIGNvbW11bml0eSBkcml2ZW4gbW9iaWxlIHByb2plY3QuIEl0IG9mZmVycyBjb250ZW50IGFjY2VzcyBmb3IgcmVhZGluZywgY29tbWVudGluZywgdm90aW5nLCBwb3N0aW5nLCB0cmFuc2ZlciBlYXJuaW5ncywgZXRjLiBmZWF0dXJlcyBvZmZlcmVkIGJ5IHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiBhbmQge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBBcHAgbmV2ZXIgYWNjZXNzIG9yIGhvbGQgb250byB1c2VyIGZ1bmRzLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBcHAgb2ZmZXJzIGEgY2xpZW50LXNpZGUgc2VjdXJpdHkgbW9kZWwsIHdpdGggcHJpdmF0ZSBrZXlzIGhvc3RlZCBsb2NhbGx5IGFuZCBuZXZlciBzZW50IHRvIGFueSBzZXJ2ZXJzLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBcHAgb2ZmZXJzIHNpbXBsZSwgYXR0cmFjdGl2ZSB1c2VyIGludGVyZmFjZXMgYW5kIGV4cGVyaWVuY2VzLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBBcHAgbmV2ZXIgcmVxdWlyZSB1c2VycyB0byBpbnB1dCBhbnkgcGVyc29uYWwgaW5mb3JtYXRpb24uXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlZvdGUgZ29vZC1rYXJtYSBhcyB3aXRuZXNzXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhY3QvRmVlZGJhY2s6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNb3JlIGluZm86XCIsXG5cdFwiUkVNT1ZFXCI6IFwiUmVtb3ZlXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJNYXJrZXQgVmlld1wiLFxuXHRcIlBSSUNFXCI6IFwiUHJpY2VcIixcblx0XCJBTU9VTlRcIjogXCJBbW91bnRcIixcblx0XCJUT1RBTFwiOiBcIlRvdGFsXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJObyBvcGVuIG9yZGVycyBmb3JcIixcblx0XCJEQVRFXCI6IFwiRGF0ZVwiLFxuXHRcIkJVWVwiOiBcIkJ1eVwiLFxuXHRcIlNFTExcIjogXCJTZWxsXCIsXG5cdFwiT1BFTlwiOiBcIk9wZW5cIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yeVwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiRm9sbG93IGJhY2tcIixcblx0XCJGT0xMT1dFRFwiOiBcIkZvbGxvd2VkXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJVbmZvbGxvd1wiLFxuXHRcIkZPTExPV0lOR1wiOiBcIkZvbGxvd2luZ1wiLFxuXHRcIkZPTExPV0VSU1wiOiBcIkZvbGxvd2Vyc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJTZWFyY2ggZm9sbG93ZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIlNlYXJjaCBmb2xsb3dpbmdcIixcblx0XCJCWVwiOiBcImJ5XCIsXG5cdFwiSU5cIjogXCJpblwiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJCb29rbWFya1wiLFxuXHRcIlJFQkxPR1wiOiBcIlJlYmxvZ1wiLFxuXHRcIlVQVk9URVwiOiBcIlVwdm90ZVwiLFxuXHRcIkRPV05WT1RFXCI6IFwiRG93bnZvdGVcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiVW52b3RlIERvd252b3RlZFwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiVW52b3RlIHVwdm90ZWRcIixcblx0XCJSRVBMWVwiOiBcIlJlcGx5XCIsXG5cdFwiRURJVFwiOiBcIkVkaXRcIixcblx0XCJQT1NUXzFcIjogXCJTd2lwZSBsZWZ0IG9uIGNvbW1lbnRzIHRvIHNlZSBvcHRpb25zXCIsXG5cdFwiUE9TVF8yXCI6IFwiVGFwIG9uIGNvbW1lbnRzIHRvIHNlZSBzdWItY29tbWVudHNcIixcblx0XCJPUFRJT05TXCI6IFwiT3B0aW9uc1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlYmxvZ2dlZCBieVwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIk5vdGhpbmcgaGVyZSwgeWV0Li4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJCYWxhbmNlc1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIHRyYWRlYWJsZSB0b2tlbnMgdGhhdCBtYXkgYmUgdHJhbnNmZXJyZWQgYXQgYW55dGltZS4ge3twbGF0Zm9ybW5hbWV9fSBjYW4gYmUgY29udmVydGVkIHRvIHt7cGxhdGZvcm1wb3dlcn19IGluIGEgcHJvY2VzcyBjYWxsZWQgcG93ZXJpbmcgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGluZmx1ZW5jZSB0b2tlbnMgdGhhdCBlYXJuIG1vcmUgcG93ZXIgZm9yIGhvbGRpbmcgbG9uZyB0ZXJtIGFuZCB2b3Rpbmcgb24gcG9zdHMuIFRoZSBtb3JlIG9uZSBob2xkcyB0aGUgbW9yZSBvbmUgY2FuIGluZmx1ZW5jZSBvdGhlcuKAmXMgcmV3YXJkcyBhbmQgZWFybiByZXdhcmRzIGZvciBhY2N1cmF0ZSB2b3RpbmcuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW5zIHdvcnRoIGFib3V0IHt7cGxhdGZvcm1zdW5pdH19IG9mIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiRXN0aW1hdGVkIFZhbHVlXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiVGhlIGVzdGltYXRlZCB2YWx1ZSBpcyBiYXNlZCBvbiBhIDcgZGF5IGF2ZXJhZ2UgdmFsdWUgb2Yge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiVHJhbnNhY3Rpb24gSGlzdG9yeVwiLFxuXHRcIlBPU1RJTkdcIjogXCJQb3N0aW5nXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiVGhlIHBvc3Rpbmcga2V5IGlzIHVzZWQgZm9yIHBvc3RpbmcgYW5kIHZvdGluZy4gSXQgc2hvdWxkIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBhY3RpdmUgYW5kIG93bmVyIGtleXMuXCIsXG5cdFwiT1dORVJcIjogXCJPd25lclwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIlRoZSBvd25lciBrZXkgaXMgdGhlIG1hc3RlciBrZXkgZm9yIHRoZSBhY2NvdW50IGFuZCBpcyByZXF1aXJlZCB0byBjaGFuZ2UgdGhlIG90aGVyIGtleXMuIFRoZSBwcml2YXRlIGtleSBvciBwYXNzd29yZCBmb3IgdGhlIG93bmVyIGtleSBzaG91bGQgYmUga2VwdCBvZmZsaW5lIGFzIG11Y2ggYXMgcG9zc2libGUuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWN0aXZlXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiVGhlIGFjdGl2ZSBrZXkgaXMgdXNlZCB0byBtYWtlIHRyYW5zZmVycyBhbmQgcGxhY2Ugb3JkZXJzIGluIHRoZSBpbnRlcm5hbCBtYXJrZXQuXCIsXG5cdFwiTUVNT1wiOiBcIk1lbW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJUaGUgbWVtbyBrZXkgaXMgdXNlZCB0byBjcmVhdGUgYW5kIHJlYWQgbWVtb3MuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIlBvc3RzXCIsXG5cdFwiUkVQTElFU1wiOiBcIlJlcGxpZXNcIixcblx0XCJXQUxMRVRcIjogXCJXYWxsZXRcIixcblx0XCJUQUdcIjogXCJUYWdcIixcblx0XCJVU0VSXCI6IFwiVXNlclwiLFxuXHRcIkNMT1NFXCI6IFwiQ2xvc2VcIixcblx0XCJUT1wiOiBcIlRvXCIsXG5cdFwiQVNTRVRcIjogXCJBc3NldFwiLFxuXHRcIlNFTkRcIjogXCJTZW5kXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTZWN1cml0eVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkF2YWlsYWJsZVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiUHVibGljIE1lbW9cIixcblx0XCJUT19ERVNDXCI6IFwiVXNlciBlLmcuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbiBDb2RlXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU4gY29kZSBoZWxwcyB5b3UgdG8gc2VjdXJlIGFwcCBhbmQgeW91ciBkYXRhLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IE9uY2UgZW5hYmxlZCwgeW91IGhhdmUgbWF4IDQgdHJpZXMgdG8gdW5sb2NrLCBpZiB5b3UgZm9yZ290IHBpbiBvciBmYWlsLCBhcHAgd2lsbCByZW1vdmUgbG9nZ2VkIGluIHVzZXIgZGF0YS4gWW91IGNhbiByZS1sb2dpbiBhbmQgY29udGludWUgdXNpbmcgYXBwLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJOb3RpZmljYXRpb25zXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiWW91IHdpbGwgZ2V0IG5vdGlmaWNhdGlvbiB3aGVuIHNvbWVvbmUgdm90ZXMgeW91ciBjb250ZW50ISA8YnIvPiA8Yj5Ob3RlOjwvYj4gTm90aWZpY2F0aW9ucyBpbmNsdWRlIHZvdGluZyB3ZWlnaHQgYXMgd2VsbCBpbiBhbGVydCBtZXNzYWdlLiAoYmUgaXQgdXAtdm90ZSwgZG93bi12b3RlLCB1bi12b3RlKS5cIixcblx0XCJWT1RFXCI6IFwiVm90ZVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIllvdSB3aWxsIGdldCBub3RpZmljYXRpb24gd2hlbiBzb21lb25lIGNvbW1lbnRzIG9uIHlvdXIgcG9zdHMgb3IgY29tbWVudHMhPGJyLz4gPGI+Tm90ZTo8L2I+IE5vdGlmaWNhdGlvbnMgaW5jbHVkZSB3aGVuIHNvbWVvbmUgPGI+ZWRpdHM8L2I+IHRoZWlyIGNvbW1lbnRzIGFzIHdlbGwuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkNvbW1lbnRcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIllvdSB3aWxsIGdldCBub3RpZmljYXRpb24gd2hlbiBzb21lb25lIEZvbGxvdyBvciBVbmZvbGxvdyB5b3UhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW50aW9uc1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSBtZW50aW9ucyB5b3UgaW4gdGhlaXIgcG9zdC9jb21tZW50IVwiLFxuXHRcIlJFU1RFRU1cIjogXCJSZWJsb2dcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSByZWJsb2dzIHlvdXIgcG9zdCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYXRpb25zXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90aW5nXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJWb3RlIHdlaWdodCBvciBwZXJjZW50YWdlIGFmZmVjdHMgdm90aW5nIHBvd2VyIG9uIGFwcCwgc28geW91IGNhbiByZWd1bGF0ZSB5b3VyIHZvdGluZyByZXdhcmQuIDxici8+PGJyLz48Yj5Ob3RlOjwvYj4gVGhpcyB3aWxsIGNoYW5nZSB2b3Rpbmcgd2VpZ2h0L3BlcmNlbnRhZ2UgZm9yIGRvd252b3RpbmcgYXMgd2VsbCBhbmQgaXQgaXMgZXZlcnl3aGVyZSBvbiBhcHBcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJlY29tbWVuZGVkXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2F2ZSBDaGFuZ2VzXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJWb3RlcnMgaW5mb1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIldlbGNvbWUgYmFjayFcIixcblx0XCJMT0dJTl8xXCI6IFwiU2lnbiBpbiB3aXRoIHlvdXIgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHRvIGNvbnRpbnVlLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJQb3N0aW5nIGtleSBpcyB1c2VkIGZvciBwb3N0LCBjb21tZW50LCB2b3RlLCBmb2xsb3cuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFjdGl2ZSBrZXkgaXMgdXNlZCBmb3IgdHJhbnNmZXJzIGFuZCBwcm9maWxlIHBpY3R1cmUgdXBkYXRlLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJVc2VyIGNyZWRlbnRpYWxzIGFyZSBrZXB0IGxvY2FsbHkgb24gdGhlIGRldmljZS4gVXBvbiBMb2dvdXQgY3JlZGVudGlhbHMgYXJlIHJlbW92ZWQhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiRG9uJ3QgaGF2ZSBhbiBhY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiU2lnbiB1cCBub3dcIixcblx0XCJDQU5DRUxcIjogXCJDYW5jZWxcIixcblx0XCJBRFZBTkNFRFwiOiBcIkFkdmFuY2VkXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkFjdGl2ZSBwcml2YXRlIGtleVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUG9zdGluZyBwcml2YXRlIGtleVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVyL21haW4gcGFzc3dvcmRcIixcblx0XCJVU0VSTkFNRVwiOiBcIlVzZXJuYW1lXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiQ2FyZCB2aWV3XCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiQ29tcGFjdCB2aWV3XCIsXG5cdFwiU0VBUkNIXCI6IFwiU2VhcmNoXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJTdWJtaXQgYSBzdG9yeVwiLFxuXHRcIlJFUExZVE9cIjogXCJSZXBseSB0b1wiLFxuXHRcIlBPU1RcIjogXCJQb3N0XCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZXZpZXdcIixcblx0XCJERUZBVUxUXCI6IFwiRGVmYXVsdCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgVXAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiRGVjbGluZSBQYXlvdXRcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNBVkUgRk9SIExBVEVSXCIsXG5cdFwiQ0xFQVJcIjogXCJDTEVBUlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBvc3QgY29udGVudFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkNvbW1lbnQgY29udGVudFwiLFxuXHRcIlRJVExFXCI6IFwiVGl0bGVcIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk5PVCBNQVRDSFwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiQ29uZmlybSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJTkNPUlJFQ1RcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJvcGVuaW5nIHBvc3RcIixcblx0XCJTRVRfUElOXCI6IFwiU2V0IFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkVudGVyIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIkFyZSB5b3Ugc3VyZT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZyBpcyBpcnJldmVyc2libGUsIGRvIHlvdSB3YW50IHRvIGNvbnRpbnVlP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkJyb2FkY2FzdCBlcnJvciwgdHJ5IGFnYWluIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTdWNjZXNzXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJSZWJsb2dnZWQgcG9zdCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiTG9naW4gZmFpbGVkISBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGxvZ2dlZCBpbiB3aXRoIG1hc3RlciBwYXNzd29yZCBvciBwcm92aWRlZCBQb3N0aW5nIHByaXZhdGUga2V5IG9uIExvZ2luIGlmIHlvdSBoYXZlIGNob29zZWQgQWR2YW5jZWQgbW9kZS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJMb2dpbiBmYWlsZWQhIFBsZWFzZSBtYWtlIHN1cmUgeW91IGhhdmUgbG9nZ2VkIGluIHdpdGggbWFzdGVyIHBhc3N3b3JkIG9yIHByb3ZpZGVkIEFjdGl2ZSBwcml2YXRlIGtleSBvbiBMb2dpbiBpZiB5b3UgaGF2ZSBjaG9zZW4gQWR2YW5jZWQgbW9kZS5cIixcblx0XCJXQVJOSU5HXCI6IFwiV2FybmluZ1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RpbmcgZm9yIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdGVkIGZvciB3aXRuZXNzXCIsXG5cdFwiQUdPXCI6IFwiYWdvXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJmcm9tIG5vd1wiLFxuXHRcIlNFQ1NcIjogXCJzZWNzXCIsXG5cdFwiQV9NSU5cIjogXCJhIG1pblwiLFxuXHRcIk1JTlNcIjogXCJtaW5zXCIsXG5cdFwiQU5fSE9VUlwiOiBcImFuIGhyXCIsXG5cdFwiSE9VUlNcIjogXCJocnNcIixcblx0XCJBX0RBWVwiOiBcImEgZGF5XCIsXG5cdFwiREFZU1wiOiBcImRheXNcIixcblx0XCJBX01PTlRIXCI6IFwiYSBtb250aFwiLFxuXHRcIk1PTlRIU1wiOiBcIm1vbnRoc1wiLFxuXHRcIkFfWUVBUlwiOiBcImEgeWVhclwiLFxuXHRcIllFQVJTXCI6IFwieWVhcnNcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbiByZWFkXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIkRvd252b3RlIG9yIEZsYWdcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJDYXB0dXJlIFBpY3R1cmVcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlNlbGVjdCBQaWN0dXJlXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJTZXQgQ3VzdG9tIFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5zZXJ0IFBpY3R1cmVcIixcblx0XCJFUlJPUlwiOiBcIkVycm9yXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiVXBsb2FkIEVycm9yXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbWVyYSBDYW5jZWxsZWRcIixcblx0XCJTRVRfVVJMXCI6IFwiU2V0IFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJEaXJlY3Qgd2ViIGxpbmsgZm9yIHRoZSBwaWN0dXJlXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21tZW50IGlzIHN1Ym1pdHRlZCFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkRlbGV0aW5nIGNvbW1lbnRzIGFyZSBpcnJldmVyc2libGUuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJEZWxldGVkIGNvbW1lbnRcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlVwbG9hZGluZyBQaWN0dXJlXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlVwbG9hZCBDb21wbGV0ZWRcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiVXBsb2FkIEZhaWxlZFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIlRoZSBwYXNzd29yZCBvciBhY2NvdW50IG5hbWUgd2FzIGluY29ycmVjdFwiLFxuXHRcIklORk9cIjogXCJJbmZvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBsYWNlIGEgUVIgY29kZSBpbnNpZGUgdGhlIHNjYW4gYXJlYVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIk1ha2Ugc3VyZSB5b3UgaGF2ZSBlbm91Z2ggYmFsYW5jZSBmb3IgdHJhbnNhY3Rpb24hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlVzZXIgeW91IGFyZSB0cnlpbmcgdG8gdHJhbnNmZXIgZnVuZCwgZG9lc24ndCBleGlzdCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHRyYW5zZmVyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZpcm1hdGlvblwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNhY3Rpb24gaXMgYnJvYWRjYXN0ZWRcIixcblx0XCJGRUVEXCI6IFwiRmVlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRpbmdcIixcblx0XCJIT1RcIjogXCJIb3RcIixcblx0XCJORVdcIjogXCJOZXdcIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vdGVkXCIsXG5cdFwiVk9URVNcIjogXCJWb3Rlc1wiLFxuXHRcIlBBWU9VVFwiOiBcIlBheW91dFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwiQ29tbWVudHNcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5kaW5nIGZvciAzMCBkYXlzXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiU29ydCBQb3N0cyBCeTpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJQYXlvdXQgQ3ljbGVcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW50aWFsIFBheW91dFwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiUGFzdCBQYXlvdXRcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiQXV0aG9yIFBheW91dFwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkN1cmF0aW9uIFBheW91dFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUG9zdCBpcyBzdWJtaXR0ZWQhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlBvc3QgZm9yIGxhdGVyIHN1Ym1pc3Npb24hXCIsXG5cdFwiU0FWRURcIjogXCJTYXZlZFwiLFxuXHRcIkNMRUFSRURcIjogXCJDbGVhcmVkXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkZsYWdnaW5nIGEgcG9zdCBjYW4gcmVtb3ZlIHJld2FyZHMgYW5kIG1ha2UgdGhpcyBtYXRlcmlhbCBsZXNzIHZpc2libGUuPGJyPjxicj5UaGUgZmxhZyBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGZvbGxvd2luZzogPHVsPjxsaT5GcmF1ZCBvciBQbGFnaWFyaXNtPC9saT48bGk+SGF0ZSBTcGVlY2ggb3IgSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5JbnRlbnRpb25hbCBtaXNjYXRlZ29yaXplZCBjb250ZW50IG9yIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiUmVxdWVzdCBsaW1pdCByZWFjaGVkLiBDaGVjayBvdXQgb3RoZXIgdHJlbmQvdGFncyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0IGlzIHJlbW92ZWQgZnJvbSBib29rbWFya3MhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3QgaXMgYWRkZWQgdG8gYm9va21hcmtzIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVzZXRcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmeSBQcm9maWxlIFBpY3R1cmVcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmeSBDb3ZlciBQaWN0dXJlXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiUGxlYXNlIHByb3ZpZGUgQWN0aXZlIHByaXZhdGUga2V5IGlmIHlvdSBoYXZlIGNob3NlbiBBZHZhbmNlZCBsb2dpbiBtb2RlIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIlRoaXMgd2lsbCByZXNldCB1c2VyIHByb2ZpbGUgcGljdHVyZVwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIlRoaXMgd2lsbCByZXNldCB1c2VyIGNvdmVyIHBpY3R1cmVcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIlNlcnZlciB1cGRhdGUgcmVxdWlyZXMgUmVzdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiU2V0dGluZ3MgYXJlIHVwZGF0ZWQhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiTGFuZ3VhZ2VzXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJIZXJlIHlvdSBjYW4gY2hhbmdlIGxhbmd1YWdlIG9mIHRoZSBhcHAuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIlRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHVzZXIgdG8gYmUgbG9nZ2VkIGluIHdpdGggbWFpbiBwYXNzd29yZCwgYWN0aXZlL3Bvc3Rpbmcga2V5LiBQbGVhc2UgbG9naW4gYW5kIHRyeSBhZ2Fpbi5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyeVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlRyYW5zbGF0aW9uIGNvbnRyaWJ1dG9yc1wiLFxuXHRcIlNIQVJFXCI6IFwiU2hhcmVcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1hcmtldCBQbGFjZVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiRXhjaGFuZ2VcIixcblx0XCJEUkFGVFNcIjogXCJEcmFmdHNcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQb3N0IGlzIHJlbW92ZWQgZnJvbSBkcmFmdHMhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlBvc3QgaXMgYWRkZWQgdG8gZHJhZnRzIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJTd2lwZSBsZWZ0IHRvIHNlZSBvcHRpb25zXCIsXG5cdFwiTUFOQUdFXCI6IFwiTWFuYWdlXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltYWdlIGlzIHJlbW92ZWRcIixcblx0XCJDT1BZXCI6IFwiQ29weVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiWW91IGhhdmUgbm90IHVwbG9hZGVkIGFueSBpbWFnZSwgeWV0IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiUHVsbCBkb3duIHRvIHJlZnJlc2hcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiRXh0ZXJuYWwgQXBwc1wiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnaW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2dlc3RcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkNvbWluZyBzb29uXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJIZXJlIHlvdSBjYW4gY2hhbmdlIGJsb2NrY2hhaW4gb3IgZGVmYXVsdCBwbGF0Zm9ybS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIkN1cnJlbmN5XCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkhlcmUgeW91IGNhbiBjaGFuZ2UgeW91ciBkZWZhdWx0IGN1cnJlbmN5LiBZb3Ugd2lsbCBzZWUgcG9zdC9jb21tZW50IHJld2FyZCB2YWx1ZSBpbiB0aGlzIGN1cnJlbmN5LlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkZlYXR1cmUgbGlzdDwvYj48YnI+LSBBY2Nlc3MgdW5pcXVlIGFydGljbGVzIGluIGFueSBzdWJqZWN0IHlvdSBhcmUgaW50ZXJlc3RlZCByZWFkaW5nLjxicj4tIEVuZ2FnZSB3aXRoIGF1dGhvcnMgYnkgY29tbWVudGluZywgZGlzY3Vzc2luZyB0b3BpY3MuPGJyPi0gVm90aW5nIGZvciBwb3N0cyB0byByZXdhcmQgYXV0aG9yIGFzIHdlbGwgYXMgZWFybiBjdXJhdGlvbiByZXdhcmQuPGJyPi0gUHVibGlzaCB5b3VyIGFydGljbGVzLCBibG9nIHBvc3RzIGFuZCBob3N0IHRoZW0gZm9yIGZyZWUgYW5kIGVhcm4gcmV3YXJkcyBieSBlbmdhZ2luZyBhbmQgZ2FpbiBmb2xsb3dlcnMuPGJyPi0gV3JpdGUgYXJ0aWNsZXMgb24gZ28sIHNhdmUgbXVsdGlwbGUgZHJhZnRzIG9mIHRoZSBwb3N0IGZvciBsYXRlciBwdWJsaWNhdGlvbi48YnI+LSBCb29rbWFyayBmYXZvcml0ZSBhcnRpY2xlcyB0byByZWFkIGxhdGVyLjxicj4tIEV4Y2hhbmdlIG9yIGNhc2ggb3V0IHlvdXIgZWFybmluZ3MuPGJyPi0gU2VuZCB5b3VyIGZ1bmRzIHRvIGFueSBhdXRob3JzIG9yIHVzZXJzLCBmcmllbmRzLCBmb2xsb3dlcnMsIGV0Yy48YnI+LSBGb2xsb3cgaW50ZXJlc3RpbmcgYXV0aG9ycywgYmxvZ2dlcnMuPGJyPi0gU2VhcmNoIHlvdXIgZm9sbG93ZXJzIGFuZCBhdXRob3JzIHlvdSBhcmUgZm9sbG93aW5nLjxicj4tIEdldCBub3RpZmljYXRpb25zIHRvIHN0YXkgaW4gdG91Y2ggd2l0aCB5b3VyIGZvbGxvd2VycyBhbmQgZGlzY3Vzc2lvbnMgeW91IGFyZSBpbnZvbHZlZCBpbi48YnI+LSBTZWFyY2ggZm9yIGludGVyZXN0aW5nIHRhZ3MvY2F0ZWdvcmllcyBvZiBhcnRpY2xlcywgYXV0aG9ycy48YnI+LSBQZXJzb25hbGl6ZSB5b3VyIHByb2ZpbGUuPGJyPi0gTWFueSBtb3JlIGZlYXR1cmVzIHRvIGNvbWUuPGJyPjxicj48Yj5TZWN1cml0eTwvYj48YnI+MS4gQXBwIG5ldmVyIGFjY2VzcyBvciBob2xkIG9udG8gdXNlciBmdW5kcy48YnI+Mi4gQXBwIG9mZmVyIGEgY2xpZW50LXNpZGUgc2VjdXJpdHkgbW9kZWwsIHdpdGggcHJpdmF0ZSBrZXlzIGhvc3RlZCBsb2NhbGx5IGFuZCBuZXZlciBzZW50IHRvIGFueSBzZXJ2ZXJzLCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvIGJhY2tpbmcgdXAgeW91ciBwYXNzd29yZHMuPGJyPjMuIEFwcCBvZmZlcnMgc2ltcGxlLCBhdHRyYWN0aXZlIHVzZXIgaW50ZXJmYWNlcyBhbmQgZXhwZXJpZW5jZXM8YnI+NC4gQXBwIG9mZmVycyBleHRyYSBsYXllciBvZiBzZWN1cml0eSB3aXRoIHBpbi1jb2RlPGJyPjxicj5lU3RlZW0gc3VwcG9ydHMgU3RlZW0gYW5kIEdvbG9zIHBsYXRmb3Jtcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkZvdW5kZXIgYW5kIExlYWQgZGV2ZWxvcGVyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBZGQgYWNjb3VudFwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgYWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJSYXRpZmljYXRpb24gZGVhZGxpbmVcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyBleHBpcmF0aW9uXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkVzY3JvdyBmZWVcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgdGVybXNcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTmlnaHQgbW9kZVwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiRGF5IG1vZGVcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJWaWV3IHRoZSBmdWxsIGNvbnRleHRcIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiVXNlciBOb3QgRm91bmRcIixcblx0XCJBUFBST1ZFXCI6IFwiQXBwcm92ZVwiLFxuXHRcIkRJU1BVVEVcIjogXCJEaXNwdXRlXCIsXG5cdFwiUkVMRUFTRVwiOiBcIlJlbGVhc2VcIixcblx0XCJGUk9NXCI6IFwiRnJvbVwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJTdWJtaXRcIixcblx0XCJSRUNFSVZFUlwiOiBcIlJlY2VpdmVyXCIsXG5cdFwiTE9DQVRJT05cIjogXCJMb2NhdGlvblwiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJzaXRlXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiRGlzcGxheSBuYW1lXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkhvZ2FyXCIsXG5cdFwiTE9HSU5cIjogXCJJbmljaWFyIFNlc2nDs25cIixcblx0XCJMT0dPVVRcIjogXCJDZXJyYXIgU2VzacOzblwiLFxuXHRcIlBST0ZJTEVcIjogXCJQZXJmaWxcIixcblx0XCJGT0xMT1dcIjogXCJTZWd1aXJcIixcblx0XCJCT09LTUFSS1NcIjogXCJNYXJjYWRvcmVzXCIsXG5cdFwiVFJBTlNGRVJcIjogXCJUcmFuc2ZlcmlyXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWVyY2Fkb1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwiQWp1c3Rlc1wiLFxuXHRcIkFCT1VUXCI6IFwiQWNlcmNhIGRlXCIsXG5cdFwiQUJPVVRfMVwiOiBcImRvbmRlIHRvZG8gZWwgbXVuZG8gcHVlZGUgb2J0ZW5lciBnYW5hbmNpYXMgcG9yIHN1IGNvbnRlbmlkb1wiLFxuXHRcIkFCT1VUXzJcIjogXCJwcm92aXN0byBwb3IgbGEgcGxhdGFmb3JtYSB7e3BsYXRmb3JtbmFtZX19LiBBcHAgY3JlYWRhIHBvclwiLFxuXHRcIkFCT1VUXzNcIjogXCJlcyB1biBwcm95ZWN0byBkZSBtw7N2aWwgaW1wdWxzYWRvIHBvciBsYSBjb211bmlkYWQsIGRlIGPDs2RpZ28gYWJpZXJ0by4gT2ZyZWNlIGFjY2VzbyBhbCBjb250ZW5pZG8gcGFyYSBzdSBsZWN0dXJhLCBjb21lbnRhcmlvcywgdm90b3MsIHB1YmxpY2FjaW9uZXMsIHRyYW5zZmVyZW5jaWEgZGUgZ2FuYW5jaWFzLCBldGM7IGNhcmFjdGVyw61zdGljYXMgb2ZyZWNpZGFzIHBvciBsYSBjYWRlbmEgZGUgYmxvcXVlcyB7e3BsYXRmb3JtbmFtZX19IHkge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBMYSBBcHAgbnVuY2EgYWNjZWRlIG8gcmV0aWVuZSBmb25kb3MgZGUgbG9zIHVzdWFyaW9zLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBMYSBBcHAgb2ZyZWNlIHVuIG1vZGVsbyBkZSBzZWd1cmlkYWQgZGVsIGNsaWVudGUgY29uIGNvbnRyYXNlw7FhcyBwcml2YWRhcyBhbG1hY2VuYWRhcyBsb2NhbG1lbnRlIHkgcXVlIG5vIHNvbiBudW5jYSBlbnZpYWRhcyBhIG5pbmfDum4gc2Vydmlkb3IuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIExhIEFwcCBvZnJlY2UgdW5hIGV4cGVyaWVuY2lhIHkgdW5hIGludGVyZmF6IHNpbXBsZSB5IGF0cmFjdGljYS5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gTGEgQXBwIG51bmNhIHBpZGUgcXVlIGxvcyB1c3VhcmlvcyBpbnRyb2R1emNhbiBuaW5ndW5hIGluZm9ybWFjacOzbiBwZXJzb25hbC5cIixcblx0XCJBQk9VVF84XCI6IFwiVm90YSBhIGdvb2Qta2FybWEgY29tbyB0ZXN0aWdvXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhY3RvL1N1Z2VyZW5jaWFzXCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNw6FzIGluZm9ybWFjacOzblwiLFxuXHRcIlJFTU9WRVwiOiBcIkVsaW1pbmFyXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJWaXN0YSBkZSBNZXJjYWRvXCIsXG5cdFwiUFJJQ0VcIjogXCJQcmVjaW9cIixcblx0XCJBTU9VTlRcIjogXCJDYW50aWRhZFwiLFxuXHRcIlRPVEFMXCI6IFwiVG90YWxcIixcblx0XCJOT09SREVSU1wiOiBcIlNpbiDDs3JkZW5lcyBhYmllcnRhcyBwYXJhXCIsXG5cdFwiREFURVwiOiBcIkZlY2hhXCIsXG5cdFwiQlVZXCI6IFwiQ29tcHJhclwiLFxuXHRcIlNFTExcIjogXCJWZW5kZXJcIixcblx0XCJPUEVOXCI6IFwiQWJyaXJcIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaWFsXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJEZXZvbHZlciBTZWd1aW1pZW50b1wiLFxuXHRcIkZPTExPV0VEXCI6IFwiU2VndWlkb1wiLFxuXHRcIlVORk9MTE9XXCI6IFwiRGVqYXIgZGUgU2VndWlyXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiU2lndWllbmRvXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiU2VndWlkb3Jlc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJCdXNjYXIgc2VndWlkb3Jlc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJCdXNjYXIgc2VndWlkb3NcIixcblx0XCJCWVwiOiBcInBvclwiLFxuXHRcIklOXCI6IFwiZW5cIixcblx0XCJNRU5VXCI6IFwiTWVuw7pcIixcblx0XCJCT09LTUFSS1wiOiBcIk1hcmNhZG9yXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVibG9ndWVhclwiLFxuXHRcIlVQVk9URVwiOiBcIlZvdG8gUG9zaXRpdm9cIixcblx0XCJET1dOVk9URVwiOiBcIlZvdG8gTmVnYXRpdm9cIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiRGVzaGFjZXIgVm90byBOZWdhdGl2b1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiRGVzaGFjZXIgVm90byBQb3NpdGl2b1wiLFxuXHRcIlJFUExZXCI6IFwiUmVzcG9uZGVyXCIsXG5cdFwiRURJVFwiOiBcIkVkaXRhclwiLFxuXHRcIlBPU1RfMVwiOiBcIkRlc2xpemEgYSBsYSBpenF1aWVyZGEgZW4gbG9zIGNvbWVudGFyaW9zIHBhcmEgdmVyIGxhcyBvcGNpb25lc1wiLFxuXHRcIlBPU1RfMlwiOiBcIlB1bHNhIGVuIGxvcyBjb21lbnRhcmlvcyBwYXJhIHZlciBsb3Mgc3ViY29tZW50YXJpb3NcIixcblx0XCJPUFRJT05TXCI6IFwiT3BjaW9uZXNcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZXN0ZWVtZWQgcG9yXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiTmFkYSBwb3IgYXF1w60gYcO6bi4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU2FsZG9zXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgZmljaGFzIGNvbWVyY2lhYmxlcyBxdWUgcHVlZGVuIHNlciB0cmFuc2ZlcmlkYXMgZW4gY3VhbHF1aWVyIG1vbWVudG8uIHt7cGxhdGZvcm1uYW1lfX0gcHVlZGVuIHNlciBjb252ZXJ0aWRhcyBhIHt7cGxhdGZvcm1wb3dlcn19IGVuIHVuIHByb2Nlc28gbGxhbWFkbyBwb3dlciB1cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgZmljaGFzIGRlIGluZmx1ZW5jaWEgcXVlIGNvbnNpZ3VlbiBtw6FzIHBvZGVyIHBvciBtYW50ZW5lcmxhcyBhIGxhcmdvIHBsYXpvIHkgdm90YXIgZW4gbG9zIHBvc3RzLiBDdWFudGFzIG3DoXMgdGVuZ2FzIG3DoXMgaW5mbHVlbmNpYSB0ZW5kcsOhcyBlbiBsYXMgcmVjb21wZW5zYXMgcXVlIGxlIGRhcyBhbCByZXN0byBkZSB1c3VhcmlvcyB5IG3DoXMgcmVjb21wZW5zYXMgb2J0ZW5kcsOhcyBwb3IgdHVzIHZvdG9zLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlZhbG9yIGRlIGxhcyBmaWNoYXMge3twbGF0Zm9ybXN1bml0fX0gZGUge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJWYWxvciBFc3RpbWFkb1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIkVsIHZhbG9yIGVzdGltYWRvIHNlIGJhc2EgZW4gdW4gdmFsb3IgcHJvbWVkaW8gZGUgNyBkw61hcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJIaXN0b3JpYWwgZGUgVHJhbnNhY2Npb25lc1wiLFxuXHRcIlBPU1RJTkdcIjogXCJQdWJsaWNhY2nDs25cIixcblx0XCJQUk9GSUxFXzVcIjogXCJMYSBjbGF2ZSBkZSBwdWJsaWNhY2nDs24gZXMgdXRpbGl6YWRhIHBhcmEgcHVibGljYXIgeSB2b3Rhci4gVGllbmUgcXVlIHNlciBkaWZlcmVudGUgYSBsYSBjbGF2ZSBhY3RpdmEgeSBhIGxhIGNsYXZlIGRlIHByb3BpZXRhcmlvLlwiLFxuXHRcIk9XTkVSXCI6IFwiUHJvcGlldGFyaW9cIixcblx0XCJQUk9GSUxFXzZcIjogXCJMYSBjbGF2ZSBkZSBwcm9waWV0YXJpbyBlcyBsYSBjbGF2ZSBtYWVzdHJhIGRlIGxhIGN1ZW50YSB5IHNlIHJlcXVpZXJlIHBhcmEgY2FtYmlhciBsYXMgb3RyYXMgY2xhdmVzLiBMYSBjbGF2ZSBvIGNvbnRyYXNlw7FhIHByaXZhZGEgZGUgbGEgY2xhdmUgZGUgcHJvcGlldGFyaW8gZGViZXLDrWEgc2VyIG1hbnRlbmlkYSBcXFwib2ZmbGluZVxcXCIgdGFudG8gY29tbyBzZWEgcG9zaWJsZS5cIixcblx0XCJBQ1RJVkVcIjogXCJBY3RpdmFcIixcblx0XCJQUk9GSUxFXzdcIjogXCJMYSBjbGF2ZSBhY3RpdmEgc2UgdXRpbGl6YSBwYXJhIGhhY2VyIHRyYW5zZmVyZW5jaWFzIHkgaGFjZXIgcGVkaWRvcyBlbiBlbCBtZXJjYWRvIGludGVybm8uXCIsXG5cdFwiTUVNT1wiOiBcIk1lbW9yw6FuZHVtXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiTGEgY2xhdmUgZGUgbWVtb3LDoW5kdW1zIHNlIHV0aWxpemEgcGFyYSBjcmVhciB5IGxlZXIgbWVtb3LDoW5kdW1zLlwiLFxuXHRcIkJMT0dcIjogXCJFc2NyaWJlXCIsXG5cdFwiUE9TVFNcIjogXCJQdWJsaWNhY2lvbmVzXCIsXG5cdFwiUkVQTElFU1wiOiBcIlJlc3B1ZXN0YXNcIixcblx0XCJXQUxMRVRcIjogXCJNb25lZGVyb1wiLFxuXHRcIlRBR1wiOiBcIkV0aXF1ZXRhXCIsXG5cdFwiVVNFUlwiOiBcIlVzdWFyaW9cIixcblx0XCJDTE9TRVwiOiBcIkNlcnJhclwiLFxuXHRcIlRPXCI6IFwiQVwiLFxuXHRcIkFTU0VUXCI6IFwiUG9zZXNpw7NuIGRlIENhcGl0YWxcIixcblx0XCJTRU5EXCI6IFwiRW52aWFyXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTZWd1cmlkYWRcIixcblx0XCJBVkFJTEFCTEVcIjogXCJEaXNwb25pYmxlXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJNZW1vcsOhbmR1bSBQw7pibGljb1wiLFxuXHRcIlRPX0RFU0NcIjogXCJVc3VhcmlvIGVqLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJDw7NkaWdvIFBpblwiLFxuXHRcIlBJTl9URVhUXCI6IFwiRWwgY8OzZGlnbyBQSU4gdGUgYXl1ZGEgYSBkYXIgc2VndXJpZGFkIGEgbGEgYXBwIHkgYSB0dXMgZGF0b3MuXFxuPGJyLz48YnIvPjxiPk5vdGE6PC9iPiBVbmEgdmV6IGFjdGl2YWRvLCB0aWVuZXMgdW4gbcOheGltbyBkZSA0IGludGVudG9zIHBhcmEgZGVzYmxvcXVlYXJsbzsgc2kgdGUgb2x2aWRhcyBkZSB0dSBwaW4gbyBmYWxsYXMsIGxhIGFwcCBlbGltaW5hcsOhIGxvcyByZWdpc3Ryb3MgZW4gbG9zIGRhdG9zIGRlIHVzdWFyaW8uIFB1ZWRlcyB2b2x2ZXIgYSBpbmljaWFyIHNlc2nDs24geSBjb250aW51YXIgdXNhbmRvIGxhIGFwcC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2FjaW9uZXNcIixcblx0XCJWT1RFX1RFWFRcIjogXCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIHZvdGUgdHUgY29udGVuaWRvISA8YnIvPiA8Yj5Ob3RhOjwvYj4gTGFzIG5vdGlmaWNhY2lvbmVzIGluY2x1eWVuIHRhbWJpw6luIGVsIHBlc28gZGUgbGEgdm90YWNpw7NuIGVuIGVsIG1lbnNhamUgZGUgYWxlcnRhLiAoeWEgc2VhIHBvciB2b3RhY2nDs24gcG9zaXRpdmEsIHZvdGFjacOzbiBuZWdhdGl2YSwgZGVzaGFjZXIgdm90YWNpw7NuKS5cIixcblx0XCJWT1RFXCI6IFwiVm90YXJcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIGNvbWVudGUgZW4gdHVzIHB1YmxpY2FjaW9uZXMgbyBjb21lbnRhcmlvcyE8YnIvPiA8Yj5Ob3RlOjwvYj4gTGFzIG5vdGlmaWNhY2lvbmVzIGluY2x1eWVuIGN1YW5kbyBhbGd1aWVuIDxiPmVkaXRhPC9iPiBzdXMgY29tZW50YXJpb3MgdGFtYmnDqW4uXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkNvbWVudGFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIHRlIHNpZ2EgbyB0ZSBkZWplIGRlIHNlZ3VpciFcIixcblx0XCJNRU5USU9OU1wiOiBcIk1lbmNpb25lc1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJSZWNpYmlyw6FzIHVuYSBub3RpZmljYWNpw7NuIGN1YW5kbyBhbGd1aWVuIHRlIG1lbmNpb25lIGVuIHN1IHB1YmxpY2FjacOzbi9jb21lbnRhcmlvIVwiLFxuXHRcIlJFU1RFRU1cIjogXCJSZWJsb2d1ZWFyXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiBoYWdhIHJlYmxvZyBhIHR1IHB1YmxpY2FjacOzbiFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYWNpb25lc1wiLFxuXHRcIlZPVElOR1wiOiBcIlZvdG9cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIkVsIHBlc28gbyBwb3JjZW50YWplIGRlbCB2b3RvIGFmZWN0YSBhbCBwb2RlciBkZSB2b3RhY2nDs24gZW4gbGEgYXBwLCBkZSB0YWwgbWFuZXJhIHF1ZSBwdWVkZXMgcmVndWxhciB0dSByZWNvbXBlbnNhIGRlIHZvdGFjacOzbi4gPGJyLz48YnIvPjxiPk5vdGE6PC9iPiBFc3RvIGNhbWJpYXLDoSB0YW1iacOpbiBlbCBwZXNvL3BvcmNlbnRhamUgZGVsIHZvdG8gYSBsYSBob3JhIGRlIGhhY2VyIHVuIHZvdG8gbmVnYXRpdm9cIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2aWRvclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVjb21lbmRhZG9cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJHdWFyZGFyIENhbWJpb3NcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZm8gZGUgdm90YW50ZXNcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJCaWVudmVuaWRvIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJSZWfDrXN0cmF0ZSBjb24gdHUgbm9tYnJlIGRlIHVzdWFyaW8geSBjb250cmFzZcOxYSBwYXJhIGNvbnRpbnVhci5cIixcblx0XCJMT0dJTl8yXCI6IFwiTGEgY2xhdmUgZGUgcHVibGljYWNpw7NuIHNlIHVzYSBwYXJhIHB1YmxpY2FyLCBjb21lbnRhciwgdm90YXIsIHNlZ3Vpci5cIixcblx0XCJMT0dJTl8zXCI6IFwiTGEgY2xhdmUgYWN0aXZhIHNlIHVzYSBwYXJhIGxhcyB0cmFuc2ZlcmVuY2lhcyB5IGxhIGFjdHVhbGl6YWNpw7NuIGRlIGxhIGZvdG8gZGUgcGVyZmlsLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJMYXMgY3JlZGVuY2lhbGVzIGRlbCB1c3VhcmlvIHNlIGd1YXJkYW4gbG9jYWxtZW50ZSBlbiBlbCBkaXNwb3NpdGl2by4gQWwgY2VycmFyIGxhIHNlc2nDs24gbGFzIGNyZWRlbmNpYWxlcyBzb24gZWxpbWluYWRhcyFcIixcblx0XCJET05UX0hBVkVcIjogXCJObyB0aWVuZXMgdW5hIGN1ZW50YT9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlJlZ8Otc3RyYXRlIGFob3JhXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQ2FuY2VsYXJcIixcblx0XCJBRFZBTkNFRFwiOiBcIkF2YW56YWRvXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkNsYXZlIGFjdGl2YSBwcml2YWRhXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJDbGF2ZSBkZSBwdWJsaWNhY2nDs24gcHJpdmFkYVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiQ29udHJhc2XDsWEgbWFlc3RyYS9wcmluY2lwYWxcIixcblx0XCJVU0VSTkFNRVwiOiBcIk5vbWJyZSBkZSBVc3VhcmlvXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiVmlzdGEgZGUgY2FzaWxsYXNcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJWaXN0YSBjb21wYWN0YVwiLFxuXHRcIlNFQVJDSFwiOiBcIkJ1c2NhclwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiUHVibGljYXIgdW4gYXJ0w61jdWxvXCIsXG5cdFwiUkVQTFlUT1wiOiBcIlJlc3BvbmRlciBhXCIsXG5cdFwiUE9TVFwiOiBcIlB1YmxpY2FyXCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZXZpc3VhbGl6YWNpw7NuXCIsXG5cdFwiREVGQVVMVFwiOiBcIlBvciBkZWZlY3RvIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJQb3RlbmNpYWNpw7NuIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlJlY2hhemFyIFBhZ29cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIkdVQVJEQVIgUEFSQSBNw4FTIFRBUkRFXCIsXG5cdFwiQ0xFQVJcIjogXCJCT1JSQVJcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJQdWJsaWNhciBjb250ZW5pZG9cIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJDb21lbnRhciBjb250ZW5pZG9cIixcblx0XCJUSVRMRVwiOiBcIlTDrXR1bG9cIixcblx0XCJUQUdTXCI6IFwiRXRpcXVldGFzXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTk8gQ09JTkNJREVcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZpcm1hciBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJTkNPUlJFQ1RPXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiUG9zdCBpbmljaWFsXCIsXG5cdFwiU0VUX1BJTlwiOiBcIkVzdGFibGVjZXIgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiSW50cm9kdWNpciBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJFc3TDoXMgc2VndXJvP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVibG9nZWFyIGVzIGlycmV2ZXJzaWJsZSDCv2Rlc2VhcyBjb250aW51YXI/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiRXJyb3IgZGUgdHJhbnNtaXNpw7NuLCBpbnTDqW50YWxvIGRlIG51ZXZvIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJDb25zZWd1aWRvXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJQdWJsaWNhY2nDs24gUmVibG9ndWVhZGFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiSW5pY2lvIGRlIHNlc2nDs24gZmFsbGlkbyEgUG9yIGZhdm9yIGFzZWfDunJhdGUgZGUgcXVlIGhhcyBpbmljaWFkbyBzZXNpw7NuIGNvbiB0dSBjb250cmFzZcOxYSBtYWVzdHJhIG8gY29uIGxhIGNsYXZlIGRlIFB1YmxpY2FjacOzbiBwcml2YWRhIHByb3BvcmNpb25hZGEgZW4gZWwgYXBhcnRhZG8gSW5pY2lhciBTZXNpw7NuIHNpIGVsZWdpc3RlIGVsIE1vZG8gQXZhbnphZG8uXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiSW5pY2lvIGRlIHNlc2nDs24gZmFsbGlkbyEgUG9yIGZhdm9yIGFzZWfDunJhdGUgZGUgcXVlIGhhcyBpbmljaWFkbyBzZXNpw7NuIGNvbiB0dSBjb250cmFzZcOxYSBtYWVzdHJhIG8gY29uIGxhIGNsYXZlIEFjdGl2YSBwcml2YWRhIGVuIGVsIGFwYXJ0YWRvIEluaWNpYXIgU2VzacOzbiBzaSBlbGVnaXN0ZSBlbCBNb2RvIEF2YW56YWRvLlwiLFxuXHRcIldBUk5JTkdcIjogXCJBZHZlcnRlbmNpYVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RhciBhIHRlc3RpZ29cIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdGFkbyBhIHRlc3RpZ29cIixcblx0XCJBR09cIjogXCJoYWNlXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJkZXNkZSBhaG9yYVwiLFxuXHRcIlNFQ1NcIjogXCJzZWd1bmRvc1wiLFxuXHRcIkFfTUlOXCI6IFwidW4gbWludXRvXCIsXG5cdFwiTUlOU1wiOiBcIm1pbnV0b3NcIixcblx0XCJBTl9IT1VSXCI6IFwidW5hIGhvcmFcIixcblx0XCJIT1VSU1wiOiBcImhvcmFzXCIsXG5cdFwiQV9EQVlcIjogXCJ1biBkw61hXCIsXG5cdFwiREFZU1wiOiBcImTDrWFzXCIsXG5cdFwiQV9NT05USFwiOiBcInVuIG1lc1wiLFxuXHRcIk1PTlRIU1wiOiBcIm1lc2VzXCIsXG5cdFwiQV9ZRUFSXCI6IFwidW4gYcOxb1wiLFxuXHRcIllFQVJTXCI6IFwiYcOxb3NcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbnV0b3MgZGUgbGVjdHVyYVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJWb3RhciBOZWdhdGl2YW1lbnRlIG8gTWFyY2FyIENvbW8gSW5hcHJvcGlhZG9cIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJUb21hciBmb3RvXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJTZWxlY2Npb25hciBJbWFnZW5cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIkVzdGFibGVjZXIgVVJMIHBlcnNvbmFsaXphZGFcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluc2VydGFyIEltYWdlblwiLFxuXHRcIkVSUk9SXCI6IFwiRXJyb3JcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJFcnJvciBhbCBDYXJnYXJcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiQ8OhbWFyYSBDYW5jZWxhZGFcIixcblx0XCJTRVRfVVJMXCI6IFwiRXN0YWJsZWNlciBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRW5sYWNlIHdlYiBkaXJlY3RvIGEgbGEgaW1hZ2VuXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJFbCBjb21lbnRhcmlvIHNlIGhhIGVudHJlZ2FkbyFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkVsaW1pbmFyIGNvbWVudGFyaW9zIGVzIGlycmV2ZXJzaWJsZS4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIkVsaW1pbmFyIGNvbWVudGFyaW9cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlN1YmllbmRvIEltYWdlblwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJTdWJpZGEgQ29tcGxldGFkYVwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJMYSBzdWJpZGEgaGEgZmFsbGFkb1wiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkxhIGNvbnRyYXNlw7FhIG8gZWwgbm9tYnJlIGRlIGN1ZW50YSBzb24gaW5jb3JyZWN0b3NcIixcblx0XCJJTkZPXCI6IFwiSW5mb3JtYWNpw7NuXCIsXG5cdFwiUVJfVEVYVFwiOiBcIkNvbG9jYSBlbCBjw7NkaWdvIFFSIGRlbnRybyBkZSBsYSB6b25hIGRlIGVzY2FuZW9cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJBc2Vnw7pyYXRlIGRlIHF1ZSB0aWVuZXMgc3VmaWNpZW50ZSBzYWxkbyBwYXJhIGxhIHRyYW5zYWNjacOzbiFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiRWwgdXN1YXJpbyBhbCBxdWUgZXN0w6FzIGludGVudGFuZG8gdHJhbnNmZXJpciBmb25kb3Mgbm8gZXhpc3RlIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJFc3TDoXMgc2VndXJvIGRlIHF1ZSBxdWllcmVzIGhhY2VyIGxhIHRyYW5zZmVyZW5jaWE/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiQ29uZmlybWFjacOzblwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNhY2Npw7NuIHRyYW5zbWl0aWRhXCIsXG5cdFwiRkVFRFwiOiBcIkluaWNpb1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVGVuZGVuY2lhc1wiLFxuXHRcIkhPVFwiOiBcIkNhbGllbnRlXCIsXG5cdFwiTkVXXCI6IFwiTnVldm9cIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vY2lvbmFkb1wiLFxuXHRcIlZPVEVTXCI6IFwiVm90b3NcIixcblx0XCJQQVlPVVRcIjogXCJQYWdvXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJDb21lbnRhcmlvc1wiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiU2llbmRvIFRlbmRlbmNpYSBkdXJhbnRlIDMwIGTDrWFzXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiT3JkZW5hciBQdWJsaWNhY2lvbmVzIFBvclwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkNpY2xvIGRlIFBhZ29cIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUGFnbyBQb3RlbmNpYWxcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlBhZ28gUGFzYWRvXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlBhZ28gZGUgQXV0b3JcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJQYWdvIGRlIEN1cmFjacOzblwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiTGEgcHVibGljYWNpw7NuIGZ1ZSBlbnZpYWRhIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQdWJsaWNhY2nDs24gcGFyYSBwb3N0ZXJpb3IgcHJlc2VudGFjacOzbiFcIixcblx0XCJTQVZFRFwiOiBcIkd1YXJkYWRvXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkJvcnJhZG9cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiTWFyY2FyIGNvbW8gaW5hcHJvcGlhZGEgdW5hIHB1YmxpY2FjacOzbiBwdWVkZSBlbGltaW5hciBsYXMgcmVjb21wZW5zYXMgeSBoYWNlciBxdWUgZWwgbWF0ZXJpYWwgbWFyY2FkbyBzZWEgbWVub3MgdmlzaWJsZS48YnI+PGJyPiBNYXJjYXIgY29tbyBpbmFwcm9waWFkbyBkZWJlIHV0aWxpemFyc2UgZW4gbG9zIHNpZ3VpZW50ZXMgY2Fzb3M6IDx1bD48bGk+RnJhdWRlIG8gUGxhZ2lvPC9saT48bGk+RGlzY3Vyc29zIGRlIE9kaW8gbyBBY3RpdHVkZXMgZGUgUHJvdm9jYWNpw7NuIHkgTW9sZXN0aWEgQ29uc3RhbnRlczwvbGk+PGxpPkNvbnRlbmlkbyBjYXRlZ3JpemFkbyBtYWwgaW50ZW5jaW9uYWRhbWVudGUgbyBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkzDrW1pdGUgZGUgc29saWNpdHVkIGFsY2FuemFkby4gUmV2aXNhIG90cmFzIGV0aXF1ZXRhcy90ZW5kZW5jaWFzIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIlB1YmxpY2FjacOzbiBlbGltaW5hZGEgZGUgbG9zIG1hcmNhZG9yZXMhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlB1YmxpY2FjacOzbiBhw7FhZGlkYSBhIG1hcmNhZG9yZXMhXCIsXG5cdFwiUkVTRVRcIjogXCJSZWluaWNpYXJcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmaWNhciBGb3RvIGRlIFBlcmZpbFwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiTW9kaWZpY2FyIEZvdG8gZGUgUG9ydGFkYVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlBvciBmYXZvciBwcm9wb3JjaW9uYSBsYSBjbGF2ZSBBY3RpdmEgcHJpdmFkYSBzaSBoYXMgZWxlZ2lkbyBlbCBtb2RvIGRlIEluaWNpbyBkZSBTZXNpw7NuIEF2YW56YWRvIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIkVzdG8gcmVpbmljaWFyw6EgbGEgZm90byBkZSBwZXJmaWwgZGVsIHVzdWFyaW9cIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJFc3RvIHJlaW5pY2lhcsOhIGxhIGZvdG8gZGUgcG9ydGFkYSBkZWwgdXN1YXJpb1wiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiTGEgYWN0dWFsaXphY2nDs24gZGVsIHNlcnZpZG9yIHJlcXVpZXJlIHVuIHJlaW5pY2lvIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJBanVzdGVzIGFjdHVhbGl6YWRvcyFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJJZGlvbWFzXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJBcXXDrSBwdWVkZXMgY2FtYmlhciBlbCBpZGlvbWEgZGUgbGEgYXBwXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIkVzdGEgb3BlcmFjacOzbiByZXF1aWVyZSBxdWUgZWwgdXN1YXJpbyBpbmljaWUgc2VzacOzbiBjb24gbGEgY29udHJhc2XDsWEgbWFlc3RyYS9wcmluY2lwYWwsIGNsYXZlIGFjdGl2YS9wdWJsaWNhci4gUG9yIGZhdm9yIGluaWNpYSBzZXNpw7NuIHkgdnVlbHZlIGEgaW50ZW50YXJsby5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXLDrWFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJDb2xhYm9yYWRvcmVzIGRlIHRyYWR1Y2Npb25lc1wiLFxuXHRcIlNIQVJFXCI6IFwiQ29tcGFydGlyXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNZXJjYWRvXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJDYW1iaW9cIixcblx0XCJEUkFGVFNcIjogXCJCb3JyYWRvcmVzXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiwqFMYSBwdWJsaWNhY2nDs24gc2UgaGEgZWxpbWluYWRvIGRlIGJvcnJhZG9yZXMhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIsKhTGEgcHVibGljYWNpw7NuIHNlIGhhIGHDsWFkaWRvIGEgYm9ycmFkb3JlcyFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiRGVzbGljZSBoYWNpYSBsYSBpenF1aWVyZGEgcGFyYSB2ZXIgbGFzIG9wY2lvbmVzXCIsXG5cdFwiTUFOQUdFXCI6IFwiR2VzdGlvbmFyXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkxhIGZvdG8gc2UgaGEgZWxpbWluYWRvXCIsXG5cdFwiQ09QWVwiOiBcIkNvcGlhclwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiwqFBw7puIG5vIGhhcyBzdWJpZG8gbmluZ3VuYSBmb3RvIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiVGlyZSBoYWNpYSBhYmFqbyBwYXJhIGFjdHVhbGl6YXJcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBwcyBleHRlcm5hc1wiLFxuXHRcIlBMVUdJTlNcIjogXCJFeHRlbnNpb25lc1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTdWdlcmlyXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJNdXkgcHJvbnRvXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJBcXXDrSBwdWVkZXMgY2FtYmlhciBsYSBibG9ja2NoYWluIG8gbGEgcGxhdGFmb3JtYSBwb3IgZGVmZWN0by5cIixcblx0XCJDVVJSRU5DWVwiOiBcIkRpdmlzYVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJBcXXDrSBwdWVkZSBjYW1iaWFyIHN1IG1vbmVkYSBwb3IgZGVmZWN0by4gVmVyw6EgZWwgdmFsb3IgZGUgcmVjb21wZW5zYSBwb3N0L2NvbWVudGFyaW8gZW4gZXN0YSBtb25lZGEuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+TGlzdGEgZGUgQ2FyYWN0ZXLDrXN0aWNhczwvYj48YnI+IEFjY2VkZSBhIGFydMOtY3Vsb3Mgw7puaWNvcyBkZSBjdWFscXVpZXIgdGVtYSBlbiBsb3MgcXVlIGVzdMOpcyBpbnRlcmVzYWRvIDxicj4gQ29tcGFydGUgY29uIGxvcyBhdXRvcmVzIGNvbWVudGFuZG8sIGRpc2N1dGllbmRvIHRlbWFzLjxicj4gVm90YXIgbG9zIGFydMOtY3Vsb3MgcmVjb21wZW5zYSBhbCBhdXRvciB0YW50byBjb21vIGdhbmEgcmVjb21wZW5zYXMgcG9yIGN1cmFjacOzbiBkZSBjb250ZW5pZG9zLiA8YnI+IFB1YmxpY2EgdHVzIGFydMOtY3Vsb3MsIG5vdGFzIGRlIGJsb2csIGhvc3BlZGEgZ3JhdHVpdGFtZW50ZSB5IGdhbmEgcmVjb21wZW5zYXMgYWwgYXRyYWVyIHkgZ2FuYXIgc2VndWlkb3Jlcy48YnI+IEVzY3JpYmUgYXJ0w61jdWxvcyBlbiB2aXZvLCBhc8OtIGNvbW8gdGFtYmnDqW4gZ3VhcmRhciBtw7psdGlwbGVzIGJvcnJhZG9yZXMgZGVsIGFydGljdWxvIHBhcmEgZnV0dXJhIHB1YmxpY2FjacOzbi48YnI+IE1hcmNhIHR1cyBhcnTDrWN1bG9zIGZhdm9yaXRvcyBwYXJhIGxlZXJsb3MgbWFzIHRhcmRlLjxicj4gSW50ZXJjYW1iaWEgbyBzYWNhIGRpbmVybyBkZSB0dXMgZ2FuYW5jaWFzPGJyPiBFbnZpYSBmb25kb3MgYSBjdWFscXVpZXIgYXV0b3IgbyB1c3VhcmlvLCBhbWlnb3MsIHNlZ3VpZG9yZXMsIGV0Yy48YnI+IFNpZ3VlIGF1dG9yZXMgaW50ZXJlc2FudGVzLCBibG9nZ2Vycy48YnI+IEJ1c2NhIHR1cyBzZWd1aWRvcmVzIHkgYXV0b3JlcyBxdWUgc2lndWVzLjxicj4gUmVjaWJlIG5vdGlmaWNhY2lvbmVzIHBhcmEgbWFudGVuZXJ0ZSBlbiBjb250YWN0byBjb24gdHVzIHNlZ3VpZG9yZXMgeSBkaXNjdXNpb25lcyBlbiBsYXMgcXVlIGVzdGVzIGludm9sdWNyYWRvLiA8YnI+IEJ1c2NhIGNhdGVnb3LDrWFzL2V0aXF1ZXRhcyBkZSBhcnTDrWN1bG9zIHkgYXV0b3Jlcy48YnI+UGVyc29uYWxpemEgdHUgcGVyZmlsLjxicj4gTXVjaGFzIG1hcyBmdW5jaW9uYWxpZGFkZXMgcG9yIHZlbmlyLjxicj48YnI+PGI+U2VndXJpZGFkPC9iPjxicj4xLiBMYSBhcGxpY2FjacOzbiBudW5jYSBhY2NlZGVyw6EgbyBtYW50ZW5kcsOhIGZvbmRvcyBkZSB1c3Vhcmlvcy4gPGJyPjIuIExhIGFwbGljYWNpw7NuIG9mcmVjZSB1biBtb2RlbG8gZGUgc2VndXJpZGFkIGxhZG8tY2xpZW50ZSwgY29uIGNsYXZlcyBwcml2YWRhcyBob3NwZWRhZGFzIGxvY2FsbWVudGUgeSBudW5jYSBlbnZpYWRhcyBhIG5pbmfDum4gc2Vydmlkb3IsIHVzdGVkIGVzIHJlc3BvbnNhYmxlIGRlIHJlc3BhbGRhciBzdXMgY29udHJhc2XDsWFzLjxicj4zLiBMYSBhcGxpY2FjacOzbiBvZnJlY2UgdW5hIGV4cGVyaWVuY2lhIGRlbCB1c3VhcmlvIHNpbXBsZSB5IGF0cmFjdGl2YSwgYSB0cmF2w6lzIGRlIHN1IGludGVyZmF6LiA8YnI+NC4gTGEgYXBsaWNhY2nDs24gb2ZyZWNlIHVuYSBjYXBhIGV4dHJhIGRlIHNlZ3VyaWRhZCBjb24gdW4gY8OzZGlnby1waW48YnI+PGJyPlNvcG9ydGUgZGUgZVN0ZWVtIHNvcG9ydGEgU3RlZW0geSBQbGF0YWZvcm1hcyBHb2xvcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkZ1bmRhZG9yIHkgZGVzYXJyb2xsYWRvciBQcmluY2lwYWxcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIkHDsWFkaXIgY3VlbnRhXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0YWZvcm1hXCIsXG5cdFwiRVNDUk9XXCI6IFwiRGVww7NzaXRvIGRlIGdhcmFudMOtYVwiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkFnZW50ZSBFc2Nyb3dcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJGZWNoYSBsw61taXRlIGRlIHJhdGlmaWNhY2nDs25cIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIlZlbmNpbWllbnRvIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJUYXJpZmEgZGUgRXNjcm93XCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiVMOpcm1pbm9zIGRlIEVzY3Jvd1wiLFxuXHRcIk5JR0hUX01PREVcIjogXCJNb2RvIE5vY2hlXCIsXG5cdFwiREFZX01PREVcIjogXCJNb2RvIETDrWFcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJWZXIgZWwgdGV4dG8gY29tcGxldG9cIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiVXN1YXJpbyBObyBFbmNvbnRyYWRvXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkFwcm9iYWRhXCIsXG5cdFwiRElTUFVURVwiOiBcIkNvbmZsaWN0b1wiLFxuXHRcIlJFTEVBU0VcIjogXCJMaWJlcmFyXCIsXG5cdFwiRlJPTVwiOiBcIkRlc2RlXCIsXG5cdFwiSURcIjogXCJJRFwiLFxuXHRcIlNVQk1JVFwiOiBcIkVudmlhclwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiUmVjaWJpclwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9jYWxpemFjacOzblwiLFxuXHRcIldFQlNJVEVcIjogXCJQw6FnaW5hIFdlYlwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIk1vc3RyYXIgbm9tYnJlXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcItiu2KfZhtmHXCIsXG5cdFwiTE9HSU5cIjogXCLZiNix2YjYr1wiLFxuXHRcIkxPR09VVFwiOiBcItiu2LHZiNisXCIsXG5cdFwiUFJPRklMRVwiOiBcItm+2LHZiNmB2KfbjNmEXCIsXG5cdFwiRk9MTE9XXCI6IFwi2K/Zhtio2KfZhCDaqdix2K/ZhlwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcItmG2LTYp9mG2qnigIzZh9inXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLYp9mG2KrZgtin2YRcIixcblx0XCJNQVJLRVRcIjogXCLYqNin2LLYp9ixXCIsXG5cdFwiU0VUVElOR1NcIjogXCLYqtmG2LjbjNmF2KfYqlwiLFxuXHRcIkFCT1VUXCI6IFwi2K/Ysdio2KfYsdmHXCIsXG5cdFwiQUJPVVRfMVwiOiBcItis2KfbjNuMINqp2Ycg2YfYsSDaqdiz24wg2YXbjNiq2YjYp9mG2K8g2KjYsdin24wg2YXYrdiq2YjYp9uMINiq2YjZhNuM2K/bjCDYrtmI2K8g2K/Ysdin2YXYryDaqdiz2Kgg2qnZhtivIVwiLFxuXHRcIkFCT1VUXzJcIjogXCLYqNinINin2LPYqtmB2KfYr9mHINin2LIg2LLbjNix2LPYp9iu2Kp7e9mG2KfZhSDYstuM2LHYs9in2K7Yqn19INiq2YjZhNuM2K8g2LTYr9mHINin2LPYqi4g2KfbjNmGINin2b7ZhNuM2qnbjNi02YYg2LPYp9iu2KrZhyDYtNiv2Ycg2KrZiNiz2LdcIixcblx0XCJBQk9VVF8zXCI6IFwi2KfbjNmGINuM2qkg2b7YsdmI2pjZhyDZhdmI2KjYp9uM2YTbjCDYp9iz2Kog2qnZhyDYqNmHINi12YjYsdiqINmF2KrZhiDYqNin2LIg2Ygg2KrYrdiqINin2K/Yp9ix2Ycg24zaqSDaqdmF24zYqtmHINmF2LHYr9mF24wg2YXbjCDYqNin2LTYry4g2KfbjNmGINio2LHZhtin2YXZhyDYp9mF2qnYp9mGINiv2LPYqtix2LPbjCDYqNmHINmF2K3YqtmI2Kcg2LHYpyDYqNix2KfbjCDYrtmI2KfZhtiv2YbYjCDYr9ix2Kwg2YbYuNix2KfYqtiMINix2KPbjCDYr9in2K/ZhtiMINiq2YjZhNuM2K8g2YXYrdiq2YjYp9iMINin2YbYqtmC2KfZhNiMINiv2LHYp9mF2K8g2LLYp9uM24wg2YjCoNi624zYsdmHINix2Kcg2YXbjCDYr9mH2K8uINmI24zamNqv24zigIzZh9in24wg2qnZhyDYqtmI2LPYtyDYqNmE2KfaqeKAjNqG24zZhiB7e9mG2KfZhSDZvtmE2KrZgdmI2LHZhX19INmIIHt72YbYp9mFINiz2KfbjNiqfX0g2KfYsdin2KbZhyDYtNiv2Ycg2KfYs9iqLlwiLFxuXHRcIkFCT1VUXzRcIjogXCLbsS4g2KfZvtmE24zaqduM2LTZhiDZh9ix2q/YsiDYqNmHINm+2YjZhOKAjNmH2KfbjCDaqdin2LHYqNixINiv2LPYqtix2LPbjCDZvtuM2K/YpyDZhtmF24zigIzaqdmG2K8g2Ygg2KfYrtiq24zYp9ix24wg2K/YsSDZhdmI2LHYryDYotmGINmG2K/Yp9ix2K8uXCIsXG5cdFwiQUJPVVRfNVwiOiBcItuyLiDYp9m+2YTbjNqp24zYtNmGINmF2K/ZhCDYp9mF2YbbjNiq24wg2LPZhdiqINmF2LTYqtix24wg2K/Yp9ix2K/YjCDYqNmHINi32YjYsduMINqp2Ycg2qnZhNuM2K/Zh9in24wg2K7YtdmI2LXbjCDYqNmHINi12YjYsdiqINmF2K3ZhNuMINiw2K7bjNix2Ycg2YXbjOKAjNi02YjZhtivINmIINmH2LHar9iyINio2Ycg2YfbjNqGINiz2LHZiNix24wg2YHYsdiz2KrYp9iv2Ycg2YbZhduM4oCM2LTZiNmG2K8uXCIsXG5cdFwiQUJPVVRfNlwiOiBcItuzLiDYp9m+2YTbjNqp24zYtNmGINix2KfYqNi3INmIINiq2KzYsdio2YfigIzbjCDaqdin2LHYqNix24wg2LPYp9iv2Ycg2Ygg2KzYsNin2KjbjCDYr9in2LHYry5cIixcblx0XCJBQk9VVF83XCI6IFwi27QuINiq2LHZhSDYp9mB2LLYp9ix2YfbjNqG2q/Yp9mHINmG24zYp9iyINio2Ycg2K/YsduM2KfZgdiqINin2LfZhNin2LnYp9iqINi02K7YtduMINqp2KfYsdio2LHYqtiv2KfYsdivLlwiLFxuXHRcIkFCT1VUXzhcIjogXCLYqNmHIGdvb2Qta2FybWEg2KjZhyDYudmG2YjYp9mGINi02KfZh9ivINix2KPbjCDYqNiv2YfbjNivXCIsXG5cdFwiQUJPVVRfOVwiOiBcItiq2YXYp9izL9io2KfYstiu2YjYsdivOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi2KfYt9mE2KfYudin2Kog2KjbjNi02KrYsTpcIixcblx0XCJSRU1PVkVcIjogXCLYrdiw2YFcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcItmI2LbYuduM2Kog2KjYp9iy2KfYsVwiLFxuXHRcIlBSSUNFXCI6IFwi2YLbjNmF2KpcIixcblx0XCJBTU9VTlRcIjogXCLZhdio2YTYulwiLFxuXHRcIlRPVEFMXCI6IFwi2KzZhdi5XCIsXG5cdFwiTk9PUkRFUlNcIjogXCLZh9uM2obar9mI2YbZhyDYs9mB2KfYsdi0INio2KfYstuMINio2LHYp9uMXCIsXG5cdFwiREFURVwiOiBcItiq2KfYsduM2K5cIixcblx0XCJCVVlcIjogXCLYrtix24zYr1wiLFxuXHRcIlNFTExcIjogXCLZgdix2YjYtFwiLFxuXHRcIk9QRU5cIjogXCLYqNin2LJcIixcblx0XCJISVNUT1JZXCI6IFwi2KrYp9ix24zYrtqG2YdcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcItiv2YbYqNin2YQg2qnYsdiv2YYg2YXYqtmC2KfYqNmEXCIsXG5cdFwiRk9MTE9XRURcIjogXCLYr9mG2KjYp9mEINi02K/Zh1wiLFxuXHRcIlVORk9MTE9XXCI6IFwi2LnYr9mFINiv2YbYqNin2YQg2qnYsdiv2YZcIixcblx0XCJGT0xMT1dJTkdcIjogXCLYr9mG2KjYp9mEINmF24zaqdmG24zYr1wiLFxuXHRcIkZPTExPV0VSU1wiOiBcItiv2YbYqNin2YQg2qnZhtmG2K/ar9in2YZcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwi2KzYs9iq2KzZiNuMINiv2YbYqNin2YQg2qnZhtmG2K/ar9in2YZcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwi2KzYs9iq2KzZiNuMINiv2YbYqNin2YQg2LTZiNmG2K/ar9in2YZcIixcblx0XCJCWVwiOiBcItiq2YjYs9i3XCIsXG5cdFwiSU5cIjogXCLYr9ixXCIsXG5cdFwiTUVOVVwiOiBcItmB2YfYsdiz2KpcIixcblx0XCJCT09LTUFSS1wiOiBcItmG2LTYp9mG2qlcIixcblx0XCJSRUJMT0dcIjogXCLYp9i02KrYsdin2qkg2YXYrNiv2K9cIixcblx0XCJVUFZPVEVcIjogXCLYsdij24wg2YXYq9io2KpcIixcblx0XCJET1dOVk9URVwiOiBcItix2KPbjCDZhdmG2YHbjFwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLYrdiw2YEg2LHYo9uMINmF2YbZgduMXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLYrdiw2YEg2LHYo9uMINmF2KvYqNiqXCIsXG5cdFwiUkVQTFlcIjogXCLZvtin2LPYrlwiLFxuXHRcIkVESVRcIjogXCLZiNuM2LHYp9uM2LRcIixcblx0XCJQT1NUXzFcIjogXCLYqNix2KfbjCDYr9uM2K/ZhiDar9iy24zZhtmH4oCM2YfYp9iMINix2YjbjCDZhti42LHYp9iqINio2Ycg2obZviDYqNqp2LTbjNivLlwiLFxuXHRcIlBPU1RfMlwiOiBcItio2LHYp9uMINiv24zYr9mGINmG2LjYsdin2Kog2YHYsdi524zYjCDYsdmI24wg2YbYuNix2KfYqiDaqdmE24zaqSDaqduM2YbYry5cIixcblx0XCJPUFRJT05TXCI6IFwi2q/YstuM2YbZh+KAjNmH2KdcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLYp9i02KrYsdin2qkg2YXYrNiv2K8g2KrZiNiz2LdcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLYp9uM2YbYrNinINmH2YbZiNiyINqG24zYstuMINmG24zYs9iqLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCLZhdin2YbYr9mH4oCM2YfYp1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt72YbYp9mFINm+2YTYqtmB2YjYsdmFfX3YjCDZhtmF2KfYr9mH2KfbjCDZgtin2KjZhCDYr9in2K/CoNmIwqDYs9iq2K8g2qnZhyDZhduM4oCM2KrZiNin2YYg2KLZhiDYsdinINiv2LEg2YfYsSDYstmF2KfZhiDYp9mG2KrZgtin2YQg2K/Yp9ivLiB7e9mG2KfZhSDZvtmE2KrZgdmI2LHZhX19INix2Kcg2YXbjOKAjNiq2YjYp9mGINin2LIg2LfYsduM2YIg2YHYsdii24zZhtiv24wg2KjZhyDZhtin2YUg2KjYp9mE2Kcg2KjYsdiv2YYg2YLYr9ix2Kog2KjZhyB7e9iq2YjYp9mGINiq2KfYq9uM2LEg2q/YsNin2LHZvtmE2KrZgdmI2LHZhX19INiq2KjYr9uM2YQg2qnYsdivLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt72KrZiNin2YYg2KrYp9ir24zYsSDar9iw2KfYsdm+2YTYqtmB2YjYsdmFfX3YjCDZhtmF2KfYr9mH2KfbjCDYqtij2KvbjNix2q/YsNin2LHbjCDaqdmHINmC2K/YsdiqINio24zYtNiq2LHbjCDYqNix2KfbjCDZhtqv2YfYr9in2LHbjCDYqNmE2YbYr9mF2K/YqiDZiCDYsdij24wg2K/Yp9iv2YYg2K/YsSDZvtiz2KrigIzZh9inINqp2LPYqCDZhduM4oCM2qnZhtmG2K8uINmH2LEg2obZhyDYp9uM2YYg2LHYpyDYqNuM2LTYqtixINmG2q/Zh9iv2KfYsduMINqp2YbbjNiv2Iwg2KjbjNi02KrYsSDZhduM4oCM2KrZiNin2YbbjNivINio2LEg2b7Yp9iv2KfYtOKAjNmH2KfbjCDYr9uM2q/Ysdin2YYg2KrYo9ir24zYsSDYr9in2LTYqtmHINio2KfYtNuM2K8g2Ygg2K/YsSDYp9iy2KfbjCDYsdij24wg2K/Yp9iv2YYg2K/ZgtuM2YLYjCDZvtin2K/Yp9i0INqp2LPYqCDZhtmF2KfbjNuM2K8uXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwi2YbZhdin2K/Zh9in24zbjCDYqNinINin2LHYsti0INit2K/ZiNivIHt7cGxhdGZvcm1zdW5pdH19INin2LIge3vZhtin2YUg2b7ZhNiq2YHZiNix2YV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLYp9ix2LLYtCDYqNix2KLZiNix2K8g2LTYr9mHXCIsXG5cdFwiUFJPRklMRV80XCI6IFwi2KfYsdiy2LQg2KjYsdii2YjYsdivINi02K/ZhyDZhdio2KrbjCDYqNixINin2LHYsti0INmF2KrZiNiz2Lcg27cg2LHZiNiy2YfigIzbjCB7e9mG2KfZhSDZvtmE2KrZgdmI2LHZhX19INin2LPYqi5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi2KrYp9ix24zYrtqG2YfigIzbjCDYqtix2KfaqdmG2LRcIixcblx0XCJQT1NUSU5HXCI6IFwi2KfYsdiz2KfZhCDZhdi32YTYqFwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcItqp2YTbjNivINin2LHYs9in2YQg2YXYt9mE2Kgg2KjYsdin24wg2KfYsdiz2KfZhCDaqdix2K/ZhiDZhdi32YTYqCDZiCDYsdij24wg2K/Yp9iv2YYg2KfYs9iq2YHYp9iv2Ycg2YXbjOKAjNi02YjYry4g2KfbjNmGINio2KfbjNivINio2Kcg2qnZhNuM2K/Zh9in24wg2YHYudin2YQg2Ygg2YXYp9mE2qkg2YXYqtmB2KfZiNiqINio2KfYtNivLlwiLFxuXHRcIk9XTkVSXCI6IFwi2YXYp9mE2qlcIixcblx0XCJQUk9GSUxFXzZcIjogXCLaqdmE24zYryDZhdin2YTaqSDaqdmE24zYryDYp9i12YTbjCDYrdiz2KfYqCDYp9iz2Kog2Ygg2KjYsdin24wg2KrYutuM24zYsSDYr9in2K/ZhiDaqdmE24zYr9mH2KfbjCDYr9uM2q/YsSDZhdmI2LHYryDZhtuM2KfYsiDYp9iz2KouINqp2YTbjNivINiu2LXZiNi124wg24zYpyDar9iw2LHZiNin2pjZhyDYqNix2KfbjCDaqdmE24zYryDZhdin2YTaqSDYqNin24zYryDYqtinINit2K8g2KfZhdqp2KfZhiDYotmB2YTYp9uM2YYg2Ybar9mH2K/Yp9ix24wg2LTZiNivLlwiLFxuXHRcIkFDVElWRVwiOiBcItmB2LnYp9mEXCIsXG5cdFwiUFJPRklMRV83XCI6IFwi2qnZhNuM2K8g2YHYudin2YQg2KjYsdin24wg2KfZhtiq2YLYp9mEINmIINiz2YHYp9ix2LQg2K/Yp9iv2YYg2K/YsSDYqNin2LLYp9ixINiv2KfYrtmE24wg2KfYs9iq2YHYp9iv2Ycg2YXbjOKAjNi02YjYry5cIixcblx0XCJNRU1PXCI6IFwi24zYp9iv2K/Yp9i02KpcIixcblx0XCJQUk9GSUxFXzhcIjogXCLaqdmE24zYryDbjNin2K/Yr9in2LTYqiDYqNix2KfbjCDYp9uM2KzYp9ivINmIINiu2YjYp9mG2K/ZhiDbjNin2K/Yr9in2LTYquKAjNmH2Kcg2KfYs9iq2YHYp9iv2Ycg2YXbjOKAjNi02YjYry5cIixcblx0XCJCTE9HXCI6IFwi2KjZhNin2q9cIixcblx0XCJQT1NUU1wiOiBcItm+2LPYquKAjNmH2KdcIixcblx0XCJSRVBMSUVTXCI6IFwi2b7Yp9iz2K7igIzZh9inXCIsXG5cdFwiV0FMTEVUXCI6IFwi2qnbjNmBINm+2YjZhFwiLFxuXHRcIlRBR1wiOiBcItio2LHahtiz2KhcIixcblx0XCJVU0VSXCI6IFwi2qnYp9ix2KjYsVwiLFxuXHRcIkNMT1NFXCI6IFwi2KjYs9iq2YZcIixcblx0XCJUT1wiOiBcItio2YdcIixcblx0XCJBU1NFVFwiOiBcItiv2KfYsdin24zbjFwiLFxuXHRcIlNFTkRcIjogXCLZgdix2LPYqtin2K/ZhlwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi2KfZhdmG24zYqlwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcItmF2YjYrNmI2K9cIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcItuM2KfYr9iv2KfYtNiqINi52YXZiNmF24xcIixcblx0XCJUT19ERVNDXCI6IFwi2qnYp9ix2KjYsSDZhdir2YTYp9mLIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcItm+24zZhuKAjNqp2K9cIixcblx0XCJQSU5fVEVYVFwiOiBcItm+24zZhuKAjNqp2K8g2KjZhyDYp9mF2YYg2qnYsdiv2YYg2KfZvtmE24zaqduM2LTZhiDZiCDYr9in2K/Zh+KAjNmH2KfbjCDYtNmF2Kcg2qnZhdqpINmF24zigIzaqdmG2K8uIDxici8+PGJyLz48Yj7YqtmI2KzZhzo8L2I+INm+2LMg2KfYsiDZgdi52KfZhOKAjNiz2KfYstuM2Iwg2LTZhdinINmB2YLYtyDbtCDYqNin2LEg2KjYsdin24wg2KjYp9iyINqp2LHYr9mGINmB2LHYtdiqINiv2KfYsduM2K/YmyDYp9qv2LEg2b7bjNmGINix2Kcg2YHYsdin2YXZiNi0INqp2YbbjNivINuM2Kcg2KfYtNiq2KjYp9mHINmI2KfYsdivINqp2YbbjNiv2Iwg2KfZvtmE24zaqduM2LTZhiDYr9in2K/Zh+KAjNmH2KfbjCDYq9io2Kog2LTYr9mH4oCM24wg2qnYp9ix2KjYsSDYsdinINit2LDZgSDYrtmI2KfZh9ivINqp2LHYry4g2YXbjOKAjNiq2YjYp9mG24zYryDYr9mI2KjYp9ix2Ycg2YjYp9ix2K8g2LTZiNuM2K8g2Ygg2KjZhyDYp9iz2KrZgdin2K/ZhyDYp9iyINin2b7ZhNuM2qnbjNi02YYg2KfYr9in2YXZhyDYr9mH24zYry5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi2KfYt9mE2KfYuSDYsdiz2KfZhtuM4oCM2YfYp1wiLFxuXHRcIlZPVEVfVEVYVFwiOiBcItmI2YLYqtuMINqp2Ycg2qnYs9uMINio2Ycg2YXYrdiq2YjYp9uMINi02YXYpyDYsdij24wg2YXbjOKAjNiv2YfYr9iMINio2Ycg2LTZhdinINin2LfZhNin2Lkg2LHYs9in2YbbjCDZhduMINqv2LHYr9ivISA8YnIvPiA8Yj7YqtmI2KzZhzo8L2I+INin2LfZhNin2Lkg2LHYs9in2YbbjOKAjNmH2Kcg2LTYp9mF2YQg2YjYstmGINix2KPbjCDZiCDZhtuM2LIg2b7bjNin2YUg2YfYtNiv2KfYsSDYp9iz2KouICjYtNin2YXZhCDYsdij24wg2YXYq9io2KrYjCDYsdij24wg2YXZhtmB24zYjCDYrdiw2YEg2LHYo9uMKS5cIixcblx0XCJWT1RFXCI6IFwi2LHYo9uMINiv2KfYr9mGXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi2YjZgtiq24wg2qnZhyDaqdiz24wg2K/YscKg2KjYp9ix2YfigIzbjCDZhdi32KfZhNioINin2LHYs9in2YTbjCDYtNmF2Kcg2YbYuNixINmF24zigIzYr9mH2K/YjCDYqNmHINi02YXYpyDYp9i32YTYp9i5INix2LPYp9mG24wg2YXbjNqv2LHYr9ivITxici8+IDxiPtiq2YjYrNmHOjwvYj7Yp9i32YTYp9i5INix2LPYp9mG24wg2LTYp9mF2YQg2LLZhdin2YbbjCDaqdmHINqp2LPbjCDZhti42LEg2K7ZiNivINix2KcgPGI+2YjbjNix2KfbjNi0PC9iPiDZhduM4oCM2qnZhtiv2Iwg2YbbjNiyINmH2LPYqi5cIixcblx0XCJDT01NRU5UXCI6IFwi2YbYuNixINiv2KfYr9mGXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLZiNmC2KrbjCDaqdmHINqp2LPbjCDYtNmF2Kcg2LHYpyDYr9mG2KjYp9mEINmF24zigIzaqdmG2K8g24zYpyDYr9mG2KjYp9mEINqp2LHYr9mGINix2Kcg2K3YsNmBINmF24zigIzaqdmG2K/YjNio2Ycg2LTZhdinINin2LfZhNin2Lkg2LHYs9in2YbbjCDZhduM2q/Ysdiv2K8h2YtcIixcblx0XCJNRU5USU9OU1wiOiBcItiw2qnYsSDZhtin2YVcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwi2YjZgtiq24wg2qnZhyDaqdiz24wg2YbYp9mFINi02YXYpyDYsdinINiv2LEg2b7Ys9iqL9mG2LjYsSDYrtmI2K8g2LDaqdixINmF24zigIzaqdmG2K/YjCDYqNmHINi02YXYpyDYp9i32YTYp9i5INix2LPYp9mG24wg2YXbjNqv2LHYr9ivIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLYp9i02KrYsdin2qkg2q/YsNin2LHbjCDZhdis2K/Yr1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcItmI2YLYqtuMINqp2Ycg2qnYs9uMINm+2LPYqiDYtNmF2Kcg2LHYpyDZhdis2K/YryDYqNmHINin2LTYqtix2KfaqSDar9iw2KfYsdiv2Iwg2KjZhyDYtNmF2Kcg2KfYt9mE2KfYuSDYsdiz2KfZhtuMINmF24zar9ix2K/YryFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcItm+24zaqdix2KjZhtiv24zigIzZh9inXCIsXG5cdFwiVk9USU5HXCI6IFwi2LHYo9uM4oCM2K/Zh9uMXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLZiNiy2YYg24zYpyDYr9ix2LXYryDYsdij24zigIzYr9mH24wg2KjYsSDZgtiv2LHYqiDYsdij24zigIzYr9mH24wg2K/YsSDZhtix2YUg2KfZgdiy2KfYsdiq2KPYq9uM2LEg2YXbjOKAjNqv2LDYp9ix2K/YjCDYqNmG2KfCoNio2LHCoNin24zZhtiMINmF24zigIzYqtmI2KfZhtuM2K8g2b7Yp9iv2KfYtCDYsdij24zigIzYr9mH24wg2K7ZiNivINix2Kcg2KrZhti424zZhSDaqdmG24zYry4gPGJyLz48YnIvPjxiPtiq2YjYrNmHOjwvYj4g2KfbjNmGINmI2LLZhi/Yr9ix2LXYryDYsdij24zigIzYr9mH24wg2LHYpyDYqNix2KfbjCDYsdij24wg2YXZhtmB24wg2YfZhSDYqti624zbjNixINiu2YjYp9mH2K8g2K/Yp9ivINmIINiv2LEg2KrZhdin2YUg2KzYp9mH2KfbjCDZhtix2YUg2KfZgdiy2KfYsdin2LnZhdin2YQg2K7ZiNin2YfYryDYtNivXCIsXG5cdFwiU0VSVkVSXCI6IFwi2LPYsdmI2LFcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcItiq2YjYtduM2Ycg2LTYr9mHXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwi2LDYrtuM2LHZhyDaqdix2K/ZhiDYqti624zbjNix2KfYqlwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwi2KfYt9mE2KfYudin2Kog2LHYo9uMINiv2YfZhtiv2q/Yp9mGXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwi2K7ZiNi0INii2YXYr9uM2K8hXCIsXG5cdFwiTE9HSU5fMVwiOiBcItis2YfYqiDYp9iv2KfZhdmHINio2Kcg2YbYp9mFINqp2KfYsdio2LHbjCDZiCDar9iw2LHZiNin2pjZh+KAjNuMINiu2YjYryDZiNin2LHYryDYtNmI24zYry5cIixcblx0XCJMT0dJTl8yXCI6IFwi2qnZhNuM2K8g2KfYsdiz2KfZhCDZhdi32YTYqCDYqNix2KfbjCDYp9ix2LPYp9mEINqp2LHYr9mGINmF2LfZhNio2Iwg2YbYuNixINiv2KfYr9mG2Iwg2LHYo9uMINiv2KfYr9mG2Iwg2Ygg2K/Zhtio2KfZhCDaqdix2K/ZhiDYp9iz2KrZgdin2K/ZhyDZhduM4oCM2LTZiNivLlwiLFxuXHRcIkxPR0lOXzNcIjogXCLaqdmE24zYryDZgdi52KfZhCDYqNix2KfbjCDYp9mG2KrZgtin2YQg2Ygg2KjZh+KAjCDYsdmI2LIg2LHYs9in2YbbjCDYqti12YjbjNixINm+2LHZiNmB2KfbjNmEINin2LPYqtmB2KfYr9mHINmF24zigIzYtNmI2K8uXCIsXG5cdFwiTE9HSU5fNFwiOiBcItmF2K/Yp9ix2qkg2qnYp9ix2KjYsSDYqNmHINi32YjYsSDZhdit2YTbjCDYsdmI24wg2K/Ys9iq2q/Yp9mHINmG2q/Zh9iv2KfYsduMINmF24zigIzYtNmI2K8uINiv2LEg2YfZhtqv2KfZhSDYrtix2YjYrNiMINmF2K/Yp9ix2qkg2K3YsNmBINmF24zigIzYtNmI2K8hXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi2K3Ys9in2Kgg2YbYr9in2LHbjNiv2J9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcItin2qnZhtmI2YYg2KvYqNiq4oCM2YbYp9mFINqp2YbbjNivXCIsXG5cdFwiQ0FOQ0VMXCI6IFwi2YTYutmIINqp2LHYr9mGXCIsXG5cdFwiQURWQU5DRURcIjogXCLYrdin2YTYqiDZvtuM2LTYsdmB2KrZh1wiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLaqdmE24zYryDYrti12YjYtduMINmB2LnYp9mEXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCLaqdmE24zYryDYrti12YjYtduMINin2LHYs9in2YQg2YXYt9mE2KhcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcItqv2LDYsdmI2KfamNmH4oCM24wg2KfYtdmE24xcIixcblx0XCJVU0VSTkFNRVwiOiBcItmG2KfZhSDaqdin2LHYqNix24xcIixcblx0XCJDQVJEX1ZJRVdcIjogXCLZhtmF2KfbjCDaqdin2LHYqlwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcItmG2YXYp9uMINmB2LTYsdiv2YdcIixcblx0XCJTRUFSQ0hcIjogXCLYrNiz2KrYrNmIXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCLYq9io2Kog24zaqSDYr9in2LPYqtin2YZcIixcblx0XCJSRVBMWVRPXCI6IFwi2b7Yp9iz2K4g2K/Yp9iv2YYg2KjZh1wiLFxuXHRcIlBPU1RcIjogXCLYp9ix2LPYp9mEINmF2LfZhNioXCIsXG5cdFwiUFJFVklFV1wiOiBcItm+24zYtOKAjNmG2YXYp9uM2LRcIixcblx0XCJERUZBVUxUXCI6IFwi2b7bjNi04oCM2YHYsdi2INu127DZqiAvINu127DZqlwiLFxuXHRcIlBPV0VSVVBcIjogXCLbsduw27DZqiDYqNin2YTYpyDYqNix2K/ZhiDZgtiv2LHYqlwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwi2KfZhdiq2YbYp9i5INin2LIg2b7Ysdiv2KfYrtiqXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCLYsNiu24zYsdmHINqp2LHYr9mGINio2LHYp9uMINio2LnYr1wiLFxuXHRcIkNMRUFSXCI6IFwi2b7Yp9qpINqp2LHYr9mGXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi2YXYrdiq2YjYp9uMINmF2LfZhNioXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi2YXYrdiq2YjYp9uMINmG2LjYsVwiLFxuXHRcIlRJVExFXCI6IFwi2LnZhtmI2KfZhlwiLFxuXHRcIlRBR1NcIjogXCLYqNix2obYs9io4oCM2YfYp1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIti52K/ZhSDYp9mG2LfYqNin2YJcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcItiq2KPbjNuM2K8g2b7bjNmGXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi2YbYp9iv2LHYs9iqXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi2KjYp9iyINqp2LHYr9mGINmF2LfZhNioXCIsXG5cdFwiU0VUX1BJTlwiOiBcItiq2LnbjNuM2YYg2b7bjNmGXCIsXG5cdFwiRU5URVJfUElOXCI6IFwi2YjYp9ix2K8g2qnYsdiv2YYg2b7bjNmGXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwi2YXYt9mF2KbZhtuM2K/Yn1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwi2KfYtNiq2LHYp9qpINqv2K/Yp9ix24wg2YXYrNiv2K8g2LrbjNix2YLYp9io2YQg2KjYsdqv2LTYqiDYp9iz2KrYjCDZhduM4oCM2K7ZiNin2YfbjNivINin2K/Yp9mF2Ycg2K/Zh9uM2K/Yn1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcItiu2LfYp9uMINm+2K7YtNiMINiv2YjYqNin2LHZhyDYqtmE2KfYtCDaqdmG24zYryFcIixcblx0XCJTVUNDRVNTXCI6IFwi2YXZiNmB2YLbjNiqXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLZhdi32YTYqCDYp9ix2LPYp9mEINmF2KzYr9ivINi02K8hXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcItmI2LHZiNivINio2Kcg2LTaqdiz2Kog2YXZiNin2KzZhyDYtNivISDZhNi32YHYp9mLINin2LfZhduM2YbYp9mGINit2KfYtdmEINqp2YbbjNivINqp2Ycg2KjYpyDar9iw2LHZiNin2pjZh+KAjNuMINin2LXZhNuMINmI2KfYsdivINi02K/Zh+KAjNin24zYryDbjNinINiv2LEg2LXZiNix2KrbjCDaqdmHINit2KfZhNiqINm+24zYtNix2YHYqtmHINix2Kcg2KfZhtiq2K7Yp9ioINqp2LHYr9mH4oCM2KfbjNiv2Iwg2qnZhNuM2K8g2K7YtdmI2LXbjCDYp9ix2LPYp9mEINmF2LfZhNioINix2Kcg2K/YsSDZiNix2YjYryDYp9ix2KfYptmHINqp2LHYr9mH4oCM2KfbjNivLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcItmI2LHZiNivINio2Kcg2LTaqdiz2Kog2YXZiNin2KzZhyDYtNivISDZhNi32YHYp9mLINin2LfZhduM2YbYp9mGINit2KfYtdmEINqp2YbbjNivINqp2Ycg2KjYpyDar9iw2LHZiNin2pjZh+KAjNuMINin2LXZhNuMINmI2KfYsdivINi02K/Zh+KAjNin24zYryDbjNinINiv2LEg2LXZiNix2KrbjCDaqdmHINit2KfZhNiqINm+24zYtNix2YHYqtmHINix2Kcg2KfZhtiq2K7Yp9ioINqp2LHYr9mH4oCM2KfbjNiv2Iwg2qnZhNuM2K8g2K7YtdmI2LXbjCDZgdi52KfZhCDYsdinINiv2LEg2YjYsdmI2K8g2KfYsdin2KbZhyDaqdix2K/Zh+KAjNin24zYry5cIixcblx0XCJXQVJOSU5HXCI6IFwi2YfYtNiv2KfYsVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLYsdij24wg2K/Yp9iv2YYg2KjYsdin24wg2LTYp9mH2K9cIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcItix2KPbjCDYr9in2K/ZhyDYtNiv2Ycg2KjYsdin24wg2LTYp9mH2K9cIixcblx0XCJBR09cIjogXCLZgtio2YRcIixcblx0XCJGUk9NX05PV1wiOiBcItin2LIg2K3Yp9mE2KdcIixcblx0XCJTRUNTXCI6IFwi2KvYp9mG24zZh1wiLFxuXHRcIkFfTUlOXCI6IFwi24zaqSDYr9mC24zZgtmHXCIsXG5cdFwiTUlOU1wiOiBcItiv2YLbjNmC2YdcIixcblx0XCJBTl9IT1VSXCI6IFwi24zaqSDYs9in2LnYqlwiLFxuXHRcIkhPVVJTXCI6IFwi2LPYp9i52KpcIixcblx0XCJBX0RBWVwiOiBcItuM2qkg2LHZiNiyXCIsXG5cdFwiREFZU1wiOiBcItix2YjYslwiLFxuXHRcIkFfTU9OVEhcIjogXCLbjNqpINmF2KfZh1wiLFxuXHRcIk1PTlRIU1wiOiBcItmF2KfZh1wiLFxuXHRcIkFfWUVBUlwiOiBcItuM2qkg2LPYp9mEXCIsXG5cdFwiWUVBUlNcIjogXCLYs9in2YRcIixcblx0XCJNSU5fUkVBRFwiOiBcItiv2YLbjNmC2Ycg2K7ZiNin2YbYr9mGXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcItix2KPbjCDZhdmG2YHbjCDbjNinINi52YTYp9mF2Kog2q/YsNin2LTYqtmGXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi2q/YsdmB2KrZhiDYudqp2LNcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcItin2YbYqtiu2KfYqCDYqti12YjbjNixXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLYqti524zbjNmGINmG2LTYp9mG24wg2KfbjNmG2KrYsdmG2KrbjCDYs9mB2KfYsdi024xcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcItiv2LHYrCDaqdix2K/ZhiDYqti12YjbjNixXCIsXG5cdFwiRVJST1JcIjogXCLYrti32KdcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLYrti32KfbjCDYotm+2YTZiNivXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcItiv2YjYsdio24zZhiDZhNi62Ygg2LTYr1wiLFxuXHRcIlNFVF9VUkxcIjogXCLYqti524zbjNmGINmG2LTYp9mG24wg2KfbjNmG2KrYsdmG2KrbjFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLZhNuM2YbaqSDZiNioINmF2LPYqtmC24zZhSDYqNix2KfbjCDYqti12YjbjNixXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCLZhti42LEg2KvYqNiqINi02K8hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCLYrdiw2YEg2qnYsdiv2YYg2YbYuNix2KfYqiDYqNix2q/YtNiq4oCM2YbYp9m+2LDbjNixINin2LPYqi4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcItmG2LjYsSDYrdiw2YEg2LTYr1wiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi2K/YsSDYrdin2YQg2KLZvtmE2YjYryDaqdix2K/ZhiDYqti12YjbjNixXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcItii2b7ZhNmI2K8g2qnYp9mF2YQg2LTYr1wiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLYotm+2YTZiNivINio2Kcg2LTaqdiz2Kog2YXZiNin2KzZhyDYtNivXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwi2q/YsNix2YjYp9qY2Ycg24zYpyDZhtin2YUg2K3Ys9in2Kgg2YbYp9iv2LHYs9iqINio2YjYr1wiLFxuXHRcIklORk9cIjogXCLYp9i32YTYp9i52KfYqlwiLFxuXHRcIlFSX1RFWFRcIjogXCLbjNqpINqp24zZiNii2LHaqdivINix2Kcg2K/YsSDYr9in2K7ZhCDZhtin2K3bjNmH4oCM24wg2KfYs9qp2YYg2YLYsdin2LEg2K/Zh9uM2K9cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCLYr9mC2Kog2qnZhtuM2K8g2qnZhyDYqNix2KfbjCDYqtix2KfaqdmG2LQg2YXYp9mG2K/Zh+KAjNuMINqp2KfZgduMINiv2KfYtNiq2Ycg2KjYp9i024zYryFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi2qnYp9ix2KjYsduMINqp2Ycg2YXbjOKAjNiu2YjYp9mH24zYryDYqNix2KfbjNi0INm+2YjZhCDYqNmB2LHYs9iq24zYr9iMINmI2KzZiNivINmG2K/Yp9ix2K8hXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcItmF2LfZhdim2YbbjNivINmF24zigIzYrtmI2KfZh9uM2K8g2KfZhtiq2YLYp9mEINix2Kcg2KfZhtis2KfZhSDYr9mH24zYr9ifXCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwi2KrYo9uM24zYr1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi2KrYsdin2qnZhti0INm+2K7YtCDYtNivXCIsXG5cdFwiRkVFRFwiOiBcItmB24zYr1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwi2b7Ysdi32LHZgdiv2KfYsVwiLFxuXHRcIkhPVFwiOiBcItiv2KfYulwiLFxuXHRcIk5FV1wiOiBcItis2K/bjNivXCIsXG5cdFwiUFJPTU9URURcIjogXCLYp9ix2KrZgtinINiv2KfYr9mHINi02K/Zh1wiLFxuXHRcIlZPVEVTXCI6IFwi2LHYo9uM4oCM2YfYp1wiLFxuXHRcIlBBWU9VVFwiOiBcItm+2LHYr9in2K7YqlwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi2YbYuNix2KfYqlwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwi2b7Ysdi32LHZgdiv2KfYsSDYr9ixINuz27Ag2LHZiNiyXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi2YXYsdiq2KjigIzYs9in2LLbjCDZhdi32KfZhNioINio2LHCoNit2LPYqDpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLahtix2K7Zh+KAjNuMINm+2LHYr9in2K7YqlwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCLZvtix2K/Yp9iu2Kog2KfYrdiq2YXYp9mE24xcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcItm+2LHYr9in2K7YqiDar9iw2LTYqtmHXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcItm+2LHYr9in2K7YqiDZhtmI24zYs9mG2K/ar9uMXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwi2b7Ysdiv2KfYrtiqINmI24zYsdin2LPYqtin2LHbjFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi2YXYt9mE2Kgg2KvYqNiqINi02K8hXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcItmF2LfZhNioINio2LHYp9uMINir2KjYqiDYr9ixINii24zZhtiv2YchXCIsXG5cdFwiU0FWRURcIjogXCLYsNiu24zYsdmHINi02K9cIixcblx0XCJDTEVBUkVEXCI6IFwi2b7Yp9qpINi02K9cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwi2q/YsNin2LTYqtmGINi52YTYp9mF2Kog2b7YsdqG2YUg2KjYsdin24wg24zaqSDZhdi32YTYqCDZhduM4oCM2KrZiNin2YbYryDZhdmI2KzYqCDYrdiw2YEg2b7Yp9iv2KfYtOKAjNmH2Kcg2LTYr9mHINmIINmF24zYstin2YYg2YbZhdin24zYtCDYotmGINmF2LfZhNioINix2Kcg2qnYp9mH2LQg2K/Zh9ivLjxicj48YnI+2b7YsdqG2YUg2q/YsNin2LTYqtmGINio2KfbjNivINio2LHYp9uMINmF2YjYp9ix2K8g2LLbjNixINin2LPYqtmB2KfYr9mHINi02YjYrzogPHVsPjxsaT7aqdmE2KfZh9io2LHYr9in2LHbjCDbjNinINiz2LHZgtiqINin2K/YqNuMPC9saT48bGk+2YbZgdix2KrigIzZvtix2KfaqdmG24wg24zYpyDZhdiy2KfYrdmF2Kog2KfbjNmG2KrYsdmG2KrbjDwvbGk+PGxpPtiv2LPYqtmH4oCM2KjZhtiv24wg2LrZhNi3INi52YXYr9uMINmF2K3YqtmI2Kcg24zYpyDZh9ix2LLZhtin2YXZhzwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCLYrdivINiq2YLYp9i22Kcg2b7YsSDYtNivLiDYqNmHINix2YjZhtiv2YfYpy/YqNix2obYs9io4oCM2YfYp9uMINiv24zar9ixINmF2LHYp9is2LnZhyDaqdmG24zYryFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLZhdi32YTYqCDYp9iyINmG2LTYp9mG2qnigIzZh9inINit2LDZgSDYtNivIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLZhdi32YTYqCDYqNmHINmG2LTYp9mG2qnigIzZh9inINin2LbYp9mB2Ycg2LTYryFcIixcblx0XCJSRVNFVFwiOiBcIti02LHZiNi5INmF2KzYr9ivXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLYqti624zbjNixINiq2LXZiNuM2LEg2b7YsdmI2YHYp9uM2YRcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItiq2LrbjNuM2LEg2KrYtdmI24zYsSDYstmF24zZhtmHXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi2YTYt9mB2KfZiyDYr9ixINi12YjYsdiq24wg2qnZhyDYrdin2YTYqiDZiNix2YjYryDZvtuM2LTYsdmB2KrZhyDYsdinINin2YbYqtiu2KfYqCDaqdix2K/Zh+KAjNin24zYr9iMINqp2YTbjNivINiu2LXZiNi124wg2YHYudin2YQg2LHYpyDYp9ix2KfYptmHINqp2YbbjNivIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcItin24zZhiDZhdmI2KzYqCDYqNin2LLZhti02KfZhtuMINiq2LXZiNuM2LEg2b7YsdmI2YHYp9uM2YQg2qnYp9ix2KjYsSDYrtmI2KfZh9ivINi02K9cIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCLYp9uM2YYg2YXZiNis2Kgg2KjYp9iy2YbYtNin2YbbjCDYqti12YjbjNixINiy2YXbjNmG2YfigIzbjCDaqdin2LHYqNixINiu2YjYp9mH2K8g2LTYr1wiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwi2KjZh+KAjNix2YjYstix2LPYp9mG24wg2LPYsdmI2LEg2YbbjNin2LLZhdmG2K8g2LTYsdmI2Lkg2YXYrNiv2K8g2KfYs9iqIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCLYqtmG2LjbjNmF2KfYqiDYqNmH4oCM2LHZiNiy2KLZiNix24wg2LTYryFcIixcblx0XCJMQU5HVUFHRVNcIjogXCLYstio2KfZhuKAjNmH2KdcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcItiv2LEg2KfbjNmG2KzYpyDZhduM4oCM2KrZiNin2YbbjNivINiy2KjYp9mGINmG2LHZhSDYp9mB2LLYp9ix2LHYpyDYqti624zbjNixINiv2YfbjNivLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLYqNix2KfbjCDYp9uM2YYg2LnZhdmE2Iwg2YTYp9iy2YUg2KfYs9iqINqp2Ycg2qnYp9ix2KjYsSDYqNinINqv2LDYsdmI2KfamNmH4oCM24wg2KfYtdmE24zYjCDaqdmE24zYryDZgdi52KfZhC/Yp9ix2LPYp9mEINmF2LfZhNioINmI2KfYsdivINi02K/ZhyDYqNin2LTYry4g2YTYt9mB2KfZiyDZiNin2LHYryDYtNmI24zYryDZiCDYr9mI2KjYp9ix2Ycg2KrZhNin2LQg2qnZhtuM2K8uXCIsXG5cdFwiR0FMTEVSWVwiOiBcItqv2KfZhNix24xcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLYqtix2KzZhdmHINqp2YbZhtiv2q/Yp9mGXCIsXG5cdFwiU0hBUkVcIjogXCLYp9i02KrYsdin2qkg2q/YsNin2LHbjFwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwi2KjYp9iy2KfYsVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwi2KrYqNin2K/ZhCDYp9ix2LJcIixcblx0XCJEUkFGVFNcIjogXCLZvtuM2LQg2YbZiNuM2LNcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLZhdi32YTYqCDYp9iyINmC2LPZhdiqINm+24zYtCDZhtmI24zYsyDZh9inINit2LDZgSDar9ix2K/bjNivIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCLZhdi32YTYqCDYqNmHINmC2LPZhdiqINm+24zYtCDZhtmI24zYsyDZh9inINin2LbYp9mB2Ycg2q/Ysdiv24zYryFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwi2KjYsdin24wg2YXYtNin2YfYr9mHINqv2LLbjNmG2Ycg2YfYpyDYqNmHINqG2b4g2Kjaqdi024zYr1wiLFxuXHRcIk1BTkFHRVwiOiBcItmF2K/bjNix24zYqlwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLYudqp2LMg2K3YsNmBINqv2LHYr9uM2K9cIixcblx0XCJDT1BZXCI6IFwi2qnZvtuMXCIsXG5cdFwiTk9fSU1BR0VcIjogXCLYtNmF2Kcg2YfZhtmI2LIg2Lnaqdiz24wg2KjYp9ix2q/YsNin2LHbjCDZhtqp2LHYr9uM2K8hXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLYrNmH2Kog2KjYp9ixINqv2LDYp9ix24wg2YXYrNiv2K8g2KjZhyDZvtin24zbjNmGINio2qnYtNuM2K9cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi2KfZvtmE24zaqduM2LTZhuKAjNmH2KfbjCDYqNuM2LHZiNmG24xcIixcblx0XCJQTFVHSU5TXCI6IFwi2b7ZhNin2q/bjNmG4oCM2YfYp1wiLFxuXHRcIlNVR0dFU1RcIjogXCLZvtuM2LTZhtmH2KfYr1wiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwi2KjZhyDYstmI2K/bjFwiLFxuXHRcIkNIQUlOXCI6IFwi2LLZhtis24zYsdmHXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcItiv2LEg2KfbjNmG2KzYpyDZhduM4oCM2KrZiNin2YbbjNivINio2YTYp9qp4oCM2obbjNmGINuM2Kcg2b7ZhNiq2YHYsdmFINm+24zYtOKAjNmB2LHYtiDYsdinINiq2LrbjNuM2LEg2K/Zh9uM2K8uXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLZiNin2K3YryDZvtmI2YRcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi2K/YsSDYp9uM2YbYrNinINi02YXYpyDZhduMINiq2YjYp9mG24zYryDYqtmG2LjbjNmF2KfYqiDZiNin2K3YryDZvtmI2YQg2K7ZiNivINix2Kcg2KrYutuM24zYsSDYr9mH24zYr9iM2KfYsdiy2LQg2b7Yp9iv2KfYtCDZvtiz2KrZh9inL9mG2LjYsdin2Kog2LTZhdinINio2Kcg2YjYp9it2K8g2b7ZiNmEINiq2YbYuNuM2YUg2LTYr9mHINmG2LTYp9mGINiv2KfYr9mHINmF24wg2LTZiNivLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPtmE24zYs9iqINmC2KfYqNmE24zYqiDZh9inPC9iPjxicj4tINiv2LPYqtix2LPbjCDYqNmHINmF2YLYp9mE2Ycg2YfYp9uMINiu2KfYtSDZiCDZhdmG2K3YtdixINio2Ycg2YHYsdivINiv2LEg2YfYsSDZhdmI2LHYr9uMINqp2Ycg2KjZhyDYotmGINi52YTYp9mC2Ycg2YXZhtivINmH2LPYqtuM2K8uPGJyPi0g2KfYsdiq2KjYp9i3INio2Kcg2YbZiNuM2LPZhtiv2q/Yp9mGINio2Ycg2YjYs9uM2YTZhyDZhti42LEg2K/Zh9uMINmIINio2K3YqyDYr9ixINmF2YjYsdivINmF2YjYttmI2Lkg2YXZiNix2K8g2YbYuNixINm+2LPYqi48YnI+LSDYsdin24wg2K/Zh9uMINio2Ycg2b7Ys9iqINmH2Kcg2KzZh9iqINin2YXYqtuM2KfYsiDYr9mH24wg2Ygg2KzYp9uM2LLZhyDYr9in2K/ZhiDYqNmHINmG2YjbjNiz2YbYr9qv2KfZhtiMINmIINmH2YXahtmG24zZhiDaqdiz2Kgg2K/Ysdin2YXYryDYqNix2KfbjCDYrtmI2K8uPGJyPi0g2YXZgtin2YTYp9iqINmIINm+2LPYqiDZh9in24wg2K7ZiNivINix2Kcg2KjZhyDYsdin24zar9in2YYg2KfYtNiq2LHYp9qpINio2q/YsNin2LHbjNiv2Iwg2Ygg2KjZhyDZiNiz24zZhNmHINin2YHYsdin2K/bjCDaqdmHINi02YXYpyDYsdinINiv2YbYqNin2YQg2YXbjCDaqdmG2YbYryDZiCDYqNmHINm+2LPYqiDZh9in24wg2LTZhdinINix2KfbjCDZhduMINiv2YfZhtivINiv2LHYp9mF2K8g2qnYs9ioINqp2YbbjNivLjxicj4tINmF2YLYp9mE2KfYqiDYrtmI2K8g2LHYpyDYr9ixINmH2LEg2qnYrNinINqp2Ycg2YfYs9iq24zYryDYqNmG2YjbjNiz24zYryDZiCDZvtuM2LQg2YbZiNuM2LMg2YfYp9uMINmF2K7YqtmE2YHbjCDYsdinINio2LHYp9uMINin2LTYqtix2KfaqSDar9iw2KfYsduMINiv2LEg2KLbjNmG2K/ZhyDYsNiu24zYsdmHINqp2YbbjNivLjxicj4tINmF2YLYp9mE2KfYqiDZhdmI2LHYryDYudmE2KfZgtmHINiu2YjYryDYsdinINio2LHYp9uMINiv2LPYqtix2LPbjCDYotiz2KfZhiDYr9ixINii24zZhtiv2Ycg2YbYtNin2YbZhyDar9iw2KfYsduMINqp2YbbjNivLjxicj4tINiv2LHYp9mF2K8g2K7ZiNivINix2Kcg2KjYpyDYqtio2K/bjNmEINio2Ycg2b7ZiNmEINmG2YLYryDZiCDbjNinINiv24zar9ixINin2LHYsiDZh9in24wg2K/bjNis24zYqtin2YQg2YbZhdin24zbjNivLjxicj4tINiv2LHYp9mF2K8g2K7ZiNivINix2Kcg2KjZhyDZhtmI24zYs9mG2K/ar9in2YbYjCDaqdin2LHYqNix2KfZhtiM2K/ZiNiz2KrYp9mGINmIINi624zYsdmHINin2LHYs9in2YQg2YbZhdin24zbjNivLjxicj4tINmG2YjbjNiz2YbYr9qv2KfZhiDZiCDYqNmE2KfaryDZhtmI24zYs9in2YYg2YXZiNix2K8g2LnZhNin2YLZhyDYrtmI2K8g2LHYpyDYr9mG2KjYp9mEINmG2YXYp9uM24zYry48YnI+LSDYr9ixINmE24zYs9iqINmG2YjbjNiz2YbYr9qv2KfZhiDZiCDYr9mG2KjYp9mEINqp2YbZhtiv2q/Yp9mGINiu2YjYryDYr9mG2KjYp9mEINin2LPZhSDZhdmI2LHYryDZhti42LEg2K7ZiNivINio2q/Ysdiv24zYry48YnI+LSDYrNmH2Kog2K/YsSDYp9ix2KrYqNin2Lcg2YXYp9mG2K/ZhiDYqNinINiv2YbYqNin2YQg2qnZhtmG2K/ar9in2YYg2K7ZiNivINmIINmH2YXahtmG24zZhiDZhdmC2KfZhNin2KrbjCDYr9ixINii2YbZh9inINmG2YLYtNuMINiv2KfYtNiq2Ycg2KfbjNivINm+24zYutin2YUg2K/YsduM2KfZgdiqINmG2YXYp9uM24zYry48YnI+LSDar9ix2YjZhyDZh9inINmIINiq2q8g2YfYp9uMINmF2YjYsdivINi52YTYp9mC2Ycg2K7ZiNivINix2Kcg2KjYsSDYp9iz2KfYsyDZhtin2YUg2YbZiNuM2LPZhtiv2q/Yp9mGINmIINmF2YjYttmI2Lkg2YXZgdin2YTYp9iqINm+2KjYr9inINmG2YXYp9uM24zYry48YnI+LSDZvtix2YjZgdin24zZhCDYrtmI2K8g2LHYpyDYtNiu2LXbjCDYs9in2LLbjCDZhtmF2KfbjNuM2K8uPGJyPi0g2YLYp9io2YTbjNiqINmH2KfbjCDYqNuM2LTYqtix24wg2K/YsSDYsdin2Ycg2KfYs9iqLjxicj48YnI+PGI+2KfZhdmG24zYqjwvYj48YnI+MS4g2YbYsdmFINin2YHYstin2LEg2YfYsdqv2LIg2KjZhyDYrdiz2KfYqCDYtNmF2Kcg2K/Ys9iq2LHYs9uMINmG2K7ZiNin2YfYryDYr9in2LTYqi48YnI+Mi4g2YbYsdmFINin2YHYstin2LEg24zaqSDYsdmI2LQg2KfZhdmG24zYqtuMINiz2YXYqiDaqdin2LHYqNixINix2Kcg2b7YqNin2K/ZhyDYs9in2LLbjCDZhduMINmG2YXYp9uM2K8g2qnZhyDaqdmE24zYryDZh9in24wg2K7YtdmI2LXbjCDYs9mF2Kog2qnYp9ix2KjYsSDZhtqv2YfYr9in2LHbjCDYtNiv2Ycg2Ygg2KjZhyDZh9uM2oYg2LPYsdmI2LHbjCDYp9ix2LPYp9mEINmG2YXbjCDar9ix2K/Yr9iMINmF2LPYptmI2YTbjNiqINm+2LTYqtuM2KjYp9mGINqv24zYsduMINin2LIg2qnZhNuM2K8g2YfYp9uMINi02K7YtduMINio2Ycg2LnZh9iv2Ycg2LTZhdin2LPYqi48YnI+My4g2YbYsdmFINin2YHYstin2LEg24zaqSDYsdin2KjYtyDaqdin2LHYqNix24wg2LPYp9iv2Ycg2Ygg2KrYrNix2KjZhyDYp9uMINiy24zYqNinINin2LHYp9im2Ycg2YXbjCDZhtmF2KfbjNivPGJyPjQuINmG2LHZhSDYp9mB2LLYp9ixINio2Ycg2YjYs9uM2YTZhyDYsdmF2LIg2b7bjNmGINuM2qkg2YTYp9uM2Ycg2KfZhdmG24zYqtuMINin2LbYp9mB2Ycg2KfYsdin2KbZhyDZhduMINmG2YXYp9uM2K8uPGJyPjxicj5lc3RlZW0g2KfYsiDZvtmE2KrZgdmI2LHZhSDZh9in24wgU3RlZW0g2YggR29sb3Mg2b7YtNiq24zYqNin2YbbjCDZhduMINmG2YXYp9uM2K8uPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLZhdmI2LPYsyDZiCDYqNix2YbYp9mF2Ycg2YbZiNuM2LMg2KfYsdi02K9cIixcblx0XCJBRERfQUNDT1VOVFwiOiBcItin2YHYstmI2K/ZhiDYrdiz2KfYqCDaqdin2LHYqNix24xcIixcblx0XCJQTEFURk9STVwiOiBcItm+2YTYqtmB2LHZhVwiLFxuXHRcIkVTQ1JPV1wiOiBcItmF2KjYp9iv2YTZhyDYqti22YXbjNmG24xcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCLZhdin2YXZiNixINmI2qnYp9mE2Kog2K/Yp9iv2Ycg2LTYr9mHXCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwi2YXZh9mE2Kog2KrYtdmI24zYqFwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwi2b7Yp9uM2KfZhiDYstmF2KfZhiDZiNqp2KfZhNiqXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcItmH2LLbjNmG2Ycg2Yjaqdin2YTYqlwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIti02LHYp9uM2Lcg2Yjaqdin2YTYqlwiLFxuXHRcIk5JR0hUX01PREVcIjogXCLYrdin2YTYqiDYtNioXCIsXG5cdFwiREFZX01PREVcIjogXCLYrdin2YTYqiDYsdmI2LJcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCLZhdi02KfZh9iv2Ycg2YXYqtmGINqp2KfZhdmEXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcItqp2KfYsdio2LEg24zYp9mB2Kog2YbYtNivXCIsXG5cdFwiQVBQUk9WRVwiOiBcItiq2KfbjNuM2K9cIixcblx0XCJESVNQVVRFXCI6IFwi2KfYrtiq2YTYp9mBXCIsXG5cdFwiUkVMRUFTRVwiOiBcItin2YbYqti02KfYsSDZhtiz2K7Zh1wiLFxuXHRcIkZST01cIjogXCLYp9iyINi32LHZgVwiLFxuXHRcIklEXCI6IFwi2LTZhtin2LPZhyDaqdin2LHYqNixXCIsXG5cdFwiU1VCTUlUXCI6IFwi2KvYqNiqXCIsXG5cdFwiUkVDRUlWRVJcIjogXCLYr9ix24zYp9mB2Kog2qnZhtmG2K/Zh1wiLFxuXHRcIkxPQ0FUSU9OXCI6IFwi2YXYrdmEXCIsXG5cdFwiV0VCU0lURVwiOiBcItmI2Kgg2LPYp9uM2KpcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCLZhtin2YXbjCDaqdmHINmG2YXYp9uM2LQg2K/Yp9iv2Ycg2YXbjCDYtNmI2K9cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiQmFoYXlcIixcblx0XCJMT0dJTlwiOiBcIk1hZy1Mb2dpblwiLFxuXHRcIkxPR09VVFwiOiBcIkx1bWFiYXNcIixcblx0XCJQUk9GSUxFXCI6IFwiSXlvbmcgUHJvZmlsZVwiLFxuXHRcIkZPTExPV1wiOiBcInN1bmRhblwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIk1nYSBCb29rbWFya1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwiSWxpcGF0XCIsXG5cdFwiTUFSS0VUXCI6IFwiTWVya2Fkb1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwiTWdhIFNldHRpbmdcIixcblx0XCJBQk9VVFwiOiBcIlR1bmdrb2wgZGl0b1wiLFxuXHRcIkFCT1VUXzFcIjogXCJrdW5nIHNhYW4gbmEga2FoaXQgc2lubyBhbmcgcHV3ZWRlbmcga3VtaXRhIHNhIGthbmlsYW5nIG5pbGF0aGFsYSFcIixcblx0XCJBQk9VVF8yXCI6IFwiYXkgc29zeWFsIG5hIGFwbGlrYXN5b24ga3VuZyBzYWFuIGJhYmF5YXJhbiBrYSBzYSBwYWctYm9ibG9nLCBwYWcta3VrdW1lbnRhcnlvIGF0IHBhZ3BpbGkgbmcgdGFtYS5cIixcblx0XCJBQk9VVF8zXCI6IFwiYXQgaXRvIGF5IG9wZW4tc291cmNlLCBwcm95ZWt0b25nIHBhbmcga3VtdW5pbmRhZC4gTmFnIG8tb2ZmZXIgbmcgYWtzZXMgc2EgcGFnYmFzYSBuZyBtZ2EgbmlsYXRoYWxhLCBwYWdrdW1lbnRhcnlvLCBwYWdib3RvLCBwYWdsYXRoYWxhLCBwYWdsaXBhdCBuZyBwZXJhIGF0IGliYSBwYSBuYSBpbm8tb2ZmZXIgbmcge3twbGF0Zm9ybW5hbWV9fSBhdCBuZyB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIERpIHBpbmFwYXlhZ2FuIG5nIEFwcCBhbmcgcGFnLWFrc2VzIG8gcGFnLWhhd2FrIG5nIHBvbmRvIG5nIG1heS1hcmkuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEFuZyBBcHAgYXkgbmFnIG8tb2ZmZXIgbmcgY2xpZW50LXNpZGUgbmEgc2VndXJpZGFkLCBuYSBtYXkgcHJpYmFkb25nIGtleXMgbmEgbG9rYWwgYXQgaGluZGkgbmFncGFwYWRhbGEgc2EgYW51bWFuZyBzZXJ2ZXIuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIEFuZyBBcHAgYXkgbmFnIG8tb2ZmZXIgbmcgcGF5YWssIG1nYSBhdHJha3RpYiBuYSB1c2VyIGludGVyZmFjZXMgYXQgbWdhIGthcmFuYXNhbi5cIixcblx0XCJBQk9VVF83XCI6IFwiQW5nIEFwcCBheSBoaW5kaSBrYWlsYW5tYW4gcHVtaXBpbGl0IHNhIG1nYSBtYXktYXJpIG5hIG1hZ2xhZ2F5IG5nIHBlcnNvbmFsIG5hIGltcG9ybWFzeW9uLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJJYm90byBhbmcgZ29vZC1rYXJtYSBiaWxhbmcgdGlzdGlnb1wiLFxuXHRcIkFCT1VUXzlcIjogXCJLb250YWsvVHVnb246XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNYXJhbWluZyBpbmZvOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlRpbmFuZ2FsXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJUYW5hd2luIG5nIE1lcmthZG9cIixcblx0XCJQUklDRVwiOiBcIlByZXN5b1wiLFxuXHRcIkFNT1VOVFwiOiBcIkhhbGFnZFwiLFxuXHRcIlRPVEFMXCI6IFwiS2FidW9oYW5cIixcblx0XCJOT09SREVSU1wiOiBcIldhbGFuZyBidWthcyBuYSBvcmRlclwiLFxuXHRcIkRBVEVcIjogXCJQZXRzYVwiLFxuXHRcIkJVWVwiOiBcIkJpbGlcIixcblx0XCJTRUxMXCI6IFwiQmVudGFcIixcblx0XCJPUEVOXCI6IFwiQnVrYXNcIixcblx0XCJISVNUT1JZXCI6IFwiS2FzYXlzYXlhblwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiU3VuZGFuX3BhYmFsaWtcIixcblx0XCJGT0xMT1dFRFwiOiBcInNpbnVuZGFuXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJXYWcgc3VuZGFuXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwic2ludXN1bmRhblwiLFxuXHRcIkZPTExPV0VSU1wiOiBcInN1bXVzdW5vZFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJoYW5hcGluIGFuZyBtZ2Egc3VtdXN1bm9kXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcImhhbmFwaW4gYW5nIG1nYSBzaW51c3VuZGFuXCIsXG5cdFwiQllcIjogXCJuaVwiLFxuXHRcIklOXCI6IFwic2FcIixcblx0XCJNRU5VXCI6IFwicGFncGlwaWxpYW5cIixcblx0XCJCT09LTUFSS1wiOiBcIkJvb2ttYXJrXCIsXG5cdFwiUkVCTE9HXCI6IFwiVWxpdGluZyBpLWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJQYWdib3RvIG5nIG1hdGFhc1wiLFxuXHRcIkRPV05WT1RFXCI6IFwiUGFnYm90byBuZyBtYWJhYmFcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiVGFuZ2dhbGluIGFuZyBQYWdib3RvIG5nIG1hYmFiYVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiVGFuZ2dhbGluIGFuZyBQYWdib3RvIG5nIG1hdGFhc1wiLFxuXHRcIlJFUExZXCI6IFwic2Fnb3RcIixcblx0XCJFRElUXCI6IFwiQmFndWhpblwiLFxuXHRcIlBPU1RfMVwiOiBcInBhZHVsYXNpbiBwYWthbGl3YSBzYSBrdW1lbnRhcnlvIHBhcmEgbWFraXRhIGFuZyBwYWdwaXBpbGlhblwiLFxuXHRcIlBPU1RfMlwiOiBcIkktdGFwIGFuZyBtZ2Ega29tZW50byBwYXJhIG1ha2l0YSBhbmcgaWJhIHBhbmcga29tZW50b25nIG5ha2FwYWxvb2JcIixcblx0XCJPUFRJT05TXCI6IFwicGFncGlwaWxpYW5cIixcblx0XCJSRVNURUVNRURfQllcIjogXCJJbnVsaXQgbmEgaS1ibG9nIG5pXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwid2FsYSBwYSBkaXRvXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJCYWxhbnNlXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgbWdhIHRyYWRlYWJsZSBuYSB0b2tlbiBuYSBwdXdlZGVuZyBpbGlwYXQga2FoaXQgYW51bWFuZyBvcmFzLnt7cGxhdGZvcm1uYW1lfX0gcHV3ZWRlbmcgaS1jb252ZXJ0IHNhIHt7cGxhdGZvcm1wb3dlcn19IG5hIGlzYW5nIHByb3Nlc29uZyB0aW5hdGF3YWcgbmEgcG93ZXJpbmcgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGltcGx1d2Vuc3lhIG5nIG1nYSB0b2tlbiBuYSBrdW1pdGEgbmcgaGlnaXQgcGFuZyBwb3dlciBzYSBwYWdoYWhhd2FrIG5nIG1hdGFnYWwgYXQgcGFnYm90byBzYSBtZ2EgaXBpbm9zdC4gS2FwYWcgbWFyYW1pIGFuZyBoaW5hd2FrYW4gbWFzIG1hbGFraSBhbmcgcHV3ZWRlbmcgbWFpYmlnYXkgbmEgcmV3YXJkcy5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJLYWhhbGFnYWhhbiBuZyBtZ2EgdG9rZW4gdHVuZ2tvbCBzYXt7cGxhdGZvcm1zdW5pdH19IG5nIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiZW5pc3RpbWFuZyBoYWxhZ2FcIixcblx0XCJQUk9GSUxFXzRcIjogXCJBbmcgdGluYXRheWFuZyBoYWxhZ2EgYXkgbmFrYWJhc2Ugc2EgaXNhbmcgNy1hcmF3IG5hIGthcmFuaXdhbmcgaGFsYWdhIG5nIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIkthc2F5c2F5YW4gbmcgbWdhIFRyYW5zYWtzeW9uXCIsXG5cdFwiUE9TVElOR1wiOiBcIlBhZy1wb3N0XCIsXG5cdFwiUFJPRklMRV81XCI6IFwiQW5nIHN1c2kgc2EgcGFncG9zdCBheSBnaW5hZ2FtaXQgc2EgcGFnLXBvcG9zdCBhdCBwYWdib3RvLiBEYXBhdCBpYmEgaXRvIHNhIGFrdGliIG5hIHN1c2kgYXQgc3VzaSBuZyBtYXktYXJpLlwiLFxuXHRcIk9XTkVSXCI6IFwibWF5IGFyaVwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkFuZyBzdXNpIG5nIG1heS1hcmkgYXkgYW5nIG1hc3RlciBrZXkgcGFyYSBzYSBhY2NvdW50IGF0IGthaWxhbmdhbiBpdG8gcGFyYSBzYSBwYWctaWJhIG5nIGliYW5nIGtleXMuIEFuZyBwcmliYWRvbmcga2V5IG8gYW5nIHBhc3N3b3JkIG5nIHN1c2kgbmcgbWF5LWFyaSBheSBkYXBhdCBpdGFnbyBvZmZsaW5lLlwiLFxuXHRcIkFDVElWRVwiOiBcImFrdGlib1wiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkFuZyBha3RpYiBuYSBzdXNpIGF5IGdpbmFnYW1pdCBzYSBwYWdsaXBhdCBhdCBwYWdsYWdheSBuZyBvcmRlciBzYSBpbnRlcm5hbCBuYSBtZXJrYWRvLlwiLFxuXHRcIk1FTU9cIjogXCJUYWxhXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiQW5nIHN1c2kgbmcgdGFsYSBheSBnaW5hZ2FtaXQgc2EgcGFnZ2F3YSBhdCBwYWdiYXNhIG5nIG1nYSB0YWxhLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJQb3N0c1wiLFxuXHRcIlJFUExJRVNcIjogXCJtZ2Egc2Fnb3RcIixcblx0XCJXQUxMRVRcIjogXCJwaXRha2FcIixcblx0XCJUQUdcIjogXCJUYWdcIixcblx0XCJVU0VSXCI6IFwiR3VtYWdhbWl0XCIsXG5cdFwiQ0xPU0VcIjogXCJzYXJhXCIsXG5cdFwiVE9cIjogXCJwYXJhIGtheVwiLFxuXHRcIkFTU0VUXCI6IFwiQXNzZXRcIixcblx0XCJTRU5EXCI6IFwicGluYWRhbGFcIixcblx0XCJTRUNVUklUWVwiOiBcInNlZ3VyaWRhZFwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIk5hZ2FnYW1pdFwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiUHVibGlrb25nIFRhbGFcIixcblx0XCJUT19ERVNDXCI6IFwiR3VtYWdhbWl0IGhhbGltYmF3YSwgZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUGluIENvZGVcIixcblx0XCJQSU5fVEVYVFwiOiBcIkFuZyBQSU4gY29kZSBheSB0dW11dHVsb25nIHNhIHBhZyBzaWd1cm8gbmcgYXBwIGF0IG5nIGl5b25nIG1nYSBkYXRvcy48YnIvPjxici8+PGI+IFRhbmRhYW46PC9iPiBLYXBhZyBuYWthIGVuYWJsZSwgbWF5IGhpZ2l0IDQgbmEgYmVzZXMga2EgbWFnIHVubG9jaywga2FwYWcgbmFrYWxpbXV0YW4gbW8gaXRvLCBhbmcgZGF0b3MgbmcgZ3VtYWdhbWl0IGF5IHRhdGFuZ2dhbGluIG5nIGFwcC4gTWFhYXJpIGthbmcgbWFnIHJlLWxvZ2luIGF0IG1hZ3BhdHVsb3kgc2EgcGFnZ2FtaXQgbmcgYXBwLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJNZ2EgQWJpc29cIixcblx0XCJWT1RFX1RFWFRcIjogXCJNYWtha2FrdWhhIGthIG5nIGFiaXNvIGthcGFnIG1heSBzaW5vIG1hbmcgdGFvIG5hIGJvYm90byBzYSBpcGlub3N0IG1vISA8YnIvPjxiPlRhbmRhYW46PC9iPiBOYWthcGFsb29iIGRpbiBzYSBtZ2EgYWJpc28gYW5nIGJpZ2F0IG5nIGl5b25nIHBhZ2JvdG8gYXQgbWdhIG1lbnNhaGVuZyBtYXkgYWxlcnRvLlwiLFxuXHRcIlZPVEVcIjogXCJib3RvXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiTWFrYWtha3VoYSBrYSBuZyBhYmlzbyBrYXBhZyBtYXkgc2lubyBtYW5nIHRhbyBuYSBtYWdrdWt1bWVudG8gc2EgbWdhIHBpbm9zdCBhdCBtZ2Ega29tZW50byBtbyE8YnIvPjxiPlRhbmRhYW46PC9iPk5ha2FwYWxvb2IgZGluIHNhIG1nYSBhYmlzbyBrdW5nIG1heSBzaW5vIG1hbmcgdGFvIDxiPmFuZyBtYWcgYmFnbzwvYj4gc2Ega2FuaWxhbmcgbWdhIGtvbWVudG8uXCIsXG5cdFwiQ09NTUVOVFwiOiBcImt1bWVudGFyeW9cIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIk1ha2FrYWt1aGEga2EgbmcgYWJpc28ga2FwYWcgbWF5IHNpbm8gbWFuZyB0YW8gYW5nIHN1c3Vub2QgYXQgZGkgc3VzdW5vZCBzYSBpeW8hXCIsXG5cdFwiTUVOVElPTlNcIjogXCJzaW5hYmlcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiTWFrYWtha3VoYSBrYSBuZyBhYmlzbyBrYXBhZyBtYXkgc2lubyBtYW5nIHRhbyBhbmcgYmFiYW5nZ2l0IHNhIHBhbmdhbGFuIG1vIHNhIHBvc3RzL2tvbWVudG8gbmlsYSFcIixcblx0XCJSRVNURUVNXCI6IFwiVWxpdGluZyBpLWJsb2dcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJNYWtha2FrdWhhIGthIG5nIGFiaXNvIGthcGFnIG1heSBzaW5vIG1hbmcgdGFvIGFuZyBtYWcgdXVsaXQgc2EgcGFnYmxvZyBuZyBpeW9uZyBpcGlub3N0IVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiQ29uZmlndXJhdGlvbnNcIixcblx0XCJWT1RJTkdcIjogXCJiaW5vYm90b1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiQW5nIGJpZ2F0IG5nIHBhZ2JvdG8gYXkgbmFrYWthYXBla3RvIHNhIHBvd2VyIG5nIHBhZ2JvdG8sIGtheWEgcHV3ZWRlIG1vbmcgbWEtaXJlZ3VsYXRlIGFuZyByZXdhcmQgc2EgcGFnYm90by48YnIvPjxici8+PGI+VGFuZGFhbjo8L2I+TWFrYWthaWJhIGl0byBzYSBiaWdhdCBuZyBwYWdib3RvIGthcGFnIGJ1bW90byBrYSBuZyBtYWJhYmFcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIk5pcmVyZWtvbWVuZGFcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJJLXNhdmUgYW5nIG1nYSBQYWdiYWJhZ29cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkltcG9ybWFzeW9uIG5nIG1nYSBib3RhbnRlXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwibWFsaWdheWFuZyBwYWdiYWJhbGlrXCIsXG5cdFwiTE9HSU5fMVwiOiBcIk1hZy1zaWduIGluIGdhbWl0IGFuZyBpeW9uZyB1c2VybmFtZSBhdCBwYXNzd29yZCBwYXJhIG1hZ3BhdHVsb3kuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkFuZyBzdXNpIG5nIHBhZy1wb3N0IGF5IGdpbmFnYW1pdCBzYSBwYWctcG9zdCwga29tZW50bywgcGFnYm90bywgcGFnLXN1bm9kLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBbmcgYWt0aWIgbmEgc3VzaSBheSBnaW5hZ2FtaXQgc2EgcGFnbGlwYXQgYXQgcGFnLXVwZGF0ZSBuZyBsYXJhd2FuIG5nIG1heS1hcmkuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkFuZyBtZ2Ega3JlZGVuc3lhbCBuZyBndW1hZ2FtaXQgYXkgbG9rYWwgbmEgdGluYXRhZ28gc2EgZGV2aWNlLiBLYXBhZyBuYWctbG9nb3V0LCBhbmcgbWdhIGtyZWRlbnN5YWwgYXkgdGluYXRhbmdnYWwhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiV2FsYSBwYW5nIGFjY291bnQ/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJNYWctc2lnbiB1cFwiLFxuXHRcIkNBTkNFTFwiOiBcIkthc2VsYWhpblwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiQWR2YW5jZWRcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiUHJpYmFkb25nIGFrdGliIG5hIHN1c2lcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIlByaWJhZG9uZyBzdXNpIHNhIHBhZy1wb3N0XCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJNYXN0ZXIvbWFpbiBwYXNzd29yZFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiVXNlcm5hbWVcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJUYW5hd2luIG5nIGNhcmRcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJUYW5hd2luZyBjb21wYWN0XCIsXG5cdFwiU0VBUkNIXCI6IFwiaGFuYXBpblwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwibWFncGFwYXNhIG5nIHN0b3J5YVwiLFxuXHRcIlJFUExZVE9cIjogXCJzdW1hZ290IGtheVwiLFxuXHRcIlBPU1RcIjogXCJQb3N0XCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZXZpZXdcIixcblx0XCJERUZBVUxUXCI6IFwiRGVmYXVsdCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgVXAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiVGFuZ2dpaGFuIGFuZyBQYXlvdXRcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIkktU0FWRSBQQVJBIE1BTUFZQVwiLFxuXHRcIkNMRUFSXCI6IFwiQlVSQUhJTlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBhZy1wb3N0IG5nIG5pbGFsYW1hblwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIk1hZ2t1bWVudG8gc2EgbmlsYWxhbWFuXCIsXG5cdFwiVElUTEVcIjogXCJ0aXRvbG9cIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIkhJTkRJIFRVR01BXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJLdW1waXJoYW1pbiBhbmcgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiaGluZGkgdGFtYVwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcImFuZyBwb3N0IGF5IGJpbnVidWtzYW5cIixcblx0XCJTRVRfUElOXCI6IFwiTWFnLXNldCBuZyBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJpcGFzb2sgYW5nIHBpblwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcInNpZ3VyYWRvIGthP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiQW5nIHBhZ3VsaXQgc2EgcGFnYmxvZyBheSBoaW5kaSBtYXdhd2FsYW4gbmcgYmlzYSwgZ3VzdG8gbW8gYmFuZyBtYWdwYXR1bG95P1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkVycm9yIHNhIHBhZy1icm9hZGNhc3QsIHN1YnVrYW5nIG11bGkhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlRhZ3VtcGF5XCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJBbmcgcG9zdCBheSBuYWktYmxvZ2dlZCB1bGl0IVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJCaWdvIHNhIHBhZy1sb2dpbiEgTWFuZ3lhcmluZyB0aXlha2luIGFuZyBtYXN0ZXIgcGFzc3dvcmQgbyBhbmcgcHJpYmFkb25nIHN1c2kgc2EgcGFnLXBvc3Qga3VuZyBwaW5pbGkgbW8gYW5nIEFkdmFuY2VkIG1vZGUuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiQmlnbyBzYSBwYWctbG9naW4hIE1hbmd5YXJpbmcgdGl5YWtpbiBhbmcgbWFzdGVyIHBhc3N3b3JkIG8gYW5nIHByaWJhZG9uZyBha3RpYiBuYSBzdXNpIGt1bmcgcGluaWxpIG1vIGFuZyBBZHZhbmNlZCBtb2RlLlwiLFxuXHRcIldBUk5JTkdcIjogXCJiYWJhbGFcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiaWJpbm90byBwYXJhIG1hZ2luZyB0ZXN0aWdvXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJiaW5vdG8gcGFyYSBtYWdpbmcgdGVzdGlnb1wiLFxuXHRcIkFHT1wiOiBcIm5ha2FsaXBhc1wiLFxuXHRcIkZST01fTk9XXCI6IFwibXVsYSBuZ2F5b25cIixcblx0XCJTRUNTXCI6IFwic2Vnb25kb1wiLFxuXHRcIkFfTUlOXCI6IFwiaXNhbmcgbWludXRvXCIsXG5cdFwiTUlOU1wiOiBcIm1nYSBtaW51dG9cIixcblx0XCJBTl9IT1VSXCI6IFwiaXNhbmcgb3Jhc1wiLFxuXHRcIkhPVVJTXCI6IFwibWdhIG9yYXNcIixcblx0XCJBX0RBWVwiOiBcImlzYW5nIGFyYXdcIixcblx0XCJEQVlTXCI6IFwibWdhIGFyYXdcIixcblx0XCJBX01PTlRIXCI6IFwiaXNhbmcgYnV3YW5cIixcblx0XCJNT05USFNcIjogXCJtZ2EgYnV3YW5cIixcblx0XCJBX1lFQVJcIjogXCJpc2FuZyB0YW9uXCIsXG5cdFwiWUVBUlNcIjogXCJtZ2EgdGFvblwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWludXRvIHNhIHBhZ2Jhc2FcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiUGFnYm90byBuZyBtYWJhYmEgbyBGbGFnXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiS3VuYW4gbmcgTGFyYXdhblwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwicGlsaSBuZyBsaXRyYXRvXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJNYWctc2V0IG5nIEN1c3RvbSBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIk1hZy1pbnNlcnQgbmcgTGFyYXdhblwiLFxuXHRcIkVSUk9SXCI6IFwiRXJyb3JcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJFcnJvciBzYSBQYWctdXBsb2FkXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIktpbmFuc2VsYSBhbmcgQ2FtZXJhXCIsXG5cdFwiU0VUX1VSTFwiOiBcIkktc2V0IGFuZyBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWt0YSBuYSB3ZWIgbGluayBwYXJhIHNhIGxhcmF3YW5cIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcImt1bWVudG8gYXkgbmFwYXNhIG5hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJidXJhIGFuZyBrdW1lbnRvXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwibmFidXJhIG5hIGFuZyBrdW1lbnRvXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJBbmcgbGFyYXdhbiBheSBpbmEtdXBsb2FkXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIkFuZyBwYWctdXBsb2FkIGF5IG5ha3VtcGxldG9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiQmlnbyBhbmcgcGFnLXVwbG9hZFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkFuZyBwYXNzd29yZCBvIGFjY291bnQgYXkgaGluZGkgdGFtYVwiLFxuXHRcIklORk9cIjogXCJJbXBvcm1hc3lvblwiLFxuXHRcIlFSX1RFWFRcIjogXCJJbGFnYXkgYW5nIFFSIGNvZGUgc2EgbG9vYiBuZyBzY2FuIGFyZWFcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJTaWd1cmFkdWhpbmcgbWF5IHNhcGF0IG5hIGJhbGFuc2UgcGFyYSBzYSB0cmFuc2Frc3lvbiFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiQW5nIGd1bWFnYW1pdCBuYSBndXN0byBtb25nIGxpcGF0YW4gbmcgcG9uZG8gYXkgZGkgbWF0YWdwdWFuIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJzaWd1cmFkbyBrYSBuYSBndXN0byBtbyBpbGlwYXQ/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiS29tcGlybWFzeW9uXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJBbmcgdHJhbnNha3N5b24gYXkgbmFpLWJyb2FkY2FzdFwiLFxuXHRcIkZFRURcIjogXCJGZWVkXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJUcmVuZGluZ1wiLFxuXHRcIkhPVFwiOiBcIm1haW5pdFwiLFxuXHRcIk5FV1wiOiBcImJhZ29cIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vdGVkXCIsXG5cdFwiVk9URVNcIjogXCJtZ2EgYm90b1wiLFxuXHRcIlBBWU9VVFwiOiBcImJheWFkXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJrdW1lbnRvXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuZGluZyBzYSAzMCBhcmF3XCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiVXJpaW4gYW5nIG1nYSBwb3N0IG5nOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIlBheW91dCBDeWNsZVwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQb3RlbnN5YWwgbmEgUGF5b3V0XCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJuYWthcmFhbmcgYmF5YWFkXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcImJheWFkIHNhIG1heSBha2RhXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiQ3VyYXRpb24gUGF5b3V0XCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJBbmcgcG9zdCBheSBuYWktc3VibWl0IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQb3N0IHBhcmEgc2EgbWFtYXlhbmcgcGFnLXN1Ym1pdCFcIixcblx0XCJTQVZFRFwiOiBcIk5haS1zYXZlXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIk5haS1idXJhXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIlNhIHBhZy1mbGFnIG5nIHBvc3QgbmEgaXRvIGF5IG1hYXJpbmcgbWF0YW5nZ2FsIGFuZyByZXdhcmRzIGF0IGFuZyBtYXRlcmlhbCBheSBkaSBuYSBtYWtpa2l0YS48YnI+PGJyPkFuZyBwYWctZmxhZyBheSBwdXdlZGVuZyBnYW1pdGluIGxhYmFuIHNhOiA8dWw+PGxpPkthc2ludW5nYWxpbmdhbiBvIFBhZ2tvcHlhPC9saT48bGk+SGF0ZSBTcGVlY2ggbyBJbnRlcm5ldCBUcm9sbGluZzwvbGk+PGxpPkRpIGNhdGVnb3JhZG8gbmEgbmlsYWxhbWFuIG8gU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJVbWFib3Qgc2EgbGltaXRhc3lvbiBhbmcgaGluaWhpbGluZy4gVGlnbmFuIGFuZyBpYmFuZyB0cmVuZHMvdGFncyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJBbmcgcG9zdCBheSBuYXRhbmdnYWwgc2EgbWdhIGJvb2ttYXJrcyFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiQW5nIHBvc3QgYXkgbmFpZGFnZGFnIHNhIG1nYSBib29rbWFya3MhXCIsXG5cdFwiUkVTRVRcIjogXCJJLXJlc2V0XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJCYWd1aGluIGFuZyBsYXJhd2FuIG5nIG1heS1hcmlcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIkJhZ3VoaW4gYW5nIENvdmVyIG5nIExhcmF3YW5cIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJNYW5neWFyaW5nIG1hZ2JpZ2F5IG5nIHByaWJhZG9uZyBha3RpYiBuYSBzdXNpIGt1bmcgcGluaWxpIG1vIGFuZyBBZHZhbmNlZCBsb2dpbiBtb2RlIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIklyaS1yZXNldCBuaXRvIGFuZyBsYXJhd2FuIG5nIGd1bWFnYW1pdFwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIklyaS1yZXNldCBuaXRvIGFuZyBjb3ZlciBuYSBsYXJhd2FuIG5nIGd1bWFnYW1pdFwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiS2FpbGFuZ2FuIGktcmVzdGFydCBwYXJhIHNhIHNlcnZlciB1cGRhdGUhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIk5hLXVwZGF0ZSBhbmcgbWdhIHNldHRpbmdzIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcImxlbmd1YWdlXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJEaXRvIG1vIHB1d2VkZW5nIGliYWhpbiBhbmcgbGluZ2d1d2FoZSBuZyBhcHAuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIk1haW4gcGFzc3dvcmQgYW5nIGthaWxhbmdhbiBzYSBvcGVyYXN5b24gbmEgaXRvLiBNYW5neWFyaW5nIG1hZy1sb2dpbiBhdCBzdWJ1a2FuZyBtdWxpLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxsZXJ5XCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiTWdhIG5hZy1hbWJhZyBuZyBwYWdzYXNhbGluXCIsXG5cdFwiU0hBUkVcIjogXCJJYmFoYWdpXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJMdWdhciBuZyBNZXJrYWRvXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJtYWdwYWxpdFwiLFxuXHRcIkRSQUZUU1wiOiBcIk1nYSBCb3JhZG9yXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiQW5nIHBvc3QgYXkgdGluYW5nZ2FsIHNhIG1nYSBib3JhZG9yIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJBbmcgcG9zdCBheSBuYWlkYWdkYWcgc2EgbWdhIGJvcmFkb3IhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcInBhZHVsYXNpbiBwYWthbGl3YSBwYXJhIG1ha2l0YSBhbmcgcGFncGlwaWxpYW5cIixcblx0XCJNQU5BR0VcIjogXCJQYW1haGFsYWFuXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIm5hdGFuZ2FsIG5hIGFuZyBpbWFoZVwiLFxuXHRcIkNPUFlcIjogXCJjb3B5YVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwid2FsYW5nIGxhcmF3YW5cIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIkhpbGFoaW4gcGFyYSBtYWktcmVmcmVzaFwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJQYW5sYWJhcyBuYSBtZ2EgQXBwXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpbnNcIixcblx0XCJTVUdHRVNUXCI6IFwiTWFnbXVuZ2thaGlcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIk1hbGFwaXQgbmFcIixcblx0XCJDSEFJTlwiOiBcIkthZGVuYVwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJEaXRvIG1pIHB1d2VkZW5nIGJhZ3VoaW4gYW5nIGJsb2NrY2hhaW4gbyBkZWZhdWx0IG5hIHBsYXRmb3JtLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiUGVyYVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJEaXRvIG1vIHB1d2VkZW5nIGJhZ3VoaW4gYW5nIGl5b25nIGRlZmF1bHQgbmEgcGVyYS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj5UYW1wb2sgbmEgbGlzdGFoYW48L2I+IDxicj4tQWtzZXMgc2Ega2FrYWliYW5nIGFydGlrdWxvIHNhIGFudW1hbmcgcGFrc2EgbW8gYXkgaW50ZXJlc2FkbyBzYSBwYWdiYWJhc2EuIDxicj4gLU1ha2lzYWxpIHNhIG1heS1ha2RhIHNhIHBhbWFtYWdpdGFuIG5nIHBhZ2t1bWVudG8sIHBhZ3RhbGFrYXkgbmcgbWdhIHBha3NhLiA8YnI+LVBhZ2JvdG8gcGFyYSBzYSBwb3N0IG5hIG1heSByZXdhcmRzIHNhIG1nYSBhd3RvciBwYXRpIHJld2FyZHMgc2EgY3VyYXRpb24uIDxicj4tUGFnbGF0aGFsYSBuZyBtZ2EgYXJ0aWt1bG8sIGJsb2cgcG9zdCBhdCBtYWctaG9zdCBzYSBrYW5pbGEgbmFuZyBsaWJyZSBhdCBrdW1pdGEgbmcgcHJlbXlvIHNhIHBhZ3NhbGkgYXQgbWFna2Fyb29uIG5nIHRhZ2FzdW5vZC4gPGJyPi1TdW11bGF0IG5nIGFydGlrdWxvIHR1bmdrb2wgc2EgbWdhIGJhZ2F5LCBtYWxpYmFuIHNhIG1hcmFtaW5nIGJvcmFkb3IgbmcgYW5nIHBvc3QgbmEgaXRvIHBhcmEgc2EgbWdhIG1hbWF5YSBwdWJsaWthc3lvbi4gPGJyPi1Cb29rbWFyayBwYWJvcml0byBuaW55b25nIG1nYSBhcnRpa3VsbyBwYXJhIGJhc2FoaW4gc2EgaWJhbmcgcGFna2FrYXRhb24uIDxicj4tRXhjaGFuZ2UgbyBjYXNoIG91dCBzYSBpeW9uZyBraXRhLiA8YnI+LVBhZGFsYSBtb25nIHBlcmEgcGFyYSBzYSBhbnVtYW5nIG1nYSBtYXktYWtkYSBvIG1nYSBndW1hZ2FtaXQsIG1nYSBrYWliaWdhbiwgbWdhIHRhZ2FzdW5vZCwgYXQga3VuZyBhbnUtYW5vIHBhIDxicj5Gb2xsb3cga2F3aWxpLXdpbGluZyBtZ2EgbWF5LWFrZGEsIGJsb2dnZXIuIDxicj4gLVNhbGlrc2lraW4gYW5nIGlueW9uZyBtZ2EgdGFnYXN1bm9kIGF0IHNpbnVzdW5vZCBtbyBhbmcgbWdhIG1heS1ha2RhLiBLdW11aGEgbmcgbWdhIDxicj5ub3RpZmljYXRpb24gbmEgbWFuYXRpbGluZyBtYXkgdWduYXlhbiBzYSBpeW9uZyBtZ2EgdGFnYXN1bm9kIGF0IHRhbGFrYXlhbiBrYXlvIGF5IGthc2FuZ2tvdC4gcGEgPGJyPi1TZWFyY2ggcGFyYSBzYSBrYXdpbGktd2lsaW5nIHRhZ3Mva2F0ZWdvcnlhIG5nIGFydGlrdWxvLCBtYXktYWtkYS4gPGJyPiAtSS1wZXJzb25hbGl6ZSBhbmcgaXlvbmcgcHJvZmlsZS4gPGJyPlNhIG1hcmFtaW5nIGthcmFnZGFnYW5nIHRhbXBvayBuYSBkYXJhdGluZy4gPGJyPjxicj48Yj5TZWN1cml0eTwvYj4gPGJyPjEgSS1hY2Nlc3MgYW5nIGFwcCBrYWlsYW5tYW4gbyBodW1hd2FrIG5nIG1nYSBndW1hZ2FtaXQgbmcgbWdhIHBvbmRvLiA8YnI+Mi4gYXBwIGF5IG5hZy1hYWxvayBuZyBpc2FuZyBtb2RlbG8gbmcgc2VndXJpZGFkIHNhIGNsaWVudCBzaWRlLCBtYXkgcHJpYmFkb25nIHN1c2kgbmEgbmFrYS1ob3N0IHNhIGthbmlsYW5nIGx1Z2FyIGF0IGhpbmRpIG5hZ3BhZGFsYSBzYSBhbnVtYW5nIG1nYSBzZXJ2ZXIsIGlrYXcgYXkgcmVzcG9uc2FibGUgcGFyYSBzYSBwYWctYmFjayB1cCBuZyBpeW9uZyBwYXNzd29yZC4gPGJyPjMuIGFwcCBheSBuYWctYWFsb2sgbmcgbWdhIGd1bWFnYW1pdCBuZyBzaW1wbGUgYXQga2Fha2l0LWFraXQgbmEgaW50ZXJmYWNlcyBhdCA8YnI+NCBtZ2Ega2FyYW5hc2FuLiBBcHAgYXkgbmFnLWFhbG9rIG5nIGRhZ2RhZyBuYSBwYXRvbmcgbmcgc2VndXJpZGFkIHNhIEtvZGlnbyBuZyBwaW4gPGJyPjxicj5wYWdwYXBhaGFsYWdhIGF5IHN1bXVzdXBvcnRhIHNhIFN0ZWVtIGF0IEdvbG9zIG5hIHBsYXRmb3JtLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIlRhZ2FwYWd0YXRhZyBhdCBOYW5ndW5ndW5hbmcgRGV2ZWxvcGVyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJNYWdkYWdkYWcgbmcgYWNjb3VudFwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgYWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJEZWFkbGluZSBzYSBwYWdwYXBhdGliYXlcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyBleHBpcmF0aW9uXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkJheWFkIHNhIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIk1nYSB0dW50dW5pbiBzYSBFc2Nyb3dcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiUGFuZy1nYWJpIG5hIG1vZGVcIixcblx0XCJEQVlfTU9ERVwiOiBcIlBhbmctdW1hZ2FuZyBtb2RlXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiVGlnbmFuIGFuZyBidW9uZyBrb250ZWtzdG9cIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiSGluZGkgbWFoYW5hcCBhbmcgZ3VtYWdhbWl0XCIsXG5cdFwiQVBQUk9WRVwiOiBcIkFwcnViYWhhblwiLFxuXHRcIkRJU1BVVEVcIjogXCJQYWd0YXRhbG9cIixcblx0XCJSRUxFQVNFXCI6IFwiUmVsZWFzZVwiLFxuXHRcIkZST01cIjogXCJNdWxhIHNhXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIklzdW1pdGVcIixcblx0XCJSRUNFSVZFUlwiOiBcIlRhZ2F0YW5nZ2FwXCIsXG5cdFwiTE9DQVRJT05cIjogXCJMb2thc3lvblwiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJzaXRlXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiUGFuZ2FsYW4gbmEgbmFrYWRpc3BsYXlcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiQWNjdWVpbFwiLFxuXHRcIkxPR0lOXCI6IFwiQ29ubmV4aW9uXCIsXG5cdFwiTE9HT1VUXCI6IFwiRMOpY29ubmV4aW9uXCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbFwiLFxuXHRcIkZPTExPV1wiOiBcIlN1aXZyZVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlNpZ25ldHNcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVydFwiLFxuXHRcIk1BUktFVFwiOiBcIk1hcmNow6lcIixcblx0XCJTRVRUSU5HU1wiOiBcIlBhcmFtw6h0cmVzXCIsXG5cdFwiQUJPVVRcIjogXCJBIHByb3Bvc1wiLFxuXHRcIkFCT1VUXzFcIjogXCJvw7kgbidpbXBvcnRlIHF1aSBwZXV0IGdhZ25lciBkZXMgcsOpY29tcGVuc2VzIHBvdXIgc29uIGNvbnRlbnUhXCIsXG5cdFwiQUJPVVRfMlwiOiBcImVzdCBzdXBwb3J0w6kgcGFyIGxhIHBsYXRlLWZvcm1lIHt7cGxhdGZvcm1uYW1lfX0uIEFwcGxpY2F0aW9uIGNyw6nDqWUgcGFyXCIsXG5cdFwiQUJPVVRfM1wiOiBcIklsIHMnYWdpdCBkJ3VuIHByb2pldCBwb3VyIGxhIGNvbW11bmF1dMOpIG1vYmlsZSBldCBpbCBlc3Qgb3Blbi1zb3VyY2UuIElsIG9mZnJlIHVuIGFjY8OocyBwb3VyIGxpcmUsIGNvbW1lbnRlciwgdm90ZXIsIHBvc3RlciwgYWZmaWNoZXIgbGUgdHJhbnNmZXJ0IGRlIHLDqWNvbXBlbnNlLCBldGMuIFRvdXRlcyBsZXMgZm9uY3Rpb25uYWxpdMOpcyBvZmZlcnRlcyBwYXIge3tzaXRlbmFtZX19IGV0IGxhIGJsb2NrY2hhaW4ge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gTCdhcHBsaWNhdGlvbiBuJ2EgamFtYWlzIGFjY8OocyBhdXggZm9uZHMgZGUgbCd1dGlsaXNhdGV1ci5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gTCdhcHBsaWNhdGlvbiBvZmZyZSB1biBtb2TDqGxlIGRlIHPDqWN1cml0w6kgw6Agc2VzIGNsaWVudCwgYXZlYyBkZXMgY2zDqXMgcHJpdsOpZXMgaMOpYmVyZ8OpZXMgbG9jYWxlbWVudCBldCBqYW1haXMgZW52b3nDqWVzIMOgIGF1Y3VuIHNlcnZldXJzLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBMJ2FwcGxpY2F0aW9uIG9mZnJlIHVuZSBpbnRlcmZhY2Ugc2ltcGxlIGV0IGRlcyBleHDDqXJpZW5jZXMgYXR0cmF5YW50ZXMgYXV4IHV0aWxpc2F0ZXVycy5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gTCdhcHBsaWNhdGlvbiBuZSBkZW1hbmRlIGphbWFpcyDDoCBjZSBxdWUgbGVzIHV0aWxpc2F0ZXVycyBzYWlzaXNzZW50IGRlcyBpbmZvcm1hdGlvbnMgcGVyc29ubmVsbGVzLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJWb3RleiBwb3VyIGdvb2Qta2FybWEgY29tbWUgdMOpbW9pblwiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YWN0L1LDqWFjdGlvbjpcIixcblx0XCJBQk9VVF8xMFwiOiBcIlBsdXMgZCdpbmZvczpcIixcblx0XCJSRU1PVkVcIjogXCJTdXBwcmltZXJcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIlZ1ZSBkdSBtYXJjaMOpXCIsXG5cdFwiUFJJQ0VcIjogXCJQcml4XCIsXG5cdFwiQU1PVU5UXCI6IFwiTW9udGFudFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiUGFzIGQnb3JkcmVzIG91dmVydHMgcG91clwiLFxuXHRcIkJVWVwiOiBcIkFjaGF0XCIsXG5cdFwiU0VMTFwiOiBcIlZlbnRlXCIsXG5cdFwiT1BFTlwiOiBcIk91dmVydFwiLFxuXHRcIkhJU1RPUllcIjogXCJIaXN0b3JpcXVlXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJTdWl2cmVcIixcblx0XCJGT0xMT1dFRFwiOiBcIkFib25uw6lcIixcblx0XCJVTkZPTExPV1wiOiBcIkTDqXNhYm9ubmVyXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIkNoZXJjaGVyIGZvbGxvd2Vyc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJDaGVyY2hlciBmb2xsb3dpbmdcIixcblx0XCJCWVwiOiBcInBhclwiLFxuXHRcIklOXCI6IFwiZGFuc1wiLFxuXHRcIkJPT0tNQVJLXCI6IFwiU2lnbmV0XCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlJldGlyZXIgRG93bnZvdGVcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlJldGlyZXIgVXB2b3RlXCIsXG5cdFwiUkVQTFlcIjogXCJSw6lwb25kcmVcIixcblx0XCJFRElUXCI6IFwiRWRpdGVyXCIsXG5cdFwiUE9TVF8xXCI6IFwiR2xpc3NlciB2ZXJzIGxhIGdhdWNoZSBzdXIgbGVzIGNvbW1lbnRhaXJlcyBwb3VyIHZvaXIgbGVzIG9wdGlvbnNcIixcblx0XCJQT1NUXzJcIjogXCJBcHB1eWV6IHN1ciBsZXMgY29tbWVudGFpcmVzIHBvdXIgdm9pciBsZXMgc291cy1jb21tZW50YWlyZXNcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZXN0ZWVtIHBhclwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIlJpZW4gaWNpIGVuY29yZS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU29sZGVzXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwiTGVzIHt7cGxhdGZvcm1uYW1lfX0sIGpldG9ucyBuw6lnb2NpYWJsZXMgcXVpIHBldXZlbnQgw6p0cmUgdHJhbnNmw6lyw6lzIMOgIHRvdXQgbW9tZW50LiBMZSB7e3BsYXRmb3JtbmFtZX19IHBldXQgw6p0cmUgY29udmVydGkgZW4ge3twbGF0Zm9ybXBvd2VyfX0gZGFucyB1biBwcm9jZXNzdXMgYXBwZWzDqSBwb3dlci11cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgamV0b25zIGQnaW5mbHVlbmNlLCB2b3VzIGdhZ25leiBwbHVzIGRlIFN0ZWVtIFBvd2VyIGVuIGxlIGNvbmNlcnZhbnQgw6AgbG9uZyB0ZXJtZSBldCBlbiB2b3RhbnQgc3VyIGxlcyBwb3N0ZXMuIFBsdXMgb24gbGUgY29uc2VydmUsIHBsdXMgb24gYSBkJ2luZmx1ZW5jZSBzdXIgbGVzIHLDqWNvbXBlbnNlcyBkZXMgYXV0cmVzIGV0IGRhbnMgbCdvYnRlbnRpb24gZGUgcsOpY29tcGVuc2UgcG91ciB1biB2b3RlIGVuIHBhcnRpY3VsaWVyLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIkpldG9ucyBkJ3VuZSB2YWxldXIgZCdlbnZpcm9uIHt7cGxhdGZvcm1zdW5pdH19IGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiVmFsZXVyIGVzdGltw6llXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiTGEgdmFsZXVyIGVzdGltw6llIGVzdCBjYWxjdWzDqWUgc3VyIHVuZSBtb3llbm5lIGRlIDMuNSBqb3VycyBkZSBsYSB2YWxldXIgZHUge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiSGlzdG9yaXF1ZSBkZXMgVHJhbnNhY3Rpb25zXCIsXG5cdFwiUE9TVElOR1wiOiBcIlBvc3RlXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiTGEgY2zDqSBkZSBwb3N0IGVzdCB1dGlsaXPDqWUgcG91ciBwb3N0ZXIgZXQgdm90ZXIuIEVsbGUgZG9pdCDDqnRyZSBkaWZmw6lyZW50ZSBkZXMgY2zDqXMgYWN0aXZlcyBldCBwcm9wcmnDqXRhaXJlcy5cIixcblx0XCJPV05FUlwiOiBcIlByb3ByacOpdGFpcmVcIixcblx0XCJQUk9GSUxFXzZcIjogXCJMYSBjbMOpIHByb3ByacOpdGFpcmUgZXN0IGxhIGNsw6kgcHJpbmNpcGFsZSBkdSBjb21wdGUgZXQgZXN0IHJlcXVpc2UgcG91ciBjaGFuZ2VyIGxlcyBhdXRyZXMgY2zDqXMuIExhIGNsw6kgcHJpdsOpZSBvdSBsZSBtb3QgZGUgcGFzc2UgZGUgbGEgY2zDqSBwcm9wcmnDqXRhaXJlIGRvaXZlbnQgw6p0cmUgbWlzIGhvcnMgbGlnbmUgYXV0YW50IHF1ZSBwb3NzaWJsZS5cIixcblx0XCJQUk9GSUxFXzdcIjogXCJMYSBjbMOpIGFjdGl2ZSBlc3QgdXRpbGlzw6llIHBvdXIgZWZmZWN0dWVyIGRlcyB0cmFuc2ZlcnRzIGV0IHBhc3NlciBkZXMgb3JkcmVzIGRhbnMgbGUgbWFyY2jDqSBpbnTDqXJpZXVyLlwiLFxuXHRcIk1FTU9cIjogXCJNw6ltb1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkxhIGNsw6kgbcOpbW8gcGVybWV0IGRlIGNyw6llciBldCBkZSBsaXJlIGRlcyBtw6ltb3MuXCIsXG5cdFwiUkVQTElFU1wiOiBcIlLDqXBvbnNlc1wiLFxuXHRcIldBTExFVFwiOiBcIlBvcnRlZmV1aWxsZVwiLFxuXHRcIlVTRVJcIjogXCJVdGlsaXNhdGV1clwiLFxuXHRcIkNMT1NFXCI6IFwiRmVybWVyXCIsXG5cdFwiVE9cIjogXCLDoFwiLFxuXHRcIkFTU0VUXCI6IFwiVHlwZVwiLFxuXHRcIlNFTkRcIjogXCJFbnZveWVyXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTw6ljdXJpdMOpXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiRGlzcG9uaWJsZVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTcOpbW8gcHVibGlxdWVcIixcblx0XCJUT19ERVNDXCI6IFwiVXRpbGlzYXRldXIgcGFyIGV4LiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJDb2RlIFBJTlwiLFxuXHRcIlBJTl9URVhUXCI6IFwiTGUgY29kZSBQSU4gdm91cyBhaWRlIMOgIHPDqWN1cmlzZXIgbCdhcHBsaWNhdGlvbiBldCB2b3MgZG9ubsOpZXMuIDxici8+PGJyLz48Yj5Ob3RlOjwvYj4gVW5lIGZvaXMgYWN0aXbDqSwgdm91cyBhdmV6IDQgdGVudGF0aXZlcyBtYXhpbXVtIHBvdXIgZMOpdmVycm91aWxsZXIsIHNpIHZvdXMgYXZleiBvdWJsacOpIGxlIHBpbiBvdSBzaSB2b3VzIMOpY2hvdWV6LCBsJ2FwcGxpY2F0aW9uIHN1cHByaW1lcmEgbGVzIGRvbm7DqWVzIHV0aWxpc2F0ZXVyIGVucmVnaXN0csOpZXMuIFZvdXMgcG91dmV6IHZvdXMgcmVjb25uZWN0ZXIgZXQgY29udGludWVyIMOgIHV0aWxpc2VyIGwnYXBwbGljYXRpb24uXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiVm91cyByZWNldnJleiB1bmUgbm90aWZpY2F0aW9uIHF1YW5kIHF1ZWxxdSd1biB2b3RlcmEgcG91ciB1biBkZXMgdm9zIGNvbnRlbnVzISA8YnIvPiA8Yj5Ob3RlOjwvYj4gTGVzIG5vdGlmaWNhdGlvbnMgaW5jbHVlbnQgbGUgcG9pZHMgZHUgdm90ZSBkYW5zIGxlIG1lc3NhZ2UgZCdhbGVydGUuIChRdSdpbCBzJ2FnaXNzZSBkJ3VuIHVwdm90ZSwgZCcgdW4gZG93bnZvdGUgb3UgZCd1biB2b3RlIHJldGlyw6kpLlwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gY29tbWVudGVyYSB1biBkZXMgdm9zIHBvc3RzIG91IHVuIGRlIHZvcyBjb21tZW50YWlyZXMhPGJyLz4gPGI+Tm90ZTo8L2I+IExlcyBub3RpZmljYXRpb25zIGluY2x1ZW50IHF1YW5kIHF1ZWxxdSd1biA8Yj7DqWRpdGU8L2I+IHNlcyBwcm9wcmVzIGNvbW1lbnRhaXJlcyBhdXNzaS5cIixcblx0XCJDT01NRU5UXCI6IFwiQ29tbWVudGFpcmVcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gcydhYm9ubmVyYSBvdSBzZSBkw6lzYWJvbm5lcmEgZGUgdm91cyFcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiVm91cyByZWNldnJleiB1bmUgbm90aWZpY2F0aW9uIHF1YW5kIHF1ZWxxdSd1biB2b3VzIG1lbnRpb25uZXJhIGRhbnMgdW4gcG9zdC9jb21tZW50YWlyZSFcIixcblx0XCJWT1RJTkdcIjogXCJWb3RlXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJMZSBwb2lkcyBvdSBsZSBwb3VyY2VudGFnZSBkdSB2b3RlIGFmZmVjdGUgbGUgcG91dm9pciBkZSB2b3RlIGRhbnMgbCdhcHBsaWNhdGlvbiwgZGUgdGVsbGUgbWFuacOocmUgdm91cyBwb3V2ZXogcsOpZ2xlciB2b3RyZSByw6ljb21wZW5zZSBkZSB2b3RlLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IENlbGEgY2hhbmdlcmEgbGUgcG9pZHMvcG91cmNlbnRhZ2UgZHUgdm90ZSBwb3VyIGxlIGRvd252b3RlIHBhcnRvdXQgZGFucyBsJ2FwcGxpY2F0aW9uXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmV1clwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVjb21tYW5kw6lcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTYXV2ZWdhcmRlciBsZXMgY2hhbmdlbWVudHNcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZm8gdm90ZVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIkJpZW52ZW51ZSDDoCBub3V2ZWF1IVwiLFxuXHRcIkxPR0lOXzFcIjogXCJDb25uZWN0ZXotdm91cyBhdmVjIHZvdHJlIG5vbSBkJ3V0aWxpc2F0ZXVyIGV0IHZvdHJlIG1vdCBkZSBwYXNzZSBwb3VyIGNvbnRpbnVlci5cIixcblx0XCJMT0dJTl8yXCI6IFwiTGEgY2zDqSBkZSBwb3N0cyBlc3QgdXRpbGlzw6llIHBvdXIgcG9zdGVyLCBjb21tZW50ZXIsIHZvdGVyLCBzdWl2cmUuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkxhIGNsw6kgYWN0aXZlIGVzdCB1dGlsaXPDqWUgcG91ciBsZXMgdHJhbnNmZXJ0cyBldCBsYSBtaXNlIMOgIGpvdXIgZGUgbCdpbWFnZSBkZSBwcm9maWwuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkxlcyBpbmZvcm1hdGlvbnMgZCdpZGVudGlmaWNhdGlvbiBkZSBsJ3V0aWxpc2F0ZXVyIHNvbnQgY29uc2VydsOpZXMgbG9jYWxlbWVudCBzdXIgdm90cmUgYXBwYXJlaWwuIExvcnMgZGUgbGEgZMOpY29ubmV4aW9uIGVsbGVzIHNvbnQgc3VwcHJpbcOpZXMhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiUGFzIGVuY29yZSBkZSBjb21wdGU/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJFbnJlZ2lzdHJlei12b3VzIG1haW50ZW5hbnRcIixcblx0XCJDQU5DRUxcIjogXCJTdXBwcmltZXJcIixcblx0XCJBRFZBTkNFRFwiOiBcIkF2YW5jw6lcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQ2zDqSBwcml2w6llIGFjdGl2ZVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiQ2zDqSBwcml2w6llIGRlIHBvc3RzXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJNb3QgZGUgcGFzc2UgcHJpbmNpcGFsXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJOb20gZCd1dGlsaXNhdGV1clwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIlZ1ZSB0aHVpbGVcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJWdWUgY29tcGFjdGVcIixcblx0XCJTRUFSQ0hcIjogXCJSZWNoZXJjaGVyXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJQcm9wb3NlciB1biBwb3N0XCIsXG5cdFwiUkVQTFlUT1wiOiBcIlLDqXBvbmRyZSDDoFwiLFxuXHRcIlBSRVZJRVdcIjogXCJBcGVyw6d1XCIsXG5cdFwiREVGQVVMVFwiOiBcIlBhciBkw6lmYXV0IDUwJSAvIDUwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiUmVmdXNlciBsZSBwYXllbWVudFwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiU2F1dmVnYXJkZXIgcG91ciBwbHVzIHRhcmRcIixcblx0XCJDTEVBUlwiOiBcIkVmZmFjZXJcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJQb3N0ZXIgbGUgY29udGVudVwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkNvbW1lbnRlclwiLFxuXHRcIlRJVExFXCI6IFwiVGl0cmVcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJQYXMgZGUgY29uY29yZGFuY2VcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZpcm1lciBQSU5cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJPdXZlcnR1cmUgZHUgcG9zdFwiLFxuXHRcIlNFVF9QSU5cIjogXCJDb25maWd1cmVyIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkVudHJlciBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJWb3VzIMOqdGVzIHN1cj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJFcnJldXIgZGUgZGlmZnVzaW9uLCBlc3NheWVyIMOgIG5vdXZlYXUhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlLDqXVzc2l0ZVwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUG9zdCByZWJsb2fDqSFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiRWNoZWMgZGUgbGEgY29ubmV4aW9uISBWZXVpbGxleiB2b3VzIGFzc3VyZXIgZCdhdm9pciBvdXZlcnQgdW5lIHNlc3Npb24gYXZlYyBsZSBtb3QgZGUgcGFzc2UgcHJpbmNpcGFsIG91IHZvdHJlIGNsw6kgcHJpdsOpZSBkZSBwb3N0IHNpIHZvdXMgYXZleiBjaG9pc2kgbGUgbW9kZSBhdmFuY8OpLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIsOJY2hlYyBkZSBsYSBjb25uZXhpb24hIFZldWlsbGV6IHZvdXMgYXNzdXJlciBkJ2F2b2lyIG91dmVydCB1bmUgc2Vzc2lvbiBhdmVjIGxlIG1vdCBkZSBwYXNzZSBwcmluY2lwYWwgb3UgYXZvaXIgZm91cm5pIHVuZSBjbMOpIHByaXbDqWUgYWN0aXZlIGxvcnMgZGUgbGEgY29ubmV4aW9uIHNpIHZvdXMgYXZleiBjaG9pc2kgbGUgbW9kZSBBdmFuY8OpLlwiLFxuXHRcIldBUk5JTkdcIjogXCJBdHRlbnRpb25cIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiVm90ZSBwb3VyIHTDqW1vaW5cIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcImEgdm90w6kgcG91ciB0w6ltb2luXCIsXG5cdFwiQUdPXCI6IFwiZGVwdWlzXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLDoCBwYXJ0aXIgZGUgbWFpbnRlbmFudFwiLFxuXHRcIlNFQ1NcIjogXCJTZWNvbmRlc1wiLFxuXHRcIkFfTUlOXCI6IFwidW5lIG1pblwiLFxuXHRcIkFOX0hPVVJcIjogXCJ1bmUgaGV1cmVcIixcblx0XCJIT1VSU1wiOiBcImhcIixcblx0XCJBX0RBWVwiOiBcInVuIGpvdXJcIixcblx0XCJEQVlTXCI6IFwiam91cnNcIixcblx0XCJBX01PTlRIXCI6IFwidW4gbW9pc1wiLFxuXHRcIk1PTlRIU1wiOiBcIm1vaXNcIixcblx0XCJBX1lFQVJcIjogXCJ1bmUgYW5uw6llXCIsXG5cdFwiWUVBUlNcIjogXCJhbm7DqWVzXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gdGVtcHMgbGVjdHVyZVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJEb3dudm90ZVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIkNhcHR1cmVyIEltYWdlXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJTw6lsZWN0aW9ubmVyIEltYWdlXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJDb25maWd1cmVyIFVSTCBwZXJzb25uYWxpc8OpZVwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5zw6lyZXIgSW1hZ2VcIixcblx0XCJFUlJPUlwiOiBcIkVycmV1clwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkVycmV1ciB0w6lsw6ljaGFyZ2VtZW50XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbcOpcmEgc3VwcHJpbcOpZVwiLFxuXHRcIlNFVF9VUkxcIjogXCJDb25maWd1cmVyIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJMaWVuIGRpcmVjdCBwb3VyIGwnaW1hZ2VcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIkNvbW1lbnRhaXJlIGVudm95w6khXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJMYSBzdXBwcmVzc2lvbiBkZXMgY29tbWVudGFpcmVzIGVzdCBpcnLDqXZlcnNpYmxlLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIkNvbW1lbnRhaXJlIHN1cHByaW3DqVwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiVMOpbMOpY2hhcmdlbWVudCBkZSBsJ2ltYWdlXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlTDqWzDqWNoYXJnZW1lbnQgdGVybWluw6lcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiVMOpbMOpY2hhcmdlbWVudCDDqWNob3XDqVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIk1vdCBkZSBwYXNzZSBvdSBub20gZCd1dGlsaXNhdGV1ciBpbmNvcnJlY3RcIixcblx0XCJRUl9URVhUXCI6IFwiUGxhY2VyIGxlIFFSIGNvZGUgZGFucyBsYSB6b25lIGRlIHNjYW5cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJTb3lleiBzdXIgZCdhdm9pciB1biBzb2xkZSBzdWZmaXNhbnQgcG91ciBsYSB0cmFuc2FjdGlvbiFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiTCd1dGlsaXNhdGV1ciBhdXF1ZWwgdm91cyBlc3NheWV6IGQnZW52b3llciBkZXMgZm9uZHMgbidleGlzdGUgcGFzIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJFdGVzLXZvdXMgc3VyIGRlIHZvdWxvaXIgdHJhbnNmw6lyZXI/XCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJMYSB0cmFuc2FjdGlvbiBlc3QgZGlmZnVzw6llXCIsXG5cdFwiRkVFRFwiOiBcIlN1aXZpc1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVGVuZGFuY2VcIixcblx0XCJORVdcIjogXCJOb3V2ZWF1XCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tdVwiLFxuXHRcIlBBWU9VVFwiOiBcIlBhaWVtZW50XCIsXG5cdFwiQ09NTUVOVFNcIjogXCJDb21tZW50YWlyZXNcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRlbmRhbmNlIGRlcHVpcyAzMCBqb3Vyc1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIkNsYXNzZXIgcG9zdHMgcGFyOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkN5Y2xlIGRlIFBhaWVtZW50XCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBhaWVtZW50IHBvdGVudGllbFwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiUGFpZW1lbnQgcGFzc8OpXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlBhaWVtZW50IGF1dGV1clwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlBhaWVtZW50IHZvdGVzXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJQb3N0IGVudm95w6khXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlNvdW1ldHRyZSBsZSBwb3N0IHBsdXMgdGFyZCFcIixcblx0XCJTQVZFRFwiOiBcIlNhdXZlZ2FyZMOpXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIlN1cHByaW3DqVwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJEb3dudm90ZSB1biBwb3N0IHBldXQgZW5sZXZlciBsZXMgcsOpY29tcGVuc2VzIGV0IHJlbmRyZSBjZWx1aS1jaSBtb2lucyB2aXNpYmxlLjxicj48YnI+TGUgRG93bnZvdGUgZGV2cmFpdCDDqnRyZSB1dGlsaXPDqSBwb3VyIGNlY2k6IDx1bD48bGk+RnJhdWRlIG91IFBsYWdpYXJpc21lPC9saT48bGk+VHJvbGxzIG91IGRpc2NvdXJzIGRlIGhhaW5lPC9saT48bGk+Q29udGVudSBpbmFwcHJvcHJpw6kgaW50ZW50aW9ubmVsIG91IFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTGltaXRlIGF0dGVpbnRlLiBEw6ljb3V2cmV6IGQnYXV0cmVzIHRhZ3MvdGVuZGFuY2VzIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIlBvc3QgZW5sZXbDqSBkZXMgc2lnbmV0cyFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiUG9zdCBham91dMOpIGF1IHNpZ25ldHMhXCIsXG5cdFwiUkVTRVRcIjogXCJSw6lpbml0aWFsaXNlclwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpZXIgbCdpbWFnZSBkdSBwcm9maWxcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmaWVyIGwnaW1hZ2UgZGUgY291dmVydHVyZVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlNWUCwgdmV1aWxsZXogaW5kaXF1ZXIgbGEgY2zDqSBwcml2w6llIGFjdGl2ZSBzaSB2b3VzIGF2ZXogY2hvaXNpIGxlIG1vZGUgZGUgY29ubmV4aW9uIGF2YW5jw6kuXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiQ2VjaSB2YSByw6lpbml0aWFsaXNlciBsJ2ltYWdlIHByb2ZpbCBkZSBsJ3V0aWxpc2F0ZXVyXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiQ2VjaSB2YSByw6lpbml0aWFsaXNlciBsJ2ltYWdlIGRlIGNvdXZlcnR1cmUgZGUgbCd1dGlsaXNhdGV1clwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiTGEgbWlzZSDDoCBqb3VyIGR1IHNlcnZldXIgbsOpY2Vzc2l0ZSB1biByZWTDqW1hcnJhZ2UhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIlBhcmFtw6h0cmVzIG1pcyDDoCBqb3VyIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkxhbmd1ZXNcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIlZvdXMgcG91dmV6IGNoYW5nZXIgaWNpIGxhIGxhbmd1ZSBkZSBsJ2FwcGxpY2F0aW9uXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIkNldHRlIG9ww6lyYXRpb24gcmVxdWllcnQgcXVlIGwndXRpbGlzYXRldXIgc29pdCBjb25uZWN0w6kgYXZlYyBsZSBtb3QgZGUgcGFzc2UgcHJpbmNpcGFsLCBsYSBjbMOpIGRlIHBvc3QvY2zDqSBhY3RpdmUuIFZldWlsbGV6IHZvdXMgY29ubmVjdGVyIGV0IHLDqWVzc2F5ZXIuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGxlcmllXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiQ29udHJpYnV0ZXVycyBkZSB0cmFkdWN0aW9uXCIsXG5cdFwiU0hBUkVcIjogXCJQYXJ0YWdlXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNYXJjaMOpXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJFY2hhbmdlXCIsXG5cdFwiRFJBRlRTXCI6IFwiQnJvdWlsbG9uc1wiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIlBvc3Qgc3VwcHJpbcOpIGRlcyBicm91aWxsb25zIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQb3N0IGFqb3V0w6kgYXV4IGJyb3VpbGxvbnMhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkdsaXNzZXIgdmVycyBsYSBnYXVjaGUgcG91ciB2b2lyIGxlcyBvcHRpb25zXCIsXG5cdFwiTUFOQUdFXCI6IFwiR8OpcmVyXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltYWdlIGVubGV2w6llXCIsXG5cdFwiQ09QWVwiOiBcImNvcGnDqVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiVm91cyBuJ2F2ZXogcGFzIGVuY29yZSB0w6lsw6ljaGFyZ2VyIGQnaW1hZ2VzIHBvdXIgbGUgbW9tZW50IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiVGlyZXogdmVycyBsZSBiYXMgcG91ciByYWZyYcOuY2hpclwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJBcHBzIGV4dGVybmVcIixcblx0XCJTVUdHRVNUXCI6IFwiU3VnZ2VzdGlvblwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiQmllbnTDtHRcIixcblx0XCJDSEFJTl9URVhUXCI6IFwiSWNpIHZvdXMgcG91dmV6IGNoYW5nZXIgcG91ciBsYSBibG9ja2NoYWluIG91IGxhIHBsYXRlLWZvcm1lIHBhciBkw6lmYXV0LlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCLXotee15XXkyDXlNeR15nXqlwiLFxuXHRcIkxPR0lOXCI6IFwi15vXoNeZ16HXlFwiLFxuXHRcIkxPR09VVFwiOiBcIteZ16bXmdeQ15RcIixcblx0XCJQUk9GSUxFXCI6IFwi16TXqNeV16TXmdecXCIsXG5cdFwiRk9MTE9XXCI6IFwi15zXoten15XXkVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIteh15nXnteg15nXldeqXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLXlNei15HXqNeUXCIsXG5cdFwiTUFSS0VUXCI6IFwi16nXldenXCIsXG5cdFwiU0VUVElOR1NcIjogXCLXkNek16nXqNeV15nXldeqXCIsXG5cdFwiQUJPVVRcIjogXCLXnteZ15PXolwiLFxuXHRcIkFCT1VUXzFcIjogXCLXnten15XXnSDXqdeR15Ug15vXnCDXkNeX15Mg15nXm9eV15wg15zXlNeo15XXldeZ15cg15HXlteb15XXqiDXlNeq15vXoNeZ150g16nXnNeVIVwiLFxuXHRcIkFCT1VUXzJcIjogXCLXnteV16TXotecINei15wg15nXk9eZIHt7cGxhdGZvcm1uYW1lfX0uINeU15DXpNeZ15zXp9em15nXlCDXoNeb16rXkdeUINei15wg15nXk9eZXCIsXG5cdFwiQUJPVVRfM1wiOiBcIteV15TXldeQINek16rXldeXLCDXldee15XXoNeiINei15wg15nXk9eZINeU16fXlNeZ15zXlC4g15TXldeQINee16bXmdeiINeS15nXqdeUINec16fXqNeZ15DXlCwg15zXm9eq15nXkdeqINeq15LXldeR15XXqiwg15zXnNeZ15nXp9eZ150sINec15TXoteR16jXqiDXm9eh16TXmdedINeV15vXlScuINeU16TXoteV15zXldeqINee15XXptei15XXqiDXotecINeZ15PXmSDXlNeR15zXlden16Yn15nXmdefINep15wge3twbGF0Zm9ybW5hbWV9fSDXldei15wg15nXk9eZIHt7c2l0ZW5hbWV9fVwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiDXnNeQ16TXnNeZ16fXpteZ15Qg15DXmdefINeS15nXqdeUINec15vXodek15nXnSDXqdecINeU157Xqdeq157XqS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4g15TXkNek15zXmden16bXmdeUINeU15nXkCDXkdeY15XXl9eULCDXm9ep15TXp9eV15Mg15TXpNeo15jXmSDXqdee15XXqCDXnten15XXnteZ16og15XXnNeQINeg16nXnNeXINec16nXqNeq15nXnSDXl9eZ16bXldeg15nXmdedLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiDXlNeQ16TXnNeZ16fXpteZ15Qg157XpteZ16LXlCDXkteZ16nXlCDXpNep15XXmNeUINeV16DXldeX15Qg15zXntep16rXntepLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiDXlNeQ16TXnNeZ16fXpteZ15Qg15zXkCDXnteR16fXqdeqINee157Xqdeq157XqdeZ150g157XmdeT16Ig16TXqNeY15kuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIteU16bXkdeZ16LXlSDXnC1nb29kLWthcm1hINeR16rXldeoINei15NcIixcblx0XCJBQk9VVF85XCI6IFwi16bXldeoINen16nXqFwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi157XmdeT16Ig16DXldeh16M6XCIsXG5cdFwiUkVNT1ZFXCI6IFwi15TXodeo15RcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcItem16TXlCDXkdep15XXp1wiLFxuXHRcIlBSSUNFXCI6IFwi157Xl9eZ16hcIixcblx0XCJBTU9VTlRcIjogXCLXm9ee15XXqlwiLFxuXHRcIlRPVEFMXCI6IFwi16HXmiDXlNeb15xcIixcblx0XCJOT09SREVSU1wiOiBcIteQ15nXnyDXlNeW157XoNeV16og16TXqteV15fXldeqINei15HXldeoXCIsXG5cdFwiREFURVwiOiBcIteq15DXqNeZ15pcIixcblx0XCJCVVlcIjogXCLXp9eg15nXmdeUXCIsXG5cdFwiU0VMTFwiOiBcItee15vXmdeo15RcIixcblx0XCJPUEVOXCI6IFwi16TXqteZ15fXlFwiLFxuXHRcIkhJU1RPUllcIjogXCLXlNeZ16HXmNeV16jXmdeUXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLXnNei16fXldeRXCIsXG5cdFwiRk9MTE9XRURcIjogXCLXoteV16fXkVwiLFxuXHRcIlVORk9MTE9XXCI6IFwi15zXlNek16HXmdenINec16LXp9eV15FcIixcblx0XCJGT0xMT1dJTkdcIjogXCLXoteV16fXkVwiLFxuXHRcIkZPTExPV0VSU1wiOiBcItei15XXp9eR15nXnVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLXl9eZ16TXldepINeR16LXlden15HXmdedINeQ15fXqNeZ15lcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwi15fXmdek15XXqSDXkdee15kg16nXkNeg15kg16LXlden15Eg15DXl9eo15nXlVwiLFxuXHRcIkJZXCI6IFwi16LXnCDXmdeT15lcIixcblx0XCJJTlwiOiBcIteR16rXldeaXCIsXG5cdFwiTUVOVVwiOiBcIteq16TXqNeZ15hcIixcblx0XCJCT09LTUFSS1wiOiBcIteh15nXnteg15nXlFwiLFxuXHRcIlJFQkxPR1wiOiBcItei16nXlSDXqNeZ15HXnNeV15JcIixcblx0XCJVUFZPVEVcIjogXCLXnNeZ15nXp1wiLFxuXHRcIkRPV05WT1RFXCI6IFwi15DXoNec15nXmdenXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIteR15nXmNeV15wg15DXoNec15nXmdenXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLXkdeZ15jXldecINec15nXmdenXCIsXG5cdFwiUkVQTFlcIjogXCLXnNeU16nXmdeRXCIsXG5cdFwiRURJVFwiOiBcItei16jXmdeb15RcIixcblx0XCJQT1NUXzFcIjogXCLXlNeX15zXpyDXkNeqINeU16rXkteV15Qg16nXnteQ15zXlCDXnNem16TXmdeZ15Qg15HXkNek16nXqNeV15nXldeqXCIsXG5cdFwiUE9TVF8yXCI6IFwi15zXl9elINei15wg16rXkteV15HXlCDXm9eT15kg15zXqNeQ15XXqiDXqteq15kt16rXkteV15HXldeqXCIsXG5cdFwiT1BUSU9OU1wiOiBcIteQ16TXqdeo15XXmdeV16pcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLXotep15Ug16jXmdeh15jXmdedXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwi15DXmdefINek15Qg15vXnNeV150g16LXk9eZ15nXny4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwi15vXodek15nXnVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sINee15jXkdei15XXqiDXqdeg15nXqteg15nXnSDXnNeU16LXkdeo15Qg15HXm9ecINei16ouINeg15nXqtefINec15TXnteZ16gge3twbGF0Zm9ybW5hbWV9fSDXnC17e3BsYXRmb3JtcG93ZXJ9fSDXkdei15bXqNeqINeq15TXnNeZ15og16nXoNen16jXkCDXpNeQ15XXldeoLdeQ16QuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sINee15jXkdei15XXqiDXlNep16TXoteUINep157Xldeh15nXpNeZ150g15zXm9edINeb15XXlyDXkdeU16bXkdei15QuINeb15vXnCDXqdeZ16kg15zXm9edINeZ15XXqteoLCDXqteV15vXnNeZINec15TXqdek15nXoiDXmdeV16rXqCDXotecINeU16rXqdec15XXnSDXqdecINek15XXodeY15nXnSDXldeq15XXm9ec15Ug15zXlNeo15XXldeZ15cg16jXldeV15fXmdedINeS15PXldec15nXnSDXmdeV16rXqCDXkdeU16bXkdei15QuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwi157XmNeR16LXldeqINep16nXldeZ15nXnSB7e3BsYXRmb3Jtc3VuaXR9fSDXqdecIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi16LXqNeaINee15XXoteo15pcIixcblx0XCJQUk9GSUxFXzRcIjogXCLXlNei16jXmiDXl9eV16nXkSDXotecINeZ15PXmSDXntee15XXpteiINee15fXmdeo15nXnSDXkS03INeU15nXnteZ150g15TXkNeX16jXldeg15nXnSDXqdecIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIteU15nXodeY15XXqNeZ15nXqiDXpNei15XXnNeV16pcIixcblx0XCJQT1NUSU5HXCI6IFwi15TXotec15DXqiDXpNeV16HXmFwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcItee16TXqteXINeU16TXldeh15jXmdedINeg15XXoteTINec15vXqteZ15HXqiDXpNeV16HXmNeZ150g15XXnNec15nXmden15nXnS4g16LXnNeZ15Ug15zXlNeZ15XXqiDXqdeV16DXlCDXnteU157XpNeq15cg15TXpNei15nXnCDXldee157XpNeq15cg15TXntep16rXntepLlwiLFxuXHRcIk9XTkVSXCI6IFwi15HXotec15nXnVwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcItee16TXqteXINeU157Xqdeq157XqSDXlNeV15Ag15TXntek16rXlyDXlNeo15DXqdeZINec15fXqdeR15XXnyDXldeU15XXkCDXoNeX15XXpSDXotecINee16DXqiDXnNep16DXldeqINee16TXqteX15XXqiDXkNeX16jXmdedLiDXlNee16TXqteXINeU16TXqNeY15kg15DXlSDXlNeh15nXodee15Ag15zXp9eR15zXqiDXntek16rXlyDXlNee16nXqtee16kg15fXmdeZ15HXmdedINec15TXmdeV16og16nXnteV16jXmdedINee15fXldelINec15DXqteoLlwiLFxuXHRcIkFDVElWRVwiOiBcItek16LXmdecXCIsXG5cdFwiUFJPRklMRV83XCI6IFwi15TXntek16rXlyDXlNek16LXmdecINeg15XXoteTINec15HXmdem15XXoiDXlNeR16jXldeqINeb16HXpNeZ150g15XXnNeR15nXpteV16Ig15TXltee16DXldeqINeR16nXldenINeU16TXoNeZ157XmS5cIixcblx0XCJNRU1PXCI6IFwi15TXoteo15RcIixcblx0XCJQUk9GSUxFXzhcIjogXCLXntek16rXlyDXlNeq15bXmdeb15nXqNedINeg15XXoteTINec15vXqteZ15HXqiDXlden16jXmdeQ16og16rXlteb15nXqNeZ150uXCIsXG5cdFwiQkxPR1wiOiBcIteR15zXldeSXCIsXG5cdFwiUE9TVFNcIjogXCLXpNeV16HXmNeZ151cIixcblx0XCJSRVBMSUVTXCI6IFwi16rXkteV15HXldeqXCIsXG5cdFwiV0FMTEVUXCI6IFwi15DXqNeg16dcIixcblx0XCJUQUdcIjogXCLXmNeQ15LXmdedXCIsXG5cdFwiVVNFUlwiOiBcItee16nXqtee16lcIixcblx0XCJDTE9TRVwiOiBcIteh15LXldeoXCIsXG5cdFwiVE9cIjogXCLXkNecXCIsXG5cdFwiQVNTRVRcIjogXCLXoNeb16FcIixcblx0XCJTRU5EXCI6IFwi15zXqdec15XXl1wiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi15HXmNeZ15fXldeqXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi16TXoNeV15lcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIteU16LXqNeUINek15XXnteR15nXqlwiLFxuXHRcIlRPX0RFU0NcIjogXCLXntep16rXntepLCDXnNeT15XXktee15AgZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwi16fXldeTXCIsXG5cdFwiUElOX1RFWFRcIjogXCLXp9eV15Mg16LXldeW16gg15zXm9edINec15DXkdeY15cg15DXqiDXlNeQ16TXmdec16fXpteZ15Qg15XXkNeqINeU157XmdeT16Ig16nXnNeb150uINeU16LXqNeUOiDXkdeo15LXoiDXqdeU15XXpNei15wsINeQ16TXqdeoINec16DXodeV16og15zXpNeq15XXlyDXoteTIDQg16TXotee15nXnS4g15DXnSDXqdeb15fXqtedINeQ16og15TXp9eV15MsINeU15DXpNec15nXp9em15nXlCDXqtee15fXpyDXkNeqINeU157XmdeT16Ig16nXnCDXlNee16nXqtee16kuINeq15XXm9ecINec15TXmdeb16DXoSDXnteX15PXqSDXldec15TXqdeq157XqSDXkdeQ16TXnNeZ16fXpteZ15QuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIteU15XXk9ei15XXqlwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIteq16fXkdeV15wg15TXldeT16LXlCDXm9ep157Xmdep15TXlSDXmdei16nXlCDXnNeb150g15zXmdeZ16chINeU16LXqNeUOiDXlNeU15XXk9ei15XXqiDXmdeb15zXnNeVINeS150g15DXqiDXntep16fXnCDXlNec15nXmdenICjXkdeZ158g15DXnSDXnNeZ15nXpywg15DXoNec15nXmdenLCDXkNeVINeR15nXmNeV15wg15zXmdeZ16cpLlwiLFxuXHRcIlZPVEVcIjogXCLXnNeU16bXkdeZ16JcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCLXqten15HXnNeVINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXkteZ15Eg15zXpNeV16HXmNeZ150g15DXlSDXnNeq15LXldeR15XXqiDXqdec15vXnSEg15TXoteo15Q6INeq16fXkdec15Ug15TXldeT16LXlCDXktedINeb16nXnteZ16nXlNeVINeZ16LXqNeV15og15DXqiDXlNeq15LXldeR15Qg16nXnNeVLlwiLFxuXHRcIkNPTU1FTlRcIjogXCLXqteS15XXkdeUXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLXqten15HXnCDXlNeV15PXoteUINeb16nXnteZ16nXlNeVINeZ16LXp9eV15Eg15DXlSDXmdek16HXmdenINec16LXp9eV15Eg15DXl9eo15nXmiFcIixcblx0XCJNRU5USU9OU1wiOiBcIteq15bXm9eV16jXmdedXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIteq16fXkdecINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXlteb15nXqCDXkNeV16rXmiDXkdek15XXodeYINeQ15Ug15HXqteS15XXkdeUIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLXotep15Ug16jXmdeR15zXldeSXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwi16rXp9eR15zXlSDXlNeV15PXoteUINeb16nXnteZ16nXlNeVINeZ16LXqdeUINeo15nXodeY15nXnSDXnNek15XXodeYINep15zXm9edIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi16fXldeg16TXmdeS15XXqNem15nXldeqXCIsXG5cdFwiVk9USU5HXCI6IFwi15TXpteR16LXldeqXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLXntep16fXnCDXlNec15nXmdenINeg15XXqtefINec15vXnSDXnNep15zXldeYINeR15LXldeT15wg15TXktee15XXnCDXqdeq16fXkdec15UuINeU16LXqNeUOiDXpNei15XXnNeUINeW15Ug16rXqdeg15Qg15LXnSDXkNeqINeU157Xqden15wg16LXkdeV16gg15DXoNec15nXmdenXCIsXG5cdFwiU0VSVkVSXCI6IFwi16nXqNeqXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLXnteV157XnNelXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwi15zXqdee15XXqCDXqdeZ16DXldeZ15nXnVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwi157XmdeT16Ig16LXnCDXntem15HXmdei15nXnVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIteR16jXldeb15nXnSDXlNep15HXmdedIVwiLFxuXHRcIkxPR0lOXzFcIjogXCLXlNeZ15vXoNeh15Ug15HXoteW16jXqiDXqdedINeU157Xqdeq157XqSDXldeU16HXmdeh157XkCDXotecINee16DXqiDXnNeU157XqdeZ15ouXCIsXG5cdFwiTE9HSU5fMlwiOiBcItee16TXqteXINeU16TXldeh15jXmdedINeg15XXoteTINec15vXqteZ15HXqiDXpNeV16HXmNeZ150g15XXqteS15XXkdeV16osINeV15zXnNeZ15nXp9eZ150uXCIsXG5cdFwiTE9HSU5fM1wiOiBcIteU157XpNeq15cg15TXpNei15nXnCDXoNeV16LXkyDXnNeU16LXkdeo15XXqiDXldec16LXk9eb15XXnyDXqtee15XXoNeqINeU16TXqNeV16TXmdecLlwiLFxuXHRcIkxPR0lOXzRcIjogXCLXlNee15nXk9eiINei15wg15TXntep16rXntepINep157XldeoINee16fXldee15nXqiDXotecINeU157Xm9ep15nXqC4g15vXqdee16rXoNeq16fXmdedINeU157XmdeT16Ig16DXnteX16chXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi15DXmdefINec15vXnSDXl9ep15HXldefINee16nXqtee16k/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCLXlNeo16nXnteVINei15vXqdeZ15VcIixcblx0XCJDQU5DRUxcIjogXCLXkdeZ15jXldecXCIsXG5cdFwiQURWQU5DRURcIjogXCLXnteq16fXk9edXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcItee16TXqteXINek16LXmdecXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCLXntek16rXlyDXpNeV16HXmNeZ151cIixcblx0XCJNQVNURVJfUEFTU1wiOiBcItee16TXqteXINeo15DXqdeZXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLXqdedINee16nXqtee16lcIixcblx0XCJDQVJEX1ZJRVdcIjogXCLXqtem15XXkteqINeb16jXmNeZ16HXmdedXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwi16rXpteV15LXlCDXp9eV157XpNen15jXmdeqXCIsXG5cdFwiU0VBUkNIXCI6IFwi15fXmdek15XXqVwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi15vXqteR15Ug16TXldeh15hcIixcblx0XCJSRVBMWVRPXCI6IFwi15TXqdeZ15HXlSDXnC1cIixcblx0XCJQT1NUXCI6IFwi16TXldeh15hcIixcblx0XCJQUkVWSUVXXCI6IFwi16rXpteV15LXlCDXnten15PXmdee15RcIixcblx0XCJERUZBVUxUXCI6IFwi15HXqNeZ16jXqiDXnteX15PXmiA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwi16TXkNeV15XXqC3XkNekIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIteh16jXkdeVINec16rXqdec15XXnVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi16nXnteo15Ug15zXnteQ15XXl9eoINeZ15XXqteoXCIsXG5cdFwiQ0xFQVJcIjogXCLXoNeZ16fXldeZXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi16rXldeb158g15TXpNeV16HXmFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIteq15XXm9efINeU16rXkteV15HXlFwiLFxuXHRcIlRJVExFXCI6IFwi15vXldeq16jXqlwiLFxuXHRcIlRBR1NcIjogXCLXmNeQ15LXmdedXCIsXG5cdFwiTk9UX01BVENIXCI6IFwi15zXkCDXnteq15DXmdedXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCLXkNep16gg16fXldeTXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi16nXkteV15lcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLXpNeV16rXlyDXpNeV16HXmFwiLFxuXHRcIlNFVF9QSU5cIjogXCLXp9eR16LXlSDXp9eV15NcIixcblx0XCJFTlRFUl9QSU5cIjogXCLXlNeW15nXoNeVINen15XXk1wiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIteR15jXldeX15nXnT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIteQ15kg15DXpNep16gg15zXkdeY15wg16jXmdeh15jXmdedLCDXqteo16bXlSDXnNeU157XqdeZ15o/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwi15HXoteZ15nXqiDXqten16nXldeo16osINeg16HXlCDXqdeV15EhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIteU16bXnNeX15RcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcItei16nXmdeq150g15zXpNeV16HXmCDXqNeZ15HXnNeV15IhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIteU15vXoNeZ16HXlCDXoNeb16nXnNeUISDXkNeg15Ag15XXk9eQ15Ug16nXoNeb16DXodeq150g16LXnSDXlNeh15nXodee15Ag15TXqNeQ16nXmdeqINeQ15Ug16nXlNeW16DXqtedINeQ16og157XpNeq15cg15TXpNeV16HXmNeZ150g15DXnSDXoNeZ16HXmdeq150g15zXlNeZ15vXoNehINeR157XpteRINee16rXp9eT157Xqi5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLXlNeb16DXmdeh15Qg16DXm9ep15zXlCEg15DXoNeQINeV15PXkNeVINep16DXm9eg16HXqtedINei150g15TXodeZ16HXnteQINeU16jXkNep15nXqiDXkNeVINep15TXlteg16rXnSDXkNeqINeU157XpNeq15cg15TXpNei15nXnCDXkNedINeg15nXodeZ16rXnSDXnNeU15nXm9eg16Eg15HXntem15Eg157Xqten15PXnteqLlwiLFxuXHRcIldBUk5JTkdcIjogXCLXkNeW15TXqNeUXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIteU16bXkdei15Qg15zXoteTXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCLXlNem15HXoteUINec16LXkyDXkdeV16bXoteUXCIsXG5cdFwiQUdPXCI6IFwi15zXpNeg15lcIixcblx0XCJGUk9NX05PV1wiOiBcItee16LXm9ep15nXlVwiLFxuXHRcIlNFQ1NcIjogXCLXqdeg15nXldeqXCIsXG5cdFwiQV9NSU5cIjogXCLXk9en15RcIixcblx0XCJNSU5TXCI6IFwi15PXp9eV16pcIixcblx0XCJBTl9IT1VSXCI6IFwi16nXoteUXCIsXG5cdFwiSE9VUlNcIjogXCLXqdei15XXqlwiLFxuXHRcIkFfREFZXCI6IFwi15nXldedXCIsXG5cdFwiREFZU1wiOiBcIteZ157XmdedXCIsXG5cdFwiQV9NT05USFwiOiBcIteX15XXk9epXCIsXG5cdFwiTU9OVEhTXCI6IFwi15fXldeT16nXmdedXCIsXG5cdFwiQV9ZRUFSXCI6IFwi16nXoNeUXCIsXG5cdFwiWUVBUlNcIjogXCLXqdeg15nXnVwiLFxuXHRcIk1JTl9SRUFEXCI6IFwi15PXp9eV16og16fXqNeZ15DXlFwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCLXotep15Ug15DXoNec15nXmdenXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi16bXnNee15Ug16rXnteV16DXlFwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwi15HXl9eoINeq157Xldeg15RcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIten15HXoteVINeb16rXldeR16og15DXmdep15nXqlwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwi15TXm9eg16HXlCDXqtee15XXoNeUXCIsXG5cdFwiRVJST1JcIjogXCLXqdeS15nXkNeUXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi16nXkteZ15DXlCDXkdeU16LXnNeQ15RcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi157Xptec157XlCDXkdeV15jXnNeUXCIsXG5cdFwiU0VUX1VSTFwiOiBcIten15HXoteVINen15nXqdeV16hcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi16fXmdep15XXqCDXnNeq157Xldeg15RcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIteU16rXkteV15HXlCDXoNep15zXl9eUIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi15DXmSDXkNek16nXqCDXnNep15fXlteoINeq15LXldeR15Qg16nXoNee15fXp9eULi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi16rXkteV15HXlCDXoNee15fXp9eUXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLXntei15zXlCDXqtee15XXoNeUXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIteq157Xldeg15Qg15TXldei15zXqteUXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIteU16LXnNeQ15Qg16DXm9ep15zXlFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIteU16HXmdeh157XlCDXkNeVINep150g15TXnteq16nXntepINep15LXldeZ15nXnVwiLFxuXHRcIklORk9cIjogXCLXnteZ15PXolwiLFxuXHRcIlFSX1RFWFRcIjogXCLXqdeZ157XlSDXp9eV15MgUVIg15HXqteV15og15DXlteV16gg15TXp9eo15nXkNeUXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi15HXk9en15Ug16nXmdepINec15vXnSDXnteh16TXmdenINeb16HXpNeZ150g15zXlNei15HXqNeUIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLXlNee16nXqtee16kg16nXkNec15nXlSDXoNeZ16HXmdeq150g15zXlNei15HXmdeoINeb16HXpNeZ150g15zXkCDXp9eZ15nXnSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwi15HXmNeV15cg16nXqteo16bXlSDXnNeU16LXkdeZ16gg15DXqiDXlNeb16HXpNeZ150/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwi15DXmdep15XXqFwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi15TXpNei15XXnNeUINeg16nXnNeX15RcIixcblx0XCJGRUVEXCI6IFwi16TXmdeTXCIsXG5cdFwiVFJFTkRJTkdcIjogXCLXntem15zXmdeXXCIsXG5cdFwiSE9UXCI6IFwi15fXnVwiLFxuXHRcIk5FV1wiOiBcIteX15PXqVwiLFxuXHRcIlBST01PVEVEXCI6IFwi157Xp9eV15PXnteZ151cIixcblx0XCJWT1RFU1wiOiBcItec15nXmden15nXnVwiLFxuXHRcIlBBWU9VVFwiOiBcIteq16nXnNeV151cIixcblx0XCJDT01NRU5UU1wiOiBcIteq15LXldeR15XXqlwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwi15fXnteZ150g15EtMzAg15TXmdee15nXnSDXlNeQ15fXqNeV16DXmdedXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi157XmdeZ16DXlSDXnNek15k6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi15bXntefINeq16nXnNeV151cIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi16rXqdec15XXnSDXoteq15nXk9eZXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLXqtep15zXldedINei15HXqFwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLXqtep15zXldedINec15vXldeq15FcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLXqtep15zXldedINec157XqdeS15nXl9eZ151cIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIteU16TXldeh15gg16DXqdec15chXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcItec16nXnNeV15cg157XkNeV15fXqCDXmdeV16rXqFwiLFxuXHRcIlNBVkVEXCI6IFwi16DXqdee16hcIixcblx0XCJDTEVBUkVEXCI6IFwi16DXlden15RcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwi15DXoNec15nXmdenINec16TXldeh15gg157Xl9eh15nXqCDXnteU16rXqdec15XXnSDXldeU15XXpNeaINeQ15XXqteVINec16TXl9eV16og16DXqNeQ15QuINeQ16DXnNeZ15nXpyDXnteZ15XXoteTINec157Xp9eo15nXnSDXlNeR15DXmdedOiDXlNei16rXp9eULCDXkteW16LXoNeV16osINeT15HXqNeZINep16DXkNeULCDXmNeo15XXnNeZ16DXkiwg16HXpNeQ151cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCLXlNeS16LXqtedINec15LXkdeV15wg157Xodek16gg15TXkden16nXldeqLiDXkdeT16fXlSDXmNeQ15LXmdedINeQ15fXqNeZ150hXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi15TXpNeV16HXmCDXlNeV16HXqCDXnteU16HXmdee16DXmdeV16ohXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIteU16TXldeh15gg16DXqdee16gg15HXodeZ157XoNeZ15XXqiFcIixcblx0XCJSRVNFVFwiOiBcIteQ15nXqteX15XXnFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi15zXqdeg15XXqiDXqtee15XXoNeqINek16jXldek15nXnFwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwi15zXqdeg15XXqiDXqtee15XXoNeqINeb15XXqteo16pcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCLXkNeg15Ag15TXldeh15nXpNeVINee16TXqteXINek16LXmdecINeQ150g16rXqNem15Ug15zXlNeZ15vXoNehINec157XpteRINee16rXp9eT150hXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwi16rXnteV16DXqiDXlNek16jXldek15nXnCDXqteQ15XXqteX15xcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCLXqtee15XXoNeqINeU15vXldeq16jXqiDXqteQ15XXqteX15xcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcItei15PXm9eV158g15TXqdeo16og15PXldeo16kg15DXqteX15XXnCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi15TXlNeS15PXqNeV16og16LXldeT15vXoNeVIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcItep16TXldeqXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLXm9eQ158g16DXmdeq158g15zXqdeg15XXqiDXkNeqINeU16nXpNeULlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLXpNei15XXnNeUINeW15Ug15PXldeo16nXqiDXnteU157Xqdeq157XqSDXnNeU15nXldeqINeo16nXldedINei150g15TXodeZ16HXnteQINeU16jXkNep15nXqiDXldeU157XpNeq15cg15TXpNei15nXnCDXkNeVINee16TXqteXINeU16TXodeV15guINeQ16DXkCDXm9eg16HXlSDXldeg16HXlSDXqdeg15nXqi5cIixcblx0XCJHQUxMRVJZXCI6IFwi15LXnNeo15nXlFwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcItee16rXqNeS157XmdedXCIsXG5cdFwiU0hBUkVcIjogXCLXqdeq16NcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIteU16nXldenXCIsXG5cdFwiRVhDSEFOR0VcIjogXCLXnteh15fXqFwiLFxuXHRcIkRSQUZUU1wiOiBcIteY15nXldeY15XXqlwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIteU16TXldeh15gg15TXldeh16gg157XlNeY15nXldeY15XXqiFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi15TXpNeV16HXmCDXlNeq15XXldeh16Mg15zXmNeZ15XXmNeV16ohXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIteU15fXnNeZ16fXlSDXqdee15DXnNeUINeR16nXkdeZ15wg15DXpNep16jXldeZ15XXqlwiLFxuXHRcIk1BTkFHRVwiOiBcIteg15nXlNeV15xcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwi15TXqtee15XXoNeUINeU15XXodeo15RcIixcblx0XCJDT1BZXCI6IFwi15TXoteq16dcIixcblx0XCJOT19JTUFHRVwiOiBcItei15XXkyDXnNeQINeU16LXnNeZ16og16rXnteV16DXlCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcItee16nXm9eVINec157XmNeUINeb15PXmSDXnNeo16LXoNefXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIteZ15nXqdeV157XmdedINeX15nXpteV16DXmdeZ151cIixcblx0XCJQTFVHSU5TXCI6IFwi16rXldeh16TXldeqXCIsXG5cdFwiU1VHR0VTVFwiOiBcIteU16bXoiDXnNen16jXmdeQ15RcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIteR16fXqNeV15FcIixcblx0XCJDSEFJTlwiOiBcItep16jXqdeo16pcIixcblx0XCJDSEFJTl9URVhUXCI6IFwi15vXkNefINeq15XXm9ec15Ug15zXqdeg15XXqiDXkdec15XXp9emJ9eZ15nXnyDXkNeVINeQ16og15HXqNeZ16jXqiDXlNee15fXk9ecXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLXnteY15HXolwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCLXm9eQ158g16rXldeb15zXlSDXnNep16DXldeqINeQ16og157XmNeR16Ig15HXqNeZ16jXqiDXlNee15fXk9ecINep15zXm9edLiDXlNep15XXldeZINep15wg16TXldeh15hcXFxc16rXkteV15HXlCDXmdeV16TXmdeiINeR157XmNeR16Ig15bXlC5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj7XqNep15nXnteqINep15nXnteV16nXmdedINeR16TXnNeY16TXldeo157XlDwvYj4gPGJyPi3XkteZ16nXlCDXnNee15DXnteo15nXnSDXmdeX15XXk9eZ15nXnSDXkdeb15wg16DXldep15Ag16nXqteU15nXlSDXntei15XXoNeZ15nXoNeZ150g15zXp9eo15XXkC4gPGJyPiAt15TXqteX15HXqNeVINec15vXldeq15HXmdedINeT16jXmiDXqteS15XXkdeV16og15XXk9eZ15XXoNeZ150uIDxicj4t15TXpteR16LXlCDXoteR15XXqCDXpNeV16HXmNeZ150g15zXlNei16DXp9eqINeS157XldecLCDXldeU16jXldeV15fXqiDXktee15XXnCDXoteR15XXqCDXlNem15HXoteV16ouIDxicj4t16TXqNeh157XlSDXnteQ157XqNeZ150g15XXpNeV16HXmNeZ150sINeU16jXldeV15nXl9eVINeq15LXnteV15zXmdedINeV157XpteQ15Ug15DXoNep15nXnSDXqdeZ16LXp9eR15Ug15DXl9eo15kg15TXkdec15XXkiDXqdec15vXnS4gPGJyPi3Xm9eq15nXkdeqINee15DXnteo15nXnSDXk9eZ16DXnteZ16osINep157Xmdeo16og16fXkdeV16og16nXnCDXlNek15XXodeYINec16TXqNeh15XXnSDXnteQ15XXl9eoINeZ15XXqteoLiA8YnI+LSDXqdee16jXlSDXnteQ157XqNeZ150g15zXp9eo15nXkNeUINeR157Xldei15Mg157XkNeV15fXqCDXmdeV16rXqC4gPGJyPi0g16TXk9eVINeQ16og15TXqNeV15XXl9eZ150g16nXnNeb150uIDxicj4t16nXnNeX15Ug15vXodek15nXnSDXnNeX15HXqNeZ150g15DXlSDXnNee16nXqtee16nXmdedINeQ15fXqNeZ150gPGJyPi0g16LXp9eR15Ug15DXl9eo15kg16HXldek16jXmdedINeV15HXnNeV15LXqNeZ150g157Xoteg15nXmdeg15nXnS4gPGJyPiAt15fXmdek15XXqSDXkdei15XXp9eR15nXnSDXqdec15vXnSDXldeR157XmSDXqdei15XXp9eRINeQ15fXqNeZ15vXnS4gPGJyPi3Xp9eR15zXlSDXlNeV15PXoteV16og16LXnCDXnteg16og15zXlNeZ16nXkNeoINeR16LXoNeZ15nXoNeZ150g16LXnSDXoteV16fXkdeZ150g15XXotedINeV15PXmdeV16DXmdedINep15DXqtedINee16LXqNeV15HXmdedINeR15TXnS4gPGJyPi3Xl9eZ16TXldepINeq15LXmdeV16ov16fXmNeS15XXqNeZ15XXqiDXntei16DXmdeZ16DXldeqINep15wg157XkNee16jXmdedINeV15vXldeq15HXmdedLiA8YnI+IC3XlNeq15DXnteUINeQ15nXqdeZ16og16nXnCDXlNek16jXldek15nXnCDXqdec15ouIDxicj4t16LXldeTINeU16jXkdeUINek15XXoNen16bXmdeV16og15HXk9eo15ouIDxicj48YnI+PGI+15DXkdeY15fXlDwvYj4gPGJyPjEuINec15DXpNec15nXp9em15nXlCDXkNeZ158g15LXmdep15Qg15zXm9eh16TXmSDXlNee16nXqtee16kuIDxicj4yLiDXlNeQ16TXnNeZ16fXpteZ15Qg157XpteZ16LXlCDXnteV15PXnCDXkNeR15jXl9eUINeR16bXkyDXlNec16fXldeXLCDXotedINee16TXqteX15XXqiDXpNeo15jXmdeZ150g15TXqdee15XXqNeZ150g15HXkNeV16TXnyDXnten15XXnteZINeV16nXkNeZ16DXnSDXoNep15zXl9eZ150g15zXqdeo16rXmdedLCDXkNeq150g15DXl9eo15DXmdedINec15LXmdeR15XXmSDXlNeh15nXodee15DXldeqINep15zXm9edLiA8YnI+My4g15TXkNek15zXmden16bXmdeUINee16bXmdei15Qg157Xntep16cg15XXl9eV15XXmdeUINeQ15jXqNen15jXmdeR15nXqiDXnNee16nXqtee16kgPGJyPjQuINeU15DXpNec15nXp9em15nXlCDXntem15nXoteUINep15vXkdeUINeg15XXodek16og16nXnCDXkdeZ15jXl9eV158g16LXnSDXp9eV15MgPGJyPjxicj4gZVN0ZWVtINeq15XXnteaINeR16TXnNeY16TXldeo157XldeqIFN0ZWVtINeVLUdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcItee15nXmdeh15Mg15XXntek16rXlyDXqNeQ16nXmVwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwi15TXldeh16Mg157Xqdeq157XqVwiLFxuXHRcIlBMQVRGT1JNXCI6IFwi16TXnNeY16TXldeo157XlFwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJQb8SNZXRuYSBzdHJhbmljYVwiLFxuXHRcIkxPR0lOXCI6IFwiUHJpamF2YVwiLFxuXHRcIkxPR09VVFwiOiBcIk9kamF2YVwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJQcmF0aVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIk96bmFrZVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiUHJpamVub3NcIixcblx0XCJNQVJLRVRcIjogXCJUcmdvdmluYVwiLFxuXHRcIlNFVFRJTkdTXCI6IFwiUG9zdGF2a2VcIixcblx0XCJBQk9VVFwiOiBcIk8gYXBsaWthY2lqaVwiLFxuXHRcIkFCT1VUXzFcIjogXCJnZGplIHN2YXRrbyBtb8W+ZSB6YXJhZGl0aSBuYWdyYWRlIHphIHN2b2ogc2FkcsW+YWohXCIsXG5cdFwiQUJPVVRfMlwiOiBcImplIGRydcWhdHZlbmEgYXBsaWthY2lqYSBnZGplIHNpIHBsYcSHZW4gemEgYmxvZ2FuamUsIGtvbWVudGlyYW5qZSBpIGt1cmFjaWplLlwiLFxuXHRcIkFCT1VUXzNcIjogXCJpIG9uYSBqZSBvdHZvcmVub2ctaXp2b3JhLCB6YWplZG5pY2EgcG9rcmXEh2UgbW9iaWxuaSBwcm9qZWt0LiBOdWRpIHNhZHLFvmFqIGtvamkgamUgZG9zdHVwYW4gemEgxI1pdGFuamUsIGtvbWVudGlyYW5qZSwgZ2xhc2FuamUsIG9iamF2bGppdmFuamUsIHByaWplbm9zIHphcmFkZSBpIGRydWdlIHBvZ29kbm9zdGkga29qZSBuYW0gbnVkaSB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gaSB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIkFwbGlrYWNpamEgbmlrYWQgbmUgcHJpc3R1cGEgaWxpIHphZHLFvmF2YSBrb3Jpc25pxI1rYSBzcmVkc3R2YS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQXBsaWthY2lqYSBudWRpIHNpZ3Vybm9zbmkgbW9kZWwgbmEgc3RyYW5pIGtsaWplbnRhLiBQcml2YXRuaSBrbGp1xI1ldmkgc3Ugc3ByZW1lbGphbmkgbG9rYWxubyBpIG5pa2FkIHNlIG5lIMWhYWxqdSBuYSBzZXJ2ZXJlLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBcGxpa2FjaWphIG51ZGkgamVkbm9zdGF2bm8sIGF0cmFrdGl2bm8ga29yaXNuacSNa28gc3XEjWVsamUgaSBkb8W+aXZsamFqLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBBcGxpa2FjaWphIG5pa2FkIG5lIHphaHRqZXZhIG9kIGtvcmlzbmlrYSBkYSB1bm9zaSBwcml2YXRuZSBpbmZvcm1hY2lqZS5cIixcblx0XCJBQk9VVF84XCI6IFwiR2xhc2FqIHphIGdvb2Qta2FybWEga2FvIHN2amVkb2thXCIsXG5cdFwiQUJPVVRfOVwiOiBcIktvbnRha3QvZmVlZGJhY2s6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJWacWhZSBpbmZvcm1hY2lqYTpcIixcblx0XCJSRU1PVkVcIjogXCJVa2xvbmlcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIlByZWdsZWQgdHLFvmnFoXRhXCIsXG5cdFwiUFJJQ0VcIjogXCJDaWplbmFcIixcblx0XCJBTU9VTlRcIjogXCJJem5vc1wiLFxuXHRcIlRPVEFMXCI6IFwiVWt1cG5vXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJOZW1hIG90dm9yZW5paCBuYXJ1ZMW+YmkgemFcIixcblx0XCJEQVRFXCI6IFwiRGF0dW1cIixcblx0XCJCVVlcIjogXCJLdXBpXCIsXG5cdFwiU0VMTFwiOiBcIlByb2RhalwiLFxuXHRcIk9QRU5cIjogXCJPdHZvcmlcIixcblx0XCJISVNUT1JZXCI6IFwiUG92aWplc3RcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlV6dnJhdGkgcHJhxIdlbmplXCIsXG5cdFwiRk9MTE9XRURcIjogXCJQcmF0aW1cIixcblx0XCJVTkZPTExPV1wiOiBcIlByZXN0YW5pIHByYXRpdGlcIixcblx0XCJGT0xMT1dJTkdcIjogXCJQcmHEh2VuamVcIixcblx0XCJGT0xMT1dFUlNcIjogXCJQcmF0aXRlbGppXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlByZXRyYcW+aSBwcmF0aXRlbGplXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIlByZXRyYcW+aSBvbmUga29qZSBwcmF0aXRlXCIsXG5cdFwiQllcIjogXCJvZFwiLFxuXHRcIklOXCI6IFwidVwiLFxuXHRcIk1FTlVcIjogXCJJemJvcm5pa1wiLFxuXHRcIkJPT0tNQVJLXCI6IFwiT3puYWthXCIsXG5cdFwiUkVCTE9HXCI6IFwiUG9kaWplbGlcIixcblx0XCJVUFZPVEVcIjogXCJTdmnEkWEgbWkgc2VcIixcblx0XCJET1dOVk9URVwiOiBcIk5lIHN2acSRYSBtaSBzZVwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJQb25pxaF0aSBnbGFzXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJQb25pxaF0aSBnbGFzXCIsXG5cdFwiUkVQTFlcIjogXCJPZGdvdm9yXCIsXG5cdFwiRURJVFwiOiBcIlVyZWRpXCIsXG5cdFwiUE9TVF8xXCI6IFwiUG92dWNpdGUgdSBsaWpldm8ga29tZW50YXJlIGRhIGJpIHN0ZSB2aWRqZWxpIG9wY2lqZVwiLFxuXHRcIlBPU1RfMlwiOiBcIkRvZGlybml0ZSBrb21lbnRhcmUgZGEgYmkgc3RlIHZpZGplbGkgcG9kLWtvbWVudGFyZVwiLFxuXHRcIk9QVElPTlNcIjogXCJPcGNpamVcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJQb2RqZWxqZW5vIG9kXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiSm/FoSB1dmlqZWsgbmVtYXRlIG5pxaF0YSBvdmRqZS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU3RhbmplXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgVHJnb3ZpbnNraSB0b2tlbmkga29qaSBzZSBtb2d1IHByZWJhY2l0aSB1IGJpbG8ga29qZSB2cmlqZW1lLnt7cGxhdGZvcm1uYW1lfX0gbW/FvmUgYml0aSBwcmViYcSNZW4gdSB7e3BsYXRmb3JtcG93ZXJ9fSB1IHByb2Nlc3Uga29qaSBzZSB6b3ZlIEphxI1hbmplIHByb2ZpbGEuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIHRva2VuaSBrb2ppIHByZXplbnRpcmFqdSBqYcSNaW51IHZhxaFlZyBwcm9maWxhLiDFoHRvIGloIHZpxaFlIG5ldGtvIGltYSB0byBpbWEgdmXEh2kgdXRqZWNhaiBuYSBuYWdyYWR1IG9iamF2ZSB6YSBrb2p1IGdsYXN1amUgaSB6YXJhxJF1amUgdmXEh2UgbmFncmFkZSB6YSBnbGFzb3ZhbmplLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VuaSB2cmlqZWRlIG90cHJpbGlrZSB7e3BsYXRmb3Jtc3VuaXR9fSBvZCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlByb2NpamVuamVuYSB2cmlqZWRub3N0XCIsXG5cdFwiUFJPRklMRV80XCI6IFwiUHJvY2lqZW5qZW5hIHZyaWplZG5vc3QgYmF6aXJhbmEgbmEgNyBkbmV2bm9qIHByb3NqZcSNbm9qIHZyaWplZG5vc3RpIG9kIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlBvdmlqZXN0IHRyYW5zYWtjaWphXCIsXG5cdFwiUE9TVElOR1wiOiBcIk9iamF2bGppdmFuamVcIixcblx0XCJQUk9GSUxFXzVcIjogXCJLbGp1xI0gemEgb2JqYXZsaml2YW5qZSBzZSBrb3Jpc3RpIHphIG9iamF2ZSBpIGdsYXNhbmplLiBUcmViYW8gYmkgYml0aSBkcnVnYcSNaWppIG9kIGFrdGl2bm9nIGkgdmxhc25pxI1rb2cga2xqdcSNYS5cIixcblx0XCJPV05FUlwiOiBcIlZsYXNuaWtcIixcblx0XCJQUk9GSUxFXzZcIjogXCJWbGFzbmnEjWtpIGtsanXEjSBqZSBtYXN0ZXIga2xqdcSNIHphIHJhxI11biBpIHBvdHJlYmFuIGplIHphIHByb21qZW51IGRydWdpaCBrbGp1xI1ldmEuIFByaXZhdG5pIGtsanXEjSBpbGkgbG96aW5rYSB6YSB2bGFzbmnEjWtpIGtsanXEjSB0cmViYWxhIGJpIGJpdGkgdmFuIG1yZcW+ZSDFoXRvIGplIHZpxaFlIG1vZ3XEh2UuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0aXZub3N0aVwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkFrdGl2bmkga2xqdcSNIHNlIGtvcmlzdGkgemEgdHJhbnNha2NpamUgaSB6YWRhdmFuamUgbmFydWTFvmJpIHUgdWdyYcSRZW5vbSB0csW+acWhdHUuXCIsXG5cdFwiTUVNT1wiOiBcIkJpbGplxaFrYVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIktsanXEjSB6YSBiaWxqZcWha3Ugc2Uga29yaXN0aSB6YSBpenJhZHUgaSDEjWl0YW5qZSBiaWxqZcWha2kuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIk9iamF2ZVwiLFxuXHRcIlJFUExJRVNcIjogXCJPZGdvdm9yaVwiLFxuXHRcIldBTExFVFwiOiBcIk5vdsSNYW5pa1wiLFxuXHRcIlRBR1wiOiBcIlRhZ292aVwiLFxuXHRcIlVTRVJcIjogXCJLb3Jpc25pa1wiLFxuXHRcIkNMT1NFXCI6IFwiWmF0dm9yaVwiLFxuXHRcIlRPXCI6IFwiWmFcIixcblx0XCJBU1NFVFwiOiBcIkltb3ZpbmFcIixcblx0XCJTRU5EXCI6IFwiUG/FoWFsamlcIixcblx0XCJTRUNVUklUWVwiOiBcIlNpZ3Vybm9zdFwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRvc3R1cG5vXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJKYXZuYSBiaWxqZcWha2FcIixcblx0XCJUT19ERVNDXCI6IFwiS29yaXNuaWsgbnByLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJQaW4ga29kXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU4ga29kIHZhbSBwb21hxb5lIHphxaF0aXRpdGkgYXBsaWthY2lqdSBpIHZhxaFlIHBvZGF0a2UuPGJyLz48YnIvPjxiPk5hcG9tZW5hOjwvYj5LYWQgc2UgamVkbm9tIHVrbGp1xI1pLCBpbWF0ZSBtYWtzaW1hbG5vIDQgcG9rdcWhYWphIHphIG90a2xqdcSNYXRpLCBha28gemFib3Jhdml0ZSBwaW4gaWxpIHBvZ3JpamXFoWl0ZSwgYXBsaWthY2lqYSDEh2UgbWFrbnV0aSBwb2RhdGtlIGxvZ2lyYW5qYS4gTW/FvmV0ZSBzZSBwb25vdm8gbG9naXJhdGkgaSBuYXN0YXZpdGkga29yaXN0aXRpIGFwbGlrYWNpanUuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk9iYXZpamVzdGlcIixcblx0XCJWT1RFX1RFWFRcIjogXCJEb2JpdCDEh2V0ZSBvYmF2aWplc3Qga2FkYSBuZXRrbyBnbGFzdWplIHphIHZhxaEgc2FkcsW+YWohIDxici8+PGI+TmFwb21lbmE6PC9iPiBPYmF2aWplc3RpIHRha2/EkWVyIHNhZHLFvmUgcG9zdG90YWsgZ2xhc2EgaSBvcGlzIGdsYXNhLiAoU3ZpxJFhIG1pIHNlLCBOZSBzdmnEkWEgbWkgc2UsIFBvbmnFoXRhdmFuamUgZ2xhc2EpLlwiLFxuXHRcIlZPVEVcIjogXCJHbGFzXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiRG9iaXQgxIdldGUgb2JhdmlqZXN0IGthZCBuZXRrbyBrb21lbnRpcmEgdmHFoXUgb2JqYXZ1IGlsaSBrb21lbnRhciE8YnIvPjxiPk5hcG9tZW5hOjwvYj5PYmF2aWplc3RpIMSHZSB0YWtvxJFlciBzYWRyxb5hdmF0aSBpIDxiPnByb21qZW5lPC9iPiBuamlob3ZpaCBrb21lbnRhcmEuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIktvbWVudGFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJEb2JpdCDEh2V0ZSBvYmF2aWplc3Qga2FkIHZhcyBuZXRrbyBwb8SNbmUgaWxpIHByZXN0YW5lIHByYXRpdGkhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJTcG9taW5qYW5qYVwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJEb2JpdCDEh2V0ZSBvYmF2aWplc3Qga2FkIHZhcyBuZXRrbyBzcG9tZW5lIHUgb2JqYXZpIGlsaSBrb21lbnRhcnUhXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlBvZGlqZWxpXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiRG9iaXQgxIdldGUgb2JhdmlqZXN0IGthZGEgbmV0a28gcG9kaWplbGkgdHZvanUgb2JqYXZ1IVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiS29uZmlndXJhY2lqYVwiLFxuXHRcIlZPVElOR1wiOiBcIkdsYXNvdmFuamVcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIlBvc3RvdGFrIGdsYXNhIHV0amXEjWUgbmEgZ2xhc2FuamEgdSBhcGxpa2FjaWppLCB6bmHEjWkgbW/FvmV0ZSByZWd1bGlyYXRpIG5hZ3JhZHUga29qdSBwcmVkYWpldGUgb2JqYXZpLjxici8+PGJyLz48Yj5OYXBvbWVuYTo8L2I+IE92byDEh2UgdGFrb8SRZXIgcHJvbWlqZW5pdGkgcG9zdG90YWsgaSBcXFwiTmVzdmnEkWFuamFcXFwiIGkgdG8gc3Z1Z2RqZSB1IGFwbGlrYWNpamlcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlByZXBvcnXEjWVub1wiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNwcmVtaSBwcm9tamVuZVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiSW5mb3JtYWNpamUgZ2xhc2HEjWFcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJEb2JybyBkb8WhbGkgbmF0cmFnIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJQcmlqYXZpdGUgc2Ugc2Egc3ZvamltIGtvcmlzbmnEjWtpbSBpbWVub24gaSBsb3ppbmtvbSB6YSBuYXN0YXZhay5cIixcblx0XCJMT0dJTl8yXCI6IFwiS2xqdcSNIHphIG9iamF2ZSBzZSBrb3Jpc3RpIHphIG9iamF2ZSwga29tZW50YXJlLCBnbGFzb3ZhbmplLCBwcmHEh2VuamUuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFrdGl2bmkga2xqdcSNIHNlIGtvcmlzdGkgemEgcHJpamVub3Mgc3JlZHN0YXZhIGkgcHJvbWplbnUgcHJvZmlsbmUgc2xpa2UuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIktvcmlzbmnEjWtpIHBvZGF0Y2kgcHJpamF2ZSDEjXV2YWp1IHNlIGxva2Fsbm8gbmEgdXJlxJFhanUuIE5ha29uIG9kamF2ZSBwb2RhdGNpIHphIHByaWphdnUgbmVzdGFqdSFcIixcblx0XCJET05UX0hBVkVcIjogXCJOZW1hdGUga29yaXNuacSNa2kgcmHEjXVuP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiUmVnaXN0cmlyYWp0ZSBzZSBvZG1haFwiLFxuXHRcIkNBTkNFTFwiOiBcIk9kdXN0YW5pXCIsXG5cdFwiQURWQU5DRURcIjogXCJOYXByZWRub1wiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJBa3Rpdm5pIHByaXZhdG5pIGtsanXEjVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUHJpdmF0bmkga2xqdcSNIHphIG9iamF2ZVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVyL2dsYXZuYSBsb3ppbmthXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJLb3Jpc25pxI1rbyBpbWVcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJLYXJ0acSNbmkgcHJlZ2xlZFwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIktvbXBha3RuaSBwcmVnbGVkXCIsXG5cdFwiU0VBUkNIXCI6IFwiUHJldHJhxb5pXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJPYmphdmkgbm92dSBwcmnEjXVcIixcblx0XCJSRVBMWVRPXCI6IFwiT2Rnb3ZvciBuYVwiLFxuXHRcIlBPU1RcIjogXCJPYmphdmFcIixcblx0XCJQUkVWSUVXXCI6IFwiUHJlZHByZWdsZWRcIixcblx0XCJERUZBVUxUXCI6IFwiWmFkYW5vIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJKYcSNYW5qZSBwcm9maWxhIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIk90a2HFvmkgaXNwbGF0dVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiU1BSRU1JIFpBIEtBU05JSkVcIixcblx0XCJDTEVBUlwiOiBcIk/EjElTVElcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJTYWRyxb5haiBvYmphdmVcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJLb21lbnRpcmFqdGUgc2FkcsW+YWpcIixcblx0XCJUSVRMRVwiOiBcIk5hc2xvdlwiLFxuXHRcIlRBR1NcIjogXCJUYWdvdmlcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJORSBPREdPVkFSQVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiUG90dnJkaXRlIFBJTlwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIk5FSVNQUkFWTk9cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJvdHZhcmFuamUgb2JqYXZlXCIsXG5cdFwiU0VUX1BJTlwiOiBcIlBvc3RhdmkgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiVW5lc2l0ZSBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJKZXN0ZSBsaSBzaWd1cm5pP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiRGlqZWxqZW5qZSBwb3N0YSBqZSBuZXBvdnJhdG5vLCDFvmVsaXRlIGxpIG5hc3Rhdml0aT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJQb2dyZcWha2EgcHJpbGlrb20gZW1pdGlyYW5qYSwgcG9rdcWhYWp0ZSBwb25vdm8hXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlVzcGplxaFub1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiT2JqYXZhIGplIHBvZGlqZWxqZW5hIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJQcmlqYXZhIG5pamUgdXNwamVsYS4gTW9saW1vIHByb3ZqZXJpdGUgamVzdGUgbGkgcHJpamF2bGplbmkgc2EgbWFzdGVyIGxvemlua29tIGlsaSBrbGp1xI1lbSB6YSBvYmphdmUgYWtvIHN0ZSBvZGFicmFsaSBuYXByZWRuaSBuYcSNaW4gcmFkYS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJQcmlqYXZhIG5pamUgdXNwamVsYSEgTW9saW1vIHZhcyBwcm92amVyaXRlIGplc3RlIGxpIHByaWphdmxqZW5pIHNhIG1hc3RlciBsb3ppbmtvbSBpbGkgYWt0aXZuaW0gcHJpdmF0bmltIGtsanXEjWVtIGFrbyBzdGUgb2RhYnJhbGkgbmFwcmVkbmkgbmHEjWluLlwiLFxuXHRcIldBUk5JTkdcIjogXCJVcG96b3JlbmplXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIkdsYXNvdmFuamUgemEgc3ZqZWRva2FcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIkdsYXNhbGkgc3RlIHphIHN2amVkb2thXCIsXG5cdFwiQUdPXCI6IFwicHJpamVcIixcblx0XCJGUk9NX05PV1wiOiBcIm9kIHNhZGFcIixcblx0XCJTRUNTXCI6IFwic2VrdW5kaVwiLFxuXHRcIkFfTUlOXCI6IFwiMSBtaW5cIixcblx0XCJNSU5TXCI6IFwibWluXCIsXG5cdFwiQU5fSE9VUlwiOiBcIjEgc2F0XCIsXG5cdFwiSE9VUlNcIjogXCJzYXRpXCIsXG5cdFwiQV9EQVlcIjogXCIxIGRhblwiLFxuXHRcIkRBWVNcIjogXCJkYW5hXCIsXG5cdFwiQV9NT05USFwiOiBcIm1qZXNlYyBkYW5hXCIsXG5cdFwiTU9OVEhTXCI6IFwibWplc2VjaVwiLFxuXHRcIkFfWUVBUlwiOiBcImdvZGludSBkYW5hXCIsXG5cdFwiWUVBUlNcIjogXCJnb2RpbmVcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbiDEjWl0YW5qYVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJOZXN2acSRYW5qZSBpbGkgcHJpamF2YVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIlNuaW1pIHNsaWt1XCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJPZGFiZXJpdGUgc2xpa3VcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIlBvc3RhdmxqYW5qZSBwcmlsYWdvxJFlbm9nIFVSTC1hXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJVbWV0bmkgc2xpa3VcIixcblx0XCJFUlJPUlwiOiBcIkdyZcWha2FcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJQb2dyZcWha2EgcHJpIHByaWplbm9zdVwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJLYW1lcmEgb3RrYXphbmFcIixcblx0XCJTRVRfVVJMXCI6IFwiUG9zdGF2aSBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWt0bmkgd2ViIGxpbmsgbmEgc2xpa3VcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIktvbWVudGFyIGplIHBvc2xhbiFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkJyaXNhbmplIGtvbWVudGFyYSBqZSBuZXBvdnJhdG5vLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiSXpicmlzYW5pIGtvbWVudGFyXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJVxI1pdGF2YW5qZSBzbGlrZVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJVxI1pdGF2YW5qZSB6YXZyxaFlbm9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiTmV1c3BqZcWhYW4gcHJpamVub3NcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJQb2dyZcWhbm8ga29yaXNuacSNa28gaW1lIGlsaSBsb3ppbmthXCIsXG5cdFwiSU5GT1wiOiBcIkluZm9cIixcblx0XCJRUl9URVhUXCI6IFwiUG9zdGF2aSBRUiBrb2QgdW51dGFyIHBvZHJ1xI1qYSBza2VuaXJhbmphXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiUHJvdmplcml0ZSBpbWF0ZSBsaSBkb3ZvbGpubyBzcmVkc3RhdmEgemEgdHJhbnNha2NpanUhXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIktvcmlzbmlrIGtvamVtIMW+ZWxpdGUgcG9zbGF0aSBzcmVkc3R2YSBuZSBwb3N0b2ppIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJKZXN0ZSBsaSBzaWd1cm5pIGRhIMW+ZWxpdGUgb2Jhdml0aSB0cmFuc2FrY2lqdT9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJQb3R2cmRhXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJUcmFua3NhY2lqYSBqZSBwcm92ZWRlbmFcIixcblx0XCJGRUVEXCI6IFwiTm92b3N0aVwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiUG9wdWxhcm5vXCIsXG5cdFwiSE9UXCI6IFwiQWt0dWFsbm9cIixcblx0XCJORVdcIjogXCJOb3ZvXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3ZpcmFub1wiLFxuXHRcIlZPVEVTXCI6IFwiR2xhc292aVwiLFxuXHRcIlBBWU9VVFwiOiBcIklzcGxhdGFcIixcblx0XCJDT01NRU5UU1wiOiBcIktvbWVudGFyaVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiUG9wdWxhcm5vIHphZG5qaWggMzAgZGFuYVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlJhc3BvcmVkaSBwb3N0b3ZlIHBvOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIklzcGxhdG5pIGNpa2x1c1wiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJNb2d1xIdhIGlzcGxhdGFcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlByb8WhbGEgaXNwbGF0YVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJBdXRvcnNrYSBpc3BsYXRhXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiS3VyYWNpanNrYSBpc3BsYXRhXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJPYmphdmEgamUgb2JqYXZsamVuYSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiT2JqYXZhIHphIG9iamF2bGppdmFuamUga2FzbmlqZSFcIixcblx0XCJTQVZFRFwiOiBcIlNwcmVtbGplbm9cIixcblx0XCJDTEVBUkVEXCI6IFwiSXpicmlzYW5vXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIlByaWphdmEgb2JqYXZlIG1vxb5lIG1ha251dGkgbmFncmFkZSBpIHXEjWluaXRpIG5qZW4gc2FkcsW+YWogbWFuamUgdmlkbGppdi48YnI+PGJyPlByaWphdmEgYmkgc2UgdHJlYmFsYSBrb3Jpc3RpdGkgemE6PHVsPjxsaT5QcmV2YXJlIGkgcGxhZ2lqYXRlPC9saT48bGk+R292b3IgbXLFvm5qZSBpbGkgcHJvdm9jaXJhbmplPC9saT48bGk+cG9ncmXFoW48L3VsPjwvdWw+byBrYXRlZ29yaXppcmFuaSBzYWRyxb5haiBpbGkgc3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJOZW1hIHNhZHLFvmFqYS4gUG9nbGVkYWp0ZSBkcnVnZSBzdHJhbmljZS90YWdvdmUhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiT2JqYXZhIGplIGl6YnJpc2FuYSBpeiBvem5ha2EhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIk9iamF2YSBqZSBkb2RhbmEgdSBvem5ha2UhXCIsXG5cdFwiUkVTRVRcIjogXCJSZXNldGlyYWpcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIlByb21pamVuaSBzbGlrdSBwcm9maWxhXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJQcm9taWplbmkgbmFzbG92bnUgc2xpa3VcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJNb2xpbW8gdW5lc2l0ZSBha3Rpdm5pIGtsanXEjSBha28gc3RlIG9kYWJyYWxpIG5hcHJlZG5pIG5hxI1pbiBsb2dpcmFuamEhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiT3ZvIMSHZSByZXNldGlyYXRpIGtvcmlzbmnEjWt1IHByb2ZpbG51IHNsaWt1XCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiT3ZvIMSHZSByZXNldGlyYXRpIGtvcmlzbmnEjWt1IG5hc2xvdm51IHNsaWt1XCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBxb51cmlyYW5qZSBzZXJ2ZXJhIHphaHRqZXZhIFJlc3RhcnQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIlBvc3RhdmtlIHN1IGHFvnVyaXJhbmUhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiSmV6aWNpXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJPdmRqZSBtb8W+ZXRlIHByb21pamVuaXRpIGplemlrIGFwbGlrYWNpamUuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIk92YWogcG9zdHVwYWsgemFodGpldmEgZGEga29yaXNuaWsgYnVkZSBwcmlqYXZsamVuIHNhIGdsYXZub20gbG96aW5rb20sIGFrdGl2bmltL2tsanXEjWVtIHphIG9iamF2ZS4gTW9saW1vIHByaWphdml0ZSBzZSBpIHBva3XFoWFqdGUgcG9ub3ZvLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxlcmlqYVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlByZXZlbGkgaSBwcmlsYWdvZGlsaTpcIixcblx0XCJTSEFSRVwiOiBcIlBvZGlqZWxpXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJUcmdvdmluYVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiQnVyemFcIixcblx0XCJEUkFGVFNcIjogXCJTa2ljZVwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIk9iamF2YSBqZSBtYWtudXRhIGl6IHNraWNhIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJPYmphdmEgamUgZG9kYW5hIHUgc2tpY2UhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIlBvdnVjaSB1IGxpamV2byB6YSB2aWRqZXRpIG9wY2lqZVwiLFxuXHRcIk1BTkFHRVwiOiBcIlVwcmF2bGphbmplXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIlNsaWthIGplIHVrbG9uamVuYVwiLFxuXHRcIkNPUFlcIjogXCJLb3BpcmFqXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJKb8WhIG5pc3RlIHBvc3RhdmlsaSBuaWplZG51IHNsaWt1IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiUG92dWNpdGUgZG9samUgemEgb3N2amXFvmF2YW5qZVwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJWYW5qc2tlIGFwbGlrYWNpamVcIixcblx0XCJQTFVHSU5TXCI6IFwiRG9kYXRjaVwiLFxuXHRcIlNVR0dFU1RcIjogXCJQcmVkbG/FvmlcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIlVza29ybyBkb2xhemlcIixcblx0XCJDSEFJTlwiOiBcIkxhbmFjXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIk92ZGplIG1vxb5ldGUgcHJvbWlqZW5pdGkgYmxvY2tjaGFpbiBpbGkgemFkYW51IHBsYXRmb3JtdS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlZhbHV0YVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJPdmRqZSBtb8W+ZXplIHByb21pamVuaXRpIHZhxaF1IHphZGFudSB2YWx1dHUuIE5hZ3JhZGUgbmEgb2JqYXZhbWEgaSBrb21lbnRhcmltYSDEh2UgdmFtIGJpdGkgcHJpa2F6YW5lIHUgb3ZvaiB2YWx1dGkuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+TGlzdGEgbW9ndcSHbm9zdGk8L2I+PGJyPi1QcmlzdHVwaXRlIGJpbG8ga29qb2ogb2JqYXZpIHUgYmlsbyBrb2pvaiB0ZW1pIGtvamEgdmFzIHphbmltYS48YnI+VWtsanXEjWl0ZSBzZSBzYSBhdXRvcmltYSBzIGtvbWVudGlyYW5qZW0gaSByYXNwcmF2bGphbmplbSBvIHRlbWFtYS48YnI+LUdsYXN1anRlIHphIG9iamF2ZSB0YWtvIGRhIG5hZ3JhZGl0ZSBhdXRvcmEgaSBkYSB6YXJhZGl0ZSBuYSBrdXJhY2lqYW1hLjxicj4tT2JqYXZpdGUgdmHFoWUgxI1sYW5rZSxvYmphdmUgYmVzcGxhdG5vIGkgemFyYWRpdGUgbmFncmFkZSBzIHByaXZsYcSNZW5qZW0gaSBkb2JpdmFuamVtIHByYXRpdGVsamEuPGJyPi1QacWhaXRlIMSNbGFua2UgemEgcHV0dSwgc3ByZW1pdGUgdmnFoWUgc2tpY2EgemEga2FzbmlqdSBvYmphdnUuPGJyPi1Pem5hxI1pIG5hamRyYcW+ZSDEjWxhbmtlIHphIHByb8SNaXRhdGkga2FzbmlqZS48YnI+LVJhem1qZW5pIGlsaSBpc3BsYXRpIHN2b2p1IHphcmFkdS48YnI+LVBvxaFhbGppdGUgdmHFoWEgc3JlZHN0dmEgYmlsbyBrb2plbSBhdXRvcnUgaWxpIGtvcmlzbmlrdSwgcHJpamF0ZWxqdSwgcHJhdGl0ZWxqdSwgaXRkLjxicj4tUHJhdGkgemFuaW1saml2ZSBhdXRvcmUsIGJsb2dlcmUuPGJyPi1QcmV0cmHFvmkgc3ZvamUgcHJhdGl0ZWxqZSBpIGF1dG9yZSBrb2plIHByYXRpdGUuPGJyPi1Eb2JpdmFqdGUgb2JhdmlqZXN0aSBkYSBiaSBzdGUgb3N0YWxpIHUga29udGFrdHUgc2Egc3ZvamltIHByYXRpdGVsamltYSBpIHJhc3ByYXZhbWEgdSBrb2ppbWEgc3RlIHVrbGp1xI1lbmkuPGJyPi1QcmV0cmHFvml0ZSB6YW5pbWxqaXZlIHRhZ292ZS9rYXRlZ29yaWplIMSNbGFuYWthLCBhdXRvcmEuPGJyPlBlcnNvbmFsaXppcmFqdGUgdmHFoSBwcm9maWwuPGJyPi1Kb8WhIHB1bm8gbm92b3N0aSBzdGnFvmUuPGJyPjxicj48Yj5TaWd1cm5vc3Q8L2I+PGJyPjEuQXBsaWthY2lqYSBuaWthZCBuZSBwcmlzdHVwYSBpbGkgemFkcsW+YXZhIG5hIGtvcmlzbmnEjWtpbSBzcmVkc3R2aW1hLjxicj4yLkFwbGlrYWNpamEgbnVkaSBzaWd1cm5vc25pIG1vZGVsIG5hIHN0cmFuaSBrbGlqZW50YSwgcyBwcml2YXRuaW0ga2xqdcSNZXZpbWEgcG9ocmFuamVuaW1hIGxva2Fsbm8gaSBuaWthZCBzZSBuZSDFoWFsanUgbmEgc2VydmVyLCB2aSBzdGUgb2Rnb3Zvcm5pIHphIMSNdXZhbmplIHZhxaFpaCBsb3ppbmtpLjxicj4zLiBBcGxpa2FjaWphIG51ZGkgamVkbm9zdGF2YW5vLCBhdHJha3RpdmFubyBrb3Jpc25pxI1rbyBzdcSNZWxqZSBpIGRvxb5pdmxqYWo8YnI+NC5BcGxpa2FjaWphIG51ZGkgZG9kYXRhbiBzbG9qIHphxaF0aXRlIHNhIFBJTiBrb2RvbTxicj48YnI+ZVN0ZWVtIHBvZHLFvmF2YSBTdGVlbSBpIEdvbG9zIHBsYXRmb3JtZS48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIk9zbml2YcSNIGkgZ2xhdm5pIHByb2dyYW1lclwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiRG9kYWogcmHEjXVuXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0Zm9ybWFcIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgYWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJSb2sgcG90dnLEkWl2YW5qYVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiRXNjcm93IGlzdGVrXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkVzY3JvdyBob25vcmFyXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IHV2amV0aVwiLFxuXHRcIk5JR0hUX01PREVcIjogXCJOb8SHbmkgbmHEjWluXCIsXG5cdFwiREFZX01PREVcIjogXCJEbmV2bmkgbmHEjWluXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiUG9nbGVkYWogY2lqZWxpIHNhZHLFvmFqXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIktvcmlzbmlrIG5pamUgcHJvbmHEkWVuXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkRvenZvbGlcIixcblx0XCJESVNQVVRFXCI6IFwiUmFzcHJhdmlcIixcblx0XCJSRUxFQVNFXCI6IFwiSXpkYW5qZVwiLFxuXHRcIkZST01cIjogXCJPZFwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJPYmphdmlcIixcblx0XCJSRUNFSVZFUlwiOiBcIlByaW1hdGVsalwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9rYWNpamFcIixcblx0XCJXRUJTSVRFXCI6IFwiV2ViIHN0cmFuaWNhXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiUHJpa2F6YW5pIG5heml2XCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIktlemTFkWxhcFwiLFxuXHRcIkxPR0lOXCI6IFwiQmVqZWxlbnRrZXrDqXNcIixcblx0XCJMT0dPVVRcIjogXCJLaWplbGVudGtlesOpc1wiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJLw7Z2ZXTDqXNcIixcblx0XCJCT09LTUFSS1NcIjogXCJLw7ZueXZqZWx6xZFrXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLDgXR1dGFsw6FzXCIsXG5cdFwiTUFSS0VUXCI6IFwiUGlhY1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwiQmXDoWxsw610w6Fzb2tcIixcblx0XCJBQk9VVFwiOiBcIlLDs2x1bmtcIixcblx0XCJBQk9VVF8xXCI6IFwiYWhvbCBiw6Fya2kga2FwaGF0IGp1dGFsbWFrYXQgYSB0YXJ0YWxtYWnDqXJ0IVwiLFxuXHRcIkFCT1VUXzJcIjogXCJhIHt7cGxhdGZvcm1uYW1lfX0gcGxhdGZvcm0gw7x6ZW1lbHRldGkuIEF6IGFsa2FsbWF6w6FzIGvDqXN6w610xZFqZVwiLFxuXHRcIkFCT1VUXzNcIjogXCLDqXMgbnnDrWx0IGZvcnLDoXNrw7Nkw7osIGvDtnrDtnNzw6lnIMOhbHRhbCBtxbFrw7ZkdGV0ZXR0IHByb2pla3QuIFTDoW1vZ2F0amEgYSB0YXJ0YWxvbWhvenrDoWbDqXLDqXN0IG9sdmFzw6Fzw6lydCwgYSBob3p6w6FzesOzbMOhc3QsIHN6YXZhesOhc3QsIHBvc3p0b2zDoXN0LCBmaXpldHPDqWcgw6F0dXRhbMOhc8OhdCwgc3RiLiBmdW5rY2nDs2thdCwgYW1pa2V0IGEge3twbGF0Zm9ybW5hbWV9fSBibG9ra2zDoW5jIMOpcyBhIHt7c2l0ZW5hbWV9fSBrw61uw6FsbmFrLlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBBeiBhbGthbG1hesOhcyBzb2hhIG5lbSBmw6lyIGhvenrDoSB2YWd5IHTDoXJvbGphIGEgZmVsaGFzem7DoWzDs2sgcMOpbnrDqXQuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEF6IGFsa2FsbWF6w6FzIGtsaWVucyBvbGRhbGkgYml6dG9uc8OhZ2kgbW9kZWxsdCBrw61uw6FsLCBhIHByaXbDoXQga3VsY3NvayBoZWx5YmVuaSB0w6Fyb2zDoXPDoXZhbCwgYW1payBzb2hhIG5lbSBrZXLDvGxuZWsgZWxrw7xsZMOpc3JlIHNlbW1pbHllbiBzemVydmVycmUuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIEF6IGFsa2FsbWF6w6FzIGVneXN6ZXLFsSwgdGV0c3pldMWRcyBmZWxoYXN6bsOhbMOzaSBmZWzDvGxldGV0IMOpcyAtw6lsbcOpbnl0IG55w7pqdC5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXogYWxrYWxtYXrDoXMgc29oYSBuZW0ga8OpcmkgYSBmZWxoYXN6bsOhbMOza2F0IGEgc3plbcOpbHllcyBhZGF0YWlrIG1lZ2Fkw6Fzw6FyYS5cIixcblx0XCJBQk9VVF84XCI6IFwiU3phdmF6eiBnb29kLWthcm1hIC1yYSBtaW50IHRhbsO6XCIsXG5cdFwiQUJPVVRfOVwiOiBcIkthcGNzb2xhdC9WaXNzemFqZWx6w6lzOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiVMO2YmIgaW5mw7M6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiRWx0w6F2b2zDrXTDoXNcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIlBpYWMgTsOpemV0XCIsXG5cdFwiUFJJQ0VcIjogXCLDgXJcIixcblx0XCJBTU9VTlRcIjogXCLDlnNzemVnXCIsXG5cdFwiVE9UQUxcIjogXCLDlnNzemVzZW5cIixcblx0XCJOT09SREVSU1wiOiBcIk5pbmNzIG55aXRvdHQgbWVnYsOtesOhc1wiLFxuXHRcIkRBVEVcIjogXCJEw6F0dW1cIixcblx0XCJCVVlcIjogXCJWw6l0ZWxcIixcblx0XCJTRUxMXCI6IFwiRWxhZMOhc1wiLFxuXHRcIk9QRU5cIjogXCJOeWl0w6FzXCIsXG5cdFwiSElTVE9SWVwiOiBcIlTDtnJ0w6luZXRcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlZpc3N6YWvDtnZldMOpc1wiLFxuXHRcIkZPTExPV0VEXCI6IFwiS8O2dmV0dmVcIixcblx0XCJVTkZPTExPV1wiOiBcIkvDtnZldMOpcyBtZWdzesO8bnRldMOpc2VcIixcblx0XCJGT0xMT1dJTkdcIjogXCJLw7Z2ZXRldHRla1wiLFxuXHRcIkZPTExPV0VSU1wiOiBcIkvDtnZldMWRa1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJLw7Z2ZXTFkWsga2VyZXPDqXNlXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIkvDtnZldGV0dGVrIGtlcmVzw6lzZVwiLFxuXHRcIkJZXCI6IFwiw6FsdGFsXCIsXG5cdFwiSU5cIjogXCJpdHQ6XCIsXG5cdFwiTUVOVVwiOiBcIk1lbsO8XCIsXG5cdFwiQk9PS01BUktcIjogXCJLw7ZueXZqZWx6xZFrXCIsXG5cdFwiUkVCTE9HXCI6IFwiw5pqcmFibG9nb2zDoXNcIixcblx0XCJVUFZPVEVcIjogXCJGZWxzemF2YXrDoXNcIixcblx0XCJET1dOVk9URVwiOiBcIkxlc3phdmF6w6FzXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkxlc3phdmF6w6FzIGVsdMOhdm9sw610w6FzYVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiRmVsc3phdmF6w6FzIGVsdMOhdm9sw610w6FzYVwiLFxuXHRcIlJFUExZXCI6IFwiVsOhbGFzelwiLFxuXHRcIkVESVRcIjogXCJTemVya2VzenTDqXNcIixcblx0XCJQT1NUXzFcIjogXCJDc8O6c3p0YXNzIGJhbHJhIGEgaG96esOhc3rDs2zDoXNva29uLCBob2d5IGzDoXNkIGF6IG9wY2nDs2thdFwiLFxuXHRcIlBPU1RfMlwiOiBcIktvcHBpbnRzIGEgaG96esOhc3rDs2zDoXNva29uLCBob2d5IGzDoXNkIGF6IGFsLWhvenrDoXN6w7Nsw6Fzb2thdFwiLFxuXHRcIk9QVElPTlNcIjogXCJPcGNpw7NrXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiw5pqcmFvc3p0dmEgw6FsdGFsYTpcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJTZW1taSBzaW5jcyBpdHQgbcOpZy4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiRWd5ZW5sZWdla1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIGVsYWRoYXTDsyB0b2tlbmVrLCBhbWVseWVrZXQgw6F0IGxlaGV0IHV0YWxuaSBiw6FybWlrb3IuXFxue3twbGF0Zm9ybW5hbWV9fSBrb252ZXJ0w6FsaGF0w7Mge3twbGF0Zm9ybXBvd2VyfX0gLcOpIGVneSBmb2x5YW1hdGJhbiwgYW1pdCBmZWx0w7ZsdMOpc25layBuZXZlesO8bmsuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGJlZm9secOhc29sw7MgdG9rZW5laywgYW1payB0w7ZiYiBlcsWRdCBrYXBuYWsgYSBob3NzesO6IHTDoXbDuiBiaXJ0b2tsw6FzdWvDqXJ0IMOpcyBhIHBvc3p0b2sgZmVsc3phdmF6w6Fzw6HDqXJ0LiBNaW7DqWwgdMO2YmJldCBiaXJ0b2tvbCBiZWzFkWxlIHZhbGFraSwgYW5uw6FsIGpvYmJhbiB0dWRqYSBiZWZvbHnDoXNvbG5pIG3DoXNvayBqdXRhbG1haXQgw6lzIGthcCB0w7ZiYiBqdXRhbG1hdCBheiBhbGFwb3Mgc3phdmF6w6Fzw6lydC5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbmVrLCBhbWlrIGvDtnLDvGxiZWzDvGwge3twbGF0Zm9ybXN1bml0fX0gLW55aSB7e3BsYXRmb3JtbmFtZX19IC1ldCDDqXJuZWsuXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiQmVjc8O8bHQgw4lydMOpa1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIkEgYmVjc8O8bHQgw6lydMOpayBhIHt7cGxhdGZvcm1uYW1lfX0gNyBuYXBvcyDDoXRsYWdvcyDDqXJ0w6lrw6luIGFsYXBzemlrLlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCLDgXR1dGFsw6FzIFTDtnJ0w6luZXRcIixcblx0XCJQT1NUSU5HXCI6IFwiUG9zenRvbMOhc1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkEgcG9zenRvbMOzIGt1bGNzIHBvc3p0b2zDoXNyYSDDqXMgc3phdmF6w6FzcmEgaGFzem7DoWxhdG9zLiBLw7xsw7ZuYsO2esWRbmVrIGtlbGwgbGVubmllIGF6IGFrdMOtdiDDqXMgYSB0dWxhamRvbm9zaSBrdWxjc29rdMOzbC5cIixcblx0XCJPV05FUlwiOiBcIlR1bGFqZG9ub3NcIixcblx0XCJQUk9GSUxFXzZcIjogXCJBIHR1bGFqZG9ub3Mga3VsY3MgZWd5IG1lc3Rlcmt1bGNzIGEgc3rDoW1sw6Fob3ogw6lzIGvDtnRlbGV6xZEgYSB0w7ZiYmkga3VsY3MgbWVndsOhbHRvenRhdMOhc8OhaG96LiBBIHR1bGFqZG9ub3NpIGt1bGNzIHByaXbDoXQga3VsY3PDoXQgdmFneSBqZWxzemF2w6F0IHRpdG9rYmFuIMOpcyBvZmZsaW5lIGtlbGwgdGFydGFuaSwgYW1lbm55aXJlIGNzYWsgbGVoZXRzw6lnZXMuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0w612XCIsXG5cdFwiUFJPRklMRV83XCI6IFwiQXogYWt0w612IGt1bGNzIGhhc3puw6FsYXRvcyBheiDDoXR1dGFsw6Fzb2sgaW5kw610w6Fzw6Fob3ogw6lzIGEgbWVnYsOtesOhc29rIGJlamVneXrDqXPDqWhleiBhIGJlbHPFkSBwaWFjb24uXCIsXG5cdFwiTUVNT1wiOiBcIkZlbGplZ3l6w6lzXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiQSBmZWxqZWd5esOpcyBrdWxjcyBoYXN6bsOhbGF0b3MgZmVsamVneXrDqXNlayBrw6lzesOtdMOpc8OpcmUgw6lzIG9sdmFzw6Fzw6FyYS5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiUG9zenRva1wiLFxuXHRcIlJFUExJRVNcIjogXCJWw6FsYXN6b2tcIixcblx0XCJXQUxMRVRcIjogXCJUw6FyY2FcIixcblx0XCJUQUdcIjogXCJDw61ta2VcIixcblx0XCJVU0VSXCI6IFwiRmVsaGFzem7DoWzDs1wiLFxuXHRcIkNMT1NFXCI6IFwiQmV6w6FyXCIsXG5cdFwiVE9cIjogXCJOZWtpXCIsXG5cdFwiQVNTRVRcIjogXCJWYWd5b250w6FyZ3lcIixcblx0XCJTRU5EXCI6IFwiS8O8bGRcIixcblx0XCJTRUNVUklUWVwiOiBcIkJpenRvbnPDoWdcIixcblx0XCJBVkFJTEFCTEVcIjogXCJSZW5kZWxrZXrDqXNyZSDDoWxsXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJOeWlsdsOhbm9zIGZlbGplZ3l6w6lzXCIsXG5cdFwiVE9fREVTQ1wiOiBcIkZlbGhhc3puw6Fsw7MsIHBsLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJQSU4ta8OzZFwiLFxuXHRcIlBJTl9URVhUXCI6IFwiQSBQSU4ta8OzZCBzZWfDrXQgaG9neSBtZWfDs3ZkIGF6IGFsa2FsbWF6w6Fzb2Qgw6lzIGF6IGFkYXRhaWQuIDxici8+PGJyLz48Yj5NZWdqZWd5esOpczo8L2I+IE1pdXTDoW4gYWxrYWxtYXp2YSB2YW4sIG1heC4gNCBwcsOzYsOhbGtvesOhc2kgbGVoZXTFkXPDqWdlZCB2YW4gaG9neSBmZWxueWlzZDsgaGEgZWxmZWxlanRlZCBhIFBJTi10IHZhZ3kgaGliw6F6b2wsIGF6IGFsa2FsbWF6w6FzIGVsIGZvZ2phIHTDoXZvbMOtdGFuaSBtaW5kZW4gYmVqZWxlbnRrZXpldHQgZmVsaGFzem7DoWzDs2kgYWRhdG90LiBWaXNzemEgdHVkc3ogamVsZW50a2V6bmkgw6lzIGZvbHl0YXRoYXRvZCBheiBhbGthbG1hesOhcyBoYXN6bsOhbGF0w6F0LlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLDiXJ0ZXPDrXTDqXNla1wiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIsOJcnRlc8OtdMOpc2VrZXQga2Fwc3osIGFtaWtvciB2YWxha2kgc3phdmF6IGEgYmVqZWd5esOpc2VkcmUhIGJyLz4gPGI+TWVnamVneXrDqXM6PC9iPiBBeiDDqXJ0ZXPDrXTDqXNlayB0YXJ0YWxtYXp6w6FrIGEgc3phdmF6w6FzIHPDumx5b3rDoXPDoXQgYSBmaWd5ZWxtZXp0ZXTFkSDDvHplbmV0YmVuIGlzIChMZWd5ZW4gYXogZmVsc3phdmF6w6FzLCBsZXN6YXZhesOhcyB2YWd5IHN6YXZhemF0IHZpc3N6YXZvbsOhc2EpLlwiLFxuXHRcIlZPVEVcIjogXCJTemF2YXrDoXNcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCLDiXJ0ZXPDrXTDqXN0IGthcHN6IGhhIHZhbGFraSBob3p6w6FzesOzbCBhIHBvc3p0b2Rob3ogdmFneSBhIGhvenrDoXN6w7Nsw6Fzb2Rob3ohIDxici8+IDxiPk1lZ2plZ3l6w6lzOjwvYj4gQXogw6lydGVzw610w6lzZWsgdGFydGFsbWF6esOhayBhenQgaXMsIGFtaWtvciB2YWxha2kgPGI+c3plcmtlc3p0aTwvYj4gYSBob3p6w6FzesOzbMOhc2FpdC5cIixcblx0XCJDT01NRU5UXCI6IFwiSG96esOhc3rDs2zDoXNcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIsOJcnRlc8OtdMOpc3Qga2Fwc3osIGFtaWtvciB2YWxha2kgS8O2dmV0IHTDqWdlZCB2YWd5IFZpc3N6YXZvbmphIGEga8O2dmV0w6lzdCFcIixcblx0XCJNRU5USU9OU1wiOiBcIkVtbMOtdMOpc2VrXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIsOJcnRlc8OtdMOpc2VrZXQga2Fwc3osIGFtaWtvciB2YWxha2kgbWVnZW1sw610IHTDqWdlZCBlZ3kgcG9zenRiYW4vaG96esOhc3rDs2zDoXNiYW4hXCIsXG5cdFwiUkVTVEVFTVwiOiBcIsOaanJhYmxvZ29sw6FzXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiw4lydGVzw610w6lzdCBrYXBzeiwgYW1pa29yIHZhbGFraSByZXN0ZWVtZWxpIGEgcG9zenRvZGF0IVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiS29uZmlndXLDoWNpw7NcIixcblx0XCJWT1RJTkdcIjogXCJTemF2YXrDoXNcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIkEgc3phdmF6YXQgc8O6bHlvesOhc2EgdmFneSBzesOhemFsw6lrYSBhIHN6YXZhemF0aSBlcsWRcmUgdmFuIGtpaGF0w6Fzc2FsIGF6IGFsa2FsbWF6w6FzYmFuLCDDrWd5IHN6YWLDoWx5b3puaSB0dWRvZCBhIHN6YXZhesOhc2kganV0YWxtYWlkLiA8YnIvPjxici8+PGI+TWVnamVneXrDqXM6PC9iPiBFeiBhIGxlc3phdmF6w6FzIHN6YXZhemF0aSBlcmVqw6l0L3N6w6F6YWzDqWvDoXQgaXMgbWVnIGZvZ2phIHbDoWx0b3p0YXRuaSDDqXMgbWluZGVuw7x0dCDDqXJ2w6lueWVzIGF6IGFsa2FsbWF6w6Fzb24gYmVsw7xsLlwiLFxuXHRcIlNFUlZFUlwiOiBcIlN6ZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIkFqw6FubG90dFwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlbDoWx0b3p0YXTDoXNvayBNZW50w6lzZVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiSW5mw7MgYSBzemF2YXrDs2tyw7NsXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiw5xkdiDDumpyYSFcIixcblx0XCJMT0dJTl8xXCI6IFwiQSBmb2x5dGF0w6FzaG96IGplbGVudGtlenogYmUgYSBmZWxoYXN6bsOhbMOzbmV2ZWRkZWwgw6lzIGplbHN6YXZhZGRhbC5cIixcblx0XCJMT0dJTl8yXCI6IFwiQSBwb3N6dG9sw7Mga3VsY3MgYSBwb3N6dG9raG96LCBob3p6w6FzesOzbMOhc29raG96LCBzemF2YXrDoXNob3ogw6lzIGvDtnZldMOpc2hleiBoYXN6bsOhbGF0b3MuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkF6IGFrdMOtdiBrdWxjcyBheiB1dGFsw6Fzb2tob3ogw6lzIGEgcHJvZmlsa8OpcCBmcmlzc8OtdMOpc8OpaGV6IGhhc3puw6FsYXRvcy5cIixcblx0XCJMT0dJTl80XCI6IFwiQSBmZWxoYXN6bsOhbMOzIGJlamVsZW50a2V6w6lzaSBhZGF0YWkgaGVseWlsZWcgdmFubmFrIHTDoXJvbHZhIGEga8Opc3rDvGzDqWtlbi4gS2lqZWxlbnRrZXrDqXNrb3IgYSBiZWplbGVudGtlesOpc2kgYWRhdG9rIGVsdMOhdm9sw610w7NkbmFrIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIk5pbmNzIG3DqWcgZmnDs2tvZD9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlJlZ2lzenRyw6FsaiBtb3N0XCIsXG5cdFwiQ0FOQ0VMXCI6IFwiTcOpZ3NlXCIsXG5cdFwiQURWQU5DRURcIjogXCJIYWxhZMOzXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkFrdMOtdiBwcml2w6F0IGt1bGNzXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJQb3N6dG9sw7MgcHJpdsOhdCBrdWxjc1wiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWVzdGVyL2bFkSBqZWxzesOzXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJGZWxoYXN6bsOhbMOzbsOpdlwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIkvDoXJ0eWEgbsOpemV0XCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiS29tcGFrdCBuw6l6ZXRcIixcblx0XCJTRUFSQ0hcIjogXCJLZXJlc8Opc1wiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiQ2lrayBiZWvDvGxkw6lzZVwiLFxuXHRcIlJFUExZVE9cIjogXCJWw6FsYXN6IG5la2lcIixcblx0XCJQT1NUXCI6IFwiUG9zenRcIixcblx0XCJQUkVWSUVXXCI6IFwiRWzFkW7DqXpldFwiLFxuXHRcIkRFRkFVTFRcIjogXCJBbGFww6lydGVsbWV6ZXR0IDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJGZWx0w7ZsdMOpcyAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJLaWZpemV0w6lzIEVsdXRhc8OtdMOhc2FcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIk1FTlTDiVMgS8OJU8WQQkJSRVwiLFxuXHRcIkNMRUFSXCI6IFwiVMOWUkzDiVNcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJUYXJ0YWxvbSBwb3N6dG9sw6FzYVwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkhvenrDoXN6w7Nsw6FzIHRhcnRhbG9taG96XCIsXG5cdFwiVElUTEVcIjogXCJDw61tXCIsXG5cdFwiVEFHU1wiOiBcIkPDrW1rw6lrXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTkVNIElMTElLIMOWU1NaRVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiUElOIG1lZ2VyxZFzw610w6lzZVwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIk5FTSBNRUdGRUxFTMWQXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwibnlpdMOzIHBvc3p0XCIsXG5cdFwiU0VUX1BJTlwiOiBcIlBJTiBiZcOhbGzDrXTDoXNhXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiUElOIG1lZ2Fkw6FzYVwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIkJpenRvcyB2YWd5IGJlbm5lP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiQSByZXN0ZWVtIHZpc3N6YXZvbmhhdGF0bGFuLCBiaXp0b3MgdmFneSBiZW5uZT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJUZXJqZXN6dMOpc2kgaGliYSwgcHLDs2LDoWxkIMO6anJhLlwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTaWtlclwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiw5pqcmFibG9nb2x0IHBvc3p0IVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJBIGJlbMOpcMOpcyBuZW0gc2lrZXLDvGx0ISBLw6lybGVrIGd5xZF6xZFkaiBtZWcgcsOzbGEsIGhvZ3kgYSBtZXN0ZXJqZWxzemF2YWRkYWwgbMOpcHTDqWwgYmUgdmFneSBtZWdhZHRhZCBhIFBvc3p0b2zDsyBwcml2w6F0IGt1bGNzb3QsIGhhIGEgSGFsYWTDsyBtw7Nkb3QgdsOhbGFzenRvdHRhZCBCZWplbGVudGtlesOpc2tvci5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJBIGJlbMOpcMOpcyBuZW0gc2lrZXLDvGx0ISBLw6lybGVrIGd5xZF6xZFkaiBtZWcgcsOzbGEsIGhvZ3kgYSBtZXN0ZXJqZWxzemF2YWRkYWwgbMOpcHTDqWwgYmUgdmFneSBtZWdhZHRhZCBheiBBa3TDrXYgcHJpdsOhdCBrdWxjc290LCBoYSBhIEhhbGFkw7MgbcOzZG90IHbDoWxhc3p0b3R0YWQgQmVqZWxlbnRrZXrDqXNrb3IuXCIsXG5cdFwiV0FSTklOR1wiOiBcIkZpZ3llbG1lenRldMOpc1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJTemF2YXrDoXMgdGFuw7pyYVwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiU3phdmF6dMOhbCB0YW7DunJhXCIsXG5cdFwiQUdPXCI6IFwiw7N0YVwiLFxuXHRcIkZST01fTk9XXCI6IFwibW9zdGFudMOzbFwiLFxuXHRcIlNFQ1NcIjogXCJtw6Fzb2RwZXJjXCIsXG5cdFwiQV9NSU5cIjogXCJlZ3kgcGVyY1wiLFxuXHRcIk1JTlNcIjogXCJwZXJjZWtcIixcblx0XCJBTl9IT1VSXCI6IFwiZWd5IMOzcmFcIixcblx0XCJIT1VSU1wiOiBcIsOzcmFcIixcblx0XCJBX0RBWVwiOiBcImVneSBuYXBcIixcblx0XCJEQVlTXCI6IFwibmFwb2tcIixcblx0XCJBX01PTlRIXCI6IFwiZWd5IGjDs25hcFwiLFxuXHRcIk1PTlRIU1wiOiBcImjDs25hcG9rXCIsXG5cdFwiQV9ZRUFSXCI6IFwiZWd5IMOpdlwiLFxuXHRcIllFQVJTXCI6IFwiw6l2ZWtcIixcblx0XCJNSU5fUkVBRFwiOiBcInBlcmMgb2x2YXPDoXNcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiTGVzemF2YXrDoXMgdmFneSBKZWxlbnTDqXNcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJLw6lwIEvDqXN6w610w6lzXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJLw6lwIEtpdsOhbGFzenTDoXNcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIkVneWVkaSBVUkwgQmXDoWxsw610w6FzXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJLw6lwIEJlaWxsZXN6dMOpc1wiLFxuXHRcIkVSUk9SXCI6IFwiSGliYVwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkZlbHTDtmx0w6lzaSBIaWJhXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkthbWVyYSBUw7Zyw7ZsdmVcIixcblx0XCJTRVRfVVJMXCI6IFwiVVJMIGJlw6FsbMOtdMOhc1wiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJEaXJla3Qgd2ViIGxpbmsgYSBrw6lwaGV6XCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJBIGhvesOhc3rDs2zDoXMgZWxrw7xsZHZlIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiQSBob3p6w6FzesOzbMOhc29rIHTDtnJsw6lzZSB2aXNzemF2b25oYXRhdGxhbi4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIlTDtnLDtmx0IGhvenrDoXN6w7Nsw6FzXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJLw6lwIGZlbHTDtmx0w6lzZVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJGZWx0w7ZsdMOpcyBLw6lzelwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJGZWx0w7ZsdMOpcyBNZWdoacO6c3VsdFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkEgamVsc3rDsyB2YWd5IGZlbGhhc3puw6Fsw7Nuw6l2IGhpYsOhcyB2b2x0XCIsXG5cdFwiSU5GT1wiOiBcIkluZsOzXCIsXG5cdFwiUVJfVEVYVFwiOiBcIkhlbHllenogZWd5IFFSLWvDs2RvdCBhIGxlb2x2YXPDoXNpIHRlcsO8bGV0YmVcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJHecWResWRZGogbWVnIHLDs2xhLCBob2d5IGVsZWdlbmTFkSBlZ3llbmxlZ2VkIHZhbiBheiB1dGFsw6FzaG96IVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJBIGZlbGhhc3puw6Fsw7MsIGFraW5layB1dGFsbmkgcHLDs2LDoWxzeiwgbmVtIGzDqXRlemlrIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJCaXp0b3MgdmFneSBiZW5uZSwgaG9neSB1dGFsbmkgYWthcnN6P1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIk1lZ2VyxZFzw610w6lzXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJBIHRyYW56YWtjacOzIGvDtnp2ZXTDrXR2ZVwiLFxuXHRcIkZFRURcIjogXCJIw61yZm9seWFtXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJOw6lwc3plcsWxXCIsXG5cdFwiSE9UXCI6IFwiRm9ycsOzXCIsXG5cdFwiTkVXXCI6IFwiw5pqXCIsXG5cdFwiUFJPTU9URURcIjogXCJUw6Ftb2dhdG90dFwiLFxuXHRcIlZPVEVTXCI6IFwiU3phdmF6YXRva1wiLFxuXHRcIlBBWU9VVFwiOiBcIktpZml6ZXTDqXNcIixcblx0XCJDT01NRU5UU1wiOiBcIkhvenrDoXN6w7Nsw6Fzb2tcIixcblx0XCJUUkVORElOR18zMFwiOiBcIk7DqXBzemVyxbEgMzAgbmFwcmFcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJQb3N6dG9rIHJlbmRlesOpc2U6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiS2lmaXpldMOpc2kgQ2lrbHVzXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIkxlaGV0c8OpZ2VzIEtpZml6ZXTDqXNcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlLDqWdpIEtpZml6ZXTDqXNcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiU3plcnrFkWkgS2lmaXpldMOpc1wiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkt1csOhdG9yaSBLaWZpemV0w6lzXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJBIHBvc3p0IGJla8O8bGR2ZSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiUG9zenQga8Opc8WRYmJpIGJla8O8bGTDqXNyZSFcIixcblx0XCJTQVZFRFwiOiBcIk1lbnR2ZVwiLFxuXHRcIkNMRUFSRURcIjogXCJUw7Zyw7ZsdmVcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiRWd5IHBvc3p0IGplbGVudMOpc2UgZWwgdHVkamEgdMOhdm9sw610YW5pIGEganV0YWxtYWthdCDDqXMga2V2w6lzYsOpIGzDoXRoYXTDs3bDoSB0ZXN6aSBlenQgYXogYW55YWdvdC48YnI+PGJyPkEgamVsZW50w6lzdCBhIGvDtnZldGtlesWRa3JlIGtlbGxlbmUgaGFzem7DoWxuaTogPHVsPjxsaT5Dc2Fsw6FzIHZhZ3kgUGxhZ2l6w6Fsw6FzPC9saT48bGk+R3nFsWzDtmxldCBiZXN6w6lkIHZhZ3kgSW50ZXJuZXQgVHJvbGxrb2TDoXM8L2xpPjxsaT5UdWRhdG9zYW4gZsOpbHJla2F0ZWdvcml6w6FsdCB0YXJ0YWxvbSB2YWd5IFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiS8OpcsOpc2kgbGltaXQgZWzDqXJ2ZS4gTsOpenogbWVnIG3DoXMgdHJlbmRldC9jw61ta8OpdCFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJBIHBvc3p0IGVsdMOhdm9sw610dmEgYSBrw7ZueXZqZWx6xZFrIGvDtnrDvGwhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIkEgcG9zenQgaG96esOhYWR2YSBhIGvDtm55dmplbHrFkWtow7Z6IVwiLFxuXHRcIlJFU0VUXCI6IFwiVmlzc3phw6FsbMOtdMOhc1wiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiUHJvZmlsa8OpcCBNw7Nkb3PDrXTDoXNhXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJCb3LDrXTDs2vDqXAgTcOzZG9zw610w6FzYVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIkvDqXJsZWsgYWRkIG1lZyBheiBBa3TDrXYgcHJpdsOhdCBrdWxjc290LCBoYSBhIEhhbGFkw7MgYmVsw6lww6lzaSBtw7Nkb3QgdsOhbGFzenRvdHRhZCFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJFeiB2aXNzemEgZm9namEgw6FsbMOtdGFuaSBhIHByb2ZpbGvDqXBldFwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIkV6IHZpc3N6YSBmb2dqYSDDoWxsw610YW5pIGEgYm9yw610w7Nrw6lwZXRcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkEgc3plcnZlciBmcmlzc8OtdMOpc2UgbWVna8O2dmV0ZWxpIGF6IMOaanJhaW5kw610w6FzdC5cIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiQmXDoWxsw610w6Fzb2sgZnJpc3PDrXR2ZSFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJOeWVsdmVrXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJJdHQgdHVkb2QgbWVndsOhbHRvenRhdG5pIGF6IGFsa2FsbWF6w6FzIG55ZWx2w6l0LlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJFeiBhIG3FsXZlbGV0IG1lZ2vDtnZldGVsaSwgaG9neSBhIGZlbGhhc3puw6Fsw7MgYSBmxZEgamVsc3phdsOhdmFsLCBha3TDrXYvcG9zenRvbMOzIGt1bGNzw6F2YWwgbGVneWVuIGJlamVsZW50a2V6dmUuIEvDqXJsZWsgbMOpcGogYmUgw6lzIHByw7Niw6FsZCDDumpyYS5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2Fsw6lyaWFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJBIGZvcmTDrXTDoXMga8O2enJlbcWxa8O2ZMWRaVwiLFxuXHRcIlNIQVJFXCI6IFwiTWVnb3N6dMOhc1wiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiUGlhY3TDqXJcIixcblx0XCJFWENIQU5HRVwiOiBcIlbDoWx0w7NcIixcblx0XCJEUkFGVFNcIjogXCJQaXN6a296YXRcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJBIGJlamVneXrDqXMgZWx0w6F2b2zDrXR2YSBhIHBpc3prb3phdG9rYsOzbCFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiQSBiZWplZ3l6w6lzIGhvenrDoWFkdmEgYSBwaXN6a296YXRva2hveiFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiQ3PDunN6dGFzcyBiYWxyYSBheiBvcGNpw7Nrw6lydFwiLFxuXHRcIk1BTkFHRVwiOiBcIktlemVsw6lzXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkvDqXAgdMO2csO2bHZlXCIsXG5cdFwiQ09QWVwiOiBcIk3DoXNvbMOhc1wiLFxuXHRcIk5PX0lNQUdFXCI6IFwiTcOpZyBuZW0gdMO2bHTDtnR0w6lsIGZlbCBzZW1taWx5ZW4ga8OpcGV0IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiSMO6emQgbGUgYSBmcmlzc8OtdMOpc2hlelwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJLw7xsc8WRIEFsa2FsbWF6w6Fzb2tcIixcblx0XCJQTFVHSU5TXCI6IFwiQmXDqXDDvGzFkWtcIixcblx0XCJTVUdHRVNUXCI6IFwiSmF2YXNvbFwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiSGFtYXJvc2FuIG1lZ2plbGVuaWtcIixcblx0XCJDSEFJTlwiOiBcIkzDoW5jXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkl0dCB0dWRzeiBibG9ra2zDoW5jb3QgdmFneSBhbGFww6lydGVsbWV6ZXR0IGZlbMO8bGV0ZXQgY3NlcsOpbG5pLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiUMOpbnpuZW1cIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiSXR0IHR1ZG9kIG1lZ3bDoWx0b3p0YXRuaSBheiBhbGFww6lydGVsbWV6ZXR0IHDDqW56bmVtZXQuIEViYmVuIGEgcMOpbnpuZW1iZW4gZm9nb2QgbMOhdG5pIGEgYmVqZWd5esOpc2VpZCBqdXRhbG1haXQuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+RnVua2Npw7MgbGlzdGE8L2I+PGJyPi0gRsOpcmogaG96esOhIGVneWVkaSBjaWtrZWtoZXogYsOhcm1pbHllbiB0w6ltw6FiYW4sIGFtaSBjc2FrIMOpcmRla2VsLjxicj4tIEtlcsO8bGoga8O2emVsZWJiIGEgc3plcnrFkWtow7Z6IGhvenrDoXN6w7Nsw6Fzb2trYWwsIGJlc3rDqWxnZXTDqXNla2tlbC48YnI+LSBTemF2YXp6IGJlamVneXrDqXNla3JlLCBob2d5IG1lZ2p1dGFsbWF6ZCBhIHN6ZXJ6xZFrZXQgw6lzIGVrw7Z6YmVuIGt1csOhdG9yaSBqdXRhbG1hdCBrYXBqLjxicj4tIFB1Ymxpa8OhbGQgYSBjaWtrZWlkIMOpcyBibG9nIHBvc3p0amFpZCwgdMOhcm9sZCDFkWtldCBpbmd5ZW4gw6lzIMOpcmogZWwganV0YWxtYWthdCBhenphbCwgaG9neSBrw7Z2ZXTFkWtldCBzemVyemVsIMOpcyBmb2dsYWxrb3pvbCB2ZWzDvGsuPGJyPi0gw41yaiBjaWtrZWtldCBtZW5ldCBrw7Z6YmVuLCBtZW50cyBlbCB0w7ZiYiBwaXN6a296YXRvdCBhIGvDqXPFkWJiaSBwdWJsaWvDoWNpw7Nob3ouPGJyPi0gS8O2bnl2amVsesWRemQgYSBrZWR2ZW5jIGNpa2tlaWQgYSBrw6lzxZFiYmkgb2x2YXPDoXNob3ouPGJyPi0gVsOhbHRzZCDDoXQgdmFneSB2ZWRkIGtpIGEgZml6ZXRzw6lnZWQuPGJyPi0gS8O8bGRqIHDDqW56dCBiw6FybWVseSBzemVyesWRbmVrLCBmZWxoYXN6bsOhbMOzbmFrLCBiYXLDoXRuYWssIGvDtnZldMWRbmVrLCBzdGIuPGJyPi0gS8O2dmVzcyDDqXJkZWtlcyBzemVyesWRa2V0LCBibG9nZ2VyZWtldC48YnI+LSBLZXJlc3MgcsOhIGEga8O2dmV0xZFpZHJlIMOpcyBheiDDoWx0YWxhZCBrw7Z2ZXRldHRla3JlLjxicj4tIEthcGogw6lydGVzw610w6lzZWtldCwgaG9neSBrYXBjc29sYXRiYW4gbWFyYWRoYXNzIGEga8O2dmV0xZFpZGRlbCDDqXMgYSBiZXN6w6lsZ2V0w6lzZWtrZWwsIGFtaWtiZW4gcsOpc3p0IHZlc3plbC48YnI+LSBLZXJlc3MgY2lra2VrZXQgw6lzIHN6ZXJ6xZFrZXQgw6lyZGVrZXMgY8OtbWvDqWsva2F0ZWfDs3Jpw6FrIGFsYXR0Ljxicj4tIFN6YWJkIHN6ZW3DqWx5cmUgYSBwcm9maWxvZGF0Ljxicj4tIMOJcyBtw6lnIHNvayDDumogZnVua2Npw7MgdsOhcmhhdMOzLjxicj48YnI+PGI+Qml6dG9uc8OhZzwvYj48YnI+MS4gQXogYWxrYWxtYXrDoXMgc29oYSBuZW0gZsOpciBob3p6w6EgYSBmZWxoYXN6bsOhbMOzIHDDqW56w6loZXouPGJyPjIuIEF6IGFsa2FsbWF6w6FzIGtsaWVucy1vbGRhbGkgaGl0ZWxlc8OtdMOpc3QgaGFzem7DoWwsIGEgcHJpdsOhdCBrdWxjc29rIGhlbHliZW4gdmFubmFrIHTDoXJvbHZhIMOpcyBzb2hhIG5lbSBrZXLDvGxuZWsgZWxrw7xsZMOpc3JlIHNlbW1pbHllbiBzemVydmVycmU7IHRlIHZhZ3kgYSBmZWxlbMWRcyBhIGplbHN6YXZhaWQgYml6dG9uc8OhZ2kgbWVudMOpc2Vpw6lydC48YnI+My4gQXogYWxrYWxtYXrDoXMgZWd5c3plcsWxLCB0ZXRzemV0xZFzIGZlbGhhc3puw6Fsw7NpIGZlbMO8bGV0ZXQgw6lzIMOpbG3DqW55dCBuecO6anQ8YnI+NC4gQXogYWxrYWxtYXrDoXMgZXh0cmEgYml6dG9uc8OhZ2kgcsOpdGVnZXQga8OtbsOhbCBhIFBJTi1rw7NkZGFsPGJyPjxicj5BeiBlU3RlZW0gdMOhbW9nYXRqYSBhIFN0ZWVtIMOpcyBhIEdvbG9zIHBsYXRmb3Jtb2thdC48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkFsYXDDrXTDsyDDqXMgVmV6ZXTFkSBmZWpsZXN6dMWRXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJGacOzayBob3p6w6FhZMOhc2FcIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtXCIsXG5cdFwiRVNDUk9XXCI6IFwiTGV0w6l0XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiTGV0w6l0aSDDvGd5bsO2a1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIk1lZ2VyxZFzw610w6lzaSBoYXTDoXJpZMWRXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJMZXTDqXQgbGVqw6FydGFcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiTGV0w6l0aSBkw61qXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiTGV0w6l0aSBmZWx0w6l0ZWxla1wiLFxuXHRcIk5JR0hUX01PREVcIjogXCLDiWpzemFrYWkgbcOzZFwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiTmFwcGFsaSBtw7NkXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiTXV0YXNkIHN6w7Z2ZWdrw7ZybnllemV0YmVuXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIkEgRmVsaGFzem7DoWzDsyBOZW0gVGFsw6FsaGF0w7NcIixcblx0XCJBUFBST1ZFXCI6IFwiSsOzdsOhaGFneVwiLFxuXHRcIkRJU1BVVEVcIjogXCJWaXRhXCIsXG5cdFwiUkVMRUFTRVwiOiBcIktpYWTDoXNcIixcblx0XCJGUk9NXCI6IFwiRmVsYWTDs1wiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJLw7xsZFwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiRm9nYWTDs1wiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiSGVseVwiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJvbGRhbFwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIk1lZ2plbGVuw610ZW5kxZEgbsOpdlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJCZXJhbmRhXCIsXG5cdFwiTE9HSU5cIjogXCJNYXN1a1wiLFxuXHRcIkxPR09VVFwiOiBcIktlbHVhclwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJJa3V0aVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlRhbmRhaVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiVHJhbnNmZXJcIixcblx0XCJNQVJLRVRcIjogXCJQYXNhclwiLFxuXHRcIlNFVFRJTkdTXCI6IFwiU2V0ZWxhblwiLFxuXHRcIkFCT1VUXCI6IFwiVGVudGFuZ1wiLFxuXHRcIkFCT1VUXzFcIjogXCJTaWFwYXB1biBiaXNhIG1lbmRhcGF0a2FuIGtldW50dW5nYW4gZGFyaSBrb250ZW5cIixcblx0XCJBQk9VVF8yXCI6IFwiQXBwbGlrYXNpIGRpYnVhdCBvbGVoXCIsXG5cdFwiQUJPVVRfM1wiOiBcImRhbiBpbmkgYWRhbGFoIG9wZW4gc291cmNlLCBwcm95ZWsgbW9iaWxlIGJlcmJhc2lzIG1hc3lhcmFrYXQuIEluaSBtZW5hd2Fya2FuIGFrc2VzIGtvbnRlbiB1bnR1ayBtZW1iYWNhLCBiZXJrb21lbnRhciwgdm90aW5nLCBwb3N0aW5nLCBtZW50cmFuc2ZlciBwZW5kYXBhdGFuLCBkbGwgZml0dXIgeWFuZyBkaXRhd2Fya2FuIG9sZWgge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGRhbiB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIEFwbGlrYXNpIHRpZGFrIHBlcm5haCBtZW5nYWtzZXMgYXRhdSBtZW1lZ2FuZyBkYW5hIHBlbmdndW5hLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBcGxpa2FzaSBtZW5hd2Fya2FuIG1vZGVsIGtlYW1hbmFuIGNsaWVudC1zaWRlLCBkZW5nYW4ga3VuY2kgcHJpYmFkaSBob3N0IHNlY2FyYSBsb2thbCBkYW4gdGlkYWsgcGVybmFoIGRpa2lyaW0ga2Ugc2VydmVyLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBcGxpa2FzaSBtZW5hd2Fya2FuIHNlZGVyaGFuYSwgdXNlciBpbnRlcmZhY2UgeWFuZyBtZW5hcmlrIGRhbiBwZW5nYWxhbWFuLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBBcGxpa2FzaSB0aWRhayBwZXJuYWggbWVuZ2hhcnVza2FuIHBlbmdndW5hIHVudHVrIG1lbWFzdWtrYW4gaW5mb3JtYXNpIHByaWJhZGkgYXBhcHVuLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJQaWxpaCBnb29kLWthcm1hIHNlYmFnYWkgd2l0bmVzc1wiLFxuXHRcIkFCT1VUXzlcIjogXCJLb250YWsvU2FyYW46XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJJbmZvIGxlYmloIGxhbmp1dDpcIixcblx0XCJSRU1PVkVcIjogXCJNZW5naGFwdXNcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIlBhc2FyXCIsXG5cdFwiUFJJQ0VcIjogXCJIYXJnYVwiLFxuXHRcIkFNT1VOVFwiOiBcIkp1bWxhaFwiLFxuXHRcIlRPVEFMXCI6IFwiSnVtbGFoXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJObyBvcGVuIG9yZGVyIHVudHVrXCIsXG5cdFwiREFURVwiOiBcIlRhbmdnYWxcIixcblx0XCJCVVlcIjogXCJCZWxpXCIsXG5cdFwiU0VMTFwiOiBcIkp1YWxcIixcblx0XCJPUEVOXCI6IFwiQnVrYVwiLFxuXHRcIkhJU1RPUllcIjogXCJSaXdheWF0XCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJNZW5naWt1dGkga2VtYmFsaVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiRGlpa3V0aVwiLFxuXHRcIlVORk9MTE9XXCI6IFwiQmVyaGVudGkgbWVuZ2lrdXRpXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiTWVuZ2lrdXRpXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiUGVuZ2lrdXRcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiTWVuY2FyaSBQZW5naWt1dFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJNZW5jYXJpIE1lbmdpa3V0aVwiLFxuXHRcIkJZXCI6IFwib2xlaFwiLFxuXHRcIklOXCI6IFwiZGFsYW1cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiQm9va21hcmtcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJVcHZvdGVcIixcblx0XCJET1dOVk9URVwiOiBcIkRvd252b3RlXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkJhdGFsa2FuIERvd252b3RlXFxuXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJCYXRhbGthbiBVcHZvdGVkXFxuXCIsXG5cdFwiUkVQTFlcIjogXCJCYWxhc1wiLFxuXHRcIkVESVRcIjogXCJFZGl0XCIsXG5cdFwiUE9TVF8xXCI6IFwiR2VzZXIga2Uga2lyaSBwYWRhIGtvbWVudGFyIHVudHVrIG1lbGloYXQgb3BzaVwiLFxuXHRcIlBPU1RfMlwiOiBcIktldHVrIHBhZGEga29tZW50YXIgdW50dWsgbWVsaWhhdCBzdWIta29tZW50YXJcIixcblx0XCJPUFRJT05TXCI6IFwiT3BzaVwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlc3RlZW1lZCBPbGVoXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiVGlkYWsgYWRhIGRpIHNpbmkuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlNhbGRvXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3tQbGF0Zm9ybW5hbWV9fSwgdG9rZW4gdHJhZGVhYmxlIHlhbmcgZGFwYXQgZGl0cmFuc2ZlciBrYXBhbiBzYWphLiB7e1BsYXRmb3JtbmFtZX19IGRhcGF0IGRpa29udmVyc2kga2Uge3trZWt1YXRhbiBwbGF0Zm9ybSB5YW5nfX0gZGFsYW0gcHJvc2VzIHlhbmcgZGlzZWJ1dCBwb3dlcmluZyB1cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e1BsYXRmb3JtcG93ZXJ9fSwgbWVtcGVuZ2FydWhpIHRva2VuIHlhbmcgbWVuZGFwYXRrYW4gbGViaWggYmFueWFrIGtla3VhdGFuIHVudHVrIG1lbWVnYW5nIGphbmdrYSBwYW5qYW5nIGRhbiBzdWFyYSBwYWRhIHBvc3RpbmcuIFNlbWFraW4gc2F0dSBtZW1lZ2FuZyBsZWJpaCBzYXR1IGRhcGF0IG1lbXBlbmdhcnVoaSBpbWJhbGFuIGxhaW4gZGFuIG1lbmRhcGF0a2FuIGltYmFsYW4gdW50dWsgdm90aW5nIGFrdXJhdC5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbiBiZXJuaWxhaSBzZWtpdGFyIHt7cGxhdGZvcm1zdW5pdH19IGRhcmkge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJQZXJraXJhYW4gTmlsYWlcIixcblx0XCJQUk9GSUxFXzRcIjogXCJOaWxhaSBlc3RpbWFzaSBpbmkgZGlkYXNhcmthbiBwYWRhIG5pbGFpIHJhdGEtcmF0YSA3IGhhcmkge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiU2VqYXJhaCBUcmFuc2Frc2lcIixcblx0XCJQT1NUSU5HXCI6IFwiUG9zdGluZ2FuXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiS3VuY2kgcG9zdGluZ2FuIGRpZ3VuYWthbiB1bnR1ayBwb3N0aW5nIGRhbiB2b3RpbmcuIEluaSBoYXJ1cyBiZXJiZWRhIGRhcmkgdG9tYm9sIGFrdGlmIGRhbiBwZW1pbGlrLlwiLFxuXHRcIk9XTkVSXCI6IFwiUGVtaWxpa1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkt1bmNpIHBlbWlsaWsgYWRhbGFoIGt1bmNpIG1hc3RlciB1bnR1ayBhY2NvdW50IGRhbiBkaXBlcmx1a2FuIHVudHVrIG1lbmd1YmFoIGt1bmNpIGxhaW5ueWEuIEt1bmNpIHByaWJhZGkgYXRhdSBwYXNzd29yZCB1bnR1ayBrdW5jaSBwZW1pbGlrIGhhcnVzIGRpc2ltcGFuIHNlY2FyYSBvZmZsaW5lIHNlYmFueWFrIG11bmdraW4uXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0aWZcIixcblx0XCJQUk9GSUxFXzdcIjogXCJLdW5jaSBha3RpZiBkaWd1bmFrYW4gdW50dWsgbWVsYWt1a2FuIHRyYW5zZmVyIGRhbiB0ZW1wYXQgb3JkZXIgZGkgcGFzYXIgaW50ZXJuYWwuXCIsXG5cdFwiTUVNT1wiOiBcIk1lbW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJLdW5jaSBtZW1vIGRpZ3VuYWthbiB1bnR1ayBtZW1idWF0IGRhbiBtZW1iYWNhIG1lbW8uXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIlBvc3RcIixcblx0XCJSRVBMSUVTXCI6IFwiQmFsYXNhblwiLFxuXHRcIldBTExFVFwiOiBcIkRvbXBldFwiLFxuXHRcIlRBR1wiOiBcIlRhZ1wiLFxuXHRcIlVTRVJcIjogXCJQZW5nZ3VuYVwiLFxuXHRcIkNMT1NFXCI6IFwiVHV0dXBcIixcblx0XCJUT1wiOiBcIktlcGFkYVwiLFxuXHRcIkFTU0VUXCI6IFwiQXNldFwiLFxuXHRcIlNFTkRcIjogXCJLaXJpbVwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiS2VhbWFuYW5cIixcblx0XCJBVkFJTEFCTEVcIjogXCJUZXJzZWRpYVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTWVtbyBwdWJsaWtcIixcblx0XCJUT19ERVNDXCI6IFwiUGVuZ2d1bmEgbWlzYWxueWEgZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiS29kZSBQaW5cIixcblx0XCJQSU5fVEVYVFwiOiBcIktvZGUgUElOIG1lbWJhbnR1IEFuZGEgdW50dWsgbWVuZ2FtYW5rYW4gYXBsaWthc2kgZGFuIGRhdGEgQW5kYS4gPGJyLz48YnIvPiA8Yj5DYXRhdGFuOjwvYj4gU2V0ZWxhaCBkaWFrdGlma2FuLCBBbmRhIG1lbWlsaWtpIG1heCA0IG1lbmNvYmEgdW50dWsgbWVtYnVrYSwgamlrYSBBbmRhIGx1cGEgcGluIGF0YXUgZ2FnYWwsIGFwbGlrYXNpIGFrYW4gaGFwdXMgbG9naW4gZGF0YSBwZW5nZ3VuYS4gQW5kYSBkYXBhdCBsb2dpbiBrZW1iYWxpIGRhbiB0ZXJ1cyBtZW5nZ3VuYWthbiBhcGxpa2FzaS5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpa2FzaVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3JhbmcgbWVtYmVyaWthbiBzdWFyYSBrb250ZW4gQW5kYSEgPGJyLz4gPGI+Q2F0YXRhbjo8L2I+IFBlbWJlcml0YWh1YW4gdGVybWFzdWsgc3VhcmEgYmVyYXQgc2VydGEgZGFsYW0gcGVzYW4gcGVyaW5nYXRhbi4gKEJhaWsgaXR1IHVwLXZvdGUsIGRvd24tdm90ZSwgdW4tdm90ZSkuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGluZ1wiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3Jhbmcga29tZW50YXIgcGFkYSBwb3N0aW5nIGF0YXUga29tZW50YXIhPGJyLz4gPGI+Q2F0YXRhbjo8L2I+IFBlbWJlcml0YWh1YW4gdGVybWFzdWsga2V0aWthIHNlc2VvcmFuZyA8Yj5TdW50aW5nPC9iPiBrb21lbnRhciBtZXJla2EganVnYS5cIixcblx0XCJDT01NRU5UXCI6IFwiS29tZW50YXJcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3JhbmcgRm9sbG93IGF0YXUgVW5mb2xsb3cgQW5kYSFcIixcblx0XCJNRU5USU9OU1wiOiBcIk1lbnllYnV0a2FuXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBwZW1iZXJpdGFodWFuIGJpbGEgc2VzZW9yYW5nIG1lbnllYnV0a2FuIEFuZGEgZGFsYW0gcG9zdGluZ2FuIG1lcmVrYS9rb21lbnRhciFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiQW5kYSBha2FuIG1lbmRhcGF0a2FuIG5vdGlmaWthc2kga2V0aWthIHNlc2VvcmFuZyByZWJsb2dzIHBvc3RpbmcgQW5kYSFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3VyYXNpXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90aW5nXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJLZWt1YXRhbiBWb3RpbmcgYXRhdSBwZXJzZW50YXNlIG1lbXBlbmdhcnVoaSBoYWsgc3VhcmEgcGFkYSBhcGxpa2FzaSwgc2VoaW5nZ2EgQW5kYSBkYXBhdCBtZW5nYXR1ciByZXdhcmQgVm90aW5nIEFuZGEuIDxici8+PGJyLz48Yj5DYXRhdGFuOjwvYj4gaW5pIGFrYW4gbWVuZ3ViYWgga2VrdWF0YW4gdm90aW5nL3BlcnNlbnRhc2UgdW50dWsgZG93bnZvdGluZyBqdWdhIGRhbiBpdHUgYWRhbGFoIGRpIG1hbmEtbWFuYSBwYWRhIGFwbGlrYXNpXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJEaXJla29tZW5kYXNpa2FuXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2ltcGFuIHBlcnViYWhhblwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiVm90ZXJzIGluZm9cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJTZWxhbWF0IERhdGFuZyBrZW1iYWxpIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJNYXN1ayBkZW5nYW4gbmFtYSBwZW5nZ3VuYSBkYW4gcGFzc3dvcmQgdW50dWsgbWVsYW5qdXRrYW4uXCIsXG5cdFwiTE9HSU5fMlwiOiBcIlBvc3Rpbmcga3VuY2kgZGlndW5ha2FuIHVudHVrIHBvc3RpbmcsIGtvbWVudGFyLCB2b3RpbmcsIGZvbGxvdy5cIixcblx0XCJMT0dJTl8zXCI6IFwiQWN0aXZlIGt1bmNpIGRpZ3VuYWthbiB1bnR1ayB0cmFuc2ZlciBkYW4gbWVtcGVyYmFydWkgZ2FtYmFyIHByb2ZpbC5cIixcblx0XCJMT0dJTl80XCI6IFwia3JlZGVuc2lhbCBwZW5nZ3VuYSBkaXNpbXBhbiBzZWNhcmEgbG9rYWwgcGFkYSBwZXJhbmdrYXQuIFNldGVsYWggS2VsdWFyIGtyZWRlbnNpYWwgZGloYXB1cyFcIixcblx0XCJET05UX0hBVkVcIjogXCJUaWRhayBtZW1pbGlraSBha3VuP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiRGFmdGFyIFNla2FyYW5nXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQmF0YWxcIixcblx0XCJBRFZBTkNFRFwiOiBcIkxhbmp1dGFuXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkt1bmNpIGFrdGlmIHByaWJhZGlcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIkt1bmNpIFBvc3RpbmcgUHJpYmFkaVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVyL3Bhc3N3b3JkIHV0YW1hXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJOYW1hIFBlbmdndW5hXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiTGloYXQga2FydHVcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJDb21wYWN0IFZpZXdcIixcblx0XCJTRUFSQ0hcIjogXCJDYXJpXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJNYXN1a2thbiBjZXJpdGFcIixcblx0XCJSRVBMWVRPXCI6IFwiQmFsYXMga2VcIixcblx0XCJQT1NUXCI6IFwicG9zdGluZ1wiLFxuXHRcIlBSRVZJRVdcIjogXCJUaW5qYXVhblwiLFxuXHRcIkRFRkFVTFRcIjogXCJEZWZhdWx0IDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJQb3dlciBVcCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJNZW5vbGFrIHBlbWJheWFyYW5cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNJTVBBTiBVTlRVSyBOQU5USVwiLFxuXHRcIkNMRUFSXCI6IFwiQkVSU0lIS0FOXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiUG9zdGluZyBrb250ZW5cIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJLb250ZW4ga29tZW50YXJcIixcblx0XCJUSVRMRVwiOiBcIkp1ZHVsXCIsXG5cdFwiVEFHU1wiOiBcIlRhZ3NcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJUSURBSyBDT0NPS1wiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiS29uZmlybWFzaSBQaW5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJTQUxBSFwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIlBvc3QgcGVtYnVrYWFuXCIsXG5cdFwiU0VUX1BJTlwiOiBcIkF0dXIgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiTWFzdWthbiBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJBcGFrYWggYW5kYSB5YWtpbj9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZyBpcmV2ZXJzaWJlbCwgYXBha2FoIEFuZGEgaW5naW4gbWVsYW5qdXRrYW4/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiU2lhcmFuIGVycm9yLCBjb2JhIGxhZ2khXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlN1a3Nlc1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUmVibG9nZ2VkIHBvc3QhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkdhZ2FsIG1hc3VrISBQYXN0aWthbiBBbmRhIHRlbGFoIGxvZ2luIGRlbmdhbiBwYXNzd29yZCBtYXN0ZXIgYXRhdSB0ZXJzZWRpYSBQb3N0aW5nIGt1bmNpIHByaWJhZGkgcGFkYSBMb2dpbiBqaWthIEFuZGEgdGVsYWggY2hvb3NlZCBtb2RlIEFkdmFuY2VkLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkdhZ2FsIG1hc3VrISBQYXN0aWthbiBBbmRhIHRlbGFoIGxvZ2luIGRlbmdhbiBwYXNzd29yZCBtYXN0ZXIgYXRhdSBkaXNlZGlha2FuIGt1bmNpIHByaWJhZGkgQWt0aWYgZGkgTG9naW4gamlrYSBBbmRhIHRlbGFoIG1lbWlsaWggbW9kZSBBZHZhbmNlZC5cIixcblx0XCJXQVJOSU5HXCI6IFwiUGVyaW5nYXRhblwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RpbmcgdW50dWsgd2l0bmVzc1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiVm90ZWQgdW50dWsgd2l0bmVzc1wiLFxuXHRcIkFHT1wiOiBcImxhbHVcIixcblx0XCJGUk9NX05PV1wiOiBcImRhcmkgc2VrYXJhbmdcIixcblx0XCJTRUNTXCI6IFwiZGV0aWtcIixcblx0XCJBX01JTlwiOiBcInNlbWVuaXRcIixcblx0XCJNSU5TXCI6IFwibWVuaXRcIixcblx0XCJBTl9IT1VSXCI6IFwic2VqYW1cIixcblx0XCJIT1VSU1wiOiBcImphbVwiLFxuXHRcIkFfREFZXCI6IFwic2VoYXJpXCIsXG5cdFwiREFZU1wiOiBcImhhcmlcIixcblx0XCJBX01PTlRIXCI6IFwic2VidWxhblwiLFxuXHRcIk1PTlRIU1wiOiBcImJ1bGFuXCIsXG5cdFwiQV9ZRUFSXCI6IFwic2V0YWh1blwiLFxuXHRcIllFQVJTXCI6IFwidGFodW5cIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbiBiYWNhXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIkRvd252b3RlIGF0YXUgYmVuZGVyYVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIkFtYmlsIEdhbWJhclwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiUGlsaWggR2FtYmFyXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJNZW5ldGFwa2FuIFVSTCBrdXN0b21cIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIk1hc3VrYW4gR2FtYmFyXCIsXG5cdFwiRVJST1JcIjogXCJrZXNhbGFoYW5cIixcblx0XCJVUExPQURfRVJST1JcIjogXCJrZXNhbGFoYW4gTWVuZ3VwbG9hZCBcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiS2FtZXJhIERpYmF0YWxrYW5cIixcblx0XCJTRVRfVVJMXCI6IFwiTWVuZXRhcGthbiBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWN0IHdlYiBsaW5rIHV0dWsgR2FtYmFyXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJLb21lbnRhciBkaXNhbXBhaWthbiFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIk1lbmdoYXB1cyBrb21lbnRhciBhZGFsYWggaXJldmVyc2liZWwuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJNZW5naGFwdXMga29tZW50YXJcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlVwbG9hZCBHYW1iYXJcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiVXBsb2FkIFNlbGVzYWlcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiVXBsb2FkIEdhZ2FsXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiUGFzc3dvcmQgYXRhdSBuYW1hIGFrdW4gdGlkYWsgYmVuYXJcIixcblx0XCJJTkZPXCI6IFwiSW5mb1wiLFxuXHRcIlFSX1RFWFRcIjogXCJUZW1wYXRrYW4ga29kZSBRUiBkaSBkYWxhbSBhcmVhIHBpbmRhaVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIlBhc3Rpa2FuIEFuZGEgbWVtaWxpa2kgc2FsZG8geWFuZyBjdWt1cCB1bnR1ayB0cmFuc2Frc2khXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlBlbmdndW5hIHlhbmcgQW5kYSBjY29iYSB1bnR1ayBtZW50cmFuc2ZlciBkYW5hLCB0aWRhayBhZGEhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIkFwYWthaCBBbmRhIHlha2luIEFuZGEgaW5naW4gbWVudHJhbnNmZXI/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiS29uZmlybWFzaVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNha3NpIGRpc2lhcmthblwiLFxuXHRcIkZFRURcIjogXCJVbXBhblwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRpbmdcIixcblx0XCJIT1RcIjogXCJIb3RcIixcblx0XCJORVdcIjogXCJCYXJ1XCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3NpXCIsXG5cdFwiVk9URVNcIjogXCJWb3RlXCIsXG5cdFwiUEFZT1VUXCI6IFwiRGliYXlhclwiLFxuXHRcIkNPTU1FTlRTXCI6IFwiS29tZW50YXJcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5kaW5nIDMwIEhhcmlcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJVcnV0a2FuIFBvc3RpbmdhbjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJTaWtsdXMgcGVtYmF5YXJhblwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQb3RlbnNpIFBlbWJheWFyYW5cIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlBlbWJheWFyYW4gdGVyYWtoaXJcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiUGVtYmF5YXJhbiBQZW51bGlzXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUGVtYmF5YXJhbiBLdXJhc2lcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIlBvc3QgZGl0YXlhbmdrYW4hXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlBvc3RpbmcgdW50dWsgZGlhanVrYW4gbmFudGkhXCIsXG5cdFwiU0FWRURcIjogXCJEaXNpbXBhblwiLFxuXHRcIkNMRUFSRURcIjogXCJEaWJlcnNpaGthblwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJGbGFnZ2luZyBwb3N0aW5nYW4gZGFwYXQgbWVuZ2hhcHVzIGltYmFsYW4gZGFuIG1lbWJ1YXQgYmFoYW4gaW5pIGt1cmFuZyB0ZXJsaWhhdCA8YnI+IGJlbmRlcmEgaGFydXMgZGlndW5ha2FuIHVudHVrIGJlcmlrdXQ6IDx1bD48bGk+UGVuaXB1YW4gYXRhdSBQbGFnaWFyaXNtZTwvbGk+PGxpPkthdGEga2FzYXIgYXRhdSBJbnRlcm5ldCBUcm9sbGluZyA8L2xpPjxsaT5Lb250ZW4gRGlzZW5nYWphIGRpa2F0ZWdvcmlrYW4gYXRhdSBTcGFtPC9saT4gPC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJCYXRhcyBwZXJtaW50YWFuIHRlcmNhcGFpLiBMaWhhdCB0cmVuL3RhZyBsYWlubnlhIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIlBvc3RpbmcgZGloaWxhbmdrYW4gZGFyaSBib29rbWFyayFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiUG9zdGluZyBkaXRhbWJhaGthbiBrZSBib29rbWFyayFcIixcblx0XCJSRVNFVFwiOiBcIlNldGVsIFVsYW5nXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJNb2RpZmlrYXNpIGdhbWJhciBQcm9maWxcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1lbW9kaWZpa2FzaSBTYW1wdWwgZ2FtYmFyXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiSGFyYXAgbWVtYmVyaWthbiBrdW5jaSBwcmliYWRpIEFjdGl2ZSBqaWthIEFuZGEgdGVsYWggbWVtaWxpaCBtb2R1cyBtYXN1ayBMYW5qdXRhbiFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJJbmkgYWthbiBtZW55ZXRlbCB1bGFuZyBnYW1iYXIgcHJvZmlsXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiSW5pIGFrYW4gbWVyZXNldCBnYW1iYXIgc2FtcHVsXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJVcGRhdGUgc2VydmVyIG1lbWVybHVrYW4gUmVzdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiUGVuZ2F0dXJhbiBkaXBlcmJhcnVpIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkJhaGFzYVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiRGkgc2luaSBBbmRhIGRhcGF0IG1lbmd1YmFoIGJhaGFzYSBhcGxpa2FzaS5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiT3BlcmFzaSBpbmkgbWVuZ2hhcnVza2FuIHBlbmdndW5hIHVudHVrIGxvZ2luIGRlbmdhbiBwYXNzd29yZCB1dGFtYSwgYWt0aWYvcG9zdGluZ2FuIGt1bmNpLiBTaWxhaGthbiBsb2dpbiBkYW4gY29iYSBsYWdpLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxlcmlcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJLb250cmlidXRvciB0ZXJqZW1haGFuXCIsXG5cdFwiU0hBUkVcIjogXCJCYWdpa2FuXFxuXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJQYXNhclwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiUGVydHVrYXJhblwiLFxuXHRcIkRSQUZUU1wiOiBcImRyYWZ0XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiUG9zdGluZyBha2FuIGRpaGFwdXMgZGFyaSBkcmFmdCFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiUG9zdGluZyBkaXRhbWJhaGthbiBrZSBkcmFmdCFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiR2VzZXIga2Uga2lyaSB1bnR1ayBtZWxpaGF0IG9wc2lcIixcblx0XCJNQU5BR0VcIjogXCJNZW5nZWxvbGFcXG5cIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiR2FtYmFyIGRpaGFwdXNcIixcblx0XCJDT1BZXCI6IFwiY29weVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiQW5kYSBiZWx1bSBtZW5ndW5nZ2FoIGdhbWJhciBhcGFwdW4sIGJlbHVtIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiVGFyaWsga2UgYmF3YWggdW50dWsgbWVueWVnYXJrYW5cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiXFxuIEV4dGVybmFsIEFwcHNcIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Z2luc1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTYXJhblwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiU2VnZXJhIGhhZGlyXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblxcblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJEaSBzaW5pIEFuZGEgZGFwYXQgbWVuZ3ViYWggYmxvY2tjaGFpbiBhdGF1IHBsYXRmb3JtIGRlZmF1bHQuXFxuQ2hhaW5fVGV4dFwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiTWF0YSB1YW5nXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkRpIHNpbmkgQW5kYSBkYXBhdCBtZW5ndWJhaCBtYXRhIHVhbmcgZGVmYXVsdCBBbmRhLiBBbmRhIGFrYW4gbWVsaWhhdCBuaWxhaSBoYWRpYWggcG9zdGluZy9rb21lbnRhciBwYWRhIG1hdGEgdWFuZyBpbmkuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+RGFmdGFyIGZpdHVyPC9iPiA8YnI+LWFrc2VzIHVuaWsgYXJ0aWtlbCBkYWxhbSBzdWJqZWsgQW5kYSB0ZXJ0YXJpayBtZW1iYWNhLiA8YnI+IC1UZXJsaWJhdCBkZW5nYW4gcGVudWxpcyBkZW5nYW4ga29tZW50YXIsIG1lbWJhaGFzIHRvcGlrLiA8YnI+LVZvdGluZyB1bnR1ayBwb3N0aW5nIGtlIHBlbnVsaXMgaGFkaWFoIHNlcnRhIG1lbmRhcGF0a2FuIHBhaGFsYSBwZW5na3VyYXNpYW4uIDxicj4tUHVibGlzaCBhcnRpa2VsLCBwb3N0aW5nIGJsb2cgZGFuIGhvc3QgbWVyZWthIHNlY2FyYSBncmF0aXMgZGFuIG1lbmRhcGF0a2FuIGltYmFsYW4gZGVuZ2FuIG1lbGliYXRrYW4gZGFuIG1lbmRhcGF0a2FuIHBlbmdpa3V0LiA8YnI+LU1lbnVsaXMgYXJ0aWtlbCB0ZW50YW5nIHBlcmdpLCBtZW55aW1wYW4gZHJhZiBiZWJlcmFwYSBwb3N0aW5nIHVudHVrIGtlbXVkaWFuIHB1Ymxpa2FzaS4gPGJyPi1Cb29rbWFyayBmYXZvcml0IGFydGlrZWwgdW50dWsgZGliYWNhIG5hbnRpLiA8YnI+LUV4Y2hhbmdlIGF0YXUgdWFuZyB0dW5haSBwZW5naGFzaWxhbiBBbmRhLiA8YnI+LU1lbmdpcmltIGRhbmEga2VwYWRhIHBlbnVsaXMgYXRhdSBwZW5nZ3VuYSwgdGVtYW5tdSwgcGVuZ2lrdXRtdSwgZGxsIDxicj4taWt1dGkgbWVuYXJpayBwZW51bGlzLCBibG9nZ2VyLiA8YnI+IC1DYXJpIHBlbmdpa3V0bnlhIGRhbiBwZW51bGlzIEFuZGEgbWVuZ2lrdXRpIEFuZGEuIDxicj4tR2V0IHBlbWJlcml0YWh1YW4gdW50dWsgdGV0YXAgYmVyaHVidW5nYW4gZGVuZ2FuIHBlbmdpa3V0IEFuZGEgZGFuIGRpc2t1c2kgQW5kYSB5YW5nIHRlcmxpYmF0IGluLiA8YnI+LXBlbmNhcmlhbiB1bnR1ayBtZW5hcmlrIHRhZ3MvS2F0ZWdvcmkgYXJ0aWtlbCwgcGVudWxpcy4gPGJyPiAtTWVtcGVyc29uYWxpc2FzaWthbiBwcm9maWwgQW5kYS4gPGJyPi1CYW55YWsgbGViaWggYmFueWFrIGZpdHVyIHVudHVrIGRhdGFuZy4gPGJyPjxicj48Yj5LZWFtYW5hbjwvYj4gPGJyPjEuIEFwcCB0aWRhayBwZXJuYWggbWVuZ2Frc2VzIGF0YXUgbWVtZWdhbmcgcGVuZ2d1bmEgZGFuYS4gPGJyPjIuIGFwcCBtZW5hd2Fya2FuIG1vZGVsIGtlYW1hbmFuIHNpc2kga2xpZW4gZGVuZ2FuIHByaXZhdGUga2V5IGhvc3Qgc2VjYXJhIGxva2FsIGRhbiB0aWRhayBwZXJuYWggZGlraXJpbWthbiBrZSBzZXJ2ZXIgYXBhcHVuLCBBbmRhIGJlcnRhbmdndW5nIGphd2FiIHVudHVrIG1lbWJ1YXQgY2FkYW5nYW4gcGFzc3dvcmQgQW5kYS4gPGJyPjMuIGFwcCBtZW5hd2Fya2FuIGFudGFybXVrYSBwZW5nZ3VuYSB5YW5nIHNlZGVyaGFuYSwgbWVuYXJpayBkYW4gcGVuZ2FsYW1hbiA8YnI+NC4gQXBwIG1lbmF3YXJrYW4gbGFwaXNhbiB0YW1iYWhhbiBrZWFtYW5hbiBkZW5nYW4ga29kZSBwaW4gPGJyPjxicj5oYXJnYSBtZW5kdWt1bmcgcGxhdGZvcm0gU3RlZW0gZGFuIEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIlBlbmRpcmkgZGFuIHBlbmdlbWJhbmdcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIlRhbWJhaCBha3VuXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0Zm9ybVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkFnZW4gZXNjcm93XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUmF0aWZpa2FzaSB0ZW5nZ2F0IHdha3R1XCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cga2FkYWx1YXJzYVwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgYmlheWFcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgcGVyc3lhcmF0YW5cIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTW9kZSBtYWxhbVwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiTW9kZSBTaWFuZ1wiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIkxpaGF0IGtvbnRla3MgbGVuZ2thcFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJQZW5nZ3VuYSB0aWRhayBkaXRlbXVrYW5cIixcblx0XCJBUFBST1ZFXCI6IFwiRGlzZXR1anVpXCIsXG5cdFwiRElTUFVURVwiOiBcIlNlbmdrZXRhXCIsXG5cdFwiUkVMRUFTRVwiOiBcIlJpbGlzXCIsXG5cdFwiRlJPTVwiOiBcIkRhcmlcIixcblx0XCJJRFwiOiBcImlkXCIsXG5cdFwiU1VCTUlUXCI6IFwiU3VibWl0XCIsXG5cdFwiUkVDRUlWRVJcIjogXCJQZW5lcmltYVwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9rYXNpXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYnNpdGVcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJOYW1hIHRhbXBpbGFuXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIlBhZ2luYSBJbml6aWFsZVwiLFxuXHRcIkxPR0lOXCI6IFwiQWNjZWRpXCIsXG5cdFwiTE9HT1VUXCI6IFwiRXNjaVwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxvXCIsXG5cdFwiRk9MTE9XXCI6IFwiQ2hpIFNlZ3VpXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiUHJlZmVyaXRpXCIsXG5cdFwiVFJBTlNGRVJcIjogXCJUcmFzZmVyaW1lbnRpXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWVyY2F0b1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwiSW1wb3N0YXppb25pXCIsXG5cdFwiQUJPVVRcIjogXCJJbmZvXCIsXG5cdFwiQUJPVVRfMVwiOiBcImRvdmUgY2hpdW5xdWUgcHXDsiBndWFkYWduYXJlIHJpY29tcGVuc2UgcGVyIGkgcHJvcHJpIGNvbnRlbnV0aSFcIixcblx0XCJBQk9VVF8yXCI6IFwiw6ggb2ZmZXJ0byBkYWxsYSBwaWF0dGFmb3JtYSB7e3BsYXRmb3JtbmFtZX19LiBMJ2FwcCDDqCBjcmVhdGEgZGFcIixcblx0XCJBQk9VVF8zXCI6IFwiZWQgw6ggdW4gcHJvZ2V0dG8gcGVyIGRpc3Bvc2l0aXZpIG1vYmlsaSwgb3Blbi1zb3VyY2UgZSBwb3J0YXRvIGF2YW50aSBkYWxsYSBjb21tdW5pdHkuIE9mZnJlIGwnYWNjZXNzbyBwZXIgbGEgbGV0dHVyYSwgaWwgY29tbWVudG8sIGlsIHZvdG8sIGUgbGEgcHViYmxpY2F6aW9uZSBkaSBjb250ZW51dGkuIENhcmF0dGVyaXN0aWNoZSBvZmZlcnRlIGRhbGxhIHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiBlIGRhIHt7c2l0ZW5hbWV9fVwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBMJ2FwcCBub24gaGEgbWFpIGwnYWNjZXNzbyBuw6ggaWwgY29udHJvbGxvIHN1aSBmb25kaSBkZWxsJ3V0ZW50ZS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gTCdhcHAgb2ZmcmUgdW4gbW9kZWxsbyBkaSBzaWN1cmV6emEgXFxcImxhdG8gY2xpZW50ZVxcXCIsIGdyYXppZSBhbGxlIGNoaWF2aSBwcml2YXRlIG1lbW9yaXp6YXRlIGxvY2FsbWVudGUgZSBtYWkgdHJhc21lc3NlIGFkIGFsY3VuIHNlcnZlci5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gTCdhcHAgb2ZmcmUgdW4nZXNwZXJpZW56YSBlIHVuJ2luZmVyZmFjY2lhIGdyYWZpY2Egc2VtcGxpY2UgZSBhdHRyYWVudGUuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIEwnYXBwIG5vbiByaWNoaWVkZSBtYWkgbCdpbnNlcmltZW50byBkaSBpbmZvcm1hemlvbmkgcGVyc29uYWxpIGRhIHBhcnRlIGRlbGwndXRlbnRlXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlZvdGEgZ29vZC1rYXJtYSBjb21lIHRlc3RpbW9uaWFsXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhdHRpL0ZlZWRiYWNrOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTWFnZ2lvcmkgaW5mb3JtYXppb25pOlwiLFxuXHRcIlJFTU9WRVwiOiBcIkVsaW1pbmFcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIk1lcmNhdG9cIixcblx0XCJQUklDRVwiOiBcIlByZXp6b1wiLFxuXHRcIkFNT1VOVFwiOiBcIkltcG9ydG9cIixcblx0XCJUT1RBTFwiOiBcIlRvdGFsZVwiLFxuXHRcIk5PT1JERVJTXCI6IFwiTmVzc3VuIG9yZGluZSBhcGVydG9cIixcblx0XCJEQVRFXCI6IFwiRGF0YVwiLFxuXHRcIkJVWVwiOiBcIkNvbXByYVwiLFxuXHRcIlNFTExcIjogXCJWZW5kaVwiLFxuXHRcIk9QRU5cIjogXCJBcHJpXCIsXG5cdFwiSElTVE9SWVwiOiBcIkNyb25vbG9naWFcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlNlZ3VpXCIsXG5cdFwiRk9MTE9XRURcIjogXCJTZWd1aXRvXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJTbWV0dGkgZGkgc2VndWlyZVwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIlNlZ3VpdG9cIixcblx0XCJGT0xMT1dFUlNcIjogXCJGb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiQ2VyY2EgdHJhIGkgdHVvaSBmb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiQ2VyY2EgdHJhIGNoaSBzZWd1aVwiLFxuXHRcIkJZXCI6IFwiZGFcIixcblx0XCJJTlwiOiBcImluXCIsXG5cdFwiTUVOVVwiOiBcIk1lbnVcIixcblx0XCJCT09LTUFSS1wiOiBcIkFnZ2l1bmdpIGFpIHByZWZlcml0aVwiLFxuXHRcIlJFQkxPR1wiOiBcIkNvbmRpdmlkaVwiLFxuXHRcIlVQVk9URVwiOiBcIlZvdGFcIixcblx0XCJET1dOVk9URVwiOiBcIkRpc2FwcHJvdmFcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiUmltdW92aSBEb3dudm90ZVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiUmltdW92aSBVcHZvdGVcIixcblx0XCJSRVBMWVwiOiBcIlJpc3BvbmRpXCIsXG5cdFwiRURJVFwiOiBcIk1vZGlmaWNhXCIsXG5cdFwiUE9TVF8xXCI6IFwiU3dpcGUgYSBzaW5pc3RyYSBzdWkgY29tbWVudGkgcGVyIHZpc3VhbGl6emFyZSBsZSBvcHppb25pXCIsXG5cdFwiUE9TVF8yXCI6IFwiQ2xpY2NhIHN1aSBjb21tZW50aSBwZXIgdmlzdWFsaXp6YXJlIGkgc290dG8tY29tbWVudGlcIixcblx0XCJPUFRJT05TXCI6IFwiT3B6aW9uaVwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIkNvbnRkaXZpc28gZGFcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOb24gYyfDqCBhbmNvcmEgbmllbnRlIHF1aS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU2FsZGlcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBzb25vIHRva2VucyBjaGUgcG9zc29ubyBlc3NlcmUgc2NhbWJpYXRpLiB7e3BsYXRmb3JtbmFtZX19IHBvc3Nvbm8gZXNzZXJlIGNvbnZlcnRpdGkgaW4ge3twbGF0Zm9ybXBvd2VyfX0gYXR0cmF2ZXJzbyB1biBwcm9jZXNzbyBjaGlhbWF0byBwb3dlcmluZyB1cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCIgXFxuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiSSB0b2tlbnMgdmFsZ29ubyBjaXJjYSB7e3BsYXRmb3Jtc3VuaXR9fSBkaSB7e3BsYXRmb3JtbmFtZX19LiBcIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJWYWxvcmUgU3RpbWF0b1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIklsIHZhbG9yZSBzdGltYXRvIHNpIGJhc2Egc3VsbGEgbWVkaWEgZGVnbGkgdWx0aW1pIDcgZ2lvcm5pIGRpIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIkNyb25vbG9naWEgZGVsbGUgdHJhbnNhemlvbmlcIixcblx0XCJQT1NUSU5HXCI6IFwiUHViYmxpY2F6aW9uZVwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkxhIFxcXCJwb3N0aW5nIGtleVxcXCIgw6ggdXRpbGl6emF0YSBwZXIgbGEgcHViYmxpY2F6aW9uZSBlIGxhIHZvdGF6aW9uZSBkaSBjb250ZW51dGkuIEVzc2EgZG92cmViYmUgZXNzZXJlIGRpdmVyc2EgZGFsbCdhY3RpdmUgZSBkYWxsJ293bmVyIGtleS5cIixcblx0XCJPV05FUlwiOiBcIlByb3ByaWV0YXJpb1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkxhIFxcXCJvd25lciBrZXlcXFwiIMOoIGxhIGNoaWF2ZSBtYWVzdHJhIGRlbGwnYWNjb3VudCBlZCDDqCByaWNoaWVzdGEgcGVyIG1vZGlmaWNhcmUgbGUgYWx0cmUgY2hpYXZpLiBUYWxlIGNoaWF2ZSBwcml2YXRhLCBjb3PDrCBjb21lIGxhIHBhc3N3b3JkIHByaW5jaXBhbGUsIGRvdnJlYmJlcm8gZXNzZXJlIHRlbnV0ZSBvZmZsaW5lIGlsIHBpw7kgcG9zc2liaWxlLlwiLFxuXHRcIkFDVElWRVwiOiBcIkF0dGl2aXTDoFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkxhIFxcXCJhY3RpdmUga2V5XFxcIiDDqCB1dGlsaXp6YXRhIHBlciBlZmZldHR1YXJlIHRyYXNmZXJpbWVudGkgZSBwaWF6emFyZSBvcmRpbmkgbmVsIG1lcmNhdG8gaW50ZXJuby5cIixcblx0XCJNRU1PXCI6IFwiTWVtb1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkxhIFxcXCJtZW1vIGtleVxcXCIgw6ggdXRpbGl6emF0YSBwZXIgbGEgY3JlYXppb25lIGUgbGV0dHVyYSBkZWkgbWVtby5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiQ29tbWVudGlcIixcblx0XCJSRVBMSUVTXCI6IFwiUmlzcG9zdGVcIixcblx0XCJXQUxMRVRcIjogXCJQb3J0YWZvZ2xpb1wiLFxuXHRcIlRBR1wiOiBcIlRhZ1wiLFxuXHRcIlVTRVJcIjogXCJVdGVudGVcIixcblx0XCJDTE9TRVwiOiBcIkNoaXVkaVwiLFxuXHRcIlRPXCI6IFwiQVwiLFxuXHRcIkFTU0VUXCI6IFwiQXNzZXRcIixcblx0XCJTRU5EXCI6IFwiSW52aWFcIixcblx0XCJTRUNVUklUWVwiOiBcIlNpY3VyZXp6YVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRpc3BvbmliaWxlXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJNZW1vIHB1YmJsaWNhXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlV0ZW50ZSBhZCBlc2VtcGlvIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIkNvZGljZSBQSU5cIixcblx0XCJQSU5fVEVYVFwiOiBcIklsIGNvZGljZSBQSU4gdGkgYWl1dGEgYSByZW5kZXJlIHNpY3VyaSBsJ2FwcGxpY2F6aW9uZSBlIGkgdHVvaSBkYXRpLiA8YnIvPjxici8+PGI+QXR0ZW56aW9uZTo8L2I+IHVuYSB2b2x0YSBhdHRpdmF0bywgaGFpIGFsIG1hc3NpbW8gNCB0ZW50YXRpdmkgcGVyIHNibG9jY2FyZSBsJ2FwcCwgc2UgdGkgZGltZW50aWNoaSBpbCBQSU4gbyBmYWxsaXNjaSBpIHRlbnRhdGl2aSwgbCdhcHBsaWNhemlvbmUgcmltdW92ZXLDoCBpIGRhdGkgdXRlbnRlLiBQb3RyYWkgZmFyZSBudW92YW1lbnRlIGlsIGxvZ2luIGUgY29udGludWFyZSBhZCB1c2FyZSBsJ2FwcGxpY2F6aW9uZS5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2hlXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiUmljZXZlcmFpIHVuYSBub3RpZmljYSBxdWFuZG8gcXVhbGN1bm8gdm90YSBpIHR1b2kgY29udGVudXRpITxici8+PGJyPk5vdGE6PC9iPiBMYSBub3RpZmljYSBpbmNsdWRlcsOgIGlsIHRpcG8gZGkgdm90by4gKHVwLXZvdGUsIGRvd24tdm90ZSwgdW4tdm90ZSkuXCIsXG5cdFwiVk9URVwiOiBcIlZvdG9cIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJSaWNldmVyYWkgdW5hIG5vdGlmaWNhIHF1YW5kbyBxdWFsY3VubyBjb21tZW50YSB1biB0dW8gcG9zdCBvIHJpc3BvbmRlIGFkIHVuIHR1byBjb21tZW50byE8YnIvPjxicj5Ob3RhOjwvYj4gUmljZXZlcmFpIHVuYSBub3RpZmljYSBhbmNoZSBxdWFuZG8gcXVhbGN1bm8gbW9kaWZpY2EgaWwgc3VvIGNvbW1lbnRvIVwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21tZW50b1wiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiUmljZXZlcmFpIHVuYSBub3RpZmljYSBxdWFuZG8gcXVhbGN1bm8gaW5pemlhIG8gc21ldHRlIGRpIHNlZ3VpcnRpIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiTWVuemlvbmVcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiUmljZXZlcmFpIHVuYSBub3RpZmljYSBxdWFuZG8gcXVhbGN1bm8gdGkgbWVuemlvbmEgaW4gdW4gc3VvIHBvc3QgbyBjb21tZW50byFcIixcblx0XCJSRVNURUVNXCI6IFwiQ29uZGl2aWRpXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiUmljZXZlcmFpIHVuYSBub3RpZmljYSBxdWFuZG8gcXVhbGN1bm8gY29uZGl2aWRlIGlsIHR1byBwb3N0IVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiQ29uZmlndXJhemlvbmlcIixcblx0XCJWT1RJTkdcIjogXCJWb3RvXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJJbCBwZXNvIGRlbCB2b3RvIG8gbGEgcGVyY2VudHVhbGUgaW5mbHVlbnphbm8gaWwgcG90ZXJlIGRpIHZvdG8gbmVsbCdhcHAsIGNvc8OsIHB1b2kgcmVnb2xhcmUgaWwgcHJlbWlvIGRlbCB0dW8gdm90by4gPGJyLz48YnIvPjxiPk5vdGE6PC9iPiBxdWVzdG8gY2FtYmllcsOgIGFuY2hlIHBlc28vcGVyY2VudHVhbGUgZGVsIGRvd252b3RlLlwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmFjY29tYW5kYXRpXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2FsdmEgbGUgbW9kaWZpY2hlXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvIFZvdGFudGlcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJCZW50b3JuYXRvIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJBY2NlZGkgZm9ybmVuZG8gaWwgdHVvIE5vbWUgVXRlbnRlIGUgbGEgdHVhIFBhc3N3b3JkIHBlciBjb250aW51YXJlLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJMYSBcXFwicG9zdGluZyBrZXlcXFwiIHZpZW5lIHVzYXRhIHBlciBwdWJibGljYXJlIG51b3ZpIHBvc3QgZSBjb21tZW50aSwgcGVyIHZvdGFyZSwgZSBwZXIgZ2VzdGlyZSBjaGkgc2VndWlcIixcblx0XCJMT0dJTl8zXCI6IFwiTGEgXFxcImFjdGl2ZSBrZXlcXFwiIMOoIHV0aWxpenphdGEgcGVyIGkgdHJhc2ZlcmltZW50aSBlIHBlciBhZ2dpb3JuYXJlIGxhIGZvdG8gZGVsIHByb2ZpbG8uXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkxlIHR1ZSBjcmVkZW56aWFsaSBzb25vIG1lbW9yaXp6YXRlIGxvY2FsbWVudGUgc3VsIGRpc3Bvc2l0aXZvLiBTZSBmYWkgaWwgTG9nb3V0IGxlIGNyZWRlbnppYWxpIHZlcnJhbm5vIHJpbW9zc2UhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTm9uIGhhaSB1biBhY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiUmVnaXN0cmF0aSBvcmFcIixcblx0XCJDQU5DRUxcIjogXCJDYW5jZWxsYVwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiQXZhbnphdGVcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQ2hpYXZlIHByaXZhdGEgYXR0aXZhXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJDaGlhdmUgUHJpdmF0YSBwZXIgcHViYmxpY2F6aW9uZVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiUGFzc3dvcmQgcHJpbmNpcGFsZVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiTm9tZSBVdGVudGVcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJWaXN0YSBlc3Rlc2FcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJWaXN0YSBjb21wYXR0YVwiLFxuXHRcIlNFQVJDSFwiOiBcIkNlcmNhXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJJbnNlcmlzY2kgdW4gYXJ0aWNvbG9cIixcblx0XCJSRVBMWVRPXCI6IFwiUmlzcG9uZGkgYVwiLFxuXHRcIlBPU1RcIjogXCJQdWJibGljYVwiLFxuXHRcIlBSRVZJRVdcIjogXCJBbnRlcHJpbWFcIixcblx0XCJERUZBVUxUXCI6IFwiUHJlZGVmaW5pdG8gNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIFVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlJpZml1dGEgcmljb21wZW5zYVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiU0FMVkEgUEVSIERPUE9cIixcblx0XCJDTEVBUlwiOiBcIkNBTkNFTExBXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiVGVzdG8gZGVsIHBvc3RcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJUZXN0byBkZWwgY29tbWVudG9cIixcblx0XCJUSVRMRVwiOiBcIlRpdG9sb1wiLFxuXHRcIlRBR1NcIjogXCJUYWdzXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTk9OIFRST1ZBVE9cIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZlcm1hIFBJTlwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIklOQ09SUkVUVE9cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJhcGVydHVyYSBwb3N0XCIsXG5cdFwiU0VUX1BJTlwiOiBcIkltcG9zdGEgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiSW5zZXJpc2NpIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIlNlaSBzaWN1cm8/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJJbCByZWJsb2cgw6ggaXJyZXZlcnNpYmlsZSwgdnVvaSBjb250aW51YXJlP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkVycm9yZSBkaSB0cmFzbWlzc2lvbmUsIHJpcHJvdmEhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlN1Y2Nlc3NvXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJQb3N0IGNvbmRpdmlzbyFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiQWNjZXNzbyBmYWxsaXRvISBQZXIgZmF2b3JlLCBhc3NpY3VyYXRpIGRpIGF2ZXIgcmljaGllc3RvIGwnYWNjZXNzbyB0cmFtaXRlIGxhIHR1YSBwYXNzd29yZCBwcmluY2lwYWxlIG8gYXZlbmRvIGluc2VyaXRvIGxhIFxcXCJQb3N0aW5nIHByaXZhdGUga2V5XFxcIiBzZSBoYWkgc2NlbHRvIGxhIG1vZGFsaXTDoCBBdmFuemF0YS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJBY2Nlc3NvIGZhbGxpdG8hIFBlciBmYXZvcmUsIGFzc2ljdXJhdGkgZGkgYXZlciByaWNoaWVzdG8gbCdhY2Nlc3NvIHRyYW1pdGUgbGEgdHVhIHBhc3N3b3JkIHByaW5jaXBhbGUgbyBhdmVuZG8gaW5zZXJpdG8gbGEgdHVhIFxcXCJBY3RpdmUgcHJpdmF0ZSBrZXlcXFwiIHNlIGhhaSBzY2VsdG8gbGEgbW9kYWxpdMOgIEF2YW56YXRhLlwiLFxuXHRcIldBUk5JTkdcIjogXCJBdHRlbnppb25lXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIlZvdGF6aW9uZSBwZXIgaWwgd2l0bmVzc1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiVm90YXRvIHBlciBpbCB0ZXN0aW1vbmlhbFwiLFxuXHRcIkFHT1wiOiBcImZhXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJkYSBvcmFcIixcblx0XCJTRUNTXCI6IFwic2Vjb25kaVwiLFxuXHRcIkFfTUlOXCI6IFwidW4gbWludXRvXCIsXG5cdFwiTUlOU1wiOiBcIm1pbnV0aVwiLFxuXHRcIkFOX0hPVVJcIjogXCJ1bidvcmFcIixcblx0XCJIT1VSU1wiOiBcIm9yZVwiLFxuXHRcIkFfREFZXCI6IFwidW4gZ2lvcm5vXCIsXG5cdFwiREFZU1wiOiBcImdpb3JuaVwiLFxuXHRcIkFfTU9OVEhcIjogXCJ1biBtZXNlXCIsXG5cdFwiTU9OVEhTXCI6IFwibWVzaVwiLFxuXHRcIkFfWUVBUlwiOiBcInVuIGFubm9cIixcblx0XCJZRUFSU1wiOiBcImFubmlcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbnV0aSBkaSBsZXR0dXJhLlwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJEb3dudm90ZSBvIHNlZ25hbGFcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJTY2F0dGEgRm90b1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiU2VsZXppb25hIGZvdG9cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIkltcG9zdGEgVVJMIHBlcnNvbmFsaXp6YXRhXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJJbnNlcmlzY2kgSW1tYWdpbmVcIixcblx0XCJFUlJPUlwiOiBcIkVycm9yZVwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkVycm9yZSBkdXJhbnRlIGlsIGNhcmljYW1lbnRvXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbWVyYSBjYW5jZWxsYXRhXCIsXG5cdFwiU0VUX1VSTFwiOiBcIkltcG9zdGEgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkxpbmsgd2ViIGRpcmV0dG8gcGVyIGwnaW1tYWdpbmVcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIkNvbW1lbnRvIGluc2VyaXRvIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiTGEgY2FuY2VsbGF6aW9uZSBkZWkgY29tbWVudGkgw6ggaXJyZXZlcnNpYmlsZS4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIkNvbW1lbnRvIHJpbW9zc29cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlN0byBjYXJpY2FuZG8gbCdpbW1hZ2luZVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJDYXJpY2FtZW50byBjb21wbGV0YXRvXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIkNhcmljYW1lbnRvIGZhbGxpdG9cIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJOb21lIFV0ZW50ZSBvIFBhc3N3b3JkIGVycmF0aVwiLFxuXHRcIklORk9cIjogXCJJbmZvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBvc2l6aW9uYSB1biBjb2RpY2UgUVIgYWxsJ2ludGVybm8gZGVsbCdhcmVhIGRpIHNjYW5zaW9uZVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIkFzc2ljdXJhdGkgY2hlIGlsIHR1byBiaWxhbmNpbyBzaWEgc3VmZmljaWVudGUgcGVyIGxhIHRyYW5zYXppb25lXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkwndXRlbnRlIGEgY3VpIHN0YWkgY2VyY2FuZG8gZGkgdHJhc2ZlcmlyZSBkZWkgZm9uZGkgbm9uIGVzaXN0ZSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiU2VpIHNpY3VybyBkaSB2b2xlciBwcm9jZWRlcmUgY29uIGlsIHRyYXNmZXJpbWVudG8/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiQ29uZmVybWFcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIkxhIHRyYW5zYXppb25lIMOoIHN0YXRhIHRyYXNtZXNzYVwiLFxuXHRcIkZFRURcIjogXCJGZWVkXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJEaSB0ZW5kZW56YVwiLFxuXHRcIkhPVFwiOiBcIlBvcG9sYXJpXCIsXG5cdFwiTkVXXCI6IFwiTnVvdm9cIixcblx0XCJQUk9NT1RFRFwiOiBcIlNwb25zb3JpenphdGlcIixcblx0XCJWT1RFU1wiOiBcIlZvdGlcIixcblx0XCJQQVlPVVRcIjogXCJQYWdhbWVudG9cIixcblx0XCJDT01NRU5UU1wiOiBcIkNvbW1lbnRpXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuZGluZyBwZXIgMzAgZ2lvcm5pXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiT3JkaW5hIHBlcjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDaWNsbyBkZWkgcGFnYW1lbnRpXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBheW91dCBwb3RlbnppYWxlXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJQYXlvdXQgcGFzc2F0b1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJSaWNvbXBlbnNhIGRlbGwnYXV0b3JlXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUmljb21wZW5zYSBkZWkgY3VyYXRvcmlcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIkwnYXJ0aWNvbG8gw6ggc3RhdG8gaW5zZXJpdG8hXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIkluc2VyaXNjaSBQb3J0IHBpw7kgdGFyZGkhXCIsXG5cdFwiU0FWRURcIjogXCJTYWx2YXRvXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkNhbmNlbGxhdG9cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiU2VnbmFsYXJlIHVuIHBvc3QgcHXDsiBhbm51bGxhcmUgbGUgcmljb21wZW5zZSBlIHJlbmRlcmUgcXVlc3RvIG1hdGVyaWFsZSBtZW5vIHZpc2liaWxlLiA8YnI+PGJyPiBMYSBzZWduYWxhemlvbmUgZG92cmViYmUgZXNzZXJlIHVzYXRhIHBlciBpIHNlZ3VlbnRpIG1vdGl2aTogPHVsPiB0cnVmZmEgbyBQbGFnaW8gPC9saT48bGk+IGluY2l0YXppb25lIGFsbCdvZGlvIG8gVHJvbGxpbmcgPC9saT48bGk+IHBvc3QgaW5zZXJpdGkgaW50ZW56aW9uYWxtZW50ZSBpbiBjYXRlZ29yaWUgZXJyYXRlIG8gU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJMaW1pdGUgcmFnZ2l1bnRvLiBWZXJpZmljYSBhbHRyaSB0cmVuZC90YWdzIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIklsIHBvc3Qgw6ggc3RhdG8gcmltb3NzbyBkYWkgc2VnbmFsaWJyaSFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiSWwgcG9zdCDDqCBzdGF0byBhZ2dpdW50byBhaSBzZWduYWxpYnJpIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVpbXBvc3RhXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJNb2RpZmljYSBsYSBGb3RvIGRlbCBQcm9maWxvXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZmljYSBsJ2ltbWFnaW5lIGRpIGNvcGVydGluYVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlBlciBmYXZvcmUsIGluc2VyaXNjaSBsYSB0dWEgXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgc2UgaGFpIHNjZWx0byBsJ2FjY2Vzc28gaW4gbW9kYWxpdMOgIEF2YW56YXRhIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIlF1ZXN0YSBhemlvbmUgcmVzZXR0ZXLDoCBsJ2ltbWFnaW5lIGRlbCBwcm9maWxvXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiUXVlc3RhIGF6aW9uZSByZXNldHRlcsOgIGwnaW1tYWdpbmUgZGkgY29wZXJ0aW5hXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJVbiBhZ2dpb3JuYW1lbnRvIGxhdG8gc2VydmVyIHJpY2hpZWRlIGlsIFJpYXZ2aW8gZGVsbCdhcHBsaWNhemlvbmUhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkltcG9zdGF6aW9uaSBhZ2dpb3JuYXRlIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkxpbmd1YVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiUXVpIHB1b2kgY2FtYmlhcmUgbGEgbGluZ3VhIGRlbGwnYXBwXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIlF1ZXN0YSBvcGVyYXppb25pIHJpY2hpZWRlIGNoZSBsJ3V0ZW50ZSBhYmJpYSBlZmZldHR1YXRvIGwnYWNjZXNzby4gUGVyIGZhdm9yZSwgYWNjZWRpIGUgcmlwcm92YS5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyaWEgSW1tYWdpbmlcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJUcmFkdXR0b3JpXCIsXG5cdFwiU0hBUkVcIjogXCJDb25kaXZpZGlcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIkFsdHJlIGFwcGxpY2F6aW9uaVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiU2NhbWJpb1wiLFxuXHRcIkRSQUZUU1wiOiBcIkJvenplXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiSWwgcG9zdCDDqCBzdGF0byByaW1vc3NvIGRhbGxlIGJvenplIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJJbCBwb3N0IMOoIHN0YXRvIGFnZ2l1bnRvIGFsbGUgYm96emUhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIlRyYXNjaW5hIGEgc2luaXN0cmEgcGVyIHZlZGVyZSBsZSBvcHppb25pXCIsXG5cdFwiTUFOQUdFXCI6IFwiR2VzdGlzY2lcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiSW1tYWdpbmUgcmltb3NzYVwiLFxuXHRcIkNPUFlcIjogXCJDb3BpYVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiTm9uIGhhaSBhbmNvcmEgY2FyaWNhdG8gdW4naW1tYWdpbmUhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJUcmFzY2luYSBpbiBiYXNzbyBwZXIgYWdnaW9ybmFyZVwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJBcHBsaWNhemlvbmkgZXN0ZXJuZVwiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnSW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2dlcmlzY2lcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIlByb3NzaW1hbWVudGVcIixcblx0XCJDSEFJTlwiOiBcIkNoYWluXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIlF1aSBwdW9pIGNhbWJpYXJlIGxhIGJsb2NrY2hhaW4gbyBsYSBwaWF0dGFmb3JtYSBwcmVkZWZpbml0YS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlZhbHV0YVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJRdWkgcHVvaSBtb2RpZmljYXJlIGxhIHR1YSB2YWx1dGEgcHJlZGVmaW5pdGEuIFZlZHJhaSBpbCB2YWxvcmUgZGkgcmljb21wZW5zYSBwb3N0L2NvbW1lbnRvIGluIHF1ZXN0YSB2YWx1dGEuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+TGlzdGEgZGVsbGUgZnVuemlvbmFsaXTDoDwvYj48YnI+LSBBY2Nlc3NvIGFnbGkgYXJ0aWNvbGkgc3VsbGUgdGVtYXRpY2hlIGRpIHZvc3RybyBpbnRlcmVzc2UuIDxicj4tIEludGVyYXppb25lIGNvbiBnbGkgYXV0b3JpIGRlZ2xpIGFydGljb2xpIGNvbW1lbnRhbmRvIGUgZGlzY3V0ZW5kbyBzdWdsaSBhcmdvbWVudGkuPGJyPi0gUG9zc2liaWxpdMOgIGRpIHZvdGFyZSBpIHBvc3QgcGVyIHJpY29tcGVuc2FyZSBnbGkgYXV0b3JpIGUsIGFsbG8gc3Rlc3NvIHRlbXBvLCBndWFkYWduYXJlIHJpY29tcGVuc2UgZGFpIHZvdGkgZGF0aS48YnI+LSBQb3NzaWJpbGl0w6AgZGkgcHViYmxpY2FyZSBpIHZvc3RyaSBhcnRpY29saSwgcG9zdGFybGkgc3VsIGJsb2cgZ3JhdHVpdGFtZW50ZSBlIGd1YWRhZ25hcmUgcmljb21wZW5zZSBpbnRlcmFnZW5kbyBlIGluY3JlbWVudGFuZG8gaWwgbnVtZXJvIGRlaSBmb2xsb3dlcnMuIDxicj4tIFBvc3NpYmlsaXTDoCBkaSBzY3JpdmVyZSBhcnRpY29saSBkYSBwdWJibGljYXJlLCBzYWx2YW5kbyBsZSBib3p6ZSBwZXIgcHViYmxpY2FybGkgaW4gc2VndWl0by48YnI+LSBVdGlsaXp6byBkaSB1biBcXFwic2VnbmFsaWJyb1xcXCIgcGVyIGdsaSBhcnRpY29saSBwcmVmZXJpdGksIGluIG1vZG8gZGEgcG90ZXJsaSBsZWdnZXJlIHN1Y2Nlc3NpdmFtZW50ZS48YnI+LSBQb3NzaWJpbGl0w6AgZGkgc2NhbWJpYXJlIG8gaW5jYXNzYXJlIGkgdm9zdHJpIGd1YWRhZ25pLjxicj4tIFBvc3NpYmlsaXTDoCBkaSBpbnZpYXJlIGkgdm9zdHJpIGZvbmRpIGFkIGFsdHJpIGF1dG9yaSBvIHV0ZW50aSwgYW1pY2ksIGZvbGxvd2VycywgZXRjLiA8YnI+LSBSaWNlcmNhIGRlaSB2b3N0cmkgZm9sbG93ZXJzIGUgZGVnbGkgYXV0b3JpIGNoZSBzZWd1aXRlLjxicj4tIFJpY2V6aW9uZSBkaSBub3RpZmljaGUgcGVyIHJpbWFuZXJlIGFnZ2lvcm5hdGkgc3VpIHZvc3RyaSBmb2xsb3dlcnMgZSBzdWxsZSBkaXNjdXNzaW9uaSBpbiBjdWkgc2lldGUgY29pbnZvbHRpLiA8YnI+LSBSaWNlcmNhIGRpIGFydGljb2xpIHBlciB0YWdzL2NhdGVnb3JpZSBkaSB2b3N0cm8gaW50ZXJlc3NlIGUgYXV0b3JpLjxicj4tIFBvc3NpYmlsaXTDoCBkaSBwZXJzb25hbGl6emFyZSBpbCBwcm9wcmlvIHByb2ZpbG8uPGJyPi0gTW9sdGUgYWx0cmUgZnVuemlvbmFsaXTDoCBzb25vIGluIGZhc2UgZGkgc3ZpbHVwcG8uPGJyPjxicj48Yj5TaWN1cmV6emE8L2I+PGJyPjEuIEwnQXBwbGljYXppb25lIG5vbiBhdnLDoCBtYWkgYWNjZXNzbyBhaSBmb25kaSBkZWdsaSB1dGVudGkgbsOoIGxpIHBvdHLDoCBkZXRlbmVyZS4gPGJyPjIuIEwnQXBwbGljYXppb25lIG9mZnJlIHVuIG1vZGVsbG8gZGkgc2ljdXJlenphIENsaWVudC1zaWRlLCBjb24gQ2hpYXZpIHByaXZhdGUgZGV0ZW51dGUgbG9jYWxtZW50ZSBlIG1haSBpbnZpYXRlIGFkIGFsY3VuIHNlcnZlci4gVHUgc3Rlc3NvIHNhcmFpIHJlc3BvbnNhYmlsZSBkaSBmYXJlIGlsIGJhY2t1cCBkZWxsZSB0dWUgQ2hpYXZpIFByaXZhdGUvUGFzc3dvcmRzLiA8YnI+My4gTCdBcHBsaWNhemlvbmUgb2ZmcmUgaW50ZXJmYWNjaWEgZWQgZXNwZXJpZW56ZSBzZW1wbGljZSBlIGF0dHJhZW50aSBwZXIgbCd1dGVudGUuIDxicj40LiBMJ0FwcGxpY2F6aW9uZSBvZmZyZSB1biB1bHRlcmlvcmUgbGl2ZWxsbyBkaSBzaWN1cmV6emEgdHJhbWl0ZSBsJ3VzbyBkaSBjb2RpY2UgUGluLiA8YnI+PGJyPmVTdGVlbSBzdXBwb3J0YSBsZSBwaWF0dGFmb3JtZSBkaSBTdGVlbSBlIGRpIEdvbG9zLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiRm9uZGF0b3JlIGUgcmVzcG9uc2FiaWxlIGRlbGxvIHN2aWx1cHBvXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBZ2dpdW5naSBhY2NvdW50XCIsXG5cdFwiUExBVEZPUk1cIjogXCJQaWF0dGFmb3JtYVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkRlcG9zaXRhcmlvXCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiU2NhZGVuemEgZGVsbGEgcmF0aWZpY2F6aW9uZVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiU2NhZGVuemEgZGVsIGRlcG9zaXRvXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIlRhc3NhIGRlbCBkZXBvc2l0b1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIkNvbmRpemlvbmkgZSB0ZXJtaW5pIGRlbCBEZXBvc2l0b1wiLFxuXHRcIk5JR0hUX01PREVcIjogXCJNb2RhbGl0w6Agbm90dHVybmFcIixcblx0XCJEQVlfTU9ERVwiOiBcIk1vZGFsaXTDoCBkaXVybmFcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJNb3N0cmEgaWwgdGVzdG8gY29tcGxldG9cIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiVXRlbnRlIG5vbiB0cm92YXRvXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkFwcHJvdmFcIixcblx0XCJESVNQVVRFXCI6IFwiQ29udHJvdmVyc2lhXCIsXG5cdFwiUkVMRUFTRVwiOiBcIlJpbGFzY2lhXCIsXG5cdFwiRlJPTVwiOiBcIkRhXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIkluc2VyaXNjaVwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiRGVzdGluYXRhcmlvXCIsXG5cdFwiTE9DQVRJT05cIjogXCJMb2NhbGl0w6BcIixcblx0XCJXRUJTSVRFXCI6IFwiU2l0byBXZWJcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJWaXN1YWxpenphIG5vbWVcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiS2VkaWFtYW5cIixcblx0XCJMT0dJTlwiOiBcIkxvZyBNYXN1a1wiLFxuXHRcIkxPR09VVFwiOiBcIkxvZyBLZWx1YXJcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiSWt1dFwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlBlbmFuZGEgYnVrdVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiUGluZGFoXCIsXG5cdFwiTUFSS0VUXCI6IFwiUGFzYXJcIixcblx0XCJTRVRUSU5HU1wiOiBcIlRldGFwYW5cIixcblx0XCJBQk9VVFwiOiBcIk1lbmdlbmFpXCIsXG5cdFwiQUJPVVRfMVwiOiBcImRpIG1hbmEgYW5kYSB0ZXJpbWEgZ2FuamFyYW4gdW50dWsgaXNpIGthbmR1bmRhbiBhbmRhIVwiLFxuXHRcIkFCT1VUXzJcIjogXCJkaWt1YXNhaSBvbGVoIHBsYXRmb3JtIHt7cGxhdGZvcm1uYW1lfX0sIGFwbGlrYXNpIGRpY2lwdGEgb2xlaC5cIixcblx0XCJBQk9VVF8zXCI6IFwiZGFuIGlhbnlhIHN1bWJlciB0ZXJidWthLCBrb211bml0aSB5YW5nIGRpZG9yb25nIG9sZWggcHJvamVrIG11ZGFoIGFsaWguIElhIG1lbmF3YXJrYW4gYWtzZXMga2FuZHVuZ2FuIHVudHVrIG1lbWJhY2EsIG1lbmd1bGFzLCBtZW5ndW5kaSwgcG9zdGluZywgcGVtaW5kYWhhbiBwZW5kYXBhdGFuLCBkYW4gbGFpbi1sYWluIGNpcmktY2lyaSB5YW5nIGRpdGF3YXJrYW4gb2xlaCB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gZGFuIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gQXBsaWthc2kgaW5pIHRpZGFrIG1lbXB5bnlhaSBha3NlcyBrZSBha2F1biBhbmRhLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBcGxpa2FzaSBtZW5hd2Fya2FuIGtlc2VsYW1hdGFuLWtsaWVuLCBkZW5nYW4ga3VuY2kgcGVyaWJhZGkgeWFuZyBkaWhvc2thbiBkYWxhbSB0ZW1wYXRhbiBkYW4gdGlkYWsgYWthbiBkaWhhbnRhciBrZSBtYW5hLW1hbmEgc2VydmVyIGxhaW4uXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIEFwbGlrYXNpIG1lbmF3YXJrYW4gYW50YXJhbXVrYSBwZW5nZ3VuYSB5YW5nIG11ZGFoIGRhbiBtZW5hcmlrLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBBcGxpa2FzaSB0aWRhayBha2FuIG1lbWVybHVrYW4gcGVuZ2d1bmEgdW50dWsgbWVtYXN1a2thbiBtYWtsdW1hdCBwZXJpYmFkaS5cIixcblx0XCJBQk9VVF84XCI6IFwiVW5kaSBnb29kLWthcm1hIHNlYmFnYWkgc2Frc2lcIixcblx0XCJBQk9VVF85XCI6IFwiSHVidW5naS9NYWtsdW0gYmFsYXM6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJJbmZvIGxhbmp1dDpcIixcblx0XCJSRU1PVkVcIjogXCJNZW1idWFuZ1wiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiR2FtYmFyYW4gUGFzYXJhblwiLFxuXHRcIlBSSUNFXCI6IFwiSGFyZ2FcIixcblx0XCJBTU9VTlRcIjogXCJKdW1sYWhcIixcblx0XCJUT1RBTFwiOiBcIkp1bWxhaFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiUGVzYW5hbiB0aWRhayB0ZXJidWthIHVudHVrXCIsXG5cdFwiREFURVwiOiBcIlRhcmlraFwiLFxuXHRcIkJVWVwiOiBcIkJlbGlcIixcblx0XCJTRUxMXCI6IFwiTWVuanVhbFwiLFxuXHRcIk9QRU5cIjogXCJEaWJ1a2FcIixcblx0XCJISVNUT1JZXCI6IFwiU2VqYXJhaFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiSWt1dCBrZW1iYWxpXCIsXG5cdFwiRk9MTE9XRURcIjogXCJEaWlrdXRpXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJCZXJoZW50aVwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIkJlcmlrdXRcIixcblx0XCJGT0xMT1dFUlNcIjogXCJGb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiQ2FyaSBwZW5naWt1dFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJDYXJpIHBlbmdpa3V0XCIsXG5cdFwiQllcIjogXCJvbGVoXCIsXG5cdFwiSU5cIjogXCJkYWxhbVwiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJQZW5hbmRhIGJ1a3VcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJVbmRpIG5haWtcIixcblx0XCJET1dOVk9URVwiOiBcIlVuZGkgKG5lZ2F0aWYpXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkJhdGFsa2FuIHVuZGkgKG5lZ2F0aWYpXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJCYXRhbGthbiB1bmRpXCIsXG5cdFwiUkVQTFlcIjogXCJKYXdhcGFuXCIsXG5cdFwiRURJVFwiOiBcIkVkaXRcIixcblx0XCJQT1NUXzFcIjogXCJTYXB1IGtlIGtpcmkgYXRhcyBrb21lbiB1bnR1ayBtZWxpaGF0IG9wc3llblwiLFxuXHRcIlBPU1RfMlwiOiBcIktldHVrIGF0YXMga29tZW4gdW50dWsgbWVsaWhhdCBzdWIta29tZW5cIixcblx0XCJPUFRJT05TXCI6IFwiUGlsaWhhblwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlYmxvZ2dlZCBvbGVoXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiVElBREEgQVBBIERJIFNJTklcIixcblx0XCJCQUxBTkNFU1wiOiBcIkJha2lcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCB0b2tlbiBjYWlyIHlhbmcgYm9sZWggZGlwaW5kYWhrYW4gcGFkYSBiaWxhLWJpbGEgbWFzYS4ge3twbGF0Zm9ybW5hbWV9fSBib2xlaCBkaXR1a2FyIGtlcGFkYSB7e3BsYXRmb3JtcG93ZXJ9fSBkaSBkYWxhbSBwcm9zZXMgeWFuZyBkaXBhbmdnaWwgbWVuamFuYWthbi5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgcGVuZ2FydWggdG9rZW4geWFuZyBtZW5kYXBhdCBrdWFzYSB5YW5nIGxlYmloIHVudHVrIHBlZ2FuZ2FuIGphbmdrYSBwYW5qYW5nIGRhbiBwZW5ndW5kaWFuIGtlIGF0YXMgcG9zdGluZy4gTGViaWggYmFueWFrIHNlc2VvcmFuZyBtZW1lZ2FuZyBsZWJpaCBiYW55YWsgeWFuZyBib2xlaCBtZW1wZW5nYXJ1aGkgZ2FuamFyYW4gbGFpbiBkYW4gbWVuZGFwYXQgZ2FuamFyYW4gdW50dWsgdW5kaWFuIHlhbmcgdGVwYXQuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW4gYmVybmlsYWkga2lyYS1raXJhIHt7cGxhdGZvcm1zdW5pdH19IGRhcmlwYWRhIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiQW5nZ2FyYW4gbmlsYWlcIixcblx0XCJQUk9GSUxFXzRcIjogXCJOaWxhaSBhbmdnYXJhbiBpbmkgYWRhbGFoIGJlcmRhc2Fya2FuIG5pbGFpIHB1cmF0YSA3IGhhcmkge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiVXJ1cyBuaWFnYVwiLFxuXHRcIlBPU1RJTkdcIjogXCJQRU5FTVBBVEFOXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiS2VrdW5jaSBwb3N0aW5nIGRpZ3VuYWthbiB1bnR1ayBwb3N0aW5nIGRhbiBtZW5ndW5kaS4gSWEgaGFydXMgYmVyYmV6YSBkYXJpcGFkYSBrZWt1bmNpIGFrdGlmIGRhbiBwZW1pbGlrLlwiLFxuXHRcIk9XTkVSXCI6IFwiUGVtaWxpa1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIktla3VuY2kgcGVtaWxpayBhZGFsYWgga3VuY2kgdXRhbWEgdW50dWsgYWthdW4gZGFuIGRpa2VoZW5kYWtpIG1lbnVrYXIga2VrdW5jaSB5YW5nIGxhaW4uIEt1bmNpIHBlcmliYWRpIGRhbiBrYXRhIGxhbHVhbiB1bnR1ayBwZW1pbGlrIGt1bmNpIHBlcmx1IGRpc2ltcGFuIGRpIGx1YXIgdGFsaWFuIHNlYmFueWFrIG11bmdraW4uXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0aWZcIixcblx0XCJQUk9GSUxFXzdcIjogXCJLZWt1bmNpIHlhbmcgYWt0aWYgZGlndW5ha2FuIHVudHVrIG1lbWJ1YXQgcGVtaW5kYWhhbiBkYW4gbWVtYnVhdCBwZXNhbmFuIGRhbGFtIHBhc2FyYW4gZGFsYW1hbi5cIixcblx0XCJNRU1PXCI6IFwiTWVtb1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIktla3VuY2kgbWVtbyBkaWd1bmFrYW4gdW50dWsgbWVuY2lwdGEgZGFuIG1lbWJhY2EgbWVtby5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiSmF3YXRhblwiLFxuXHRcIlJFUExJRVNcIjogXCJCYWxhc2FuXCIsXG5cdFwiV0FMTEVUXCI6IFwiV2FsbGV0XCIsXG5cdFwiVEFHXCI6IFwiVGFnXCIsXG5cdFwiVVNFUlwiOiBcIlBlbmdndW5hXCIsXG5cdFwiQ0xPU0VcIjogXCJUdXR1cFwiLFxuXHRcIlRPXCI6IFwiVG9cIixcblx0XCJBU1NFVFwiOiBcIkFzZXRcIixcblx0XCJTRU5EXCI6IFwiSGFudGFyXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJLZXNlbGFtYXRhblwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIlRlcnNlZGlhXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJNZW1vIGF3YW1cIixcblx0XCJUT19ERVNDXCI6IFwiUGVuZ2d1bmEgY29udG9obnlhIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIktvZCBQaW5cIixcblx0XCJQSU5fVEVYVFwiOiBcIktvZCBQSU4gbWVtYmFudHUgYW5kYSB1bnR1ayBtZW5kYXBhdGthbiBhcGxpa2FzaSBkYW4gZGF0YSBhbmRhLiA8YnIvPiA8YnIvPiA8Yj5Ob3RhOjwvYj4gU2ViYWlrIHNhaGFqYSBkaWJvbGVoa2FuLCBhbmRhIG1lbXB1bnlhaSBtYWtzaW11bSA0IGN1YmEgdW50dWsgbWVtYnVrYSwgamlrYSBhbmRhIHRlcmx1cGEgcGluIGF0YXUgZ2FnYWwsIGFwbGlrYXNpIGFrYW4gbWVtYWRhbSBsb2cgbWFzdWsgZGF0YSBwZW5nZ3VuYS4gQW5kYSBib2xlaCBsb2dpbiBzZW11bGEgZGFuIHRlcnVzIG1lbmdndW5ha2FuIGFwbGlrYXNpLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJXYXJ0YVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdCBwZW1iZXJpdGFodWFuIGFwYWJpbGEgc2VzZW9yYW5nIHVuZGkga2FuZHVuZ2FuIGFuZGEhIDxici8+IDxiPk5vdGE6PC9iPiBwZW1iZXJpdGFodWFuIHRlcm1hc3VrIG1lbmd1bmRpIGJlcmF0IHNlcnRhIG1lc2VqIGFtYXJhbi4gKHNhbWEgYWRhIHVuZGkgKHBvc2l0aWYpLCB1bmRpIChuZWdhdGlmKSwgbWVtYmF0YWxrYW4gdW5kaSkuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGVcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXQgcGVtYmVyaXRhaHVhbiBhcGFiaWxhIHNlc2VvcmFuZyBhdGF1IG1lbWJlcmkga29tZW4gcGFkYSBwb3N0aW5nIGF0YXUga29tZW4gYW5kYSEgPGJyLz4gPGI+Tm90YTo8L2I+IFBlbWJlcml0YWh1YW4gdGVybWFzdWsgYXBhYmlsYSBzZXNlb3JhbmcgPGI+c3VudGluZ2FuPC9iPiBrb21lbiBtZXJla2EganVnYS5cIixcblx0XCJDT01NRU5UXCI6IFwiS29tZW5cIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBwZW1iZXJpdGFodWFuIGFwYWJpbGEgc2VzZW9yYW5nIG1lbmdpa3V0aSBhdGF1IGlrdXQgYW5kYSFcIixcblx0XCJNRU5USU9OU1wiOiBcIk1lbnllYnV0XCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdCBwZW1iZXJpdGFodWFuIGFwYWJpbGEgc2VzZW9yYW5nIG1lbnllYnV0IGFuZGEgZGkgcG9zdC9rb21lbiFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiQW5kYSBha2FuIG1lbmRhcGF0IHBlbWJlcml0YWh1YW4gYXBhYmlsYSBzZXNlb3JhbmcgcmVibG9nIHBvc3QgYW5kYSFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3VyYXNpXCIsXG5cdFwiVk9USU5HXCI6IFwiTWVuZ3VuZGlcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIkJlcmF0IHVuZGkgYXRhdSBwZXJhdHVzIG1lbmplamFza2FuIGt1YXNhIG1lbmd1bmRpIHBhZGEgYXBsaWthc2ksIHN1cGF5YSBhbmRhIGJvbGVoIG1lbmdhd2FsIGdhbmphcmFuIG1lbmd1bmRpLiA8YnIvPiA8YnIvPiA8Yj5Ob3RhOjwvYj4gSW5pIGFrYW4gbWVuZ3ViYWggYmVyYXQvcGVyYXR1c2FuIHVuZGlhbiB1bnR1ayB1bmRpIChuZWdhdGlmKSBqdWdhIGRhbiBpYSBhZGFsYWggZGkgbWFuYS1tYW5hIGFwbGlrYXNpXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJEaXN5b3JrYW5cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTaW1wYW4gcGVydWJhaGFuXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvIHBlbmd1bmRpXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiU2VsYW1hdCBrZW1iYWxpIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJEYWZ0YXIgTWFzdWsgZGVuZ2FuIHVzZXJuYW1lIGRhbiBwYXNzd29yZCBhbmRhIHVudHVrIHRlcnVza2FuLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJLdW5jaSBwb3N0aW5nIGRpZ3VuYWthbiB1bnR1ayBwb3Mga29tZW4sIHVuZGksIGlrdXQuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkt1bmNpIGFrdGlmIGRpZ3VuYWthbiB1bnR1ayBwZW1pbmRhaGFuIGRhbiBrZW1hc2tpbmkgZ2FtYmFyIHByb2ZpbC5cIixcblx0XCJMT0dJTl80XCI6IFwiS2VsYXlha2FuIHBlbmdndW5hIGRpc2ltcGFuIHNlY2FyYSB0ZW1wYXRhbiBwYWRhIHBlcmFudGkuIEFwYWJpbGEgbG9nIGtlbHVhciBrZWxheWFrYW4gYWthbiBkaWtlbHVhcmthbiFcIixcblx0XCJET05UX0hBVkVcIjogXCJUaWRhayBhZGEgYWthdW4/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJEYWZ0YXJsYWggc2VrYXJhbmdcIixcblx0XCJDQU5DRUxcIjogXCJCYXRhbFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiQWR2YW5jZWRcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiS3VuY2kgYWt0aWYgcGVyc2VuZGlyaWFuXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJLdW5jaSBwb3N0aW5nIHBlcnNlbmRpcmlhblwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiS2F0YSBsYWx1YW4gaW5kdWsvdXRhbWFcIixcblx0XCJVU0VSTkFNRVwiOiBcIk5hbWEgUGVuZ2d1bmFcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJLYWQgcGFwYXJhblwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIlBhcGFyYW4geWFuZyBwYWRhdFwiLFxuXHRcIlNFQVJDSFwiOiBcIkNhcmlhblwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiSGFudGFyIGNlcml0YVwiLFxuXHRcIlJFUExZVE9cIjogXCJCYWxhcyBrZXBhZGFcIixcblx0XCJQT1NUXCI6IFwiSGFudGFyXCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZXZpZXdcIixcblx0XCJERUZBVUxUXCI6IFwiTGFsYWkgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIk1lbmdla3Vhc2FpIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIk1lbm9sYWsgYmF5YXJhblwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiU0lNUEFOIFVOVFVLIEtFTVVESUFOXCIsXG5cdFwiQ0xFQVJcIjogXCJKRUxBU1wiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBvc3Qga2FuZHVuZ2FuXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiS29tZW4ga2FuZHVuZ2FuXCIsXG5cdFwiVElUTEVcIjogXCJUYWp1a1wiLFxuXHRcIlRBR1NcIjogXCJUYWdzXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiVElEQUsgUEFEQU5cIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlNhaGthbiBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJCRVRVTFwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcInBlbWJ1a2FhbiBwb3N0XCIsXG5cdFwiU0VUX1BJTlwiOiBcIlRldGFwa2FuIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIk1hc3Vra2FuIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIkFkYWthaCBhbmRhIHBhc3RpP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVibG9nIHRpZGFrIGJvbGVoIGRpYmFsaWtrYW4sIGFkYWthaCBhbmRhIHBhc3RpIGhlbmRhayBtZW5lcnVza2FuP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkRpc2lhcmthbiByYWxhdCwgY3ViYSBsYWdpIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJLZWpheWFhblwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUmVibG9nZ2VkIHBvc3QhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkxvZyBtYXN1ayBnYWdhbCEgU2lsYSBwYXN0aWthbiBhbmRhIHRlbGFoIGxvZyBtYXN1ayBkZW5nYW4ga2F0YSBsYWx1YW4gaW5kdWsgYXRhdSBrdW5jaSBwZXJpYmFkaSBwb3N0aW5nIGFuZGEga2UgYXRhcyBsb2cgbWFzdWsgamlrYSBhbmRhIHRlbGFoIG1lbWlsaWggbW9kIEFkdmFuY2VkLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkxvZyBtYXN1ayBnYWdhbCEgU2lsYSBwYXN0aWthbiBhbmRhIHRlbGFoIGxvZyBtYXN1ayBkZW5nYW4ga2F0YSBsYWx1YW4gaW5kdWsgYXRhdSBrdW5jaSBwZXJpYmFkaSBwb3N0aW5nIGFuZGEga2UgYXRhcyBsb2cgbWFzdWsgamlrYSBhbmRhIHRlbGFoIG1lbWlsaWggbW9kIEFkdmFuY2VkLlwiLFxuXHRcIldBUk5JTkdcIjogXCJBbWFyYW5cIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiTWVuZ3VuZGkgdW50dWsgc2Frc2lcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIk1lbmd1bmRpIHVudHVrIHNha3NpXCIsXG5cdFwiQUdPXCI6IFwiTGFsdVwiLFxuXHRcIkZST01fTk9XXCI6IFwiZGFyaSBzZWthcmFuZ1wiLFxuXHRcIlNFQ1NcIjogXCJzYWF0XCIsXG5cdFwiQV9NSU5cIjogXCJtaW5pdFwiLFxuXHRcIk1JTlNcIjogXCJtaW5pdFwiLFxuXHRcIkFOX0hPVVJcIjogXCJzZWphbVwiLFxuXHRcIkhPVVJTXCI6IFwiamFtXCIsXG5cdFwiQV9EQVlcIjogXCJzYXR1IGhhcmlcIixcblx0XCJEQVlTXCI6IFwiaGFyaVwiLFxuXHRcIkFfTU9OVEhcIjogXCJzZWJ1bGFuXCIsXG5cdFwiTU9OVEhTXCI6IFwiYnVsYW5cIixcblx0XCJBX1lFQVJcIjogXCJzZXRhaHVuXCIsXG5cdFwiWUVBUlNcIjogXCJ0YWh1blwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluaXQgbWVtYmFjYVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJWb3RlIChuZWdhdGlmKSBhdGF1IE1lbmFuZGFpXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiVGFuZ2thcCBnYW1iYXJcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlBpbGloIGdhbWJhclwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiVGV0YXBrYW4gVVJMIGJvbGVoLXViYWhcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIk1hc3Vra2FuIGdhbWJhclwiLFxuXHRcIkVSUk9SXCI6IFwiUmFsYXRcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJSYWxhdCBtdWF0IG5haWtcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiS2FtZXJhIFRlbGFoIERpYmF0YWxrYW5cIixcblx0XCJTRVRfVVJMXCI6IFwiVGV0YXBrYW4gVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIlBhdXRhbiB3ZWIgbGFuZ3N1bmcgZ2FtYmFyXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJLb21lbiBkaWhhbnRhciFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIk1lbmdoYXB1c2thbiBrb21lbiB0aWRhayBib2xlaCBkaWJhbGlra2FuLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiS29tZW4gZGloYXB1c2thblwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiTXVhdCBOYWlrIEdhbWJhclwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJNdWF0IE5haWsgU2VsZXNhaVwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJNdWF0IE5haWsgR2FnYWxcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJOYW1hIGFrYXVuIGF0YXUga2F0YSBsYWx1YW4gdGlkYWsgYmV0dWxcIixcblx0XCJJTkZPXCI6IFwiTWFrbHVtYXRcIixcblx0XCJRUl9URVhUXCI6IFwiTGV0YWtrYW4gS29kIFFSIGRpIGRhbGFtIGthd2FzYW4gaW1iYXNhblwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIlBhc3Rpa2FuIGFuZGEgbWVtcHVueWFpIGJha2kgeWFuZyBtZW5jdWt1cGkgdW50dWsgdHJhbnNha3NpIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJQZW5nZ3VuYSB5YW5nIGFuZGEgY3ViYSB1bnR1ayBtZW1pbmRhaGthbiBkYW5hLCB0aWRhayB3dWp1ZCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiQWRha2FoIGFuZGEgcGFzdGkgYW5kYSBtYWh1IG1lbWluZGFoa2FuP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIlBlbmdlc2FoYW5cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlVydXMgbmlhZ2EgZGlzaWFya2FuXCIsXG5cdFwiRkVFRFwiOiBcIlN1YXBhblwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlblwiLFxuXHRcIkhPVFwiOiBcIlBhbmFzXCIsXG5cdFwiTkVXXCI6IFwiQmFydVwiLFxuXHRcIlBST01PVEVEXCI6IFwiRGlnYWxha2thblwiLFxuXHRcIlZPVEVTXCI6IFwiVW5kaVwiLFxuXHRcIlBBWU9VVFwiOiBcIlBlbWJheWFyYW5cIixcblx0XCJDT01NRU5UU1wiOiBcIktPTUVOVEFSXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuIHVudHVrIDMwIGhhcmlcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJQb3N0aW5nIHN1c3VuIG9sZWg6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiS2l0YXJhbiBwZW1iYXlhcmFuXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBvdGVuc2kgUGVtYmF5YXJhblwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiUGVtYmF5YXJhbiBNYXNhIExhbHVcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiQmF5YXJhbiBQZW51bGlzXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUGVtYmF5YXJhbiBDdXJhdGlvblwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUG9zIGRpaGFudGFyIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQb3MgdW50dWsgcGVuZ2hhbnRhcmFuIGxld2F0IVwiLFxuXHRcIlNBVkVEXCI6IFwidGVyc2ltcGFuXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkRJUEFEQU1LQU5cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiTWVuYW5kYSBhdGF1IHVuZGlhbiAobmVnYXRpZikgcG9zIGJvbGVoIGtlbHVhcmthbiBnYW5qYXJhbiBkYW4gamFkaWthbiBiYWhhbiBpbmkga3VyYW5nIGtlbGloYXRhbi4gPGJyPjxicj5CZW5kZXJhIGhlbmRha2xhaCBkaWd1bmFrYW4gdW50dWsgcGVya2FyYS1wZXJrYXJhIGJlcmlrdXQ6IDx1bD48bGk+cGVuaXB1YW4gYXRhdSBwbGFnaWF0PC9saT4gPGxpPnVjYXBhbiBiZW5jaSBhdGF1IEludGVybmV0IFRyb2xsaW5nPC9saT4gPGxpPkthdGVnb3JpIHlhbmcgbWVuZ2VsaXJ1a2FuIGF0YXUgU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJIYWQgcGVtaW50YWFuIGRpY2FwYWkuIE1lbnllbWFrIGFsaXJhbiB0YWcgbGFpbiFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3MgZGlhbGloIGtlbHVhciBkYXJpcGFkYSBwZW5hbmRhIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQb3N0IGRpdGFtYmFoIGtlIHBlbmFuZGEhXCIsXG5cdFwiUkVTRVRcIjogXCJUZXRhcGthbiBzZW11bGFcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIlR1a2FyIEdhbWJhciBQcm9maWxcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIlR1a2FyIEdhbWJhciBDb3ZlclwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlNpbGEgYmVyaWthbiBrdW5jaSBwZXJpYmFkaSB5YW5nIGFrdGlmIGppa2EgYW5kYSB0ZWxhaCBtZW1pbGloIG1vZCBsb2dpbiBtYWp1IVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIkluaSBha2FuIG1lbmV0YXBrYW4gc2VtdWxhIGdhbWJhciBwcm9maWwgcGVuZ2d1bmFcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJJbmkgYWthbiBtZW5ldGFwa2FuIHNlbXVsYSBnYW1iYXIgcHJvZmlsIHBlbmdndW5hXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJLZW1hc2tpbmkgcGVsYXlhbiBtZW1lcmx1a2FuIHJlc2V0IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJUZXRhcGFuIGRpa2VtYXNraW5pIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkJBSEFTQVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiRGkgc2luaSBhbmRhIGJvbGVoIG1lbnVrYXIgYmFoYXNhIGRhcmlwYWRhIGFwbGlrYXNpIGluaS5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiT3BlcmFzaSBpbmkgbWVtZXJsdWthbiBwZW5nZ3VuYSBsb2cgbWFzdWsgZGVuZ2FuIGthdGEgbGFsdWFuIHV0YW1hLCBrZWt1bmNpIGFrdGlmL3Bvc3RpbmcuIFNpbGEgbG9nIG1hc3VrIGRhbiBjdWJhIGxhZ2kuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdBTEVSSVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlRFUkpFTUFIQU5cIixcblx0XCJTSEFSRVwiOiBcIktvbmdzaVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiUGFzYXJhblwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiUGVydHVrYXJhblwiLFxuXHRcIkRSQUZUU1wiOiBcIkRyYWZcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQb3MgZGlhbGloIGtlbHVhciBkYXJpcGFkYSBkcmFmIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQb3N0IGRpdGFtYmFoIGtlcGFkYSBkcmFmIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJTYXB1IGtpcmkgdW50dWsgbWVsaWhhdCBvcHN5ZW5cIixcblx0XCJNQU5BR0VcIjogXCJVcnVzXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltZWogZGlrZWx1YXJrYW5cIixcblx0XCJDT1BZXCI6IFwiU2FsaW5cIixcblx0XCJOT19JTUFHRVwiOiBcIkFuZGEgdGlkYWsgdXBsb2FkIGdhbWJhciBhcGEtYXBhLCBsYWdpIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiVGFyaWsga2UgYmF3YWggdW50dWsgbWVtdWF0IHNlbXVsYVwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJBcGxpa2FzaSBsdWFyYW5cIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Z2luXCIsXG5cdFwiU1VHR0VTVFwiOiBcIkNhZGFuZ2thblwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiQWthbiBkYXRhbmdcIixcblx0XCJDSEFJTlwiOiBcIkNoYWluXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkRpIHNpbmkgYW5kYSBib2xlaCBtZW51a2FyIHBsYXRmb3JtIGJsb2NrY2hhaW4gYXRhdSBsYWxhaS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIk1hdGF3YW5nXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkRpIHNpbmkgYW5kYSBib2xlaCBtZW51a2FyIE1hdGEgV2FuZyBsYWxhaSBhbmRhLiBBbmRhIGFrYW4gbWVsaWhhdCBwb3N0L2tvbWVuIGdhbmphcmFuIG5pbGFpIE1hdGEgV2FuZyBpbmkuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+U2VuYXJhaSBjaXJpLWNpcmk8L2I+IDxicj5ha3NlcyB1bmlrIGFydGlrZWwgZGFsYW0gbWFuYS1tYW5hIHN1YmplayBhbmRhIGJlcm1pbmF0IG1lbWJhY2EuIDxicj4gLU1lbGliYXRrYW4gZGlyaSBkZW5nYW4gcGVudWxpcyBvbGVoIG1lbmd1bGFzLCBtZW1iaW5jYW5na2FuIHRvcGlrLiA8YnI+LVBlbmd1bmRpYW4gYmFnaSBqYXdhdGFuIGtlcGFkYSBwZW5nYXJhbmcgZ2FuamFyYW4gc2VydGEgbWVuZGFwYXQgZ2FuamFyYW4gY3VyYXRpb24uIDxicj4tU2lhcmthbiBhcnRpa2VsLCBwb3N0aW5nIGJsb2cgYW5kYSBkYW4gaG9zdCBtZXJla2Egc2VjYXJhIHBlcmN1bWEgZGFuIG1lbmRhcGF0IGdhbmphcmFuIGRlbmdhbiBtZWxpYmF0a2FuIGRhbiBtZW5kYXBhdCBwZW5naWt1dC4gPGJyPlR1bGlzIGFydGlrZWwgbWVuZ2VuYWkgcGVyZ2ksIHNpbXBhbiBiZWJlcmFwYSBEcmFmIGphd2F0YW4gdW50dWsgcGVuZXJiaXRhbiBrZW11ZGlhbi4gPGJyPi1Cb29rbWFyayBhcnRpa2VsIGtlZ2VtYXJhbiBtZW1iYWNhIGtlbXVkaWFuLiA8YnI+LVBlcnR1a2FyYW4gYXRhdSBXYW5nIFR1bmFpIGRhcmlwYWRhIHBlbmRhcGF0YW4gYW5kYS4gPGJyPk1lbmdoYW50YXIgZGFuYSBhbmRhIGtlcGFkYSBtYW5hLW1hbmEgcGVuZ2FyYW5nIGF0YXUgcGVuZ2d1bmEsIHJha2FuLXJha2FuLCBwZW5naWt1dCwgZGFuIGxhaW4tbGFpbiA8YnI+LWlrdXQgcGVudWxpcyBtZW5hcmlrLCBCbG9nZ2VyLiA8YnI+IC1DYXJpIHBlbmdpa3V0IGRhbiBwZW51bGlzIGFuZGEgbWVuZ2lrdXRpIGFuZGEuIDxicj4tRGFwYXRrYW4gcGVtYmVyaXRhaHVhbiB1bnR1ayBrZWthbCBiZXJodWJ1bmcgZGVuZ2FuIHBlbmdpa3V0IGRhbiBwZXJiaW5jYW5nYW4gYW5kYSBhbmRhIGFrYW4gdGVybGliYXQgaW4uIDxicj4tQ2FyaSBsYWJlbC9rYXRlZ29yaSBtZW5hcmlrIGFydGlrZWwsIHBlbmdhcmFuZy4gPGJyPiAtTWVtcGVyaWJhZGlrYW4gcHJvZmlsIGFuZGEuIDxicj4tQmFueWFrIGxlYmloIGJhbnlhayBjaXJpIHVudHVrIGRhdGFuZy4gPGJyPjxicj48Yj5LZXNlbGFtYXRhbjwvYj4gPGJyPjEuIEFwbGlrYXNpIHRpZGFrIHBlcm5haCBtZW5jYXBhaSBhdGF1IG1lbWVnYW5nIHdhbmcgcGVuZ2d1bmEuIDxicj4yLiBhcGxpa2FzaSBtZW5hd2Fya2FuIG1vZGVsIEtlc2VsYW1hdGFuLWtsaWVuLCBkZW5nYW4ga3VuY2kgcGVyaWJhZGkgeWFuZyBkaWhvc2thbiBkYWxhbSBuZWdhcmEgZGFuIHRpZGFrIHBlcm5haCBkaWhhbnRhciBrZSBtYW5hLW1hbmEgcGVsYXlhbiwgYW5kYSBiZXJ0YW5nZ3VuZ2phd2FiIHVudHVrIG1lbnlhbmRhcmthbiBrYXRhIGxhbHVhbiBhbmRhLiA8YnI+My4gYXBsaWthc2kgbWVuYXdhcmthbiBhbnRhcmEgbXVrYSBwZW5nZ3VuYSB5YW5nIG11ZGFoLCBtZW5hcmlrIGRhbiBwZW5nYWxhbWFuIDxicj40LiBBcGxpa2FzaSBtZW5hd2Fya2FuIHRhbWJhaGFuIGxhcGlzYW4gS2VzZWxhbWF0YW4gZGVuZ2FuIGhhcmdhIDxicj48YnI+a29kIHBpbiBtZW55b2tvbmcgcGxhdGZvcm0gU3RlZW0gZGFuIEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIlBlbmdhc2FzIGRhbiBwZW1hanUgdXRhbWFcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIlRhbWJhaCBha2F1blwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFamVuIGVzY3Jvd1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlRhcmlraCBha2hpciBrZWx1bHVzYW5cIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyB0YW1hdFwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJZdXJhbiBlc2Nyb3dcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJUZXJtYS10ZXJtYSBlc2Nyb3dcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiSG9tZVwiLFxuXHRcIkxPR0lOXCI6IFwiTG9nIGluXCIsXG5cdFwiTE9HT1VUXCI6IFwiTG9nIHVpdFwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWVsXCIsXG5cdFwiRk9MTE9XXCI6IFwiVm9sZ2VuXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiQmxhZHdpanplcnNcIixcblx0XCJUUkFOU0ZFUlwiOiBcIk92ZXJzY2hyaWp2ZW5cIixcblx0XCJNQVJLRVRcIjogXCJNYXJrdFwiLFxuXHRcIlNFVFRJTkdTXCI6IFwiSW5zdGVsbGluZ2VuXCIsXG5cdFwiQUJPVVRcIjogXCJPdmVyXCIsXG5cdFwiQUJPVVRfMVwiOiBcIndhYXIgaWVkZXJlZW4gZWVuIGJlbG9uaW5nIGthbiB2ZXJkaWVuZW4hXCIsXG5cdFwiQUJPVVRfMlwiOiBcImlzIHNvY2lhbCBtZWRpYSBkaWVuc3Qgd2FhciBqZSBiZXRhYWxkIHdvcmR0IHZvb3IgaGV0IGJsb2dnZW4sIGFudHdvb3JkZW4gZW4gY3VyZXJlbi5cIixcblx0XCJBQk9VVF8zXCI6IFwiZW4gaGV0IGlzIGVlbiBvcGVuLXNvdXJjZSwgY29tbXVuaXRpZSBnZWRyZXZlbiBwcm9qZWN0LiBIZXQgYmllZHQgbW9nZWxpamtoZWRlbiB0b3QgbGV6ZW4sIHJlYWdlcmVuLCBzdGVtbWVuLCBwbGFhdHNlbiB2YW4gYmVyaWNodGVuLCBvdmVyc2NocmlqdmVuIHZhbiBpbmtvbXN0ZW4sIGV0Yy4gZnVuY3RpZXMgd29yZGVuIGFhbmdlYm9kZW4gZG9vciB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gRGUgYXBwIGhlZWZ0IGdlZW4gdG9lZ2FuZyB0b3QgdGVnb2VkZW4gdmFuIGRlIGdlYnJ1aWtlci5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gRGUgYXBwIGJpZWR0IGVlbiBjbGllbnQgYmV2ZWlsaWdpbmdzbW9kZWwsIG1ldCBwcml2w6kgc2xldXRlbHMgZGllIGxva2FhbCB3b3JkZW4gb3BnZXNsYWdlbiBlbiBub29pdCBuYWFyIHNlcnZlcnMgd29yZGVuIHZlcnpvbmRlbi5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gRGUgYXBwIGJpZWR0IHNpbXBlbGUsIGFhbnRyZWtrZWxpamtlIGdlYnJ1aWtlcnNvbWdldmluZ2VuIGVuIGVydmFyaW5nZW4uXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIERlIGFwcCB2cmFhZ3QgdSBub29pdCBvbSBwZXJzb29ubGlqa2UgaW5mb3JtYXRpZS5cIixcblx0XCJBQk9VVF84XCI6IFwiU3RlbSBvcCBnb29kLWthcm1hIGFscyB3aXRuZXNzXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhY3QvVGVydWdrb3BwZWxpbmc6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNZWVyIGluZm9ybWF0aWU6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiVmVyd2lqZGVyZW5cIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIk1hcmt0IFdlZXJnYXZlXCIsXG5cdFwiUFJJQ0VcIjogXCJQcmlqc1wiLFxuXHRcIkFNT1VOVFwiOiBcIkJlZHJhZ1wiLFxuXHRcIlRPVEFMXCI6IFwiVG90YWFsXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJHZWVuIHVpdHN0YWFuZGUgYmVzdGVsbGluZ2VuIHZvb3JcIixcblx0XCJEQVRFXCI6IFwiRGF0dW1cIixcblx0XCJCVVlcIjogXCJLb3BlblwiLFxuXHRcIlNFTExcIjogXCJWZXJrb3BlblwiLFxuXHRcIk9QRU5cIjogXCJPcGVuXCIsXG5cdFwiSElTVE9SWVwiOiBcIkdlc2NoaWVkZW5pc1wiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiVGVydWd2b2xnZW5cIixcblx0XCJGT0xMT1dFRFwiOiBcIkdldm9sZ2RcIixcblx0XCJVTkZPTExPV1wiOiBcIk9udHZvbGdlblwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIlZvbGdlblwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIlZvbGdlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiWm9layB2b2xnZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIlpvZWsgdm9sZ2VuXCIsXG5cdFwiQllcIjogXCJkb29yXCIsXG5cdFwiSU5cIjogXCJpblwiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJCbGFkd2lqemVyXCIsXG5cdFwiUkVCTE9HXCI6IFwiSGVyYmxvZ1wiLFxuXHRcIlVQVk9URVwiOiBcIlN0ZW0gT21ob29nXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJTdGVtIE9tbGFhZ1wiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJEb3dudm90ZSB3ZWdoYWxlblwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiU3RlbSBPbWhhYWcgd2VnaGFsZW5cIixcblx0XCJSRVBMWVwiOiBcIlJlYWdlZXJcIixcblx0XCJFRElUXCI6IFwiV2lqemlnZW5cIixcblx0XCJQT1NUXzFcIjogXCJTd2lwZSBuYWFyIGxpbmtzIG9wIGVlbiByZWFjdGllIG9tIG9wdGllcyB0ZSB6aWVuXCIsXG5cdFwiUE9TVF8yXCI6IFwiVGlrIG9wIHJlYWN0aWVzIG9tIHN1Yi1yZWFjdGllcyB0ZSB6aWVuXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wdGllc1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIkhlcmJsb2dkIGRvb3JcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOb2cgbmlldHMgdGUgemllbiBoaWVyLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJUZWdvZWRlblwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIHZlcmhhbmRlbGJhcmUgdG9rZW5zIGRpZSBhbHRpamQgb3ZlcmdlbWFha3Qga2FuIHdvcmRlbi4ge3twbGF0Zm9ybW5hbWV9fSBrYW4gd29yZGVuIG9tZ2V6ZXQgbmFhciB7e3BsYXRmb3JtcG93ZXJ9fSBpbiBlZW4gcHJvY2VzIGdlbmFhbWQgcG93ZXJpbmcgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGludmxvZWQgdG9rZW5zIGRpZSBtZWVyIGtyYWNodCBrcmlqZ2VuIGRvb3IgaGV0IG9wIGxhbmdlIHRlcm1pam4gdGUgYmV3YXJlbiBlbiBkb29yIGhldCBzdGVtbWVuIG9wIGJlcmNpaHRlbi4gSG9lIG1lZXIgdG9rZW5zIHUgdmFzdGhvdWR0LCBob2UgbWVlciBpbnZsb2VkIHUgaGVlZnQgb3AgYW5kZXJtYW5zIG9wYnJlbmdzdGVuIGVuIGhvZSBob2dlciBkZSBvcGJyZW5nc3RlbiBiaWogY3VyZXJlbi5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbnMgemlqbiBvbmdldmVlciB7e3BsYXRmb3Jtc3VuaXR9fSB7e3BsYXRmb3JtbmFtZX19IHdhYXJkLlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkdlc2NoYXR0ZSB3YWFyZGVcIixcblx0XCJQUk9GSUxFXzRcIjogXCJEZSBnZXNjaGF0dGUgd2FhcmRlIGlzIGdlYmFzZWVyZCBvcCBlZW4gNy1kYWFncyBnZW1pZGRlbGRlIHdhYXJkZSB2YW4ge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiVHJhbnNhY3RpZSBnZXNjaGllZGVuaXNcIixcblx0XCJQT1NUSU5HXCI6IFwiUGxhYXRzZW5cIixcblx0XCJQUk9GSUxFXzVcIjogXCJEZSBiZXJpY2h0ZW4gc2xldXRlbCB3b3JkdCBnZWJydWlrdCB2b29yIGhldCBwbGFhdHNlbiB2YW4gZW4gdm9vciBoZXQgc3RlbW1lbiBvcCBiZXJpY2h0ZW4uIERlemUgem91IGFuZGVycyBtb2V0ZW4gemlqbiBkYW4gZGUgYWN0aWV2ZS0gZW4gZWlnZW5hYXIgc2xldXRlbHMuXCIsXG5cdFwiT1dORVJcIjogXCJFaWdlbmFhclwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkRlIGVpZ2VuYWFycyBzbGV1dGVsIGlzIGRlIGhvb2Zkc2xldXRlbCB2b29yIGhldCBhY2NvdW50IGVuIGlzIG5vZGlnIG9tIGFuZGVyZSBzbGV1dGVscyBhYW4gdGUgcGFzc2VuLiBEZSBwcml2w6kgc2xldXRlbCBvZiB3YWNodHdvb3JkIHZvb3IgZGUgZWlnZW5hYXJzIHNsZXV0ZWwgem91IHpvIHZlZWwgbW9nZWxpamsgb2ZmbGluZSBvcGdlc2xhZ2VuIG1vZXRlbiB3b3JkZW4uXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWN0aWVmXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiRGUgYWN0aWV2ZSBzbGV1dGVsIHdvcmR0IGdlYnJ1aWt0IG9tIHRyYW5zYWN0aWVzIGVuIGJlc3RlbGxpbmdlbiB0ZSBwbGFhdHNlbiBpbiBkZSBpbnRlcm5lIG1hcmt0LlwiLFxuXHRcIk1FTU9cIjogXCJNZW1vXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiRGUgbWVtbyBzbGV1dGVsIHdvcmR0IGdlYnJ1aWt0IHZvb3IgaGV0IG1ha2VuIGVuIGxlemVuIHZhbiBtZW1vJ3MuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIkJlcmljaHRlblwiLFxuXHRcIlJFUExJRVNcIjogXCJSZWFjdGllc1wiLFxuXHRcIldBTExFVFwiOiBcIlBvcnRlbW9ubmVlXCIsXG5cdFwiVEFHXCI6IFwiTGFiZWxcIixcblx0XCJVU0VSXCI6IFwiR2VicnVpa2VyXCIsXG5cdFwiQ0xPU0VcIjogXCJBZnNsdWl0ZW5cIixcblx0XCJUT1wiOiBcIk5hYXJcIixcblx0XCJBU1NFVFwiOiBcIkJleml0dGluZ1wiLFxuXHRcIlNFTkRcIjogXCJWZXJ6ZW5kZW5cIixcblx0XCJTRUNVUklUWVwiOiBcIkJldmVpbGlnaW5nXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiQmVzY2hpa2JhYXJcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIlB1YmxpZWtlbGlqa2UgbWVtb1wiLFxuXHRcIlRPX0RFU0NcIjogXCJHZWJydWlrZXIgYmlqdi4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUGluY29kZVwiLFxuXHRcIlBJTl9URVhUXCI6IFwiUElOIGNvZGUgaGVscHQgdSB1dyBhcHAgZW4gZ2VnZXZlbnMgdGUgYmVzY2hlcm1lbi4gPGJyLz48YnIvPjxiPk9wbWVya2luZzo8L2I+IEVlbm1hYWwgaW5nZXN0ZWxkIGhlZWZ0IHUgbWF4aW1hYWwgNCBrYW5zZW4sIHdhbm5lZXIgdSBkZSBQSU4gYmVudCB2ZXJnZXRlbiBvZiB1IGhldCA0IGtlZXIgdmVya2VlcmQgaGVlZnQgaW5nZXZvZXJkIHphbCBkZSBhcHAgdXcgZ2VicnVpa2Vyc2dlZ2V2ZW5zIHZlcndpamRlcmVuLiBVIGt1bnQgZGFuIG9wbmlldXcgaW5sb2dnZW4gb20gZGUgYXBwIHdlZXIgdGUga3VubmVuIGdlYnJ1aWtlbi5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2F0aWVzXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiVSBrcmlqZ3QgZWVuIG5vdGlmaWNhdGllIHdhbm5lZXIgaWVtYW5kIHZvb3IgdXcgYmVyaWNodCBzdGVtdC48YnIvPiA8Yj5PcG1lcmtpbmc6PC9iPiBOb3RpZmljYXRpZXMgZ2VlZnQgc3RlbWdld2ljaHQgYWFuIGFsc29vayBpbiBoZXQgbWVsZGluZ3NiZXJpY2h0LiAoem93ZWwgdm9vciBzdGVtIG9taG9vZywgc3RlbSBvbWxhYWcsIHZlcndpamRlciBzdGVtKS5cIixcblx0XCJWT1RFXCI6IFwiU3RlbVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlUga3Jpamd0IGVlbiBub3RpZmljYXRpZSB3YW5uZWVyIGllbWFuZCByZWFnZWVydCBvcCB1dyBiZXJpY2h0ZW4gb2YgcmVhY3RpZXMuIDxici8+IDxiPk9wbWVya2luZzo8L2I+IE5vdGlmaWNhdGllcyBvb2sgd2FubmVlciBpZW1hbmQgemlqbi9oYWFyIHJlYWN0aWVzIDxiPmFhbnBhc3Q8L2I+LlwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21tZW50YWFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdSB2b2xndCBvZiBzdG9wdCBtZXQgdm9sZ2VuIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiVmVybWVsZGluZ2VuXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlUga3Jpamd0IGVlbiBub3RpZmljYXRpZSB3YW5uZWVyIGllbWFuZCB1IG5vZW10IGluIHppam4gb2YgaGFhciBiZXJpY2h0L3JlYWN0aWUhXCIsXG5cdFwiUkVTVEVFTVwiOiBcIkhlcmJsb2dcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdXcgYmVyaWNodCBoZXJibG9nZCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYXRpZXNcIixcblx0XCJWT1RJTkdcIjogXCJTdGVtbWVuXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJTdGVtZ2V3aWNodCBvZiBwZXJjZW50YWdlIGhlYmJlbiBpbnZsb2VkIG9wIFN0ZW1rcmFjaHQgaW4gZGUgYXBwLCB6b2RhdCB1IHV3IHN0ZW1vcGJyZW5nc3RlbiBrdW50IHJlZ3VsZXJlbi4gPGJyLz48YnIvPjxiPk9wbWVya2luZzo8L2I+IERpdCB6YWwgdXcgc3RlbWdld2ljaHQvcGVyY2VudGFnZSB2b29yIGhldCBvbWxhYWcgc3RlbW1lbiBvb2sgYWFudGFzdGVuIGVuIGdlbGR0IHZvb3IgZGUgZ2VoZWxlIGFwcFwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiQWFuYmV2b2xlblwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIldpanppZ2luZ2VuIG9wc2xhYW5cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIlN0ZW1tZXJzIGluZm9ybWF0aWVcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJXZWxrb20gdGVydWchXCIsXG5cdFwiTE9HSU5fMVwiOiBcIkxvZyBpbiBtZXQgdXcgZ2VicnVpa2Vyc25hYW0gZW4gd2FjaHR3b29yZCBvbSB2ZXJkZXIgdGUgZ2Fhbi5cIixcblx0XCJMT0dJTl8yXCI6IFwiUG9zdGluZyBzbGV1dGVsIHdvcmR0IGdlYnJ1aWt0IHZvb3IgaGV0IHBsYWF0c2VuIHZhbiBiZXJpY2h0ZW4sIHJlYWN0aWVzLCBzdGVtbWVuIGVuIGhldCB2b2xnZW4gdmFuIGdlYnJ1aWtlcnMuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFjdGlldmUgc2xldXRlbCB3b3JkdCBnZWJydWlrdCB2b29yIG92ZXJtYWtlbiBlbiBhYW5wYXNzaW5nZW4gdmFuIGRlIHByb2ZpZWwgZm90by5cIixcblx0XCJMT0dJTl80XCI6IFwiR2VicnVpa2Vyc2dlZ2V2ZW5zIHdvcmRlbiBsb2thYWwgb3AgdXcgYXBwYXJhYXQgb3BnZXNsYWdlbi4gQmlqIGhldCB1aXRsb2dnZW4gd29yZGVuIGRlIGdlZ2V2ZW5zIHZlcndpamRlcmQhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiSGVlZnQgdSBnZWVuIGFjY291bnQ/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJNZWxkIGplIG51IGFhblwiLFxuXHRcIkNBTkNFTFwiOiBcIkFubnVsZXJlblwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiVWl0Z2VicmVpZFwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJBY3RpZXZlIHByaXbDqSBzbGV1dGVsXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJQb3N0aW5nIHByaXbDqSBzbGV1dGVsXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJIb29mZHdhY2h0d29vcmRcIixcblx0XCJVU0VSTkFNRVwiOiBcIkdlYnJ1aWtlcnNuYWFtXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiS2FhcnQgd2VlcmdhdmVcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJDb21wYWN0ZSB3ZWVyZ2F2ZVwiLFxuXHRcIlNFQVJDSFwiOiBcIlpvZWtlblwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiUGxhYXRzIGVlbiBiZXJpY2h0XCIsXG5cdFwiUkVQTFlUT1wiOiBcIlJlYWdlZXIgb3BcIixcblx0XCJQT1NUXCI6IFwiQmVyaWNodFwiLFxuXHRcIlBSRVZJRVdcIjogXCJQcmV2aWV3XCIsXG5cdFwiREVGQVVMVFwiOiBcIlN0YW5kYWFyZCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgVXAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiVWl0YmV0YWxpbmcgQWZ3aWp6ZW5cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIk9QU0xBQU4gVk9PUiBMQVRFUlwiLFxuXHRcIkNMRUFSXCI6IFwiTEVFR01BS0VOXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiUGxhYXRzIGJlcmljaHRcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJSZWFnZWVyIG9wIGJlcmljaHRcIixcblx0XCJUSVRMRVwiOiBcIlRpdGVsXCIsXG5cdFwiVEFHU1wiOiBcIkxhYmVsc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIktPTVQgTklFVCBPVkVSRUVOXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJCZXZlc3RpZyBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJPTkpVSVNUXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiQmVyaWNodCBvcGVuZW5cIixcblx0XCJTRVRfUElOXCI6IFwiSW5zdGVsbGVuIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkludm9lcmVuIFBJTlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIldlZXQgdSBoZXQgemVrZXI/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJIZXJibG9nZ2VuIGlzIGRlZmluaXRpZWYsIHdpbHQgdSBkb29yZ2Fhbj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJWZXJ6ZW5kZm91dCwgcHJvYmVlciBvcG5pZXV3IVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTdWNjZXN2b2xcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIkJlcmljaHQgaGVyYmxvZ2QhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIklubG9nZ2VuIG1pc2x1a3QhIENvbnRyb2xlZXIgb2YgdSBnZXByb2JlZXJkIGhlZWZ0IGluIHRlIGxvZ2dlbiBtZXQgdXcgaG9vZmR3YWNodHdvb3JkIG9mIFBvc3RpbmcgcHJpdsOpIHNsZXV0ZWwgYWxzIHUgdm9vciBnZWF2YW5jZWVyZGUgbW9kdXMgaGVlZnQgZ2Vrb3plbi5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJJbmxvZ2dlbiBtaXNsdWt0ISBDb250cm9sZWVyIG9mIHUgZ2Vwcm9iZWVyZCBoZWVmdCBpbiB0ZSBsb2dnZW4gbWV0IHV3IGhvb2Zkd2FjaHR3b29yZCBvZiBBY3RpZXZlIHByaXbDqSBzbGV1dGVsIGFscyB1IHZvb3IgZ2VhdmFuY2VlcmRlIG1vZHVzIGhlZWZ0IGdla296ZW4uXCIsXG5cdFwiV0FSTklOR1wiOiBcIldhYXJzY2h1d2luZ1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJTdGVtbWVuIHZvb3Igd2l0bmVzc1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiR2VzdGVtZCB2b29yIHdpdG5lc3NcIixcblx0XCJBR09cIjogXCJnZWxlZGVuXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJ2YW5hZiBudVwiLFxuXHRcIlNFQ1NcIjogXCJzZWNzXCIsXG5cdFwiQV9NSU5cIjogXCJlZW4gbWludXV0XCIsXG5cdFwiTUlOU1wiOiBcIm1pbnV0ZW5cIixcblx0XCJBTl9IT1VSXCI6IFwiZWVuIHV1clwiLFxuXHRcIkhPVVJTXCI6IFwidXJlblwiLFxuXHRcIkFfREFZXCI6IFwiZWVuIGRhZ1wiLFxuXHRcIkRBWVNcIjogXCJkYWdlblwiLFxuXHRcIkFfTU9OVEhcIjogXCJlZW4gbWFhbmRcIixcblx0XCJNT05USFNcIjogXCJtYWFuZGVuXCIsXG5cdFwiQV9ZRUFSXCI6IFwiZWVuIGphYXJcIixcblx0XCJZRUFSU1wiOiBcImphcmVuXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4uIGxlZXN0aWpkXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIlN0ZW0gT21sYWFnIG9mIFZsYWdcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJOZWVtIEJlZWxkXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJTZWxlY3RlZXIgRm90b1wiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiU3RlbCBFaWdlbiBVUkwgaW5cIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkZvdG8gSW52b2VnZW5cIixcblx0XCJFUlJPUlwiOiBcIkZvdXRcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJVcGxvYWQgRm91dFwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJDYW1lcmEgR2Vhbm51bGVlcmRcIixcblx0XCJTRVRfVVJMXCI6IFwiU3RlbCBVUkwgaW5cIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWN0ZSB3ZWIgbGluayB2b29yIGRlIGZvdG9cIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIkNvbW1lbnRhYXIgaXMgdmVyc3R1dXJkIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiSGV0IHZlcndpamRlcmVuIHZhbiByZWFjdGllcyBpcyBkZWZpbml0aWVmLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiVmVyd2lqZGVyZGUgcmVhY3RpZVwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiRm90byBpcyBhYW4gaGV0IHVwbG9hZGVuXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlVwbG9hZCBHZXNsYWFnZFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJVcGxvYWQgTWlzbHVrdFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkhldCB3YWNodHdvb3JkIG9mIGdlYnJ1aWtlcnNuYWFtIGlzIGZvdXRcIixcblx0XCJJTkZPXCI6IFwiSW5mb1wiLFxuXHRcIlFSX1RFWFRcIjogXCJQbGFhdHMgZWVuIFFSIGNvZGUgaW4gaGV0IHNjYW5nZWJpZWRcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJDb250cm9sZWVyIG9mIHUgZ2Vub2VnIHRlZ29lZCBoZWVmdCB2b29yIGRlIHRyYW5zYWN0aWUhXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkRlIGdlYnJ1aWtlciBuYWFyIHdpZSB1IHByb2JlZXJ0IG92ZXIgdGUgbWFrZW4sIGJlc3RhYXQgbmlldCFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiV2VldCB1IHpla2VyIGRhdCB1IHdpbHQgb3Zlcm1ha2VuP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkJldmVzdGlnaW5nXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJUcmFuc2FjdGllIGlzIHZlcnN0dXVyZFwiLFxuXHRcIkZFRURcIjogXCJGZWVkXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJUcmVuZGluZ1wiLFxuXHRcIkhPVFwiOiBcIlBvcHVsYWlyXCIsXG5cdFwiTkVXXCI6IFwiTmlldXdcIixcblx0XCJQUk9NT1RFRFwiOiBcIkdlc3BvbnNvcmRcIixcblx0XCJWT1RFU1wiOiBcIlN0ZW1tZW5cIixcblx0XCJQQVlPVVRcIjogXCJVaXRiZXRhbGluZ1wiLFxuXHRcIkNPTU1FTlRTXCI6IFwiUmVhY3RpZXNcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5kaW5nIGxhYXRzdGUgMzAgZGFnZW5cIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJTb3J0ZWVyIGJlcmljaHRlbiBvcDpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJVaXRiZXRhbGluZ3NjeWNsdXNcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW50acOrbGUgVWl0YmV0YWxpbmdcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlZlcmxlZGVuIFVpdGJldGFsaW5nXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIkF1dGV1ciBVaXRiZXRhbGluZ1wiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkN1cmF0aWUgVWl0YmV0YWxpbmdcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIkJlcmljaHQgaXMgdmVyem9uZGVuIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJUZSB2ZXJzdHVyZW4gYmVyaWNodGVuIVwiLFxuXHRcIlNBVkVEXCI6IFwiT3BnZXNsYWdlblwiLFxuXHRcIkNMRUFSRURcIjogXCJHZXdpc3RcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiRWVuIGJlcmljaHQgdmxhZ2dlbiBvZiBvbWxhYWcgc3RlbW1lbiBrYW4gZGUgb3BicmVuZ3N0ZW4gd2VnaGFsZW4gZW4gbWluZGVyIHppY2h0YmFhciBtYWtlbi48YnI+PGJyPkRlIHZsYWcgbWFnIGFsbGVlbiBpbiBkZSB2b2xnZW5kZSBnZXZhbGxlbiBnZWJydWlrdCB3b3JkZW46IDx1bD48bGk+RnJhdWRlIG9mIFBsYWdpYWF0PC9saT48bGk+SGFhdHNwcmFhayBvZiBJbnRlcm5ldCBUcm9sbGluZzwvbGk+PGxpPk1ldCBpbnRlbnRpZSBpbiB2ZXJrZWVyZGUgY2F0ZWdvcmllIGdlcGxhYXRzdCBvZiBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWlldCB2ZXJ6b2VrIGJlcmVpa3QuIEJla2lqayBvb2sgYW5kZXJlIHRyZW5kcy90YWdzIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIkJlcmljaHQgaXMgdmFuIGJsYWR3aWp6ZXJzIHZlcndpamRlcmQhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIkJlcmljaHQgaXMgYWFuIGJsYWR3aWp6ZXJzIHRvZWdldm9lZ2QhXCIsXG5cdFwiUkVTRVRcIjogXCJIZXJzdGVsbGVuXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJQYXMgcHJvZmllbGZvdG8gYWFuXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJQYXMgb21zbGFnZm90byBhYW5cIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJHZWxpZXZlIGVlbiBhY3RpZXZlIHNsZXV0ZWwgdGUgZ2JlcnVpa2VuIHdhbm5lZXIgdSBraWVzdCB2b29yIGdlYXZhbmNlZXJkZSBpbmxvZyBtb2R1cyFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJEaXQgemFsIGRlIHByb2ZpZWxmb3RvIHZhbiBkZSBnZWJydWlrZXIgaGVyc3RlbGxlblwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIkRpdCB6YWwgZGUgb21zbGFnZm90byB2YW4gZGUgZ2VicnVpa2VyIGhlcnN0ZWxsZW5cIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIlNlcnZlciB1cGRhdGUgdmVyZWlzdCBoZXJzdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiSW5zdGVsbGluZ2VuIHppam4gYmlqZ2V3ZXJrdCFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJUYWxlblwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiSGllciBrdW50IHUgZGUgdGFhbCB2YW4gZGUgYXBwIHZlcmFuZGVyZW4uXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIk9tIGRpdCB0ZSBkb2VuIGRpZW50IHUgaW4gdGUgbG9nZ2VuIG1ldCB1dyBob29mZHdhY2h0d29vcmQsIGFjdGlldmUvcG9zdGluZyBzbGV1dGVsLiBMb2cgYWxzdHVibGllZnQgaW4gZW4gcHJvYmVlciBvcG5pZXV3LlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxsZXJpalwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlZlcnRhbGVyc1wiLFxuXHRcIlNIQVJFXCI6IFwiRGVsZW5cIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1hcmt0cGxhYXRzXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJCZXVyc1wiLFxuXHRcIkRSQUZUU1wiOiBcIkNvbmNlcHRlblwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIkJlcmljaHQgaXMgdWl0IGNvbmNlcHRlbiB2ZXJ3aWpkZXJkIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJCZXJpY2h0IHRvZWdldm9lZ2QgYWFuIGNvbmNlcHRlbiFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiVmVlZyBuYWFyIGxpbmtzIHZvb3Igb3B0aWVzXCIsXG5cdFwiTUFOQUdFXCI6IFwiQmVoZWVyXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkFmYmVlbGRpbmcgaXMgdmVyd2lqZGVyZFwiLFxuXHRcIkNPUFlcIjogXCJLb3Bpw6tyZW5cIixcblx0XCJOT19JTUFHRVwiOiBcIkplIGhlYnQgbm9nIGdlZW4gYWZiZWVsZGluZyBnZXVwbG9hZCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlRyZWsgb21sYWFnIG9tIHRlIHZlcnZlcnNlblwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJFeHRlcm5lIGFwcGxpY2F0aWVzXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpbnNcIixcblx0XCJTVUdHRVNUXCI6IFwiU3VnZ2VyZWVyXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJCaW5uZW5rb3J0XCIsXG5cdFwiQ0hBSU5cIjogXCJLZXRlblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJIaWVyIGt1bnQgdSB2ZXJhbmRlcmVuIHZhbiBibG9ja2NoYWluIG9mIHN0YW5kYWFyZCBwbGF0Zm9ybS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlZhbHV0YVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJWZXJhbmRlciBoaWVyIHV3IHN0YW5kYWFyZCB2YWx1dGEuIEJlbG9uaW5nZW4gdm9vciBiZXJpY2h0ZW4vcmVhY3RpZXMgaW4gZGV6ZSB2YWx1dGEuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+RnVuY3RpZXM8L2I+PGJyPi0gVG9lZ2FuZyB0b3QgdW5pZWtlIGFydGlrZWxlbiBtZXQgdWl0ZWVubG9wZW5kZSBvbmRlcndlcnBlbi48YnI+LSBDb252ZXJzZWVyIG1ldCBhdXRldXJzIGRvb3IgdGUgcmVhZ2VyZW4gZW4gdGUgZGlzY3Vzc2nDq3Jlbi48YnI+LSBTdGVtbWVuIHZvb3IgYmVyaWNodGVuIG9tIHpvIGRlIGF1dGV1ciB0ZSBiZWxvbmVuIGFsc29vayBiZWxvbmluZyB0ZSBvbnR2YW5nZW4gdm9vciBjdXJlcmVuLjxicj4tIFB1YmxpY2VyZW4gdmFuIHV3IGFydGlrZWxlbiBlbiBiZXJpY2h0ZW4gZW4gdmVyZGllbiBiZWxvbmluZ2VuIGRvb3IgaW50ZXJhY3RpZSBlbiBncm9laSB2YW4gdm9sZ2Vycy48YnI+LSBTY2hyaWpmIGFydGlrZWxlbiwgc2xhIG1lZXJkZXJlIGNvbmNlcHRlbiBvcCBlZW4gbGF0ZXIgdGlqZHN0aXAgdGUgcHVibGljZXJlbi48YnI+LSBTbGEgZmF2b3JpZXRlIGFydGlrZWxlbiBvcCBvbmRlciBibGFkd2lqemVycyBvbSBkZXplIGxhdGVyIHRlIGxlemVuLjxicj4tIFdpc3NlbCBvZiB2ZXJ6aWx2ZXIgamUgaW5rb21zdGVuLjxicj4tIE1hYWsgdGVnb2VkZW4gb3ZlciBhYW4gYW5kZXJlIGF1dGV1cnMgb2YgZ2VicnVpa2VycywgdnJpZW5kZW4sIHZvbGdlcnMsIGV0Yy48YnI+LSBWb2xnIGludGVyZXNzYW50ZSBhdXRldXJzLCBibG9nZ2Vycy48YnI+LSBab2VrIGplIHZvbGdlcnMgZW4gYXV0ZXVycyBkaWUgamUgdm9sZ3QuPGJyPi0gT250dmFuZyBub3RpZmljYXRpZXMgb20gaW4gY29udGFjdCB0ZSBibGlqdmVuIG1ldCBqZSB2b2xnZXJzIGVuIGRpc2N1c3NpZXMgd2FhcmluIGplIGJldHJva2tlbiBiZW50Ljxicj4tIFpvZWsgb3AgaW50ZXJlc3RhbnRlIGxhYmVscy9jYXRlZ29yaWXDq24gdmFuIGFydGlrZWxlbiwgYXV0ZXVycy48YnI+LSBQZXJzb25hbGlzZWVyIGplIHByb2ZpZWwuPGJyPi0gVmVsZSBhbmRlcmUgZnVuY3RpZXMgZGllIG5vZyB6dWxsZW4gd29yZGVuIHRvZWdldm9lZ2QuPGJyPjxicj48Yj5WZWlsaWdoZWlkPC9iPjxicj4xLiBBcHAgemFsIG5vb2l0IHRlZ29lZGVuIHZhbiBkZSBnZWJydWlrZXIgYWFucmFrZW4gb2Ygb3BzbGFhbi48YnI+Mi4gQXBwIGhlZWZ0IGVlbiBjbGllbnQtc2lkZSBiZXZlaWxpZ2luZ3Ntb2RlbCwgbWV0IHByaXbDqSBzbGV1dGVscyBkaWUgbG9rYWFsIG9wZ2VzbGFnZW4gd29yZGVuIGVuIG5vb2l0IG5hYXIgYW5kZXJlIHNlcnZlcnMgdG9lZ2VzdHV1cmQgd29yZGVuLCB1IGJlbnQgemVsZiB2ZXJhbnR3b29yZGVsaWprIG9tIGhldCB3YWNodHdvb3JkIG9wIHRlIHNsYWFuLjxicj4zLiBBcHAgYmllZHQgZWVuIHNpbXBlbGUgZW4gYWFuc3ByZWtlbmRlIGdlYnJ1aWtlcnN0b2VnYW5nLjxicj40LiBBcHAgYmllZHQgZWVuIGV4dHJhIGJldmVpbGlnaW5nIGRvb3IgbWlkZGVsIHZhbiBlZW4gcGluY29kZTxicj48YnI+ZVN0ZWVtIG9uZGVyc3RldW5kIFN0ZWVtIGVuIEdvbG9zIHBsYXRmb3JtZW4uPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJPcHJpY2h0ZXIgZW4gSG9vZmRvbnR3aWtrZWxhYXJcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIkFjY291bnQgdG9ldm9lZ2VuXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0Zm9ybVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkVzY3Jvdy1hZ2VudFwiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlJhdGlmaWNhdGllIHRlcm1pam5cIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyB2ZXJsb3BlblwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgdmVyZ29lZGluZ1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIkVzY3JvdyB2b29yd2FhcmRlblwiLFxuXHRcIk5JR0hUX01PREVcIjogXCJOYWNodCBtb2R1c1wiLFxuXHRcIkRBWV9NT0RFXCI6IFwiRGFnIG1vZHVzXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiQmVraWprIGRlIHZvbGxlZGlnZSBjb250ZXh0XCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIkdlYnJ1aWtlciBuaWV0IGdldm9uZGVuXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkdvZWRrZXVyZW5cIixcblx0XCJESVNQVVRFXCI6IFwiR2VzY2hpbFwiLFxuXHRcIlJFTEVBU0VcIjogXCJWZXJzaWVcIixcblx0XCJGUk9NXCI6IFwiVmFuXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIlZlcnplbmRcIixcblx0XCJSRUNFSVZFUlwiOiBcIk9udHZhbmdlclwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiUGxhYXRzXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYnNpdGVcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJUb29uIG5hYW1cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiU3Ryb25hIGfFgsOzd25hXCIsXG5cdFwiTE9HSU5cIjogXCJaYWxvZ3VqXCIsXG5cdFwiTE9HT1VUXCI6IFwiV3lsb2d1alwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJPYnNlcnd1alwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlpha8WCYWRraVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiUHJ6ZWxld1wiLFxuXHRcIk1BUktFVFwiOiBcIkdpZcWCZGFcIixcblx0XCJTRVRUSU5HU1wiOiBcIlVzdGF3aWVuaWFcIixcblx0XCJBQk9VVFwiOiBcIk8gTmFzXCIsXG5cdFwiQUJPVVRfMVwiOiBcImdkemllIGthxbxkeSBtb8W8ZSB6ZG9ieXdhxIcgd3luYWdyb2R6ZW5pZSB6YSBzd29qZSB3cGlzeSFcIixcblx0XCJBQk9VVF8yXCI6IFwiZnVua2Nqb251amUgdyBvcGFyY2l1IG8gcGF0Zm9ybcSZIHt7cGxhdGZvcm1uYW1lfX0uIEFwbGlrYWNqYSBqZXN0IHN0d29yem9uYSBwcnplelwiLFxuXHRcIkFCT1VUXzNcIjogXCJpIGplc3Qgb25hIG90d2FydHltIGkgcHJvd2Fkem9ueW0gcHJ6ZXogc3BvxYJlY3pub8WbxIcgcHJvamVrdGVtLiBPZmVydWplIGRvc3TEmXAgZG8gY3p5dGFuaWEsIGtvbWVudG93YW5pYSwgb2RkYXdhbmlhIGfFgm9zdSBuYSB0cmXFm2NpIG9yYXogdWRvc3TEmXBuaWFuaWEgd3Bpc8OzdywgYSB0YWvFvGUgbmEgemFyesSFZHphbmllIHphcm9ia2FtaSBvcmF6IGlubnltaSBkb3N0xJlwbnltaSBvcGNqYW1pIG9mZXJvd2FueW1pIHByemV6IMWCYcWEY3VjaCBibG9rw7N3IHt7cGxhdGZvcm1uYW1lfX0gaSB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIkFwbGlrYWNqYSBuaWdkeSBuaWUgbWEgZG9zdMSZcHUgaSBuaWUgcHJ6ZXRyenltdWplIMWbcm9ka8OzdyBmaW5hbnNvd3ljaCB1xbx5dGtvd25pa2EuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIkFwbGlrYWNqYSBvZmVydWplIG1vZGVsIGJlenBpZWN6ZcWEc3R3YSBwbyBzdHJvbmllIGtsaWVudGEsIGdkemllIGtsdWN6ZSBwcnl3YXRuZSBzxIUgcHJ6ZWNob3d5d2FuZSBsb2thbG5pZSBpIG5pZ2R5IG5pZSBzxIUgcHJ6ZXN5xYJhbmUgbmEgamFraWVrb2x3aWVrIHNlcndlcnkuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIkFwbGlrYWNqYSBvZmVydWplIMWCYXR3eSBpIHByenlqZW1ueSB3IG9ic8WCdWR6ZSBpbnRlcmZlanMuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIkFwbGlrYWNqYSBuaWdkeSBuaWUgd3ltYWdhIHBvZGFuaWEgZGFueWNoIG9zb2Jvd3ljaCBvZCBzd29pY2ggdcW8eXRrb3duaWvDs3cuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlphZ8WCb3N1aiBuYSBnb29kLWthcm1hIG5hIMWbd2lhZGthXCIsXG5cdFwiQUJPVVRfOVwiOiBcIktvbnRha3QvT3BpbmllXCIsXG5cdFwiQUJPVVRfMTBcIjogXCJXacSZY2VqIGluZm9ybWFjamk6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiVXN1xYRcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIldpZG9rIG5hIGdpZcWCZMSZXCIsXG5cdFwiUFJJQ0VcIjogXCJDZW5hXCIsXG5cdFwiQU1PVU5UXCI6IFwiSWxvxZvEh1wiLFxuXHRcIlRPVEFMXCI6IFwiU3VtYVwiLFxuXHRcIk5PT1JERVJTXCI6IFwiQnJhayBvdHdhcnR5Y2ggemxlY2XFhCBkbGFcIixcblx0XCJEQVRFXCI6IFwiRGF0YVwiLFxuXHRcIkJVWVwiOiBcIkt1cFwiLFxuXHRcIlNFTExcIjogXCJTcHJ6ZWRhalwiLFxuXHRcIk9QRU5cIjogXCJXIHRva3VcIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaWFcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIk9ic2Vyd3VqIHLDs3duaWXFvFwiLFxuXHRcIkZPTExPV0VEXCI6IFwiT2JzZXJ3b3dhbnlcIixcblx0XCJVTkZPTExPV1wiOiBcIlByemVzdGHFhCBvYnNlcndvd2HEh1wiLFxuXHRcIkZPTExPV0lOR1wiOiBcIk9ic2Vyd3VqZXN6XCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiT2JzZXJ3dWrEhSBjacSZXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlN6dWthaiB3xZtyw7NkIG9ic2Vyd3VqxIVjeWNoXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIlN6dWthaiB3xZtyw7NkIG9ic2Vyd293YW55Y2hcIixcblx0XCJCWVwiOiBcInByemV6XCIsXG5cdFwiSU5cIjogXCJ3XCIsXG5cdFwiTUVOVVwiOiBcIk1lbnVcIixcblx0XCJCT09LTUFSS1wiOiBcIlpha8WCYWRraVwiLFxuXHRcIlJFQkxPR1wiOiBcIlJlYmxvZ3VqXCIsXG5cdFwiVVBWT1RFXCI6IFwiR8WCb3MgemFcIixcblx0XCJET1dOVk9URVwiOiBcIkfFgm9zIHByemVjaXdcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiQW51bHVqIGfFgm9zIHByemVjaXdcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIkFudWx1aiBnxYJvcyB6YVwiLFxuXHRcIlJFUExZXCI6IFwiT2Rwb3dpZWTFulwiLFxuXHRcIkVESVRcIjogXCJFZHl0dWpcIixcblx0XCJQT1NUXzFcIjogXCJQcnplY2nEhWduaWoga29tZW50YXJ6IHcgbGV3bywgYWJ5IHpvYmFjennEhyBkb3N0xJlwbmUgb3BjamVcIixcblx0XCJQT1NUXzJcIjogXCJOYWNpxZtuaWogbmEga29tZW50YXJ6ZSwgYWJ5IHJvendpbsSFxIdcIixcblx0XCJPUFRJT05TXCI6IFwiT3BjamVcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZXN0ZWVtb3dhbnkgcHJ6ZXpcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOYSByYXppZSBuaWMgdHUgbmllIG1hLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJTYWxkYVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0gd3ltaWVuaWFsbmUgdG9rZW55LCBrdMOzcmUgbW9nxIUgYnnEhyBwcnpldHJhbnNmZXJvd2FuZSB3IGRvd29sbnltIG1vbWVuY2llLiB7e3BsYXRmb3JtbmFtZX19IG1vZ8SFIGJ5xIcgd3ltaWVuaW9uZSBuYSB7e3BsYXRmb3JtcG93ZXJ9fSB3IHByb2Nlc2llIHp3YW55bSBQb3dlci11cC5cXG5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSB0b2tlbnkgd3DFgnl3dSwga3TDs3JlIHVtb8W8bGl3aWFqxIUgbmEgemRvYnl3YW5pZSB3acSZa3N6ZWogaWxvxZtjaSBtb2N5IHphIHRyenltYW5pZSBpY2ggZMWCdW90ZXJtaW5vd28gb3JheiB6YSBnxYJvc293YW5pZSBuYSB3cGlzeS4gSW0gd2nEmWNlaiBzacSZIGljaCBwb3NpYWRhLCB0eW0gYmFyZHppZWogd3DFgnl3YSBzacSZIG5hIHd5bmFncm9kemVuaWUgaW5ueWNoIHdwaXPDs3cgaSBuYSB6ZG9ieXdhbmllIG5hZ3LDs2QgendpxIV6YW5lIHogb2RkYW5pZW0gZ8WCb3N1LlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VueSB3YXJ0ZSBva2/Fgm8ge3twbGF0Zm9ybXN1bml0fX0gcGxhdGZvcm15IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiU3phY293YW5hIHdhcnRvxZvEh1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIldhcnRvxZvEhyBqZXN0IHN6YWNvd2FuYSBuYSBwb2RzdGF3aWUgxZtyZWRuaWVqIHdhcnRvxZtjaSB6IDctbWl1IGRuaS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiSGlzdG9yaWEgdHJhbnNha2NqaVwiLFxuXHRcIlBPU1RJTkdcIjogXCJVZG9zdMSZcG5pYW5pZVwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIktsdWN6IHVkb3N0xJlwbmllbmlhIGplc3QgdcW8eXdhbnkgcHJ6eSB1ZG9zdMSZcG5pYW5pdSB3cGlzw7N3IGkgb2RkYXdhbml1IGfFgm9zw7N3LiBQb3dpbmllbiBiecSHIGlubnkgbmnFvCBrbHVjeiBha3R5d255IGkga2x1Y3ogd8WCYXNub8WbY2kuXCIsXG5cdFwiT1dORVJcIjogXCJXxYJhxZtjaWNpZWxcIixcblx0XCJQUk9GSUxFXzZcIjogXCJLbHVjeiB3xYJhc25vxZtjaSBqZXN0IGtsdWN6ZW0gZ8WCw7N3bnltIGtvbnRhIGkgamVzdCB3eW1hZ2FueSBkbyB6bWlhbnkgcG96b3N0YcWCeWNoIGtsdWN6eS4gS2x1Y3ogcHJ5d2F0bnkgbHViIGhhc8WCbyBkbyBrbHVjemEgd8WCYXNub8WbY2kgcG93aW5ubyBiecSHIHRyenltYW5lIG9mZmxpbmUsIGdkeSBqZXN0IHRvIHR5bGtvIG1vxbxsaXdlLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFrdHl3bnlcIixcblx0XCJQUk9GSUxFXzdcIjogXCJLbHVjeiBha3R5d255IGplc3QgdcW8eXdhbnkgZG8gd3lrb255d2FuaWEgcHJ6ZWxld8OzdyBpIHNrxYJhZGFuaWEgemFtw7N3aWXFhCBuYSB3ZXduxJl0cnpuZWogZ2llxYJkemllLlwiLFxuXHRcIk1FTU9cIjogXCJOb3RhdGthXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiS2x1Y3ogbm90YXRraSBqZXN0IHXFvHl0eSwgYWJ5IHNwb3J6xIVkemHEhyBpIGN6eXRhxIcgbm90YXRraS5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiV3Bpc3lcIixcblx0XCJSRVBMSUVTXCI6IFwiT2Rwb3dpZWR6aVwiLFxuXHRcIldBTExFVFwiOiBcIlBvcnRmZWxcIixcblx0XCJUQUdcIjogXCJFdHlraWV0YVwiLFxuXHRcIlVTRVJcIjogXCJVxbx5dGtvd25pa1wiLFxuXHRcIkNMT1NFXCI6IFwiWmFta25palwiLFxuXHRcIlRPXCI6IFwiRG9cIixcblx0XCJBU1NFVFwiOiBcIkthcGl0YcWCXCIsXG5cdFwiU0VORFwiOiBcIld5xZtsaWpcIixcblx0XCJTRUNVUklUWVwiOiBcIkJlenBpZWN6ZcWEc3R3b1wiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRvc3TEmXBueVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTm90YXRrYSBwdWJsaWN6bmFcIixcblx0XCJUT19ERVNDXCI6IFwiVcW8eXRrb3duaWsgbnAuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIktvZCBQSU5cIixcblx0XCJQSU5fVEVYVFwiOiBcIktvZCBQSU4gcG96d2FsYSBDaSB6YWJlenBpZWN6ecSHIGFwbGlrYWNqxJkgb3JheiB0d29qZSBkYW5lLiA8YnIvPjxici8+IDxiPlV3YWdhOjwvPiBNYXN6IG1ha3N5bWFsbmllIDQgcHLDs2J5IGFieSB3cGlzYcSHIHBvcHJhd25lIGhhc8WCbyBpIG9kYmxva293YcSHIGtvbnRvLCBqZcW8ZWxpIHphcG9tbmlhxYJlxZsga29kdSBQSU4gbHViIHdwaXNhxYJlxZsgesWCZSBoYXPFgm8gd2nEmWNlaiByYXp5LCBhcGxpa2FjamEgdXN1bmllIHdzenlzdGtpZSBkYW5lIHXFvHl0a293bmlrYS4gTW/FvGVzeiBzacSZIHd0ZWR5IHphbG9nb3dhxIcgcG9ub3duaWUgaSBrb250eW51b3dhxIcgdcW8eXRrb3dhbmllIGFwbGlrYWNqaS5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiUG93aWFkb21pZW5pYVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIk90cnp5bWFzeiBwb3dpYWRvbWllbmllLCBnZHkga3RvxZsgb2RkYSBnxYJvcyBuYSB0d8OzaiB3cGlzISA8YnIvPjxiPlV3YWdhOjwvYj5Qb3dpYWRvbWllbmlhIHphd2llcmFqxIUgdGFrxbxlIHR5cCBnxYJvc3UgKHR6bi4gZ8WCb3MgemEsIGfFgm9zIHByemVjaXcsIGFudWx1aiBnxYJvcykuXCIsXG5cdFwiVk9URVwiOiBcIlphZ8WCb3N1alwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIk90cnp5bWFzeiBwb3dhZG9taWVuaWUsIGdkeSBrdG/FmyBza29tZW50dWplIHR3w7NqIHdwaXMgbHViIGtvbWVudGFyeiE8YnIvPiA8Yj5Vd2FnYTo8L2I+Wm9zdGFuaWVzeiByw7N3bmllxbwgcG93aWFkb21pb255LCBnZHkga3RvxZsgPGI+ZWR5dHVqZTwvYj4gc3fDs2oga29tZW50YXJ6LlwiLFxuXHRcIkNPTU1FTlRcIjogXCJLb21lbnRhcnpcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIk90cnp5bWFzeiBwb3dpYWRvbWllbmllLCBnZHkga3RvxZsgemFjem5pZSBsdWIgcHJ6ZXN0YW5pZSBjacSZIG9ic2Vyd293YcSHIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiV3ptaWFua2lcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiWm9zdGFuaWVzeiBwb3dpYWRvbWlvbnksIGdkeSBrdG/FmyB3c3BvbW5pIGNpxJkgdyBzd29pbSB3cGlzaWUva29tZW50YXJ6dSFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9ndWpcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJPdHJ6eW1hc3ogcG93aWFkb21pZW5pZSwgZ2R5IGt0b8WbIHJlc3RlZW11amUgdHfDs2ogd3BpcyFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3VyYWNqZVwiLFxuXHRcIlZPVElOR1wiOiBcIk9kZGFuaWUgZ8WCb3N1XCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJNb2MgbHViIHByb2NlbnQgZ8WCb3N1IHdwxYJ5d2EgbmEgbW9jIG9kZGFuZWdvIGfFgm9zdSBpIHVtb8W8bGl3aWEgY2kgbmEgcmVndWxvd2FuaWUgc3dvamVnbyB3eW5hZ3JvZHplbmlhIHphIG9kZGFuZSBnxYJvc3kuIDxici8+PGJyLz48Yj5Vd2FnYTo8L2I+IFptaWFuYSB3cMWCeW5pZSBuYSBtb2MvcHJvY2VudCBnxYJvc3UgY2HFgmVqIGFwbGlrYWNqaSwgZG90eWN6eSB0byByw7N3bmllxbwgZ8WCb3PDs3cgb2RkYW55Y2ggcHJ6ZWNpd1wiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcndlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVrb21lbmRvd2FuZVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlphY2hvd2FqIHptaWFueVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiR8WCb3Nvd2FsaVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIldpdGFqIHBvbm93bmllIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJBYnkga29udHludW93YcSHLCB6YWxvZ3VqIHNpxJkgcHJ6eSB1xbx5Y2l1IGxvZ2ludSBpIGhhc8WCYS5cIixcblx0XCJMT0dJTl8yXCI6IFwiS2x1Y3ogdWRvc3TEmXBuaWFqxIVjeSBqZXN0IHXFvHl3YW55IGRvIHVkb3N0xJlwbmlhbmlhIHdwaXPDs3csIGtvbWVudG93YW5pYSwgZ8WCb3Nvd2FuaWEgaSDFm2xlZHplbmlhLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJLbHVjeiBha3R5d255IHXFvHl3YW55IGplc3QgZG8gd3lrb255d2FuaWEgcHJ6ZWxld8OzdyBpIHptaWFuIHpkasSZY2lhIHByb2ZpbG93ZWdvLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJEYW5lIHXFvHl0a293bmlrYSBzxIUgdHJ6eW1hbmUgbG9rYWxuaWUgcHJ6eSB1xbx5Y2lhIHR3b2plZ28gdXJ6xIVkemVuaWEuIFBvIHd5bG9nb3dhbml1IGRhbmUgem9zdGFqxIUgdXN1bmnEmXRlIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIk5pZSBtYXN6IGplc3pjemUga29udGE/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJaYcWCw7PFvCBrb250b1wiLFxuXHRcIkNBTkNFTFwiOiBcIkFudWx1alwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiWmFhd2Fuc293YW5lXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIktsdWN6IGFrdHl3bnkgcHJ5d2F0bnlcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIktsdWN6IHVkb3N0xJlwbmlhasSFY3kgcHJ5d2F0bnlcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIkhhc8WCbyBnxYLDs3duZVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiTG9naW5cIixcblx0XCJDQVJEX1ZJRVdcIjogXCJXaWRvayBrYXJ0eVwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIldpZG9rIGtvbXBha3Rvd3lcIixcblx0XCJTRUFSQ0hcIjogXCJTenVrYWpcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIk9wdWJsaWt1aiB0cmXFm8SHXCIsXG5cdFwiUkVQTFlUT1wiOiBcIk9kcG93aWVkelwiLFxuXHRcIlBPU1RcIjogXCJPcHVibGlrdWpcIixcblx0XCJQUkVWSUVXXCI6IFwiUG9kZ2zEhWRcIixcblx0XCJERUZBVUxUXCI6IFwiU3RhbmRhcmRvd2UgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIFVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIk9kbcOzdyB3eW5hZ3JvZHplbmlhXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJaQUNIT1dBSiBOQSBQw5PFuU5JRUpcIixcblx0XCJDTEVBUlwiOiBcIldZQ1pZxZrEhlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIk9wdWJsaWt1aiB3cGlzXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiU2tvbWVudHVqXCIsXG5cdFwiVElUTEVcIjogXCJUeXR1xYJcIixcblx0XCJUQUdTXCI6IFwiRXR5a2lldHlcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJCUkFLIFpHT0ROT8WaQ0lcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlBvd3TDs3J6IFBJTlwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIk5JRVBPUFJBV05ZXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwib3R3aWVyYW5pZSB3cGlzdVwiLFxuXHRcIlNFVF9QSU5cIjogXCJVc3RhdyBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJQb2RhaiBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJDenkgamVzdGXFmyBwZXdpZW4/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJSZWJsb2cgamVzdCBuaWVvZHdyYWNhbG5lLCBjenkgY2hjZXN6IGtvbnR5bnVvd2HEhz9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJCxYLEhWQgcG/FgsSFY3plbmlhLCBzcHLDs2J1aiBwb25vd25pZSFcIixcblx0XCJTVUNDRVNTXCI6IFwiWmFrb8WEY3pvbm8gcG93b2R6ZW5pZW1cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlJlYmxvZ3VqIHdwaXMhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkLFgsSFZCBsb2dvd2FuaWEhIFVwZXduaWogc2nEmSBjenkgemFsb2dvd2HFgmXFmyBzacSZIHByenkgdcW8eWNpdSBrbHVjemEgZ8WCw7N3bmVnbyBsdWIgY3p5IHXFvHnFgmXFmyBha3R5d25lZ28ga2x1Y3phIHByeXdhdG5lZ28gcHJ6eSBsb2dvd2FuaXUgdyB0cnliaWUgemFhd2Fuc293YW55bS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJCxYLEhWQgbG9nb3dhbmlhISBVcGV3bmlqIHNpxJkgY3p5IHphbG9nb3dhxYJlxZsgc2nEmSBwcnp5IHXFvHljaXUga2x1Y3phIGfFgsOzd25lZ28gbHViIGN6eSB1xbx5xYJlxZsgcHJ5d2F0bmVnbyBrbHVjemEgdWRvc3TEmXBuaWFqxIVjZWdvIHByenkgbG9nb3dhbml1IHcgdHJ5YmllIHphYXdhbnNvd2FueW0uXCIsXG5cdFwiV0FSTklOR1wiOiBcIlV3YWdhXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIkfFgm9zdWplc3ogbmEgxZt3aWFka2FcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlphZ8WCb3Nvd2HFgmXFmyBuYSDFm3dpYWRrYVwiLFxuXHRcIkFHT1wiOiBcInRlbXVcIixcblx0XCJGUk9NX05PV1wiOiBcIm9kIHRlcmF6XCIsXG5cdFwiU0VDU1wiOiBcInNla3VuZCh5KVwiLFxuXHRcIkFfTUlOXCI6IFwibWludXTEmVwiLFxuXHRcIk1JTlNcIjogXCJtaW51dCh5KVwiLFxuXHRcIkFOX0hPVVJcIjogXCJnb2R6aW7EmVwiLFxuXHRcIkhPVVJTXCI6IFwiZ29kemluKHkpXCIsXG5cdFwiQV9EQVlcIjogXCJkemllxYRcIixcblx0XCJEQVlTXCI6IFwiZG5pXCIsXG5cdFwiQV9NT05USFwiOiBcIm1pZXNpxIVjXCIsXG5cdFwiTU9OVEhTXCI6IFwibWllc2nEmWN5XCIsXG5cdFwiQV9ZRUFSXCI6IFwicm9rXCIsXG5cdFwiWUVBUlNcIjogXCJsYXQoYSlcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbnV0IHRlbXUgem9zdGHFgm8gcHJ6ZWN6eXRhbmVcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiR8WCb3N1aiBwcnplY2l3IGx1YiBvZmxhZ3VqXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiWnLDs2IgemRqxJljaWVcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIld5Ymllcnogb2JyYXpcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIlVzdGF3IHd5YnJhbnkgVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJXc3RhdyBvYnJhelwiLFxuXHRcIkVSUk9SXCI6IFwiQsWCxIVkXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiQsWCxIVkIHByenkgd3J6dWNhbml1IHBsaWt1XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkFwYXJhdCBuaWVha3R5d25hXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlVzdGF3IFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJCZXpwb8WbcmVkbmkgbGluayBuYSBzdHJvbsSZIHplIHpkasSZY2llbVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiS29tZW50YXJ6IHpvc3RhxYIgb3B1Ymxpa293YW55IVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiVXN1bmnEmWNpZSBrb21lbnRhcnp5IGplc3Qgbmllb2R3cmFjYWxuZS4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIlVzdcWEIGtvbWVudGFyelwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiV3N0YXcgemRqxJljaWVcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiV3N0YXdpZW5pZSB6YWtvxYRjem9uZVwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJXcnp1Y2VuaWUgbmllIHBvd2lvZMWCbyBzacSZXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiTmllcHJhd2lkxYJvd3kgbG9naW4gbHViIGhhc8WCb1wiLFxuXHRcIklORk9cIjogXCJJbmZvcm1hY2phXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlVtaWXFm8SHIGtvZCBRUiB3IG9icsSZYmllIHBvbGEgc2thbm93YW5pYVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIlVwZXduaWogc2nEmSwgY3p5IG1hc3ogd3lzdGFyY3phasSFY8SFIGlsb8WbxIcgxZtyb2Rrw7N3IGFieSB3eWtvbmHEhyB0cmFuc2FrY2rEmSFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiVcW8eXRrb3duaWsgZG8ga3TDs3JlZ28gcHLDs2J1amVzeiBwcnplc8WCYcSHIMWbcm9ka2ksIG5pZSBpc3RuaWVqZSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiQ3p5IG5hIHBld25vIGNoY2VzeiB3eXPFgmHEhyDFm3JvZGtpP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIlBvdHdpZXJkemVuaWVcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYWtjamEgdyB0b2t1XCIsXG5cdFwiRkVFRFwiOiBcIkFrdHVhbG5vxZtjaVwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmR5XCIsXG5cdFwiSE9UXCI6IFwiTmEgdG9waWVcIixcblx0XCJORVdcIjogXCJOb3dlXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3dhbmVcIixcblx0XCJWT1RFU1wiOiBcIklsb8WbxIcgZ8WCb3PDs3dcIixcblx0XCJQQVlPVVRcIjogXCJQcnp5Y2jDs2RcIixcblx0XCJDT01NRU5UU1wiOiBcIklsb8WbxIcgS29tZW50YXJ6eVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVHJlbmR5IHogMzAgZG5pXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiVXBvcnrEhWRrdWogd2VkxYJ1ZzpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDeWtsIHByenljaG9kdVwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQb3RlbmNqYWxueSBwcnp5Y2jDs2RcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIldjemXFm25pZWogd3lwxYJhY29ub1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJQcnp5Y2jDs2QgYXV0b3JhXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUHJ6eWNow7NkIHphIG1lY2VuYXRcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIldwaXMgem9zdGHFgiBvcHVibGlrb3dhbnkhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIk9wdWJsaWt1aiB3cGlzIHDDs8W6bmllaiFcIixcblx0XCJTQVZFRFwiOiBcIlphcGFtacSZdGFqXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIld5Y3p5xZvEh1wiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJPZmxhZ293YW5pZSB3cGlzdSBtb8W8ZSBzcG93b2Rvd2HEhyB1c3VuacSZY2llIHd5bmFncm9kemVuaWEgaSB6bW5pZWpzemVuaWUgamVnbyB3aWRvY3pub8WbY2kuPGJyPjxicj5GbGFnYSBwb3dpbm5hIGJ5xIcgdcW8eXRhIHcgc3l0dWFjamFjaCB0YWtpY2ggamFrOiA8dWw+PGxpPk9zenVzdHdvIGx1YiBQbGFnaWF0PC9saT48bGk+TW93xJkgbmllbmF3acWbY2kgbHViIEludGVybmV0b3d5IHRyb2xsaW5nPC9saT48bGk+V3BpcyBjZWxvd28gxbpsZSBza2F0YWdvcnl6b3dhbnkgbHViIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTGltaXQgem9zdGHFgiBvc2nEhWduacSZdHkuIFNwcmF3ZMW6IGlubmUgZXR5a2lldHkvdHJlbmR5IVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIldwaXMgem9zdGHFgiB1c3VuacSZdHkgeiB6YWvFgmFkZWshXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIldwaXMgem9zdGHFgiBkb2RhbnkgZG8gemFrxYJhZGVrIVwiLFxuXHRcIlJFU0VUXCI6IFwiWnJlc2V0dWpcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIlptb2R5ZmlrdWogemRqxJljaWUgcHJvZmlsb3dlXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJabWllxYQgemRqxJljaWUgdyB0bGVcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJQb2RhaiBha3R5d255IGtsdWN6IHByeXdhdG55IGplxZtsaSB3eWJyYcWCZcWbIHRyeWIgemFhd2Fuc293YW5lZ28gbG9nb3dhbmlhIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIlNwb3dvZHVqZSB6cmVzZXRvd2FuaWUgemRqxJljaWEgcHJvZmlsb3dlZ29cIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJTcG93b2R1amUgenJlc2V0b3dhbmllIHpkasSZY2lhIHcgdGxlXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBa3R1YWxpemFjamEgc2Vyd2VyYSB3eW1hZ2EgenJlc2V0b3dhbmlhIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJVc3Rhd2llbmlhIHpvc3RhxYJ5IHpha3R1YWxpem93YW5lXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiSsSZenlrXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJUdSBtb8W8ZXN6IHptaWVuacSHIGrEmXp5ayBhcGxpa2FjamkuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIlRhIG9wZXJhY2phIHd5bWFnYSB6YWxvZ293YW5pYSBoYXPFgmVtIGfFgsOzd255bSwga2x1Y3plbSBha3l0d255bS91ZG9zdMSZcG5pYWrEhWN5bS4gWmFsb2d1aiBzacSZIGkgc3Byw7NidWogcG9ub3duaWUuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGVyaWFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJQcnpldMWCdW1hY3p5bGlcIixcblx0XCJTSEFSRVwiOiBcIlBvbGXEh1wiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiU2tsZXBcIixcblx0XCJFWENIQU5HRVwiOiBcIld5bWlhbmFcIixcblx0XCJEUkFGVFNcIjogXCJXZXJzamUgcm9ib2N6ZVwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIldwaXMgem9zdGHFgiB1c3VuacSZdHkgeiByb2JvY3p5Y2ghXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIldwaXMgem9zdGHFgiB6YXBpc2FueSBqYWtvIHdlcnNqYSByb2JvY3phIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJQcnplY2nEhWduaWogdyBsZXdvLCBhYnkgem9iYWN6ecSHIG9wY2plXCIsXG5cdFwiTUFOQUdFXCI6IFwiWmFyesSFZHphalwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJPYnJheiB6b3N0YcWCIHVzdW5pxJl0eVwiLFxuXHRcIkNPUFlcIjogXCJLb3BpdWpcIixcblx0XCJOT19JTUFHRVwiOiBcIk5pZSBvcHVibGlrb3dhxYJlxZsgamVzemN6ZSDFvGFkbmVnbyBvYnJhenUhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJQcnplY2nEhWduaWogdyBkw7PFgiwgYWJ5IG9kxZt3aWXFvHnEhy5cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBsaWthY2plIHpld27EmXRyem5lXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpbnlcIixcblx0XCJTVUdHRVNUXCI6IFwiWmFzdWdlcnVqXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJKdcW8IHdrcsOzdGNlXCIsXG5cdFwiQ0hBSU5cIjogXCLFgWHFhGN1Y2hcIixcblx0XCJDSEFJTl9URVhUXCI6IFwiVHV0YWogbW/FvGVzeiB6bWllbmnEhyDFgmHFhGN1Y2ggYmxva8OzdyBsdWIgZG9tecWbbG7EhSBwbGF0Zm9ybcSZLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiV2FsdXRhXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIlR1dGFqIG1vxbxuYSB6bWllbmnEhyBkb215xZtsbsSFIHdhbHV0xJkuIFdhcnRvxZvEhyBuYWdyb2R5IHphIHBvc3Qva29tZW50YXJ6IHpvc3RhbmllIHd5xZt3aWV0bG9uYSB3IHRlaiB3YWx1Y2llLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIGZ1bmtjamk8L2I+PGJyPi0gRG9zdMSZcCBkbyB1bmlrYWxueWNoIHRyZcWbY2kgeiBrcsSZZ8OzdyBUd29pY2ggemFpbnRlcmVzb3dhxYQuPGJyPi0gWmFhbmdhxbx1aiBzacSZIHcgZHlza3VzamUgeiBhdXRvcmFtaS48YnI+IC0gR8WCb3N1aiBuYSBwb3N0eSBieSBuYWdyb2R6acSHIGF1dG9yw7N3LCB6ZG9ieXdhaiB3eW5hZ3JvZHplbmllIHphIHpuYWpkb3dhbmllIHdhcnRvxZtjaW93eWNoIHRyZcWbY2kuPGJyPiAtIFB1Ymxpa3VqIGFydHlrdcWCeSBpIHphcmFiaWFqIG5hIG5pY2ggemRvYnl3YWrEhWMgendvbGVubmlrw7N3PGJyPiAtIFBpc3ogcG9kY3phcyBwb2Ryw7PFvHksIHphcGlzdWogd2llbGUga29waWkgcm9ib2N6eWNoIGRvIHDDs8W6bmllanN6ZWogcHVibGlrYWNqaS48YnI+IC0gRG9kYWogdWx1YmlvbmUgYXJ0eWt1xYJ5IGRvIHpha8WCYWRlayBieSBwcnplY3p5dGHEhyBqZSBww7PFum5pZWouPGJyPiAtIFd5bWllxYQgbHViIHd5cMWCYcSHIHN3b2plIHphcm9ia2kuIDxicj4gLSBXecWbbGlqIHN3b2plIMWbcm9ka2kgZG8gYXV0b3LDs3csIHXFvHl0a293bmlrw7N3LCBwcnp5amFjacOzxYIsIHp3b2xlbm5pa8OzdywgZXRjLjxicj4gLcWabGVkxbogY2lla2F3eWNoIGF1dG9yw7N3Ljxicj4gLSBXeXN6dWtpd2FuaWUgd8WbcsOzZCBwb3N0w7N3IHN3b2ljaCB6d29sZW5uaWvDs3cgb3JheiDFm2xlZHpvbnljaCBhdXRvcsOzdy4uPGJyPiAtIE90cnp5bXVqIHBvd2lhZG9taWVuaWEgYnkgbmllIHByemVnYXBpxIcgZHlza3VzamkgdyBrdMOzcmUgamVzdGXFmyB6YWFuZ2HFvG93YW55Ljxicj4gLSBTenVrYWogY2lla2F3eWNoIHRhZ8OzdyAvIGthdGVnb3JpaS4gPGJyPiAtU3BlcnNvbmFsaXp1aiBzd8OzaiBwcm9maWwuIDxicj4gSmVzemN6ZSB3acSZY2VqIGZ1bmtjamkgd2tyw7N0Y2UuLiA8YnI+PGJyPjxiPkJlenBpZWN6ZcWEc3R3bzwvYj4gPGJyPjEuIEFwbGlrYWNqYSBuaWdkeSBuaWUgc2nEmWdhIGRvIFR3b2ljaCDFm3JvZGvDs3cuLiA8YnI+Mi4gQXBsaWthY2phIG9mZXJ1amUgbW9kZWwgemFiZXpwaWVjemXFhCBwbyBzdHJvbmllIGtsaWVudGEsIHoga2x1Y3phbWkgcHJ5d2F0bnltaSB0cnp5bWFueW1pIGxva2FsbmllIGkgbmlnZHkgbmllIHd5c3nFgmEgaWNoIGRvIMW8YWRuZWdvIHNlcndlcmEuIEplc3RlxZsgb2Rwb3dpZWR6aWFsbnkgemEgd3lrb255d2FuaWUga29waWkgemFwYXNvd3ljaCBzd29pY2ggaGFzZcWCLiA8YnI+My4gQXBsaWthY2phIG9mZXJ1amUgcHJvc3R5LCBhdHJha2N5am55IGludGVyZmVqcyB1xbx5dGtvd25pa2EuIDxicj40LiBEb2RhdGtvd2Egd2Fyc3R3YSB6YWJlenBpZWN6ZcWEIHcgcG9zdGFjaSBrb2R1IFBpbiA8YnI+PGJyPmVTdGVlbSBvYnPFgnVndWplIHBsYXRmb3JteSBTdGVlbSBvcmF6IEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIlphxYJvxbx5Y2llbCBpIGfFgsOzd255IHByb2dyYW1pc3RhXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJEb2RhaiBrb250b1wiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1hXCIsXG5cdFwiRVNDUk9XXCI6IFwiRXNjcm93XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiQWdlbnQgRXNjcm93XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiVGVybWluIHJhdHlmaWthY2ppXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJXeWdhxZtuacSZY2llIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJPcMWCYXRhIHphIHVzxYJ1Z8SZIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIldhcnVua2kgdXPFgnVnaSBFc2Nyb3dcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiVHJ5YiBOb2NueVwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiVHJ5YiBkemllbm55XCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiWm9iYWN6IHBlxYJueSBrb250ZWtzdFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJOaWUgem5hbGV6aW9ubyB1xbx5dGtvd25pa2FcIixcblx0XCJBUFBST1ZFXCI6IFwiWmF0d2llcmTFulwiLFxuXHRcIkRJU1BVVEVcIjogXCJTcMOzclwiLFxuXHRcIlJFTEVBU0VcIjogXCJVd29sbmlqXCIsXG5cdFwiRlJPTVwiOiBcIk9kXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIlByemXFm2xpalwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiT2RiaW9yY2FcIixcblx0XCJMT0NBVElPTlwiOiBcIkxva2FsaXphY2phXCIsXG5cdFwiV0VCU0lURVwiOiBcIldpdHJ5bmEgaW50ZXJuZXRvd2FcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJOYXp3YSB3ecWbd2lldGxhbmFcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiUMOhZ2luYSBJbmljaWFsXCIsXG5cdFwiTE9HSU5cIjogXCJFbnRyYXJcIixcblx0XCJMT0dPVVRcIjogXCJTYWlyXCIsXG5cdFwiUFJPRklMRVwiOiBcIlBlcmZpbFwiLFxuXHRcIkZPTExPV1wiOiBcIlNlZ3VpclwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIkZhdm9yaXRvc1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwiVHJhbnNmZXJpclwiLFxuXHRcIk1BUktFVFwiOiBcIk1lcmNhZG9cIixcblx0XCJTRVRUSU5HU1wiOiBcIkNvbmZpZ3VyYcOnw7Vlc1wiLFxuXHRcIkFCT1VUXCI6IFwiU29icmVcIixcblx0XCJBQk9VVF8xXCI6IFwib25kZSBxdWFscXVlciB1bSBwb2RlIGdhbmhhciByZWNvbXBlbnNhcyBwZWxvIHNldSBjb250ZcO6ZG9cIixcblx0XCJBQk9VVF8yXCI6IFwiw6kgcGF0cm9jaW5hZG8gcGVsYSBwbGF0YWZvcm1hIHt7cGxhdGZvcm1uYW1lfX0uIEFwbGljYXRpdm8gY3JpYWRvIHBvclwiLFxuXHRcIkFCT1VUXzNcIjogXCJlIMOpIGPDs2RpZ28tYWJlcnRvLCBwcm9qZWN0byBvcmllbnRhZG8gcGFyYSBhIGNvbXVuaWRhZGUgbcOzdmVsLiBPZmVyZWNlIGFjZXNzbyBhbyBjb250ZcO6ZG8gcGFyYSBsZWl0dXJhLCBjb21lbnTDoXJpb3MsIHZvdG9zLCBwdWJsaWNhciwgdHJhbmZlcmlyIGdhbmhvcyBldGMuIENhcmF0ZXLDrXN0aWNhcyBvZmVyZWNpZGFzIHBlbCB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gZSB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIE8gYXBsaWNhdGl2byBudW5jYSBhY2Vzc2Egb3UgZ3VhcmRhIG8gZGluaGVpcm8gZG9zIHVzdcOhcmlvcy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQSBBcHAgb2ZlcmXDp2UgdW0gbW9kZWxvIHNlZ3VybyBkbyBsYWRvLWNsaWVudGUsIGNvbSBjaGF2ZXMgcHJpdmFkYXMsIGd1YXJkYWRhcyBsb2NhbG1lbnRlIGUgbnVuY2EgZW52aWRhIGEgb3V0cm9zIHNlcnZpZG9yZXMuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIE8gQXBsaWNhdGl2byBvZmVyZWNlIHNpbXBsaWNpZGFkZSwgaW50ZXJmYWNlcyBkZSB1c3XDoXJpbyBlIGV4cGVyacOqbmNpYXMgYXRyYXRpdmFzLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBPIEFwbGljYXRpdm8gcmVxdWVyIHF1ZSBvcyB1c3XDoXJpb3MgaW5zaXJhbSBpbmZvcm1hw6fDtWVzIHBlc3NvYWlzLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJWb3RlIGJvbS1rYXJtYSBjb21vIHRlc3RlbXVuaGFcIixcblx0XCJBQk9VVF85XCI6IFwiQ29udGF0by9Db21lbnTDoXJpb3NcIixcblx0XCJBQk9VVF8xMFwiOiBcIk1haXMgaW5mb3JtYcOnw7VlczpcIixcblx0XCJSRU1PVkVcIjogXCJSZW1vdmVyXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJWaXPDo28gZG8gTWVyY2Fkb1wiLFxuXHRcIlBSSUNFXCI6IFwiUHJlw6dvXCIsXG5cdFwiQU1PVU5UXCI6IFwiUXVhbnRpZGFkZVwiLFxuXHRcIk5PT1JERVJTXCI6IFwiU2VtIG9yZGVucyBhYmVydGFzIHBhcmFcIixcblx0XCJEQVRFXCI6IFwiRGF0YVwiLFxuXHRcIkJVWVwiOiBcIkNvbXByYXJcIixcblx0XCJTRUxMXCI6IFwiVmVuZGVyXCIsXG5cdFwiT1BFTlwiOiBcIkFicmlyXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpdMOzcmljb1wiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiU2VndWlyIGRlIHZvbHRhXCIsXG5cdFwiRk9MTE9XRURcIjogXCJTZWd1aWRvXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJEZWl4YXIgZGUgc2VndWlyXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiU2VndWluZG9cIixcblx0XCJGT0xMT1dFUlNcIjogXCJTZWd1aWRvcmVzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlByb2N1cmFyIHNlZ3VpZG9yZXNcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiUHJvY3VyYXIgcXVlbSBlc3RvdSBzZWd1aW5kb1wiLFxuXHRcIkJZXCI6IFwicG9yXCIsXG5cdFwiSU5cIjogXCJub1wiLFxuXHRcIkJPT0tNQVJLXCI6IFwiRmF2b3JpdG9zXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVwb3N0YXJcIixcblx0XCJVUFZPVEVcIjogXCJVcHZvdGVcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiQ2FuY2VsYXIgRG93bnZvdGVcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIkNhbmNlbGFyIFVwdm90ZVwiLFxuXHRcIlJFUExZXCI6IFwiUmVzcG9uZGVyXCIsXG5cdFwiRURJVFwiOiBcIkVkaXRhclwiLFxuXHRcIlBPU1RfMVwiOiBcIkRlc2xpemUgcGFyYSBlc3F1ZXJkYSBub3MgY29tZW50w6FyaW9zIHBhcmEgdmVyIGFzIG9ww6fDtWVzXCIsXG5cdFwiUE9TVF8yXCI6IFwiVG9xdWUgbm9zIGNvbWVudMOhcmlvcyBwYXJhIHZlciBvcyBzdWItY29tZW50w6FyaW9zXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9ww6fDtWVzXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVwb3N0YWRvIHBvclwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIk5hZGEgcG9yIGFxdWksIGFpbmRhLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJCYWxhbsOnb1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIHByb3ZhcyB0cmFuc2FjaW9uw6F2ZWlzIHF1ZSBwb2RlbSBzZXIgdHJhbnNmZXJpZGFzIGVtIHF1YWxxdWVyIGFsdHVyYS4ge3twbGF0Zm9ybW5hbWV9fSBwb2RlbSBzZXIgY29udmVydGlkYXMge3twbGF0Zm9ybXBvd2VyfX0gbnVtIHByb2Nlc3NvIGNoYW1hZG8gcG9kZXIgYWJhaXhvLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBwcm92YXMgZGUgaW5mbHVlbmNpYSBwYXIgZ2FuaGFyIG1haXMgcG9kZXIgcG9yIGd1YXJkYXIgYSBsb25nbyBwcmF6byBlIHZvdGFyIG5hcyBwdWJsaWNhw6fDtWVzLiBRdWFudG8gbWFpcyBzZSBwb3NzdWkgbWFpcyBzZSBwb2RlIGluZmx1ZW5jaWFyIGFzIHJlY29tcGVuc2FzIGEgb3V0cm9zIGUgZ2FuaGFyIG1haXMgcmVjb21wZW5zYXMgcG9yIHZvdGFyLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlByb3ZhcyB2YWxlbmRvIGNlcmNhIGRlIHt7cGxhdGZvcm1zdW5pdH19IGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiVmFsb3IgZXN0aW1hZG9cIixcblx0XCJQUk9GSUxFXzRcIjogXCJPIHZhbG9yIGVzdGltYWRvIMOpIGJhc2VhZG8gbnVtYSBtw6lkaWEgZG8gdmFsb3IgZGUgNyBkaWFzIGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIkhpc3TDs3JpY28gZGUgVHJhbnNhw6fDtWVzXCIsXG5cdFwiUE9TVElOR1wiOiBcIlBvc3RhbmRvXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiQSBjaGF2ZSBkZSBwb3N0YWdlbSDDqSB1c2FkYSBwYXJhIHBvc3RhciBlIHZvdGFyLiBFbGEgZGV2ZXLDoSBzZXIgZGlmZXJlbnRlIGRhIGNoYXZlIGRlIGF0aXZhw6fDo28gZSBkYSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvLlwiLFxuXHRcIk9XTkVSXCI6IFwiUHJvcHJpZXTDoXJpb1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpbyDDqSBhIGNoYXZlIG1lc3RyYSBwYXJhIGNvbnRhIGUgw6kgZXhpZ2lkYSBwYXJhIG11ZGFyIGFzIG91dHJhcyBjaGF2ZXMuIFVtYSBjaGF2ZSBwcml2YWRhIG91IHNlbmhhIHBhcmEgYSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvIGRldmVyw6Egc2VyIG1hbnRpZGEgb2ZmbGluZSBhc3NpbSBxdWUgcG9zc8OtdmVsLlwiLFxuXHRcIkFDVElWRVwiOiBcIkF0aXZvXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiQSBjaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgZmF6ZXIgdHJhbnNmZXLDqm5jaWFzIGUgY29sb2NhciBvcmRlbnMgbm8gbWVyY2FkbyBpbnRlcm5vLlwiLFxuXHRcIk1FTU9cIjogXCJBbm90YcOnw7Vlc1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkEgY2hhdmUgZGUgYW5vdGHDp8O1ZXMgw6kgdXNhZGEgcGFyYSBjcmlhciBlIGxlciBhbm90YcOnw7Vlcy5cIixcblx0XCJQT1NUU1wiOiBcIlBvc3RhZ2Vuc1wiLFxuXHRcIlJFUExJRVNcIjogXCJSZXNwb3N0YXNcIixcblx0XCJXQUxMRVRcIjogXCJDYXJ0ZWlyYVwiLFxuXHRcIlVTRVJcIjogXCJVc3XDoXJpb1wiLFxuXHRcIkNMT1NFXCI6IFwiRmVjaGFkb1wiLFxuXHRcIlRPXCI6IFwiUGFyYVwiLFxuXHRcIkFTU0VUXCI6IFwiQXRpdm9cIixcblx0XCJTRU5EXCI6IFwiRW52aWFyXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTZWd1cmFuw6dhXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiRGlzcG9uw612ZWxcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk1lbW9yYW5kbyBQw7pibGljb1wiLFxuXHRcIlRPX0RFU0NcIjogXCJVdGlsaXphZG9yIGV4OiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJDw7NkaWdvIFBpblwiLFxuXHRcIlBJTl9URVhUXCI6IFwiQ8OzZGlnbyBQaW4gYWp1ZGEgdm9jw6ogYSBhc3NlZ3VyYXIgbyBhcGxpY2F0aXZvIGUgc3VhcyBpbmZvcm1hw6fDtWVzLiA8YnIvPjxici8+IFVtYSB2ZXogYXRpdmFkbywgdm9jw6ogdGVyw6Egbm8gbcOheGltbyA0IHRlbnRhdGl2YXMgcGFyYSBkZXN0cmF2YXIsIHNlIHZvY2UgZXNxdWVjZXJvIHBpbiBvdSBlcnJhciwgbyBhcGxpY2F0aXZvIGlyw6EgcmVtb3ZlciBzdWFzIGluZm9ybWHDp8O1ZXMgZGUgdXN1w6FyaW8uIFZvY8OqIHBvZGUgZW50cmFyIGRlIG5vdm8gZSBjb250aW51YXIgYSB1c2FyIG8gYXBsaWNhdGl2by5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2HDp8O1ZXNcIixcblx0XCJWT1RFX1RFWFRcIjogXCJWb2PDqiByZWNlYmVyw6EgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gdm90ZXIgbm8gc2V1IGNvbnRlw7pkbyEgTm90aWZpY2HDp8O1ZXMgdGFtYsOpbSBpbmNsdWVtIHBlc28gZGUgdm90byBubyBhbGVydGEgZGEgbWVuc2FnZW0uKSBzZWphIHZvdG8gcG9zaXRpdm8sIHZvdG8gbmVnYXRpdm8sIHZvdG8gbnVsbykuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGFyXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiVm9jw6ogcmVjZWJlcsOhIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gY29tZW50YXIgbmFzIHN1YXMgcG9zdGFnZW5zIG91IGNvbWVudMOhcmlvcy48YnIvPiBOb3RpZmljYcOnw7VlcyBpbmNsdWVtIHF1YW5kbyBhbGd1w6ltIGVkaXRhIG9zIGNvbWVudMOhcmlvcyB0YW1iw6ltLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21lbnRhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiVm9jw6ogcmVjZWJlcsOhIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIFNlZ3VpciBvdSBEZWl4YXIgZGUgc2VndWlyIHZvY8OqIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiTWVuw6fDtWVzXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlZvY8OqIHJlY2ViZXLDoSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBtZW5jaW9uYXIgdm9jw6ogZW0gYWxndW1hIHBvc3RhZ2VtIG91IGNvbWVudMOhcmlvIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiQ29uZmlndXJhw6fDtWVzXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90YW5kb1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiTyBwZXNvIGRlIHZvdG8gb3UgcGVyY2VudGFnZW0gYWZldGEgbyBwb2RlciBkZSB2b3RvIG5hIGFwcCwgcG9yIGlzc28gcG9kZSByZWd1bGFyIG8gc2V1IHJlY29tcGVuc2EgZGUgdm90byA8YnIvPjxici8+PGI+Tm90YTo8L2I+IElzdG8gaXLDoSBtb2RpZmljYXIgbyBwc2Vzby9wZXJjZW50YWdlbSBwYXJhIHZvdGFyIHBhcmEgYmFpeG8gdGFtYsOpbSBlIGVtIHRvZG8gbyBsYWRvIG5hIEFwcFwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZpZG9yXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJSZWNvbWVuZGFkb1wiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNhbHZhciBtdWRhbsOnYXNcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZm9ybWHDp8O1ZXMgZG9zIGVsZWl0b3Jlc1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIkJlbSB2aW5kbyBkZSBWb2x0YSFcIixcblx0XCJMT0dJTl8xXCI6IFwiQ29uZWN0ZS1zZSBjb20gc2V1IG5vbWUgZGUgdXN1w6FyaW8gZSBzZW5oYSBwYXJhIGNvbnRpbnVhci5cIixcblx0XCJMT0dJTl8yXCI6IFwiQ2hhdmUgZGUgcG9zdGFnZW0gw6kgdXNhZGEgcGFyYSBwb3N0YXIsIGNvbWVudGFyLCB2b3Rhciwgc2VndWlyLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJDaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgdHJhbmZlcsOqbmNpYXMgZSBhdHVhbGl6YcOnw6NvIGRlIGZvdG9zIGRlIHBlcmZpbC5cIixcblx0XCJMT0dJTl80XCI6IFwiQXMgY3JlZGVuY2lhaXMgZG8gdXRpbGl6YWRvciBzw6NvIGd1YXJkYWRhcyBsb2NhbG1lbnRlIG5vIHNldSBhcGFyZWxoby4gRGVwaXMgZGUgZGVzbGlnYXIgYXMgc3VhcyBjZXJkZW5jaWFpcyBzw6NvIHJlbW92aWRhcyFcIixcblx0XCJET05UX0hBVkVcIjogXCJOw6NvIHBvc3N1aSB1bWEgY29udGE/XFxuXCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJDYWRhc3RyZS1zZSBhZ29yYVwiLFxuXHRcIkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG5cdFwiQURWQU5DRURcIjogXCJBdmFuw6dhZG9cIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQ2hhdmUgZGUgYXRpdmHDp8OjbyBwcml2YWRhXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJDaGF2ZSBkZSBwb3N0YWdlbSBwcml2YWRhXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJTZW5oYSBNZXN0cmEvUHJpbmNpcGFsXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJVc3XDoXJpb1wiLFxuXHRcIkNBUkRfVklFV1wiOiBcIlZpc8OjbyBkZSBDYXJ0w6NvXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVmlzdGEgY29tcGFjdGFcIixcblx0XCJTRUFSQ0hcIjogXCJQcm9jdXJhclwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiUG9zdGFyIHVtYSBoaXN0w7NyaWFcIixcblx0XCJSRVBMWVRPXCI6IFwiUmVzcG9uZGVyIHBhcmFcIixcblx0XCJQT1NUXCI6IFwiUG9zdGFnZW1cIixcblx0XCJQUkVWSUVXXCI6IFwiVml6dWFsaXphw6fDo29cIixcblx0XCJERUZBVUxUXCI6IFwiUGFkcsOjbyA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiRm9yw6dhIFRvdGFsIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlJlY3VzYXIgUGFnYW1lbnRvXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJHdWFyZGFyIHByYSBtYWlzIHRhcmRlXCIsXG5cdFwiQ0xFQVJcIjogXCJUZXJtaW5hZG9cIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJDb250ZcO6ZG8gZGEgcG9zdGFnZW1cIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJDb250ZcO6ZG8gZG8gY29tZW50w6FyaW9cIixcblx0XCJUSVRMRVwiOiBcIlTDrXR1bG9cIixcblx0XCJOT1RfTUFUQ0hcIjogXCJOw6NvIGNvbmRpelwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiQ29uZmlybWFyIFBpblwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIkluY29ycmV0b1wiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIkFicmluZG8gcG9zdGFnZW1cIixcblx0XCJTRVRfUElOXCI6IFwiQ29uZmlndXJlIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkVudHJhciBjb20gUGluXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiVm9jw6ogdGVtIGNlcnRlemE/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJSZXB1YmxpY2FyIMOpIGlycmV2ZXJzw612ZWwsIHF1ZXIgbWVzbW8gY29udGludWFyP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkVycm8gZGUgZGlmdXPDo28sIHRlbnRlIG5vdmFtZW50ZSFcIixcblx0XCJTVUNDRVNTXCI6IFwiU3VjZXNzb1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUHVibHVjYcOnw6NvIHJlcHVibGljYWRhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkxvZ2luIGZhbGhvdSEgcG9yIGZhdm9yIGNlcnRpZmlxdWUtc2UgcXVlIGVzdMOhIGNvbmV0YWRvIGNvbSBhIHNlbmhhIG1hc3RlciBvdSBhIGNoYXZlIHB1YmxpY2HDp8OjbyBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiTG9naW4gZmFsaG91ISBwb3IgZmF2b3IgY2VydGlmaXF1ZS1zZSBxdWUgZXN0w6EgY29uZXRhZG8gY29tIGEgc2VuaGEgbWFzdGVyIG91IGEgY2hhdmUgYXRpdmEgcHJpdmFkYSBubyBMb2dpbiBzZSBlc2NvbGhldSBvIG1vZG8gYXZhbsOnYWRvLlwiLFxuXHRcIldBUk5JTkdcIjogXCJDdWlkYWRvXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIlZvdGFuZG8gcG9yIHVtYSBUZXN0ZW11bmhhXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJWb3RvdSBwb3IgdW1hIFRlc3RlbXVuaGFcIixcblx0XCJBR09cIjogXCJhdHLDoXNcIixcblx0XCJGUk9NX05PV1wiOiBcImRlIGFnb3JhXCIsXG5cdFwiU0VDU1wiOiBcInNlZ3NcIixcblx0XCJBX01JTlwiOiBcInVtIG1pbnV0b1wiLFxuXHRcIkFOX0hPVVJcIjogXCJ1bWEgaG9yYVwiLFxuXHRcIkhPVVJTXCI6IFwiaG9yYXNcIixcblx0XCJBX0RBWVwiOiBcInVtIGRpYVwiLFxuXHRcIkRBWVNcIjogXCJkaWFzXCIsXG5cdFwiQV9NT05USFwiOiBcInVtIG3DqnNcIixcblx0XCJNT05USFNcIjogXCJtZXNlc1wiLFxuXHRcIkFfWUVBUlwiOiBcInVtIGFub1wiLFxuXHRcIllFQVJTXCI6IFwiYW5vc1wiLFxuXHRcIk1JTl9SRUFEXCI6IFwibGVyIG1pblwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJWb3RlIGFiYWl4byBvdSBiYW5kZWlyZVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIkNhcHR1cmFyIGltYWdlbVwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiRXNjb2xoZXIgdW1hIGltYWdlbVwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiQ29uZmlndXJlIFVSTCBjb3N0dW1pemFkYVwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5zZXJpciB1bWEgaW1hZ2VtXCIsXG5cdFwiRVJST1JcIjogXCJFcnJvXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiRXJybyBubyBjYXJyZWdhbWVudG9cIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiQ2FtZXJhIGNhbmNlbGFkYVwiLFxuXHRcIlNFVF9VUkxcIjogXCJDb25maWd1cmFsIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJMaW5rIHdlYiBkaXJldG8gcGFyYSBhIGltYWdlbVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiQ29tZW50w6FyaW8gcG9zdGFkbyFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkRlbGV0YXIgY29tZW50w6FyaW9zIMOpIGlycmV2ZXJzw612ZWxcIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJDb21lbnTDoXJpbyBkZWxldGFkb1wiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiQ2FycmVnYWJkbyBpbWFnZW1cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiQ2FycmVnYW1lbnRvIGNvbXBlbGV0b1wiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJDYXJyZWdhbWVudG8gZmFsaG91XCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiQSBzZW5oYSBvdSBub21lIGRhIGNvbnRhIGVzdMOjbyBpbmNvcnJldG9zXCIsXG5cdFwiSU5GT1wiOiBcIkluZm9ybWHDp8O1ZXNcIixcblx0XCJRUl9URVhUXCI6IFwiUG9uaGEgbyBjw7NkaWdvIFFSIGRlbnRybyBkYSDDoXJlYSBkZSBzY2FuXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiQ2VydGlmaXF1ZS1zZSBxdWUgcG9zc3VpIHNhbGRvIHN1ZmljaWVudGUgcGFyYSBhIHRyYW5zYcOnw6NvIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJPIHV0aWxpemFkb3IgcGFyYSBxdWVtIGVzdMOhIGEgdGVudGFyIHRyYW5zZmVyaXIgZnVuZG9zLCBuw6NvIGV4aXN0ZVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJUZW0gY2VydGV6YSBxdWUgcXVlciB0cmFuc2ZlcmlyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZpcm1hw6fDo29cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYcOnw6NvIGZvaSBkaWZ1bmRpZGFcIixcblx0XCJUUkVORElOR1wiOiBcIlRlbmRlbmNpYVwiLFxuXHRcIkhPVFwiOiBcIlF1ZW50ZVwiLFxuXHRcIk5FV1wiOiBcIk5vdmlkYWRlc1wiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvbW92aWRvc1wiLFxuXHRcIlZPVEVTXCI6IFwiVm90b3NcIixcblx0XCJQQVlPVVRcIjogXCJQYWdhbWVudG9cIixcblx0XCJDT01NRU5UU1wiOiBcIkNvbWVudMOhcmlvc1wiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVGVuZGVuY2lhIGEgMzAgZGlhc1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIk9yZGVuYXIgcHVibGljYcOnw7VlcyBwb3I6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiQ2ljbG8gZGUgUGFnYW1lbnRvXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBhZ2FtZW50byBlbSBwb3RlbmNpYWxcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIsOabHRpbW8gUGFnYW1lbnRvXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlBhZ2FtZW50byBkbyBBdXRvclwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlBhZ2FtZW50byBkZSBjdXJhZG9yaWFcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIlBvc3RhZ2VtIGVudmlhZGEhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlB1YmxpcXVlIHBhcmEgZnV0dXJhIHN1Ym1pc3PDo29cIixcblx0XCJTQVZFRFwiOiBcIlNhbHZvXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkxpbXBvXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIlBvciBCYW5kZWlyYSBudW1hIHB1YmxpY2HDp8OjbyBwb2RlIHJlbW92ZXIgcmVjb21wZW5zYXMgZSB0b3JuYXIgbyBtYXRlcmlhbCBtZW5vcyB2aXNpdmVsLjxicj48YnI+QSBiYW5kZWlyYSBkZXYgc2VyIHVzYWRhIHBhcmEgOiA8dWw+PGxpPkZyYXVkZSBvdSBQbGFnaWFyaXNtbzwvbGk+PGxpPkRpc2N1cnNvIGRlIMOzZGlvIG91IEludGVybmV0IFRyb2xsaW5nPC9saT48bGk+Q2F0ZWdvcml6YcOnw6NvIG1hbCBmZWl0YSBpbnRlbmNpb25hbG1lbnRlIG91IFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTGltaXRlIGRlIHBlZGlkb3MgYXRpbmdpZG8uIHZlcmlmaXF1ZSBvdXRybyBhc3N1bnRvL2V0aXF1ZXRhIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIlBvc3RhZ2VtIHJlbW92aWRhIGRvcyBmYXZvcml0b3MhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3RhZ2VtIGFkaWNpb25hZGEgYW9zIGZhdm9yaXRvcyFcIixcblx0XCJSRVNFVFwiOiBcIlJlaW5pY2lhclwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpY2FyIGZvdG8gZGUgcGVyZmlsXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZmljYXIgZm90byBkZSBjYXBhXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiUG9yIGZhdm9yIGZvcm5hw6dhIGEgY2hhdmUgZGUgYWN0aXZhw6fDo28gcHJpdmFkYSBxdWUgZXNjb2xoZXUsIE1vZG8gZGUgTG9naW4gQXZhbsOnYWRvXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiSXN0byByZWNvbmZpZ3VyYSBhIGltYWdlbSBkbyBwZXJmaWwgdWx0aXphZG9yXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiSXN0byByZWNvbmZpZ3VyYSBhIGltYWdlbSBkbyB1bHRpemFkb3JcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkF0dWFsaXphw6fDo28gZG8gc2VydmVyIG9icmlnYSBhIFJlaW5pY2lhciFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiQ29uZmlndXJhw6fDtWVzIGZvcmFtIGF0dWFsaXphZGFzXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiTMOtbmd1YXNcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkFxdWkgcG9kZSBtdWRhciBhIGzDrW5ndWEgZGEgQXBwXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIkVzdCBvcGVyYcOnw6NvIG9icmlnYSBxdWUgbyB1dGlsaXphZG9yIGVzdGFqYSBsaWdhZG8gY29tIGEgc2VuaGEgcHJpbmlwYWwsIGNoYXZlIGFjdGl2YcOnw6NvL3B1YmxpY2HDp8Ojb1wiLFxuXHRcIkdBTExFUllcIjogXCJHYWxlcmlhXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiVHJhZHV0b3JlcyBxdWUgY29udHJpYnVpcmFtXCIsXG5cdFwiU0hBUkVcIjogXCJQYXJ0aWxoYXJcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1lcmNhZG9cIixcblx0XCJFWENIQU5HRVwiOiBcIkNhbWJpb1wiLFxuXHRcIkRSQUZUU1wiOiBcIlJhc2N1bmhvc1wiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIlBvc3RhZ2VtIHJlbW92aWRhIGRvcyBSYXNjdW5ob3MhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlBvc3RhZ2VtIGFkaWNpb25hZGEgYSBSYXNjdW5ob3MhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIlJvbGUgcGFyYSBhIGVzcXVlcmRhIHBhcmEgb3DDp8O1ZXNcIixcblx0XCJNQU5BR0VcIjogXCJHZXJpclwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJJbWFnZS4gcmVtb3ZpZGFcIixcblx0XCJDT1BZXCI6IFwiQ29waWFyXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJOw6NvIGNhcnJlZ291IG5lbmh1bWEgaW1hZ2VtLCBhaW5kYVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiQ2FycmVndWUgcGFyYSByZWZyZXNjYXJcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBwcyBFeHRlcm5hc1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTdWdpcmFcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkJyZXZlbWVudGVcIixcblx0XCJDSEFJTl9URVhUXCI6IFwiQXF1aSBwb2RlIGVzY29saGVyIGJsb2NrY2hhaW4gb3UgYSBwbGF0YWZvcm1hIHBvciBkZWZlaXRvXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIlDDoWdpbmEgSW5pY2lhbFwiLFxuXHRcIkxPR0lOXCI6IFwiRW50cmFyXCIsXG5cdFwiTE9HT1VUXCI6IFwiU2FpclwiLFxuXHRcIlBST0ZJTEVcIjogXCJQZXJmaWxcIixcblx0XCJGT0xMT1dcIjogXCJTZWd1aXJcIixcblx0XCJCT09LTUFSS1NcIjogXCJGYXZvcml0b3NcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVyaXJcIixcblx0XCJNQVJLRVRcIjogXCJNZXJjYWRvXCIsXG5cdFwiU0VUVElOR1NcIjogXCJDb25maWd1cmHDp8O1ZXNcIixcblx0XCJBQk9VVFwiOiBcIlNvYnJlXCIsXG5cdFwiQUJPVVRfMVwiOiBcIk9uZGUgcXVhbHF1ZXIgdW0gcG9kZSBnYW5oYXIgcmVjb21wZW5zYXMgcGVsbyBzZXUgY29udGXDumRvXCIsXG5cdFwiQUJPVVRfMlwiOiBcIsOpIHVtYSBhcGxpY2HDp8OjbyBzb2NpYWwgb25kZSB2b2PDqiDDqSBwYWdvIHBvciBwdWJsaWNhciwgY29tZW50YXIgZSBjdXJhci5cIixcblx0XCJBQk9VVF8zXCI6IFwiZSDDqSBjw7NkaWdvLWFiZXJ0bywgcHJvamVjdG8gb3JpZW50YWRvIHBhcmEgYSBjb211bmlkYWRlIG3Ds3ZlbC4gT2ZlcmVjZSBhY2Vzc28gYW8gY29udGXDumRvIHBhcmEgbGVpdHVyYSwgY29tZW50w6FyaW9zLCB2b3RvcywgcHVibGljYXIsIHRyYW5mZXJpciBnYW5ob3MgZXRjLiBDYXJhdGVyaXN0aWNhcyBvZmVyZWNpZGFzIHBvciB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gTyBhcGxpY2F0aXZvIG51bmNhIGFjZXNzYSBvdSBndWFyZGEgbyBkaW5oZWlybyBkb3MgdXRpbGl6YWRvcmVzLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBIEFwcCBvZmVyZWNlIHVtIG1vZGVsbyBzZWd1cm8gZG8gbGFkby1jbGllbnRlLCBjb20gY2hhdmVzIHByaXZhZGFzLCBndWFyZGFkYXMgbG9jYWxtZW50ZSBlIG51bmNhIGVudmlhZGEgcGFyYSBvdXRyb3Mgc2Vydmlkb3Jlcy5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gTyBBcGxpY2F0aXZvIG9mZXJlY2Ugc2ltcGxpY2lkYWRlLCBpbnRlcmZhY2VzIGRlIHV0aWxpemFkb3IgZSBleHBlcmnDqm5jaWFzIGF0cmF0aXZhcy5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gTyBBcGxpY2F0aXZvIHJlcXVlciBxdWUgb3MgdXRpbGl6YWRvcmVzIGluc2lyYW0gaW5mb3JtYcOnw7VlcyBwZXNzb2Fpcy5cIixcblx0XCJBQk9VVF84XCI6IFwiVm90ZSBib20ta2FybWEgY29tbyB0ZXN0ZW11bmhhXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhdG8vQ29tZW50w6FyaW9zXCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNYWlzIGluZm9ybWHDp8O1ZXM6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiUmVtb3ZlclwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiVmlzw6NvIGRvIE1lcmNhZG9cIixcblx0XCJQUklDRVwiOiBcIlByZcOnb1wiLFxuXHRcIkFNT1VOVFwiOiBcIlF1YW50aWRhZGVcIixcblx0XCJUT1RBTFwiOiBcIlRvdGFsXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJTZW0gb3JkZW5zIGFiZXJ0YXMgcGFyYVwiLFxuXHRcIkRBVEVcIjogXCJEYXRhXCIsXG5cdFwiQlVZXCI6IFwiQ29tcHJhclwiLFxuXHRcIlNFTExcIjogXCJWZW5kZXJcIixcblx0XCJPUEVOXCI6IFwiQWJyaXJcIixcblx0XCJISVNUT1JZXCI6IFwiSGl0w7NyaWNvXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJWb2x0YXIgYSBzZWd1aXJcIixcblx0XCJGT0xMT1dFRFwiOiBcIlNlZ3VpZG9cIixcblx0XCJVTkZPTExPV1wiOiBcIkRlaXhhciBkZSBzZWd1aXJcIixcblx0XCJGT0xMT1dJTkdcIjogXCJTZWd1aW5kb1wiLFxuXHRcIkZPTExPV0VSU1wiOiBcIlNlZ3VpZG9yZXNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiUHJvY3VyYXIgc2VndWlkb3Jlc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJQcm9jdXJhciBwb3IgcXVlbSBlc3RvdSBhIHNlZ3VpclwiLFxuXHRcIkJZXCI6IFwicG9yXCIsXG5cdFwiSU5cIjogXCJub1wiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJGYXZvcml0b3NcIixcblx0XCJSRUJMT0dcIjogXCJSZXBvc3RhclwiLFxuXHRcIlVQVk9URVwiOiBcIlZvdG8gcG9zaXRpdm9cIixcblx0XCJET1dOVk9URVwiOiBcIlZvdG8gbmVnYXRpdm9cIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiQ2FuY2VsYXIgdm90byBuZWdhdGl2b1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiQ2FuY2VsYXIgdm90byBwb3NpdGl2b1wiLFxuXHRcIlJFUExZXCI6IFwiUmVzcG9uZGVyXCIsXG5cdFwiRURJVFwiOiBcIkVkaXRhclwiLFxuXHRcIlBPU1RfMVwiOiBcIkRlc2xpemUgcGFyYSBlc3F1ZXJkYSBub3MgY29tZW50w6FyaW9zIHBhcmEgdmVyIGFzIG9ww6fDtWVzXCIsXG5cdFwiUE9TVF8yXCI6IFwiVG9xdWUgbm9zIGNvbWVudMOhcmlvcyBwYXJhIHZlciBvcyBzdWItY29tZW50w6FyaW9zXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9ww6fDtWVzXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVwb3N0YWRvIHBvclwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIk5hZGEgcG9yIGFxdWksIGFpbmRhLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJCYWxhbsOnb1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIHByb3ZhcyB0cmFuc2FjaW9uw6F2ZWlzIHF1ZSBwb2RlbSBzZXIgdHJhbnNmZXJpZGFzIGVtIHF1YWxxdWVyIGFsdHVyYS4ge3twbGF0Zm9ybW5hbWV9fSBwb2RlbSBzZXIgY29udmVydGlkYXMge3twbGF0Zm9ybXBvd2VyfX0gbnVtIHByb2Nlc3NvIGNoYW1hZG8gcG9kZXIgYWJhaXhvLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCB0b2tlbnMgZGUgaW5mbHVlbmNpYSBwYXJhIGdhbmhhciBtYWlzIHBvZGVyIHBhcmEgZ3VhcmRhciBhIGxvbmdvIHByYXpvIGUgdm90YXIgbmFzIHB1YmxpY2HDp8O1ZXMuIFF1YW50byBtYWlzIHNlIHBvc3N1aSBtYWlzIHNlIHBvZGUgaW5mbHVlbmNpYXIgYXMgcmVjb21wZW5zYXMgcGFyYSBvdXRyb3MgZSBnYW5oYXIgbWFpcyByZWNvbXBlbnNhcyBwb3Igdm90YXIuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiUHJvdmFzIHF1ZSB2YWxlbSBjZXJjYSBkZSB7e3BsYXRmb3Jtc3VuaXR9fSBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlZhbG9yIGVzdGltYWRvXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiTyB2YWxvciBlc3RpbWFkbyDDqSBiYXNlYWRvIG51bWEgbcOpZGlhIGRvIHZhbG9yIGRlIDcgZGlhcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJIaXN0w7NyaWNvIGRlIFRyYW5zYcOnw6NvXCIsXG5cdFwiUE9TVElOR1wiOiBcIlB1YmxpY2FuZG9cIixcblx0XCJQUk9GSUxFXzVcIjogXCJBIGNoYXZlIGRlIHB1YmxpY2HDp8OjbyDDqSB1c2FkYSBwYXJhIHB1YmxpY2FyIGUgdm90YXIuIEVsYSBkZXZlIHNlciBkaWZlcmVudGUgZGEgY2hhdmUgZGUgYXRpdmHDp8OjbyBlIGRhIGNoYXZlIGRlIHByb3ByaWV0w6FyaW8uXCIsXG5cdFwiT1dORVJcIjogXCJQcm9wcmlldMOhcmlvXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiQSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvIMOpIGEgY2hhdmUgbWVzdHJhIHBhcmEgY29udGEgZSDDqSBleGlnaWRhIHBhcmEgbXVkYXIgYXMgb3V0cmFzIGNoYXZlcy4gVW1hIGNoYXZlIHByaXZhZGEgb3Ugc2VuaGEgcGFyYSBhIGNoYXZlIGRlIHByb3ByaWV0w6FyaW8gZGV2ZXLDoSBzZXIgbWFudGlkYSBvZmZsaW5lIGFzc2ltIHF1ZSBwb3Nzw612ZWwuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQXRpdm9cIixcblx0XCJQUk9GSUxFXzdcIjogXCJBIGNoYXZlIGRlIGF0aXZhw6fDo28gw6kgdXNhZGEgcGFyYSBmYXplciB0cmFuc2ZlcsOqbmNpYXMgZSBjb2xvY2FyIG9yZGVucyBubyBtZXJjYWRvIGludGVybm8uXCIsXG5cdFwiTUVNT1wiOiBcIkFub3Rhw6fDtWVzXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiQSBjaGF2ZSBkZSBhbm90YcOnw7VlcyDDqSB1c2FkYSBwYXJhIGNyaWFyIGUgbGVyIGFub3Rhw6fDtWVzLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9ndWVcIixcblx0XCJQT1NUU1wiOiBcIlB1YmxpY2HDp8O1ZXNcIixcblx0XCJSRVBMSUVTXCI6IFwiUmVzcG9zdGFzXCIsXG5cdFwiV0FMTEVUXCI6IFwiQ2FydGVpcmFcIixcblx0XCJUQUdcIjogXCJFdGlxdWV0YVwiLFxuXHRcIlVTRVJcIjogXCJVdGlsaXphZG9yXCIsXG5cdFwiQ0xPU0VcIjogXCJGZWNoYWRvXCIsXG5cdFwiVE9cIjogXCJQYXJhXCIsXG5cdFwiQVNTRVRcIjogXCJBdGl2b1wiLFxuXHRcIlNFTkRcIjogXCJFbnZpYXJcIixcblx0XCJTRUNVUklUWVwiOiBcIlNlZ3VyYW7Dp2FcIixcblx0XCJBVkFJTEFCTEVcIjogXCJEaXNwb27DrXZlbFwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTWVtb3JhbmRvIFDDumJsaWNvXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlV0aWxpemFkb3IgZXg6IGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIkPDs2RpZ28gUGluXCIsXG5cdFwiUElOX1RFWFRcIjogXCJDw7NkaWdvIFBpbiBhanVkYSBhIGFzc2VndXJhciBvIGFwbGljYXRpdm8gZSBzdWFzIGluZm9ybWHDp8O1ZXMuIDxici8+PGJyLz4gVW1hIHZleiBhdGl2YWRvLCB0ZXLDoSBubyBtw6F4aW1vIDQgdGVudGF0aXZhcyBwYXJhIGRlc3RyYXZhciwgc2UgZXNxdWVjZXIgbyBwaW4gb3UgZXJyYXIsIG8gYXBsaWNhdGl2byBpcsOhIHJlbW92ZXIgc3VhcyBpbmZvcm1hw6fDtWVzIGRlIHV0aWxpemFkb3IuIFBvZGUgZW50cmFyIGRlIG5vdm8gZSBjb250aW51YXIgYSB1c2FyIG8gYXBsaWNhdGl2by5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2HDp8O1ZXNcIixcblx0XCJWT1RFX1RFWFRcIjogXCJWb2PDqiByZWNlYmVyw6EgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gdm90YXIgbm8gc2V1IGNvbnRlw7pkbyEgTm90aWZpY2HDp8O1ZXMgdGFtYsOpbSBpbmNsdWVtIHBlc28gZGUgdm90byBubyBhbGVydGEgZGEgbWVuc2FnZW0uKSBzZWphIHZvdG8gcG9zaXRpdm8sIHZvdG8gbmVnYXRpdm8sIHZvdG8gbnVsbykuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGFyXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiUmVjZWJlIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIGNvbWVudGFyIG5hcyBzdWFzIHB1YmxpY2HDp8O1ZXMgb3UgY29tZW50w6FyaW9zLjxici8+IE5vdGlmaWNhw6fDtWVzIGluY2x1ZW0gcXVhbmRvIGFsZ3XDqW0gZWRpdGEgb3MgY29tZW50w6FyaW9zIHRhbWLDqW0uXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkNvbWVudGFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJSZWNlYmUgc2VtcHJlIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIFNlZ3VpciBvdSBEZWl4YXIgZGUgc2VndWktbG8hXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW7Dp8O1ZXNcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiUmVjZWJlIHNlbXByZSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBvIG1lbmNpb25hciBuYWxndW1hIHB1YmxpY2HDp8OjbyBvdSBjb21lbnTDoXJpbyFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVwb3N0YXJcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJJcsOhIHJlY2ViZXIgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gcGFydGlsaGFyIGEgc3VhIHB1YmxpY2HDp8OjbyFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYcOnw7Vlc1wiLFxuXHRcIlZPVElOR1wiOiBcIlZvdGFuZG9cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIk8gcGVzbyBkZSB2b3RvIG91IHBlcmNlbnRhZ2VtIGFmZXRhIG8gcG9kZXIgZGUgdm90byBuYSBhcHAsIHBvciBpc3NvIHBvZGUgcmVndWxhciBvIHNldSByZWNvbXBlbnNhIGRlIHZvdG8gPGJyLz48YnIvPjxiPk5vdGE6PC9iPiBJc3RvIGlyw6EgbW9kaWZpY2FyIG8gcGVzby9wZXJjZW50YWdlbSBwYXJhIHZvdGFyIHBhcmEgYmFpeG8gdGFtYsOpbSBlIGVtIHRvZG8gbyBsYWRvIG5hIEFwcFwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZpZG9yXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJSZWNvbWVuZGFkb1wiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNhbHZhciBtdWRhbsOnYXNcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZm9ybWHDp8O1ZXMgZG9zIGVsZWl0b3Jlc1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIkJlbSB2aW5kbyBkZSBWb2x0YSFcIixcblx0XCJMT0dJTl8xXCI6IFwiQ29uZWN0ZS1zZSBjb20gc2V1IG5vbWUgZGUgdXRpbGl6YWRvciBlIHNlbmhhIHBhcmEgY29udGludWFyLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJDaGF2ZSBkZSBwdWJsaWNhw6fDo28gw6kgdXNhZGEgcGFyYSBwdWJsaWNhciwgY29tZW50YXIsIHZvdGFyLCBzZWd1aXIuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkNoYXZlIGRlIGF0aXZhw6fDo28gw6kgdXNhZGEgcGFyYSB0cmFuZmVyw6puY2lhcyBlIGF0dWFsaXphw6fDo28gZGUgZm90b3MgZGUgcGVyZmlsLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJBcyBjcmVkZW5jaWFpcyBkbyB1dGlsaXphZG9yIHPDo28gZ3VhcmRhZGFzIGxvY2FsbWVudGUgbm8gc2V1IGFwYXJlbGhvLiBEZXBpcyBkZSBkZXNsaWdhciBhcyBzdWFzIGNyZWRlbmNpYWlzIHPDo28gcmVtb3ZpZGFzXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTsOjbyBwb3NzdWkgY29udGE/XFxuXCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJSZWdpc3RlLXNlIGFnb3JhXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQ2FuY2VsYXJcIixcblx0XCJBRFZBTkNFRFwiOiBcIkF2YW7Dp2Fkb1wiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJDaGF2ZSBkZSBhdGl2YcOnw6NvIHByaXZhZGFcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIkNoYXZlIGRlIHB1YmxpY2HDp8OjbyBwcml2YWRhXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJTZW5oYSBNZXN0cmEvUHJpbmNpcGFsXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJVdGlsaXphZG9yXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiVmlzw6NvIGRlIENhcnTDo29cIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJWaXN0YSBjb21wYWN0YVwiLFxuXHRcIlNFQVJDSFwiOiBcIlByb2N1cmFyXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJQdWJsaWNhciB1bWEgaGlzdMOzcmlhXCIsXG5cdFwiUkVQTFlUT1wiOiBcIlJlc3BvbmRlciBwYXJhXCIsXG5cdFwiUE9TVFwiOiBcIlB1YmxpY2HDp8Ojb1wiLFxuXHRcIlBSRVZJRVdcIjogXCJWaXp1YWxpemFyXCIsXG5cdFwiREVGQVVMVFwiOiBcIlBhZHLDo28gNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIkZvcsOnYSBUb3RhbCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJSZWN1c2FyIFBhZ2FtZW50b1wiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiR3VhcmRhciBwcmEgbWFpcyB0YXJkZVwiLFxuXHRcIkNMRUFSXCI6IFwiVGVybWluYWRvXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiQ29udGXDumRvIGRhIHB1YmxpY2HDp8Ojb1wiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkNvbnRlw7pkbyBkbyBjb21lbnTDoXJpb1wiLFxuXHRcIlRJVExFXCI6IFwiVMOtdHVsb1wiLFxuXHRcIlRBR1NcIjogXCJFdGlxdWV0YXNcXG5NYXJjYWRvcmVzXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTsOjbyBjb25kaXpcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZpcm1hciBQaW5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJbmNvcnJldG9cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJBYnJpbmRvIHBvc3RhZ2VtXCIsXG5cdFwiU0VUX1BJTlwiOiBcIkNvbmZpZ3VyZSBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJFbnRyYXIgY29tIFBpblwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIlRlbSBhIGNlcnRlemE/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJSZXB1YmxpY2FyIMOpIGlycmV2ZXJzw612ZWwsIHF1ZXIgbWVzbW8gY29udGludWFyP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkVycm8gZGUgZGlmdXPDo28sIHRlbnRlIG5vdmFtZW50ZSFcIixcblx0XCJTVUNDRVNTXCI6IFwiU3VjZXNzb1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUHVibGljYcOnw6NvIHJlcHVibGljYWRhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkxvZ2luIGZhbGhvdSEgcG9yIGZhdm9yIGNlcnRpZmlxdWUtc2UgcXVlIGVzdMOhIGxpZ2FkbyBjb20gYSBzZW5oYSBtYXN0ZXIgb3UgYSBjaGF2ZSBwdWJsaWNhw6fDo28gcHJpdmFkYSBubyBMb2dpbiBzZSBlc2NvbGhldSBvIG1vZG8gYXZhbsOnYWRvLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkxvZ2luIGZhbGhvdSEgcG9yIGZhdm9yIGNlcnRpZmlxdWUtc2UgcXVlIGVzdMOhIGNvbmV0YWRvIGNvbSBhIHNlbmhhIG1hc3RlciBvdSBhIGNoYXZlIGF0aXZhIHByaXZhZGEgbm8gTG9naW4gc2UgZXNjb2xoZXUgbyBtb2RvIGF2YW7Dp2Fkby5cIixcblx0XCJXQVJOSU5HXCI6IFwiQ3VpZGFkb1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RhbmRvIHBvciB1bWEgVGVzdGVtdW5oYVwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiVm90b3UgcG9yIHVtYSBUZXN0ZW11bmhhXCIsXG5cdFwiQUdPXCI6IFwiYXRyw6FzXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJkZSBhZ29yYVwiLFxuXHRcIlNFQ1NcIjogXCJzZWdzXCIsXG5cdFwiQV9NSU5cIjogXCJ1bSBtaW51dG9cIixcblx0XCJNSU5TXCI6IFwibWludXRvc1wiLFxuXHRcIkFOX0hPVVJcIjogXCJ1bWEgaG9yYVwiLFxuXHRcIkhPVVJTXCI6IFwiaG9yYXNcIixcblx0XCJBX0RBWVwiOiBcInVtIGRpYVwiLFxuXHRcIkRBWVNcIjogXCJkaWFzXCIsXG5cdFwiQV9NT05USFwiOiBcInVtIG3DqnNcIixcblx0XCJNT05USFNcIjogXCJtZXNlc1wiLFxuXHRcIkFfWUVBUlwiOiBcInVtIGFub1wiLFxuXHRcIllFQVJTXCI6IFwiYW5vc1wiLFxuXHRcIk1JTl9SRUFEXCI6IFwibGVyIG1pblwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJWb3RlIHBhcmEgYmFpeG8gb3UgYmFuZGVpcmFcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJDYXB0dXJhciBpbWFnZW1cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIkVzY29saGVyIHVtYSBpbWFnZW1cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIkNvbmZpZ3VyZSBVUkwgY29zdHVtaXphZGFcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluc2VyaXIgdW1hIGltYWdlbVwiLFxuXHRcIkVSUk9SXCI6IFwiRXJyb1wiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkVycm8gbm8gY2FycmVnYW1lbnRvXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbWVyYSBjYW5jZWxhZGFcIixcblx0XCJTRVRfVVJMXCI6IFwiQ29uZmlndXJhcmwgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkxpbmsgd2ViIGRpcmV0byBwYXJhIGEgaW1hZ2VtXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21lbnTDoXJpbyBwdWJsaWNhZG8hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJBcGFnYXIgY29tZW50w6FyaW9zIMOpIGlycmV2ZXJzw612ZWxcIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJDb21lbnTDoXJpbyBhcGFnYWRvXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJDYXJyZWdhbmRvIGltYWdlbVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJDYXJyZWdhbWVudG8gY29tcGxldG9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiQ2FycmVnYW1lbnRvIGZhbGhvdVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkEgc2VuaGEgb3Ugbm9tZSBkYSBjb250YSBzw6NvIGluY29ycmV0b3NcIixcblx0XCJJTkZPXCI6IFwiSW5mb3JtYcOnw7Vlc1wiLFxuXHRcIlFSX1RFWFRcIjogXCJQb25oYSBvIGPDs2RpZ28gUVIgZGVudHJvIGRhIMOhcmVhIGRlIHNjYW5cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJDZXJ0aWZpcXVlLXNlIHF1ZSBwb3NzdWkgc2FsZG8gc3VmaWNpZW50ZSBwYXJhIGEgdHJhbnNhw6fDo28hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIk8gdXRpbGl6YWRvciBwYXJhIHF1ZW0gZXN0w6EgYSB0ZW50YXIgdHJhbnNmZXJpciBmdW5kb3MsIG7Do28gZXhpc3RlXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIlRlbSBjZXJ0ZXphIHF1ZSBxdWVyIHRyYW5zZmVyaXI/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiQ29uZmlybWHDp8Ojb1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNhw6fDo28gZm9pIGRpZnVuZGlkYVwiLFxuXHRcIkZFRURcIjogXCJDb250ZcO6ZG8gZGUgbm90w61jaWFzXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJUZW5kZW5jaWFcIixcblx0XCJIT1RcIjogXCJRdWVudGVcIixcblx0XCJORVdcIjogXCJOb3ZpZGFkZXNcIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vdmlkb3NcIixcblx0XCJWT1RFU1wiOiBcIlZvdG9zXCIsXG5cdFwiUEFZT1VUXCI6IFwiUGFnYW1lbnRvXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJDb21lbnTDoXJpb3NcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRlbmRlbmNpYSBhIDMwIGRpYXNcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJPcmRlbmFyIHB1YmxpY2HDp8O1ZXMgcG9yOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkNpY2xvIGRlIFBhZ2FtZW50b1wiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQYWdhbWVudG8gZW0gcG90ZW5jaWFsXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLDmmx0aW1vIFBhZ2FtZW50b1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJQYWdhbWVudG8gZG8gQXV0b3JcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJQYWdhbWVudG8gZGUgY3VyYWRvcmlhXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJQdWJsaWNhw6fDo28gZW52aWFkYSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiUHVibGlxdWUgcGFyYSBmdXR1cmEgc3VibWlzc8Ojb1wiLFxuXHRcIlNBVkVEXCI6IFwiU2Fsdm9cIixcblx0XCJDTEVBUkVEXCI6IFwiTGltcG9cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiUG9yIHVtYSBiYW5kZWlyYSBudW1hIHB1YmxpY2HDp8OjbyBwb2RlIHJlbW92ZXIgcmVjb21wZW5zYXMgZSB0b3JuYXIgbyBtYXRlcmlhbCBtZW5vcyB2aXNpdmVsLjxicj48YnI+QSBiYW5kZWlyYSBkZXZlIHNlciB1c2FkYSBwYXJhIDogPHVsPjxsaT5GcmF1ZGUgb3UgUGxhZ2lhcmlzbW88L2xpPjxsaT5EaXNjdXJzbyBkZSDDs2RpbyBvdSBJbnRlcm5ldCBUcm9sbGluZzwvbGk+PGxpPkNhdGVnb3JpemHDp8OjbyBtYWwgZmVpdGEgaW50ZW5jaW9uYWxtZW50ZSBvdSBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWl0ZSBkZSBwZWRpZG9zIGF0aW5naWRvLiB2ZXJpZmlxdWUgb3V0cm8gYXNzdW50by9ldGlxdWV0YSFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQdWJsaWNhw6fDo28gcmVtb3ZpZGEgZG9zIGZhdm9yaXRvcyFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiUHVibGljYcOnw6NvIGFkaWNpb25hZGEgYW9zIGZhdm9yaXRvcyFcIixcblx0XCJSRVNFVFwiOiBcIlJlaW5pY2lhclwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpY2FyIGEgZm90b2dyYWZpYSBkZSBwZXJmaWxcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmaWNhciBmb3RvZ3JhZmlhIGRhIGNhcGFcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJQb3IgZmF2b3IgaW5zaXJhIGEgY2hhdmUgZGUgYWN0aXZhw6fDo28gcHJpdmFkYSBxdWUgZXNjb2xoZXUsIE1vZG8gZGUgTG9naW4gQXZhbsOnYWRvXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiSXN0byByZWNvbmZpZ3VyYSBhIGltYWdlbSBkbyBwZXJmaWwgdWx0aXphZG9yXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiSXN0byByZWNvbmZpZ3VyYSBhIGltYWdlbSBkbyB1bHRpemFkb3JcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkF0dWFsaXphw6fDo28gZG8gc2VydmVyIG9icmlnYSBhIFJlaW5pY2lhciFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiQ29uZmlndXJhw6fDtWVzIGZvcmFtIGF0dWFsaXphZGFzXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiTMOtbmd1YVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiQXF1aSBwb2RlIG11ZGFyIGEgbMOtbmd1YSBkYSBBcHBcIixcblx0XCJMT0dJTl9UT19YXCI6IFwiRXN0YSBvcGVyYcOnw6NvIG9icmlnYSBxdWUgbyB1dGlsaXphZG9yIGVzdGFqYSBsaWdhZG8gY29tIGEgc2VuaGEgcHJpbmNpcGFsLCBjaGF2ZSBhY3RpdmHDp8Ojby9wdWJsaWNhw6fDo29cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXJpYVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlRyYWR1dG9yZXMgcXVlIGNvbnRyaWJ1aXJhbVwiLFxuXHRcIlNIQVJFXCI6IFwiUGFydGlsaGFyXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNZXJjYWRvXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJDw6JtYmlvXCIsXG5cdFwiRFJBRlRTXCI6IFwiUmFzY3VuaG9zXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiUHVibGljYcOnw6NvIHJlbW92aWRhIGRvcyBSYXNjdW5ob3MhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlB1cGxpY2HDp8OjbyBhZGljaW9uYWRhIGEgUmFzY3VuaG9zIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJSb2xlIHBhcmEgYSBlc3F1ZXJkYSBwYXJhIG9ww6fDtWVzXCIsXG5cdFwiTUFOQUdFXCI6IFwiR2VyaXJcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiSW1hZ2VtIHJlbW92aWRhXCIsXG5cdFwiQ09QWVwiOiBcIkNvcGlhclwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiTsOjbyBjYXJyZWdvdSBuZW5odW1hIGltYWdlbSwgYWluZGFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIkNhcnJlZ3VlIHBhcmEgcmVmcmVzY2FyXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkFwcHMgRXh0ZXJuYXNcIixcblx0XCJQTFVHSU5TXCI6IFwiTcOzZHVsb3MgZGUgZXh0ZW5zw6NvXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2lyYVwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiQnJldmVtZW50ZVwiLFxuXHRcIkNIQUlOXCI6IFwiQ29ycmVudGVcIixcblx0XCJDSEFJTl9URVhUXCI6IFwiQXF1aSBwb2RlIGVzY29saGVyIGJsb2NrY2hhaW4gb3UgYSBwbGF0YWZvcm1hIHBvciBkZWZlaXRvXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJNb2VkYVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJBcXVpIHBvZGUgYWx0ZXJhciBhIHN1YSB1bmlkYWRlIG1vbmV0w6FyaWEgcGFkcsOjby4gVmVyw6EgbyB2YWxvciBkYSByZWNvbXBlbnNhIGRvIHBvc3QvY29tZW50w6FyaW8gbmVzc2EgbW9lZGEuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+TGlzdGEgZGUgZnVuY2lvbmFsaWRhZGVzPC9iPjxicj4tIFRlbmhhIGFjZXNzbyBhIGFydGlnb3MgZXhjbHVzaXZvcyBzb2JyZSBxdWFscXVlciBhc3N1bnRvIHF1ZSBlc3RlamEgaW50ZXJlc3NhZG8gZW0gbGVyLjxicj4tIEVudm9sdmEtc2UgY29tIG9zIGF1dG9yZXMsIGNvbWVudGFuZG8gZSBkaXNjdXRpbmRvIG9zIHTDs3BpY29zLjxicj4tIFZvdGUgZW0gcG9zdHMgcGFyYSByZWNvbXBlbnNhciBvIGF1dG9yLCBiZW0gY29tbyBwYXJhIGdhbmhhciB1bWEgcmVjb21wZW5zYSBkZSBjdXJhZG9yLjxicj4tIFB1YmxpcXVlIG9zIHNldXMgYXJ0aWdvcyBlIHBvc3RzIGhvc3BlZGFuZG8tb3MgZ3JhdHVpdGFtZW50ZSBlIGdhbmhlIHJlY29tcGVuc2FzIHBvciBjYXRpdmFyIGUgZ2FuaGFyIHNlZ3VpZG9yZXMuPGJyPi0gRXNjcmV2YSBhcnRpZ29zIGVtIG1vdmltZW50bywgc2FsdmUgbcO6bHRpcGxvcyByYXNjdW5ob3MgZG8gcG9zdCBwYXJhIHB1YmxpY2HDp8OjbyBwb3N0ZXJpb3IuPGJyPi0gQWRpY2lvbmUgYXJ0aWdvcyBhb3Mgc2V1cyBmYXZvcml0b3MgcGFyYSBsZXIgbWFpcyB0YXJkZS48YnI+LSBDYW1iaWUgb3UgcmVjb2xoYSBvcyBzZXVzIGdhbmhvcy48YnI+LSBFbnZpZSBvcyBzZXVzIGZ1bmRvcyBwYXJhIHF1YWlzcXVlciBhdXRvcmVzIG91IHVzdcOhcmlvcywgYW1pZ29zLCBzZWd1aWRvcmVzLCBldGMuPGJyPi0gU2lnYSBhdXRvcmVzIGludGVyZXNzYW50ZXMsIGJsb2dnZXJzPGJyPi0uIFByb2N1cmUgb3Mgc2VndWlkb3JlcyBlIGF1dG9yZXMgcXVlIHNlZ3VlLjxicj4tIFJlY2ViYSBub3RpZmljYcOnw7VlcyBwYXJhIHNlIG1hbnRlciBlbSBjb250YWN0byBjb20gb3Mgc2V1cyBzZWd1aWRvcmVzIGUgZGlzY3Vzc8O1ZXMgZW0gcXVlIHNlIGVuY29udHJlIGVudm9sdmlkby48YnI+LSBQcm9jdXJlIHBvciBtYXJjYWRvcmVzL2NhdGVnb3JpYXMgaW50ZXJlc3NhbnRlcyBkZSBhcnRpZ29zLCBhdXRvcmVzLjxicj4tIFBlcnNvbmFsaXplIG8gc2V1IHBlcmZpbC48YnI+LSBNdWl0YXMgbWFpcyBmdW5jaW9uYWxpZGFkZXMgYSBjYW1pbmhvLjxicj48YnI+PGJyPlNlZ3VyYW7Dp2E8L2I+PGJyPjEuIEEgYXBsaWNhw6fDo28gbnVuY2EgYWNlZGUgb3UgcmV0w6ltIGZ1bmRvcyBkbyB1c3XDoXJpby48YnI+Mi4gQSBhcGxpY2HDp8OjbyBvZmVyZWNlIHVtIG1vZGVsbyBkZSBzZWd1cmFuw6dhIHF1ZSBwcml2aWxlZ2lhIG8gY2xpZW50ZSwgY29tIGNoYXZlcyBwcml2YWRhcyBob3NwZWRhZGFzIGxvY2FsbWVudGUgZSBudW5jYSBlbnZpYWRhcyBwYXJhIHF1YWxxdWVyIHNlcnZpZG9yLCB2b2PDqiDDqSByZXNwb25zw6F2ZWwgcG9yIGZhemVyIHVtYSBjw7NwaWEgZGUgc2VndXJhbsOnYSBkYXMgc3VhcyBzZW5oYXMuPGJyPjMuIEEgYXBsaWNhw6fDo28gb2ZlcmVjZSBleHBlcmnDqm5jaWFzIGUgaW50ZXJmYWNlcyBkZSB1c3XDoXJpbywgc2ltcGxlcyBlIGF0cmFlbnRlcy48YnI+NC4gQSBhcGxpY2HDp8OjbyBvZmVyZWNlIHVtIG7DrXZlbCBleHRyYSBkZSBzZWd1cmFuw6dhIGF0cmF2w6lzIGRvIGPDs2RpZ28gUGluPGJyPjxicj5PIGVTdGVlbSBhcG9pYSBhcyBwbGF0YWZvcm1hcyBTdGVlbSBlIEdvbG9zLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiRnVuZGFkb3IgZSBkZXNlbnZvbHZlZG9yIHByaW5jaXBhbFwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiQWRpY2lvbmFyIGNvbnRhXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0YWZvcm1hXCIsXG5cdFwiRVNDUk9XXCI6IFwiQ29tcHJvbWlzc29cIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJBZ2VudGUgZGVwb3NpdMOhcmlvXCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUHJhem8gZGUgcmF0aWZpY2HDp8Ojb1wiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiVmVuY2ltZW50byBkbyBjb21wcm9taXNzb1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJUYXhhIGRlIGRlcMOzc2l0b1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIlRlcm1vcyBkbyBjb21wcm9taXNzb1wiLFxuXHRcIk5JR0hUX01PREVcIjogXCJNb2RvIG5vY3R1cm5vXCIsXG5cdFwiREFZX01PREVcIjogXCJNb2RvIGRpdXJub1wiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIlZlciBvIGNvbnRleHRvIGNvbXBsZXRvXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIlV0aWxpemFkb3IgbsOjbyBlbmNvbnRyYWRvXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkFwcm92YXJcIixcblx0XCJESVNQVVRFXCI6IFwiRGlzcHV0YVwiLFxuXHRcIlJFTEVBU0VcIjogXCJMYW7Dp2FtZW50b1wiLFxuXHRcIkZST01cIjogXCJEZVwiLFxuXHRcIklEXCI6IFwiaWRlbnRpZmljYcOnw6NvXCIsXG5cdFwiU1VCTUlUXCI6IFwiU3VibWV0ZXJcIixcblx0XCJSRUNFSVZFUlwiOiBcIkRlc3RpbmF0w6FyaW9cIixcblx0XCJMT0NBVElPTlwiOiBcIkxvY2FsaXphw6fDo29cIixcblx0XCJXRUJTSVRFXCI6IFwiV2Vic2l0ZVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIk5vbWUgYSBleGliaXJcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi0JTQvtC80L7QuVwiLFxuXHRcIkxPR0lOXCI6IFwi0JLQvtC50YLQuFwiLFxuXHRcIkxPR09VVFwiOiBcItCS0YvQudGC0LhcIixcblx0XCJQUk9GSUxFXCI6IFwi0J/RgNC+0YTQuNC70YxcIixcblx0XCJGT0xMT1dcIjogXCLQn9C+0LTQv9C40YHQsNGC0YzRgdGPXCIsXG5cdFwiQk9PS01BUktTXCI6IFwi0JfQsNC60LvQsNC00LrQuFwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi0J/QtdGA0LXQstC10YHRgtC4INGB0YDQtdC00YHRgtCy0LBcIixcblx0XCJNQVJLRVRcIjogXCLQoNGL0L3QvtC6XCIsXG5cdFwiU0VUVElOR1NcIjogXCLQndCw0YHRgtGA0L7QudC60LhcIixcblx0XCJBQk9VVFwiOiBcItCeINC/0YDQvtCz0YDQsNC80LzQtVwiLFxuXHRcIkFCT1VUXzFcIjogXCLQs9C00LUg0LrQsNC20LTRi9C5INC80L7QttC10YIg0L/QvtC70YPRh9Cw0YLRjCDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1INC30LAg0YHQstC+0Lgg0LrQvtC90YLQtdC90YIhXCIsXG5cdFwiQUJPVVRfMlwiOiBcItC+0YHQvdC+0LLQsNC90L4g0L3QsCDQv9C70LDRgtGE0L7RgNC80LUge3twbGF0Zm9ybW5hbWV9fS4g0J/RgNC40LvQvtC20LXQvdC40LUg0YHQvtC30LTQsNC90L5cIixcblx0XCJBQk9VVF8zXCI6IFwi0Lgg0Y/QstC70Y/QtdGC0YHRjyDQvNC+0LHQuNC70YzQvdGL0Lwg0L/RgNC+0LXQutGC0L7QvCDRgSDQvtGC0LrRgNGL0YLRi9C8INC40YHRhdC+0LTQvdGL0Lwg0LrQvtC00L7QvCDRg9C/0YDQsNCy0LvRj9C10LzRi9C8INGB0L7QvtCx0YnQtdGB0YLQstC+0LwuINCf0YDQuNC70L7QttC10L3QuNC1INC/0YDQtdC00L7RgdGC0LDQstC70Y/QtdGCINC00L7RgdGC0YPQvyDQuiDQutC+0L3RgtC10L3RgtGDINC00LvRjyDRh9GC0LXQvdC40Y8sINC60L7QvNC80LXQvdGC0LjRgNC+0LLQsNC90LjRjywg0LPQvtC70L7RgdC+0LLQsNC90LjRjyDQuCDRgNCw0LfQvNC10YnQtdC90LjRjywg0L/RgNC10LTQvtGB0YLQsNCy0LvRj9C10YIg0LLQvtC30LzQvtC20L3QvtGB0YLRjCDQv9C10YDQtdCy0L7QtNCwINGB0YDQtdC00YHRgtCyINC4INC00YDRg9Cz0LjQtSDRhNGD0L3QutGG0LjQuCwg0L/RgNC10LTQu9Cw0LPQsNC10LzRi9C1INCx0LvQvtC60YfQtdC50L3QvtC8IHt7cGxhdGZvcm1uYW1lfX0g0Lgg0YHQtdGA0LLQuNGB0L7QvCB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuINCf0YDQuNC70L7QttC10L3QuNC1INC90LUg0LjQvNC10LXRgiDQtNC+0YHRgtGD0L/QsCDQuiDQtNC10L3QtdC20L3Ri9C8INGB0YDQtdC00YHRgtCy0LDQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0Lgg0L3QtSDRg9C00LXRgNC20LjQstCw0LXRgiDQuNGFO1wiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQuNGB0L/QvtC70YzQt9GD0LXRgiDQvNC+0LTQtdC70Ywg0LHQtdC30L7Qv9Cw0YHQvdC+0YHRgtC4INC90LAg0YHRgtC+0YDQvtC90LUg0LrQu9C40LXQvdGC0LAsINC30LDQutGA0YvRgtGL0LUg0LrQu9GO0YfQuCDRhdGA0LDQvdGP0YLRgdGPINC70L7QutCw0LvRjNC90L4g0Lgg0L3QuNC60L7Qs9C00LAg0L3QtSDQv9C10YDQtdC00LDRjtGC0YHRjyDQvdCwINGB0LXRgNCy0LXRgNCwO1wiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQv9GA0L7RgdGC0L7QuSDQuCDQv9GA0LjQstC70LXQutCw0YLQtdC70YzQvdGL0Lkg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GM0YHQutC40Lkg0LjQvdGC0LXRgNGE0LXQudGBO1wiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvdC40LrQvtCz0LTQsCDQvdC1INGC0YDQtdCx0YPQtdGCINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQstCy0LXRgdGC0Lgg0LrQsNC60LjQtS3Qu9C40LHQviDQv9C10YDRgdC+0L3QsNC70YzQvdGL0LUg0LTQsNC90L3Ri9C1LlwiLFxuXHRcIkFCT1VUXzhcIjogXCLQn9GA0L7Qs9C+0LvQvtGB0L7QstCw0YLRjCDQt9CwINC00LXQu9C10LPQsNGC0LAgZ29vZC1rYXJtYVwiLFxuXHRcIkFCT1VUXzlcIjogXCLQmtC+0L3RgtCw0LrRgtGLL9Ce0LHRgNCw0YLQvdCw0Y8g0YHQstGP0LfRjDpcIixcblx0XCJBQk9VVF8xMFwiOiBcItCU0L7Qv9C+0LvQvdC40YLQtdC70YzQvdCw0Y8g0LjQvdGE0L7RgNC80LDRhtC40Y86XCIsXG5cdFwiUkVNT1ZFXCI6IFwi0KPQtNCw0LvQuNGC0YxcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcItCe0LHQt9C+0YAg0YDRi9C90LrQsFwiLFxuXHRcIlBSSUNFXCI6IFwi0KbQtdC90LBcIixcblx0XCJBTU9VTlRcIjogXCLQodGD0LzQvNCwXCIsXG5cdFwiVE9UQUxcIjogXCLQktGB0LXQs9C+XCIsXG5cdFwiTk9PUkRFUlNcIjogXCLQndC10YIg0L7RgtC60YDRi9GC0YvRhSDQvtGA0LTQtdGA0L7QsiDRg1wiLFxuXHRcIkRBVEVcIjogXCLQlNCw0YLQsFwiLFxuXHRcIkJVWVwiOiBcItCa0YPQv9C40YLRjFwiLFxuXHRcIlNFTExcIjogXCLQn9GA0L7QtNCw0YLRjFwiLFxuXHRcIk9QRU5cIjogXCLQntGC0LrRgNGL0YLRjFwiLFxuXHRcIkhJU1RPUllcIjogXCLQmNGB0YLQvtGA0LjRj1wiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwi0J/QvtC00L/QuNGB0LDRgtGM0YHRjyDQstC30LDQuNC80L3QvlwiLFxuXHRcIkZPTExPV0VEXCI6IFwi0J/QvtC00L/QuNGB0LrQuFwiLFxuXHRcIlVORk9MTE9XXCI6IFwi0J7RgtC/0LjRgdCw0YLRjNGB0Y9cIixcblx0XCJGT0xMT1dJTkdcIjogXCLQn9C+0LTQv9C40YHQutCwXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwi0J/QvtC00L/QuNGB0LDQvdGLXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcItCf0L7QuNGB0Log0L/QvtC00L/QuNGB0YfQuNC60L7QslwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCLQn9C+0LjRgdC6INC/0L7QtNC/0LjRgdCw0L3QvdGL0YVcIixcblx0XCJCWVwiOiBcItC+0YJcIixcblx0XCJJTlwiOiBcItCyXCIsXG5cdFwiTUVOVVwiOiBcItCc0LXQvdGOXCIsXG5cdFwiQk9PS01BUktcIjogXCLQl9Cw0LrQu9Cw0LTQutCwXCIsXG5cdFwiUkVCTE9HXCI6IFwi0KDQtdC/0L7RgdGCXCIsXG5cdFwiVVBWT1RFXCI6IFwi0JPQvtC70L7RgSDQl9CwXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLQk9C+0LvQvtGBINCf0YDQvtGC0LjQslwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLQodC90Y/RgtGMINCT0L7Qu9C+0YEg0J/RgNC+0YLQuNCyXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLQodC90Y/RgtGMINCT0L7Qu9C+0YEg0JfQsFwiLFxuXHRcIlJFUExZXCI6IFwi0J7RgtCy0LXRgtC40YLRjFwiLFxuXHRcIkVESVRcIjogXCLQoNC10LTQsNC60YLQuNGA0L7QstCw0YLRjFwiLFxuXHRcIlBPU1RfMVwiOiBcItCf0YDQvtCy0LXQtNC40YLQtSDQv9Cw0LvRjNGG0LXQvCDQstC70LXQstC+INC90LAg0LrQvtC80LzQtdC90YLQsNGA0LjQuCwg0YfRgtC+0LHRiyDRg9Cy0LjQtNC10YLRjCDQstCw0YDQuNCw0L3RgtGLXCIsXG5cdFwiUE9TVF8yXCI6IFwi0J3QsNC20LzQuNGC0LUg0L3QsCDQutC+0LzQvNC10L3RgtCw0YDQuNC4LCDRh9GC0L7QsdGLINGD0LLQuNC00LXRgtGMINCy0LvQvtC20LXQvdC90YvQtSDQutC+0LzQvNC10L3RgtCw0YDQuNC4XCIsXG5cdFwiT1BUSU9OU1wiOiBcItCf0LDRgNCw0LzQtdGC0YDRi1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcItCg0LXQv9C+0YHRgtC90YPRgtC+XCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwi0JfQtNC10YHRjCDQv9C+0LrQsCDQvdC40YfQtdCz0L4g0L3QtdGCLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCLQkdCw0LvQsNC90YHRi1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sINC/0LXRgNC10LzQtdGJ0LDQtdC80YvQtSDRhtC40YTRgNC+0LLRi9C1INGC0L7QutC10L3Riywg0LrQvtGC0L7RgNGL0LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDQv9C10YDQtdC00LDQvdGLINCyINC70Y7QsdC+0LUg0LLRgNC10LzRjy4ge3twbGF0Zm9ybW5hbWV9fSDQvNC+0LbQtdGCINCx0YvRgtGMINC60L7QvdCy0LXRgNGC0LjRgNC+0LLQsNC9INCyIHt7cGxhdGZvcm1wb3dlcn19LCDRjdGC0L7RgiDQv9GA0L7RhtC10YHRgSDQvdCw0LfRi9Cy0LDQtdGC0YHRjyDCq9GD0YHQuNC70LXQvdC40LUge3twbGF0Zm9ybW5hbWV9fS3QsMK7LlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCDQvdC10L/QtdGA0LXQvNC10YnQsNC10LzRi9C1INGG0LjRhNGA0L7QstGL0LUg0YLQvtC60LXQvdGLLCDQuNGFINC60L7Qu9C40YfQtdGB0YLQstC+INGD0LLQtdC70LjRh9C40LLQsNC10YLRgdGPINC/0YDQuCDQtNC+0LvQs9C+0YHRgNC+0YfQvdC+0Lwg0YXRgNCw0L3QtdC90LjQuCDQuCDQs9C+0LvQvtGB0L7QstCw0L3QuNC4INC30LAg0L/QvtGB0YLRiy4g0KfQtdC8INC40YUg0YMg0JLQsNGBINCx0L7Qu9GM0YjQtSwg0YLQtdC8INGB0LjQu9GM0L3QtdC5INCS0Ysg0LLQu9C40Y/QtdGC0LUg0L3QsCDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1INC30LAg0L/QvtGB0YLRiyDQtNGA0YPQs9C40YUg0Lgg0YLQtdC8INCx0L7Qu9GM0YjQtSDQktGLINC/0L7Qu9GD0YfQsNC10YLQtSDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1INC30LAg0YHQstC+0LUg0LPQvtC70L7RgdC+0LLQsNC90LjQtS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCLQotC+0LrQtdC90Ysg0YHRgtC+0Y/RgiDQv9GA0LjQvNC10YDQvdC+IHt7cGxhdGZvcm1zdW5pdH19INCyIHt7cGxhdGZvcm1uYW1lfX0g0Y3QutCy0LjQstCw0LvQtdC90YLQtS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLQntGA0LjQtdC90YLQuNGA0L7QstC+0YfQvdCw0Y8g0YHRgtC+0LjQvNC+0YHRgtGMXCIsXG5cdFwiUFJPRklMRV80XCI6IFwi0J7RgNC40LXQvdGC0LjRgNC+0LLQvtGH0L3QsNGPINGB0YLQvtC40LzQvtGB0YLRjCDQvtGB0L3QvtCy0LDQvdCwINC90LAgNy3QtNC90LXQstC90L7QuSDRgdGA0LXQtNC90LXQuSDRgdGC0L7QuNC80L7RgdGC0Lgge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi0JjRgdGC0L7RgNC40Y8g0YLRgNCw0L3Qt9Cw0LrRhtC40LlcIixcblx0XCJQT1NUSU5HXCI6IFwi0J/QvtGB0YLQuNC90LNcIixcblx0XCJQUk9GSUxFXzVcIjogXCLQn9C+0YHRgtC40L3QsyDQutC70Y7RhyDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LTQu9GPINC/0L7RgdGC0LjQvdCz0LAg0Lgg0LPQvtC70L7RgdC+0LLQsNC90LjRjy4g0J7QvSDQtNC+0LvQttC10L0g0L7RgtC70LjRh9Cw0YLRjNGB0Y8g0L7RgiDQsNC60YLQuNCy0L3QvtCz0L4g0LrQu9GO0YfQsCDQuCDQutC70Y7Rh9CwINCy0LvQsNC00LXQu9GM0YbQsC5cIixcblx0XCJPV05FUlwiOiBcItCS0LvQsNC00LXQu9C10YZcIixcblx0XCJQUk9GSUxFXzZcIjogXCLQmtC70Y7RhyDQstC70LDQtNC10LvRjNGG0LAg0Y/QstC70Y/QtdGC0YHRjyDQvNCw0YHRgtC10YAg0LrQu9GO0YfQvtC8INC00LvRjyDQsNC60LrQsNGD0L3RgtCwINC4INGC0YDQtdCx0YPQtdGC0YHRjyDQtNC70Y8g0LjQt9C80LXQvdC10L3QuNGPINC00YDRg9Cz0LjRhSDQutC70Y7Rh9C10LkuINCX0LDQutGA0YvRgtGL0Lkg0LrQu9GO0Ycg0LjQu9C4INC/0LDRgNC+0LvRjCDQvtGCINC60LvRjtGH0LAg0LLQu9Cw0LTQtdC70YzRhtCwINC00L7Qu9C20LXQvSDRhdGA0LDQvdC40YLRjNGB0Y8g0L7RhNC70LDQudC9LCDQvdCw0YHQutC+0LvRjNC60L4g0Y3RgtC+INCy0L7Qt9C80L7QttC90L4uXCIsXG5cdFwiQUNUSVZFXCI6IFwi0JDQutGC0LjQstC90YvQuVwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcItCQ0LrRgtC40LLQvdGL0Lkg0LrQu9GO0Ycg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQv9C10YDQtdCy0L7QtNCwINGB0YDQtdC00YHRgtCyINC4INGA0LDQt9C80LXRidC10L3QuNGPINC+0YDQtNC10YDQvtCyINC90LAg0LLQvdGD0YLRgNC10L3QvdC10Lwg0YDRi9C90LrQtS5cIixcblx0XCJNRU1PXCI6IFwi0J/RgNC40LzQtdGH0LDQvdC40LVcIixcblx0XCJQUk9GSUxFXzhcIjogXCLQmtC70Y7RhyDQtNC70Y8g0L/RgNC40LzQtdGH0LDQvdC40Lkg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDRgdC+0LfQtNCw0L3QuNGPINC4INGH0YLQtdC90LjRjyDQv9GA0LjQvNC10YfQsNC90LjQuS5cIixcblx0XCJCTE9HXCI6IFwi0JHQu9C+0LNcIixcblx0XCJQT1NUU1wiOiBcItCf0L7RgdGC0YtcIixcblx0XCJSRVBMSUVTXCI6IFwi0J7RgtCy0LXRgtGLXCIsXG5cdFwiV0FMTEVUXCI6IFwi0JrQvtGI0LXQu9C10LpcIixcblx0XCJUQUdcIjogXCLQotC10LNcIixcblx0XCJVU0VSXCI6IFwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMXCIsXG5cdFwiQ0xPU0VcIjogXCLQl9Cw0LrRgNGL0YLRjFwiLFxuXHRcIlRPXCI6IFwi0JrQvtC80YNcIixcblx0XCJBU1NFVFwiOiBcItCQ0LrRgtC40LJcIixcblx0XCJTRU5EXCI6IFwi0J7RgtC/0YDQsNCy0LjRgtGMXCIsXG5cdFwiU0VDVVJJVFlcIjogXCLQkdC10LfQvtC/0LDRgdC90L7RgdGC0YxcIixcblx0XCJBVkFJTEFCTEVcIjogXCLQlNC+0YHRgtGD0L/QvdC+XCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLQntCx0YnQtdC00L7RgdGC0YPQv9C90L7QtSDQv9GA0LjQvNC10YfQsNC90LjQtVwiLFxuXHRcIlRPX0RFU0NcIjogXCLQn9C+0LvRjNC30L7QstCw0YLQtdC70YwsINC90LDQv9GA0LjQvNC10YAgZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUElOLdC60L7QtFwiLFxuXHRcIlBJTl9URVhUXCI6IFwiUElOLdC60L7QtCDQv9C+0LzQvtC20LXRgiDQktCw0Lwg0LfQsNGJ0LjRgtC40YLRjCDQv9GA0LjQu9C+0LbQtdC90LjQtSDQuCDQktCw0YjQuCDQtNCw0L3QvdGL0LUuIDxici8+PGJyLz48Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCf0L7RgdC70LUg0LLQutC70Y7Rh9C10L3QuNGPLCDRgyDQktCw0YEg0LXRgdGC0Ywg0LzQsNC60YHQuNC80YPQvCA0INC/0L7Qv9GL0YLQutC4INGA0LDQt9Cx0LvQvtC60LjRgNC+0LLQsNGC0Ywg0L/RgNC40LvQvtC20LXQvdC40LUsINC10YHQu9C4INCS0Ysg0LfQsNCx0YvQu9C4IFBJTi3QutC+0LQg0LjQu9C4INC+0YjQuNCx0LvQuNGB0Ywg0LIg0LXQs9C+INC90LDQsdC+0YDQtSwg0L/RgNC40LvQvtC20LXQvdC40LUg0YPQtNCw0LvQuNGCINC00LDQvdC90YvQtSDQstC+0YjQtdC00YjQtdCz0L4g0LIg0YHQuNGB0YLQtdC80YMg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPLiDQktGLINC80L7QttC10YLQtSDQv9C+0LLRgtC+0YDQvdC+INCy0YvQv9C+0LvQvdC40YLRjCDQstGF0L7QtCDQuCDQv9GA0L7QtNC+0LvQttC40YLRjCDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0L/RgNC40LvQvtC20LXQvdC40LUuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcItCj0LLQtdC00L7QvNC70LXQvdC40Y9cIixcblx0XCJWT1RFX1RFWFRcIjogXCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4g0YLQviDQs9C+0LvQvtGB0YPQtdGCINC30LAg0JLQsNGIINC60L7QvdGC0LXQvdGCISA8YnIvPjxiPtCf0YDQuNC80LXRh9Cw0L3QuNC1OjwvYj4g0KPQstC10LTQvtC80LvQtdC90LjRjyDQvtGC0L7QsdGA0LDQttCw0Y7RgiDQstC10YEg0LPQvtC70L7RgdCwINCyINGB0L7QvtCx0YnQtdC90LjQuCAo0LHRg9C00Ywg0YLQviDQk9C+0LvQvtGBINCX0LAsINCT0L7Qu9C+0YEg0J/RgNC+0YLQuNCyLCDRgdC90Y/RgtC40LUg0JPQvtC70L7RgdCwKS5cIixcblx0XCJWT1RFXCI6IFwi0JPQvtC70L7RgdC+0LLQsNC90LjQtVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcItCS0Ysg0L/QvtC70YPRh9C40YLQtSDRg9Cy0LXQtNC+0LzQu9C10L3QuNC1LCDQutC+0LPQtNCwINC60YLQvi3RgtC+INC/0YDQvtC60L7QvNC80LXQvdGC0LjRgNGD0LXRgiDQktCw0YjQuCDQv9C+0YHRgtGLINC40LvQuCDQutC+0LzQvNC10L3RgtCw0YDQuNC4ITxici8+IDxiPtCf0YDQuNC80LXRh9Cw0L3QuNC1OjwvYj4g0JLRiyDRgtCw0LrQttC1INC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LXRgdC70Lgg0LrRgtC+LdGC0L4gPGI+0L7RgtGA0LXQtNCw0LrRgtC40YDRg9C10YI8L2I+INGB0LLQvtC5INC60L7QvNC80LXQvdGC0LDRgNC40LkuXCIsXG5cdFwiQ09NTUVOVFwiOiBcItCa0L7QvNC80LXQvdGC0LDRgNC40LlcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcItCS0Ysg0L/QvtC70YPRh9C40YLQtSDRg9Cy0LXQtNC+0LzQu9C10L3QuNC1LCDQutC+0LPQtNCwINC60YLQvi3RgtC+INC/0L7QtNC/0LjRiNC10YLRgdGPINC40LvQuCDQvtGC0L/QuNGI0LXRgtGB0Y8g0L7RgiDQktCw0YEhXCIsXG5cdFwiTUVOVElPTlNcIjogXCLQo9C/0L7QvNC40L3QsNC90LjRj1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDRg9C/0L7QvNGP0L3QtdGCINCS0LDRgSDQsiDRgdCy0L7QtdC8INC/0L7RgdGC0LUv0LrQvtC80LzQtdC90YLQsNGA0LjQuSFcIixcblx0XCJSRVNURUVNXCI6IFwi0KDQtdC/0L7RgdGC0YtcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDRgdC00LXQu9Cw0LXRgiDRgNC10L/QvtGB0YIg0JLQsNGI0LXQs9C+INC/0L7RgdGC0LAhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCLQmtC+0L3RhNC40LPRg9GA0LDRhtC40Y9cIixcblx0XCJWT1RJTkdcIjogXCLQk9C+0LvQvtGB0L7QstCw0YLRjFwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi0JLQtdGBINCz0L7Qu9C+0YHQsCDQsiDQv9GA0L7RhtC10L3RgtCw0YUg0LLQu9C40Y/QtdGCINC90LAg0YHQuNC70YMg0LPQvtC70L7RgdCwINCyINC/0YDQuNC70L7QttC10L3QuNC4LCDRgtCw0Log0YfRgtC+INCS0Ysg0LzQvtC20LXRgtC1INGA0LXQs9GD0LvQuNGA0L7QstCw0YLRjCDQvdCw0LPRgNCw0LTRgyDQv9GA0Lgg0LPQvtC70L7RgdC+0LLQsNC90LjQuC4gPGJyLz48YnIvPjxiPtCf0YDQuNC80LXRh9Cw0L3QuNC1OjwvYj4g0K3RgtC+INGC0LDQutC20LUg0LjQt9C80LXQvdC40YIg0LLQtdGBINCT0L7Qu9C+0YHQsCDQn9GA0L7RgtC40LJcIixcblx0XCJTRVJWRVJcIjogXCLQodC10YDQstC10YBcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcItCg0LXQutC+0LzQtdC90LTQvtCy0LDQvdC90YvQuVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItCh0L7RhdGA0LDQvdC40YLRjCDQuNC30LzQtdC90LXQvdC40Y9cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItCY0L3RhNC+0YDQvNCw0YbQuNGPINC+INC/0YDQvtCz0L7Qu9C+0YHQvtCy0LDQstGI0LjRhVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcItCU0L7QsdGA0L4g0L/QvtC20LDQu9C+0LLQsNGC0YwhXCIsXG5cdFwiTE9HSU5fMVwiOiBcItCn0YLQvtCx0Ysg0L/RgNC+0LTQvtC70LbQuNGC0YwsINCy0L7QudC00LjRgtC1INGBINCS0LDRiNC40Lwg0LjQvNC10L3QtdC8INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQuCDQv9Cw0YDQvtC70LXQvC5cIixcblx0XCJMT0dJTl8yXCI6IFwi0J/QvtGB0YLQuNC90LMg0LrQu9GO0Ycg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQvdCw0L/QuNGB0LDQvdC40Y8g0L/QvtGB0YLQvtCyLCDQutC+0LzQvNC10L3RgtCw0YDQuNC10LIsINCz0L7Qu9C+0YHQvtCy0LDQvdC40Y8g0Lgg0L/QvtC00L/QuNGB0L7Qui5cIixcblx0XCJMT0dJTl8zXCI6IFwi0JDQutGC0LjQstC90YvQuSDQutC70Y7RhyDQuNGB0L/QvtC70YzQt9GD0LXRgtGB0Y8g0LTQu9GPINC/0LXRgNC10LLQvtC00LAg0YHRgNC10LTRgdGC0LIg0Lgg0L7QsdC90L7QstC70LXQvdC40Y8g0LjQt9C+0LHRgNCw0LbQtdC90LjRjyDQsiDQv9GA0L7RhNC40LvQtS5cIixcblx0XCJMT0dJTl80XCI6IFwi0KPRh9C10YLQvdGL0LUg0LTQsNC90L3Ri9C1INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDRhdGA0LDQvdGP0YLRgdGPINC70L7QutCw0LvRjNC90L4g0L3QsCDRg9GB0YLRgNC+0LnRgdGC0LLQtS4g0J/RgNC4INCS0YvRhdC+0LTQtSDRg9GH0LXRgtC90YvQtSDQtNCw0L3QvdGL0LUg0LHRg9C00YPRgiDRg9C00LDQu9C10L3RiyFcIixcblx0XCJET05UX0hBVkVcIjogXCLQndC1INC30LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDQvdGLP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwi0JfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNGC0YzRgdGPINGB0LXQudGH0LDRgVwiLFxuXHRcIkNBTkNFTFwiOiBcItCe0YLQvNC10L3QsFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi0KDQsNGB0YjQuNGA0LXQvdC90YvQuSDRgNC10LbQuNC8XCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcItCQ0LrRgtC40LLQvdGL0Lkg0LfQsNC60YDRi9GC0YvQuSDQutC70Y7Rh1wiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi0J/QvtGB0YLQuNC90LMg0LfQsNC60YDRi9GC0YvQuSDQutC70Y7Rh1wiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwi0JzQsNGB0YLQtdGAL9C+0YHQvdC+0LLQvdC+0Lkg0L/QsNGA0L7Qu9GMXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLQmNC80Y8g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi0JrQsNGA0YLQvtGH0LrQuFwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcItCa0L7QvNC/0LDQutGC0L3Ri9C5XCIsXG5cdFwiU0VBUkNIXCI6IFwi0J/QvtC40YHQulwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi0JTQvtCx0LDQstC40YLRjCDRgdGC0LDRgtGM0Y5cIixcblx0XCJSRVBMWVRPXCI6IFwi0J7RgtCy0LXRgtC40YLRjCDQvdCwXCIsXG5cdFwiUE9TVFwiOiBcItCf0L7RgdGCXCIsXG5cdFwiUFJFVklFV1wiOiBcItCf0YDQtdC00LLQsNGA0LjRgtC10LvRjNC90YvQuSDQv9GA0L7RgdC80L7RgtGAXCIsXG5cdFwiREVGQVVMVFwiOiBcItCf0L4g0YPQvNC+0LvRh9Cw0L3QuNGOIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCLQl9Cw0L/Qu9Cw0YLQuNGC0YwgMTAwJSDQsiB7e3BsYXRmb3JtcG93ZXJ9fVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwi0J7RgtC60LDQt9Cw0YLRjNGB0Y8g0L7RgiDQstGL0L/Qu9Cw0YLRi1wiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi0KHQntCl0KDQkNCd0JjQotCsINCU0JvQryDQn9Ce0KHQm9CV0JTQo9Cu0KnQldCT0J4g0JjQodCf0J7Qm9Cs0JfQntCS0JDQndCY0K9cIixcblx0XCJDTEVBUlwiOiBcItCe0KfQmNCh0KLQmNCi0KxcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCLQodC+0LTQtdGA0LbQsNC90LjQtSDQv9C+0YHRgtCwXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi0KHQvtC00LXRgNC20LDQvdC40LUg0LrQvtC80LzQtdC90YLQsNGA0LjRj1wiLFxuXHRcIlRJVExFXCI6IFwi0JfQsNCz0L7Qu9C+0LLQvtC6XCIsXG5cdFwiVEFHU1wiOiBcItCi0LXQs9C4XCIsXG5cdFwiTk9UX01BVENIXCI6IFwi0J3QlSDQodCe0JLQn9CQ0JTQldCd0JjQmVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi0J/QvtC00YLQstC10YDQtNC40YLQtSBQSU4t0LrQvtC0XCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi0J3QldCf0KDQkNCS0JjQm9Cs0J3QnlwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcItC+0YLQutGA0YvRgtC40LUg0L/QvtGB0YLQsFwiLFxuXHRcIlNFVF9QSU5cIjogXCLQo9GB0YLQsNC90L7QstC40YLQtSBQSU4t0LrQvtC0XCIsXG5cdFwiRU5URVJfUElOXCI6IFwi0JLQstC10LTQuNGC0LUgUElOLdC60L7QtFwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcItCS0Ysg0YPQstC10YDQtdC90Ys/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLQoNC10L/QvtGB0YIg0Y/QstC70Y/QtdGC0YHRjyDQvdC10L7QsdGA0LDRgtC40LzRi9C8LCDQktGLINGF0L7RgtC40YLQtSDQv9GA0L7QtNC+0LvQttC40YLRjD9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLQndC1INGD0LTQsNC70L7RgdGMINGC0YDQsNC90YHQu9C40YDQvtCy0LDRgtGMLCDQv9C+0L/RgNC+0LHRg9C50YLQtSDQtdGJ0LUg0YDQsNC3IVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLQo9GB0L/QtdGI0L3QvlwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwi0KDQtdC/0L7RgdGC0L3Rg9GC0YvQuSDQv9C+0YHRgiFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwi0J7RiNC40LHQutCwINCy0YXQvtC00LAhINCf0L7QttCw0LvRg9C50YHRgtCwLCDRg9Cx0LXQtNC40YLQtdGB0YwsINGH0YLQviDQstGLINCy0L7RiNC70Lgg0LIg0YHQuNGB0YLQtdC80YMg0YEg0LzQsNGB0YLQtdGAINC/0LDRgNC+0LvQtdC8INC40LvQuCDRg9C60LDQt9Cw0LvQuCDQt9Cw0LrRgNGL0YLRi9C5INCf0L7RgdGC0LjQvdCzINC60LvRjtGHINC/0YDQuCDQstGF0L7QtNC1INCyINGB0LjRgdGC0LXQvNGDINCyINGA0LDRgdGI0LjRgNC10L3QvdC+0Lwg0YDQtdC20LjQvNC1LlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcItCe0YjQuNCx0LrQsCDQstGF0L7QtNCwISDQn9C+0LbQsNC70YPQudGB0YLQsCwg0YPQsdC10LTQuNGC0LXRgdGMLCDRh9GC0L4g0LLRiyDQstC+0YjQu9C4INCyINGB0LjRgdGC0LXQvNGDINGBINC80LDRgdGC0LXRgCDQv9Cw0YDQvtC70LXQvCDQuNC70Lgg0YPQutCw0LfQsNC70Lgg0LfQsNC60YDRi9GC0YvQuSDQkNC60YLQuNCy0L3Ri9C5INC60LvRjtGHINC/0YDQuCDQstGF0L7QtNC1INCyINGB0LjRgdGC0LXQvNGDINCyINGA0LDRgdGI0LjRgNC10L3QvdC+0Lwg0YDQtdC20LjQvNC1LlwiLFxuXHRcIldBUk5JTkdcIjogXCLQn9GA0LXQtNGD0L/RgNC10LbQtNC10L3QuNC1XCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcItCT0L7Qu9C+0YHQvtCy0LDRgtGMINC30LAg0LTQtdC70LXQs9Cw0YLQsFwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwi0J/RgNC+0LPQvtC70L7RgdC+0LLQsNC70Lgg0LfQsCDQtNC10LvQtdCz0LDRgtCwXCIsXG5cdFwiQUdPXCI6IFwi0L3QsNC30LDQtFwiLFxuXHRcIkZST01fTk9XXCI6IFwi0YEg0Y3RgtC+0LPQviDQvNC+0LzQtdC90YLQsFwiLFxuXHRcIlNFQ1NcIjogXCLRgdC10LrRg9C90LRcIixcblx0XCJBX01JTlwiOiBcItC80LjQvdGD0YLQsFwiLFxuXHRcIk1JTlNcIjogXCLQvNC40L3Rg9GCKNGLKVwiLFxuXHRcIkFOX0hPVVJcIjogXCLRh9Cw0YFcIixcblx0XCJIT1VSU1wiOiBcItGH0LDRgdCwKNC+0LIpXCIsXG5cdFwiQV9EQVlcIjogXCLQtNC10L3RjFwiLFxuXHRcIkRBWVNcIjogXCLQtNC90Y8o0LXQuSlcIixcblx0XCJBX01PTlRIXCI6IFwi0LzQtdGB0Y/RhlwiLFxuXHRcIk1PTlRIU1wiOiBcItC80LXRgdGP0YbQsCjQtdCyKVwiLFxuXHRcIkFfWUVBUlwiOiBcItCz0L7QtFwiLFxuXHRcIllFQVJTXCI6IFwi0LPQvtC00LBcIixcblx0XCJNSU5fUkVBRFwiOiBcItC80LjQvSDRh9GC0LXQvdC40Y9cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwi0JPQvtC70L7RgSDQn9GA0L7RgtC40LIg0LjQu9C4INGE0LvQsNCzXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi0JfQsNGF0LLQsNGCINC40LfQvtCx0YDQsNC20LXQvdC40Y9cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcItCS0YvQsdC+0YAg0LjQt9C+0LHRgNCw0LbQtdC90LjRj1wiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwi0JfQsNC00LDRgtGMINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC5IFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwi0JLRgdGC0LDQstC40YLRjCDQuNC30L7QsdGA0LDQttC10L3QuNC1XCIsXG5cdFwiRVJST1JcIjogXCLQntGI0LjQsdC60LBcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLQntGI0LjQsdC60LAg0L/RgNC4INC30LDQs9GA0YPQt9C60LVcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi0JfQsNGF0LLQsNGCINC40LfQvtCx0YDQsNC20LXQvdC40Y8g0L7RgtC80LXQvdC10L1cIixcblx0XCJTRVRfVVJMXCI6IFwi0JLRgdGC0LDQstC40YLRjCDRgdGB0YvQu9C60YNcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi0J/RgNGP0LzQsNGPINGB0YHRi9C70LrQsCDQvdCwINC40LfQvtCx0YDQsNC20LXQvdC40LVcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcItCa0L7QvNC80LXQvdGC0LDRgNC40Lkg0L7RgtC/0YDQsNCy0LvQtdC9IVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi0KPQtNCw0LvQtdC90LjQtSDQutC+0LzQvNC10L3RgtCw0YDQuNC10LIg0Y/QstC70Y/QtdGC0YHRjyDQvdC10L7QsdGA0LDRgtC40LzRi9C8XCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi0KPQtNCw0LvQtdC90L3Ri9C5INC60L7QvNC80LXQvdGC0LDRgNC40LlcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcItCX0LDQs9GA0YPQt9C60LAg0LjQt9C+0LHRgNCw0LbQtdC90LjRj1wiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLQl9Cw0LPRgNGD0LfQutCwINC30LDQstC10YDRiNC10L3QsFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLQndC1INGD0LTQsNC70L7RgdGMINC30LDQs9GA0YPQt9C40YLRjFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcItCd0LXQv9GA0LDQstC40LvRjNC90YvQuSDQv9Cw0YDQvtC70Ywg0LjQu9C4INC40LzRjyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cIixcblx0XCJJTkZPXCI6IFwi0JjQvdGE0L7RgNC80LDRhtC40Y9cIixcblx0XCJRUl9URVhUXCI6IFwi0KDQsNC30LzQtdGB0YLQuNGC0LUgUVIg0LrQvtC0INCy0L3Rg9GC0YDQuCDRgdC60LDQvdC40YDRg9GO0YnQtdC5INC+0LHQu9Cw0YHRgtC4XCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi0KPQsdC10LTQuNGC0LXRgdGMINGH0YLQviDRgyDQktCw0YEg0LTQvtGB0YLQsNGC0L7Rh9C90L4g0YHRgNC10LTRgdGC0LIg0LTQu9GPINGC0YDQsNC90LfQsNC60YbQuNC4IVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLQn9C+0LvRjNC30L7QstCw0YLQtdC70YwsINC60L7RgtC+0YDQvtC80YMg0JLRiyDQv9GL0YLQsNC10YLQtdGB0Ywg0L/QtdGA0LXQstC10YHRgtC4INGB0YDQtdC00YHRgtCy0LAsINC90LUg0YHRg9GJ0LXRgdGC0LLRg9C10YIhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcItCS0Ysg0YPQstC10YDQtdC90Ysg0YfRgtC+INGF0L7RgtC40YLQtSDQvtGB0YPRidC10YHRgtCy0LjRgtGMINC/0LXRgNC10LLQvtC0INGB0YDQtdC00YHRgtCyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcItCf0L7QtNGC0LLQtdGA0LbQtNC10L3QuNC1XCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLQotGA0LDQvdC30LDQutGG0LjRjyDQsdGL0LvQsCDRgtGA0LDQvdGB0LvQuNGA0L7QstCw0L3QsFwiLFxuXHRcIkZFRURcIjogXCLQm9C10L3RgtCwXCIsXG5cdFwiVFJFTkRJTkdcIjogXCLQm9GD0YfRiNC10LVcIixcblx0XCJIT1RcIjogXCLQkNC60YLRg9Cw0LvRjNC90L7QtVwiLFxuXHRcIk5FV1wiOiBcItCd0L7QstC+0LVcIixcblx0XCJQUk9NT1RFRFwiOiBcItCf0YDQvtC00LLQuNCz0LDQtdC80L7QtVwiLFxuXHRcIlZPVEVTXCI6IFwi0JPQvtC70L7RgdC+0LJcIixcblx0XCJQQVlPVVRcIjogXCLQktGL0L/Qu9Cw0YLQsFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi0JrQvtC80LzQtdC90YLQsNGA0LjQtdCyXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCLQm9GD0YfRiNC10LUg0LfQsCAzMCDQtNC90LXQuVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItCh0L7RgNGC0LjRgNC+0LLQsNGC0Ywg0L/QvtGB0YLRiyDQv9C+OlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcItCf0LXRgNC40L7QtCDQstGL0L/Qu9Cw0YJcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi0J/QvtGC0LXQvdGG0LjQsNC70YzQvdCw0Y8g0LLRi9C/0LvQsNGC0LBcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcItCf0L7RgdC70LXQtNC90Y/RjyDQstGL0L/Qu9Cw0YLQsFwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLQkNCy0YLQvtGA0YHQutCw0Y8g0LLRi9C/0LvQsNGC0LBcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLQmtGD0YDQsNGC0L7RgNGB0LrQsNGPINCy0YvQv9C70LDRgtCwXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLQn9C+0YHRgiDQvtC/0YPQsdC70LjQutC+0LLQsNC9IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLQn9C+0YHRgiDQtNC70Y8g0L7RgtGB0YDQvtGH0LXQvdC90L7QuSDQv9GD0LHQu9C40LrQsNGG0LjQuCFcIixcblx0XCJTQVZFRFwiOiBcItCh0L7RhdGA0LDQvdC10L1cIixcblx0XCJDTEVBUkVEXCI6IFwi0J7Rh9C40YnQtdC9XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcItCh0YLQsNCy0Y8g0YTQu9Cw0LMg0L/QvtGB0YLRgywg0JLRiyDQvNC+0LbQtdGC0LUg0YPQvNC10L3RjNGI0LjRgtGMINC90LDQs9GA0LDQtNGDINC4INGB0LTQtdC70LDRgtGMINGN0YLQvtGCINC80LDRgtC10YDQuNCw0Lsg0LzQtdC90LXQtSDQt9Cw0LzQtdGC0L3Ri9C8Ljxicj48YnI+0KTQu9Cw0LMg0LTQvtC70LbQtdC9INCx0YvRgtGMINC40YHQv9C+0LvRjNC30L7QstCw0L0g0LIg0YHQu9C10LTRg9GO0YnQuNGFINGB0LvRg9GH0LDRj9GFOiA8dWw+PGxpPtCc0L7RiNC10L3QvdC40YfQtdGB0YLQstC+INC40LvQuCDQn9C70LDQs9C40LDRgjwvbGk+PGxpPtCR0YDQsNC90Ywg0LjQu9C4INCY0L3RgtC10YDQvdC10YIg0KLRgNC+0LvQu9C40L3QszwvbGk+PGxpPtCf0YDQtdC00L3QsNC80LXRgNC10L3QvdC+0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0L3QtdGB0L7QvtGC0LLQtdGA0YHRgtCy0YPRjtGJ0LXQuSDQutCw0YLQtdCz0L7RgNC40Lgg0LjQu9C4INCh0L/QsNC8PC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcItCf0YDQtdCy0YvRiNC10L3QviDQutC+0LvQuNGH0LXRgdGC0LLQviDQt9Cw0L/RgNC+0YHQvtCyLiDQn9GA0L7QstC10YDRjNGC0LUg0LTRgNGD0LPQuNC1INGC0YDQtdC90LTRiy/RgtC10LPQuCFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLQn9C+0YHRgiDRg9C00LDQu9C10L0g0LjQtyDQt9Cw0LrQu9Cw0LTQvtC6IVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLQn9C+0YHRgiDQtNC+0LHQsNCy0LvQtdC9INCyINC30LDQutC70LDQtNC60LghXCIsXG5cdFwiUkVTRVRcIjogXCLQodCx0YDQvtGB0LjRgtGMXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLQmNC30LzQtdC90LjRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LUg0L/RgNC+0YTQuNC70Y9cIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItCY0LfQvNC10L3QuNGC0Ywg0LjQt9C+0LHRgNCw0LbQtdC90LjQtSDQvtCx0LvQvtC20LrQuFwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcItCf0L7QttCw0LvRg9C50YHRgtCwLCDQv9GA0LXQtNC+0YHRgtCw0LLRjNGC0LUg0JDQutGC0LjQstC90YvQuSDQt9Cw0LrRgNGL0YLRi9C5INC60LvRjtGHLCDQtdGB0LvQuCDQktGLINCy0YvQsdGA0LDQu9C4INGA0LDRgdGI0LjRgNC10L3QvdGL0Lkg0YDQtdC20LjQvCDQsNCy0YLQvtGA0LjQt9Cw0YbQuNC4IVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcItCt0YLQviDQv9GA0LjQstC10LTQtdGCINC6INGB0LHRgNC+0YHRgyDQuNC30L7QsdGA0LDQttC10L3QuNGPINCS0LDRiNC10LPQviDQv9GA0L7RhNC40LvRj1wiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcItCt0YLQviDQv9GA0LjQstC10LTQtdGCINC6INGB0LHRgNC+0YHRgyDQuNC30L7QsdGA0LDQttC10L3QuNGPINCS0LDRiNC10Lkg0L7QsdC70L7QttC60LhcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcItCe0LHQvdC+0LLQu9C10L3QuNC1INGB0LXRgNCy0LXRgNCwINGC0YDQtdCx0YPQtdGCINC/0LXRgNC10LfQsNCz0YDRg9C30LrQuCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi0J3QsNGB0YLRgNC+0LnQutC4INC+0LHQvdC+0LLQu9C10L3RiyFcIixcblx0XCJMQU5HVUFHRVNcIjogXCLQr9C30YvQutC4XCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLQl9C00LXRgdGMINCy0Ysg0LzQvtC20LXRgtC1INC40LfQvNC10L3QuNGC0Ywg0Y/Qt9GL0Log0L/RgNC40LvQvtC20LXQvdC40Y8uXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcItCt0YLQsCDQvtC/0LXRgNCw0YbQuNGPINGC0YDQtdCx0YPQtdGCINCw0LLRgtC+0YDQuNC30LDRhtC40Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINCyINGB0LjRgdGC0LXQvNC1INGBINC/0LDRgNC+0LvQtdC8LCDQsNC60YLQuNCy0L3Ri9C8L9C/0L7RgdGC0LjQvdCzINC60LvRjtGH0L7QvC4g0J/QvtC20LDQu9GD0LnRgdGC0LAsINCw0LLRgtC+0YDQuNC30YPQudGC0LXRgdGMINC4INC/0L7QstGC0L7RgNC40YLQtSDQv9C+0L/Ri9GC0LrRgy5cIixcblx0XCJHQUxMRVJZXCI6IFwi0JPQsNC70LXRgNC10Y9cIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLQkNCy0YLQvtGA0Ysg0L/QtdGA0LXQstC+0LTQsFwiLFxuXHRcIlNIQVJFXCI6IFwi0J/QvtC00LXQu9C40YLRjNGB0Y9cIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcItCg0YvQvdC+0LpcIixcblx0XCJFWENIQU5HRVwiOiBcItCR0LjRgNC20LBcIixcblx0XCJEUkFGVFNcIjogXCLQp9C10YDQvdC+0LLQuNC60LhcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLQn9C+0YHRgiDRg9C00LDQu9C10L0g0LjQtyDRh9C10YDQvdC+0LLQuNC60L7QsiFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi0J/QvtGB0YIg0LTQvtCx0LDQstC70LXQvSDQsiDRh9C10YDQvdC+0LLQuNC60LghXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcItCf0YDQvtCy0LXQtNC40YLQtSDQv9Cw0LvRjNGG0LXQvCDQstC70LXQstC+INGH0YLQvtCx0Ysg0YPQstC40LTQtdGC0Ywg0LLQsNGA0LjQsNC90YLRi1wiLFxuXHRcIk1BTkFHRVwiOiBcItCj0L/RgNCw0LLQu9C10L3QuNC1XCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcItCY0LfQvtCx0YDQsNC20LXQvdC40LUg0YPQtNCw0LvQtdC90L5cIixcblx0XCJDT1BZXCI6IFwi0JrQvtC/0LjRgNC+0LLQsNGC0YxcIixcblx0XCJOT19JTUFHRVwiOiBcItCS0Ysg0LXRidC1INC90LUg0LfQsNCz0YDRg9C30LjQu9C4INC90Lgg0L7QtNC90L7Qs9C+INC40LfQvtCx0YDQsNC20LXQvdC40Y8hXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLQn9C+0YLRj9C90LjRgtC1INCy0L3QuNC3LCDRh9GC0L7QsdGLINC+0LHQvdC+0LLQuNGC0YxcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi0JLQvdC10YjQvdC40LUg0L/RgNC40LvQvtC20LXQvdC40Y9cIixcblx0XCJQTFVHSU5TXCI6IFwi0J/Qu9Cw0LPQuNC90YtcIixcblx0XCJTVUdHRVNUXCI6IFwi0J/RgNC10LTQu9C+0LbQuNGC0YxcIixcblx0XCJDT01JTkdfU09PTlwiOiBcItCh0LrQvtGA0L5cIixcblx0XCJDSEFJTlwiOiBcItCR0LvQvtC60YfQtdC50L1cIixcblx0XCJDSEFJTl9URVhUXCI6IFwi0JfQtNC10YHRjCDQstGLINC80L7QttC10YLQtSDQuNC30LzQtdC90LjRgtGMINC/0LvQsNGC0YTQvtGA0LzRgyDQv9C+INGD0LzQvtC70YfQsNC90LjRjiAo0LHQu9C+0LrRh9C10LnQvSkuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLQktCw0LvRjtGC0LBcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi0JfQtNC10YHRjCDQktGLINC80L7QttC10YLQtSDQuNC30LzQtdC90LjRgtGMINCy0LDQu9GO0YLRgyDQv9C+INGD0LzQvtC70YfQsNC90LjRji4g0J3QsNCz0YDQsNC00LAg0LfQsCDQv9C+0YHRgi/QutC+0LzQvNC10L3RgtCw0YDQuNC5INCx0YPQtNC10YIg0L7RgtC+0LHRgNCw0LbQsNGC0YzRgdGPINCyINGN0YLQvtC5INCy0LDQu9GO0YLQtS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj7Qn9C10YDQtdGH0LXQvdGMINCy0L7Qt9C80L7QttC90L7RgdGC0LXQuTwvYj48YnI+LSDQn9C+0LvRg9GH0LjRgtC1INC00L7RgdGC0YPQvyDQuiDRg9C90LjQutCw0LvRjNC90YvQvCDRgdGC0LDRgtGM0Y/QvCDQvdCwINC70Y7QsdGD0Y4g0LjQvdGC0LXRgNC10YHQvdGD0Y4g0JLQsNC8INGC0LXQvNGDOzxicj4tINCS0LfQsNC40LzQvtC00LXQudGB0YLQstGD0LnRgtC1INGBINCw0LLRgtC+0YDQsNC80LgsINC60L7QvNC80LXQvdGC0LjRgNGD0Y8g0Lgg0YPRh9Cw0YHRgtCy0YPRjyDQsiDQtNC40YHQutGD0YHRgdC40Y/RhTs8YnI+LSDQk9C+0LvQvtGB0YPQudGC0LUg0LfQsCDQv9C+0YHRgtGLLCDRh9GC0L7QsdGLINCy0L7Qt9C90LDQs9GA0LDQtNC40YLRjCDQsNCy0YLQvtGA0LAsINCwINGC0LDQutC20LUg0L/QvtC70YPRh9C40YLRjCDQutGD0YDQsNGC0L7RgNGB0LrQvtC1INCy0L7Qt9C90LDQs9GA0LDQttC00LXQvdC40LU7PGJyPi0g0J/Rg9Cx0LvQuNC60YPQudGC0LUg0YHQstC+0Lgg0L/QvtGB0YLRiyDQuCDQsdC10YHQv9C70LDRgtC90L4g0YDQsNC30LzQtdGJ0LDQudGC0LUg0LjRhSwg0YfRgtC+0LHRiyDQv9GA0LjQstC70LXRh9GMINGE0L7Qu9C70L7QstC10YDQvtCyINC4INC/0L7Qu9GD0YfQuNGC0Ywg0LLQvtC30L3QsNCz0YDQsNC20LTQtdC90LjRjzs8YnI+LSDQn9C40YjQuNGC0LUg0YHRgtCw0YLRjNC4INCyINC/0YPRgtC4LCDRgdC+0YXRgNCw0L3Rj9C50YLQtSDQvdC10YHQutC+0LvRjNC60L4g0YfQtdGA0L3QvtCy0LjQutC+0LIg0L/QvtGB0YLQsCDQuCDQv9GD0LHQu9C40LrRg9C50YLQtSDQuNGFLCDQutC+0LPQtNCwINCS0LDQvCDRg9C00L7QsdC90L47PGJyPi0g0JTQvtCx0LDQstC70Y/QudGC0LUg0L/QvtC90YDQsNCy0LjQstGI0LjQtdGB0Y8g0YHRgtCw0YLRjNC4INCyINC30LDQutC70LDQtNC60LgsINGH0YLQvtCx0Ysg0LLQtdGA0L3Rg9GC0YzRgdGPINC6INC90LjQvCDQv9C+0LfQttC1Ozxicj4tINCe0LHQvNC10L3QuNCy0LDQudGC0LUg0LjQu9C4INC+0LHQvdCw0LvQuNGH0LjQstCw0LnRgtC1INCS0LDRiNC4INCy0L7Qt9C90LDQs9GA0LDQttC00LXQvdC40Y87PGJyPi0g0J/QvtGB0YvQu9Cw0LnRgtC1INGB0YDQtdC00YHRgtCy0LAg0LvRjtCx0YvQvCDQsNCy0YLQvtGA0LDQvCwg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0LwsINC00YDRg9C30YzRj9C8LCDRhNC+0LvQu9C+0LLQtdGA0LDQvCDQuCDRgi7QtC47PGJyPi0g0J/QvtC00L/QuNGB0YvQstCw0LnRgtC10YHRjCDQvdCwINC40L3RgtC10YDQtdGB0L3Ri9GFINCw0LLRgtC+0YDQvtCyINC4INCx0LvQvtCz0LPQtdGA0L7Qsjs8YnI+LSDQn9C+0LvRjNC30YPQudGC0LXRgdGMINGD0LTQvtCx0L3Ri9C8INC/0L7QuNGB0LrQvtC8INC/0L4g0YTQvtC70LvQvtCy0LXRgNCw0Lwg0LjQu9C4INCw0LLRgtC+0YDQsNC8LCDQvdCwINC60L7RgtC+0YDRi9GFINCS0Ysg0L/QvtC00L/QuNGB0LDQvdGLOzxicj4tINCf0L7Qu9GD0YfQsNC50YLQtSDRg9Cy0LXQtNC+0LzQu9C10L3QuNGPIC0g0L7RgdGC0LDQstCw0LnRgtC10YHRjCDQvdCwINGB0LLRj9C30Lgg0YEg0JLQsNGI0LjQvNC4INGE0L7Qu9C70L7QstC10YDQsNC80Lgg0Lgg0L3QsNCx0LvRjtC00LDQudGC0LUg0LfQsCDRgNCw0LfQstC40YLQuNC10Lwg0LTQuNGB0LrRg9GB0YHQuNC5LCDQsiDQutC+0YLQvtGA0YvRhSDRg9GH0LDRgdGC0LLRg9C10YLQtTs8YnI+LSDQndCw0YXQvtC00LjRgtC1INC90L7QstGL0YUg0LjQvdGC0LXRgNC10YHQvdGL0YUg0LDQstGC0L7RgNC+0LIg0Lgg0YHRgtCw0YLRjNC4LCDQuNGB0L/QvtC70YzQt9GD0Y8g0L/QvtC40YHQuiDQv9C+INGC0LXQs9Cw0Lwv0LrQsNGC0LXQs9C+0YDQuNGP0Lw7PGJyPi0g0J/QtdGA0YHQvtC90LDQu9C40LfQuNGA0YPQudGC0LUg0YHRgtGA0LDQvdC40YbRgyDRgdCy0L7QtdCz0L4g0L/RgNC+0YTQuNC70Y87PGJyPi0g0J3QtSDQv9GA0L7Qv9GD0YHQutCw0LnRgtC1INC+0LHQvdC+0LLQu9C10L3QuNGPIC0g0LIg0L3QuNGFINCS0Ysg0L3QsNC50LTQtdGC0LUg0LXRidC1INCx0L7Qu9GM0YjQtSDQvdC+0LLRi9GFINGE0YPQvdC60YbQuNC5ITxicj48YnI+PGI+0JHQtdC30L7Qv9Cw0YHQvdC+0YHRgtGMPC9iPjxicj4xLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvdC1INC40LzQtdC10YIg0LTQvtGB0YLRg9C/0LAg0LjQu9C4INC/0YDQsNCy0LAg0YDQsNGB0L/QvtGA0Y/QttCw0YLRjNGB0Y8g0YHRgNC10LTRgdGC0LLQsNC80Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPOzxicj4yLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQv9GA0LXQtNC70LDQs9Cw0LXRgiDQvNC+0LTQtdC70Ywg0LHQtdC30L7Qv9Cw0YHQvdC+0YHRgtC4INC90LAg0YHRgtC+0YDQvtC90LUg0LrQu9C40LXQvdGC0LAsINCz0LTQtSDQv9GA0LjQstCw0YLQvdGL0LUg0LrQu9GO0YfQuCDRhdGA0LDQvdGP0YLRgdGPINC70L7QutCw0LvRjNC90L4g0Lgg0L3QuNC60L7Qs9C00LAg0L3QtSDQvtGC0L/RgNCw0LLQu9GP0Y7RgtGB0Y8g0L3QuCDQvdCwINC60LDQutC40LUg0YHQtdGA0LLQtdGA0LAgLSDRgtC+0LvRjNC60L4g0JLRiyDQvtGC0LLQtdGC0YHRgtCy0LXQvdC90Ysg0LfQsCDRhdGA0LDQvdC10L3QuNC1INGB0LLQvtC40YUg0L/QsNGA0L7Qu9C10Lk7PGJyPjMuINCf0YDQuNC70L7QttC10L3QuNC1INC+0LHQu9Cw0LTQsNC10YIg0L/RgNC+0YHRgtGL0Lwg0L/RgNC40LLQu9C10LrQsNGC0LXQu9GM0L3Ri9C8INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC8INC40L3RgtC10YDRhNC10LnRgdC+0LwsINGH0YLQviDQv9C+0LTQsNGA0LjRgiDQktCw0Lwg0L/QvtC70L7QttC40YLQtdC70YzQvdGL0Lkg0L7Qv9GL0YIg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y87PGJyPjQuINCSINC/0YDQuNC70L7QttC10L3QuNC4INC/0YDQtdC00YPRgdC80L7RgtGA0LXQvSDQtNC+0L/QvtC70L3QuNGC0LXQu9GM0L3Ri9C5INGD0YDQvtCy0LXQvdGMINCx0LXQt9C+0L/QsNGB0L3QvtGB0YLQuCDQsiDQstC40LTQtSDQv9C40L0t0LrQvtC00LAuPGJyPjxicj5lU3RlZW0g0L/QvtC00LTQtdGA0LbQuNCy0LDQtdGCINC/0LvQsNGC0YTQvtGA0LzRiyBTdGVlbSDQuCBHb2xvcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcItCe0YHQvdC+0LLQsNGC0LXQu9GMINC4INCy0LXQtNGD0YnQuNC5INGA0LDQt9GA0LDQsdC+0YLRh9C40LpcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcItCU0L7QsdCw0LLQuNGC0Ywg0LDQutC60LDRg9C90YJcIixcblx0XCJQTEFURk9STVwiOiBcItCf0LvQsNGC0YTQvtGA0LzQsFwiLFxuXHRcIkVTQ1JPV1wiOiBcItCT0LDRgNCw0L3RglwiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcItCT0LDRgNCw0L3RglwiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcItCh0YDQvtC6INGA0LDRgtC40YTQuNC60LDRhtC40Lgg0YHQtNC10LvQutC4XCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCLQodGA0L7QuiDQtNC10LnRgdGC0LLQuNGPINGB0LTQtdC70LrQuFwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCLQmtC+0LzQuNGB0YHQuNGPINCz0LDRgNCw0L3RgtCwXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwi0KPRgdC70L7QstC40Y8g0YHQtNC10LvQutC4XCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcItCd0L7Rh9C90L7QuSDRgNC10LbQuNC8XCIsXG5cdFwiREFZX01PREVcIjogXCLQlNC90LXQstC90L7QuSDRgNC10LbQuNC8XCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwi0J/RgNC+0YHQvNC+0YLRgCDQv9C+0LvQvdC+0LPQviDQutC+0L3RgtC10LrRgdGC0LBcIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMINC90LUg0L3QsNC50LTQtdC9XCIsXG5cdFwiQVBQUk9WRVwiOiBcItCe0LTQvtCx0YDQuNGC0YxcIixcblx0XCJESVNQVVRFXCI6IFwi0J7RgdC/0L7RgNC40YLRjFwiLFxuXHRcIlJFTEVBU0VcIjogXCLQntGB0LLQvtCx0L7QtNC40YLRjFwiLFxuXHRcIkZST01cIjogXCLQntGCXCIsXG5cdFwiSURcIjogXCLQuNC0XCIsXG5cdFwiU1VCTUlUXCI6IFwi0J7RgtC/0YDQsNCy0LjRgtGMXCIsXG5cdFwiUkVDRUlWRVJcIjogXCLQn9C+0LvRg9GH0LDRgtC10LvRjFwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwi0JzQtdGB0YLQvtC/0L7Qu9C+0LbQtdC90LjQtVwiLFxuXHRcIldFQlNJVEVcIjogXCLQktC10LEt0YHQsNC50YJcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCLQntGC0L7QsdGA0LDQttCw0LXQvNC+0LUg0LjQvNGPXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkhlbVwiLFxuXHRcIkxPR0lOXCI6IFwiTG9nZ2EgaW5cIixcblx0XCJMT0dPVVRcIjogXCJMb2dnYSB1dFwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJGw7ZsalwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIkJva23DpHJrZW5cIixcblx0XCJUUkFOU0ZFUlwiOiBcIsOWdmVyZsO2cmluZ1wiLFxuXHRcIk1BUktFVFwiOiBcIk1hcmtuYWRcIixcblx0XCJTRVRUSU5HU1wiOiBcIkluc3TDpGxsbmluZ2FyXCIsXG5cdFwiQUJPVVRcIjogXCJPbVwiLFxuXHRcIkFCT1VUXzFcIjogXCJkw6RyIHZlbSBzb20gaGVsc3Qga2FuIGJlbMO2bmFzIGbDtnIgc2l0dCBtYXRlcmlhbCFcIixcblx0XCJBQk9VVF8yXCI6IFwiw6RyIGVuIHNvY2lhbCBtZWRpYXBsYXRmb3JtIGTDpHIgZHUgYmV0YWxhcyBmw7ZyIGF0dCBibG9nZ2EsIGtvbW1lbnRlcmEgb2NoIGt1cnJlcmEgaW5sw6RnZy5cIixcblx0XCJBQk9VVF8zXCI6IFwib2NoIMOkciBldHQgY29tbXVuaXR5LWRyaXZldCBwcm9qZWt0IGbDtnIgbW9iaWxlbiBzb20gYmFzZXJhcyBww6Ugw7ZwcGVuIGvDpGxsa29kLiBEZW4gZ2VyIGdlciBkaWcgdGlsbGfDpW5nIHPDpSBhdHQgZHUga2FuIGzDpHNhIGlubmVow6VsbCwga29tbWVudGVyYSwgcsO2c3RhLCBza2FwYSBpbmzDpGdnIG9jaCBmw7ZyYSDDtnZlciBiZWzDtm5pbmdhciwgb2NoIGRpdmVyc2UgYW5kcmEgZnVua3Rpb25lciBzb20gZ8O2cnMgbcO2amxpZ2EgYXYge3twbGF0Zm9ybW5hbWV9fSBibG9jay1rZWRqYSBvY2gge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCJBcHBlbiBoYXIgYWxkcmlnIHRpbGxnw6VuZyB0aWxsIGFudsOkbmRhcmVucyBwZW5nYXIuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIkFwcGVuIGVyYmp1ZGVyIGVuIGtsaWVudGNlbnRyZXJhZCBzw6RrZXJoZXRzbW9kZWxsLCBkdnMuIGRpbmEgcHJpdmF0YSBueWNrbGFyIHN0YW5uYXIgbG9rYWx0IG9jaCBza2lja2FzIGludGUgdGlsbCBhbmRyYSBzZXJ2cmFyLlwiLFxuXHRcIkFCT1VUXzZcIjogXCJBcHBlbiBlcmJqdWRlciBldHQgZW5rZWx0IG9jaCBhdHRyYWt0aXZ0IGFudsOkbmRlcmdyw6Ruc3NuaXR0LCB2aWxrZXQgZ2VyIGVuIGdvZCBhbnbDpG5kYXJ1cHBsZXZlbHNlLlwiLFxuXHRcIkFCT1VUXzdcIjogXCJBcHBlbiBrcsOkdmVyIGFsZHJpZyBhdHQgYW52w6RuZGFyZW4gbWF0YXIgaW4gcGVyc29ubGlnIGluZm9ybWF0aW9uLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJSw7ZzdGEgcMOlIGdvb2Qta2FybWEgc29tIHZpdHRuZVwiLFxuXHRcIkFCT1VUXzlcIjogXCJLb250YWt0L8OFdGVya29wcGxpbmdcIixcblx0XCJBQk9VVF8xMFwiOiBcIk1lcmEgaW5mb3JtYXRpb246XCIsXG5cdFwiUkVNT1ZFXCI6IFwiVGEgYm9ydFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiTWFya25hZHN2eVwiLFxuXHRcIlBSSUNFXCI6IFwiUHJpc1wiLFxuXHRcIkFNT1VOVFwiOiBcIk3DpG5nZFwiLFxuXHRcIlRPVEFMXCI6IFwiU3VtbWFcIixcblx0XCJOT09SREVSU1wiOiBcIkluZ2EgYWt0aXZhIG9yZHJhciBmw7ZyXCIsXG5cdFwiREFURVwiOiBcIkRhdHVtXCIsXG5cdFwiQlVZXCI6IFwiS8O2cFwiLFxuXHRcIlNFTExcIjogXCJTw6RsalwiLFxuXHRcIk9QRU5cIjogXCLDlnBwZW5cIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaWtcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIkbDtmxqIHRpbGxiYWthXCIsXG5cdFwiRk9MTE9XRURcIjogXCJGw7ZsamVyXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJTbHV0YSBmw7ZsamFcIixcblx0XCJGT0xMT1dJTkdcIjogXCJGw7ZsamVyXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiRsO2bGphcmVcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiU8O2ayBibGFuZCBmw7ZsamFyZVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJTw7ZrIGJsYW5kIGRlIGR1IGbDtmxqZXJcIixcblx0XCJCWVwiOiBcImF2XCIsXG5cdFwiSU5cIjogXCJpXCIsXG5cdFwiTUVOVVwiOiBcIk1lbnlcIixcblx0XCJCT09LTUFSS1wiOiBcIkJva23DpHJrXCIsXG5cdFwiUkVCTE9HXCI6IFwiw4V0ZXJibG9nZ2FcIixcblx0XCJVUFZPVEVcIjogXCJSw7ZzdGEgdXBwXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJSw7ZzdGEgbmVyXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIsOFbmdyYSByw7ZzdGEgbmVyXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLDhW5ncmEgcsO2c3RhIHVwcFwiLFxuXHRcIlJFUExZXCI6IFwiU3ZhcmFcIixcblx0XCJFRElUXCI6IFwiUmVkaWdlcmFcIixcblx0XCJQT1NUXzFcIjogXCJTdmVwIMOldCB2w6Ruc3RlciDDtnZlciBrb21tZW50YXJlciBmw7ZyIGF0dCBzZSBhbHRlcm5hdGl2XCIsXG5cdFwiUE9TVF8yXCI6IFwiRHV0dGEgcMOlIGtvbW1lbnRhcmVyIGbDtnIgYXR0IHNlIHVuZGVya29tbWVudGFyZXJcIixcblx0XCJPUFRJT05TXCI6IFwiQWx0ZXJuYXRpdlwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIsOFdGVyc3RlZW1hZGVzIGF2XCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiVG9tdCDDpG4gc8OlIGzDpG5nZS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU2FsZG9uXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwiU3RlZW0sIHV0Ynl0c2JhcmEgcG9sbGV0dGVyIHNvbSBnw6VyIGF0dCDDtnZlcmbDtnJhIG7DpHIgc29tIGhlbHN0LiBTdGVlbSBrYW4gb212YW5kbGFzIHRpbGwgU3RlZW1Qb3dlciBpIGVuIHByb2Nlc3Mgc29tIGthbGxhcyBhdHQgw7ZrYSByw7ZzdGVmZmVrdCBlbGxlciBcXFwiw6VuZ2EgdXBwXFxcIi5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJTdGVlbVBvd2VyLCBpbmZseXRhbmRlcG9sbGV0dGVyIHNvbSBnZXIgaMO2Z3JlIHLDtnN0ZWZmZWt0IGbDtnIgYXR0IGR1IHNwYXJhciBkZW0gbMOlbmdzaWt0aWd0IG9jaCByw7ZzdGFyIHDDpSBpbmzDpGdnLiBKdSBtZXIgZHUgaGFyLCBkZXN0byBtZXIga2FuIGR1IHDDpXZlcmthIGFuZHJhcyBiZWzDtm5pbmdhciBvY2ggYmVsw7ZuYXMgZsO2ciBzbWFydCByw7ZzdG5pbmcuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiUG9sbGV0dGVyIHbDpHJkYSB1bmdlZsOkciB7e3BsYXRmb3Jtc3VuaXR9fSBhdiB7e3BsYXRmb3JtbmFtZX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiVXBwc2thdHRhdCB2w6RyZGVcIixcblx0XCJQUk9GSUxFXzRcIjogXCJEZXQgdXBwc2thdHRhZGUgdsOkcmRldCDDpHIgYmFzZXJhdCBww6UgZXR0IDcgZGFnYXJzIGdlbm9tc25pdHRsaWcgdsOkcmRlIGF2IHt7cGxhdGZvcm1uYW1lfS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiVHJhbnNha3Rpb25zaGlzdG9yaWtcIixcblx0XCJQT1NUSU5HXCI6IFwiSW5sw6RnZ1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIklubMOkZ2dzbnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBza3JpdmEgaW5sw6RnZyBvY2ggcsO2c3RhLiBEZW4gYsO2ciB2YXJhIG9saWsgYWxsbcOkbm55Y2tlbG4gb2NoIGh1dnVkbnlja2Vsbi5cIixcblx0XCJPV05FUlwiOiBcIsOEZ2FyZVwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIsOEZ2Fybnlja2VsbiDDpHIgaHV2dWRueWNrZWxuIGbDtnIga29udG90IG9jaCBiZWjDtnZzIGbDtnIgYXR0IGt1bm5hIGJ5dGEgZGUgYW5kcmEgbnlja2xhcm5hLiBGw7ZyIGF0dCDDtmthIHPDpGtlcmhldGVuIGLDtnIgZGVuIFxcXCJwcml2YXRhIG55Y2tlbG5cXFwiIGVsbGVyIGzDtnNlbm9yZGV0IHRpbGwgaHV2dWRueWNrZWxuIGFudsOkbmRhcyBzw6UgbGl0ZSBzb20gbcO2amxpZ3QuXCIsXG5cdFwiQUNUSVZFXCI6IFwiUsO2cmVsc2VcIixcblx0XCJQUk9GSUxFXzdcIjogXCJBbGxtw6Rubnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBnw7ZyYSDDtnZlcmbDtnJpbmdhciBvY2ggYXR0IGzDpGdnYSBvcmRyYXIgaSBkZW4gaW50ZXJuYSBtYXJrbmFkZW4uXCIsXG5cdFwiTUVNT1wiOiBcIkFudGVja25pbmdcIixcblx0XCJQUk9GSUxFXzhcIjogXCJBbnRlY2tuaW5nc255Y2tlbG4gYW52w6RuZHMgZsO2ciBhdHQgc2thcGEgb2NoIGzDpHNhIGFudGVja25pbmdhci5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ2dcIixcblx0XCJQT1NUU1wiOiBcIklubMOkZ2dcIixcblx0XCJSRVBMSUVTXCI6IFwiU3ZhclwiLFxuXHRcIldBTExFVFwiOiBcIlBsw6VuYm9rXCIsXG5cdFwiVEFHXCI6IFwiw4RtbmVcIixcblx0XCJVU0VSXCI6IFwiQW52w6RuZGFyZVwiLFxuXHRcIkNMT1NFXCI6IFwiU3TDpG5nXCIsXG5cdFwiVE9cIjogXCJUaWxsXCIsXG5cdFwiQVNTRVRcIjogXCJUaWxsZ8OlbmdcIixcblx0XCJTRU5EXCI6IFwiU2tpY2thXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTw6RrZXJoZXRcIixcblx0XCJBVkFJTEFCTEVcIjogXCJUaWxsZ8OkbmdsaWdcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk9mZmVudGxpZyBhbnRlY2tuaW5nXCIsXG5cdFwiVE9fREVTQ1wiOiBcIkFudsOkbmRhcmUgdC5leC4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUGlua29kXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQaW5rb2RlbiBoasOkbHBlciBkaWcgYXR0IHPDpGtyYSBhcHBlbiBvY2ggZGluIGRhdGEuIE7DpHIgZGVuIGFrdGl2ZXJhcyBoYXIgZHUgbWF4IDQgZsO2cnPDtmsgYXR0IGzDpXNhIHVwcCBhcHBlbi4gT20gZHUgaGFyIGdsw7ZtdCBkZW4gZWxsZXIgbWlzc2x5Y2thcyBrb21tZXIgYXBwZW4gYXR0IHRhIGJvcnQgaW5sb2dnYWQgYW52w6RuZGFyZGF0YS4gRHUgbcOlc3RlIGTDpSBsb2dnYSBpbiBww6Ugbnl0dCBmw7ZyIGF0dCBmb3J0c8OkdHRhIGFudsOkbmRhIGFwcGVuLlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJNZWRkZWxhbmRlblwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gcsO2c3RhciB1cHAgZGl0dCBpbmzDpGdnLiBNZWRkZWxhbmRlbiB0YWxhciDDpHZlbiBvbSBkZW4gdmFsZGEgcsO2c3R2aWt0ZW4uIChvYXZzZXR0IHVwcHLDtnN0bmluZywgbmVkcsO2c3RuaW5nLCBhdi9vbXLDtnN0bmluZykuXCIsXG5cdFwiVk9URVwiOiBcIlLDtnN0YVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24ga29tbWVudGVyYXIgcMOlIGRpdHQgaW5sw6RnZyBlbGxlciBrb21tZW50YXIuIE1lZGRlbGFuZGVuIGlua2x1ZGVyYXIgw6R2ZW4gbsOkciBuw6Vnb24gcmVkaWdlcmFyIHNpbiBrb21tZW50YXIuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIktvbW1lbnRhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiRHUga29tbWVyIGbDpSBldHQgbWVkZGVsYW5kZSBuw6RyIG7DpWdvbiBmw7ZsamVyIGVsbGVyIHNsdXRhciBmw7ZsamEgZGlnLlwiLFxuXHRcIk1FTlRJT05TXCI6IFwiT21uw6RtbmFuZGVcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiRHUga29tbWVyIGbDpSBldHQgbWVkZGVsYW5kZSBuw6RyIG7DpWdvbiBuw6RtbmFyIGRpdHQgbmFtbiBpIGRlcmFzIGlubMOkZ2cva29tbWVudGFyIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLDhXRlcmJsb2dnYVwiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gw6V0ZXJibG9nZ2FyIGRpdHQgaW5sw6RnZyFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkluc3TDpGxsbmluZ2FyXCIsXG5cdFwiVk9USU5HXCI6IFwiUsO2c3RuaW5nXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJSw7ZzdG5pbmdzdmlrdCBlbGxlciBwcm9jZW50IHDDpXZlcmthciByw7ZzdG5pbmdza3JhZnRlbiBww6UgYXBwZW4gc8OlIGF0dCBkdSBrYW4gcmVnbGVyYSBodXIgbXlja2V0IGR1IHZpbGwgYmVsw7ZuYSBpbmzDpGdnLiBEZXR0YSDDpG5kcmFyIG9ja3PDpSBww6UgcsO2c3RuaW5nc3Zpa3Rlbi9wcm9jZW50ZW4gZsO2ciBuZWRyw7ZzdG5pbmdhciBvY2ggZ8OkbGxlciDDtnZlcmFsbHQgcMOlIGFwcGVuLlwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVrb21tZW5kZXJhc1wiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNwYXJhIMOkbmRyaW5nYXJcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIlLDtnN0YXJlbnMgaW5mb3JtYXRpb25cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJWw6Rsa29tbWVuIHRpbGxiYWthIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJMb2dnYSBpbiBtZWQgZGl0dCBhbnbDpG5kYXJuYW1uIG9jaCBsw7ZzZW5vcmQgZsO2ciBhdHQgZm9ydHPDpHR0YS5cIixcblx0XCJMT0dJTl8yXCI6IFwiSW5sw6RnZ3NueWNrZWxuIGFudsOkbmRzIGbDtnIgYXR0IGfDtnJhIGlubMOkZ2csIGtvbW1lbnRlcmEsIHLDtnN0LCBmw7ZsamEuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFsbG3DpG5ueWNrZWxuIGFudsOkbmRzIGbDtnIgYXR0IGfDtnJhIMO2dmVyZsO2cmluZ2FyIG9jaCBhdHQgdXBwZGF0ZXJhIHByb2ZpbGJpbGQuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkFudsOkbmRhcnVwcGdpZnRlciBsYWdyYXMgbG9rYWx0IHDDpSBlbmhldGVuLiBWaWQgdXRsb2dnbmluZyBhdmzDpGdzbmFzIHVwcGdpZnRlcm5hIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIkhhciBkdSBpbmdldCBrb250bz9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlJlZ2lzdHJlcmEgZGlnIG51XCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQXZicnl0XCIsXG5cdFwiQURWQU5DRURcIjogXCJBdmFuY2VyYXQgbMOkZ2VcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiUHJpdmF0IGFsbG3DpG5ueWNrZWxcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIlByaXZhdCBpbmzDpGdnc255Y2tlbFwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiw4RnYXJlL2h1dnVkbMO2c2Vub3JkXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJBbnbDpG5kYXJuYW1uXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiS29ydHZ5XCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiS29tcGFrdCB2eVwiLFxuXHRcIlNFQVJDSFwiOiBcIlPDtmtcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIkfDtnIgZXR0IGlubMOkZ2dcIixcblx0XCJSRVBMWVRPXCI6IFwiU3ZhcmFcIixcblx0XCJQT1NUXCI6IFwiU2tpY2thXCIsXG5cdFwiUFJFVklFV1wiOiBcIkbDtnJoYW5kc2dyYW5za2FcIixcblx0XCJERUZBVUxUXCI6IFwiTm9ybWFsIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCLDhW5nYSB1cHAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiQXZzw6RnIGRpZyBiZWzDtm5pbmdcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNQQVJBIFRJTEwgU0VOQVJFXCIsXG5cdFwiQ0xFQVJcIjogXCJUw5ZNXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiU2tyaXYgaW5sw6RnZ1wiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIktvbW1lbnRlcmEgbWF0ZXJpYWxcIixcblx0XCJUSVRMRVwiOiBcIlRpdGVsXCIsXG5cdFwiVEFHU1wiOiBcIsOEbW5lblwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk1BVENIQVIgSU5URVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiQmVrcsOkZnRhIHBpbmtvZFwiLFxuXHRcIklOQ09SUkVDVFwiOiBcIkZFTEFLVElHXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiw7ZwcG5hciBpbmzDpGdnXCIsXG5cdFwiU0VUX1BJTlwiOiBcIlN0w6RsbCBpbiBwaW5rb2RcIixcblx0XCJFTlRFUl9QSU5cIjogXCJBbmdlIHBpbmtvZFwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIsOEciBkdSBzw6RrZXI/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLDhXRlcmJsb2dnYWRlIGlubMOkZ2cga2FuIGludGUgw6VuZ3JhcywgdmlsbCBkdSBmb3J0c8OkdHRhP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIlPDpG5kbmluZ3NmZWwsIGbDtnJzw7ZrIGlnZW4hXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlV0ZsO2cnRcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIsOFdGVyYmxvZ2dhZGUgaW5sw6RnZyFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiSW5sb2dnbmluZyBtaXNzbHlja2FkZXMhIFZhciBnb2Qgc8Oka2Vyc3TDpGxsIGF0dCBkdSBsb2dnYXIgaW4gbWVkIGh1dnVkbMO2c2Vub3JkIGVsbGVyIGRpbiBwcml2YXRhIGlubMOkZ2dzbnlja2VsIG9tIGR1IHZhbHQgXFxcIkF2YW5jZXJhdCBsw6RnZVxcXCIuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiSW5sb2dnbmluZyBtaXNzbHlja2FkZXMhIFZhciBnb2Qgc8Oka2Vyc3TDpGxsIGF0dCBkdSBsb2dnYXIgaW4gbWVkIGh1dnVkbMO2c2Vub3JkIGVsbGVyIGRpbiBwcml2YXRhIHLDtnJlbHNlbnlja2VsIG9tIGR1IHZhbHQgXFxcIkF2YW5jZXJhdCBsw6RnZVxcXCIuXCIsXG5cdFwiV0FSTklOR1wiOiBcIlZhcm5pbmdcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiUsO2c3RhIHDDpSB2aXR0bmVcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlLDtnN0YWRlIHDDpSB2aXR0bmV0XCIsXG5cdFwiQUdPXCI6IFwic2VkYW5cIixcblx0XCJGUk9NX05PV1wiOiBcImZyw6VuIG9jaCBtZWQgbnVcIixcblx0XCJTRUNTXCI6IFwic2VrXCIsXG5cdFwiQV9NSU5cIjogXCJlbiBtaW51dFwiLFxuXHRcIk1JTlNcIjogXCJtaW5cIixcblx0XCJBTl9IT1VSXCI6IFwiZW4gdGltbWVcIixcblx0XCJIT1VSU1wiOiBcInRpbW1hclwiLFxuXHRcIkFfREFZXCI6IFwiZW4gZGFnXCIsXG5cdFwiREFZU1wiOiBcImRhZ2FyXCIsXG5cdFwiQV9NT05USFwiOiBcImVuIG3DpW5hZFwiLFxuXHRcIk1PTlRIU1wiOiBcIm3DpW5hZGVyXCIsXG5cdFwiQV9ZRUFSXCI6IFwiZXR0IMOlclwiLFxuXHRcIllFQVJTXCI6IFwiw6VyXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gbMOkc25pbmdcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiUsO2c3RhIE5lclwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIlRhIEZvdG9cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlbDpGxqIEJpbGRcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIlN0w6RsbCBpbiBlZ2VuIFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5mb2dhIEJpbGRcIixcblx0XCJFUlJPUlwiOiBcIkZlbFwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIlVwcGxhZGRuaW5nc2ZlbFwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJLYW1lcmEgQXZicnV0ZW5cIixcblx0XCJTRVRfVVJMXCI6IFwiU3TDpGxsIGluIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJEaXJla3Qgd2ViYmzDpG5rIGbDtnIgYmlsZFwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiS29tbWVudGFyZW4gw6RyIHNraWNrYWQhXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJCb3J0dGFnbmluZyBhdiBrb21tZW50YXJlciBnw6VyIGludGUgYXR0IMOlbmdyYS4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIlRvZyBib3J0IGtvbW1lbnRhcmVuXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJMYWRkYXIgdXBwIGJpbGRcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiVXBwbGFkZG5pbmcgU2x1dGbDtnJkXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIlVwcGxhZGRuaW5nIE1pc3NseWNrYWRlc1wiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkzDtnNlbm9yZGV0IGVsbGVyIGtvbnRvbmFtbmV0IHZhciBmZWxha3RpZ3RcIixcblx0XCJJTkZPXCI6IFwiSW5mb1wiLFxuXHRcIlFSX1RFWFRcIjogXCJQbGFjZXJhIFFSLWtvZCBpbm5hbmbDtnIgc2thbm5pbmdzb21yw6VkZXRcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJTZSB0aWxsIGF0dCBkdSBoYXIgdGlsbHLDpGNrbGlndCBzYWxkbyBmw7ZyIHRyYW5zYWt0aW9uZW4hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkFudsOkbmRhcmVuIGR1IGbDtnJzw7ZrZXIgw7Z2ZXJmw7ZyYSB0aWxsIGV4aXN0ZXJhciBpbnRlIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLDhHIgZHUgc8Oka2VyIGF0dCBkdSB2aWxsIGbDtnJhIMO2dmVyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkJla3LDpGZ0ZWxzZVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiw5Z2ZXJmw7ZyaW5nIHPDpG5kZXNcIixcblx0XCJGRUVEXCI6IFwiRmzDtmRlXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJUcmVuZGFuZGVcIixcblx0XCJIT1RcIjogXCJIZXR0XCIsXG5cdFwiTkVXXCI6IFwiTnl0dFwiLFxuXHRcIlBST01PVEVEXCI6IFwiTWFya25hZHNmw7ZydFwiLFxuXHRcIlZPVEVTXCI6IFwiUsO2c3RlclwiLFxuXHRcIlBBWU9VVFwiOiBcIlV0YmV0YWxuaW5nXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJLb21tZW50YXJlclwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVHJlbmRhbmRlIGbDtnIgMzAgZGFnYXJcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJTb3J0ZXJhIGlubMOkZ2cgZWZ0ZXJcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJVdGJldGFsbmluZ3NwZXJpb2RcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW50aWVsbCBVdGJldGFsbmluZ1wiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiVGlkaWdhcmUgVXRiZXRhbG5pbmdcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiU2tyaWJlbnRzIFV0YmV0YWxuaW5nXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiS3VyYXRvcmVycyBVdGJldGFsbmluZ1wiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiSW5sw6RnZ2V0IMOkciBwdWJsaWNlcmF0IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJJbmzDpGdnIGbDtnIgc2VuYXJlIHB1YmxpY2VyaW5nIVwiLFxuXHRcIlNBVkVEXCI6IFwiU3BhcmF0XCIsXG5cdFwiQ0xFQVJFRFwiOiBcIlTDtm10XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkF0dCByw7ZzdGEgbmVyIGV0dCBpbmzDpGdnIGthbiB0YSBib3J0IGJlbMO2bmluZyBvY2ggZ8O2cmEgaW5sw6RnZ2V0IG1pbmRyZSBzeW5saWd0Ljxicj48YnI+IE5lZHLDtnN0ZW4gYsO2ciBhbnbDpG5kYXMgZsO2ciBmw7ZsamFuZGU6IDx1bD48bGk+QmVkcsOkZ2VyIGVsbGVyIFBsYWdpYXQ8L2xpPjxsaT5IZXRzIGVsbGVyIFRyb2xsaW5nPC9saT48bGk+TWVkdmV0ZXQgZmVsa2F0ZWdvcmlzZXJhdCBpbm5laMOlbGwgZWxsZXIgU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJTbHV0IHDDpSBmbMO2ZGV0IG7DpXR0LiBLb2xsYSBpbiBhbmRyYSB0cmVuZGVyL8OkbW5lc3RhZ2dhciFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJJbmzDpGdnZXQgaGFyIHRhZ2l0cyBib3J0IGZyw6VuIGJva23DpHJrZW4hXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIklubMOkZ2dldCBoYXIgbGFndHMgdGlsbCBpIGJva23DpHJrZW4hXCIsXG5cdFwiUkVTRVRcIjogXCLDhXRlcnN0w6RsbFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpZXJhIHByb2ZpbGJpbGRcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmaWVyYSB1cHBzbGFnc2JpbGRcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJWYXIgZ29kIGFuZ2UgZGVuIHByaXZhdGEgcsO2cmVsc2VueWNrZWxuIG9tIGR1IGhhciB2YWx0IEF2YW5jZXJhdCBsw6RnZSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJEZXQgaMOkciDDpXRlcnN0w6RsbGVyIHByb2ZpbGJpbGRcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJEZXQgaMOkciDDpXRlcnN0w6RsbGVyIHVwcHNsYWdzYmlsZFwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiU2VydmVydXBwZGF0ZXJpbmcga3LDpHZlciBvbXN0YXJ0IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJJbnN0w6RsbG5pbmdhciBoYXIgdXBwZGF0ZXJhdHMhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiU3Byw6VrXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJIw6RyIGthbiBkdSB2w6RsamEgZGV0IHNwcsOlayBzb20gYXBwZW4gYW52w6RuZGVyLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJEZW4gaMOkciBvcGVyYXRpb25lbiBrcsOkdmVyIGF0dCBhbnbDpG5kYXJlbiDDpHIgaW5sb2dnYWQgbWVkIGzDtnNlbm9yZCwgYWxsbcOkbm55Y2tlbC9pbmzDpGdnc255Y2tlbC4gVmFyIGdvZCBsb2dnYSBpbiBvY2ggZsO2cnPDtmsgaWdlbi5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyaVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIkJpZHJhZ2FuZGUgw7Z2ZXJzw6R0dGFyZVwiLFxuXHRcIlNIQVJFXCI6IFwiRGVsYVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiTWFya25hZHNwbGF0c1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiQsO2cnNcIixcblx0XCJEUkFGVFNcIjogXCJVdHNraWNrXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiSW5sw6RnZyBoYXIgdGFnaXRzIGJvcnQgZnLDpW4gdXRza2ljayFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiSW5sw6RnZyBoYXIgbGFndHMgdGlsbCBpIHV0c2tpY2shXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkRyYSDDpXQgdsOkbnN0ZXIgZsO2ciBhdHQgc2UgYWx0ZXJuYXRpdlwiLFxuXHRcIk1BTkFHRVwiOiBcIkhhbnRlcmFcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiQmlsZGVuIMOkciBib3J0dGFnZW5cIixcblx0XCJDT1BZXCI6IFwiS29waWVyYVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiRHUgaGFyIGludGUgbGFkZGF0IHVwcCBuw6Vnb24gYmlsZCDDpG5udSFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIkRyYSBuZXIgZsO2ciBhdHQgdXBwZGF0ZXJhXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkV4dGVybmEgYXBwYXJcIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Z2luXCIsXG5cdFwiU1VHR0VTVFwiOiBcIkbDtnJzbGFnXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJLb21tZXIgc25hcnRcIixcblx0XCJDSEFJTlwiOiBcIktlZGphXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkjDpHIga2FuIGR1IMOkbmRyYSBibG9ja2tlZGphIGVsbGVyIGbDtnJ2YWxkIHBsYXR0Zm9ybS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlZhbHV0YVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJIw6RyIGthbiBkdSDDpG5kcmEgZGluIHN0YW5kYXJkdmFsdXRhLiBEZXQgw6RyIGRlbiB2YWx1dGEgc29tIGJlbMO2bmluZ2FyIGbDtnIgaW5sw6RnZy9rb21tZW50YXJlciBrb21tZXIgYXR0IHZpc2FzIGkuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+TGlzdGEgw7Z2ZXIgZnVua3Rpb25lcjwvYj48YnI+LSBUaWxsZ8OlbmcgdGlsbCBhcnRpa2xhciBpIMOkbW5lbiBzb20gaW50cmVzc2VyYXIgZGlnLjxicj4tIEludGVyYWdlcmEgbWVkIHNrcmliZW50ZXIgZ2Vub20gYXR0IGtvbW1lbnRlcmEsIGRpc2t1dGVyYSDDpG1uZW4uPGJyPi0gUsO2c3RhIHDDpSBpbmzDpGdnIGbDtnIgYXQgYmVsw7ZuYSBza3JpYmVudGVyIG9jaCB0asOkbmEga3VyZXJpbmdzYmVsw7ZuaW5nYXIuPGJyPi0gUHVibGljZXJhIGRpbmEgYXJ0aWtsYXIsIGJsb2dnaW5sw6RnZyBvY2ggZ8O2ciBkZW0gdGlsbGfDpG5saWdhIGbDtnIgYW5kcmEgaGVsdCBncmF0aXMsIHNhbXQgdGrDpG5hIGJlbMO2bmluZ2FyIGdlbm9tIGF0dCBlbmdhZ2VyYSBvY2ggZsOlIGbDtmxqYXJlLjxicj4tIFNrcml2IGFydGlrbGFyIHDDpSBzdMOlZW5kZSBmw6V0LCBzcGFyYSBmbGVyYSB1dGthc3QgYXYgZGluYSBpbmzDpGdnIGbDtnIgc2VuYXJlIHB1YmxpY2VyaW5nLjxicj4tIEJva23DpHJrIGZhdm9ydGlubMOkZ2cgZsO2ciBhdHQgbMOkc2Egc2VuYXJlLjxicj4tIEhhbmRsYSBtZWQgZWxsZXIgdGEgdXQgZGluYSBiZWzDtm5pbmdhci48YnI+LSBHw7ZyIHRyYW5zYWt0aW9uZXIgdGlsbCB2YWxmcmkgYW52w6RuZGFyZSwgdsOkbiwgZsO2bGphcmUsIGV0Yy48YnI+LSBGw7ZsaiBpbnRyZXNzYW50YSBza3JpYmVudGVyLCBibG9nZ2FyZS48YnI+LSBTw7ZrIGJsYW5kIGRpbmEgZsO2bGphcmUgb2NoIHNrcmliZW50ZXIgZHUgZsO2bGplci48YnI+LSBGw6UgbWVkZGVsYW5kZSBzw6UgYXR0IGR1IGthbiBow6VsbGEga29udGFrdGVuIG1lZCBkaW5hIGbDtmxqYXJlIG9jaCBoYSBrb2xsIHDDpSBkZSBkaXNrdXNzaW9uZXIgZHUgZGVsdGFyIGkuPGJyPi0gU8O2ayBlZnRlciBpbnRyZXNzYW50YSDDpG1uZW4vYXJ0aWtlbGthdGVnb3JpZXIsIHNrcmliZW50ZXIuPGJyPi0gR8O2ciBkaW4gcHJvZmlsIG1lciBwZXJzb25saWcuPGJyPi0gTcOlbmdhIGZsZXIgZnVua3Rpb25lciBww6UgdsOkZzxicj48YnI+PGI+U8Oka2VyaGV0PC9iPjxicj4xLiBBcHBlbiBoYXIgZsOlciBhbGRyaWcgdGlsbGfDpW5nIHRpbGwgZWxsZXIga29udHJvbGwgw7Z2ZXIgZGluYSBwZW5nYXIuPGJyPjIuIEFwcGVucyBzw6RrZXJoZXRzbW9kZWxsIMOkciBrbGllbnRjZW50cmVyYWQsIG1lZCBwcml2YXRhIG55Y2tsYXIgc3BhcmFkZSBsb2thbHQgb2NoIGFsZHJpZyBza2lja2FkZSB0aWxsIG7DpWdyYSBhbmRyYSBzZXJ2cmFyLCBkdSDDpHIgc2rDpGx2IGFuc3ZhcmlnIGbDtnIgYXR0IHPDpGtlcmhldHNrb3BpZXJhIGRpbmEgbMO2c2Vub3JkLjxicj4zLiBBcHBlbiBlcmJqdWRlciBldHQgZW5rZWx0LCBhdHRyYWt0aXZ0IGFudsOkbmRhcmdyw6Ruc3NuaXR0IG9jaCBhbnbDpG5kYXJ1cHBsZXZlbHNlLjxicj40LiBBcHBlbiBlcmJqdWRlciBleHRyYSBzw6RrZXJoZXQgbWVkIHBpbi1rb2Q8YnI+PGJyPmVTdGVlbSBzdMO2ZGplciBTdGVlbS0gb2NoIEdvbG9zLSBwbGF0dGZvcm1hcm5hLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiR3J1bmRhcmUgb2NoIExlYWQgRGV2ZWxvcGVyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJMw6RnZyB0aWxsIGtvbnRvXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0dGZvcm1cIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgYWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJSYXRpZmljZXJpbmdlbiB0aWRzZnJpc3RlblwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiRXNjcm93IGbDtnJmYWxsb2RhdHVtXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkVzY3JvdyBhdmdpZnRcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgdmlsbGtvclwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCLQndCwINCz0L7Qu9C+0LLQvdGDXCIsXG5cdFwiTE9HSU5cIjogXCLQo9Cy0ZbQudGC0LhcIixcblx0XCJMT0dPVVRcIjogXCLQktC40LnRgtC4XCIsXG5cdFwiUFJPRklMRVwiOiBcItCf0YDQvtGE0ZbQu9GMXCIsXG5cdFwiRk9MTE9XXCI6IFwi0J/RltC00L/QuNGB0LDRgtC40YHRj1wiLFxuXHRcIkJPT0tNQVJLU1wiOiBcItCX0LDQutC70LDQtNC60LhcIixcblx0XCJUUkFOU0ZFUlwiOiBcItCf0LXRgNC10LrQsNC3INC60L7RiNGC0ZbQslwiLFxuXHRcIk1BUktFVFwiOiBcItCg0LjQvdC+0LpcIixcblx0XCJTRVRUSU5HU1wiOiBcItCd0LDQu9Cw0YjRgtGD0LLQsNC90L3Rj1wiLFxuXHRcIkFCT1VUXCI6IFwi0IbQvdGE0L7RgNC80LDRhtGW0Y8g0L/RgNC+Li4uXCIsXG5cdFwiQUJPVVRfMVwiOiBcItC00LUg0LrQvtC20LXQvSDQt9C80L7QttC1INC+0YLRgNC40LzQsNGC0Lgg0LLQuNC90LDQs9C+0YDQvtC00YMg0LfQsCDRgdCy0ZbQuSDQutC+0L3RgtC10L3RgiFcIixcblx0XCJBQk9VVF8yXCI6IFwi0ZQg0YHQvtGG0ZbQsNC70YzQvdC40Lwg0LTQvtC00LDRgtC60L7QvCwg0LTQtSDQstC4INC+0YLRgNC40LzRg9GU0YLQtSDQvtC/0LvQsNGC0YMg0LfQsCDQv9GD0LHQu9GW0LrQsNGG0ZbRlywg0LrQvtC80LXQvdGC0LDRgNGWINGC0LAg0LrRg9GA0LDRgtC+0YDRgdGC0LLQvi5cIixcblx0XCJBQk9VVF8zXCI6IFwi0ZYg0ZQg0LzQvtCx0ZbQu9GM0L3QuNC8INC/0YDQvtC10LrRgtC+0Lwg0Lcg0LLRltC00LrRgNC40YLQuNC8INCy0LjRhdGW0LTQvdC40Lwg0LrQvtC00L7QvC4g0JLQvtC90L4g0L3QsNC00LDRlCDQtNC+0YHRgtGD0L8g0LTQviDQutC+0L3RgtC10L3RgtGDINC00LvRjyDRh9C40YLQsNC90L3Rjywg0LrQvtC80LXQvdGC0YPQstCw0L3QvdGPLCDQs9C+0LvQvtGB0YPQstCw0L3QvdGPLCDQv9C+0YHRgtC40L3Qs9GDLCDQtNCw0ZQg0LzQvtC20LvQuNCy0ZbRgdGC0Ywg0L/QtdGA0LXQtNCw0YfRliDQutC+0YjRgtGW0LIg0YLQsCDRltC90YjRliDRhNGD0L3QutGG0ZbRliwg0YnQviDQv9GA0L7Qv9C+0L3Rg9GO0YLRjNGB0Y8ge3twbGF0Zm9ybW5hbWV9fSDQsdC70L7QutGH0LXQudC90L7QvCDRgtCwIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwi0JTQvtC00LDRgtC+0Log0L3QtSDQsdGD0LTQtSDQvNCw0YLQuCDQtNC+0YHRgtGD0L/RgyDQtNC+INC60L7RiNGC0ZbQsiDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINGH0Lgg0YPRgtGA0LjQvNGD0LLQsNGC0Lgg0ZfRhS5cIixcblx0XCJBQk9VVF81XCI6IFwi0JTQvtC00LDRgtC+0Log0LzQsNGUINC60LvRltC10L3Rgi3QvtGA0ZbRlNC90YLQvtCy0LDQvdGDINC80L7QtNC10LvRjCDQsdC10LfQv9C10LrQuC4g0J/RgNC40LLQsNGC0L3RliDQutC70Y7Rh9GWINC30LHQtdGA0ZbQs9Cw0Y7RgtGM0YHRjyDQu9C+0LrQsNC70YzQvdC+INC90LAg0L/RgNC40YHRgtGA0L7RlyDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINGWINC90ZbQutC+0LvQuCDQvdC1INC90LDQtNGB0LjQu9Cw0Y7RgtGM0YHRjyDQvdCwINGW0L3RiNGWINGB0LXRgNCy0LXRgNC4LlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiDQlNC+0LTQsNGC0L7QuiDQv9GA0L7Qv9C+0L3Rg9GUINC/0YDQvtGB0YLQuNC5LCDQv9GA0LjQstCw0LHQu9C40LLQuNC5INC60L7RgNC40YHRgtGD0LLQsNGG0YzQutC40Lkg0ZbQvdGC0LXRgNGE0LXQudGBINGC0LAg0LTQvtGB0LLRltC0LlwiLFxuXHRcIkFCT1VUXzdcIjogXCLQlNC+0LTQsNGC0L7QuiDQvdGW0LrQvtC70Lgg0L3QtSDQstC40LzQsNCz0LDRlCDQstGW0LQg0LrQvtGA0LjRgdGC0YPQstCw0YfRltCyINC20L7QtNC90LjRhSDQvtGB0L7QsdC40YHRgtC40YUg0LTQsNC90LjRhS5cIixcblx0XCJBQk9VVF84XCI6IFwi0J/RgNC+0LPQvtC70L7RgdGD0LLQsNGC0Lgg0LfQsCBnb29kLWthcm1hINGP0Log0LfQsCDQtNC10LvQtdCz0LDRgtCwXCIsXG5cdFwiQUJPVVRfOVwiOiBcItCa0L7QvdGC0LDQutGCL9CX0LLQvtGA0L7RgtC90ZbQuSDQt9CyJ9GP0LfQvtC6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCLQkdGW0LvRjNGI0LUg0ZbQvdGE0L7RgNC80LDRhtGW0ZdcIixcblx0XCJSRU1PVkVcIjogXCLQktC40LTQsNC70LjRgtC4XCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLQntCz0LvRj9C0INGA0LjQvdC60YNcIixcblx0XCJQUklDRVwiOiBcItCm0ZbQvdCwXCIsXG5cdFwiQU1PVU5UXCI6IFwi0JrRltC70YzQutGW0YHRgtGMXCIsXG5cdFwiVE9UQUxcIjogXCLQl9Cw0LPQsNC70L7QvFwiLFxuXHRcIk5PT1JERVJTXCI6IFwi0J3QtdC80LDRlCDQstGW0LTQutGA0LjRgtC40YUg0L7RgNC00LXRgNGW0LIg0LTQu9GPXCIsXG5cdFwiREFURVwiOiBcItCU0LDRgtCwXCIsXG5cdFwiQlVZXCI6IFwi0JrRg9C/0LjRgtC4XCIsXG5cdFwiU0VMTFwiOiBcItCf0YDQvtC00LDRgtC4XCIsXG5cdFwiT1BFTlwiOiBcItCS0ZbQtNC60YDQuNGC0LhcIixcblx0XCJISVNUT1JZXCI6IFwi0IbRgdGC0L7RgNGW0Y9cIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcItCS0ZbQtNC/0LjRgdCw0YLQuNGB0Y9cIixcblx0XCJGT0xMT1dFRFwiOiBcItCf0ZbQtNC/0LjRgdC60Lgg0L3QsCDQktCw0YFcIixcblx0XCJVTkZPTExPV1wiOiBcItCd0LUg0YHQu9GW0LTQutGD0LLQsNGC0LhcIixcblx0XCJGT0xMT1dJTkdcIjogXCLQktCw0YjRliDQv9GW0LTQv9C40YHQutC4XCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwi0J/QvtGB0LvRltC00L7QstC90LjQutC4XCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcItCf0L7RiNGD0Log0L/QvtGB0LvRltC00L7QstC90LjQutGW0LJcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwi0J/QvtGI0YPQuiDQstGW0LTRgdGC0LXQttGD0LLQsNC90L7Qs9C+XCIsXG5cdFwiQllcIjogXCLQt9CwXCIsXG5cdFwiSU5cIjogXCLQklwiLFxuXHRcIk1FTlVcIjogXCLQnNC10L3RjlwiLFxuXHRcIkJPT0tNQVJLXCI6IFwi0JfQsNC60LvQsNC00LrQsFwiLFxuXHRcIlJFQkxPR1wiOiBcItCg0LXQv9C+0YHRglwiLFxuXHRcIlVQVk9URVwiOiBcItCT0L7Qu9C+0YEg0JfQsFwiLFxuXHRcIkRPV05WT1RFXCI6IFwi0JPQvtC70L7RgSDQn9GA0L7RgtC4XCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcItCX0L3Rj9GC0Lgg0LPQvtC70L7RgSDQn9GA0L7RgtC4XCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLQl9C90Y/RgtC4INCz0L7Qu9C+0YEg0JfQsFwiLFxuXHRcIlJFUExZXCI6IFwi0J/QvtCy0YLQvtGA0LjRgtC4XCIsXG5cdFwiRURJVFwiOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4XCIsXG5cdFwiUE9TVF8xXCI6IFwi0J/RgNC+0LLQtdC00ZbRgtGMINC/0LDQu9GM0YbQtdC8INCy0LvRltCy0L4g0L3QsCDQutC+0LzQtdC90YLQsNGA0ZYsINGJ0L7QsSDQv9C+0LHQsNGH0LjRgtC4INCy0LDRgNGW0LDQvdGC0LhcIixcblx0XCJQT1NUXzJcIjogXCLQndCw0YLQuNGB0L3RltGC0Ywg0L3QsCDQutC+0LzQtdC90YLQsNGA0ZYsINGJ0L7QsSDQv9C+0LHQsNGH0LjRgtC4INCy0LrQu9Cw0LTQtdC90ZYg0LrQvtC80LXQvdGC0LDRgNGWXCIsXG5cdFwiT1BUSU9OU1wiOiBcItCS0LDRgNGW0LDQvdGC0LhcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLQoNC10L/QvtGB0YLQvdGD0YLQvlwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcItCi0YPRgiDQvdGW0YfQvtCz0L4sINC/0L7QutC4INGJ0L4uLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcItCR0LDQu9Cw0L3RgdC4XCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwg0YLQvtGA0LPQvtCy0ZYg0LzQsNGA0LrQtdGA0LgsINGP0LrRliDQvNC+0LbRg9GC0Ywg0L/QtdGA0LXQtNCw0LLQsNGC0LjRgdGPINCyINCx0YPQtNGMLdGP0LrQuNC5INGH0LDRgS4ge3twbGF0Zm9ybW5hbWV9fSDQvNC+0LbQvdCwINC60L7QvdCy0LXRgNGC0YPQstCw0YLQuCDQsiB7e3BsYXRmb3JtcG93ZXJ9fSDQsiDQv9GA0L7RhtC10YHRliwg0YnQviDQvNCw0ZQg0L3QsNC30LLRgyBcXFwi0L/QvtGB0LjQu9C10L3QvdGPXFxcIi5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwg0LzQsNGA0LrQtdGA0Lgg0LLQv9C70LjQstGDLCDRj9C60ZYg0L3QsNC00LDRjtGC0Ywg0LHRltC70YzRiNC1INGB0LjQu9C4INC/0YDQuCDRl9GFINC00L7QstCz0L7RgdGC0YDQvtC60L7QstC+0LzRgyDQt9Cx0LXRgNC10LbQtdC90L3RliDRgtCwINCz0L7Qu9C+0YHRg9Cy0LDQvdC90ZYg0LfQsCDQv9C+0YHRgtC4LiDQp9C40Lwg0LHRltC70YzRiNC1INCS0Lgg0ZfRhSDQvNCw0ZTRgtC1LCDRgtC40Lwg0LHRltC70YzRiNC40Lkg0JLQsNGIINCy0L/Qu9C40LIg0L3QsCDQstC40L3QsNCz0L7RgNC+0LTRgyDQt9CwINC/0L7RgdGCLCDRliDQsdGW0LvRjNGI0LAg0JLQsNGI0LAg0LLQuNC90LDQs9C+0YDQvtC00LAg0LfQsCDQs9C+0LvQvtGB0YPQstCw0L3QvdGPLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcItCi0L7QutC10L3QuCDQutC+0YjRgtGD0Y7RgtGMINC/0YDQuNCx0LvQuNC30L3QviB7e3BsYXRmb3Jtc3VuaXR9fSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcItCh0LXRgNC10LTQvdGPINCy0LDRgNGC0ZbRgdGC0YxcIixcblx0XCJQUk9GSUxFXzRcIjogXCLQntGA0ZbRlNC90YLQvtCy0L3QsCDQstCw0YDRgtGW0YHRgtGMINCx0LDQt9GD0ZTRgtGM0YHRjyDQvdCwIDct0LTQtdC90L3RltC5INGB0LXRgNC10LTQvdGW0Lkg0LLQsNGA0YLQvtGB0YLRliB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCLQhtGB0YLQvtGA0ZbRjyDRgtGA0LDQvdC30LDQutGG0ZbQuVwiLFxuXHRcIlBPU1RJTkdcIjogXCLQn9GD0LHQu9GW0LrQsNGG0ZbRj1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcItCf0L7RgdGC0LjQvdCzLdC60LvRjtGHINCy0LjQutC+0YDQuNGB0YLQvtCy0YPRlNGC0YzRgdGPINC00LvRjyDQv9C+0YHRgtC40L3Qs9GDINGC0LAg0LPQvtC70L7RgdGD0LLQsNC90L3Rjy4g0JLRltC9INC/0L7QstC40L3QtdC9INCy0ZbQtNGA0ZbQt9C90Y/RgtC40YHRjyDQstGW0LQg0JDQutGC0LjQstC90L7Qs9C+INC60LvRjtGH0LAg0ZYg0LrQu9GO0YfQsCDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwLlwiLFxuXHRcIk9XTkVSXCI6IFwi0JLQu9Cw0YHQvdC40LpcIixcblx0XCJQUk9GSUxFXzZcIjogXCLQmtC70Y7RhyDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINGUINCc0LDQudGB0YLQtdGALdC60LvRjtGH0LXQvCDQtNC70Y8g0L7QsdC70ZbQutC+0LLQvtCz0L4g0LfQsNC/0LjRgdGDINGWINC90LXQvtCx0YXRltC00L3QuNC5INC00LvRjyDQt9C80ZbQvdC4INGW0L3RiNC40YUg0LrQu9GO0YfRltCyLiDQl9Cw0LrRgNC40YLQuNC5INC60LvRjtGHINCw0LHQviDQv9Cw0YDQvtC70Ywg0LTQviDQmtC70Y7Rh9CwINC60L7RgNC40YHRgtGD0LLQsNGH0LAg0L/QvtCy0LjQvdC90ZYg0LfQsdC10YDRltCz0LDRgtC40YHRjyDQv9C+INC80L7QttC70LjQstC+0YHRgtGWINC+0YTRhNC70LDQudC9LlwiLFxuXHRcIkFDVElWRVwiOiBcItCQ0LrRgtC40LLQvdGWXCIsXG5cdFwiUFJPRklMRV83XCI6IFwi0JDQutGC0LjQstC90LjQuSDQutC70Y7RhyDQstC40LrQvtGA0LjRgdGC0L7QstGD0ZTRgtGM0YHRjyDQtNC70Y8g0YLQvtCz0L4sINGJ0L7QsSDQt9C00ZbQudGB0L3RjtCy0LDRgtC4INC/0LXRgNC10LrQsNC30Lgg0YLQsCDRgNC+0LfQvNGW0YnRg9Cy0LDRgtC4INC30LDQvNC+0LLQu9C10L3QvdGPINC90LAg0LLQvdGD0YLRgNGW0YjQvdGM0L7QvNGDINGA0LjQvdC60YMuXCIsXG5cdFwiTUVNT1wiOiBcItCf0LDQvCfRj9GC0LrQsFwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcItCf0LDQvCfRj9GC0LrQsCDQutC70Y7RhyDQstC40LrQvtGA0LjRgdGC0L7QstGD0ZTRgtGM0YHRjyDQtNC70Y8g0YHRgtCy0L7RgNC10L3QvdGPINGWINGH0LjRgtCw0L3QvdGPINC/0LDQvCfRj9GC0L7Qui5cIixcblx0XCJCTE9HXCI6IFwi0JHQu9C+0LNcIixcblx0XCJQT1NUU1wiOiBcItCf0L7RgdGC0LhcIixcblx0XCJSRVBMSUVTXCI6IFwi0JLRltC00L/QvtCy0ZbQtNGWXCIsXG5cdFwiV0FMTEVUXCI6IFwi0JPQsNC80LDQvdC10YbRjFwiLFxuXHRcIlRBR1wiOiBcItCi0LXQs1wiLFxuXHRcIlVTRVJcIjogXCLQmtC+0YDQuNGB0YLRg9Cy0LDRh1wiLFxuXHRcIkNMT1NFXCI6IFwi0JfQsNC60YDQuNGC0LhcIixcblx0XCJUT1wiOiBcItCa0L7QvNGDXCIsXG5cdFwiQVNTRVRcIjogXCLQkNC60YLQuNCyXCIsXG5cdFwiU0VORFwiOiBcItCS0ZbQtNC/0YDQsNCy0LjRgtC4XCIsXG5cdFwiU0VDVVJJVFlcIjogXCLQkdC10LfQv9C10LrQsFwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcItCU0L7RgdGC0YPQv9C90L5cIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcItCX0LDQs9Cw0LvRjNC90L7QtNC+0YHRgtGD0L/QvdCwINC/0LDQvCfRj9GC0LrQsFwiLFxuXHRcIlRPX0RFU0NcIjogXCLQmtC+0YDQuNGB0YLRg9Cy0LDRhywg0L3QsNC/0YDQuNC60LvQsNC0IGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBJTi3QutC+0LRcIixcblx0XCJQSU5fVEVYVFwiOiBcIlBJTi3QutC+0LQg0LTQvtC/0L7QvNCw0LPQsNGUINCy0LDQvCDQt9Cw0YXQuNGB0YLQuNGC0Lgg0LTQvtC00LDRgtC+0Log0ZYg0LLQsNGI0ZYg0LTQsNC90ZYuIDxici8+IDxici8+IDxiPtCf0YDQuNC80ZbRgtC60LA6PC9iPiDQn9GW0YHQu9GPINCy0LrQu9GO0YfQtdC90L3RjyDRgyDQktCw0YEg0ZQg0LzQsNC60YHQuNC80YPQvCA0INGB0L/RgNC+0LHQuCwg0YnQvtCxINGA0L7Qt9Cx0LvQvtC60YPQstCw0YLQuC4g0K/QutGJ0L4g0LLQuCDQt9Cw0LHRg9C70Lgg0J/QhtCdLdC60L7QtCDQsNCx0L4g0L/QvtC80LjQu9C40LvQuNGB0Y8g0L/RgNC4INCy0LLQtdC00LXQvdC90ZYg0LTQsNC90LjRhSwg0LTQvtC00LDRgtC+0Log0LLQuNC00LDQu9C40YLRjCDQtNCw0L3RliDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwLCDRidC+INC30LDQudGI0L7QsiDRgyDRgdC40YHRgtC10LzRgy4g0JLQuCDQvNC+0LbQtdGC0LUg0LDQstGC0L7RgNC40LfRg9Cy0LDRgtC40YHRjyDQv9C+0LLRgtC+0YDQvdC+INGWINC/0YDQvtC00L7QstC20LjRgtC4INC60L7RgNC40YHRgtGD0LLQsNC90L3RjyDQtNC+0LTQsNGC0LrQvtC8LlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLQn9C+0LLRltC00L7QvNC70LXQvdC90Y9cIixcblx0XCJWT1RFX1RFWFRcIjogXCLQktC4INC+0YLRgNC40LzQsNGU0YLQtSDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8sINC60L7Qu9C4INGF0YLQvtGB0Ywg0LPQvtC70L7RgdGD0ZQg0LfQsCDQktCw0Ygg0LrQvtC90YLQtdC90YIhIDxici8+IDxiPtCf0YDQuNC80ZbRgtC60LA6PC9iPiDQn9C+0LLRltC00L7QvNC70LXQvdC90Y8g0LLQutC70Y7Rh9Cw0Y7RgtGMINCy0LDQs9GDINCz0L7Qu9C+0YHRgyDQsCDRgtCw0LrQvtC2INGDINC/0L7Qv9C10YDQtdC00LbQtdC90L3RjyAo0LHRg9C00Ywg0YLQviDQs9C+0LvQvtGB0YPQstCw0L3QvdGPINCX0LAsINCz0L7Qu9C+0YHRg9Cy0LDQvdC90Y8g0J/RgNC+0YLQuCwg0JfQvdGP0YLRgtGPINCz0L7Qu9C+0YHRgykuXCIsXG5cdFwiVk9URVwiOiBcItCT0L7Qu9C+0YHRg9Cy0LDRgtC4XCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi0JLQuCDQvtGC0YDQuNC80LDRlNGC0LUg0L/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPLCDQutC+0LvQuCDRhdGC0L7RgdGMINC/0YDQvtC60L7QvNC10L3RgtGD0ZQg0JLQsNGI0ZYg0L/Rg9Cx0LvRltC60LDRhtGW0Zcg0YfQuCDQutC+0LzQtdC90YLQsNGA0ZYhIDxici8+IDxiPtCf0YDQuNC80ZbRgtC60LA6PC9iPiDQn9C+0LLRltC00L7QvNC70LXQvdC90Y8g0YLQsNC60L7QtiDQv9GA0LjQudC00LUg0YMg0LLQuNC/0LDQtNC60YMsINC60L7Qu9C4INGF0YLQvtGB0YwgPGI+0LLRltC00YDQtdC00LDQs9GD0ZQ8L2I+INGB0LLQvtGXINCy0LvQsNGB0L3RliDQutC+0LzQtdC90YLQsNGA0ZYuXCIsXG5cdFwiQ09NTUVOVFwiOiBcItCa0L7QvNC10L3RgtCw0YBcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcItCS0Lgg0L7RgtGA0LjQvNCw0ZTRgtC1INC/0L7QstGW0LTQvtC80LvQtdC90L3Rjywg0LrQvtC70Lgg0YXRgtC+0YHRjCDQv9GW0LTQv9C40YjQtdGC0YzRgdGPINC90LAg0JLQsNGI0ZYg0L/Rg9Cx0LvRltC60LDRhtGW0Zcg0LDQsdC+INCy0ZbQtNC/0LjRiNC10YLRjNGB0Y8g0LLRltC0INC90LjRhSFcIixcblx0XCJNRU5USU9OU1wiOiBcItCX0LPQsNC00YPQstCw0L3QvdGPXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcItCS0Lgg0L7RgtGA0LjQvNCw0ZTRgtC1INC/0L7QstGW0LTQvtC80LvQtdC90L3Rjywg0LrQvtC70Lgg0YXRgtC+0YHRjCDQt9Cz0LDQtNCw0ZQg0JLQsNGBINGDINGB0LLQvtGX0Lkg0L/Rg9Cx0LvRltC60LDRhtGW0Zcv0LrQvtC80LXQvdGC0LDRgNGWIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLQoNC10L/QvtGB0YJcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLQktC4INC+0YLRgNC40LzQsNGU0YLQtSDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8sINC60L7Qu9C4INGF0YLQvtGB0Ywg0LfRgNC+0LHQuNGC0Ywg0YDQtdC/0L7RgdGCINCy0LDRiNC+0Zcg0L/Rg9Cx0LvRltC60LDRhtGW0ZchXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCLQmtC+0L3RhNGW0LPRg9GA0LDRhtGW0ZdcIixcblx0XCJWT1RJTkdcIjogXCLQk9C+0LvQvtGB0YPQstCw0L3QvdGPXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLQktCw0LPQsCDQs9C+0LvQvtGB0YMg0YMg0LLRltC00YHQvtGC0LrQsNGFINCy0L/Qu9C40LLQsNGUINC90LAg0LLQsNCz0YMg0LPQvtC70L7RgdGDINCyINC00L7QtNCw0YLQutGDLCDRgtCw0LrQuNC8INGH0LjQvdC+0Lwg0LLQuCDQvNC+0LbQtdGC0LUg0YDQtdCz0YPQu9GO0LLQsNGC0Lgg0LLQuNC90LDQs9C+0YDQvtC00YMg0L/RgNC4INCz0L7Qu9C+0YHRg9Cy0LDQvdC90ZYuIDxici8+IDxici8+IDxiPtCf0YDQuNC80ZbRgtC60LA6PC9iPiDQptC1INGC0LDQutC+0LYg0LfQvNGW0L3QuNGC0Ywg0LLQsNCz0YMg0LPQvtC70L7RgdGDL9Cy0ZbQtNGB0L7RgtC+0Log0L/RgNC4INCz0L7Qu9C+0YHRg9Cy0LDQvdC90ZYg0J/RgNC+0YLQuCwg0ZYg0YHQutGA0ZbQt9GMINGDINC00L7QtNCw0YLQutGDXCIsXG5cdFwiU0VSVkVSXCI6IFwi0KHQtdGA0LLQtdGAXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLQoNC10LrQvtC80LXQvdC00L7QstCw0L3QvlwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItCX0LHQtdGA0LXQs9GC0Lgg0LfQvNGW0L3QuFwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwi0IbQvdGE0L7RgNC80LDRhtGW0Y8g0L/RgNC+INGC0LjRhSwg0YXRgtC+INCz0L7Qu9C+0YHRg9Cy0LDQslwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcItCXINC/0L7QstC10YDQvdC10L3QvdGP0LwhXCIsXG5cdFwiTE9HSU5fMVwiOiBcItCp0L7QsSDQv9GA0L7QtNC+0LLQttC40YLQuCwg0YPQstGW0LnQtNGW0YLRjCDQt9CwINC00L7Qv9C+0LzQvtCz0L7RjiDQktCw0YjQvtCz0L4g0IbQvNC10L3RliDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINGC0LAg0L/QsNGA0L7Qu9GOLlwiLFxuXHRcIkxPR0lOXzJcIjogXCLQn9C+0YHRgtC40L3Qsy3QutC70Y7RhyDQutC70Y7RhyDQstC40LrQvtGA0LjRgdGC0L7QstGD0ZTRgtGM0YHRjyDQtNC70Y8g0YDQvtC30LzRltGJ0LXQvdC90Y8g0L/QvtGB0YLRltCyLCDQutC+0LzQtdC90YLQsNGA0ZbQsiwg0LPQvtC70L7RgdGD0LLQsNC90L3Rjywg0L/RltC00L/QuNGB0L7Qui5cIixcblx0XCJMT0dJTl8zXCI6IFwi0JDQutGC0LjQstC90LjQuSDQutC70Y7RhyDQstC40LrQvtGA0LjRgdGC0L7QstGD0ZTRgtGM0YHRjyDQtNC70Y8g0L/QtdGA0LXQutCw0LfRltCyINGC0LAg0L7QvdC+0LLQu9C10L3QvdGPINC30L7QsdGA0LDQttC10L3QvdGPINC/0YDQvtGE0ZbQu9GOLlwiLFxuXHRcIkxPR0lOXzRcIjogXCLQntCx0LvRltC60L7QstGWINC00LDQvdGWINC60L7RgNC40YHRgtGD0LLQsNGH0LAg0LfQsdC10YDRltCz0LDRjtGC0YzRgdGPINC70L7QutCw0LvRjNC90L4g0L3QsCDQv9GA0LjRgdGC0YDQvtGXLiDQn9GA0Lgg0LLQuNGF0L7QtNGWINC+0LHQu9GW0LrQvtCy0ZYg0LTQsNC90ZYg0LHRg9C00YPRgtGMINCy0LjQtNCw0LvQtdC90ZYhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi0KnQtSDQvdC1INC30LDRgNC10ZTRgdGC0YDQvtCy0LDQvdGWP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwi0JfQsNGA0LXRlNGB0YLRgNGD0LLQsNGC0LjRgdGPINC30LDRgNCw0LdcIixcblx0XCJDQU5DRUxcIjogXCLQktGW0LTQvNGW0L3QsFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi0KDQvtC30YjQuNGA0LXQvdC40LlcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwi0JDQutGC0LjQstC90LjQuSDQt9Cw0LrRgNC40YLQuNC5INC60LvRjtGHXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCLQn9C+0YHRgtC40L3Qsy3QutC70Y7Rh1wiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwi0JzQsNC50YHRgtC10YAv0L7RgdC90L7QstC90LjQuSDQv9Cw0YDQvtC70YxcIixcblx0XCJVU0VSTkFNRVwiOiBcItCG0Lwn0Y8g0LrQvtGA0LjRgdGC0YPQstCw0YfQsFwiLFxuXHRcIkNBUkRfVklFV1wiOiBcItCjINCy0LjQs9C70Y/QtNGWINC60LDRgNGC0L7QulwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcItCa0L7QvNC/0LDQutGC0L3QuNC5INCy0LjQs9C70Y/QtFwiLFxuXHRcIlNFQVJDSFwiOiBcItCf0L7RiNGD0LpcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcItCf0YPQsdC70ZbQutCw0YbRltGPINGB0YLQsNGC0YLRllwiLFxuXHRcIlJFUExZVE9cIjogXCLQktGW0LTQv9C+0LLRltGB0YLQuFwiLFxuXHRcIlBPU1RcIjogXCLQn9C+0YHRglwiLFxuXHRcIlBSRVZJRVdcIjogXCLQn9C10YDQtdCz0LvRj9C0XCIsXG5cdFwiREVGQVVMVFwiOiBcItCX0LAg0LfQsNC80L7QstGH0YPQstCw0L3QvdGP0LwgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcItCX0LHRltC70YzRiNC40YLQuCDRgdC40LvRgyDQtNC+IDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcItCS0ZbQtNC80L7QstC40YLQuNGB0Y8g0LLRltC0INCy0LjQv9C70LDRgtC4XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCLQl9CR0JXQoNCV0JPQotCYINCd0JAg0JzQkNCZ0JHQo9Ci0J3QhFwiLFxuXHRcIkNMRUFSXCI6IFwi0J7Rh9C40YHRgtC40YLQuFwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcItCS0LzRltGB0YIg0L/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi0JLQvNGW0YHRgiDQutC+0LzQtdC90YLQsNGA0Y5cIixcblx0XCJUSVRMRVwiOiBcItCX0LDQs9C+0LvQvtCy0L7QulwiLFxuXHRcIlRBR1NcIjogXCLQotC10LPQuFwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcItCd0JUg0KHQn9CG0JLQn9CQ0JTQkNCEXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCLQn9GW0LTRgtCy0LXRgNC00ZbRgtGMIFBJTi3QutC+0LRcIixcblx0XCJJTkNPUlJFQ1RcIjogXCLQndCVINCS0IbQoNCd0J5cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLQstGW0LTQutGA0LjRgtGC0Y8g0L/QvtGB0YLQsFwiLFxuXHRcIlNFVF9QSU5cIjogXCLQktGB0YLQsNC90L7QstC40YLQuCBQSU4t0LrQvtC0XCIsXG5cdFwiRU5URVJfUElOXCI6IFwi0JLQstC10LTRltGC0YwgUElOLdC60L7QtFwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcItCS0Lgg0LLQv9C10LLQvdC10L3Rlj9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcItCg0LXQv9C+0YHRgiDRlCDQvdC10LfQstC+0YDQvtGC0L3RltC8LCDQstC4INCx0LDQttCw0ZTRgtC1INC/0YDQvtC00L7QstC20LjRgtC4P1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcItCf0L7QvNC40LvQutCwINGC0YDQsNC90YHQu9GP0YbRltGXLCDRgdC/0YDQvtCx0YPQudGC0LUg0YnQtSDRgNCw0LchXCIsXG5cdFwiU1VDQ0VTU1wiOiBcItCj0YHQv9GW0YVcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcItCg0LXQsdC70L7QsyDQv9C+0YHRgtCwIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLQo9Cy0ZbQudGC0Lgg0L3QtSDQstC00LDQu9C+0YHRjyEg0JHRg9C00Ywg0LvQsNGB0LrQsCwg0L/QtdGA0LXQutC+0L3QsNC50YLQtdGB0Y8sINGJ0L4g0LDQstGC0L7RgNC40LfRg9GU0YLQtdGB0Ywg0LfQsCDQtNC+0L/QvtC80L7Qs9C+0Y4g0LzQsNC50YHRgtC10YAt0L/QsNGA0L7Qu9GOINCw0LHQviDQstC60LDQt9Cw0LvQuCDQt9Cw0LrRgNC40YLQuNC5INCf0L7RgdGC0LjQvdCzLdC60LvRjtGHINC/0YDQuCDQstGF0L7QtNGWINC00L4g0YHQuNGB0YLQtdC80Lgg0YMg0YDQvtC30YjQuNGA0LXQvdC+0LzRgyDRgNC10LbQuNC80ZYuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwi0KPQstGW0LnRgtC4INC90LUg0LLQtNCw0LvQvtGB0Y8hINCR0YPQtNGMINC70LDRgdC60LAsINC/0LXRgNC10LrQvtC90LDQudGC0LXRgdGPLCDRidC+INCw0LLRgtC+0YDQuNC30YPRlNGC0LXRgdGMINC30LAg0LTQvtC/0L7QvNC+0LPQvtGOINC80LDQudGB0YLQtdGALdC/0LDRgNC+0LvRjiDQsNCx0L4g0LLQutCw0LfQsNC70Lgg0JDQutGC0LjQstC90LjQuSDQv9C10YDRgdC+0L3QsNC70YzQvdC40Lkg0LrQu9GO0Ycg0L/RgNC4INCy0YXQvtC00ZYg0LTQviDRgdC40YHRgtC10LzQuCDRgyDRgNC+0LfRiNC40YDQtdC90L7QvNGDINGA0LXQttC40LzRli5cIixcblx0XCJXQVJOSU5HXCI6IFwi0J/QvtC/0LXRgNC10LTQttC10L3QvdGPXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcItCT0L7Qu9C+0YHRg9Cy0LDQvdC90Y8g0LfQsCDRgdCy0ZbQtNC60LBcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcItCf0YDQvtCz0L7Qu9C+0YHRg9Cy0LDQu9C4INC30LAg0YHQstGW0LTQutCwXCIsXG5cdFwiQUdPXCI6IFwi0YLQvtC80YNcIixcblx0XCJGUk9NX05PV1wiOiBcItC3INGG0YzQvtCz0L4g0LzQvtC80LXQvdGC0YNcIixcblx0XCJTRUNTXCI6IFwi0YHQtdC6XCIsXG5cdFwiQV9NSU5cIjogXCLQvNGW0L1cIixcblx0XCJNSU5TXCI6IFwi0YXQsi5cIixcblx0XCJBTl9IT1VSXCI6IFwi0LPQvtC0LlwiLFxuXHRcIkhPVVJTXCI6IFwi0LPQvtC0LlwiLFxuXHRcIkFfREFZXCI6IFwi0LTQtdC90YxcIixcblx0XCJEQVlTXCI6IFwi0LTQvdGWKNGW0LIpXCIsXG5cdFwiQV9NT05USFwiOiBcItC80ZbRgdGP0YbRjFwiLFxuXHRcIk1PTlRIU1wiOiBcItC80ZbRgdGP0YbRlijRltCyKVwiLFxuXHRcIkFfWUVBUlwiOiBcItGA0ZbQulwiLFxuXHRcIllFQVJTXCI6IFwi0YDQvtC60LhcIixcblx0XCJNSU5fUkVBRFwiOiBcItGF0LIuINGH0LjRgtCw0L3QvdGPXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcItCT0L7Qu9C+0YEg0J/RgNC+0YLQuCDQsNCx0L4g0L/RgNCw0L/QvtGAXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi0JfQsNGF0L7Qv9C40YLQuCDQt9C+0LHRgNCw0LbQtdC90L3Rj1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwi0JLQuNCx0LXRgNGW0YLRjCDQt9C+0LHRgNCw0LbQtdC90L3Rj1wiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwi0JLRgdGC0LDQvdC+0LLQuNGC0LggVVJMINC60L7RgNC40YHRgtGD0LLQsNGH0LBcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcItCS0YHRgtCw0LLQuNGC0Lgg0LfQvtCx0YDQsNC20LXQvdC90Y9cIixcblx0XCJFUlJPUlwiOiBcItCf0L7QvNC40LvQutCwXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi0J/QvtC80LjQu9C60LAg0L/RgNC4INC30LDQstCw0L3RgtCw0LbQtdC90L3RllwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCLQmtCw0LzQtdGA0LAg0L3QtdC00L7RgdGC0YPQv9C90LBcIixcblx0XCJTRVRfVVJMXCI6IFwi0JLRgdGC0LDQstC40YLQuCBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi0J/RgNGP0LzQtSDQv9C+0YHQuNC70LDQvdC90Y8g0L3QsCDQt9C+0LHRgNCw0LbQtdC90L3Rj1wiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwi0JrQvtC80LXQvdGC0LDRgCDQv9GA0LjQudC90Y/RgtC+IVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi0JLQuNC00LDQu9C10L3QvdGPINC60L7QvNC10L3RgtCw0YDRltCyINGUINC90LXQt9Cy0L7RgNC+0YLQvdGW0LwuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCLQktC40LTQsNC70LXQvdGWINC60L7QvNC10L3RgtCw0YDRllwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi0JfQsNCy0LDQvdGC0LDQttC10L3QvdGPINC80LDQu9GO0L3QutCwXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcItCX0LDQstCw0L3RgtCw0LbQtdC90L3RjyDQt9Cw0LLQtdGA0YjQtdC90L5cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwi0J3QtSDQstC00LDQu9C+0YHRjyDQt9Cw0LLQsNC90YLQsNC20LjRgtC4XCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwi0J3QtdCy0ZbRgNC90LjQuSDQv9Cw0YDQvtC70Ywg0LDQsdC+INGW0Lwn0Y8g0LrQvtGA0LjRgdGC0YPQstCw0YfQsFwiLFxuXHRcIklORk9cIjogXCLQhtC90YTQvtGA0LzQsNGG0ZbRj1wiLFxuXHRcIlFSX1RFWFRcIjogXCLQoNC+0LfQvNGW0YHRgtC40YLQuCBRUi3QutC+0LQg0LLRgdC10YDQtdC00LjQvdGWINC+0LHQu9Cw0YHRgtGWINGB0LrQsNC90YPQstCw0L3QvdGPXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi0J/QtdGA0LXQutC+0L3QsNC50YLQtdGB0Y8sINGJ0L4g0YMg0LLQsNGBINC00L7RgdGC0LDRgtC90YzQviDQutC+0YjRgtGW0LIg0LTQu9GPINGC0YDQsNC90LfQsNC60YbRltGXIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLQmtC+0YDQuNGB0YLRg9Cy0LDRh9CwLCDRj9C60L7QvNGDINCy0Lgg0L3QsNC80LDQs9Cw0ZTRgtC10YHRjyDQv9C10YDQtdC60LDQt9Cw0YLQuCDQutC+0YjRgtC4LCDQvdC1INGW0YHQvdGD0ZQhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcItCS0Lgg0YHQv9GA0LDQstC00ZYg0LHQsNC20LDRlNGC0LUg0LfQtNGW0LnRgdC90LjRgtC4INC/0LXRgNC10LrQsNC3P1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcItCf0ZbQtNGC0LLQtdGA0LTQttC10L3QvdGPXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLQotGA0LDQvdC30LDQutGG0ZbRjyDQv9C10YDQtdC00LDQvdCwXCIsXG5cdFwiRkVFRFwiOiBcItCh0YLRgNGW0YfQutCwXCIsXG5cdFwiVFJFTkRJTkdcIjogXCLQn9C+0L/Rg9C70Y/RgNC90LVcIixcblx0XCJIT1RcIjogXCLQkNC60YLRg9Cw0LvRjNC90LVcIixcblx0XCJORVdcIjogXCLQndC+0LLQtVwiLFxuXHRcIlBST01PVEVEXCI6IFwi0J/RltC00YLRgNC40LzQsNC90LVcIixcblx0XCJWT1RFU1wiOiBcItCT0L7Qu9C+0YHQuFwiLFxuXHRcIlBBWU9VVFwiOiBcItCS0LjQv9C70LDRgtCwXCIsXG5cdFwiQ09NTUVOVFNcIjogXCLQmtC+0LzQtdC90YLQsNGA0ZZcIixcblx0XCJUUkVORElOR18zMFwiOiBcItCf0L7Qv9GD0LvRj9GA0L3QtSDQt9CwIDMwINC00L3RltCyXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi0KHQvtGA0YLRg9Cy0LDRgtC4INC/0L7QstGW0LTQvtC80LvQtdC90L3RjzpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLQn9C10YDRltC+0LQg0LLQuNC/0LvQsNGC0LhcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi0J/QvtGC0LXQvdGG0ZbQudC90LAg0LLQuNC/0LvQsNGC0LBcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcItCc0LjQvdGD0LvRliDQstC40L/Qu9Cw0YLQuFwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLQkNCy0YLQvtGA0YHRjNC60LAg0LLQuNC90LDQs9C+0YDQvtC00LBcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLQmtGD0YDQsNGC0L7RgNGB0YzQutCwINCy0LjQvdCw0LPQvtGA0L7QtNCwXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLQmtC+0LzQtdC90YLQsNGAINC+0L/Rg9Cx0LvRltC60L7QstCw0L3QuNC5IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLQn9C+0YHRgiDQtNC70Y8g0L/QvtC00LDQu9GM0YjQvtGXINC/0YPQsdC70ZbQutCw0YbRltGXIVwiLFxuXHRcIlNBVkVEXCI6IFwi0JfQsdC10YDQtdC20LXQvdC+XCIsXG5cdFwiQ0xFQVJFRFwiOiBcItCe0YfQuNGJ0LXQvdC+XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcItCf0L7Qt9C90LDRh9C10L3QvdGPINC/0L7QstGW0LTQvtC80LvQtdC90L3RjyDQv9GA0LDQv9C+0YDQvtC8INC80L7QttC1INCy0ZbQtNC80ZbQvdC40YLQuCDQstC40L3QsNCz0L7RgNC+0LTRgyDRgtCwINC30YDQvtCx0LjRgtC4INGG0LXQuSDQvNCw0YLQtdGA0ZbQsNC7INC80LXQvdGIINC/0L7QvNGW0YLQvdC40LzQuC4gPGJyPjxicj7Qn9GA0LDQv9C+0YAg0YHQu9GW0LQg0LLQuNC60L7RgNC40YHRgtC+0LLRg9Cy0LDRgtC4INC00LvRjyDQvdCw0YHRgtGD0L/QvdC40YUg0LLQuNC/0LDQtNC60ZbQsjogPHVsPjxsaT7QqNCw0YXRgNCw0LnRgdGC0LLQviDQsNCx0L4g0J/Qu9Cw0LPRltCw0YI8L2xpPiA8bGk+0JvQsNC50LrQsCDQsNCx0L4g0IbQvdGC0LXRgNC90LXRgiDQotGA0L7Qu9GW0L3QszwvbGk+IDxsaT7Qo9C80LjRgdC90LUg0YDQvtC30LzRltGJ0LXQvdC90Y8g0L3QtSDQsiDRgtGDINC60LDRgtC10LPQvtGA0ZbRjiDQsNCx0L4g0KHQv9Cw0Lw8L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi0J/QtdGA0LXQstC40YnQtdC90L4g0LvRltC80ZbRgiDQt9Cw0L/QuNGC0ZbQsi4g0J/QtdGA0LXQstGW0YDRgtC1INGW0L3RiNGWINGC0YDQtdC90LTQuC/RgtC10LPQuCFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLQn9C+0LLRltC00L7QvNC70LXQvdC90Y8g0LLQuNC00LDQu9C10L3QviDRltC3INC30LDQutC70LDQtNC+0LohXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcItCf0L7QstGW0LTQvtC80LvQtdC90L3RjyDQtNC+0LTQsNC90L4g0LIg0LfQsNC60LvQsNC00LrQuCFcIixcblx0XCJSRVNFVFwiOiBcItCh0LrQuNC90YPRgtC4XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLQl9C80ZbQvdC40YLQuCDQt9C+0LHRgNCw0LbQtdC90L3RjyDQv9GA0L7RhNGW0LvRjlwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwi0JfQvNGW0L3QuNGC0Lgg0LzQsNC70Y7QvdC+0Log0L7QsdC60LvQsNC00LjQvdC60LhcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCLQkdGD0LTRjCDQu9Cw0YHQutCwLCDQvdCw0LTQsNC50YLQtSDQsNC60YLQuNCy0L3QuNGFINC30LDQutGA0LjRgtC40Lkg0LrQu9GO0YcsINGP0LrRidC+INCy0Lgg0L7QsdGA0LDQu9C4INGA0L7Qt9Cz0L7RgNC90YPRgtC40Lkg0YDQtdC20LjQvCDQsNCy0YLQvtGA0LjQt9Cw0YbRltGXIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcItCm0LUg0L/RgNC40LfQstC10LTQtSDQtNC+INGB0LrQuNC00LDQvdC90Y8g0LfQvtCx0YDQsNC20LXQvdC90Y8g0L/RgNC+0YTRltC70Y4g0LrQvtGA0LjRgdGC0YPQstCw0YfQsFwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcItCm0LUg0L/RgNC40LfQstC10LTQtSDQtNC+INGB0LrQuNC00LDQvdC90Y8g0LfQvtCx0YDQsNC20LXQvdC90Y8g0L7QsdC60LvQsNC00LjQvdC60Lgg0LrQvtGA0LjRgdGC0YPQstCw0YfQsFwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwi0J7QvdC+0LLQu9C10L3QvdGPINGB0LXRgNCy0LXRgNGDINC/0L7RgtGA0LXQsdGD0ZQg0L/QtdGA0LXQt9Cw0L/Rg9GB0LrRgyFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi0J3QsNC70LDRiNGC0YPQstCw0L3QvdGPINC+0L3QvtCy0LvQtdC90L4hXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi0JzQvtCy0LhcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcItCi0YPRgiDQstC4INC80L7QttC10YLQtSDQt9C80ZbQvdC40YLQuCDQvNC+0LLRgyDQtNC+0LTQsNGC0LrRgy5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwi0KbRjyDQvtC/0LXRgNCw0YbRltGPINC/0L7RgtGA0LXQsdGD0ZQg0LDQstGC0L7RgNC40LfQsNGG0ZbRlyDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINC30LAg0LTQvtC/0L7QvNC+0LPQvtGOINC+0YHQvdC+0LLQvdC+0LPQviDQv9Cw0YDQvtC70Y4sINCw0LrRgtC40LLQvdC+0LPQvi/Qv9C+0YHRgtC40L3QsyDQutC70Y7Rh9CwLiDQkdGD0LTRjCDQu9Cw0YHQutCwLCDQsNCy0YLQvtGA0LjQt9GD0LnRgtC10YHRjCDRgtCwINC/0L7QstGC0L7RgNGW0YLRjCDRgdC/0YDQvtCx0YMg0YnQtSDRgNCw0LcuXCIsXG5cdFwiR0FMTEVSWVwiOiBcItCT0LDQu9C10YDQtdGPXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi0JDQstGC0L7RgNC4INC/0LXRgNC10LrQu9Cw0LTRg1wiLFxuXHRcIlNIQVJFXCI6IFwi0J/QvtC00ZbQu9C40YLQuNGB0Y9cIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcItCg0LjQvdC+0LpcIixcblx0XCJFWENIQU5HRVwiOiBcItCe0LHQvNGW0L1cIixcblx0XCJEUkFGVFNcIjogXCLQp9C10YDQvdC10YLQutC4XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPINCy0LjQtNCw0LvQtdC90L4g0ZbQtyDRh9C10YDQvdC10YLQvtC6IVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCLQn9C+0LLRltC00L7QvNC70LXQvdC90Y8g0LTQvtC00LDQvdC+INC00L4g0YfQtdGA0L3QtdGC0L7QuiFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwi0JPQvtGA0YLQsNC50YLQtSDQu9GW0LLQvtGA0YPRhywg0YnQvtCxINC/0LXRgNC10LPQu9GP0L3Rg9GC0Lgg0L7Qv9GG0ZbRl1wiLFxuXHRcIk1BTkFHRVwiOiBcItCj0L/RgNCw0LLQu9GW0L3QvdGPXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcItCX0L7QsdGA0LDQttC10L3QvdGPINCy0LjQtNCw0LvQtdC90L5cIixcblx0XCJDT1BZXCI6IFwi0JrQvtC/0ZbRjtCy0LDRgtC4XCIsXG5cdFwiTk9fSU1BR0VcIjogXCLQktC4INGJ0LUg0L3QtSDQt9Cw0LLQsNC90YLQsNC20LjQu9C4INC20L7QtNC90L7Qs9C+INC30L7QsdGA0LDQttC10L3QvdGPIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwi0KnQvtCxINC+0L3QvtCy0LjRgtC4LCDQv9C+0YLRj9Cz0L3RltGC0Ywg0LLQvdC40LdcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi0JfQvtCy0L3RltGI0L3RliDQtNC+0LTQsNGC0LrQuFwiLFxuXHRcIlBMVUdJTlNcIjogXCLQn9C70LDQs9GW0L3QuFwiLFxuXHRcIlNVR0dFU1RcIjogXCLQn9GA0L7Qv9C+0L3Rg9GU0LzQvlwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwi0J3QtdC30LDQsdCw0YDQvtC8XCIsXG5cdFwiQ0hBSU5cIjogXCLQkdC70L7QutGH0LXQudC9XCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcItCi0YPRgiDQstC4INC80L7QttC10YLQtSDQt9C80ZbQvdC40YLQuCDQsdC70L7QutGH0LXQudC9INCw0LHQviDQsdCw0LfQvtCy0YMg0L/Qu9Cw0YLRhNC+0YDQvNGDLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi0JLQsNC70Y7RgtCwXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcItCi0YPRgiDQstC4INC80L7QttC10YLQtSDQt9C80ZbQvdC40YLQuCDQstCw0LvRjtGC0YMg0LfQsCDQt9Cw0LzQvtCy0YfRg9Cy0LDQvdC90Y/QvC4g0JLQuNC90LDQs9C+0YDQvtC00LAg0LfQsCDQv9C+0YHRgi/QutC+0LzQtdC90YLQsNGAINCx0YPQtNC1INCy0ZbQtNC+0LHRgNCw0LbQsNGC0LjRgdGPINCyINGG0ZbQuSDQstCw0LvRjtGC0ZYuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+0JzQvtC20LvQuNCy0L7RgdGC0ZY8L2I+IDxicj4t0J7RgtGA0LjQvNCw0LnRgtC1INC00L7RgdGC0YPQvyDQtNC+INGD0L3RltC60LDQu9GM0L3QuNGFINGB0YLQsNGC0LXQuSDQvdCwINCx0YPQtNGMLdGP0LrRgyDRhtGW0LrQsNCy0YMg0LTQu9GPINCS0LDRgSDRgtC10LzRgy4gPGJyPiAt0KHQv9GW0LLQv9GA0LDRhtGO0LnRgtC1INC3INCw0LLRgtC+0YDQsNC80LgsINC60L7QvNC10L3RgtGD0Y7Rh9C4INGC0LAg0L7QsdCz0L7QstC+0YDRjtGO0YfQuCDRgtC10LzQuC4gPGJyPtCT0L7Qu9C+0YHRg9C50YLQtSDQt9CwINC/0YPQsdC70ZbQutCw0YbRltGXLCDRidC+0LEg0LLQuNC90LDQs9C+0YDQvtC00LjRgtC4INCw0LLRgtC+0YDQsCwg0LAg0YLQsNC60L7QtiDQt9Cw0YDQvtCx0LjRgtC4INC60YPRgNCw0YLQvtGA0YHRjNC60YMg0LLQuNC90LDQs9C+0YDQvtC00YMuIDxicj7Qn9GD0LHQu9GW0LrRg9C50YLQtSDQstCw0YjRliDRgdGC0LDRgtGC0ZYsINC/0L7QstGW0LTQvtC80LvQtdC90L3RjyDQsiDQsdC70L7Qt9GWINGWINGA0L7Qt9C80ZbRidGD0LnRgtC1INGX0YUg0LHQtdC30LrQvtGI0YLQvtCy0L3Qviwg0YnQvtCxINC30LDQu9GD0YfQuNGC0Lgg0L/QvtGB0LvRltC00L7QstC90LjQutGW0LIg0YLQsCDQvtGC0YDQuNC80LDRgtC4INCy0LjQvdCw0LPQvtGA0L7QtNGDLiA8YnI+0JfQsNC/0LjRgdGD0LnRgtC1INGB0YLQsNGC0YLRliDQvdCwINGF0L7QtNGDLCDQt9Cx0LXRgNGW0LPQsNC50YLQtSDQtNC10LrRltC70YzQutCwINGH0LXRgNC90LXRgtC+0Log0L/QvtGB0YLRgyDQtNC70Y8g0L/QvtC00LDQu9GM0YjQvtGXINC/0YPQsdC70ZbQutCw0YbRltGXINGDINC30YDRg9GH0L3QuNC5INC00LvRjyDQktCw0YEg0YfQsNGBLiA8YnI+0JTQvtC00LDQstCw0LnRgtC1INC00L4g0LfQsNC60LvQsNC00L7QuiDRg9C70Y7QsdC70LXQvdC40Lkg0YHRgtCw0YLRgtGWINGJ0L7QsSDQv9GA0L7Rh9C40YLQsNGC0Lgg0ZfRhSDQv9GW0LfQvdGW0YjQtS4gPGJyPtCe0LHQvNGW0L3RjtC50YLQtSDQsNCx0L4g0L/QtdGA0LXQstC+0LTRjNGC0LUg0YMg0LPQvtGC0ZbQstC60YMg0LLQsNGIINC30LDRgNC+0LHRltGC0L7Qui4gPGJyPtCf0LXRgNC10YHQuNC70LDQudGC0LUg0LrQvtGI0YLQuCDQsdGD0LTRjC3Rj9C60LjQvCDQsNCy0YLQvtGA0LDQvCDQsNCx0L4g0LrQvtGA0LjRgdGC0YPQstCw0YfQsNC8LCDQtNGA0YPQt9GP0LwsINC/0L7RgdC70ZbQtNC+0LLQvdC40LrQuCDRgtC+0YnQviA8YnI+0J/RltC00L/QuNGB0YPQudGC0LXRgdGMINC90LAg0YbRltC60LDQstC40YUg0LDQstGC0L7RgNGW0LIsINCx0LvQvtCz0LXRgNGW0LIuIDxicj4gLdCS0LjQutC+0YDQuNGB0YLQvtCy0YPQudGC0LUg0LfRgNGD0YfQvdC40Lkg0L/QvtGI0YPQuiDQv9C+0YHQu9GW0LTQvtCy0L3QuNC60ZbQsiDRliDQsNCy0YLQvtGA0ZbQsiwg0L3QsCDRj9C60LjRhSDQktC4INC/0ZbQtNC/0LjRgdCw0L3Rli4gPGJyPtCe0YLRgNC40LzRg9C50YLQtSDRgdC/0L7QstGW0YnQtdC90L3Rjywg0YnQvtCxINC30LDQu9C40YjQsNGC0LjRgdGPINC90LAg0LfQsifRj9C30LrRgyDRltC3INC/0L7RgdC70ZbQtNC+0LLQvdC40LrQsNC80Lgg0ZYg0YHQv9C+0YHRgtC10YDRltCz0LDRgtC4INC30LAg0YDQvtC30LLQuNGC0LrQvtC8INC00LjRgdC60YPRgdGW0LksINCyINGP0LrQuNGFINCS0Lgg0L/RgNC40LnQvNCw0ZTRgtC1INGD0YfQsNGB0YLRjCA8YnI+0JLQuNC60L7RgNC40YHRgtC+0LLRg9C50YLQtSDQv9C+0YjRg9C6INC/0L4g0YbRltC60LDQstC40Lwg0YLQtdCz0LDQvC/QutCw0YLQtdCz0L7RgNGW0Y/QvCDRgdGC0LDRgtC10LksINCw0LLRgtC+0YDQsNC8LiA8YnI+IC3Qn9C10YDRgdC+0L3QsNC70ZbQt9GD0LnRgtC1INCy0LDRiCDQv9GA0L7RhNGW0LvRjC4gPGJyPtCR0LDQs9Cw0YLQviDQvdC+0LLQuNGFINGE0YPQvdC60YbRltC5INC+0YfRltC60YPRlNGC0YzRgdGPINCyINC80LDQudCx0YPRgtC90YzQvtC80YMuIDxicj48YnI+PGI+0JHQtdC30L/QtdC60LA8L2I+IDxicj4xLiDQlNC+0LTQsNGC0L7QuiDQvdC1INC80LDRlCDQtNC+0YHRgtGD0L/RgyDQsNCx0L4g0L/RgNCw0LLQsCDRgNC+0LfQv9C+0YDRj9C00LbQsNGC0LjRgdGPINC60L7RiNGC0LDQvNC4INC60L7RgNC40YHRgtGD0LLQsNGH0LAuIDxicj4yLiDQlNC+0LTQsNGC0L7QuiDQv9GA0L7Qv9C+0L3Rg9GUINC60LvRltGU0L3Rgi3QsdC10LfQv9C10YfQvdGDINC80L7QtNC10LvRjCwg0LTQtSDQt9Cw0LrRgNC40YLRliDQutC70Y7Rh9GWINC30LHQtdGA0ZbQs9Cw0Y7RgtGM0YHRjyDQu9C+0LrQsNC70YzQvdC+INGWINC90ZbQutC+0LvQuCDQvdC1INC90LDQtNGB0LjQu9Cw0Y7RgtGM0YHRjyDQtNC+INCx0YPQtNGMLdGP0LrQuNGFINGB0LXRgNCy0LXRgNGW0LIsINCy0Lgg0YHQsNC80ZYg0L3QtdGB0LXRgtC1INCy0ZbQtNC/0L7QstGW0LTQsNC70YzQvdGW0YHRgtGMINC30LHQtdGA0LXQttC10L3QvdGPINGB0LLQvtGX0YUg0L/QsNGA0L7Qu9GW0LIuIDxicj4zLiDQlNC+0LTQsNGC0L7QuiDQv9GA0L7Qv9C+0L3Rg9GUINC/0YDQvtGB0YLQuNC5LCDQv9GA0LjQstCw0LHQu9C40LLQuNC5INGW0L3RgtC10YDRhNC10LnRgSDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINGWINC/0L7Qt9C40YLQuNCy0L3QuNC5INC00L7RgdCy0ZbQtCDQstC40LrQvtGA0LjRgdGC0LDQvdC90Y8uIDxicj40LiDQkiDQtNC+0LTQsNGC0LrRgyDQv9C10YDQtdC00LHQsNGH0LXQvdC+INC00L7QtNCw0YLQutC+0LLQuNC5INGA0ZbQstC10L3RjCDQsdC10LfQv9C10LrQuCDQtyDQstC40LrQvtGA0LjRgdGC0LDQvdC90Y/QvCBwaW4t0LrQvtC00YMuIDxicj48YnI+IGVTdGVlbSDQv9GW0LTRgtGA0LjQvNGD0ZQg0L/Qu9Cw0YLRhNC+0YDQvNC4IFN0ZWVtINGC0LAgR29sb3MuIDxicj5cIixcblx0XCJGT1VOREVSXCI6IFwi0JfQsNGB0L3QvtCy0L3QuNC6INGC0LAg0L/RgNC+0LLRltC00L3QuNC5INGA0L7Qt9GA0L7QsdC90LjQulwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwi0JTQvtC00LDRgtC4INCw0LrQsNGD0L3RglwiLFxuXHRcIlBMQVRGT1JNXCI6IFwi0J/Qu9Cw0YLRhNC+0YDQvNCwXCIsXG5cdFwiRVNDUk9XXCI6IFwiRXNjcm93XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwi0JDQs9C10L3RgiDRg9Cz0L7QtNC4XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwi0JrRltC90YbQtdCy0LjQuSDRgtC10YDQvNGW0L0g0YDQsNGC0LjRhNGW0LrQsNGG0ZbRl1wiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwi0KLQtdGA0LzRltC9INC00ZbRlyDRg9Cz0L7QtNC4XCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcItCa0L7QvNGW0YHRltGPINC30LAg0YPQs9C+0LTRg1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcItCj0LzQvtCy0Lgg0YPQs9C+0LTQuFwiLFxuXHRcIk5JR0hUX01PREVcIjogXCLQndGW0YfQvdC40Lkg0YDQtdC20LjQvFwiLFxuXHRcIkRBWV9NT0RFXCI6IFwi0JTQtdC90L3QuNC5INGA0LXQttC40LxcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCLQn9C10YDQtdCz0LvRj9C90YPRgtC4INC/0L7QstC90LjQuSDQutC+0L3RgtC10LrRgdGCXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcItCa0L7RgNC40YHRgtGD0LLQsNGH0LAg0L3QtSDQt9C90LDQudC00LXQvdC+XCIsXG5cdFwiQVBQUk9WRVwiOiBcItCX0LDRgtCy0LXRgNC00LjRgtC4XCIsXG5cdFwiRElTUFVURVwiOiBcItCh0YPQv9C10YDQtdGH0LrQsFwiLFxuXHRcIlJFTEVBU0VcIjogXCLQoNC10LvRltC3XCIsXG5cdFwiRlJPTVwiOiBcItCS0ZbQtFwiLFxuXHRcIklEXCI6IFwiSURcIixcblx0XCJTVUJNSVRcIjogXCLQktGW0LTQv9GA0LDQstC40YLQuFwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwi0J7RgtGA0LjQvNGD0LLQsNGHXCIsXG5cdFwiTE9DQVRJT05cIjogXCLQnNGW0YHRhtC10LfQvdCw0YXQvtC00LbQtdC90L3Rj1wiLFxuXHRcIldFQlNJVEVcIjogXCLQktC10LEt0YHRgtC+0YDRltC90LrQsFwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcItCS0ZbQtNC+0LHRgNCw0LbRg9Cy0LDQvdC1INGW0Lwn0Y9cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi6aaW6aG1XCIsXG5cdFwiTE9HSU5cIjogXCLnmbvlvZVcIixcblx0XCJMT0dPVVRcIjogXCLpgIDlh7pcIixcblx0XCJQUk9GSUxFXCI6IFwi566A5LuLXCIsXG5cdFwiRk9MTE9XXCI6IFwi5YWz5rOoXCIsXG5cdFwiQk9PS01BUktTXCI6IFwi5Lmm562+XCIsXG5cdFwiVFJBTlNGRVJcIjogXCLovazotKZcIixcblx0XCJNQVJLRVRcIjogXCLluILlnLpcIixcblx0XCJTRVRUSU5HU1wiOiBcIuiuvue9rlwiLFxuXHRcIkFCT1VUXCI6IFwi5YWz5LqOXCIsXG5cdFwiQUJPVVRfMVwiOiBcIuWcqOi/memHjOS7u+S9leS6uumDveWPr+S7pemdoOi0oeeMruWGheWuuei1mumSse+8gVwiLFxuXHRcIkFCT1VUXzJcIjogXCLnlLF7e3BsYXRmb3JtbmFtZX195bmz5Y+w5o+Q5L6b44CC5bqU55So56iL5bqP5Yib5bu655SxXCIsXG5cdFwiQUJPVVRfM1wiOiBcIuWug+S9nOS4uuW8gOa6kOOAgeekvuWMuumpseWKqOenu+WKqOerr+mhueebru+8jOaPkOS+m+WGheWuueiuv+mXrueUqOS6jumYheivu+OAgeivhOiuuuOAgeaKleelqOOAgeWPkeihqOOAgei9rOi0puaUtuebiuetieWKn+iDveOAgueUsXt7cGxhdGZvcm1uYW1lfX3ljLrlnZfpk77lkox7e3NpdGVuYW1lfX3mj5Dkvpvlip/og73jgIJcIixcblx0XCJBQk9VVF80XCI6IFwiMS7lupTnlKjnqIvluo/msLjkuI3orr/pl67miJbmjIHmnInnlKjmiLfph5HpkrHjgIJcIixcblx0XCJBQk9VVF81XCI6IFwiMi4g5bqU55So56iL5bqP5o+Q5L6b5a6i5oi356uv5a6J5YWo5qih5Z6L77yM56eB6ZKl5L+d5a2Y5Zyo5pys5Zyw77yM5rC45LiN5Y+R6YCB57uZ5Lu75L2V5pyN5Yqh5ZmoXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMu5bqU55So56iL5bqP5o+Q5L6b566A5Y2V5YW35pyJ5ZC45byV5Yqb55qE55So5oi35o6l5Y+j5Lul5Y+K5L2T6aqM44CCXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQu5bqU55So56iL5bqP5rC45LiN6KaB5rGC55So5oi36L6T5YWl5Lu75L2V5Liq5Lq65L+h5oGvXCIsXG5cdFwiQUJPVVRfOFwiOiBcIuaKleelqCBnb29kLWthcm1hIOS9nOS4uuingeivgeS6ulwiLFxuXHRcIkFCT1VUXzlcIjogXCLogZTns7sv5Y+N6aaIXCIsXG5cdFwiQUJPVVRfMTBcIjogXCLmm7TlpJrkv6Hmga9cIixcblx0XCJSRU1PVkVcIjogXCLnp7vpmaRcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIuW4guWcuuinguWvn1wiLFxuXHRcIlBSSUNFXCI6IFwi5Lu35qC8XCIsXG5cdFwiQU1PVU5UXCI6IFwi5pWw6YePXCIsXG5cdFwiVE9UQUxcIjogXCLmgLvlhbFcIixcblx0XCJOT09SREVSU1wiOiBcIuayoeacieiuouWNlVwiLFxuXHRcIkRBVEVcIjogXCLml6XmnJ9cIixcblx0XCJCVVlcIjogXCLkubBcIixcblx0XCJTRUxMXCI6IFwi5Y2WXCIsXG5cdFwiT1BFTlwiOiBcIuW8gOaUvlwiLFxuXHRcIkhJU1RPUllcIjogXCLljoblj7JcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIuWFs+azqOWbnlwiLFxuXHRcIkZPTExPV0VEXCI6IFwi5bey5YWz5rOoXCIsXG5cdFwiVU5GT0xMT1dcIjogXCLlj5bmtojlhbPms6hcIixcblx0XCJGT0xMT1dJTkdcIjogXCLlhbPms6hcIixcblx0XCJGT0xMT1dFUlNcIjogXCLnsonkuJ1cIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwi5pCc57Si57KJ5LidXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIuaQnOe0ouWFs+azqFwiLFxuXHRcIkJZXCI6IFwi55SxXCIsXG5cdFwiSU5cIjogXCLlnKhcIixcblx0XCJNRU5VXCI6IFwi6I+c5Y2VXCIsXG5cdFwiQk9PS01BUktcIjogXCLkuabnrb5cIixcblx0XCJSRUJMT0dcIjogXCLovazlj5FcIixcblx0XCJVUFZPVEVcIjogXCLotZ7miJDnpahcIixcblx0XCJET1dOVk9URVwiOiBcIuWPjeWvueelqFwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLlj5bmtojlj43lr7nnpahcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIuWPlua2iOi1nuaIkOelqFwiLFxuXHRcIlJFUExZXCI6IFwi5Zue5aSNXCIsXG5cdFwiRURJVFwiOiBcIue8lui+kVwiLFxuXHRcIlBPU1RfMVwiOiBcIuWcqOivhOiuuuS4iuWQkeW3pua7keWKqOadpeafpeeci+mAiemhuVwiLFxuXHRcIlBPU1RfMlwiOiBcIuWcqOivhOiuuuS4iueCueWHu+adpeafpeeci+WtkOivhOiuulwiLFxuXHRcIk9QVElPTlNcIjogXCLpgInpoblcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLovazlj5HnlLFcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLov5nov5jku4DkuYjpg73msqHmnIkuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIuS9meminVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIOWPr+S6pOaYk+S7o+W4geWPr+S7pemaj+aXtui9rOenuy4ge3twbGF0Zm9ybW5hbWV9fSDlj6/ku6XpgJrov4flj6vlgZrlhYXog73nmoTov4fnqIvooqvovazmjaLkuLp7e3BsYXRmb3JtcG93ZXJ9feOAglwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCDlvbHlk43lipvku6PluIHnlKjkuo7plb/mnJ/mjIHmnInku6Xlj4rnu5nmlofnq6DmipXnpajjgILmjIHmnInnmoTotorlpJrotorog73lvbHlk43ku5bkurrnmoTotY/ph5Hku6Xlj4rpgJrov4fmraPnoa7lnLDmipXnpajojrflvpflpZblirHjgIJcIixcblx0XCJQUk9GSUxFXzNcIjogXCLku6PluIHlpKfmpoLlgLx7e3BsYXRmb3Jtc3VuaXR9fSB7e3BsYXRmb3JtbmFtZX19XCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi5Lyw6K6h5Lu35YC8XCIsXG5cdFwiUFJPRklMRV80XCI6IFwi5Lyw6K6h5Lu35YC85Z+65LqOe3twbGF0Zm9ybW5hbWV9feeahDfml6XlubPlnYflgLxcIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi5Lqk5piT5Y6G5Y+yXCIsXG5cdFwiUE9TVElOR1wiOiBcIuWPkeW4g1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIuWPkeW4g+WvhumSpeeUqOS6juWPkeihqOaWh+eroOS7peWPiuaKleelqO+8jOWug+W6lOivpeS4jeWQjOS6jua0u+WKqOWvhumSpeS7peWPiuaJgOacieiAheWvhumSpeOAglwiLFxuXHRcIk9XTkVSXCI6IFwi5omA5pyJ6ICFXCIsXG5cdFwiUFJPRklMRV82XCI6IFwi5omA5pyJ6ICF5a+G6ZKl5piv5biQ5oi35Li75a+G6ZKl77yM5b2T5L+u5pS55YW25a6D5a+G6ZKl5pe26ZyA6KaB5o+Q5L6b44CC5omA5pyJ6ICF5a+G6ZKl55qE56eB6ZKl5oiW5a+G56CB5bqU5bC95Y+v6IO95Zyw56a757q/5L+d566h44CCXCIsXG5cdFwiQUNUSVZFXCI6IFwi5rS75YqoXCIsXG5cdFwiUFJPRklMRV83XCI6IFwi5rS75Yqo5a+G6ZKl55So5LqO5Y+R6LW36L2s6LSm5Lul5Y+K5Zyo5YaF6YOo5biC5Zy65LiL5Y2VXCIsXG5cdFwiTUVNT1wiOiBcIuWkh+azqFwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIuWkh+azqOWvhumSpeeUqOS6juWIm+W7uuWSjOmYheivu+Wkh+azqFwiLFxuXHRcIkJMT0dcIjogXCLljZrlrqJcIixcblx0XCJQT1NUU1wiOiBcIuaWh+eroFwiLFxuXHRcIlJFUExJRVNcIjogXCLlm57lpI1cIixcblx0XCJXQUxMRVRcIjogXCLpkrHljIVcIixcblx0XCJUQUdcIjogXCLmoIfnrb5cIixcblx0XCJVU0VSXCI6IFwi55So5oi3XCIsXG5cdFwiQ0xPU0VcIjogXCLlhbPpl61cIixcblx0XCJUT1wiOiBcIuWIsFwiLFxuXHRcIkFTU0VUXCI6IFwi6LWE5LqnXCIsXG5cdFwiU0VORFwiOiBcIuWPkemAgVwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi5a6J5YWoXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi5Y+v55SoXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLlhazlhbHlpIfms6hcIixcblx0XCJUT19ERVNDXCI6IFwi55So5oi3ICjkvovlpoI6Z29vZC1rYXJtYSlcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbiDnoIFcIixcblx0XCJQSU5fVEVYVFwiOiBcIlBJTueggeW4ruWKqeS9oOS/neaKpOW6lOeUqOWSjOaVsOaNruWuieWFqOOAgjxici8+PGJyLz48Yj7ms6jmhI86PC9iPuS4gOaXpuWQr+eUqO+8jOS9oOacgOWkmuWwneivleino+mUgTTmrKHvvIzlpoLmnpzlv5jorrDmiJblpLHotKXvvIzlupTnlKjnqIvluo/lsIbnp7vpmaTlt7LnmbvpmYbnlKjmiLfmlbDmja7jgILkvaDlj6/ku6Xph43mlrDnmbvpmYblubbnu6fnu63kvb/nlKjlupTnlKjnqIvluo/jgIJcIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi6YCa55+lXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi5b2T5pyJ5Lq657uZ5L2g55qE5YaF5a655oqV56Wo5pe277yM5L2g5bCG5b6X5Yiw6YCa55+l77yBPGJyLz4gPGI+5rOo5oSPOjwvYj4g6YCa55+l5YyF5ous5oqV56Wo5p2D6YeN5Lul5Y+K5o+Q6YaS5L+h5oGv44CCICjotZ7miJDnpagsIOWPjeWvueelqCwg5Y+W5raI5oqV56WoKS4gXCIsXG5cdFwiVk9URVwiOiBcIuaKleelqFwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIuW9k+acieS6uuivhOiuuuS9oOeahOaWh+eroOaIluivhOiuuuaXtu+8jOS9oOWwhuW+l+WIsOmAmuefpe+8gTxiPuazqOaEjzo8L2I+IOmAmuefpeS5n+WMheaLrOWIq+S6ujxiPue8lui+kTwvYj7ku5bku6znmoTor4TorrouIFwiLFxuXHRcIkNPTU1FTlRcIjogXCLor4TorrpcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIuW9k+S7luS6uuWFs+azqOS9oOaIluWPlua2iOWFs+azqOaXtuS9oOWwhuiOt+W+l+mAmuefpe+8gVwiLFxuXHRcIk1FTlRJT05TXCI6IFwi5o+Q5Y+KXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIuW9k+S7luS6uuWcqOaWh+eroOaIluivhOiuuuS4reaPkOWPiuS9oO+8jOS9oOWwhuW+l+WIsOmAmuefpe+8gVwiLFxuXHRcIlJFU1RFRU1cIjogXCLovazlj5FcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLlvZPku5bkurrovazlj5HkvaDnmoTmlofnq6Dml7bvvIzkvaDlsIblvpfliLDpgJrnn6XvvIFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIumFjee9rlwiLFxuXHRcIlZPVElOR1wiOiBcIuaKleelqOS4rVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi5oqV56Wo5p2D6YeN5oiW55m+5YiG5q+U5b2x5ZONQVBQ5Lit5oqV56Wo5aiB5Yqb77yM5L2g5Y+v5Lul55So5LqO6LCD6IqC5L2g55qE5oqV56Wo5pS255uK44CCPGJyLz48YnIvPjxiPuazqOaEjzo8L2I+IOi/meS5n+WwhuabtOaUueaKleWPjeWvueelqOeahOadg+mHjS/nmb7liIbmr5TlubbkuJTmlbTkuKpBUFDojIPlm7TlhoXmnInmlYguXCIsXG5cdFwiU0VSVkVSXCI6IFwi5pyN5Yqh5ZmoXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLmjqjojZBcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLkv53lrZjkv67mlLlcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIuaKleelqOiAheS/oeaBr1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIuasoui/juW9kuadpe+8gVwiLFxuXHRcIkxPR0lOXzFcIjogXCLkvb/nlKjnlKjmiLflkI3lr4bnoIHnmbvpmYblkI7nu6fnu61cIixcblx0XCJMT0dJTl8yXCI6IFwi5Y+R5biD5a+G6ZKl55So5LqO5Y+R6KGo5paH56ug44CB6K+E6K6644CB5oqV56Wo44CB5Lul5Y+K5YWz5rOo5LuW5Lq6XCIsXG5cdFwiTE9HSU5fM1wiOiBcIua0u+WKqOWvhumSpeeUqOS6jui9rOi0puS7peWPiuabtOaWsOi1hOaWmeWbvueJh+OAglwiLFxuXHRcIkxPR0lOXzRcIjogXCLnlKjmiLflh63or4Hkv53lrZjlnKjorr7lpIfmnKzlnLDvvIzpgIDlh7rlkI7lh63or4HkvJrooqvnp7vpmaTvvIFcIixcblx0XCJET05UX0hBVkVcIjogXCLov5jmsqHmnInotKbmiLfvvJ9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIueri+WNs+azqOWGjFwiLFxuXHRcIkNBTkNFTFwiOiBcIuWPlua2iFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi6auY57qn55qEXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIua0u+WKqOengemSpVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi5Y+R5biD56eB6ZKlXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCLkuLvlr4bnoIFcIixcblx0XCJVU0VSTkFNRVwiOiBcIueUqOaIt+WQjVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIuWNoeeJh+inhuWbvlwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIue0p+WHkeinhuWbvlwiLFxuXHRcIlNFQVJDSFwiOiBcIuaQnOe0olwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi5o+Q5Lqk5pWF5LqLXCIsXG5cdFwiUkVQTFlUT1wiOiBcIuWbnuWkjee7mVwiLFxuXHRcIlBPU1RcIjogXCLlj5HluINcIixcblx0XCJQUkVWSUVXXCI6IFwi6aKE6KeIXCIsXG5cdFwiREVGQVVMVFwiOiBcIum7mOiupCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiMTAwJSDlhYXog71cIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIuaLkue7neWllumHkVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi55WZ5b6F5Lul5ZCOXCIsXG5cdFwiQ0xFQVJcIjogXCLmuIXpmaRcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCLmlofnq6DlhoXlrrlcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCLor4TorrrlhoXlrrlcIixcblx0XCJUSVRMRVwiOiBcIuagh+mimFwiLFxuXHRcIlRBR1NcIjogXCLmoIfnrb5cIixcblx0XCJOT1RfTUFUQ0hcIjogXCLkuI3ljLnphY1cIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIuehruiupCBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCLplJnor6/nmoRcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLmraPlnKjmiZPlvIDmlofnq6BcIixcblx0XCJTRVRfUElOXCI6IFwi6K6+572uIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIui+k+WFpSBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLkvaDnoa7lrprlkJfvvJ9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIui9rOWPkeS4jeWPr+mAhu+8jOaYr+WQpue7p+e7re+8n1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIuW5v+aSremUmeivr++8jOivt+mHjeivle+8gVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLmiJDlip9cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIui9rOWPkeeahOaWh+eroFwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLnmbvpmYblpLHotKXvvIHlpoLmnpzpgInmi6npq5jnuqfmqKHlvI/vvIzor7fnoa7orqTkvb/nlKjkuLvlr4bnoIHnmbvpmYbmiJblnKjnmbvpmYbml7bmj5Dkvpvlj5HluIPnp4HpkqXjgIJcIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLnmbvpmYblpLHotKXvvIHlpoLmnpzpgInmi6npq5jnuqfmqKHlvI/vvIzor7fnoa7orqTkvb/nlKjkuLvlr4bnoIHnmbvpmYbmiJblnKjnmbvpmYbml7bmj5Dkvpvlj5HluIPnp4HpkqXjgIJcIixcblx0XCJXQVJOSU5HXCI6IFwi6K2m5ZGKXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIuaKleelqOe7meingeivgeS6ulwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwi5bey5oqV56Wo57uZ6KeB6K+B5Lq6XCIsXG5cdFwiQUdPXCI6IFwi5Lul5YmNXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLku47njrDlnKjlvIDlp4tcIixcblx0XCJTRUNTXCI6IFwi56eSXCIsXG5cdFwiQV9NSU5cIjogXCLkuIDliIbpkp9cIixcblx0XCJNSU5TXCI6IFwi5YiG6ZKfXCIsXG5cdFwiQU5fSE9VUlwiOiBcIuS4gOWwj+aXtlwiLFxuXHRcIkhPVVJTXCI6IFwi5bCP5pe2XCIsXG5cdFwiQV9EQVlcIjogXCLkuIDlpKlcIixcblx0XCJEQVlTXCI6IFwi5aSpXCIsXG5cdFwiQV9NT05USFwiOiBcIuS4gOaciFwiLFxuXHRcIk1PTlRIU1wiOiBcIuaciFwiLFxuXHRcIkFfWUVBUlwiOiBcIuS4gOW5tFwiLFxuXHRcIllFQVJTXCI6IFwi5bm0XCIsXG5cdFwiTUlOX1JFQURcIjogXCLliIbpkp/pmIXor7tcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwi5Y+N5a+556WoXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi5o2V6I635Zu+54mHXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLpgInmi6nlm77niYdcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIuiuvue9ruiHquWumuS5iVVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwi5o+S5YWl5Zu+54mHXCIsXG5cdFwiRVJST1JcIjogXCLplJnor69cIixcblx0XCJVUExPQURfRVJST1JcIjogXCLkuIrkvKDplJnor69cIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi55u45py65bey5Y+W5raIXCIsXG5cdFwiU0VUX1VSTFwiOiBcIuiuvue9rlVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLlm77niYfnmoTnm7TmjqXnvZHnu5zpk77mjqVcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIuivhOiuuuW3suaPkOS6pFwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi5Yig6Zmk6K+E6K665piv5LiN5Y+v6YCG55qELi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi6K+E6K665bey5Yig6ZmkXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLlm77niYfkuIrkvKDkuK1cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwi5LiK5Lyg5a6M5oiQXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIuS4iuS8oOWksei0pVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIueUqOaIt+WQjeaIluWvhueggeS4jeWvuVwiLFxuXHRcIklORk9cIjogXCLkv6Hmga9cIixcblx0XCJRUl9URVhUXCI6IFwi6K+35bCG5LqM57u056CB5qGG5YWl5omr5o+P5Yy65Z+fXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi6K+356Gu6K6k5L2g5pyJ6Laz5aSf55qE5L2Z6aKd55So5LqO6L2s6LSm77yBXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIuS9oOi9rOi0pueahOebruagh+eUqOaIt+S4jeWtmOWcqO+8gVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLmmK/lkKbnoa7orqTovazotKbvvJ9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLnoa7orqRcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIuS6pOaYk+W3suW5v+aSrVwiLFxuXHRcIkZFRURcIjogXCLor53pophcIixcblx0XCJUUkVORElOR1wiOiBcIui2i+WQkVwiLFxuXHRcIkhPVFwiOiBcIueDreeCuVwiLFxuXHRcIk5FV1wiOiBcIuaWsOeahFwiLFxuXHRcIlBST01PVEVEXCI6IFwi5o6o6ZSAXCIsXG5cdFwiVk9URVNcIjogXCLnpahcIixcblx0XCJQQVlPVVRcIjogXCLlpZbph5FcIixcblx0XCJDT01NRU5UU1wiOiBcIuivhOiuulwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiMzDml6XotovlkJFcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCLmjpLluo/mjInvvJpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLmlK/ku5jlkajmnJ9cIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi5r2c5Zyo5aWW6YeRXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLov4fljrvnmoTlpZbph5FcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwi5L2c6ICF5aWW6YeRXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwi55uR5oqk5Lq65aWW6YeRXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLmlofnq6Dlt7Lmj5DkuqTvvIFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwi5paH56ug55WZ5b6F5Lul5ZCO5o+Q5Lqk77yBXCIsXG5cdFwiU0FWRURcIjogXCLlt7Lkv53lrZhcIixcblx0XCJDTEVBUkVEXCI6IFwi5bey5riF6ZmkXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIue7meaWh+eroOaKleWPjeWvueelqOS8muenu+mZpOaUtuebiuW5tumZjeS9juadkOaWmeeahOWPr+ingeaAp+OAgjxicj48YnI+5Y+N5a+556Wo55So5LqO5Lul5LiL5Zy65pmv77yaPHVsPjxsaT7lvITomZrkvZzlgYfmiJblib3nqoM8L2xpPjxsaT7ku4fmgajoqIDorrrmiJbnvZHnu5zpkpPpsbw8L2xpPjxsaT7mlYXmhI/mlL7plJnnsbvnm67lhoXlrrnmiJbogIVTUEFNPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIui+vuWIsOivt+axgumZkOWItuOAguajgOafpeWFtuS7lui2i+WKvy/moIfnrb7vvIFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLmlofnq6Dlt7Lku47kuabnrb7lhoXnp7vpmaTvvIFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwi5paH56ug5bey57uP5Yqg5YWl5Lmm562+77yBXCIsXG5cdFwiUkVTRVRcIjogXCLph43nva5cIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIue8lui+kei1hOaWmeWbvueJh1wiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwi5L+u5pS55bCB6Z2i5Zu+54mHXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi5aaC5p6c5L2g6YCJ5Lit6auY57qn55m76ZmG5qih5byP77yM6K+35o+Q5L6b5rS75Yqo56eB6ZKl77yBXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwi6L+Z5bCG6YeN572u55So5oi36LWE5paZ5Zu+54mHXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi6L+Z5bCG6YeN572u55So5oi35bCB6Z2i5Zu+54mHXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLmnI3liqHlmajmm7TmlrDpnIDopoHph43lkK9cIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi6K6+572u5bey5pu05pawXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi6K+t6KiAXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLkvaDlj6/ku6XlnKjov5nkv67mlLnmraTlupTnlKjor63oqIDjgIJcIixcblx0XCJMT0dJTl9UT19YXCI6IFwi5q2k6aG55pON5L2c6KaB5rGC55So5oi35L2/55So5Li75a+G56CB77yM5rS75YqoL+WPkeW4g+WvhumSpeOAguivt+eZu+mZhuW5tumHjeivleOAglwiLFxuXHRcIkdBTExFUllcIjogXCLlm77lupNcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLnv7vor5HotKHnjK7ogIVcIixcblx0XCJTSEFSRVwiOiBcIuWIhuS6q1wiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwi5biC5Zy6XCIsXG5cdFwiRVhDSEFOR0VcIjogXCLkuqTmmJPmiYBcIixcblx0XCJEUkFGVFNcIjogXCLojYnnqL9cIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLmlofnq6Dlt7Lku47ojYnnqL/lhoXnp7vpmaTvvIFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi5paH56ug5bey57uP5Yqg5YWl6I2J56i/77yBXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIuWQkeW3pua7keWKqOafpeeci+mAiemhuVwiLFxuXHRcIk1BTkFHRVwiOiBcIueuoeeQhlwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLlm77lg4/lt7LliKDpmaRcIixcblx0XCJDT1BZXCI6IFwi5aSN5Yi2XCIsXG5cdFwiTk9fSU1BR0VcIjogXCLkvaDov5jmsqHmnInkuIrkvKDku7vkvZXlm77niYfvvIFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIuS4i+aLieWIt+aWsFwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLlpJbpg6jlupTnlKhcIixcblx0XCJQTFVHSU5TXCI6IFwi5o+S5Lu2XCIsXG5cdFwiU1VHR0VTVFwiOiBcIuW7uuiurlwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwi5Y2z5bCG5Yiw5p2lXCIsXG5cdFwiQ0hBSU5cIjogXCLpk75cIixcblx0XCJDSEFJTl9URVhUXCI6IFwi5Zyo552A5L2g5Y+v5Lul5L+u5pS55Yy65Z2X6ZO+5oiW6buY6K6k5bmz5Y+wXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLotKfluIFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi5Zyo6L+Z6YeM77yM5oKo5Y+v5Lul5pu05pS55oKo55qE6buY6K6k5biB56eN44CC5L2g5Lya55yL5Yiw6L+Z56eN6LSn5biB5biW5aWW5Yqx5YC844CCXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+5Yqf6IO95YiX6KGoPC9iPiA8YnI+6K6/6Zeu54us54m55paH56ug5Lit55qE5Lu75L2V5Li76aKY5L2g5pyJ5YW06Laj6K+744CCIDxicj4t5ZCM5L2c6ICF55qE6K+E6K6677yM6K6o6K6655qE6K+d6aKY44CCPGJyPuaKleelqOS4uuWlluWKseS9nOiAheWRmOmine+8jOS7peWPiuiOt+W+l+eyvumAieeahOWlluWKseOAgjxicj7lj5HluIPkvaDnmoTmlofnq6DvvIzljZrlrqLlkozlhY3otLnmlLblrrnku5bku6zotZrlj5bmiqXphazov5vooYzlkozojrflvpfnmoTov73pmo/ogIXjgII8YnI+LeWGmeS4i+WOu++8jOS/neWtmOWkmuS4quiNieeov+WRmOmine+8jOWFtuWQjuWPkeihqOeahOaWh+eroOOAgjxicj7kuabnrb7llpzmrKLnmoTmlofnq6DvvIzku6Xkvr/ku6XlkI7pmIXor7vjgII8YnI+5Lqk5o2i5oiW546w6YeR5pSv5LuY5L2g55qE5pS25YWl44CCPGJyPi3lj5HpgIHmgqjnmoTotYTph5HliLDku7vkvZXkvZzogIXmiJbnlKjmiLfjgIEg5pyL5Y+L44CBIOeyieS4neetiSA8YnI+6Lef6ZqP5pyJ6Laj55qE5L2c6ICF77yM5Y2a5a6i44CCIDxicj4t5pCc57Si5oKo55qE6L+96ZqP6ICF5ZKM5L2c6ICF5L2g5aaC5LiL44CCPGJyPuW+l+WIsOmAmuefpe+8jOS/neaMgeS9oOeahOi/vemaj+iAheWSjOiuqOiuuuS9oOaYr+a2ieWPiueahOiLseWvuCA8YnI+5pCc57Si5Li657G75Yir55qE54mp5ZOB77yM5L2c6ICF5pyJ6Laj5qCH562+44CCIDxicj4t5Liq5oCn5YyW5oKo55qE6YWN572u5paH5Lu244CCPGJyPuWkmuabtOWkmueahOWKn+iDveadpeOAgjxicj48YnI+PGI+5a6J5YWoPC9iPiA8YnI+MeOAguW6lOeUqOeoi+W6j+awuOi/nOS4jeS8muiuv+mXruaIluaKk+S9j+eUqOaIt+eahOi1hOmHkeOAgjxicj4yLuW6lOeUqOeoi+W6j+aPkOS+m+S6huWuouaIt+err+eahOWuieWFqOaooeWei++8jOS4juengeacieWvhumSpeeahOacrOWcsOaJmOeuoeWSjOawuOi/nOS4jeS8muWPkemAgeWIsOS7u+S9leacjeWKoeWZqO+8jOaCqOimgei0n+i0o+WvueWkh+S7veaCqOeahOWvhueggeOAgjxicj4zLuW6lOeUqOeoi+W6j+aPkOS+m+eugOWNle+8jOacieWQuOW8leWKm+eahOeUqOaIt+eVjOmdouWSjOS9k+mqjCA8YnI+NOOAguW6lOeUqOeoi+W6j+aPkOS+m+mineWklueahOWuieWFqOS4jiBwaW4g56CBIDxicj48YnI+6Ieq5bCK5bGC5pSv5oyB6JK45rG95ZKMIEdvbG9zIOW5s+WPsOOAgiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIuWIm+Wni+S6uuWSjOS4u+imgeW8gOWPkeS6uuWRmFwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwi5re75Yqg5biQ5Y+3XCIsXG5cdFwiUExBVEZPUk1cIjogXCLlubPlj7BcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi6aaW6aCBXCIsXG5cdFwiTE9HSU5cIjogXCLnmbvlhaVcIixcblx0XCJMT0dPVVRcIjogXCLnmbvlh7pcIixcblx0XCJQUk9GSUxFXCI6IFwi6Zec5pa8XCIsXG5cdFwiRk9MTE9XXCI6IFwi6L+96LmkXCIsXG5cdFwiQk9PS01BUktTXCI6IFwi5pu457GkXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLovYnluLNcIixcblx0XCJNQVJLRVRcIjogXCLluILloLRcIixcblx0XCJTRVRUSU5HU1wiOiBcIuioreWumlwiLFxuXHRcIkFCT1VUXCI6IFwi6Zec5pa8XCIsXG5cdFwiQUJPVVRfMVwiOiBcIuaJgOacieS6uueahOWFp+WuuemDveWPr+S7peWcqOmAmeijoeeNsuW+l+eNjuWLtVwiLFxuXHRcIkFCT1VUXzJcIjogXCLmmK/nlLF7e3BsYXRmb3JtbmFtZX195bmz5Y+w5omA5pSv5oyB44CC5q2kQXBw5LmL6ZaL55m86ICF54K6XCIsXG5cdFwiQUJPVVRfM1wiOiBcIuatpOeCuumWi+a6kOW8j+OAgeekvuWNgOmpheWLleS5i+ihjOWLleS9v+eUqOaWueahiO+8jOaPkOS+m+S9v+eUqOiAheWFp+WuuemWseiugOOAgeipleirluOAgeaKleelqOOAgeaWh+eroOeZvOW4g+iIh+aUtuWFpei9ieW4s+etieWKn+iDveOAguWQhOmgheWKn+iDveaYr+eUsXt7cGxhdGZvcm1uYW1lfX3kuYvljYDloYrpj4jku6Xlj4p7e3NpdGVuYW1lfX3ntrLnq5nmiYDmj5DkvpvjgIJcIixcblx0XCJBQk9VVF80XCI6IFwi5pysQXBw5LiN5pyD6JmV55CG5oiW566h5o6n5L2/55So6ICF5LmL6LOH6YeR44CCXCIsXG5cdFwiQUJPVVRfNVwiOiBcIuacrEFwcOaPkOS+m+WuouaItuerr+WuieWFqOS9v+eUqOaooeW8j++8jOS9v+eUqOiAheengemRsOWPquWcqOacrOapn+WFp+mDqOS9v+eUqO+8jOe1leS4jemAgeWHuuWIsOS7u+S9leWklumDqOS8uuacjeWZqOOAglwiLFxuXHRcIkFCT1VUXzZcIjogXCLmnKxBcHDmj5DkvpvnsKHllq7lpb3nlKjkuYvkvb/nlKjogIXku4vpnaLoiIfntpPpqZfjgIJcIixcblx0XCJBQk9VVF83XCI6IFwi5pysQXBw57WV5LiN5pyD5ZCR5L2/55So6ICF6KaB5rGC5o+Q5L6b5Lu75L2V5YCL5Lq66LOH5paZ44CCXCIsXG5cdFwiQUJPVVRfOFwiOiBcIuaKleelqOaUr+aMgWdvb2Qta2FybWHmiJDngrp3aXRuZXNzXCIsXG5cdFwiQUJPVVRfOVwiOiBcIuiBr+e1oS/mhI/opovlm57ppYtcIixcblx0XCJBQk9VVF8xMFwiOiBcIuabtOWkmuioiuaBr1wiLFxuXHRcIlJFTU9WRVwiOiBcIuenu+mZpFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwi5Lqk5piT5biC5aC0XCIsXG5cdFwiUFJJQ0VcIjogXCLlg7nmoLxcIixcblx0XCJBTU9VTlRcIjogXCLmlbjph49cIixcblx0XCJUT1RBTFwiOiBcIue4veioiFwiLFxuXHRcIk5PT1JERVJTXCI6IFwi54Sh5o6b5ZauXCIsXG5cdFwiREFURVwiOiBcIuaXpeacn1wiLFxuXHRcIkJVWVwiOiBcIuiyt+WFpVwiLFxuXHRcIlNFTExcIjogXCLos6Plh7pcIixcblx0XCJPUEVOXCI6IFwi5o6b5ZauXCIsXG5cdFwiSElTVE9SWVwiOiBcIuatt+WPsue0gOmMhFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwi57SN5YWl6L+96LmkXCIsXG5cdFwiRk9MTE9XRURcIjogXCLmraPooqvov73ouaRcIixcblx0XCJVTkZPTExPV1wiOiBcIuWPlua2iOi/vei5pFwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIui/vei5pOS9oOeahOWQjeWWrlwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIuS9oOi/vei5pOeahOWQjeWWrlwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLmkJzlsIvov73ouaTkvaDnmoTlkI3llq5cIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwi5pCc5bCL5L2g6L+96Lmk55qE5ZCN5ZauXCIsXG5cdFwiQllcIjogXCLnlLFcIixcblx0XCJJTlwiOiBcIuWcqFwiLFxuXHRcIk1FTlVcIjogXCLpgbjllq5cIixcblx0XCJCT09LTUFSS1wiOiBcIuabuOexpFwiLFxuXHRcIlJFQkxPR1wiOiBcIui9ieiyvFwiLFxuXHRcIlVQVk9URVwiOiBcIuiumlwiLFxuXHRcIkRPV05WT1RFXCI6IFwi5ZmTXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIuWPlua2iOWZk1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi5Y+W5raI6K6aXCIsXG5cdFwiUkVQTFlcIjogXCLlm57opoZcIixcblx0XCJFRElUXCI6IFwi57eo6LyvXCIsXG5cdFwiUE9TVF8xXCI6IFwi6KmV6KuW5LiK5ZCR5bem5ruR5Lul6aGv56S65YuV5L2c5riF5ZauXCIsXG5cdFwiUE9TVF8yXCI6IFwi6bue5pOK6KmV6KuW5Y+v5bGV6ZaL5LiL5LiA5bGk6KmV6KuWXCIsXG5cdFwiT1BUSU9OU1wiOiBcIumBuOmghVwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIui9ieiyvFwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIuaWveW3peS4rVwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwi57WQ6aSYXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSDmmK/lj6/kuqTmmJPnmoTosqjluaPvvIzpmqjmmYLlj6/ku6XpgLLooYznp7vovYnjgIJ7e3BsYXRmb3JtbmFtZX19IOWPr+S7peiiq+i9ieaPm+aIkCB7e3BsYXRmb3JtcG93ZXJ9fe+8jOatpOS4gOWLleS9nOeoseeCunBvd2VyaW5nIHVw44CCXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0g5Y+v6KaW54K65YW35pyJ5b2x6Z+/5Yqb55qE6IKh5qyK77yM5oyB5pyJ5Y+v6ZW35pyf5aKe5YC85Lim5bCN5paH56ug5oqV56Wo77yM5oyB5pyJ5pW46YeP6LaK5aSa5bCN5pa85YW25LuW5Lq6542O5Yu15aSn5bCP55qE5b2x6Z+/5Yqb5bCx6LaK5aSn77yM5Lmf5pu06IO95b6e5rqW56K655qE5oqV56Wo6KGM54K65Lit542y5b6X542O5Yu144CCIFwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIuebruWJjeaMgeaciXt7cGxhdGZvcm1zdW5pdH1955qEe3twbGF0Zm9ybW5hbWV9feOAglwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIuamguS8sOWDueWAvFwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIuamguS8sOWDueWAvOaYr+S7pXt7cGxhdGZvcm1uYW1lfX0zLTXlpKnkuYvlubPlnYflg7nngrrln7rnpI5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi5Lqk5piT5q235Y+y57SA6YyEXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiUG9zdGluZ+engemRsOS9v+eUqOaWvOeZvOaWh+iIh+aMieiumua0u+WLleS4iu+8jOWFtuiIh0FjdGl2ZeS7peWPik93bmVy56eB6ZGw5Yqf6IO95LiN5ZCM44CCXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiT3duZXLnp4HpkbDmmK/mnKzluLPomZ/kuYvkuLvpkbDvvIzlhbfmnInmm7TmlLnlhbbku5bnp4HpkbDnmoTmrIrlipvjgILlronlhajotbfopovvvIxPd25lcuengemRsOWvhueivOaHieipsuWEmOWPr+iDveWcsOmboue3muWEsuWtmOOAglwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkFjdGl2ZeengemRsOeUqOaWvOW4s+iZn+izh+mHkeiZleeQhua0u+WLleS7peWPiuaWvOWFp+mDqOW4guWgtOS4i+WWruiyt+izo+aWuemdouOAglwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIk1lbW/np4HpkbDnlKjmlrzlibXpgKDoiIforoDlj5ZtZW1v6KiK5oGv44CCXCIsXG5cdFwiQkxPR1wiOiBcIumDqOiQveagvFwiLFxuXHRcIlBPU1RTXCI6IFwi5L2g55qE6KmV6KuWXCIsXG5cdFwiUkVQTElFU1wiOiBcIuWbnuaHieipleirllwiLFxuXHRcIldBTExFVFwiOiBcIumMouWMhVwiLFxuXHRcIlRBR1wiOiBcIuaomeexpFwiLFxuXHRcIlVTRVJcIjogXCLkvb/nlKjogIVcIixcblx0XCJDTE9TRVwiOiBcIumXnOmWiVwiLFxuXHRcIlRPXCI6IFwi5YiwXCIsXG5cdFwiQVNTRVRcIjogXCLos4fnlKJcIixcblx0XCJTRU5EXCI6IFwi5YKz6YCBXCIsXG5cdFwiU0VDVVJJVFlcIjogXCLlronlhajmgKdcIixcblx0XCJBVkFJTEFCTEVcIjogXCLlj6/kvb/nlKhcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIuWFrOmWi+ioiuaBr1wiLFxuXHRcIlRPX0RFU0NcIjogXCLkvb/nlKjogIXvvIzkvovlpoIgZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwi5a+G56K8XCIsXG5cdFwiUElOX1RFWFRcIjogXCLoqK3nva7mraTlr4bnorzku6Xkv53orbdBcHDoiIfnlKjmiLbos4fmlpnjgII8YnIvPjxici8+PGI+5rOo5oSP77yaPC9iPuS4gOaXpuWVn+eUqO+8jOS9oOWPquiDveaciTTmrKHop6PpjpbmqZ/mnIPvvIzlpoLmnpzlv5joqJjlr4bnorzmiJbmmK/lhajmlbjnmbvlhaXlpLHmlZfvvIzliYdBcHDmnIPnp7vpmaTnmbvlhaXos4fmlpnjgILkvaDlj6/ku6Xlho3mrKHnmbvlhaXkuKbnubznuozkvb/nlKhBcHDjgIJcIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi6YCa55+lXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi5L2g55qE5YWn5a65542y5b6X5Yil5Lq65oyJ6K6a5pmC5pyD6YCa55+l5L2g77yBPGJyLz4gPGI+5rOo5oSP77yaPC9iPiDpgJrnn6XlhaflrrnljIXmi6zmjInorprmrIrph43oiIfmj5DphpLoqIrmga/jgILvvIjmjInorprjgIHmjInlmZPjgIHlj5bmtojorprvvIlcIixcblx0XCJWT1RFXCI6IFwi5oqV56WoXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi5LuW5Lq66KmV6KuW5L2g55qE5paH56ug5oiW6KmV6KuW5pmC77yM5L2g5pyD5pS25Yiw6YCa55+l77yBPGJyLz4gPGI+5rOo5oSP77yaPC9iPiDlsI3mlrnoi6U8Yj7ph43mlrDnt6jovK88L2I+6KmV6KuW5YWn5a6577yM5Lqm5pyD6YCa55+l5L2g44CCXCIsXG5cdFwiQ09NTUVOVFwiOiBcIuipleirllwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwi5LuW5Lq66L+96Lmk5oiW5Y+W5raI6L+96Lmk5L2g5pmC77yM5L2g5pyD5pS25Yiw6YCa55+l77yBXCIsXG5cdFwiTUVOVElPTlNcIjogXCLmj5Dlj4pcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwi5LuW5Lq65Zyo5paH56ug5oiW6KmV6KuW5Lit5o+Q5Y+K5L2g5pmC77yM5L2g5pyD5pS25Yiw6YCa55+l77yBXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCLntYTmhYvoqK3lrppcIixcblx0XCJWT1RJTkdcIjogXCLmipXnpahcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIuaKleelqOasiumHjeacg+W9semfv+aKleelqOiDvemHj+S7peWPiuaKleelqOeNjuWLte+8jOS9oOWPr+S7peS6iOS7peiqv+aVtOOAgjxici8+IDxiPuazqOaEj++8mjwvYj4g5bCN5qyK6YeN5LmL6Kq/5pW05ZCM5qij6YGp55So5pa85oyJ6K6a6IiH5oyJ5ZmT77yM5Lim5oyB57qM5L+d5oyB5q2k5LiA5qyK6YeN44CCXCIsXG5cdFwiU0VSVkVSXCI6IFwi5Ly65pyN5ZmoXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLmjqjolqZcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLlhLLlrZjorormm7RcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIuaKleelqOioiuaBr1wiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIuatoei/juWbnuS+hu+8gVwiLFxuXHRcIkxPR0lOXzFcIjogXCLoq4vku6XmgqjnmoTkvb/nlKjogIXluLPomZ/oiIflr4bnorznmbvlhaVcIixcblx0XCJMT0dJTl8yXCI6IFwiUG9zdGluZyBrZXnnlKjmlrznmbzluIPmlofnq6DjgIHmipXnpajoiIfov73ouaTjgIJcIixcblx0XCJMT0dJTl8zXCI6IFwiQWN0aXZlIGtleeeUqOaWvOi9ieW4s+ebuOmXnOiIh+OAjOmXnOaWvOOAjeS5i+WclueJh+abtOaWsOOAglwiLFxuXHRcIkxPR0lOXzRcIjogXCLkvb/nlKjogIXnmoToqo3orYnos4foqIrlj6rkv53lrZjlnKjoo53nva7mnKzlnLDnq6/jgILnmbvlh7rlvozoqo3orYnos4foqIrlsIfooqvnp7vpmaTjgIJcIixcblx0XCJET05UX0hBVkVcIjogXCLpgoTmspLmnInluLPomZ/ll47vvJ9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIummrOS4iuWOu+iou+WGilwiLFxuXHRcIkNBTkNFTFwiOiBcIuWPlua2iFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi6YCy6ZqOXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJNYXN0ZXLlr4bnorwv5Li75a+G56K8XCIsXG5cdFwiVVNFUk5BTUVcIjogXCLkvb/nlKjogIXlkI3nqLFcIixcblx0XCJDQVJEX1ZJRVdcIjogXCLmraPluLjmqKHlvI9cIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLnsr7nsKHmqKHlvI9cIixcblx0XCJTRUFSQ0hcIjogXCLmkJzlsItcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIuaPkOS6pOaWh+eroFwiLFxuXHRcIlJFUExZVE9cIjogXCLlm57opoZcIixcblx0XCJQT1NUXCI6IFwi6LK85paHXCIsXG5cdFwiUFJFVklFV1wiOiBcIumgkOimvVwiLFxuXHRcIkRFRkFVTFRcIjogXCLpoJDoqK0gNTAlIC8gNTAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLorJ3ntZVQYXlvdXRcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIumgkOWtmOiNieeov1wiLFxuXHRcIkNMRUFSXCI6IFwi5riF6ZmkXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi6LK85paH5YWn5a65XCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi6KmV6KuW5YWn5a65XCIsXG5cdFwiVElUTEVcIjogXCLmqJnpoYxcIixcblx0XCJUQUdTXCI6IFwi5qiZ57GkXCIsXG5cdFwiTk9UX01BVENIXCI6IFwi5LiN56ymXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCLnorroqo3lr4bnorxcIixcblx0XCJJTkNPUlJFQ1RcIjogXCLkuI3mraPnorpcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLmiZPplovosrzmlodcIixcblx0XCJTRVRfUElOXCI6IFwi6YeN6Kit5a+G56K8XCIsXG5cdFwiRU5URVJfUElOXCI6IFwi6Ly45YWl5a+G56K8XCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwi5piv5ZCm56K65a6a77yfXCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwi5buj5pKt6Yyv6Kqk77yM6KuL5YaN6Kmm5LiA5qyh77yBXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIuaIkOWKn1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwi6L2J6LK85paH56ugXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIueZu+WFpeWkseaVl++8geiri+eiuuiqjeS9oOaYr+S7pW1hc3RlcuWvhueivOeZu+WFpe+8jOaIluaYr+WcqOmAsumajuaooeW8j+S4i+S7peaPkOS+m+S5i1Bvc3Rpbmfnp4HpkbDnmbvlhaXjgIJcIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLnmbvlhaXlpLHmlZfvvIHoq4vnorroqo3kvaDmmK/ku6VtYXN0ZXLlr4bnorznmbvlhaXvvIzmiJbmmK/lnKjpgLLpmo7mqKHlvI/kuIvku6Xmj5DkvpvkuYtBY3RpdmXnp4HpkbDnmbvlhaXjgIJcIixcblx0XCJXQVJOSU5HXCI6IFwi6K2m5ZGKXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIuaKleelqOaUr+aMgeimi+itieS6ulwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwi5oqV56Wo5pSv5oyB54K66KaL6K2J5Lq6XCIsXG5cdFwiQUdPXCI6IFwi5YmNXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLpgoTmnIlcIixcblx0XCJTRUNTXCI6IFwi56eSXCIsXG5cdFwiQV9NSU5cIjogXCLkuIDliIbpkJhcIixcblx0XCJNSU5TXCI6IFwi5YiG6ZCYXCIsXG5cdFwiQU5fSE9VUlwiOiBcIuS4gOWwj+aZglwiLFxuXHRcIkhPVVJTXCI6IFwi5bCP5pmCXCIsXG5cdFwiQV9EQVlcIjogXCLkuIDlpKlcIixcblx0XCJEQVlTXCI6IFwi5aSpXCIsXG5cdFwiQV9NT05USFwiOiBcIuS4gOWAi+aciFwiLFxuXHRcIk1PTlRIU1wiOiBcIuWAi+aciFwiLFxuXHRcIkFfWUVBUlwiOiBcIuS4gOW5tFwiLFxuXHRcIllFQVJTXCI6IFwi5YCL5bm0XCIsXG5cdFwiTUlOX1JFQURcIjogXCLliIbpkJjplrHoroDmmYLplpNcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwi5oyJ5ZmTXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi542y5Y+W5ZyW54mHXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLpgbjmk4flnJbniYdcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIuioreWumuWwiOeUqOmAo+e1kFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwi5o+S5YWl5ZyW54mHXCIsXG5cdFwiRVJST1JcIjogXCLpjK/oqqRcIixcblx0XCJVUExPQURfRVJST1JcIjogXCLkuIrlgrPpjK/oqqRcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi5Y+W5raI55u45qmfXCIsXG5cdFwiU0VUX1VSTFwiOiBcIuioreWumlVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLlnJbniYfkuYvntrLnq5npgKPntZBcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIuipleirlumAgeWHulwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi5Yiq6Zmk6KmV6KuW5YuV5L2c5piv5LiN5Y+v5oGi5b6p55qEXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi5bey5Yiq6Zmk5LmL6KmV6KuWXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLkuIrlgrPlnJbniYdcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwi5LiK5YKz5a6M5oiQXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIuS4iuWCs+WkseaVl1wiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIuWvhueivOaIluW4s+iZn+WQjeeosemMr+iqpFwiLFxuXHRcIklORk9cIjogXCLoqIrmga9cIixcblx0XCJRUl9URVhUXCI6IFwi6KuL5bCHUVIgY29kZee9ruaWvOaOg+aPj+WNgOWfn+WFp1wiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIuiri+eiuuiqjeaciei2s+WkoOmkmOmhjeWPr+S+m+S6pOaYk++8gVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLovYnlhaXluLPomZ/kuI3lrZjlnKhcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwi56K65a6a6KaB6YCy6KGM6L2J5biz77yfXCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwi56K66KqNXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLkuqTmmJPlt7Llu6Pmkq1cIixcblx0XCJGRUVEXCI6IFwi5YuV5oWL5raI5oGvXCIsXG5cdFwiVFJFTkRJTkdcIjogXCLnhKbpu55cIixcblx0XCJIT1RcIjogXCLnhrHploBcIixcblx0XCJORVdcIjogXCLmnIDmlrBcIixcblx0XCJQUk9NT1RFRFwiOiBcIui0iuWKqVwiLFxuXHRcIlZPVEVTXCI6IFwi56Wo5pW4XCIsXG5cdFwiUEFZT1VUXCI6IFwi5pS25YWlXCIsXG5cdFwiQ09NTUVOVFNcIjogXCLoqZXoq5ZcIixcblx0XCJUUkVORElOR18zMFwiOiBcIjMw5aSp54Sm6bueXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi5paH56ug5o6S5bqPXCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi5pS25YWl6YCx5pyfXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIuacquWvpuePvuaUtuWFpVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwi5bey5pSv5LuY5pS25YWlXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIuS9nOiAheaUtuWFpVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIuaKleelqOaUtuWFpVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi5paH56ug5bey6YCB5Ye6XCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIuW+heeZvOaWh+eroFwiLFxuXHRcIlNBVkVEXCI6IFwi5bey5YSy5a2YXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIuW3sua4hemZpFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCLlsI3mlofnq6DmjInlmZPmnIPlvbHpn7/lhbbnjY7li7XvvIzkuKbpmY3kvY7lhbbog73opovluqbjgII8YnI+PGJyPiDmh4nlnKjkuIvliJfmg4Xms4HkuIvmjInlmZPvvJo8dWw+PGxpPuipkOasuuaIluaKhOilsjwvbGk+PGxpPuS7h+aBqOaAp+iogOirluaIlue2sui3r+a/q+eUqDwvbGk+PGxpPuWFp+WuueaVheaEj+WIhumhnumMr+iqpOaIluWkp+mHj+aVo+W4g+Weg+WcvuioiuaBrzwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCLlt7LpgZTopoHmsYLpmZDluqbvvIzoq4vmn6XoqaLlhbbku5bnhKbpu57mlofnq6DmiJbmqJnnsaTvvIFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLmlofnq6Dlt7Loh6rmm7jnsaTkuK3np7vpmaRcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwi5paH56ug5bey5Yqg5YWl5pu457GkXCIsXG5cdFwiUkVTRVRcIjogXCLph43nva5cIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIuS/ruaUueOAjOmXnOaWvOOAjeeahOWclueJh1wiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwi5L+u5pS55bCB6Z2i5ZyW54mHXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi6Iul6YG45pOH6YCy6ZqO5qih5byP77yM6KuL5o+Q5L6bQWN0aXZl56eB6ZGw77yBXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwi5q2k5YuV5L2c5bCH6YeN6Kit5L2/55So6ICF44CM6Zec5pa844CN55qE5ZyW54mHXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi5q2k5YuV5L2c5bCH6YeN6Kit5L2/55So6ICF5bCB6Z2i5ZyW54mHXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLnlLHmlrzkvLrmnI3lmajmm7TmlrDpnIDopoHph43mlrDllZ/li5XvvIFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi6Kit5a6a5bey5pu05paw77yBXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi6Kqe6KiAXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLkvaDlj6/ku6XlnKjmraTmm7TmlLlBUFDnmoTkvb/nlKjoqp7oqIBcIixcblx0XCJMT0dJTl9UT19YXCI6IFwi5q2k5LiA5YuV5L2c6ZyA6KaB5L2/55So6ICF5Lul5Li75a+G56K844CBQWN0aXZl56eB6ZGw5oiWUG9zdGluZ+engemRsOeZu+WFpeOAguiri+eZu+WFpeWGjeippuS4gOS4i+OAglwiLFxuXHRcIkdBTExFUllcIjogXCLpmbPliJdcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLlpJrlnIvoqp7oqIDnv7vora/lt6XkvZzljZTliqnogIVcIixcblx0XCJTSEFSRVwiOiBcIuWIhuS6q1wiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwi5biC5aC0XCIsXG5cdFwiRVhDSEFOR0VcIjogXCLkuqTmmJPmiYBcIixcblx0XCJEUkFGVFNcIjogXCLojYnnqL9cIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLmlofnq6Doh6rojYnnqL/kuK3np7vpmaTvvIFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi5paH56ug5Yqg5YWl6I2J56i/77yBXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIuWQkeW3pua7keWLleWPr+mWi+WVn+WLleS9nOmBuOmghVwiLFxuXHRcIk1BTkFHRVwiOiBcIueuoeeQhlwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLlnJbniYfnp7vpmaRcIixcblx0XCJDT1BZXCI6IFwi6KSH6KO9XCIsXG5cdFwiTk9fSU1BR0VcIjogXCLmgqjlsJrmnKrkuIrlgrPku7vkvZXlnJbniYfvvIFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIuWQkeS4i+aLieWLleWPr+abtOaWsFwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLlpJbpg6hBcHBcIixcblx0XCJQTFVHSU5TXCI6IFwi5aSW5o6b56iL5byPXCIsXG5cdFwiU1VHR0VTVFwiOiBcIuW7uuitsFwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwi5Y2z5bCH5o6o5Ye6XCIsXG5cdFwiQ0hBSU5cIjogXCLpj4hcIixcblx0XCJDSEFJTl9URVhUXCI6IFwi5oKo5Y+v5Lul5Zyo6YCZ6KOh6K6K5pu05L2/55So55qE5Y2A5aGK6Y+I5oiW5piv6aCQ6Kit55qE5bmz5Y+w44CCXCIsXG5cdFwiUkVMRUFTRVwiOiBcIumHi+aUvlwiXG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy9hbmd1bGFyLm1vZHVsZSgnc3RlZW0uc2VydmljZXMnLCBbXSlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuXHRhcHAuc2VydmljZSgnQVBJcycsIFsnJGh0dHAnLCAnJHJvb3RTY29wZScsICdBUElfRU5EX1BPSU5UJywgZnVuY3Rpb24gKCRodHRwLCAkcm9vdFNjb3BlLCBBUElfRU5EX1BPSU5UKSB7XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcdHJldHVybiB7XG4gICAgICBnZXRDdXJyZW5jeVJhdGU6IGZ1bmN0aW9uKGNvZGVfZnJvbSwgY29kZV90byl7XG4gICAgICAgIGNvbnNvbGUubG9nKGNvZGVfZnJvbSxjb2RlX3RvKTtcbiAgICAgICAgcmV0dXJuICRodHRwLmdldChcImh0dHBzOi8vcXVlcnkueWFob29hcGlzLmNvbS92MS9wdWJsaWMveXFsP3E9c2VsZWN0JTIwKiUyMGZyb20lMjB5YWhvby5maW5hbmNlLnhjaGFuZ2UlMjB3aGVyZSUyMHBhaXIlMjBpbiUyMCglMjJcIitjb2RlX2Zyb20rY29kZV90bytcIiUyMikmZm9ybWF0PWpzb24mZGlhZ25vc3RpY3M9ZmFsc2UmZW52PXN0b3JlJTNBJTJGJTJGZGF0YXRhYmxlcy5vcmclMkZhbGx0YWJsZXN3aXRoa2V5c1wiKTtcbiAgICAgIH0sXG4gICAgICBzYXZlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbihkZXZpY2VpZCwgdXNlcm5hbWUsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzXCIsIHtkZXZpY2VpZDogZGV2aWNlaWQsIHVzZXJuYW1lOiB1c2VybmFtZSwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIGNoYWluOiAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWlufSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uOiBmdW5jdGlvbihkZXZpY2VpZCwgdXNlcm5hbWUsIHN1YnNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gJGh0dHAucHV0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZXNcIiwge2RldmljZWlkOiBkZXZpY2VpZCwgdXNlcm5hbWU6IHVzZXJuYW1lLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiwgY2hhaW46ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW59KTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUb2tlbjogZnVuY3Rpb24oZGV2aWNlaWQsIG5ld2Rldikge1xuICAgICAgICByZXR1cm4gJGh0dHAucHV0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZS9cIitkZXZpY2VpZCwge25ld2RldjogbmV3ZGV2LCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVN1YnNjcmlwdGlvbjogZnVuY3Rpb24oZGV2aWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmRlbGV0ZShBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzL1wiK2RldmljZWlkKTtcbiAgICAgIH0sXG4gICAgICBnZXRTdWJzY3JpcHRpb25zOiBmdW5jdGlvbihkZXZpY2VpZCkge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RldmljZXMvXCIrZGV2aWNlaWQpO1xuICAgICAgfSxcblx0XHRcdGFkZEJvb2ttYXJrOiBmdW5jdGlvbih1c2VyLCBib29rbWFyaykge1xuICAgICAgICByZXR1cm4gJGh0dHAucG9zdChBUElfRU5EX1BPSU5UK1wiL2FwaS9ib29rbWFya1wiLCB7dXNlcm5hbWU6IHVzZXIsIGF1dGhvcjogYm9va21hcmsuYXV0aG9yLCBwZXJtbGluazogYm9va21hcmsucGVybWxpbmssIGNoYWluOiAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWlufSk7XG4gICAgICB9LFxuXHRcdFx0Z2V0Qm9va21hcmtzOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoQVBJX0VORF9QT0lOVCtcIi9hcGkvYm9va21hcmtzL1wiK3VzZXIpO1xuICAgICAgfSxcblx0XHRcdHJlbW92ZUJvb2ttYXJrOiBmdW5jdGlvbihpZCwgdXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZGVsZXRlKEFQSV9FTkRfUE9JTlQrXCIvYXBpL2Jvb2ttYXJrcy9cIit1c2VyK1wiL1wiK2lkKTtcbiAgICAgIH0sXG5cdFx0XHRhZGREcmFmdDogZnVuY3Rpb24odXNlciwgZHJhZnQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoQVBJX0VORF9QT0lOVCtcIi9hcGkvZHJhZnRcIiwge3VzZXJuYW1lOiB1c2VyLCB0aXRsZTogZHJhZnQudGl0bGUsIGJvZHk6IGRyYWZ0LmJvZHksIHRhZ3M6IGRyYWZ0LnRhZ3MsIHBvc3RfdHlwZTogZHJhZnQucG9zdF90eXBlLCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcblx0XHRcdGdldERyYWZ0czogZnVuY3Rpb24odXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RyYWZ0cy9cIit1c2VyKTtcbiAgICAgIH0sXG5cdFx0XHRyZW1vdmVEcmFmdDogZnVuY3Rpb24oaWQsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmRlbGV0ZShBUElfRU5EX1BPSU5UK1wiL2FwaS9kcmFmdHMvXCIrdXNlcitcIi9cIitpZCk7XG4gICAgICB9LFxuXHRcdFx0cmVtb3ZlSW1hZ2U6IGZ1bmN0aW9uKGlkLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5kZWxldGUoQVBJX0VORF9QT0lOVCtcIi9hcGkvaW1hZ2VzL1wiK3VzZXIrXCIvXCIraWQpO1xuICAgICAgfSxcblx0XHRcdGZldGNoSW1hZ2VzOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoQVBJX0VORF9QT0lOVCtcIi9hcGkvaW1hZ2VzL1wiK3VzZXIpO1xuICAgICAgfSxcbiAgICAgIHNlYXJjaEVzY3JvdzogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmdldChBUElfRU5EX1BPSU5UK1wiL2FwaS9lc2Nyb3cvXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIi9cIitpZCk7XG4gICAgICB9LFxuXHRcdH07XG5cdH1dKVxuICBhcHAuZGlyZWN0aXZlKCdiYWNrSW1nJywgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKXtcbiAgICAgICAgdmFyIHVybCA9IGF0dHJzLmJhY2tJbWc7XG4gICAgICAgIGVsZW1lbnQuY3NzKHtcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgdXJsICsnKScsXG4gICAgICAgICAgICAnYmFja2dyb3VuZC1zaXplJyA6ICdjb3ZlcidcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG4gIGFwcC5kaXJlY3RpdmUoJ3NlbGVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuYmluZCgnZm9jdXMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIC8vICRyb290U2NvcGUubG9nKFwic2hvdyBiYXIgKGhpZGUgPSBmYWxzZSlcIik7XG4gICAgICAgICAgICBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaGlkZUtleWJvYXJkQWNjZXNzb3J5QmFyKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmJpbmQoJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5jb3Jkb3ZhICYmIHdpbmRvdy5jb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIC8vICRyb290U2NvcGUubG9nKFwiaGlkZSBiYXIgKGhpZGUgPSB0cnVlKVwiKTtcbiAgICAgICAgICAgIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5oaWRlS2V5Ym9hcmRBY2Nlc3NvcnlCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgYXBwLmRpcmVjdGl2ZSgnbmF2aWdhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbGxlciA9IFsnJHNjb3BlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAkc2NvcGUuYWRkYWN0aXZlY2xhc3MgPSBmdW5jdGlvbiAobWVudUl0ZW0pIHtcbiAgICAgICAgICAkc2NvcGUuYWN0aXZlTWVudSA9IG1lbnVJdGVtLm5hbWU7XG4gICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhtZW51SXRlbSk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBtZW51SXRlbS5ocmVmO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICRzY29wZS5jZW50ZXIobWVudUl0ZW0ubmFtZSk7XG4gICAgICAgICAgJHNjb3BlLnNvbWVDdHJsRm4oe21lbnVsaW5rczogbWVudUl0ZW19KTtcbiAgICAgIH07XG5cbiAgICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKXtcbiAgICAgICAgJHNjb3BlLmNlbnRlcigpO1xuICAgICAgfSk7XG4gICAgICAkc2NvcGUuY2VudGVyID0gZnVuY3Rpb24obWVudUl0ZW0pIHtcbiAgICAgICAgdmFyIG5hdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2MVwiKTtcbiAgICAgICAgdmFyIG5hdldpZHRoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJuYXYyXCIpLm9mZnNldFdpZHRoO1xuICAgICAgICB2YXIgY3VycmVudEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbmFtZT1cIicrbWVudUl0ZW0rJ1wiXScpO1xuICAgICAgICBjdXJyZW50RWxlbWVudCA9IG1lbnVJdGVtID8gY3VycmVudEVsZW1lbnRbMF0gOiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhY3RpdmUnKVswXTtcbiAgICAgICAgaWYoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgbWFyZ2luID0gMDtcbiAgICAgICAgICB2YXIgbGVubSA9IG5hdi5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yKHZhciBpID0wOyBpPGxlbm07IGkrKyl7XG5cbiAgICAgICAgICAgIGlmKGN1cnJlbnRFbGVtZW50ID09IG5hdi5jaGlsZHJlbltpXSl7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICBtYXJnaW4gKz0gbmF2LmNoaWxkcmVuW2ldLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuYXYuc3R5bGUubWFyZ2luTGVmdCA9IChuYXZXaWR0aC8yIC0gbWFyZ2luIC0gY3VycmVudEVsZW1lbnQub2Zmc2V0V2lkdGgvMikgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5hdi5zdHlsZS5tYXJnaW5MZWZ0ID0gKG5hdldpZHRoLzIgLSAkc2NvcGUuYWN0aXZlTWVudS5sZW5ndGgpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBfbGVuID0gJHNjb3BlLm1lbnVsaW5rcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLm1lbnVsaW5rc1tpXS5ocmVmID09ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAgICAgICAkc2NvcGUuYWN0aXZlTWVudSA9ICRzY29wZS5tZW51bGlua3NbaV0ubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHNjb3BlLmFjdGl2ZU1lbnUgPSBcIlRyZW5kaW5nXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8kc2NvcGUuY2VudGVyKCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuY2VudGVyKCk7XG4gICAgICB9LCA1MCk7XG4gICAgfV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG1lbnVsaW5rczogJz0nLFxuICAgICAgICBzb21lQ3RybEZuOiAnJmNhbGxiYWNrRm4nXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlcjogY29udHJvbGxlcixcbiAgICAgIHRlbXBsYXRlOiBcIjx1bCBpZD0nbmF2MSc+XCIrXG4gICAgICAgICAgICAgIFwiPGxpIG5nLXJlcGVhdD0nbWVudWxpbmtzIGluIG1lbnVsaW5rcycgbmFtZT0ne3ttZW51bGluay5uYW1lfX0nIGNsYXNzPSd0b3Age3ttZW51bGluay5yb2xlfX0nIG5nLWNsYXNzPSd7YWN0aXZlIDogYWN0aXZlTWVudSA9PT0gbWVudWxpbmsubmFtZX0nPlwiK1xuICAgICAgICAgICAgICAgIFwiPGEgb24tdGFwPSdhZGRhY3RpdmVjbGFzcyhtZW51bGluayknPlwiK1xuICAgICAgICAgICAgICAgICAgXCJ7e21lbnVsaW5rLm5hbWV9fVwiXG4gICAgICAgICAgICAgICAgK1wiPC9hPlwiK1xuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nYXJyb3cnPjwvZGl2PlwiK1xuICAgICAgICAgICAgICAgIFwiPC9saT5cIlxuICAgICAgICAgICAgK1wiPC91bD5cIlxuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIFNpbXBsZVB1YlN1YigpIHtcbiAgICAgIHZhciBldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgb246IGZ1bmN0aW9uKG5hbWVzLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIG5hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c1tuYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZXZlbnRzW25hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGV2ZW50c1tuYW1lXSwgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfTtcblxuICBhcHAuZGlyZWN0aXZlKCdvbkZpbmlzaFJlbmRlcicsIGZ1bmN0aW9uICgkdGltZW91dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cikge1xuICAgICAgICAgICAgICBpZiAoc2NvcGUuJGxhc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY29wZS4kZW1pdCgnbmdSZXBlYXRGaW5pc2hlZCcpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gIH0pXG4gIGFwcC5kaXJlY3RpdmUoJ2NsaWNrSGFuZGxlcicsIGZ1bmN0aW9uKCR0aW1lb3V0KXtcbiAgICAgIHJldHVybntcbiAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsJGF0dHIpe1xuICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICRlbGVtZW50Lm9uKCd0YXAnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gcGVyZm9ybSBvbiB0YXBcbiAgICAgICAgYWxlcnQoXCJKdXN0IGJlZW4gQ2xpY2tlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfSlcbiAgYXBwLmRpcmVjdGl2ZSgndGFiU2xpZGVCb3gnLCBbICckdGltZW91dCcsICckd2luZG93JywgJyRpb25pY1NsaWRlQm94RGVsZWdhdGUnLCAnJGlvbmljU2Nyb2xsRGVsZWdhdGUnLCAnJHJvb3RTY29wZScsXG4gICAgZnVuY3Rpb24oJHRpbWVvdXQsICR3aW5kb3csICRpb25pY1NsaWRlQm94RGVsZWdhdGUsICRpb25pY1Njcm9sbERlbGVnYXRlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0IDogJ0EsIEUsIEMnLFxuICAgICAgICBsaW5rIDogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBuZ01vZGVsKSB7XG5cbiAgICAgICAgICB2YXIgdGEgPSBlbGVtZW50WzBdLCAkdGEgPSBlbGVtZW50O1xuICAgICAgICAgICR0YS5hZGRDbGFzcyhcInRhYmJlZC1zbGlkZWJveFwiKTtcbiAgICAgICAgICBpZihhdHRycy50YWJzUG9zaXRpb24gPT09IFwiYm90dG9tXCIpe1xuICAgICAgICAgICAgJHRhLmFkZENsYXNzKFwiYnRtXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vSGFuZGxlIG11bHRpcGxlIHNsaWRlL3Njcm9sbCBib3hlc1xuICAgICAgICAgIHZhciBoYW5kbGUgPSB0YS5xdWVyeVNlbGVjdG9yKCcuc2xpZGVyJykuZ2V0QXR0cmlidXRlKCdkZWxlZ2F0ZS1oYW5kbGUnKTtcblxuICAgICAgICAgIHZhciBpb25pY1NsaWRlQm94RGVsZWdhdGUgPSAkaW9uaWNTbGlkZUJveERlbGVnYXRlO1xuICAgICAgICAgIGlmKGhhbmRsZSl7XG4gICAgICAgICAgICBpb25pY1NsaWRlQm94RGVsZWdhdGUgPSBpb25pY1NsaWRlQm94RGVsZWdhdGUuJGdldEJ5SGFuZGxlKGhhbmRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlvbmljU2Nyb2xsRGVsZWdhdGUgPSAkaW9uaWNTY3JvbGxEZWxlZ2F0ZTtcbiAgICAgICAgICBpZihoYW5kbGUpe1xuICAgICAgICAgICAgaW9uaWNTY3JvbGxEZWxlZ2F0ZSA9IGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKGhhbmRsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnVuY3Rpb24gcmVuZGVyU2Nyb2xsYWJsZVRhYnMoKXtcbiAgICAgICAgICAgIHZhciBpY29uc0RpdiA9IGFuZ3VsYXIuZWxlbWVudCh0YS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pY29uc1wiKSksIGljb25zID0gaWNvbnNEaXYuZmluZChcImFcIiksIHdyYXAgPSBpY29uc0RpdlswXS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pYy13cnBcIiksIHRvdGFsVGFicyA9IGljb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxEaXYgPSB3cmFwLnF1ZXJ5U2VsZWN0b3IoXCIuc2Nyb2xsXCIpO1xuXG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaWNvbnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpe1xuICAgICAgICAgICAgICAgICB2YXIgYSA9IGFuZ3VsYXIuZWxlbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgIGEub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICBpb25pY1NsaWRlQm94RGVsZWdhdGUuc2xpZGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYoYS5hdHRyKCdpY29uLW9mZicpKSB7XG4gICAgICAgICAgICAgICAgYS5hdHRyKFwiY2xhc3NcIiwgYS5hdHRyKCdpY29uLW9mZicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBpbml0aWFsSW5kZXggPSBhdHRycy50YWI7XG4gICAgICAgICAgICAvL0luaXRpYWxpemluZyB0aGUgbWlkZGxlIHRhYlxuICAgICAgICAgICAgaWYodHlwZW9mIGF0dHJzLnRhYiA9PT0gJ3VuZGVmaW5lZCcgfHwgKHRvdGFsVGFicyA8PSBpbml0aWFsSW5kZXgpIHx8IGluaXRpYWxJbmRleCA8IDApe1xuICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSBNYXRoLmZsb29yKGljb25zLmxlbmd0aC8yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9JZiBpbml0aWFsIGVsZW1lbnQgaXMgMCwgc2V0IHBvc2l0aW9uIG9mIHRoZSB0YWIgdG8gMHRoIHRhYlxuICAgICAgICAgICAgaWYoaW5pdGlhbEluZGV4ID09IDApe1xuICAgICAgICAgICAgICBzZXRQb3NpdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2coJ2luaXRpYWxJbmRleCAnK2luaXRpYWxJbmRleCk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2ZlZWQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAwfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICd0cmVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDB9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2hvdCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY3JlYXRlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMn0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnYWN0aXZlJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAzfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdwcm9tb3RlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmczMCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndm90ZXMnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDZ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NoaWxkcmVuJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA3fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjYXNob3V0Jyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA4fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICd0cmVuZGluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDB9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2hvdCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY3JlYXRlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMn0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnYWN0aXZlJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAzfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdwcm9tb3RlZCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmczMCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogNX0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndm90ZXMnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDZ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NoaWxkcmVuJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA3fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjYXNob3V0Jyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA4fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlvbmljU2xpZGVCb3hEZWxlZ2F0ZS5zbGlkZShpbml0aWFsSW5kZXgpO1xuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKGluZGV4KXtcbiAgICAgICAgICAgIHZhciBpY29uc0RpdiA9IGFuZ3VsYXIuZWxlbWVudCh0YS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pY29uc1wiKSksIGljb25zID0gaWNvbnNEaXYuZmluZChcImFcIiksIHdyYXAgPSBpY29uc0RpdlswXS5xdWVyeVNlbGVjdG9yKFwiLnRzYi1pYy13cnBcIiksIHRvdGFsVGFicyA9IGljb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzY3JvbGxEaXYgPSB3cmFwLnF1ZXJ5U2VsZWN0b3IoXCIuc2Nyb2xsXCIpO1xuXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gaWNvbnNEaXZbMF0ub2Zmc2V0V2lkdGgvMjtcbiAgICAgICAgICAgIHZhciBjdXJFbCA9IGFuZ3VsYXIuZWxlbWVudChpY29uc1tpbmRleF0pO1xuICAgICAgICAgICAgdmFyIHBydkVsID0gYW5ndWxhci5lbGVtZW50KGljb25zRGl2WzBdLnF1ZXJ5U2VsZWN0b3IoXCIuYWN0aXZlXCIpKTtcbiAgICAgICAgICAgIGlmKGN1ckVsICYmIGN1ckVsLmxlbmd0aCl7XG4gICAgICAgICAgICAgIHZhciBjdXJFbFdpZHRoID0gY3VyRWxbMF0ub2Zmc2V0V2lkdGgsIGN1ckVsTGVmdCA9IGN1ckVsWzBdLm9mZnNldExlZnQ7XG5cbiAgICAgICAgICAgICAgaWYocHJ2RWwuYXR0cignaWNvbi1vZmYnKSkge1xuICAgICAgICAgICAgICAgIHBydkVsLmF0dHIoXCJjbGFzc1wiLCBwcnZFbC5hdHRyKCdpY29uLW9mZicpKTtcbiAgICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIHBydkVsLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGN1ckVsLmF0dHIoJ2ljb24tb24nKSkge1xuICAgICAgICAgICAgICAgIGN1ckVsLmF0dHIoXCJjbGFzc1wiLCBjdXJFbC5hdHRyKCdpY29uLW9uJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1ckVsLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xuXG4gICAgICAgICAgICAgIHZhciBsZWZ0U3RyID0gKG1pZGRsZSAgLSAoY3VyRWxMZWZ0KSAtICBjdXJFbFdpZHRoLzIgKyA1KTtcbiAgICAgICAgICAgICAgLy9JZiB0YWJzIGFyZSBub3Qgc2Nyb2xsYWJsZVxuICAgICAgICAgICAgICBpZighc2Nyb2xsRGl2KXtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFN0ciA9IChtaWRkbGUgIC0gKGN1ckVsTGVmdCkgLSAgY3VyRWxXaWR0aC8yICsgNSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgd3JhcC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAgXCJ0cmFuc2xhdGUzZChcIitsZWZ0U3RyK1wiLDAsMClcIiA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9JZiBzY3JvbGxhYmxlIHRhYnNcbiAgICAgICAgICAgICAgICB2YXIgd3JhcFdpZHRoID0gd3JhcC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFggPSBNYXRoLmFicyhnZXRYKHNjcm9sbERpdi5zdHlsZS53ZWJraXRUcmFuc2Zvcm0pKTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdE9mZnNldCA9IDEwMDtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IDU0O1xuICAgICAgICAgICAgICAgIC8vSWYgdGFicyBhcmUgcmVhY2hpbmcgcmlnaHQgZW5kIG9yIGxlZnQgZW5kXG4gICAgICAgICAgICAgICAgaWYoKChjdXJyZW50WCArIHdyYXBXaWR0aCkgPCAoY3VyRWxMZWZ0ICsgY3VyRWxXaWR0aCArIGVsZW1lbnRPZmZzZXQpKSB8fCAoY3VycmVudFggPiAoY3VyRWxMZWZ0IC0gbGVmdE9mZnNldCkpKXtcbiAgICAgICAgICAgICAgICAgIGlmKGxlZnRTdHIgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFN0ciA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvL1VzZSB0aGlzIHNjcm9sbFRvLCBzbyB3aGVuIHNjcm9sbGluZyB0YWIgbWFudWFsbHkgd2lsbCBub3QgZmxpY2tlclxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaW9uaWNTY3JvbGxEZWxlZ2F0ZS5zY3JvbGxUbyhNYXRoLmFicyhsZWZ0U3RyKSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYobGVmdFN0ciA+IDApe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0U3RyID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlvbmljU2Nyb2xsRGVsZWdhdGUuc2Nyb2xsVG8oTWF0aC5hYnMobGVmdFN0ciksIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0WChtYXRyaXgpIHtcblxuICAgICAgICAgICAgbWF0cml4ID0gbWF0cml4LnJlcGxhY2UoXCJ0cmFuc2xhdGUzZChcIixcIlwiKTtcbiAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5yZXBsYWNlKFwidHJhbnNsYXRlKFwiLFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIChwYXJzZUludChtYXRyaXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IHNjb3BlLmV2ZW50cztcbiAgICAgICAgICBldmVudHMub24oJ3NsaWRlQ2hhbmdlJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZXRQb3NpdGlvbihkYXRhLmluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudHMub24oJ25nUmVwZWF0RmluaXNoZWQnLCBmdW5jdGlvbihuZ1JlcGVhdEZpbmlzaGVkRXZlbnQpIHtcbiAgICAgICAgICAgIHJlbmRlclNjcm9sbGFibGVUYWJzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlclNjcm9sbGFibGVUYWJzKCk7XG4gICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRyb2xsZXIgOiBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgJGVsZW1lbnQsICRyb290U2NvcGUpIHtcbiAgICAgICAgICAkc2NvcGUuZXZlbnRzID0gbmV3IFNpbXBsZVB1YlN1YigpO1xuICAgICAgICAgICRzY29wZS5zbGlkZUhhc0NoYW5nZWQgPSBmdW5jdGlvbihpbmRleCl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNsaWRlQ2hhbmdlZCBcIitpbmRleCk7XG4gICAgICAgICAgICAkc2NvcGUuY3VycmVudFNsaWRlID0gaW5kZXg7XG4gICAgICAgICAgICAkc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogaW5kZXh9KTtcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCRzY29wZS5vblNsaWRlTW92ZSkge1xuICAgICAgICAgICAgICAgICRzY29wZS5vblNsaWRlTW92ZSh7XCJpbmRleFwiIDogZXZhbChpbmRleCl9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2ZlZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndHJlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnaG90JztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2NyZWF0ZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnYWN0aXZlJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3Byb21vdGVkJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDYpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3RyZW5kaW5nMzAnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndm90ZXMnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2hpbGRyZW4nO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2FzaG91dCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICd0cmVuZGluZyc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdob3QnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY3JlYXRlZCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdhY3RpdmUnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAncHJvbW90ZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndHJlbmRpbmczMCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICd2b3Rlcyc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjaGlsZHJlbic7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjYXNob3V0JztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkc2NvcGUuJG9uKCduZ1JlcGVhdEZpbmlzaGVkJywgZnVuY3Rpb24obmdSZXBlYXRGaW5pc2hlZEV2ZW50KSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnbmdSZXBlYXRGaW5pc2hlZCcpO1xuICAgICAgICAgICAgJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwibmdSZXBlYXRGaW5pc2hlZFwiLCB7XCJldmVudFwiIDogbmdSZXBlYXRGaW5pc2hlZEV2ZW50fSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICB9XG4gIF0pO1xuXG5cdGFwcC5maWx0ZXIoJ3RpbWVhZ28nLCBmdW5jdGlvbigkZmlsdGVyLCAkdHJhbnNsYXRlLCAkcm9vdFNjb3BlKSB7XG5cbiAgICAgIGZ1bmN0aW9uIFRpbWVBZ28oaW5wdXQsIHBfYWxsb3dGdXR1cmUpIHtcbiAgICAgICAgdmFyIHN1YnN0aXR1dGUgPSBmdW5jdGlvbiAoc3RyaW5nT3JGdW5jdGlvbiwgbnVtYmVyLCBzdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IGFuZ3VsYXIuaXNGdW5jdGlvbihzdHJpbmdPckZ1bmN0aW9uKSA/IHN0cmluZ09yRnVuY3Rpb24obnVtYmVyLCBkYXRlRGlmZmVyZW5jZSkgOiBzdHJpbmdPckZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IChzdHJpbmdzLm51bWJlcnMgJiYgc3RyaW5ncy5udW1iZXJzW251bWJlcl0pIHx8IG51bWJlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyVkL2ksIHZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3dUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGRhdGUgPSAobmV3IERhdGUoaW5wdXQpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAvL3JlZnJlc2hNaWxsaXM9IDZlNCwgLy9BIG1pbnV0ZVxuICAgICAgICAgICAgYWxsb3dGdXR1cmUgPSBwX2FsbG93RnV0dXJlIHx8IGZhbHNlLFxuICAgICAgICAgICAgc3RyaW5ncz0ge1xuICAgICAgICAgICAgICAgIHByZWZpeEFnbzogJycsXG4gICAgICAgICAgICAgICAgcHJlZml4RnJvbU5vdzogJycsXG4gICAgICAgICAgICAgICAgc3VmZml4QWdvOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUdPJyksXG4gICAgICAgICAgICAgICAgc3VmZml4RnJvbU5vdzogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZST01fTk9XJyksXG4gICAgICAgICAgICAgICAgc2Vjb25kczogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFQ1MnKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBX01JTicpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXM6IFwiJWQgXCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ01JTlMnKSxcbiAgICAgICAgICAgICAgICBob3VyOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQU5fSE9VUicpLFxuICAgICAgICAgICAgICAgIGhvdXJzOiBcIiVkIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdIT1VSUycpLFxuICAgICAgICAgICAgICAgIGRheTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FfREFZJyksXG4gICAgICAgICAgICAgICAgZGF5czogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnREFZUycpLFxuICAgICAgICAgICAgICAgIG1vbnRoOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQV9NT05USCcpLFxuICAgICAgICAgICAgICAgIG1vbnRoczogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnTU9OVEhTJyksXG4gICAgICAgICAgICAgICAgeWVhcjogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FfWUVBUicpLFxuICAgICAgICAgICAgICAgIHllYXJzOiBcIiVkIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdZRUFSUycpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0ZURpZmZlcmVuY2UgPSBub3dUaW1lIC0gZGF0ZSxcbiAgICAgICAgICAgIHdvcmRzLFxuICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGguYWJzKGRhdGVEaWZmZXJlbmNlKSAvIDEwMDAsXG4gICAgICAgICAgICBtaW51dGVzID0gc2Vjb25kcyAvIDYwLFxuICAgICAgICAgICAgaG91cnMgPSBtaW51dGVzIC8gNjAsXG4gICAgICAgICAgICBkYXlzID0gaG91cnMgLyAyNCxcbiAgICAgICAgICAgIHllYXJzID0gZGF5cyAvIDM2NSxcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IHN0cmluZ3Mud29yZFNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gIFwiIFwiIDogc3RyaW5ncy53b3JkU2VwYXJhdG9yLFxuXG5cbiAgICAgICAgICAgIHByZWZpeCA9IHN0cmluZ3MucHJlZml4QWdvLFxuICAgICAgICAgICAgc3VmZml4ID0gc3RyaW5ncy5zdWZmaXhBZ287XG5cbiAgICAgICAgaWYgKGFsbG93RnV0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZURpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gc3RyaW5ncy5wcmVmaXhGcm9tTm93O1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHN0cmluZ3Muc3VmZml4RnJvbU5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmRzID0gc2Vjb25kcyA8IDQ1ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5zZWNvbmRzLCBNYXRoLnJvdW5kKHNlY29uZHMpLCBzdHJpbmdzKSB8fFxuICAgICAgICBzZWNvbmRzIDwgOTAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLm1pbnV0ZSwgMSwgc3RyaW5ncykgfHxcbiAgICAgICAgbWludXRlcyA8IDQ1ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5taW51dGVzLCBNYXRoLnJvdW5kKG1pbnV0ZXMpLCBzdHJpbmdzKSB8fFxuICAgICAgICBtaW51dGVzIDwgOTAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmhvdXIsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIGhvdXJzIDwgMjQgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmhvdXJzLCBNYXRoLnJvdW5kKGhvdXJzKSwgc3RyaW5ncykgfHxcbiAgICAgICAgaG91cnMgPCA0MiAmJiBzdWJzdGl0dXRlKHN0cmluZ3MuZGF5LCAxLCBzdHJpbmdzKSB8fFxuICAgICAgICBkYXlzIDwgMzAgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmRheXMsIE1hdGgucm91bmQoZGF5cyksIHN0cmluZ3MpIHx8XG4gICAgICAgIGRheXMgPCA0NSAmJiBzdWJzdGl0dXRlKHN0cmluZ3MubW9udGgsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIGRheXMgPCAzNjUgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLm1vbnRocywgTWF0aC5yb3VuZChkYXlzIC8gMzApLCBzdHJpbmdzKSB8fFxuICAgICAgICB5ZWFycyA8IDEuNSAmJiBzdWJzdGl0dXRlKHN0cmluZ3MueWVhciwgMSwgc3RyaW5ncykgfHxcbiAgICAgICAgc3Vic3RpdHV0ZShzdHJpbmdzLnllYXJzLCBNYXRoLnJvdW5kKHllYXJzKSwgc3RyaW5ncyk7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2cocHJlZml4K3dvcmRzK3N1ZmZpeCtzZXBhcmF0b3IpO1xuICAgICAgICBwcmVmaXgucmVwbGFjZSgvIC9nLCAnJylcbiAgICAgICAgd29yZHMucmVwbGFjZSgvIC9nLCAnJylcbiAgICAgICAgc3VmZml4LnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgIHJldHVybiAocHJlZml4KycgJyt3b3JkcysnICcrc3VmZml4KycgJytzZXBhcmF0b3IpO1xuXG4gICAgICB9O1xuXG4gICAgICBUaW1lQWdvLiRzdGF0ZWZ1bCA9IHRydWU7XG4gICAgICByZXR1cm4gVGltZUFnbztcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ3BhcnNlVXJsJywgZnVuY3Rpb24oJHNjZSkge1xuXHQgICAgdmFyIHVybHMgPSAvKFxcYihodHRwcz98ZnRwKTpcXC9cXC9bQS1aMC05KyZAI1xcLyU/PX5ffCE6LC47LV0qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW07XG5cdCAgICB2YXIgZW1haWxzID0gLyhcXHcrQFthLXpBLVpfXSs/XFwuW2EtekEtWl17Miw2fSkvZ2ltO1xuICBcdCBcdHZhciBpbWdzID0gLyhodHRwcz86XFwvXFwvLipcXC4oPzpwbmd8anBnfGpwZWd8Z2lmKSkvZ2ltO1xuICBcdFx0dmFyIHlvdXR1YmUgPSAvXi4qKCh5b3V0dS5iZVxcLyl8KHZcXC8pfChcXC91XFwvXFx3XFwvKXwoZW1iZWRcXC8pfCh3YXRjaFxcPykpXFw/P3Y/PT8oW14jXFwmXFw/XSopLiovO1xuICBcdFx0dmFyIHlvdXR1YmVpZCA9IC8oPzooPzp5b3V0dWJlLmNvbVxcL3dhdGNoXFw/dj0pfCg/OnlvdXR1LmJlXFwvKSkoW0EtWmEtejAtOVxcX1xcLV0rKS9pO1xuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUsIHN1YnBhcnQpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIFx0Z2ZtOiB0cnVlLFxuXHRcdFx0ICAgIHRhYmxlczogdHJ1ZSxcbiAgICAgICAgICBzbWFydExpc3RzOiB0cnVlLFxuXHRcdFx0ICAgIGJyZWFrczogdHJ1ZSxcblx0XHRcdCAgICBwZWRhbnRpYzogZmFsc2UsXG5cdFx0XHQgICAgc2FuaXRpemU6IGZhbHNlLFxuXHRcdFx0ICAgIHNtYXJ0TGlzdHM6IHRydWUsXG5cdFx0XHQgICAgc21hcnR5cGFudHM6IGZhbHNlXG5cdFx0XHQgIH07XG4gICAgICAgIGlmICh0ZXh0dSkge1xuICAgICAgICAgIHZhciB0ZXh0dSA9IG1hcmtlZCh0ZXh0dSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHN1YnBhcnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gJHNjZS50cnVzdEFzSHRtbCh0ZXh0dSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gcy5zdWJzdHJpbmcocy5pbmRleE9mKFwiPHA+XCIpLCBzLmluZGV4T2YoXCI8L3A+XCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbCh0ZXh0dSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cdCAgICB9O1xuXHR9KTtcblxuICAgIGFwcC5maWx0ZXIoJ21ldGFkYXRhJywgZnVuY3Rpb24oJHNjZSkge1xuICAgICAgICB2YXIgdXJscyA9IC8oXFxiKGh0dHBzP3xmdHApOlxcL1xcL1tBLVowLTkrJkAjXFwvJT89fl98ITosLjstXSpbLUEtWjAtOSsmQCNcXC8lPX5ffF0pL2dpbTtcbiAgICAgICAgdmFyIHVzZXJzID0gLyhefFxccykoQFthLXpdWy1cXC5hLXpcXGRdK1thLXpcXGRdKS9naW07XG4gICAgICAgIHZhciBpbWdzID0gLyhodHRwcz86XFwvXFwvLipcXC4oPzpwbmd8anBnfGpwZWd8Z2lmKSkvZ2ltO1xuICAgICAgICB2YXIgeW91dHViZSA9IC9eLiooKHlvdXR1LmJlXFwvKXwodlxcLyl8KFxcL3VcXC9cXHdcXC8pfChlbWJlZFxcLyl8KHdhdGNoXFw/KSlcXD8/dj89PyhbXiNcXCZcXD9dKikuKi87XG4gICAgICAgIHZhciB5b3V0dWJlaWQgPSAvKD86KD86eW91dHViZS5jb21cXC93YXRjaFxcP3Y9KXwoPzp5b3V0dS5iZVxcLykpKFtBLVphLXowLTlcXF9cXC1dKykvaTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtdXJscyA9IHRleHR1Lm1hdGNoKHVybHMpO1xuICAgICAgICAgICAgdmFyIG11c2VycyA9IHRleHR1Lm1hdGNoKHVzZXJzKTtcbiAgICAgICAgICAgIHZhciBtaW1ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIG1saW5rcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG11cmxzKSB7XG4gICAgICAgICAgICAgIHZhciBfbGVuID0gbXVybHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmQgPSBtdXJsc1tpXS5tYXRjaChpbWdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZ3MucHVzaChtdXJsc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtbGlua3MucHVzaChtdXJsc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1saW5rcykge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKG91dCwge2xpbmtzOiBtbGlua3N9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1pbWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2Uob3V0LCB7aW1hZ2U6IG1pbWdzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG11c2Vycykge1xuICAgICAgICAgICAgICB2YXIgX2xlbiA9IG11c2Vycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbXVzZXJzW2ldID0gbXVzZXJzW2ldLnRyaW0oKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZShvdXQsIHt1c2VyczogbXVzZXJzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ21ldGFkYXRhVXNlcnMnLCBmdW5jdGlvbigkc2NlKSB7XG4gICAgICAgIHZhciB1c2VycyA9IC8oXnxcXHMpKEBbYS16XVstXFwuYS16XFxkXStbYS16XFxkXSkvZ2ltO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dHUpIHtcbiAgICAgICAgICBpZiAodGV4dHUpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBtdXNlcnMgPSB0ZXh0dS5tYXRjaCh1c2Vycyk7XG5cbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKG11c2VycykpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGV4dHU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgYXBwLmZpbHRlcignbGRvdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQrJy4uLic7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgYXBwLmZpbHRlcigncmVnZXgnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihpbnB1dCwgZmllbGQsIHJlZ2V4KSB7XG4gICAgICAgICAgdmFyIHBhdHQgPSBuZXcgUmVnRXhwKHJlZ2V4KTsgICAgICBcbiAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBhdHQudGVzdChpbnB1dFtpXVtmaWVsZF0pKTtcbiAgICAgICAgICAgIGlmKCFwYXR0LnRlc3QoaW5wdXRbaV1bZmllbGRdKSlcbiAgICAgICAgICAgICAgb3V0LnB1c2goaW5wdXRbaV0pO1xuICAgICAgICAgIH0gICAgICBcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgYXBwLmZpbHRlcignZGV0cmFuc2xpdGVyYXRlJywgZnVuY3Rpb24oKXtcbiAgICAgIC8vIGNvcHlwYXN0ZSBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RhbXIvNWZiMDBhMWM2MjE0ZjVjYWI0ZjZcbiAgICAgIC8vIChpdCBoYXZlIGJlZW4gbW9kaWZpZWQ6INC40LkgPiBpeSBhbmQgc28gb24pXG4gICAgICAvLyB0aGlzIGhhdmUgYmVlbiBkb25lIGJlZWNhdXNlIHdlIGNhbm5vdCB1c2Ugc3BlY2lhbCBzeW1ib2xzIGluIHVybCAoYGAgYW5kICcnKVxuICAgICAgLy8gYW5kIHVybCBzZWVtcyB0byBiZSB0aGUgb25seSBzb3VyY2Ugb2YgdGhydXRoXG4gICAgICB2YXIgZCA9IC9cXHMrL2csXG4gICAgICAvL3J1cyA9IFwi0YkgINGIINGHINGGINGOINGOINGPINGPICDRi9C1INC40LkgINGRINGRINC2INGKINGNINGLINCwINCxINCyINCzINC0INC1INC3INC4INC5INC6INC7INC8INC9INC+INC/INGAINGBINGCINGDINGEINGFINGFICAg0YxcIi5zcGxpdChkKSxcbiAgICAgIC8vZW5nID0gXCJzY2ggIHNoICBjaCAgY3ogIHl1ICBqdSAgeWEgIHEgIHlpZSAgaXkgIHlvICBqbyAgemggIHcgeWUgIHkgYSBiIHYgZyBkIGUgeiBpIHlpICBrIGwgbSBuIG8gcCByIHMgdCB1IGYgeCBoIGpcIi5zcGxpdChkKTtcblxuICAgICAgcnVzID0gXCLRiSAgICDRiCAg0YcgINGGICDQuSAg0ZEgINGNICDRjiAg0Y8gINGFICDQtiAg0LAg0LEg0LIg0LMg0LQg0LUg0Lcg0Lgg0Log0Lsg0Lwg0L0g0L4g0L8g0YAg0YEg0YIg0YMg0YQg0YogINGLINGMXCIuc3BsaXQoZCksXG4gICAgICBlbmcgPSBcInNoY2ggc2ggY2ggY3ogaWogeW8geWUgeXUgeWEga2ggemggYSBiIHYgZyBkIGUgeiBpIGsgbCBtIG4gbyBwIHIgcyB0IHUgZiB4eCB5IHhcIi5zcGxpdChkKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCByZXZlcnNlKSB7XG4gICAgICAgIGlmICghc3RyKSByZXR1cm4gc3RyO1xuICAgICAgICBpZiAoIXJldmVyc2UgJiYgc3RyLnN1YnN0cmluZygwLCA0KSAhPT0gJ3J1LS0nKSByZXR1cm4gc3RyO1xuICAgICAgICBpZiAoIXJldmVyc2UpIHN0ciA9IHN0ci5zdWJzdHJpbmcoNClcblxuICAgICAgICAvLyBUT0RPIHJld29yayB0aGlzXG4gICAgICAgIC8vIChkaWRudCBwbGFjZWQgdGhpcyBlYXJsaWVyIGJlY2F1c2Ugc29tZXRoaW5nIGlzIGJyZWFraW5nIGFuZCBpIGFtIHRvbyBsYXp5IHRvIGZpZ3VyZSBpdCBvdXQgOyggKVxuICAgICAgICBpZighcmV2ZXJzZSkge1xuICAgICAgICAvLyAgICBzdHIgPSBzdHIucmVwbGFjZSgvai9nLCAn0YwnKVxuICAgICAgICAvLyAgICBzdHIgPSBzdHIucmVwbGFjZSgvdy9nLCAn0YonKVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL3lpZS9nLCAn0YvQtScpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgIC8vICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/RjC9nLCAnaicpXG4gICAgICAgIC8vICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/Rii9nLCAndycpXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgv0YvQtS9nLCAneWllJylcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgcyA9IC9bXltcXF1dKyg/PV0pL2csIG9yaWcgPSBzdHIubWF0Y2gocyksXG4gICAgICAgICAgICB0ID0gLzwoLnxcXG4pKj8+L2csIHRhZ3MgPSBzdHIubWF0Y2godCk7XG5cbiAgICAgICAgaWYocmV2ZXJzZSkge1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcnVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KHJ1c1tpXSkuam9pbihlbmdbaV0pO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdChydXNbaV0udG9VcHBlckNhc2UoKSkuam9pbihlbmdbaV0udG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBydXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoZW5nW2ldKS5qb2luKHJ1c1tpXSk7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KGVuZ1tpXS50b1VwcGVyQ2FzZSgpKS5qb2luKHJ1c1tpXS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9yaWcpIHtcbiAgICAgICAgICAgIHZhciByZXN0b3JlT3JpZyA9IHN0ci5tYXRjaChzKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3RvcmVPcmlnLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJlc3RvcmVPcmlnW2ldLCBvcmlnW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN0b3JlVGFncyA9IHN0ci5tYXRjaCh0KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3RvcmVUYWdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJlc3RvcmVUYWdzW2ldLCB0YWdzW2ldKTtcblxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcWy9nLCAnJykucmVwbGFjZSgvXFxdL2csICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSlcbiAgICAgYXBwLmZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnLCBmdW5jdGlvbigkZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGV4dC5zcGxpdCgnLScpWzFdKTtcbiAgICAgICAgICAgIC8vdmFyIHggPSB0ZXh0LnNwbGl0KCctJylbMV07XG4gICAgICAgICAgICAvL3ZhciB0dCA9ICRmaWx0ZXIoJ3VwcGVyY2FzZScpKHgpO1xuICAgICAgICAgICAgdmFyIHRleHR1ID0gd2luZG93LmdldFN5bWJvbCh0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dT09XCI/XCI/dGV4dDp0ZXh0dTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gYW5zaVdvcmRCb3VuZChjKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICgnICcgPT09IGMpIHx8XG4gICAgICAoJ1xcbicgPT09IGMpIHx8XG4gICAgICAoJ1xccicgPT09IGMpIHx8XG4gICAgICAoJ1xcdCcgPT09IGMpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZGluZ1RpbWUodGV4dCwgb3B0aW9ucykge1xuICAgIHZhciB3b3JkcyA9IDAsIHN0YXJ0ID0gMCwgZW5kID0gdGV4dC5sZW5ndGggLSAxLCB3b3JkQm91bmQsIGlcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICAvLyB1c2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVjZXNzYXJ5XG4gICAgb3B0aW9ucy53b3Jkc1Blck1pbnV0ZSA9IG9wdGlvbnMud29yZHNQZXJNaW51dGUgfHwgMjAwXG5cbiAgICAvLyB1c2UgcHJvdmlkZWQgZnVuY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgd29yZEJvdW5kID0gb3B0aW9ucy53b3JkQm91bmQgfHwgYW5zaVdvcmRCb3VuZFxuXG4gICAgLy8gZmV0Y2ggYm91bmRzXG4gICAgd2hpbGUgKHdvcmRCb3VuZCh0ZXh0W3N0YXJ0XSkpIHN0YXJ0KytcbiAgICB3aGlsZSAod29yZEJvdW5kKHRleHRbZW5kXSkpIGVuZC0tXG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIG51bWJlciBvZiB3b3Jkc1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDw9IGVuZDspIHtcbiAgICAgIGZvciAoOyBpIDw9IGVuZCAmJiAhd29yZEJvdW5kKHRleHRbaV0pOyBpKyspIDtcbiAgICAgIHdvcmRzKytcbiAgICAgIGZvciAoOyBpIDw9IGVuZCAmJiB3b3JkQm91bmQodGV4dFtpXSk7IGkrKykgO1xuICAgIH1cblxuICAgIC8vIHJlYWRpbmcgdGltZSBzdGF0c1xuICAgIHZhciBtaW51dGVzID0gd29yZHMgLyBvcHRpb25zLndvcmRzUGVyTWludXRlXG4gICAgdmFyIHRpbWUgPSBtaW51dGVzICogNjAgKiAxMDAwXG4gICAgdmFyIGRpc3BsYXllZCA9IE1hdGguY2VpbChtaW51dGVzLnRvRml4ZWQoMikpXG5cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogZGlzcGxheWVkICsgJyBtaW4gcmVhZCcsXG4gICAgICBtaW51dGVzOiBNYXRoLmNlaWwobWludXRlcy50b0ZpeGVkKDIpKSxcbiAgICAgIHRpbWU6IHRpbWUsXG4gICAgICB3b3Jkczogd29yZHNcbiAgICB9XG4gIH1cblxuICBhcHAuZmlsdGVyKCdyZWFkaW5ndGltZScsIGZ1bmN0aW9uKCRzY2UsICRyb290U2NvcGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRpbmdUaW1lKHRleHQpLm1pbnV0ZXM7XG4gICAgICAgIH1cbiAgICAgIH07XG4gIH0pXG5cblx0YXBwLmZpbHRlcignc3AnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuXHQgICAgXHRpZiAodGV4dCkge1xuXHQgICAgXHRcdHJldHVybiAoTnVtYmVyKHRleHQuc3BsaXQoXCIgXCIpWzBdKS8xZTYqJHJvb3RTY29wZS4kc3RvcmFnZS5zdGVlbV9wZXJfbXZlc3RzKS50b0ZpeGVkKDMpO1xuXHQgICAgXHR9XG5cdCAgICB9O1xuXHR9KVxuXHRhcHAuZmlsdGVyKCdzZCcsIGZ1bmN0aW9uKCRzY2UsICRyb290U2NvcGUpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbih0ZXh0LCBiYWxhbmNlLCBzYmQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKChOdW1iZXIodGV4dC5zcGxpdChcIiBcIilbMF0pLzFlNiokcm9vdFNjb3BlLiRzdG9yYWdlLnN0ZWVtX3Blcl9tdmVzdHMqJHJvb3RTY29wZS4kc3RvcmFnZS5iYXNlICsgTnVtYmVyKGJhbGFuY2Uuc3BsaXQoXCIgXCIpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmJhc2UgKyBOdW1iZXIoc2JkLnNwbGl0KFwiIFwiKVswXSkpLnRvRml4ZWQoMykpKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuXHQgICAgXHR9XG5cdCAgICB9O1xuXHR9KVxuXHRhcHAuZmlsdGVyKCdzYmQnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuXHQgICAgXHRpZiAodGV4dCkge1xuXHQgICAgXHRcdHJldHVybiAoTnVtYmVyKHRleHQuc3BsaXQoXCIgXCIpWzBdKS50b0ZpeGVkKDMpKTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcignc3QnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuXHQgICAgXHRpZiAodGV4dCkge1xuXHQgICAgXHRcdHJldHVybiAoTnVtYmVyKHRleHQuc3BsaXQoXCIgXCIpWzBdKS50b0ZpeGVkKDMpKTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcigncmVwdXRhdGlvbicsIGZ1bmN0aW9uKCl7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBib29sKSB7XG5cdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gMTtcblx0XHRcdG5lZyA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodmFsdWUgPCAwKVxuXHRcdFx0XHRuZWcgPSB0cnVlO1xuXG5cdFx0XHRpZiAodmFsdWUgIT0gMCkge1xuXHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gTWF0aC5sb2cxMChNYXRoLmFicyh2YWx1ZSkpO1xuXHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gTWF0aC5tYXgocmVwdXRhdGlvbl9sZXZlbCAtIDksIDApO1xuXG5cdFx0XHRcdGlmIChyZXB1dGF0aW9uX2xldmVsIDwgMClcblx0XHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gMDtcblx0XHRcdFx0aWYgKG5lZylcblx0XHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsICo9IC0xO1xuXG5cdFx0XHRcdHJlcHV0YXRpb25fbGV2ZWwgPSAocmVwdXRhdGlvbl9sZXZlbCo5KSArIDI1O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBib29sP3JlcHV0YXRpb25fbGV2ZWw6TWF0aC5mbG9vcihyZXB1dGF0aW9uX2xldmVsKTtcblx0XHR9XG5cdH0pXG5cbiAgYXBwLmZpbHRlcihcInN1bVBvc3RUb3RhbFwiLCBmdW5jdGlvbigkcm9vdFNjb3BlKXtcbiAgICBmdW5jdGlvbiBTdW1Qb3N0VG90YWwodmFsdWUsIHJhdGUpIHtcbiAgICAgIC8vY29uc29sZS5sb2codmFsdWUsIHJhdGUpO1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnBlbmRpbmdfcGF5b3V0X3ZhbHVlKSB7XG4gICAgICAgIC8vdmFsdWUudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KFwiIFwiKVswXSkrcGFyc2VGbG9hdCh2YWx1ZS50b3RhbF9wZW5kaW5nX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pXG4gICAgICAgIC8vcmV0dXJuIChwYXJzZUZsb2F0KHZhbHVlLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KFwiIFwiKVswXSkqcmF0ZSk7XG4gICAgICAgIHJldHVybiAoKHBhcnNlRmxvYXQodmFsdWUudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KFwiIFwiKVswXSkpKyhwYXJzZUZsb2F0KHZhbHVlLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KFwiIFwiKVswXSkpKnJhdGUpLnRvRml4ZWQoMik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vU3VtUG9zdFRvdGFsLiRzdGF0ZWZ1bCA9IHRydWU7XG5cbiAgICByZXR1cm4gU3VtUG9zdFRvdGFsO1xuICB9KTtcblxuICBhcHAuZmlsdGVyKFwicmF0ZVwiLCBmdW5jdGlvbigkcm9vdFNjb3BlKXtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQodmFsdWUpKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAgXG5cbiAgYXBwLmZpbHRlcignaHJlZlRvSlMnLCBmdW5jdGlvbiAoJHNjZSwgJHNhbml0aXplKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICB2YXIgcmVnZXggPSAvaHJlZj1cIihbXFxTXSspXCIvZztcbiAgICAgICAgICB2YXIgbmV3U3RyaW5nID0gJHNhbml0aXplKHRleHQpLnJlcGxhY2UocmVnZXgsIFwiaHJlZiBvbkNsaWNrPVxcXCJ3aW5kb3cub3BlbignJDEnLCAnX3N5c3RlbScsICdsb2NhdGlvbj15ZXMnKTtyZXR1cm4gZmFsc2U7XFxcIlwiKTtcbiAgICAgICAgICByZXR1cm4gJHNjZS50cnVzdEFzSHRtbChuZXdTdHJpbmcpO1xuICAgICAgfVxuICB9KTtcblxuICBhcHAuZGlyZWN0aXZlKCdhdXRvZm9jdXMnLCBbJyR0aW1lb3V0JyxcbiAgICBmdW5jdGlvbiAoJHRpbWVvdXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgIGxpbms6IGZ1bmN0aW9uICgkc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XSk7XG5cbiAgYXBwLmRpcmVjdGl2ZSgnc2VsZWN0SW5wdXQnLCBbJyRpb25pY1BvcHVwJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbigkaW9uaWNQb3B1cCwgJHJvb3RTY29wZSkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljOiAnRScsXG4gICAgICBzY29wZToge1xuICAgICAgICBjdXJyZW50SW5wdXQ6ICc9bmdNb2RlbCcsXG4gICAgICAgIHNlbGVjdE9wdGlvbnM6ICc9J1xuICAgICAgfSxcbiAgICAgIHJlcXVpcmU6ICc/Xm5nTW9kZWwnLFxuICAgICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiaXRlbS1pbnB1dCBpdGVtLWljb24tcmlnaHRcIiBzdHlsZT1cIndpZHRoOjEwMCU7XCI+PGlucHV0IG5nLW1vZGVsPVwiY3VycmVudElucHV0XCIgdHlwZT1cInRleHRcIiBuZy1jaGFuZ2U9XCJzb2NrZXRDaGFuZ2UoY3VycmVudElucHV0KVwiPjxpIGNsYXNzPVwiaWNvbiBpb24tYW5kcm9pZC1hcnJvdy1kcm9wZG93blwiIG5nLWNsaWNrPVwic2hvd09wdGlvbnMoKVwiPjwvaT48L2Rpdj4nLFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHNjb3BlLm9wdGlvbnMgPSB7XG4gICAgICAgICAgc2VsZWN0ZWQ6ICcnXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuc29ja2V0Q2hhbmdlID0gZnVuY3Rpb24oeHgpe1xuICAgICAgICAgIGNvbnNvbGUubG9nKHh4KTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl0gPSB4eDtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsID0geHg7XG4gICAgICAgICAgc2NvcGUucmVzdGFydCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuc2hvd09wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkaW9uaWNQb3B1cC5zaG93KHtcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGlvbi1yYWRpbyBuZy1yZXBlYXQ9XCJpdGVtIGluIHNlbGVjdE9wdGlvbnNcIiBjbGFzcz1cIml0ZW0tdGV4dC13cmFwXCIgbmctbW9kZWw9XCJvcHRpb25zLnNlbGVjdGVkXCIgbmctdmFsdWU9XCJpdGVtXCI+e3tpdGVtfX08L2lvbi1yYWRpbz4nLFxuICAgICAgICAgICAgdGl0bGU6ICdTZXJ2ZXInLFxuICAgICAgICAgICAgY3NzQ2xhc3M6ICdteS1jdXN0b20tcG9wdXAnLFxuICAgICAgICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgICAgICAgYnV0dG9uczogW3tcbiAgICAgICAgICAgICAgdGV4dDogJ0NhbmNlbCdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGV4dDogJzxiPkNvbmZpcm08L2I+JyxcbiAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbi1wb3NpdGl2ZScsXG4gICAgICAgICAgICAgIG9uVGFwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuY3VycmVudElucHV0ID0gc2NvcGUub3B0aW9ucy5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pXG5cblx0YXBwLmRpcmVjdGl2ZSgncXJjb2RlJywgZnVuY3Rpb24oJGludGVycG9sYXRlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHQgICAgcmVzdHJpY3Q6ICdFJyxcblx0XHQgICAgbGluazogZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG5cblx0XHQgICAgICB2YXIgb3B0aW9ucyA9IHtcblx0XHQgICAgICAgIHRleHQ6ICcnLFxuXHRcdCAgICAgICAgd2lkdGg6IDEyOCxcblx0XHQgICAgICAgIGhlaWdodDogMTI4LFxuXHRcdCAgICAgICAgY29sb3JEYXJrOiAnIzAwMDAwMCcsXG5cdFx0ICAgICAgICBjb2xvckxpZ2h0OiAnI2ZmZmZmZicsXG5cdFx0ICAgICAgICBjb3JyZWN0TGV2ZWw6ICdIJ1xuXHRcdCAgICAgIH07XG5cblx0XHQgICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdCAgICAgICAgb3B0aW9uc1trZXldID0gJGludGVycG9sYXRlKCRhdHRyc1trZXldIHx8ICcnKSgkc2NvcGUpIHx8IG9wdGlvbnNba2V5XTtcblx0XHQgICAgICB9KTtcblxuXHRcdCAgICAgIG9wdGlvbnMuY29ycmVjdExldmVsID0gUVJDb2RlLkNvcnJlY3RMZXZlbFtvcHRpb25zLmNvcnJlY3RMZXZlbF07XG5cblx0XHQgICAgICBuZXcgUVJDb2RlKCRlbGVtZW50WzBdLCBvcHRpb25zKTtcblxuXHRcdCAgICB9XG5cdFx0fVxuXHR9KTtcblxuXG4gICAgYXBwLmRpcmVjdGl2ZSgnaW9uQ29tbWVudCcsIGlvbkNvbW1lbnQpXG4gICAgYXBwLmRpcmVjdGl2ZSgnaW9uVGhyZWFkJywgaW9uVGhyZWFkKTtcblxuICAgIGZ1bmN0aW9uIGlvbkNvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBjb21tZW50OiAnPSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxpb24taXRlbSBuZy1pZj1cImNvbW1lbnQuYXV0aG9yXCIgY2xhc3M9XCJpb24tY29tbWVudCBpdGVtXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpb24tY29tbWVudC0tYXV0aG9yXCI+PGltZyBjbGFzcz1cInJvdW5kLWF2YXRhclwiIHNyYz1cImltZy91c2VyX3Byb2ZpbGUucG5nXCIgbmctc3JjPVwie3skcm9vdC4kc3RvcmFnZS5wYWNjb3VudHNbY29tbWVudC5hdXRob3JdLnVzZXJfaW1hZ2V8fCRyb290LiRzdG9yYWdlLnBhY2NvdW50c1tjb21tZW50LmF1dGhvcl0ucHJvZmlsZS5wcm9maWxlX2ltYWdlfX1cIiBvbmVycm9yPVwidGhpcy5zcmM9XFwnaW1nL3VzZXJfcHJvZmlsZS5wbmdcXCdcIiBvbmFib3J0PVwidGhpcy5zcmM9XFwnaW1nL3VzZXJfcHJvZmlsZS5wbmdcXCdcIiAvPjxiPjxhIGhyZWY9XCIjL2FwcC9wcm9maWxlL3t7Y29tbWVudC5hdXRob3J9fVwiPnt7Y29tbWVudC5hdXRob3J9fTwvYT48L2I+Jm5ic3A7PGRpdiBjbGFzcz1cInJlcHV0YXRpb25cIj57e2NvbW1lbnQuYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+Jm1pZGRvdDt7e2NvbW1lbnQuY3JlYXRlZHx0aW1lYWdvfX08L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlvbi1jb21tZW50LS1zY29yZVwiPjxzcGFuIG9uLXRhcD1cIm9wZW5Ub29sdGlwKCRldmVudCxjb21tZW50KVwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XCJjb21tZW50Lm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoXFwnIFxcJylbMF0gPT09IFxcJzAuMDAwXFwnXCI+PGRlbD57e2NvbW1lbnQgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L2RlbD48L3NwYW4+PHNwYW4gbmctaWY9XCJjb21tZW50Lm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoXFwnIFxcJylbMF0gIT09IFxcJzAuMDAwXFwnXCI+e3tjb21tZW50IHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPiA8L3NwYW4+IHwgPHNwYW4gb24tdGFwPVwiZG93bnZvdGVQb3N0KGNvbW1lbnQpXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1mbGFnXCIgbmctY2xhc3M9XCJ7XFwnYXNzZXJ0aXZlXFwnOmNvbW1lbnQuZG93bnZvdGVkfVwiPjwvc3Bhbj48L3NwYW4+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpb24tY29tbWVudC0tdGV4dCBib2R5dGV4dCBzZWxlY3RhYmxlXCIgbmctYmluZC1odG1sPVwiY29tbWVudC5ib2R5IHwgcGFyc2VVcmwgXCI+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpb24tY29tbWVudC0tcmVwbGllc1wiPjxpb24tc3Bpbm5lciBuZy1pZj1cImNvbW1lbnQuaW52b3RpbmdcIj48L2lvbi1zcGlubmVyPjxzcGFuIG9uLXRhcD1cInVwdm90ZVBvc3QoY29tbWVudClcIiBvbi1ob2xkPVwib3BlblNsaWRlcnIoJGV2ZW50LCBjb21tZW50KVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXBcIiBuZy1jbGFzcz1cIntcXCdwb3NpdGl2ZVxcJzpjb21tZW50LnVwdm90ZWR9XCI+PC9zcGFuPiB7e1wiVVBWT1RFXCJ8dHJhbnNsYXRlfX08L3NwYW4+IHwgPHNwYW4gb24tdGFwPVwiJHJvb3Qub3BlbkluZm8oY29tbWVudClcIj57e2NvbW1lbnQubmV0X3ZvdGVzIHx8IDB9fSB7e1wiVk9URVNcInx0cmFuc2xhdGV9fTwvc3Bhbj4gfCA8c3BhbiBvbi10YXA9XCJ0b2dnbGVDb21tZW50KGNvbW1lbnQpXCI+e3tjb21tZW50LmNoaWxkcmVuIHx8IDB9fSB7e1wiUkVQTElFU1wifHRyYW5zbGF0ZX19PC9zcGFuPiB8IDxzcGFuIG9uLXRhcD1cInJlcGx5VG9Db21tZW50KGNvbW1lbnQpXCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1yZXBseVwiPjwvc3Bhbj4ge3tcIlJFUExZXCJ8dHJhbnNsYXRlfX08L3NwYW4+IDxzcGFuIG5nLWlmPVwiY29tbWVudC5hdXRob3IgPT0gJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSAmJiBjb21wYXRlRGF0ZShjb21tZW50KVwiIG9uLXRhcD1cImVkaXRDb21tZW50KGNvbW1lbnQpXCI+IHwgPHNwYW4gY2xhc3M9XCJpb24taW9zLWNvbXBvc2Utb3V0bGluZVwiPjwvc3Bhbj4ge3tcXCdFRElUXFwnfHRyYW5zbGF0ZX19PC9zcGFuPiA8c3BhbiBuZy1pZj1cImNvbW1lbnQuYXV0aG9yID09ICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgJiYgY29tbWVudC5hYnNfcnNoYXJlcyA9PSAwXCIgb24tdGFwPVwiZGVsZXRlQ29tbWVudChjb21tZW50KVwiPiB8IDxzcGFuIGNsYXNzPVwiaW9uLWlvcy10cmFzaC1vdXRsaW5lXCI+PC9zcGFuPiB7e1xcJ1JFTU9WRVxcJ3x0cmFuc2xhdGV9fTwvc3Bhbj48L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICA8L2lvbi1pdGVtPicsXG4gICAgICAgICAgICBjb250cm9sbGVyOiBmdW5jdGlvbigkc2NvcGUsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljTW9kYWwsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCAkaW9uaWNBY3Rpb25TaGVldCwgJGNvcmRvdmFDYW1lcmEsICRmaWx0ZXIsIEltYWdlVXBsb2FkU2VydmljZSkge1xuICAgICAgICAgICAgICAgICAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJUci5odG1sJywge1xuICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAkc2NvcGVcbiAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcCA9IHBvcG92ZXI7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyU2xpZGVyci5odG1sJywge1xuICAgICAgICAgICAgICAgICAgICAgIHNjb3BlOiAkc2NvcGVcbiAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwU2xpZGVyciA9IHBvcG92ZXI7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5TbGlkZXJyID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS52b3RpbmdQb3N0ID0gZDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJhbmdlVmFsdWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuc2hvdygkZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS52b3RlUG9zdFMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnVwdm90ZVBvc3QoJHNjb3BlLnZvdGluZ1Bvc3QpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRyYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2codik7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCA9IHYqMTAwO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlU2xpZGVyciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Ub29sdGlwID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cHB2ID0gTnVtYmVyKGQucGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cHYgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhciA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdLWQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRoID0gXCI8ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPVEVOVElBTF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHBwdiwgMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBU1RfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwdiwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCd0aW1lYWdvJykoZC5jYXNob3V0X3RpbWUsIHRydWUpK1wiPC9kaXY+PC9kaXY+XCI7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwVGV4dCA9IHRleHRoO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXAuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgLy9DbGVhbnVwIHRoZSBwb3BvdmVyIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5jb21wYXRlRGF0ZSA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQubGFzdF9wYXlvdXQgPT0gXCIxOTcwLTAxLTAxVDAwOjAwOjAwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50Lm1vZGUgPT0gXCJmaXJzdF9wYXlvdXRcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS50b2dnbGVDb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCd0b2dnbGVDb21tZW50ICcrY29tbWVudC5zaG93Q2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuc2hvd0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb21tZW50LmF1dGhvciwgY29tbWVudC5wZXJtbGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5kZXB0aCAlIDUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZGVwdGg1Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnb3BlbkNvbW1lbnRzJywgeyBkYXRhOiBjb21tZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50X3JlcGxpZXNcIiwgW2NvbW1lbnQuYXV0aG9yLCBjb21tZW50LnBlcm1saW5rXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5jb21tZW50cyA9IGRkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGRkW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzLmluZGV4T2Yodi5hdXRob3IpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzLnB1c2godi5hdXRob3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgncG9zdEFjY291bnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuc2hvd0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3VwZGF0ZTpjb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCdwb3N0QWNjb3VudHMnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHJvb3RTY29wZS4kc3RvcmFnZS5wYWNjb3VudHMpXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gcmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2Lmpzb25fbWV0YWRhdGEgPT09ICdzdHJpbmcnIHx8IHYuanNvbl9tZXRhZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodi5qc29uX21ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YS5pbmRleE9mKFwiY3JlYXRlZF9hdFwiKT4tMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihhbmd1bGFyLnRvSnNvbih2Lmpzb25fbWV0YWRhdGEpKTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB2Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wYWNjb3VudHNba2V5XSA9IHYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLnVwdm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vwdm90ZScsICd1cGRhdGU6Y29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmRvd252b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdET1dOVk9URV9GTEFHJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAndXBkYXRlOmNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vudm90ZScsICd1cGRhdGU6Y29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhPXt9O1xuICAgICAgICAgICAgICAgICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvcmVwbHkuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6ICRzY29wZSAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuY21vZGFsID0gbW9kYWw7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Nb2RhbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNtb2RhbC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuY2xvc2VNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNtb2RhbC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuaXNyZXBseWluZyA9IGZ1bmN0aW9uKGNobywgeHgpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0geHg7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5wb3N0ID0gY2hvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lZGl0YyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVkaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lZGl0YyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gJHNjb3BlLnBvc3QuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5wYXRjaGJvZHkgPSAkc2NvcGUucG9zdC5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm9wZW5Nb2RhbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuc2hvd0ltZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfQ1VTVE9NX1VSTCcpIH0sXG4gICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5TRVJUX1BJQ1RVUkUnKSxcbiAgICAgICAgICAgICAgICAgICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgY2FuY2VsIGNvZGUuLlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmluc2VydEltYWdlQyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5pbnNlcnRJbWFnZUMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IDAgfHwgdHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25UeXBlOiBDYW1lcmEuRGVzdGluYXRpb25UeXBlLkZJTEVfVVJJLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVHlwZTogKHR5cGU9PT0wKT9DYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuQ0FNRVJBOkNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kaW5nVHlwZTogQ2FtZXJhLkVuY29kaW5nVHlwZS5KUEVHLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3Zlck9wdGlvbnM6IENhbWVyYVBvcG92ZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29ycmVjdE9yaWVudGF0aW9uOnRydWVcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlVXBsb2FkU2VydmljZS51cGxvYWRJbWFnZShpbWFnZURhdGEpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHJlc3VsdC5pbWFnZVVybCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCArPSBmaW5hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9FUlJPUicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RJUkVDVF9MSU5LX1BJQ1RVUkUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycgKyByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gcmVzLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgKz0gZmluYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIHZhciBkbXAgPSBuZXcgd2luZG93LmRpZmZfbWF0Y2hfcGF0Y2goKTtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKHRleHQxLCB0ZXh0Mikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dDEgJiYgdGV4dDEgPT09ICcnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaGVzID0gZG1wLnBhdGNoX21ha2UodGV4dDEsIHRleHQyKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2ggPSBkbXAucGF0Y2hfdG9UZXh0KHBhdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseSA9IGZ1bmN0aW9uICh4eCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoISRzY29wZS5lZGl0Yykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVmb3JtYXQgPSB0LmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSsodC5nZXRNb250aCgpKzEpLnRvU3RyaW5nKCkrdC5nZXREYXRlKCkudG9TdHJpbmcoKStcInRcIit0LmdldEhvdXJzKCkudG9TdHJpbmcoKSt0LmdldE1pbnV0ZXMoKS50b1N0cmluZygpK3QuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkrdC5nZXRNaWxsaXNlY29uZHMoKS50b1N0cmluZygpK1wielwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt0YWdzOiBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGEpLnRhZ3NbMF0gfHwgXCJcIiwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY29tbWVudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9hdXRob3I6ICRzY29wZS5wb3N0LmF1dGhvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiBcInJlLVwiKyRzY29wZS5wb3N0LmF1dGhvcitcIi1cIiskc2NvcGUucG9zdC5wZXJtbGluaytcIi1cIit0aW1lZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJHNjb3BlLmRhdGEuY29tbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY29tbWVudF9vcHRpb25zXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtbGluazogXCJyZS1cIiskc2NvcGUucG9zdC5hdXRob3IrXCItXCIrJHNjb3BlLnBvc3QucGVybWxpbmsrXCItXCIrdGltZWZvcm1hdCwgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBcIjEwMDAwMDAuMDAwIFwiKyRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudF9zdGVlbV9kb2xsYXJzOiAxMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogeyBcImJlbmVmaWNpYXJpZXNcIjogeyBcImFjY291bnRcIjpcImVzdGVlbWFwcFwiLCBcIndlaWdodFwiOjEwMCB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhteV9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJ1cGRhdGU6Y29udGVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2goJHNjb3BlLnBhdGNoYm9keSwgJHNjb3BlLmRhdGEuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0dGluZyBib2R5IGludG8gYnVmZmVyIHdpbGwgZXhwYW5kIFVuaWNvZGUgY2hhcmFjdGVycyBpbnRvIHRoZWlyIHRydWUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaCAmJiBwYXRjaC5sZW5ndGggPCBuZXcgQnVmZmVyKCRzY29wZS5kYXRhLmNvbW1lbnQsICd1dGYtOCcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQyID0gcGF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhwYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IHt0YWdzOiBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGEpLnRhZ3NbMF0gfHwgXCJcIiwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY29tbWVudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9hdXRob3I6ICRzY29wZS5wb3N0LnBhcmVudF9hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnBvc3QucGFyZW50X3Blcm1saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3I6ICRzY29wZS5wb3N0LmF1dGhvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWxpbms6ICRzY29wZS5wb3N0LnBlcm1saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogJHNjb3BlLmRhdGEuY29tbWVudDIgfHwgJHNjb3BlLmRhdGEuY29tbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbl9tZXRhZGF0YTogJHNjb3BlLnBvc3QuanNvbl9tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxvd192b3RlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiAkc2NvcGUucG9zdC5hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluaywgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBcIjEwMDAwMDAuMDAwIFwiKyRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudF9zdGVlbV9kb2xsYXJzOiAxMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogeyBcImJlbmVmaWNpYXJpZXNcIjogeyBcImFjY291bnRcIjpcImVzdGVlbWFwcFwiLCBcIndlaWdodFwiOjEwMCB9IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhteV9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTU1FTlRfU1VCTUlUVEVEJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInVwZGF0ZTpjb250ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5yZXBseVRvQ29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ3JlcGx5IHRvIGNvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuaXNyZXBseWluZyhjb21tZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmVkaXRDb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnZWRpdCB0byBjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzcmVwbHlpbmcoY29tbWVudCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuZGVsZXRlQ29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ2RlbGV0ZSB0byBjb21tZW50ICcrIGFuZ3VsYXIudG9Kc29uKGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBUkVfWU9VX1NVUkUnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnREVMRVRFX0NPTU1FTlQnKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiZGVsZXRlX2NvbW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogY29tbWVudC5hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWxpbms6IGNvbW1lbnQucGVybWxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JST0FEQ0FTVF9FUlJPUicpK1wiIFwiK2xvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0RFTEVURURfQ09NTUVOVCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInVwZGF0ZTpjb250ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpb25UaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBjb21tZW50czogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy9SZXBsYWNlIG5nLWlmPVwiIWNvbW1lbnQuc2hvd0NoaWxkcmVuXCIgd2l0aCBuZy1pZj1cImNvbW1lbnQuc2hvd0NoaWxkcmVuXCIgdG8gaGlkZSBhbGwgY2hpbGQgY29tbWVudHMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgLy9SZXBsYWNlIGNvbW1lbnQuZGF0YS5yZXBsaWVzLmRhdGEuY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZSBBUEkgeW91IGFyZSB1c2luZyB8IG9yZGVyQnk6XFwnLW5ldF92b3Rlc1xcJ1xuICAgICAgICAgICAgdGVtcGxhdGU6ICc8c2NyaXB0IHR5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCIgaWQ9XCJub2RlLmh0bWxcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpb24tY29tbWVudCBjb21tZW50PVwiY29tbWVudFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9pb24tY29tbWVudD5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJyZWRkaXQtcG9zdC0tY29tbWVudC0tY29udGFpbmVyXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBuZy1pZj1cImNvbW1lbnQuc2hvd0NoaWxkcmVuXCIgY2xhc3M9XCJhbmltYXRlLWlmIGlvbi1jb21tZW50LS1jaGlsZHJlblwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiY29tbWVudCBpbiBjb21tZW50LmNvbW1lbnRzIHwgb3JkZXJCeTpcXCctcGVuZGluZ19wYXlvdXRfdmFsdWVcXCcgdHJhY2sgYnkgJGluZGV4IFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWluY2x1ZGUgc3JjPVwiXFwnbm9kZS5odG1sXFwnXCIvPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9zY3JpcHQ+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpb24tbGlzdCBuZy1pZj1cImNvbW1lbnRzICYmIGNvbW1lbnRzLmxlbmd0aCA+IDBcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8dWw+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgbmctcmVwZWF0PVwiY29tbWVudCBpbiBjb21tZW50cyB8IG9yZGVyQnk6XFwnLXBlbmRpbmdfcGF5b3V0X3ZhbHVlXFwnIHRyYWNrIGJ5ICRpbmRleFwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1pbmNsdWRlIHNyYz1cIlxcJ25vZGUuaHRtbFxcJ1wiLz5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pb24tbGlzdD4nLFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgLyokc2NvcGUudG9nZ2xlQ29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2coJ3RvZ2dsZUNvbW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnNob3dDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuc2hvd0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuc2hvd0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9OyovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdXMoJHEsICRpb25pY0xvYWRpbmcsICRjb3Jkb3ZhRmlsZVRyYW5zZmVyLCAkaW9uaWNQbGF0Zm9ybSwgJGZpbHRlciwgJHJvb3RTY29wZSwgQVBJX0VORF9QT0lOVCkge1xuICAgICAgICB2YXIgc2VydmljZSA9IHt9O1xuICAgICAgICBzZXJ2aWNlLnVwbG9hZEltYWdlID0gdXBsb2FkSW1hZ2U7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xuICAgICAgICBmdW5jdGlvbiB1cGxvYWRJbWFnZShpbWFnZVVSSSkge1xuICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgdmFyIGZpbGVTaXplO1xuICAgICAgICAgIHZhciBwZXJjZW50YWdlO1xuICAgICAgICAgIC8qaWYgKGlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2VVUkkuaW5kZXhPZignZmlsZTovLycpPT09LTEpIHtcbiAgICAgICAgICAgICAgaW1hZ2VVUkk9XCJmaWxlOi8vXCIraW1hZ2VVUkk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSovXG4gICAgICAgICAgLy8gRmluZCBvdXQgaG93IGJpZyB0aGUgb3JpZ2luYWwgZmlsZSBpc1xuICAgICAgICAgIHdpbmRvdy5yZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMKGltYWdlVVJJLCBmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgIGZpbGVFbnRyeS5maWxlKGZ1bmN0aW9uKGZpbGVPYmopIHtcbiAgICAgICAgICAgICAgZmlsZVNpemUgPSBmaWxlT2JqLnNpemU7XG4gICAgICAgICAgICAgIC8vIERpc3BsYXkgYSBsb2FkaW5nIGluZGljYXRvciByZXBvcnRpbmcgdGhlIHN0YXJ0IG9mIHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURJTkdfUElDVFVSRScpICsgMCArICclJ30pO1xuICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSB1cGxvYWRcbiAgICAgICAgICAgICAgdXBsb2FkRmlsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZnVuY3Rpb24gdXBsb2FkRmlsZSgpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgQ2xvdWRpbmFyeSBcInVwbG9hZCBwcmVzZXRcIiBuYW1lIHRvIHRoZSBoZWFkZXJzXG4gICAgICAgICAgICAvLyBcImh0dHBzOi8vYXBpLmNsb3VkaW5hcnkuY29tL3YxXzEvZXN0ZWVtL2ltYWdlL3VwbG9hZFwiXG4gICAgICAgICAgICB2YXIgdXBsb2FkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgcGFyYW1zIDogeyAndXNlcm5hbWUnOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJGlvbmljUGxhdGZvcm0ucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFGaWxlVHJhbnNmZXIudXBsb2FkKEFQSV9FTkRfUE9JTlQrXCIvYXBpL3VwbG9hZFwiLCBpbWFnZVVSSSwgdXBsb2FkT3B0aW9ucykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSB1c2VyIGtub3cgdGhlIHVwbG9hZCBpcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURfQ09NUExFVEVEJyksIGR1cmF0aW9uOiAxMDAwfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3VsdCBoYXMgYSBcInJlc3BvbnNlXCIgcHJvcGVydHkgdGhhdCBpcyBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEZZSTogVGhlIHJlc3VsdCB3aWxsIGFsc28gaGF2ZSBVUkxzIGZvciBhbnkgbmV3IGltYWdlcyBnZW5lcmF0ZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBlYWdlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQocmVzdWx0LnJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVoIG9oIVxuICAgICAgICAgICAgICAgICAgICAkaW9uaWNMb2FkaW5nLnNob3coe3RlbXBsYXRlIDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQTE9BRF9GQUlMRUQnKSwgZHVyYXRpb246IDIwMDB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVwbG9hZCBwbHVnaW4gZ2l2ZXMgeW91IGluZm9ybWF0aW9uIGFib3V0IGhvdyBtdWNoIGRhdGEgaGFzIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gc29tZSBpbnRlcnZhbC4gIFVzZSB0aGlzIHdpdGggdGhlIG9yaWdpbmFsIGZpbGUgc2l6ZSB0byBzaG93IGEgcHJvZ3Jlc3MgaW5kaWNhdG9yLlxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlID0gTWF0aC5mbG9vcigocHJvZ3Jlc3MubG9hZGVkIC8gZmlsZVNpemUpICogMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURJTkdfUElDVFVSRScpICsgcGVyY2VudGFnZSArICclJ30pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHAuZmFjdG9yeSgnSW1hZ2VVcGxvYWRTZXJ2aWNlJywgaXVzKTtcblxuICAgIGFwcC5jb25zdGFudCgnZGVmYXVsdFNldHRpbmdzJywge1xuICAgICAgICBhbHBoYWJldGNvbG9yczogW1wiIzVBODc3MFwiLCBcIiNCMkI3QkJcIiwgXCIjNkZBOUFCXCIsIFwiI0Y1QUYyOVwiLCBcIiMwMDg4QjlcIiwgXCIjRjE4NjM2XCIsIFwiI0Q5M0EzN1wiLCBcIiNBNkIxMkVcIiwgXCIjNUM5QkJDXCIsIFwiI0Y1ODg4RFwiLCBcIiM5QTg5QjVcIiwgXCIjNDA3ODg3XCIsIFwiIzlBODlCNVwiLCBcIiM1QTg3NzBcIiwgXCIjRDMzRjMzXCIsIFwiI0EyQjAxRlwiLCBcIiNGMEIxMjZcIiwgXCIjMDA4N0JGXCIsIFwiI0YxODYzNlwiLCBcIiMwMDg3QkZcIiwgXCIjQjJCN0JCXCIsIFwiIzcyQUNBRVwiLCBcIiM5QzhBQjRcIiwgXCIjNUE4NzcwXCIsIFwiI0VFQjQyNFwiLCBcIiM0MDc4ODdcIl0sXG4gICAgICAgIHRleHRDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICBkZWZhdWx0Qm9yZGVyOiAnYm9yZGVyOjVweCBzb2xpZCB3aGl0ZScsXG4gICAgICAgIHRyaWFuZ2xldXA6ICd3aWR0aDogMDtoZWlnaHQ6IDA7Ym9yZGVyLWxlZnQ6IDUwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OiA1MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206IDEwMHB4IHNvbGlkOycsXG4gICAgICAgIGZvbnRzaXplOiAzMCwgLy8gdW5pdCBpbiBwaXhlbHNcbiAgICAgICAgaGVpZ2h0OiA1MCwgLy8gdW5pdCBpbiBwaXhlbHNcbiAgICAgICAgd2lkdGg6IDUwLCAvLyB1bml0IGluIHBpeGVsc1xuICAgICAgICBmb250V2VpZ2h0OiA0MDAsIC8vXG4gICAgICAgIGNoYXJDb3VudDogMSxcbiAgICAgICAgZm9udEZhbWlseTogJ0hlbHZldGljYU5ldWUtTGlnaHQsSGVsdmV0aWNhIE5ldWUgTGlnaHQsSGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLCBBcmlhbCxMdWNpZGEgR3JhbmRlLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgYmFzZTogJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJyxcbiAgICAgICAgcmFkaXVzOiAnYm9yZGVyLXJhZGl1czo1MCU7JyxcbiAgICAgICAgY3VzdG9tYmdjb2xvcjogJycsXG4gICAgICAgIGR5bmFtaWM6ICdmYWxzZScsXG4gICAgICAgIHJvdGF0ZWRlZzogJzAnXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBkaXJlY3RpdmUgdG8gY3JlYXRlIHRoZSBhdmF0YXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHBhcmFtMVxuICAgICAqIEBwYXJhbSB7dHlwZX0gcGFyYW0yXG4gICAgICovXG4gICAgYXBwLmRpcmVjdGl2ZSgnbmdMZXR0ZXJBdmF0YXInLCBbJ2RlZmF1bHRTZXR0aW5ncycsIGZ1bmN0aW9uIChkZWZhdWx0U2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQUUnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgYWxwaGFiZXRjb2xvcnM6ICc9YWxwaGFiZXRjb2xvcnMnLFxuICAgICAgICAgICAgICAgIGRhdGE6ICdAJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFBvcHVsYXRlIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRvIHBhcmFtcyBvYmplY3RcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB0eXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50OiBhdHRycy5jaGFyY291bnQgfHwgZGVmYXVsdFNldHRpbmdzLmNoYXJDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYXR0cnMuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiBkZWZhdWx0U2V0dGluZ3MudGV4dENvbG9yLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGF0dHJzLmhlaWdodCB8fCBkZWZhdWx0U2V0dGluZ3MuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXR0cnMud2lkdGggfHwgZGVmYXVsdFNldHRpbmdzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBmb250c2l6ZTogYXR0cnMuZm9udHNpemUgfHwgZGVmYXVsdFNldHRpbmdzLmZvbnRzaXplLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBhdHRycy5mb250d2VpZ2h0IHx8IGRlZmF1bHRTZXR0aW5ncy5mb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiBhdHRycy5mb250ZmFtaWx5IHx8IGRlZmF1bHRTZXR0aW5ncy5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXJCb3JkZXJTdHlsZTogYXR0cnMuYXZhdGFyY3VzdG9tYm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXJkZWZhdWx0Qm9yZGVyOiBhdHRycy5hdmF0YXJib3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRCb3JkZXI6IGRlZmF1bHRTZXR0aW5ncy5kZWZhdWx0Qm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZTogYXR0cnMuc2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhYmV0Y29sb3JzOiBzY29wZS5hbHBoYWJldGNvbG9ycyB8fCBkZWZhdWx0U2V0dGluZ3MuYWxwaGFiZXRjb2xvcnMsXG4gICAgICAgICAgICAgICAgICAgIGF2YXRhckN1c3RvbUJHQ29sb3I6IGF0dHJzLmF2YXRhcmN1c3RvbWJnY29sb3IgfHwgZGVmYXVsdFNldHRpbmdzLmN1c3RvbWJnY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWM6IGF0dHJzLmR5bmFtaWMgfHwgZGVmYXVsdFNldHRpbmdzLmR5bmFtaWMsXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRlZzogYXR0cnMucm90YXRlZGVnIHx8IGRlZmF1bHRTZXR0aW5ncy5yb3RhdGVkZWdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogdG8gZ2VuZXJhdGUgdGhlIGF2YXRhciBkeW5hbWljYWxseSBvbiBkYXRhIGNoYW5nZSwgZW5hYmxlIHRoZSBiZWxvdyBmdW5jdGlvbiB0byB3YXRjaCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWMgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2VuZXJhdGVMZXR0ZXJBdmF0YXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX2dlbmVyYXRlTGV0dGVyQXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gX2dlbmVyYXRlTGV0dGVyQXZhdGFyKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmNoYXJDb3VudCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RhdGEgPSBnZXRGaXJzdEFuZExhc3ROYW1lKHNjb3BlLmRhdGEudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gX2RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzY29wZS5kYXRhLnN1YnN0cigwLCBwYXJhbXMuY2hhckNvdW50KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNjb3BlLmRhdGEuc3Vic3RyKDAsIHBhcmFtcy5jaGFyQ291bnQpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvYmogPSBnZXRDaGFyYWN0ZXJPYmplY3QoYywgcGFyYW1zLnRleHRDb2xvciwgcGFyYW1zLmZvbnRGYW1pbHksIHBhcmFtcy5mb250V2VpZ2h0LCBwYXJhbXMuZm9udHNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3JJbmRleCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogUG9wdWxhdGUgdGhlIGNvbG9ycyBhY2NvcmRpbmcgdG8gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2hhckNvZGVBdCgwKSA8IDY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGdldFJhbmRvbUNvbG9ycygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IE1hdGguZmxvb3IoKGMuY2hhckNvZGVBdCgwKSAtIDY1KSAlIHBhcmFtcy5hbHBoYWJldGNvbG9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBwYXJhbXMuYWxwaGFiZXRjb2xvcnNbY29sb3JJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmF2YXRhckN1c3RvbUJHQ29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gcGFyYW1zLmF2YXRhckN1c3RvbUJHQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnID0gZ2V0SW1nVGFnKHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCwgY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdmcuYXBwZW5kKGNvYmopO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbHZjb21wb25lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+JykuYXBwZW5kKHN2Zy5jbG9uZSgpKS5odG1sKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdmdIdG1sID0gd2luZG93LmJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGx2Y29tcG9uZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IGRlZmF1bHRTZXR0aW5ncy5iYXNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3N0eWxlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYXZhdGFyQm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHlsZSA9IHBhcmFtcy5hdmF0YXJCb3JkZXJTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuYXZhdGFyZGVmYXVsdEJvcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0eWxlID0gcGFyYW1zLmRlZmF1bHRCb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnJvdGF0ZWRlZyAhPSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHlsZSA9ICctbXMtdHJhbnNmb3JtOiByb3RhdGUoJyArIHBhcmFtcy5yb3RhdGVkZWcgKyAnZGVnKTsgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgnICsgcGFyYW1zLnJvdGF0ZWRlZyArICdkZWcpOyB0cmFuc2Zvcm06IHJvdGF0ZSgnICsgcGFyYW1zLnJvdGF0ZWRlZyArICdkZWcpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuc2hhcGUgPT09ICdyb3VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm91bmRfc3R5bGUgPSBkZWZhdWx0U2V0dGluZ3MucmFkaXVzICsgX3N0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5kYXRhLmluZGV4T2YoJ2h0dHAnKSA+IC0xIHx8IHNjb3BlLmRhdGEuaW5kZXhPZignZGF0YTppbWFnZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltZ19zaXplID0gJ3dpZHRoOicgKyBwYXJhbXMud2lkdGggKyAncHg7aGVpZ2h0OicgKyBwYXJhbXMuaGVpZ2h0ICsgJ3B4Oyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBzY29wZS5kYXRhICsgXCIgc3R5bGU9J1wiICsgaW1nX3NpemUgKyByb3VuZF9zdHlsZSArIFwiJyAgLz5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBcIjxpbWcgc3JjPVwiICsgYmFzZSArIHN2Z0h0bWwgKyBcIiBzdHlsZT0nXCIgKyByb3VuZF9zdHlsZSArIFwiJyB0aXRsZT0nXCIgKyBzY29wZS5kYXRhICsgXCInIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmRhdGEuaW5kZXhPZignaHR0cCcpID4gLTEgfHwgc2NvcGUuZGF0YS5pbmRleE9mKCdkYXRhOmltYWdlJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWdfc2l6ZSA9ICd3aWR0aDonICsgcGFyYW1zLndpZHRoICsgJ3B4O2hlaWdodDonICsgcGFyYW1zLmhlaWdodCArICdweDsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBzY29wZS5kYXRhICsgXCIgc3R5bGU9J1wiICsgaW1nX3NpemUgKyBfc3R5bGUgKyBcIicgIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IFwiPGltZyBzcmM9XCIgKyBiYXNlICsgc3ZnSHRtbCArIFwiIHN0eWxlPSdcIiArIF9zdHlsZSArIFwiJyB0aXRsZT0nXCIgKyBzY29wZS5kYXRhICsgXCInIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmR5bmFtaWMgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmQoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVwbGFjZVdpdGgoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByYW5kb20gY29sb3JzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYW5kb21Db2xvcnMoKSB7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gJzAxMjM0NTY3ODlBQkNERUYnLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIF9jb2xvciA9ICcjJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIF9jb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9jb2xvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUgZmlyc3QgbGV0dGVycyBhbmQgY29tYmluZWQgYW5kIGZvcm0gdGhlIGxldHRlciBhdmF0YXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGaXJzdEFuZExhc3ROYW1lKGRhdGEpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gZGF0YS5zcGxpdChcIiBcIik7XG4gICAgICAgIGlmIChuYW1lcyAmJiBuYW1lcy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgdmFyIGZpcnN0TmFtZSA9IG5hbWVzWzBdO1xuICAgICAgICAgICAgdmFyIGxhc3ROYW1lID0gbmFtZXNbMV07XG4gICAgICAgICAgICBpZiAoZmlyc3ROYW1lICYmIGxhc3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaXJzdE5hbWUuc3Vic3RyKDAsIDEpICsgbGFzdE5hbWUuc3Vic3RyKDAsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSB0aGUgc3ZnIHRhZyB3aGljaCB3aWxsIHVzZWQgZm9yIHRoZSBhdmF0YXIgZ2VuZXJhdGlvblxuICAgICAqIEBwYXJhbSB7dHlwZX0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbWdUYWcod2lkdGgsIGhlaWdodCwgY29sb3IpIHtcblxuICAgICAgICB2YXIgc3ZnVGFnID0gYW5ndWxhci5lbGVtZW50KCc8c3ZnPjwvc3ZnPicpXG4gICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogd2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdmdUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlIHRoZSBMZXR0ZXIgdGFnIGJ5IHVzaW5nIHRoZSBzdmcgdGV4dCBlbGVtZW50XG4gICAgICogQHBhcmFtIHt0eXBlfSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHRleHRDb2xvclxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udEZhbWlseVxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udFdlaWdodFxuICAgICAqIEBwYXJhbSB7dHlwZX0gZm9udHNpemVcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJPYmplY3QoY2hhcmFjdGVyLCB0ZXh0Q29sb3IsIGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRzaXplKSB7XG4gICAgICAgIHZhciB0ZXh0VGFnID0gYW5ndWxhci5lbGVtZW50KCc8dGV4dCB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPjwvdGV4dD4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3knOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3gnOiAnNTAlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2R5JzogJzAuMzVlbScsXG4gICAgICAgICAgICAgICAgICAgIC8vJ3N0cm9rZSc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAnZmlsbCc6IHRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmh0bWwoY2hhcmFjdGVyKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnOiBmb250V2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAnZm9udC1zaXplJzogZm9udHNpemUgKyAncHgnLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0ZXh0VGFnO1xuICAgIH1cblxufVxuXG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9wb3N0cy9zZXJ2aWNlcy5qc1wiLFwiL3Bvc3RzXCIpIl19
