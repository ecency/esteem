(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/assert/assert.js","/../node_modules/assert")
},{"buffer":11,"pBGvAp":74,"util/":99}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// base-x encoding
// Forked from https://github.com/cryptocoinjs/bs58
// Originally written by Mike Hearn for BitcoinJ
// Copyright (c) 2011 Google Inc
// Ported to JavaScript by Stefan Thomas
// Merged Buffer refactorings from base58-native by Stephen Pair
// Copyright (c) 2013 BitPay Inc

module.exports = function base (ALPHABET) {
  var ALPHABET_MAP = {}
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)

  // pre-compute lookup table
  for (var i = 0; i < ALPHABET.length; i++) {
    ALPHABET_MAP[ALPHABET.charAt(i)] = i
  }

  function encode (source) {
    if (source.length === 0) return ''

    var digits = [0]
    for (var i = 0; i < source.length; ++i) {
      for (var j = 0, carry = source[i]; j < digits.length; ++j) {
        carry += digits[j] << 8
        digits[j] = carry % BASE
        carry = (carry / BASE) | 0
      }

      while (carry > 0) {
        digits.push(carry % BASE)
        carry = (carry / BASE) | 0
      }
    }

    // deal with leading zeros
    for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      digits.push(0)
    }

    // convert digits to a string
    for (var ii = 0, jj = digits.length - 1; ii <= jj; ++ii, --jj) {
      var tmp = ALPHABET[digits[ii]]
      digits[ii] = ALPHABET[digits[jj]]
      digits[jj] = tmp
    }

    return digits.join('')
  }

  function decode (string) {
    if (string.length === 0) return []

    var bytes = [0]
    for (var i = 0; i < string.length; i++) {
      var value = ALPHABET_MAP[string[i]]
      if (value === undefined) throw new Error('Non-base' + BASE + ' character')

      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * BASE
        bytes[j] = carry & 0xff
        carry >>= 8
      }

      while (carry > 0) {
        bytes.push(carry & 0xff)
        carry >>= 8
      }
    }

    // deal with leading zeros
    for (var k = 0; string[k] === LEADER && k < string.length - 1; ++k) {
      bytes.push(0)
    }

    return bytes.reverse()
  }

  return {
    encode: encode,
    decode: decode
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base-x/index.js","/../node_modules/base-x")
},{"buffer":11,"pBGvAp":74}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/base64-js/lib/b64.js","/../node_modules/base64-js/lib")
},{"buffer":11,"pBGvAp":74}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// (public) Constructor
function BigInteger(a, b, c) {
  if (!(this instanceof BigInteger))
    return new BigInteger(a, b, c)

  if (a != null) {
    if ("number" == typeof a) this.fromNumber(a, b, c)
    else if (b == null && "string" != typeof a) this.fromString(a, 256)
    else this.fromString(a, b)
  }
}

var proto = BigInteger.prototype

// duck-typed isBigInteger
proto.__bigi = require('../package.json').version
BigInteger.isBigInteger = function (obj, check_ver) {
  return obj && obj.__bigi && (!check_ver || obj.__bigi === proto.__bigi)
}

// Bits per digit
var dbits

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c
    c = Math.floor(v / 0x4000000)
    w[j++] = v & 0x3ffffff
  }
  return c
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
  var xl = x & 0x7fff,
    xh = x >> 15
  while (--n >= 0) {
    var l = this[i] & 0x7fff
    var h = this[i++] >> 15
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff)
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30)
    w[j++] = l & 0x3fffffff
  }
  return c
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
  var xl = x & 0x3fff,
    xh = x >> 14
  while (--n >= 0) {
    var l = this[i] & 0x3fff
    var h = this[i++] >> 14
    var m = xh * l + h * xl
    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c
    c = (l >> 28) + (m >> 14) + xh * h
    w[j++] = l & 0xfffffff
  }
  return c
}

// wtf?
BigInteger.prototype.am = am1
dbits = 26

BigInteger.prototype.DB = dbits
BigInteger.prototype.DM = ((1 << dbits) - 1)
var DV = BigInteger.prototype.DV = (1 << dbits)

var BI_FP = 52
BigInteger.prototype.FV = Math.pow(2, BI_FP)
BigInteger.prototype.F1 = BI_FP - dbits
BigInteger.prototype.F2 = 2 * dbits - BI_FP

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"
var BI_RC = new Array()
var rr, vv
rr = "0".charCodeAt(0)
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv
rr = "a".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv
rr = "A".charCodeAt(0)
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv

function int2char(n) {
  return BI_RM.charAt(n)
}

function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)]
  return (c == null) ? -1 : c
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i]
  r.t = this.t
  r.s = this.s
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1
  this.s = (x < 0) ? -1 : 0
  if (x > 0) this[0] = x
  else if (x < -1) this[0] = x + DV
  else this.t = 0
}

// return bigint initialized to value
function nbv(i) {
  var r = new BigInteger()
  r.fromInt(i)
  return r
}

// (protected) set from string and radix
function bnpFromString(s, b) {
  var self = this

  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 256) k = 8; // byte array
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else {
    self.fromRadix(s, b)
    return
  }
  self.t = 0
  self.s = 0
  var i = s.length,
    mi = false,
    sh = 0
  while (--i >= 0) {
    var x = (k == 8) ? s[i] & 0xff : intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-") mi = true
      continue
    }
    mi = false
    if (sh == 0)
      self[self.t++] = x
    else if (sh + k > self.DB) {
      self[self.t - 1] |= (x & ((1 << (self.DB - sh)) - 1)) << sh
      self[self.t++] = (x >> (self.DB - sh))
    } else
      self[self.t - 1] |= x << sh
    sh += k
    if (sh >= self.DB) sh -= self.DB
  }
  if (k == 8 && (s[0] & 0x80) != 0) {
    self.s = -1
    if (sh > 0) self[self.t - 1] |= ((1 << (self.DB - sh)) - 1) << sh
  }
  self.clamp()
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s & this.DM
  while (this.t > 0 && this[this.t - 1] == c)--this.t
}

// (public) return string representation in given radix
function bnToString(b) {
  var self = this
  if (self.s < 0) return "-" + self.negate()
    .toString(b)
  var k
  if (b == 16) k = 4
  else if (b == 8) k = 3
  else if (b == 2) k = 1
  else if (b == 32) k = 5
  else if (b == 4) k = 2
  else return self.toRadix(b)
  var km = (1 << k) - 1,
    d, m = false,
    r = "",
    i = self.t
  var p = self.DB - (i * self.DB) % k
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) > 0) {
      m = true
      r = int2char(d)
    }
    while (i >= 0) {
      if (p < k) {
        d = (self[i] & ((1 << p) - 1)) << (k - p)
        d |= self[--i] >> (p += self.DB - k)
      } else {
        d = (self[i] >> (p -= k)) & km
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if (d > 0) m = true
      if (m) r += int2char(d)
    }
  }
  return m ? r : "0"
}

// (public) -this
function bnNegate() {
  var r = new BigInteger()
  BigInteger.ZERO.subTo(this, r)
  return r
}

// (public) |this|
function bnAbs() {
  return (this.s < 0) ? this.negate() : this
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s - a.s
  if (r != 0) return r
  var i = this.t
  r = i - a.t
  if (r != 0) return (this.s < 0) ? -r : r
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0) return r
  return 0
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1,
    t
  if ((t = x >>> 16) != 0) {
    x = t
    r += 16
  }
  if ((t = x >> 8) != 0) {
    x = t
    r += 8
  }
  if ((t = x >> 4) != 0) {
    x = t
    r += 4
  }
  if ((t = x >> 2) != 0) {
    x = t
    r += 2
  }
  if ((t = x >> 1) != 0) {
    x = t
    r += 1
  }
  return r
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if (this.t <= 0) return 0
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
}

// (public) return the number of bytes in "this"
function bnByteLength() {
  return this.bitLength() >> 3
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
  var i
  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i]
  for (i = n - 1; i >= 0; --i) r[i] = 0
  r.t = this.t + n
  r.s = this.s
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r[i - n] = this[i]
  r.t = Math.max(this.t - n, 0)
  r.s = this.s
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
  var self = this
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << cbs) - 1
  var ds = Math.floor(n / self.DB),
    c = (self.s << bs) & self.DM,
    i
  for (i = self.t - 1; i >= 0; --i) {
    r[i + ds + 1] = (self[i] >> cbs) | c
    c = (self[i] & bm) << bs
  }
  for (i = ds - 1; i >= 0; --i) r[i] = 0
  r[ds] = c
  r.t = self.t + ds + 1
  r.s = self.s
  r.clamp()
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
  var self = this
  r.s = self.s
  var ds = Math.floor(n / self.DB)
  if (ds >= self.t) {
    r.t = 0
    return
  }
  var bs = n % self.DB
  var cbs = self.DB - bs
  var bm = (1 << bs) - 1
  r[0] = self[ds] >> bs
  for (var i = ds + 1; i < self.t; ++i) {
    r[i - ds - 1] |= (self[i] & bm) << cbs
    r[i - ds] = self[i] >> bs
  }
  if (bs > 0) r[self.t - ds - 1] |= (self.s & bm) << cbs
  r.t = self.t - ds
  r.clamp()
}

// (protected) r = this - a
function bnpSubTo(a, r) {
  var self = this
  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] - a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c -= a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c -= a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c -= a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c < -1) r[i++] = self.DV + c
  else if (c > 0) r[i++] = c
  r.t = i
  r.clamp()
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
  var x = this.abs(),
    y = a.abs()
  var i = x.t
  r.t = i + y.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)
  r.s = 0
  r.clamp()
  if (this.s != a.s) BigInteger.ZERO.subTo(r, r)
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs()
  var i = r.t = 2 * x.t
  while (--i >= 0) r[i] = 0
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1)
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV
      r[i + x.t + 1] = 1
    }
  }
  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)
  r.s = 0
  r.clamp()
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
  var self = this
  var pm = m.abs()
  if (pm.t <= 0) return
  var pt = self.abs()
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0)
    if (r != null) self.copyTo(r)
    return
  }
  if (r == null) r = new BigInteger()
  var y = new BigInteger(),
    ts = self.s,
    ms = m.s
  var nsh = self.DB - nbits(pm[pm.t - 1]); // normalize modulus
  if (nsh > 0) {
    pm.lShiftTo(nsh, y)
    pt.lShiftTo(nsh, r)
  } else {
    pm.copyTo(y)
    pt.copyTo(r)
  }
  var ys = y.t
  var y0 = y[ys - 1]
  if (y0 == 0) return
  var yt = y0 * (1 << self.F1) + ((ys > 1) ? y[ys - 2] >> self.F2 : 0)
  var d1 = self.FV / yt,
    d2 = (1 << self.F1) / yt,
    e = 1 << self.F2
  var i = r.t,
    j = i - ys,
    t = (q == null) ? new BigInteger() : q
  y.dlShiftTo(j, t)
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1
    r.subTo(t, r)
  }
  BigInteger.ONE.dlShiftTo(ys, t)
  t.subTo(y, y); // "negative" y so we can replace sub with am later
  while (y.t < ys) y[y.t++] = 0
  while (--j >= 0) {
    // Estimate quotient digit
    var qd = (r[--i] == y0) ? self.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2)
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
      y.dlShiftTo(j, t)
      r.subTo(t, r)
      while (r[i] < --qd) r.subTo(t, r)
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q)
    if (ts != ms) BigInteger.ZERO.subTo(q, q)
  }
  r.t = ys
  r.clamp()
  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
  if (ts < 0) BigInteger.ZERO.subTo(r, r)
}

// (public) this mod a
function bnMod(a) {
  var r = new BigInteger()
  this.abs()
    .divRemTo(a, null, r)
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r)
  return r
}

// Modular reduction using "classic" algorithm
function Classic(m) {
  this.m = m
}

function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m)
  else return x
}

function cRevert(x) {
  return x
}

function cReduce(x) {
  x.divRemTo(this.m, null, x)
}

function cMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

function cSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

Classic.prototype.convert = cConvert
Classic.prototype.revert = cRevert
Classic.prototype.reduce = cReduce
Classic.prototype.mulTo = cMulTo
Classic.prototype.sqrTo = cSqrTo

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if (this.t < 1) return 0
  var x = this[0]
  if ((x & 1) == 0) return 0
  var y = x & 3; // y == 1/x mod 2^2
  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y > 0) ? this.DV - y : -y
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m
  this.mp = m.invDigit()
  this.mpl = this.mp & 0x7fff
  this.mph = this.mp >> 15
  this.um = (1 << (m.DB - 15)) - 1
  this.mt2 = 2 * m.t
}

// xR mod m
function montConvert(x) {
  var r = new BigInteger()
  x.abs()
    .dlShiftTo(this.m.t, r)
  r.divRemTo(this.m, null, r)
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r)
  return r
}

// x/R mod m
function montRevert(x) {
  var r = new BigInteger()
  x.copyTo(r)
  this.reduce(r)
  return r
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while (x.t <= this.mt2) // pad x so am has enough room later
    x[x.t++] = 0
  for (var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x[i]*mp mod DV
    var j = x[i] & 0x7fff
    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM
    // use am to combine the multiply-shift-add into one call
    j = i + this.m.t
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t)
    // propagate carry
    while (x[j] >= x.DV) {
      x[j] -= x.DV
      x[++j]++
    }
  }
  x.clamp()
  x.drShiftTo(this.m.t, x)
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x)
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Montgomery.prototype.convert = montConvert
Montgomery.prototype.revert = montRevert
Montgomery.prototype.reduce = montReduce
Montgomery.prototype.mulTo = montMulTo
Montgomery.prototype.sqrTo = montSqrTo

// (protected) true iff this is even
function bnpIsEven() {
  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
  if (e > 0xffffffff || e < 1) return BigInteger.ONE
  var r = new BigInteger(),
    r2 = new BigInteger(),
    g = z.convert(this),
    i = nbits(e) - 1
  g.copyTo(r)
  while (--i >= 0) {
    z.sqrTo(r, r2)
    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r)
    else {
      var t = r
      r = r2
      r2 = t
    }
  }
  return z.revert(r)
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
  var z
  if (e < 256 || m.isEven()) z = new Classic(m)
  else z = new Montgomery(m)
  return this.exp(e, z)
}

// protected
proto.copyTo = bnpCopyTo
proto.fromInt = bnpFromInt
proto.fromString = bnpFromString
proto.clamp = bnpClamp
proto.dlShiftTo = bnpDLShiftTo
proto.drShiftTo = bnpDRShiftTo
proto.lShiftTo = bnpLShiftTo
proto.rShiftTo = bnpRShiftTo
proto.subTo = bnpSubTo
proto.multiplyTo = bnpMultiplyTo
proto.squareTo = bnpSquareTo
proto.divRemTo = bnpDivRemTo
proto.invDigit = bnpInvDigit
proto.isEven = bnpIsEven
proto.exp = bnpExp

// public
proto.toString = bnToString
proto.negate = bnNegate
proto.abs = bnAbs
proto.compareTo = bnCompareTo
proto.bitLength = bnBitLength
proto.byteLength = bnByteLength
proto.mod = bnMod
proto.modPowInt = bnModPowInt

// (public)
function bnClone() {
  var r = new BigInteger()
  this.copyTo(r)
  return r
}

// (public) return value as integer
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this[0] - this.DV
    else if (this.t == 0) return -1
  } else if (this.t == 1) return this[0]
  else if (this.t == 0) return 0
  // assumes 16 < DB < 32
  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
}

// (public) return value as byte
function bnByteValue() {
  return (this.t == 0) ? this.s : (this[0] << 24) >> 24
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
  return (this.t == 0) ? this.s : (this[0] << 16) >> 16
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r))
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
  if (this.s < 0) return -1
  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0
  else return 1
}

// (protected) convert to radix string
function bnpToRadix(b) {
  if (b == null) b = 10
  if (this.signum() == 0 || b < 2 || b > 36) return "0"
  var cs = this.chunkSize(b)
  var a = Math.pow(b, cs)
  var d = nbv(a),
    y = new BigInteger(),
    z = new BigInteger(),
    r = ""
  this.divRemTo(d, y, z)
  while (y.signum() > 0) {
    r = (a + z.intValue())
      .toString(b)
      .substr(1) + r
    y.divRemTo(d, y, z)
  }
  return z.intValue()
    .toString(b) + r
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
  var self = this
  self.fromInt(0)
  if (b == null) b = 10
  var cs = self.chunkSize(b)
  var d = Math.pow(b, cs),
    mi = false,
    j = 0,
    w = 0
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i)
    if (x < 0) {
      if (s.charAt(i) == "-" && self.signum() == 0) mi = true
      continue
    }
    w = b * w + x
    if (++j >= cs) {
      self.dMultiply(d)
      self.dAddOffset(w, 0)
      j = 0
      w = 0
    }
  }
  if (j > 0) {
    self.dMultiply(Math.pow(b, j))
    self.dAddOffset(w, 0)
  }
  if (mi) BigInteger.ZERO.subTo(self, self)
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
  var self = this
  if ("number" == typeof b) {
    // new BigInteger(int,int,RNG)
    if (a < 2) self.fromInt(1)
    else {
      self.fromNumber(a, c)
      if (!self.testBit(a - 1)) // force MSB set
        self.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, self)
      if (self.isEven()) self.dAddOffset(1, 0); // force odd
      while (!self.isProbablePrime(b)) {
        self.dAddOffset(2, 0)
        if (self.bitLength() > a) self.subTo(BigInteger.ONE.shiftLeft(a - 1), self)
      }
    }
  } else {
    // new BigInteger(int,RNG)
    var x = new Array(),
      t = a & 7
    x.length = (a >> 3) + 1
    b.nextBytes(x)
    if (t > 0) x[0] &= ((1 << t) - 1)
    else x[0] = 0
    self.fromString(x, 256)
  }
}

// (public) convert to bigendian byte array
function bnToByteArray() {
  var self = this
  var i = self.t,
    r = new Array()
  r[0] = self.s
  var p = self.DB - (i * self.DB) % 8,
    d, k = 0
  if (i-- > 0) {
    if (p < self.DB && (d = self[i] >> p) != (self.s & self.DM) >> p)
      r[k++] = d | (self.s << (self.DB - p))
    while (i >= 0) {
      if (p < 8) {
        d = (self[i] & ((1 << p) - 1)) << (8 - p)
        d |= self[--i] >> (p += self.DB - 8)
      } else {
        d = (self[i] >> (p -= 8)) & 0xff
        if (p <= 0) {
          p += self.DB
          --i
        }
      }
      if ((d & 0x80) != 0) d |= -256
      if (k === 0 && (self.s & 0x80) != (d & 0x80))++k
      if (k > 0 || d != self.s) r[k++] = d
    }
  }
  return r
}

function bnEquals(a) {
  return (this.compareTo(a) == 0)
}

function bnMin(a) {
  return (this.compareTo(a) < 0) ? this : a
}

function bnMax(a) {
  return (this.compareTo(a) > 0) ? this : a
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
  var self = this
  var i, f, m = Math.min(a.t, self.t)
  for (i = 0; i < m; ++i) r[i] = op(self[i], a[i])
  if (a.t < self.t) {
    f = a.s & self.DM
    for (i = m; i < self.t; ++i) r[i] = op(self[i], f)
    r.t = self.t
  } else {
    f = self.s & self.DM
    for (i = m; i < a.t; ++i) r[i] = op(f, a[i])
    r.t = a.t
  }
  r.s = op(self.s, a.s)
  r.clamp()
}

// (public) this & a
function op_and(x, y) {
  return x & y
}

function bnAnd(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_and, r)
  return r
}

// (public) this | a
function op_or(x, y) {
  return x | y
}

function bnOr(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_or, r)
  return r
}

// (public) this ^ a
function op_xor(x, y) {
  return x ^ y
}

function bnXor(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_xor, r)
  return r
}

// (public) this & ~a
function op_andnot(x, y) {
  return x & ~y
}

function bnAndNot(a) {
  var r = new BigInteger()
  this.bitwiseTo(a, op_andnot, r)
  return r
}

// (public) ~this
function bnNot() {
  var r = new BigInteger()
  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i]
  r.t = this.t
  r.s = ~this.s
  return r
}

// (public) this << n
function bnShiftLeft(n) {
  var r = new BigInteger()
  if (n < 0) this.rShiftTo(-n, r)
  else this.lShiftTo(n, r)
  return r
}

// (public) this >> n
function bnShiftRight(n) {
  var r = new BigInteger()
  if (n < 0) this.lShiftTo(-n, r)
  else this.rShiftTo(n, r)
  return r
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
  if (x == 0) return -1
  var r = 0
  if ((x & 0xffff) == 0) {
    x >>= 16
    r += 16
  }
  if ((x & 0xff) == 0) {
    x >>= 8
    r += 8
  }
  if ((x & 0xf) == 0) {
    x >>= 4
    r += 4
  }
  if ((x & 3) == 0) {
    x >>= 2
    r += 2
  }
  if ((x & 1) == 0)++r
  return r
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0) return i * this.DB + lbit(this[i])
  if (this.s < 0) return this.t * this.DB
  return -1
}

// return number of 1 bits in x
function cbit(x) {
  var r = 0
  while (x != 0) {
    x &= x - 1
    ++r
  }
  return r
}

// (public) return number of set bits
function bnBitCount() {
  var r = 0,
    x = this.s & this.DM
  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x)
  return r
}

// (public) true iff nth bit is set
function bnTestBit(n) {
  var j = Math.floor(n / this.DB)
  if (j >= this.t) return (this.s != 0)
  return ((this[j] & (1 << (n % this.DB))) != 0)
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n)
  this.bitwiseTo(r, op, r)
  return r
}

// (public) this | (1<<n)
function bnSetBit(n) {
  return this.changeBit(n, op_or)
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
  return this.changeBit(n, op_andnot)
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
  return this.changeBit(n, op_xor)
}

// (protected) r = this + a
function bnpAddTo(a, r) {
  var self = this

  var i = 0,
    c = 0,
    m = Math.min(a.t, self.t)
  while (i < m) {
    c += self[i] + a[i]
    r[i++] = c & self.DM
    c >>= self.DB
  }
  if (a.t < self.t) {
    c += a.s
    while (i < self.t) {
      c += self[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += self.s
  } else {
    c += self.s
    while (i < a.t) {
      c += a[i]
      r[i++] = c & self.DM
      c >>= self.DB
    }
    c += a.s
  }
  r.s = (c < 0) ? -1 : 0
  if (c > 0) r[i++] = c
  else if (c < -1) r[i++] = self.DV + c
  r.t = i
  r.clamp()
}

// (public) this + a
function bnAdd(a) {
  var r = new BigInteger()
  this.addTo(a, r)
  return r
}

// (public) this - a
function bnSubtract(a) {
  var r = new BigInteger()
  this.subTo(a, r)
  return r
}

// (public) this * a
function bnMultiply(a) {
  var r = new BigInteger()
  this.multiplyTo(a, r)
  return r
}

// (public) this^2
function bnSquare() {
  var r = new BigInteger()
  this.squareTo(r)
  return r
}

// (public) this / a
function bnDivide(a) {
  var r = new BigInteger()
  this.divRemTo(a, r, null)
  return r
}

// (public) this % a
function bnRemainder(a) {
  var r = new BigInteger()
  this.divRemTo(a, null, r)
  return r
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
  var q = new BigInteger(),
    r = new BigInteger()
  this.divRemTo(a, q, r)
  return new Array(q, r)
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t)
  ++this.t
  this.clamp()
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
  if (n == 0) return
  while (this.t <= w) this[this.t++] = 0
  this[w] += n
  while (this[w] >= this.DV) {
    this[w] -= this.DV
    if (++w >= this.t) this[this.t++] = 0
    ++this[w]
  }
}

// A "null" reducer
function NullExp() {}

function nNop(x) {
  return x
}

function nMulTo(x, y, r) {
  x.multiplyTo(y, r)
}

function nSqrTo(x, r) {
  x.squareTo(r)
}

NullExp.prototype.convert = nNop
NullExp.prototype.revert = nNop
NullExp.prototype.mulTo = nMulTo
NullExp.prototype.sqrTo = nSqrTo

// (public) this^e
function bnPow(e) {
  return this.exp(e, new NullExp())
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n)
  r.s = 0; // assumes a,this >= 0
  r.t = i
  while (i > 0) r[--i] = 0
  var j
  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t)
  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i)
  r.clamp()
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {
  --n
  var i = r.t = this.t + a.t - n
  r.s = 0; // assumes a,this >= 0
  while (--i >= 0) r[i] = 0
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n)
  r.clamp()
  r.drShiftTo(1, r)
}

// Barrett modular reduction
function Barrett(m) {
  // setup Barrett
  this.r2 = new BigInteger()
  this.q3 = new BigInteger()
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2)
  this.mu = this.r2.divide(m)
  this.m = m
}

function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m)
  else if (x.compareTo(this.m) < 0) return x
  else {
    var r = new BigInteger()
    x.copyTo(r)
    this.reduce(r)
    return r
  }
}

function barrettRevert(x) {
  return x
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
  var self = this
  x.drShiftTo(self.m.t - 1, self.r2)
  if (x.t > self.m.t + 1) {
    x.t = self.m.t + 1
    x.clamp()
  }
  self.mu.multiplyUpperTo(self.r2, self.m.t + 1, self.q3)
  self.m.multiplyLowerTo(self.q3, self.m.t + 1, self.r2)
  while (x.compareTo(self.r2) < 0) x.dAddOffset(1, self.m.t + 1)
  x.subTo(self.r2, x)
  while (x.compareTo(self.m) >= 0) x.subTo(self.m, x)
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
  x.squareTo(r)
  this.reduce(r)
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r)
  this.reduce(r)
}

Barrett.prototype.convert = barrettConvert
Barrett.prototype.revert = barrettRevert
Barrett.prototype.reduce = barrettReduce
Barrett.prototype.mulTo = barrettMulTo
Barrett.prototype.sqrTo = barrettSqrTo

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
  var i = e.bitLength(),
    k, r = nbv(1),
    z
  if (i <= 0) return r
  else if (i < 18) k = 1
  else if (i < 48) k = 3
  else if (i < 144) k = 4
  else if (i < 768) k = 5
  else k = 6
  if (i < 8)
    z = new Classic(m)
  else if (m.isEven())
    z = new Barrett(m)
  else
    z = new Montgomery(m)

  // precomputation
  var g = new Array(),
    n = 3,
    k1 = k - 1,
    km = (1 << k) - 1
  g[1] = z.convert(this)
  if (k > 1) {
    var g2 = new BigInteger()
    z.sqrTo(g[1], g2)
    while (n <= km) {
      g[n] = new BigInteger()
      z.mulTo(g2, g[n - 2], g[n])
      n += 2
    }
  }

  var j = e.t - 1,
    w, is1 = true,
    r2 = new BigInteger(),
    t
  i = nbits(e[j]) - 1
  while (j >= 0) {
    if (i >= k1) w = (e[j] >> (i - k1)) & km
    else {
      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i)
      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1)
    }

    n = k
    while ((w & 1) == 0) {
      w >>= 1
      --n
    }
    if ((i -= n) < 0) {
      i += this.DB
      --j
    }
    if (is1) { // ret == 1, don't bother squaring or multiplying it
      g[w].copyTo(r)
      is1 = false
    } else {
      while (n > 1) {
        z.sqrTo(r, r2)
        z.sqrTo(r2, r)
        n -= 2
      }
      if (n > 0) z.sqrTo(r, r2)
      else {
        t = r
        r = r2
        r2 = t
      }
      z.mulTo(r2, g[w], r)
    }

    while (j >= 0 && (e[j] & (1 << i)) == 0) {
      z.sqrTo(r, r2)
      t = r
      r = r2
      r2 = t
      if (--i < 0) {
        i = this.DB - 1
        --j
      }
    }
  }
  return z.revert(r)
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
  var x = (this.s < 0) ? this.negate() : this.clone()
  var y = (a.s < 0) ? a.negate() : a.clone()
  if (x.compareTo(y) < 0) {
    var t = x
    x = y
    y = t
  }
  var i = x.getLowestSetBit(),
    g = y.getLowestSetBit()
  if (g < 0) return x
  if (i < g) g = i
  if (g > 0) {
    x.rShiftTo(g, x)
    y.rShiftTo(g, y)
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x)
    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y)
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x)
      x.rShiftTo(1, x)
    } else {
      y.subTo(x, y)
      y.rShiftTo(1, y)
    }
  }
  if (g > 0) y.lShiftTo(g, y)
  return y
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
  if (n <= 0) return 0
  var d = this.DV % n,
    r = (this.s < 0) ? n - 1 : 0
  if (this.t > 0)
    if (d == 0) r = this[0] % n
    else
      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n
  return r
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
  var ac = m.isEven()
  if (this.signum() === 0) throw new Error('division by zero')
  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO
  var u = m.clone(),
    v = this.clone()
  var a = nbv(1),
    b = nbv(0),
    c = nbv(0),
    d = nbv(1)
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u)
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a)
          b.subTo(m, b)
        }
        a.rShiftTo(1, a)
      } else if (!b.isEven()) b.subTo(m, b)
      b.rShiftTo(1, b)
    }
    while (v.isEven()) {
      v.rShiftTo(1, v)
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c)
          d.subTo(m, d)
        }
        c.rShiftTo(1, c)
      } else if (!d.isEven()) d.subTo(m, d)
      d.rShiftTo(1, d)
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u)
      if (ac) a.subTo(c, a)
      b.subTo(d, b)
    } else {
      v.subTo(u, v)
      if (ac) c.subTo(a, c)
      d.subTo(b, d)
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO
  while (d.compareTo(m) >= 0) d.subTo(m, d)
  while (d.signum() < 0) d.addTo(m, d)
  return d
}

var lowprimes = [
  2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
  73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
  157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
  239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
  331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
  421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
  509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
  613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
  709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
  821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
  919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
]

var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
  var i, x = this.abs()
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i]) return true
    return false
  }
  if (x.isEven()) return false
  i = 1
  while (i < lowprimes.length) {
    var m = lowprimes[i],
      j = i + 1
    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++]
    m = x.modInt(m)
    while (i < j) if (m % lowprimes[i++] == 0) return false
  }
  return x.millerRabin(t)
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE)
  var k = n1.getLowestSetBit()
  if (k <= 0) return false
  var r = n1.shiftRight(k)
  t = (t + 1) >> 1
  if (t > lowprimes.length) t = lowprimes.length
  var a = new BigInteger(null)
  var j, bases = []
  for (var i = 0; i < t; ++i) {
    for (;;) {
      j = lowprimes[Math.floor(Math.random() * lowprimes.length)]
      if (bases.indexOf(j) == -1) break
    }
    bases.push(j)
    a.fromInt(j)
    var y = a.modPow(r, this)
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this)
        if (y.compareTo(BigInteger.ONE) == 0) return false
      }
      if (y.compareTo(n1) != 0) return false
    }
  }
  return true
}

// protected
proto.chunkSize = bnpChunkSize
proto.toRadix = bnpToRadix
proto.fromRadix = bnpFromRadix
proto.fromNumber = bnpFromNumber
proto.bitwiseTo = bnpBitwiseTo
proto.changeBit = bnpChangeBit
proto.addTo = bnpAddTo
proto.dMultiply = bnpDMultiply
proto.dAddOffset = bnpDAddOffset
proto.multiplyLowerTo = bnpMultiplyLowerTo
proto.multiplyUpperTo = bnpMultiplyUpperTo
proto.modInt = bnpModInt
proto.millerRabin = bnpMillerRabin

// public
proto.clone = bnClone
proto.intValue = bnIntValue
proto.byteValue = bnByteValue
proto.shortValue = bnShortValue
proto.signum = bnSigNum
proto.toByteArray = bnToByteArray
proto.equals = bnEquals
proto.min = bnMin
proto.max = bnMax
proto.and = bnAnd
proto.or = bnOr
proto.xor = bnXor
proto.andNot = bnAndNot
proto.not = bnNot
proto.shiftLeft = bnShiftLeft
proto.shiftRight = bnShiftRight
proto.getLowestSetBit = bnGetLowestSetBit
proto.bitCount = bnBitCount
proto.testBit = bnTestBit
proto.setBit = bnSetBit
proto.clearBit = bnClearBit
proto.flipBit = bnFlipBit
proto.add = bnAdd
proto.subtract = bnSubtract
proto.multiply = bnMultiply
proto.divide = bnDivide
proto.remainder = bnRemainder
proto.divideAndRemainder = bnDivideAndRemainder
proto.modPow = bnModPow
proto.modInverse = bnModInverse
proto.pow = bnPow
proto.gcd = bnGCD
proto.isProbablePrime = bnIsProbablePrime

// JSBN-specific extension
proto.square = bnSquare

// constants
BigInteger.ZERO = nbv(0)
BigInteger.ONE = nbv(1)
BigInteger.valueOf = nbv

module.exports = BigInteger

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/bigi.js","/../node_modules/bigi/lib")
},{"../package.json":7,"buffer":11,"pBGvAp":74}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// FIXME: Kind of a weird way to throw exceptions, consider removing
var assert = require('assert')
var BigInteger = require('./bigi')

/**
 * Turns a byte array into a big integer.
 *
 * This function will interpret a byte array as a big integer in big
 * endian notation.
 */
BigInteger.fromByteArrayUnsigned = function(byteArray) {
  // BigInteger expects a DER integer conformant byte array
  if (byteArray[0] & 0x80) {
    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(byteArray)
}

/**
 * Returns a byte array representation of the big integer.
 *
 * This returns the absolute of the contained value in big endian
 * form. A value of zero results in an empty array.
 */
BigInteger.prototype.toByteArrayUnsigned = function() {
  var byteArray = this.toByteArray()
  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray
}

BigInteger.fromDERInteger = function(byteArray) {
  return new BigInteger(byteArray)
}

/*
 * Converts BigInteger to a DER integer representation.
 *
 * The format for this value uses the most significant bit as a sign
 * bit.  If the most significant bit is already set and the integer is
 * positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
BigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray

BigInteger.fromBuffer = function(buffer) {
  // BigInteger expects a DER integer conformant byte array
  if (buffer[0] & 0x80) {
    var byteArray = Array.prototype.slice.call(buffer)

    return new BigInteger([0].concat(byteArray))
  }

  return new BigInteger(buffer)
}

BigInteger.fromHex = function(hex) {
  if (hex === '') return BigInteger.ZERO

  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')
  assert.equal(hex.length % 2, 0, 'Incomplete hex')
  return new BigInteger(hex, 16)
}

BigInteger.prototype.toBuffer = function(size) {
  var byteArray = this.toByteArrayUnsigned()
  var zeros = []

  var padding = size - byteArray.length
  while (zeros.length < padding) zeros.push(0)

  return new Buffer(zeros.concat(byteArray))
}

BigInteger.prototype.toHex = function(size) {
  return this.toBuffer(size).toString('hex')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/convert.js","/../node_modules/bigi/lib")
},{"./bigi":4,"assert":1,"buffer":11,"pBGvAp":74}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('./bigi')

//addons
require('./convert')

module.exports = BigInteger
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bigi/lib/index.js","/../node_modules/bigi/lib")
},{"./bigi":4,"./convert":5,"buffer":11,"pBGvAp":74}],7:[function(require,module,exports){
module.exports={
  "_args": [
    [
      {
        "raw": "bigi@^1.4.2",
        "scope": null,
        "escapedName": "bigi",
        "name": "bigi",
        "rawSpec": "^1.4.2",
        "spec": ">=1.4.2 <2.0.0",
        "type": "range"
      },
      "/Users/m/p/esteem/node_modules/steemauth"
    ]
  ],
  "_from": "bigi@>=1.4.2 <2.0.0",
  "_id": "bigi@1.4.2",
  "_inCache": true,
  "_installable": true,
  "_location": "/bigi",
  "_nodeVersion": "6.1.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/bigi-1.4.2.tgz_1469584192413_0.6801238611806184"
  },
  "_npmUser": {
    "name": "jprichardson",
    "email": "jprichardson@gmail.com"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {},
  "_requested": {
    "raw": "bigi@^1.4.2",
    "scope": null,
    "escapedName": "bigi",
    "name": "bigi",
    "rawSpec": "^1.4.2",
    "spec": ">=1.4.2 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ecurve",
    "/steemauth"
  ],
  "_resolved": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz",
  "_shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
  "_shrinkwrap": null,
  "_spec": "bigi@^1.4.2",
  "_where": "/Users/m/p/esteem/node_modules/steemauth",
  "bugs": {
    "url": "https://github.com/cryptocoinjs/bigi/issues"
  },
  "dependencies": {},
  "description": "Big integers.",
  "devDependencies": {
    "coveralls": "^2.11.2",
    "istanbul": "^0.3.5",
    "jshint": "^2.5.1",
    "mocha": "^2.1.0",
    "mochify": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "9c665a95f88b8b08fc05cfd731f561859d725825",
    "tarball": "https://registry.npmjs.org/bigi/-/bigi-1.4.2.tgz"
  },
  "gitHead": "c25308081c896ff84702303722bf5ecd8b3f78e3",
  "homepage": "https://github.com/cryptocoinjs/bigi#readme",
  "keywords": [
    "cryptography",
    "math",
    "bitcoin",
    "arbitrary",
    "precision",
    "arithmetic",
    "big",
    "integer",
    "int",
    "number",
    "biginteger",
    "bigint",
    "bignumber",
    "decimal",
    "float"
  ],
  "main": "./lib/index.js",
  "maintainers": [
    {
      "name": "midnightlightning",
      "email": "boydb@midnightdesign.ws"
    },
    {
      "name": "sidazhang",
      "email": "sidazhang89@gmail.com"
    },
    {
      "name": "nadav",
      "email": "npm@shesek.info"
    },
    {
      "name": "jprichardson",
      "email": "jprichardson@gmail.com"
    }
  ],
  "name": "bigi",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "url": "git+https://github.com/cryptocoinjs/bigi.git",
    "type": "git"
  },
  "scripts": {
    "browser-test": "mochify --wd -R spec",
    "coverage": "istanbul cover ./node_modules/.bin/_mocha -- --reporter list test/*.js",
    "coveralls": "npm run-script coverage && node ./node_modules/.bin/coveralls < coverage/lcov.info",
    "jshint": "jshint --config jshint.json lib/*.js ; true",
    "test": "_mocha -- test/*.js",
    "unit": "mocha"
  },
  "testling": {
    "files": "test/*.js",
    "harness": "mocha",
    "browsers": [
      "ie/9..latest",
      "firefox/latest",
      "chrome/latest",
      "safari/6.0..latest",
      "iphone/6.0..latest",
      "android-browser/4.2..latest"
    ]
  },
  "version": "1.4.2"
}

},{}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browser-resolve/empty.js","/../node_modules/browser-resolve")
},{"buffer":11,"pBGvAp":74}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/browserify/node_modules/string_decoder/index.js","/../node_modules/browserify/node_modules/string_decoder")
},{"buffer":11,"pBGvAp":74}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var basex = require('base-x')
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
var base58 = basex(ALPHABET)

module.exports = {
  encode: base58.encode,
  decode: base58.decode
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bs58/index.js","/../node_modules/bs58")
},{"base-x":2,"buffer":11,"pBGvAp":74}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/buffer/index.js","/../node_modules/buffer")
},{"base64-js":3,"buffer":11,"ieee754":70,"pBGvAp":74}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define(["long"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module['exports'] = (function() {
            var Long; try { Long = require("long"); } catch (e) {}
            return factory(Long);
        })();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/bytebuffer/dist/bytebuffer.js","/../node_modules/bytebuffer/dist")
},{"buffer":11,"long":72,"pBGvAp":74}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Transform = require('stream').Transform
var inherits = require('inherits')
var StringDecoder = require('string_decoder').StringDecoder
module.exports = CipherBase
inherits(CipherBase, Transform)
function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  this._decoder = null
  this._encoding = null
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc)
  }
  var outData = this._update(data)
  if (this.hashMode) {
    return this
  }
  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }
  return outData
}

CipherBase.prototype.setAutoPadding = function () {}

CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this._final())
  } catch (e) {
    err = e
  } finally {
    done(err)
  }
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this._final() || new Buffer('')
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }
  if (this._encoding !== enc) {
    throw new Error('can\'t switch encodings')
  }
  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }
  return out
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/cipher-base/index.js","/../node_modules/cipher-base")
},{"buffer":11,"inherits":71,"pBGvAp":74,"stream":91,"string_decoder":9}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Base = require('cipher-base')

function HashNoConstructor(hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash(hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg || 'ripemd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/browser.js","/../node_modules/create-hash")
},{"./md5":16,"buffer":11,"cipher-base":13,"inherits":71,"pBGvAp":74,"ripemd160":75,"sha.js":78}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/helpers.js","/../node_modules/create-hash")
},{"buffer":11,"pBGvAp":74}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hash/md5.js","/../node_modules/create-hash")
},{"./helpers":15,"buffer":11,"pBGvAp":74}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)
  alg = alg.toLowerCase()
  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/create-hmac/browser.js","/../node_modules/create-hmac")
},{"buffer":11,"create-hash/browser":14,"inherits":71,"pBGvAp":74,"stream":91}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/aes.js","/../node_modules/crypto-js")
},{"./cipher-core":19,"./core":20,"./enc-base64":21,"./evpkdf":23,"./md5":25,"buffer":11,"pBGvAp":74}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;

	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }
	            this._mode = modeCreator.call(mode, this, iv && iv.words);
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/cipher-core.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/core.js","/../node_modules/crypto-js")
},{"buffer":11,"pBGvAp":74}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-base64.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/enc-hex.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/evpkdf.js","/../node_modules/crypto-js")
},{"./core":20,"./hmac":24,"./sha1":26,"buffer":11,"pBGvAp":74}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/hmac.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/md5.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/crypto-js/sha1.js","/../node_modules/crypto-js")
},{"./core":20,"buffer":11,"pBGvAp":74}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var currencySymbolMap = require('./map');

var symbolCurrencyMap = {};
Object.keys(currencySymbolMap).forEach(function (key) {
  symbolCurrencyMap[currencySymbolMap[key]] = key
})

function getSymbolFromCurrency(currencyCode) {
  if (typeof currencyCode !== 'string') return undefined
  var code = currencyCode.toUpperCase();
  if (!currencySymbolMap.hasOwnProperty(code)) return undefined
  return currencySymbolMap[code];
}

function getCurrencyFromSymbol(symbol) {
  if (!symbolCurrencyMap.hasOwnProperty(symbol)) return undefined
  return symbolCurrencyMap[symbol]
}

function getSymbol(currencyCode) {
  if (typeof currencyCode !== 'string') return '?'
  var symbol = getSymbolFromCurrency(currencyCode.toUpperCase())
  return symbol !== undefined ? symbol : '?'
}

module.exports = getSymbol
module.exports.getSymbolFromCurrency = getSymbolFromCurrency
module.exports.getCurrencyFromSymbol = getCurrencyFromSymbol
module.exports.symbolCurrencyMap = symbolCurrencyMap
module.exports.currencySymbolMap = currencySymbolMap

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/currency-symbol-map.js","/../node_modules/currency-symbol-map")
},{"./map":28,"buffer":11,"pBGvAp":74}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports =
{ "ALL": "L"
, "AFN": ""
, "ARS": "$"
, "AWG": ""
, "AUD": "$"
, "AZN": ""
, "BSD": "$"
, "BBD": "$"
, "BYR": "p."
, "BZD": "BZ$"
, "BMD": "$"
, "BOB": "Bs."
, "BAM": "KM"
, "BWP": "P"
, "BGN": ""
, "BRL": "R$"
, "BND": "$"
, "BTC": ""
, "KHR": ""
, "CAD": "$"
, "KYD": "$"
, "CLP": "$"
, "CNY": ""
, "COP": "$"
, "CRC": ""
, "HRK": "kn"
, "CUP": ""
, "CZK": "K"
, "DKK": "kr"
, "DOP": "RD$"
, "XCD": "$"
, "EGP": ""
, "SVC": "$"
, "EEK": "kr"
, "EUR": ""
, "FKP": ""
, "FJD": "$"
, "GHC": ""
, "GIP": ""
, "GTQ": "Q"
, "GGP": ""
, "GYD": "$"
, "HNL": "L"
, "HKD": "$"
, "HUF": "Ft"
, "ISK": "kr"
, "INR": ""
, "IDR": "Rp"
, "IRR": ""
, "IMP": ""
, "ILS": ""
, "JMD": "J$"
, "JPY": ""
, "JEP": ""
, "KES": "KSh"
, "KZT": ""
, "KPW": ""
, "KRW": ""
, "KGS": ""
, "LAK": ""
, "LVL": "Ls"
, "LBP": ""
, "LRD": "$"
, "LTL": "Lt"
, "MKD": ""
, "MYR": "RM"
, "MUR": ""
, "MXN": "$"
, "MNT": ""
, "MZN": "MT"
, "NAD": "$"
, "NPR": ""
, "ANG": ""
, "NZD": "$"
, "NIO": "C$"
, "NGN": ""
, "NOK": "kr"
, "OMR": ""
, "PKR": ""
, "PAB": "B/."
, "PYG": "Gs"
, "PEN": "S/."
, "PHP": ""
, "PLN": "z"
, "QAR": ""
, "RON": "lei"
, "RUB": ""
, "RMB": ""
, "SHP": ""
, "SAR": ""
, "RSD": "."
, "SCR": ""
, "SGD": "$"
, "SBD": "$"
, "SOS": "S"
, "ZAR": "R"
, "LKR": ""
, "SEK": "kr"
, "CHF": "CHF"
, "SRD": "$"
, "SYP": ""
, "TZS": "TSh"
, "TWD": "NT$"
, "THB": ""
, "TTD": "TT$"
, "TRY": ""
, "TRL": ""
, "TVD": "$"
, "UGX": "USh"
, "UAH": ""
, "GBP": ""
, "USD": "$"
, "UYU": "$U"
, "UZS": ""
, "VEF": "Bs"
, "VND": ""
, "YER": ""
, "ZWD": "Z$"
, "GEL": ""
, "KZT": ""
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/currency-symbol-map/map.js","/../node_modules/currency-symbol-map")
},{"buffer":11,"pBGvAp":74}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict'

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/diff-match-patch/index.js","/../node_modules/diff-match-patch")
},{"buffer":11,"pBGvAp":74}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var Point = require('./point')

function Curve (p, a, b, Gx, Gy, n, h) {
  this.p = p
  this.a = a
  this.b = b
  this.G = Point.fromAffine(this, Gx, Gy)
  this.n = n
  this.h = h

  this.infinity = new Point(this, null, null, BigInteger.ZERO)

  // result caching
  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)
}

Curve.prototype.pointFromX = function (isOdd, x) {
  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)
  var beta = alpha.modPow(this.pOverFour, this.p) // XXX: not compatible with all curves

  var y = beta
  if (beta.isEven() ^ !isOdd) {
    y = this.p.subtract(y) // -y % p
  }

  return Point.fromAffine(this, x, y)
}

Curve.prototype.isInfinity = function (Q) {
  if (Q === this.infinity) return true

  return Q.z.signum() === 0 && Q.y.signum() !== 0
}

Curve.prototype.isOnCurve = function (Q) {
  if (this.isInfinity(Q)) return true

  var x = Q.affineX
  var y = Q.affineY
  var a = this.a
  var b = this.b
  var p = this.p

  // Check that xQ and yQ are integers in the interval [0, p - 1]
  if (x.signum() < 0 || x.compareTo(p) >= 0) return false
  if (y.signum() < 0 || y.compareTo(p) >= 0) return false

  // and check that y^2 = x^3 + ax + b (mod p)
  var lhs = y.square().mod(p)
  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)
  return lhs.equals(rhs)
}

/**
 * Validate an elliptic curve point.
 *
 * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive
 */
Curve.prototype.validate = function (Q) {
  // Check Q != O
  assert(!this.isInfinity(Q), 'Point is at infinity')
  assert(this.isOnCurve(Q), 'Point is not on the curve')

  // Check nQ = O (where Q is a scalar multiple of G)
  var nQ = Q.multiply(this.n)
  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')

  return true
}

module.exports = Curve

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/curve.js","/../node_modules/ecurve/lib")
},{"./point":34,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],31:[function(require,module,exports){
module.exports={
  "secp128r1": {
    "p": "fffffffdffffffffffffffffffffffff",
    "a": "fffffffdfffffffffffffffffffffffc",
    "b": "e87579c11079f43dd824993c2cee5ed3",
    "n": "fffffffe0000000075a30d1b9038a115",
    "h": "01",
    "Gx": "161ff7528b899b2d0c28607ca52c5b86",
    "Gy": "cf5ac8395bafeb13c02da292dded7a83"
  },
  "secp160k1": {
    "p": "fffffffffffffffffffffffffffffffeffffac73",
    "a": "00",
    "b": "07",
    "n": "0100000000000000000001b8fa16dfab9aca16b6b3",
    "h": "01",
    "Gx": "3b4c382ce37aa192a4019e763036f4f5dd4d7ebb",
    "Gy": "938cf935318fdced6bc28286531733c3f03c4fee"
  },
  "secp160r1": {
    "p": "ffffffffffffffffffffffffffffffff7fffffff",
    "a": "ffffffffffffffffffffffffffffffff7ffffffc",
    "b": "1c97befc54bd7a8b65acf89f81d4d4adc565fa45",
    "n": "0100000000000000000001f4c8f927aed3ca752257",
    "h": "01",
    "Gx": "4a96b5688ef573284664698968c38bb913cbfc82",
    "Gy": "23a628553168947d59dcc912042351377ac5fb32"
  },
  "secp192k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffeffffee37",
    "a": "00",
    "b": "03",
    "n": "fffffffffffffffffffffffe26f2fc170f69466a74defd8d",
    "h": "01",
    "Gx": "db4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d",
    "Gy": "9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d"
  },
  "secp192r1": {
    "p": "fffffffffffffffffffffffffffffffeffffffffffffffff",
    "a": "fffffffffffffffffffffffffffffffefffffffffffffffc",
    "b": "64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1",
    "n": "ffffffffffffffffffffffff99def836146bc9b1b4d22831",
    "h": "01",
    "Gx": "188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012",
    "Gy": "07192b95ffc8da78631011ed6b24cdd573f977a11e794811"
  },
  "secp256k1": {
    "p": "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "a": "00",
    "b": "07",
    "n": "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
    "h": "01",
    "Gx": "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    "Gy": "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
  },
  "secp256r1": {
    "p": "ffffffff00000001000000000000000000000000ffffffffffffffffffffffff",
    "a": "ffffffff00000001000000000000000000000000fffffffffffffffffffffffc",
    "b": "5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
    "n": "ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551",
    "h": "01",
    "Gx": "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
    "Gy": "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
  }
}

},{}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var Point = require('./point')
var Curve = require('./curve')

var getCurveByName = require('./names')

module.exports = {
  Curve: Curve,
  Point: Point,
  getCurveByName: getCurveByName
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/index.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./names":33,"./point":34,"buffer":11,"pBGvAp":74}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var BigInteger = require('bigi')

var curves = require('./curves.json')
var Curve = require('./curve')

function getCurveByName (name) {
  var curve = curves[name]
  if (!curve) return null

  var p = new BigInteger(curve.p, 16)
  var a = new BigInteger(curve.a, 16)
  var b = new BigInteger(curve.b, 16)
  var n = new BigInteger(curve.n, 16)
  var h = new BigInteger(curve.h, 16)
  var Gx = new BigInteger(curve.Gx, 16)
  var Gy = new BigInteger(curve.Gy, 16)

  return new Curve(p, a, b, Gx, Gy, n, h)
}

module.exports = getCurveByName

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/names.js","/../node_modules/ecurve/lib")
},{"./curve":30,"./curves.json":31,"bigi":6,"buffer":11,"pBGvAp":74}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var assert = require('assert')
var BigInteger = require('bigi')

var THREE = BigInteger.valueOf(3)

function Point (curve, x, y, z) {
  assert.notStrictEqual(z, undefined, 'Missing Z coordinate')

  this.curve = curve
  this.x = x
  this.y = y
  this.z = z
  this._zInv = null

  this.compressed = true
}

Object.defineProperty(Point.prototype, 'zInv', {
  get: function () {
    if (this._zInv === null) {
      this._zInv = this.z.modInverse(this.curve.p)
    }

    return this._zInv
  }
})

Object.defineProperty(Point.prototype, 'affineX', {
  get: function () {
    return this.x.multiply(this.zInv).mod(this.curve.p)
  }
})

Object.defineProperty(Point.prototype, 'affineY', {
  get: function () {
    return this.y.multiply(this.zInv).mod(this.curve.p)
  }
})

Point.fromAffine = function (curve, x, y) {
  return new Point(curve, x, y, BigInteger.ONE)
}

Point.prototype.equals = function (other) {
  if (other === this) return true
  if (this.curve.isInfinity(this)) return this.curve.isInfinity(other)
  if (this.curve.isInfinity(other)) return this.curve.isInfinity(this)

  // u = Y2 * Z1 - Y1 * Z2
  var u = other.y.multiply(this.z).subtract(this.y.multiply(other.z)).mod(this.curve.p)

  if (u.signum() !== 0) return false

  // v = X2 * Z1 - X1 * Z2
  var v = other.x.multiply(this.z).subtract(this.x.multiply(other.z)).mod(this.curve.p)

  return v.signum() === 0
}

Point.prototype.negate = function () {
  var y = this.curve.p.subtract(this.y)

  return new Point(this.curve, this.x, y, this.z)
}

Point.prototype.add = function (b) {
  if (this.curve.isInfinity(this)) return b
  if (this.curve.isInfinity(b)) return this

  var x1 = this.x
  var y1 = this.y
  var x2 = b.x
  var y2 = b.y

  // u = Y2 * Z1 - Y1 * Z2
  var u = y2.multiply(this.z).subtract(y1.multiply(b.z)).mod(this.curve.p)
  // v = X2 * Z1 - X1 * Z2
  var v = x2.multiply(this.z).subtract(x1.multiply(b.z)).mod(this.curve.p)

  if (v.signum() === 0) {
    if (u.signum() === 0) {
      return this.twice() // this == b, so double
    }

    return this.curve.infinity // this = -b, so infinity
  }

  var v2 = v.square()
  var v3 = v2.multiply(v)
  var x1v2 = x1.multiply(v2)
  var zu2 = u.square().multiply(this.z)

  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p)
  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p)
  // z3 = v^3 * z1 * z2
  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

Point.prototype.twice = function () {
  if (this.curve.isInfinity(this)) return this
  if (this.y.signum() === 0) return this.curve.infinity

  var x1 = this.x
  var y1 = this.y

  var y1z1 = y1.multiply(this.z)
  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p)
  var a = this.curve.a

  // w = 3 * x1^2 + a * z1^2
  var w = x1.square().multiply(THREE)

  if (a.signum() !== 0) {
    w = w.add(this.z.square().multiply(a))
  }

  w = w.mod(this.curve.p)
  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
  var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p)
  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(3)).mod(this.curve.p)
  // z3 = 8 * (y1 * z1)^3
  var z3 = y1z1.pow(3).shiftLeft(3).mod(this.curve.p)

  return new Point(this.curve, x3, y3, z3)
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
Point.prototype.multiply = function (k) {
  if (this.curve.isInfinity(this)) return this
  if (k.signum() === 0) return this.curve.infinity

  var e = k
  var h = e.multiply(THREE)

  var neg = this.negate()
  var R = this

  for (var i = h.bitLength() - 2; i > 0; --i) {
    var hBit = h.testBit(i)
    var eBit = e.testBit(i)

    R = R.twice()

    if (hBit !== eBit) {
      R = R.add(hBit ? this : neg)
    }
  }

  return R
}

// Compute this*j + x*k (simultaneous multiplication)
Point.prototype.multiplyTwo = function (j, x, k) {
  var i = Math.max(j.bitLength(), k.bitLength()) - 1
  var R = this.curve.infinity
  var both = this.add(x)

  while (i >= 0) {
    var jBit = j.testBit(i)
    var kBit = k.testBit(i)

    R = R.twice()

    if (jBit) {
      if (kBit) {
        R = R.add(both)
      } else {
        R = R.add(this)
      }
    } else if (kBit) {
      R = R.add(x)
    }
    --i
  }

  return R
}

Point.prototype.getEncoded = function (compressed) {
  if (compressed == null) compressed = this.compressed
  if (this.curve.isInfinity(this)) return new Buffer('00', 'hex') // Infinity point encoded is simply '00'

  var x = this.affineX
  var y = this.affineY

  var buffer

  // Determine size of q in bytes
  var byteLength = Math.floor((this.curve.p.bitLength() + 7) / 8)

  // 0x02/0x03 | X
  if (compressed) {
    buffer = new Buffer(1 + byteLength)
    buffer.writeUInt8(y.isEven() ? 0x02 : 0x03, 0)

  // 0x04 | X | Y
  } else {
    buffer = new Buffer(1 + byteLength + byteLength)
    buffer.writeUInt8(0x04, 0)

    y.toBuffer(byteLength).copy(buffer, 1 + byteLength)
  }

  x.toBuffer(byteLength).copy(buffer, 1)

  return buffer
}

Point.decodeFrom = function (curve, buffer) {
  var type = buffer.readUInt8(0)
  var compressed = (type !== 4)

  var byteLength = Math.floor((curve.p.bitLength() + 7) / 8)
  var x = BigInteger.fromBuffer(buffer.slice(1, 1 + byteLength))

  var Q
  if (compressed) {
    assert.equal(buffer.length, byteLength + 1, 'Invalid sequence length')
    assert(type === 0x02 || type === 0x03, 'Invalid sequence tag')

    var isOdd = (type === 0x03)
    Q = curve.pointFromX(isOdd, x)
  } else {
    assert.equal(buffer.length, 1 + byteLength + byteLength, 'Invalid sequence length')

    var y = BigInteger.fromBuffer(buffer.slice(1 + byteLength))
    Q = Point.fromAffine(curve, x, y)
  }

  Q.compressed = compressed
  return Q
}

Point.prototype.toString = function () {
  if (this.curve.isInfinity(this)) return '(INFINITY)'

  return '(' + this.affineX.toString() + ',' + this.affineY.toString() + ')'
}

module.exports = Point

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ecurve/lib/point.js","/../node_modules/ecurve/lib")
},{"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var TransactionBuilder = require("./src/TransactionBuilder");

module.exports = {
    TransactionBuilder: TransactionBuilder,
    ChainConfig: require("./src/ChainConfig"),
    ChainTypes: require("./src/ChainTypes"),
    ObjectId: require("./src/ObjectId"),
    NumberUtils: require("./src/NumberUtils"),
    TransactionHelper: require("./src/TransactionHelper"),
    ChainValidation: require("./src/ChainValidation"),
    Login: require("./src/AccountLogin")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/index.js","/../node_modules/esteem-lib/dist/chain")
},{"./src/AccountLogin":36,"./src/ChainConfig":37,"./src/ChainTypes":38,"./src/ChainValidation":39,"./src/NumberUtils":40,"./src/ObjectId":41,"./src/TransactionBuilder":42,"./src/TransactionHelper":43,"buffer":11,"pBGvAp":74}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrivateKey = require("../../ecc/src/PrivateKey");
var key = require("../../ecc/src/KeyUtils");

var KeyCache = function () {
    function KeyCache() {
        _classCallCheck(this, KeyCache);

        this._keyCachePriv = new Map();
        this._keyCachePub = new Map();
        this._myKeys = new Map();
    }

    _createClass(KeyCache, [{
        key: "setPrivKey",
        value: function setPrivKey(key, privKey) {
            this._keyCachePriv.set(key, privKey);
        }
    }, {
        key: "hasPrivKey",
        value: function hasPrivKey(key) {
            return this._keyCachePriv.has(key);
        }
    }, {
        key: "getPrivKey",
        value: function getPrivKey(key) {
            return this._keyCachePriv.get(key);
        }
    }, {
        key: "setPubKey",
        value: function setPubKey(key, pubKey) {
            this._keyCachePub.set(key, pubKey);
        }
    }, {
        key: "hasPubKey",
        value: function hasPubKey(key) {
            return this._keyCachePub.has(key);
        }
    }, {
        key: "getPubKey",
        value: function getPubKey(key) {
            return this._keyCachePub.get(key);;
        }
    }, {
        key: "setMyKey",
        value: function setMyKey(key, privKey) {
            this._myKeys.set(key, privKey);
        }
    }, {
        key: "getMyKey",
        value: function getMyKey(key) {
            return this._myKeys.get(key);
        }
    }]);

    return KeyCache;
}();

var AccountLogin = function () {
    function AccountLogin() {
        _classCallCheck(this, AccountLogin);

        this.reset();
        this.keyCache = new KeyCache();
    }

    _createClass(AccountLogin, [{
        key: "reset",
        value: function reset() {
            this.state = { loggedIn: false, roles: ["active", "owner", "posting", "memo"] };

            this.subs = {};
        }
    }, {
        key: "addSubscription",
        value: function addSubscription(cb) {
            this.subs[cb] = cb;
        }
    }, {
        key: "setRoles",
        value: function setRoles(roles) {
            this.state.roles = roles;
        }
    }, {
        key: "getRoles",
        value: function getRoles() {
            return this.state.roles;
        }
    }, {
        key: "generateKeys",
        value: function generateKeys(accountName, password, roles, prefix) {
            var _this = this;

            if (!accountName || !password) {
                throw new Error("Account name or password required");
            }
            if (password.length < 12) {
                throw new Error("Password must have at least 12 characters");
            }

            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {
                var seed = accountName + role + password;
                var pkey = _this.keyCache.hasPrivKey(role) ? _this.keyCache.getPrivKey(role) : PrivateKey.fromSeed(key.normalize_brainKey(seed));
                _this.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this.keyCache.getPubKey(role) ? _this.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "fromPrivKey",
        value: function fromPrivKey(accountName, privateKey, roles, prefix) {
            var _this2 = this;

            if (!privateKey) {
                return null;
            }
            var privKeys = {};
            var pubKeys = {};

            (roles || this.state.roles).forEach(function (role) {

                var pkey = _this2.keyCache.hasPrivKey(role) ? _this2.keyCache.getPrivKey(role) : PrivateKey.fromWif(privateKey);
                _this2.keyCache.setPrivKey(role, pkey);

                privKeys[role] = pkey;
                pubKeys[role] = _this2.keyCache.getPubKey(role) ? _this2.keyCache.getPubKey(role) : pkey.toPublicKey().toString(prefix);

                _this2.keyCache.setPubKey(role, pubKeys[role]);
            });

            return { privKeys: privKeys, pubKeys: pubKeys };
        }
    }, {
        key: "getPubKeys",
        value: function getPubKeys() {
            var _this3 = this;

            return this.state.roles.map(function (role) {
                return _this3.keyCache.getPubKey(role);
            });
        }
    }, {
        key: "checkKeys",
        value: function checkKeys(_ref) {
            var _this4 = this;

            var accountName = _ref.accountName,
                password = _ref.password,
                auths = _ref.auths,
                _ref$privateKey = _ref.privateKey,
                privateKey = _ref$privateKey === undefined ? null : _ref$privateKey;

            if (!accountName || !password && !privateKey || !auths) {
                throw new Error("checkKeys: Missing inputs");
            }
            var hasKey = false;

            var _loop = function _loop(role) {
                var keys = void 0;
                if (password) {
                    keys = _this4.generateKeys(accountName, password, [role]);
                } else if (privateKey) {
                    keys = _this4.fromPrivKey(accountName, privateKey, [role]);
                }

                if (keys && Object.keys(keys).length) {
                    var _keys = keys,
                        privKeys = _keys.privKeys,
                        pubKeys = _keys.pubKeys;

                    auths[role].forEach(function (key) {
                        if (key[0] === pubKeys[role]) {
                            hasKey = true;
                            _this4.keyCache.setMyKey(role, { priv: privKeys[role], pub: pubKeys[role] });
                        }
                    });
                }
            };

            for (var role in auths) {
                _loop(role);
            };

            if (hasKey) {
                this.name = accountName;
            }

            this.state.loggedIn = hasKey;

            return hasKey;
        }
    }, {
        key: "signTransaction",
        value: function signTransaction(tr) {
            var _this5 = this;

            var signerPubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var requiredPubkeys = arguments[2];


            var myKeys = {};
            var hasKey = false;

            this.state.roles.forEach(function (role) {
                var myKey = _this5.keyCache.getMyKey(role);
                if (myKey) {
                    if (signerPubkeys[myKey.pub]) {
                        hasKey = true;
                        return;
                    }
                    hasKey = true;
                    signerPubkeys[myKey.pub] = true;
                    if (requiredPubkeys && requiredPubkeys.indexOf(myKey.pub) !== -1) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    } else if (!requiredPubkeys) {
                        tr.add_signer(myKey.priv, myKey.pub);
                    }
                }
            });

            if (!hasKey) {
                console.error("You do not have any private keys to sign this transaction");
                throw new Error("You do not have any private keys to sign this transaction");
            }
        }
    }]);

    return AccountLogin;
}();

module.exports = AccountLogin;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/AccountLogin.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../ecc/src/KeyUtils":46,"../../ecc/src/PrivateKey":47,"buffer":11,"pBGvAp":74}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

//var _this;

var ecc_config = {
    address_prefix: "STM"
};

var _this = {
    core_asset: "STEEM",
    vest_asset: "VESTS",
    dollar_asset: "SBD",
    address_prefix: "STM",
    expire_in_secs: 15,
    expire_in_secs_proposal: 24 * 60 * 60,
    chain_id: "0000000000000000000000000000000000000000000000000000000000000000",
    networks: {
        Steem: {
            core_asset: "STEEM",
            vest_asset: "VESTS",
            dollar_asset: "SBD",
            address_prefix: "STM",
            chain_id: "0000000000000000000000000000000000000000000000000000000000000000"
        },
        Golos: {
            core_asset: "GOLOS",
            vest_asset: "GESTS",
            dollar_asset: "GBG",
            address_prefix: "GLS",
            chain_id: "782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12"
        }
    },
    /** Set a few properties for known chain IDs. */
    setChainId: function setChainId(chain_id) {

        var i, len, network, network_name, ref;
        ref = Object.keys(_this.networks);

        for (i = 0, len = ref.length; i < len; i++) {

            network_name = ref[i];
            network = _this.networks[network_name];

            if (network.chain_id === chain_id) {

                _this.network_name = network_name;

                if (network.address_prefix) {
                    _this.address_prefix = network.address_prefix;
                    _this.dollar_asset = network.dollar_asset;
                    _this.vest_asset = network.vest_asset;
                    _this.core_asset = network.core_asset;

                    ecc_config.address_prefix = network.address_prefix;
                    _this.chain_id = chain_id;
                }

                console.log("INFO    Configured for", network_name, ":", network.core_asset, "\n");

                return {
                    network_name: network_name,
                    network: network
                };
            }
        }

        if (!_this.network_name) {
            console.log("Unknown chain id (this may be a testnet)", chain_id);
        }
    },

    reset: function reset() {
        _this.core_asset = "STEEM";
        _this.address_prefix = "STM";
        ecc_config.address_prefix = "STM";
        _this.expire_in_secs = 15;
        _this.expire_in_secs_proposal = 24 * 60 * 60;

        console.log("Chain config reset");
    },

    setPrefix: function setPrefix() {
        var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "STM";

        _this.address_prefix = prefix;
        ecc_config.address_prefix = prefix;
    }
};
module.exports = _this;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainConfig.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var ChainTypes = {};

ChainTypes.operations = {
    vote: 0,
    comment: 1,
    transfer: 2,
    transfer_to_vesting: 3,
    withdraw_vesting: 4,
    limit_order_create: 5,
    limit_order_cancel: 6,
    feed_publish: 7,
    convert: 8,
    account_create: 9,
    account_update: 10,
    witness_update: 11,
    account_witness_vote: 12,
    account_witness_proxy: 13,
    pow: 14,
    custom: 15,
    report_over_production: 16,
    delete_comment: 17,
    custom_json: 18,
    comment_options: 19,
    set_withdraw_vesting_route: 20,
    limit_order_create2: 21,
    challenge_authority: 22,
    prove_authority: 23,
    request_account_recovery: 24,
    recover_account: 25,
    change_recovery_account: 26,
    escrow_transfer: 27,
    escrow_dispute: 28,
    escrow_release: 29,
    pow2: 30,
    escrow_approve: 31,
    transfer_to_savings: 32,
    transfer_from_savings: 33,
    cancel_transfer_from_savings: 34,
    custom_binary: 35,
    decline_voting_rights: 36,
    reset_account: 37,
    set_reset_account: 38,
    claim_reward_balance: 39,
    delegate_vesting_shares: 40,
    account_create_with_delegation: 41,
    fill_convert_request: 42,
    author_reward: 43,
    curation_reward: 44,
    comment_reward: 45,
    liquidity_reward: 46,
    interest: 47,
    fill_vesting_withdraw: 48,
    fill_order: 49,
    shutdown_witness: 50,
    fill_transfer_from_savings: 51,
    hardfork: 52,
    comment_payout_update: 53,
    return_vesting_delegation: 54,
    comment_benefactor_reward: 55
};

module.exports = ChainTypes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainTypes.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
    Account names may contain one or more names separated by a dot.
    Each name needs to start with a letter and may contain
    numbers, or well placed dashes.
    @see is_valid_name graphene/libraries/chain/protocol/account.cpp
*/
var id_regex = /\b\d+\.\d+\.(\d+)\b/;

var chainValidation = {
    is_account_name: function is_account_name(value) {
        var allow_too_short = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var i, label, len, length, ref;

        if (this.is_empty(value)) {
            return false;
        }

        length = value.length;

        if (!allow_too_short && length < 3 || length > 63) {
            return false;
        }

        ref = value.split('.');

        for (i = 0, len = ref.length; i < len; i++) {

            label = ref[i];

            if (!(/^[a-z][a-z0-9-]*$/.test(label) && !/--/.test(label) && /[a-z0-9]$/.test(label))) {
                return false;
            }
        }
        return true;
    },

    is_object_id: function is_object_id(obj_id) {
        if ('string' != typeof obj_id) return false;

        var match = id_regex.exec(obj_id);
        return match !== null && obj_id.split(".").length === 3;
    },

    is_empty: function is_empty(value) {
        return value == null || value.length === 0;
    },

    is_account_name_error: function is_account_name_error(value, allow_too_short) {
        var i, label, len, length, ref, suffix;
        if (allow_too_short == null) {
            allow_too_short = false;
        }
        suffix = "Account name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        length = value.length;
        if (!allow_too_short && length < 3) {
            return suffix + "be longer.";
        }
        if (length > 63) {
            return suffix + "be shorter.";
        }
        if (/\./.test(value)) {
            suffix = "Each account segment should ";
        }
        ref = value.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
            label = ref[i];
            if (!/^[~a-z]/.test(label)) {
                return suffix + "start with a letter.";
            }
            if (!/^[~a-z0-9-]*$/.test(label)) {
                return suffix + "have only letters, digits, or dashes.";
            }
            if (/--/.test(label)) {
                return suffix + "have only one dash in a row.";
            }
            if (!/[a-z0-9]$/.test(label)) {
                return suffix + "end with a letter or digit.";
            }
            if (!(label.length >= 3)) {
                return suffix + "be longer";
            }
        }
        return null;
    },

    is_cheap_name: function is_cheap_name(account_name) {
        return (/[0-9-]/.test(account_name) || !/[aeiouy]/.test(account_name)
        );
    },

    is_empty_user_input: function is_empty_user_input(value) {
        if (this.is_empty(value)) {
            return true;
        }
        if ((value + "").trim() === "") {
            return true;
        }
        return false;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (this.is_empty(value)) {
            throw new Error("value required for " + field_name + ": " + value);
        }
        return value;
    },

    /** @see is_valid_symbol graphene/libraries/chain/protocol/asset_ops.cpp */
    is_valid_symbol_error: function is_valid_symbol_error(value) {
        var suffix = "Asset name should ";
        if (this.is_empty(value)) {
            return suffix + "not be empty.";
        }
        if (value.split('.').length > 2) {
            return suffix + "have only one dot.";
        }
        if (value.length < 3) {
            return suffix + "be longer.";
        }
        if (value.length > 16) {
            return suffix + "be shorter.";
        }
        if (!/^[A-Z]/.test(value)) {
            return suffix + "start with a letter";
        }
        if (!/[A-Z]$/.test(value)) {
            return suffix + "end with a letter";
        }
        if (/^[A-Z0-9\.]$/.test(value)) {
            return suffix + "contain only letters numbers and perhaps a dot.";
        }
        return null;
    }
};

module.exports = chainValidation;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ChainValidation.js","/../node_modules/esteem-lib/dist/chain/src")
},{"buffer":11,"pBGvAp":74}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340
    
    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split("."),
            _number$split2 = _slicedToArray(_number$split, 2),
            _number$split2$ = _number$split2[0],
            whole = _number$split2$ === undefined ? "" : _number$split2$,
            _number$split2$2 = _number$split2[1],
            decimal = _number$split2$2 === undefined ? "" : _number$split2$2;

        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/NumberUtils.js","/../node_modules/esteem-lib/dist/chain/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('bytebuffer'),
    Long = _require.Long;

var v = require('../../serializer/src/SerializerValidation');

var DB_MAX_INSTANCE_ID = Long.fromNumber(Math.pow(2, 48) - 1);

var ObjectId = function () {
    function ObjectId(space, type, instance) {
        _classCallCheck(this, ObjectId);

        this.space = space;
        this.type = type;
        this.instance = instance;
        var instance_string = this.instance.toString();
        var _ObjectId = this.space + '.' + this.type + '.' + instance_string;
        if (!v.is_digits(instance_string)) {
            throw new ('Invalid object id ' + _ObjectId)();
        }
    }

    _createClass(ObjectId, [{
        key: 'toLong',
        value: function toLong() {
            return Long.fromNumber(this.space).shiftLeft(56).or(Long.fromNumber(this.type).shiftLeft(48).or(this.instance));
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b) {
            return b.writeUint64(this.toLong());
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.space + '.' + this.type + '.' + this.instance.toString();
        }
    }], [{
        key: 'fromString',
        value: function fromString(value) {
            if (value.space !== undefined && value.type !== undefined && value.instance !== undefined) {
                return value;
            }

            var params = v.require_match(/^([0-9]+)\.([0-9]+)\.([0-9]+)$/, v.required(value, "ObjectId"), "ObjectId");
            return new ObjectId(parseInt(params[1]), parseInt(params[2]), Long.fromString(params[3]));
        }
    }, {
        key: 'fromLong',
        value: function fromLong(long) {
            var space = long.shiftRight(56).toInt();
            var type = long.shiftRight(48).toInt() & 0x00ff;
            var instance = long.and(DB_MAX_INSTANCE_ID);
            return new ObjectId(space, type, instance);
        }
    }, {
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            return ObjectId.fromLong(b.readUint64());
        }
    }]);

    return ObjectId;
}();

module.exports = ObjectId;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/ObjectId.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../serializer/src/SerializerValidation":59,"buffer":11,"bytebuffer":12,"pBGvAp":74}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");

var _require = require("../../ecc"),
    Signature = _require.Signature,
    PublicKey = _require.PublicKey,
    hash = _require.hash;

var _require2 = require("../../serializer"),
    ops = _require2.ops;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require3 = require('steem-rpc'),
    Client = _require3.Client;

var Api = Client.get();

var _require4 = require('bytebuffer'),
    Long = _require4.Long;

var ChainTypes = require('./ChainTypes');

var head_block_time_string;

var TransactionBuilder = function () {
    function TransactionBuilder() {
        _classCallCheck(this, TransactionBuilder);

        this.ref_block_num = 0;
        this.ref_block_prefix = 0;
        this.expiration = 0;
        this.operations = [];
        this.signatures = [];
        this.signer_private_keys = [];

        // semi-private method bindings
        this._broadcast = _broadcast.bind(this);
    }

    /**
        @arg {string} name - like "transfer"
        @arg {object} operation - JSON matchching the operation's format
    */


    _createClass(TransactionBuilder, [{
        key: "add_type_operation",
        value: function add_type_operation(name, operation) {
            this.add_operation(this.get_type_operation(name, operation));
            return;
        }

        /**
            This does it all: set fees, finalize, sign, and broadcast (if wanted).
             @arg {ConfidentialWallet} cwallet - must be unlocked, used to gather signing keys
             @arg {array<string>} [signer_pubkeys = null] - Optional ["GPHAbc9Def0...", ...].  These are additional signing keys.  Some balance claims require propritary address formats, the witness node can't tell us which ones are needed so they must be passed in.  If the witness node can figure out a signing key (mostly all other transactions), it should not be passed in here.
             @arg {boolean} [broadcast = false]
        */

    }, {
        key: "process_transaction",
        value: function process_transaction(accountLogin) {
            var _this = this;

            var signer_pubkeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            // let wallet_object = cwallet.wallet.wallet_object
            // if(Api.chain_id !== wallet_object.get("chain_id"))
            //     return Promise.reject("Mismatched chain_id; expecting " +
            //         wallet_object.get("chain_id") + ", but got " +
            //         Api.chain_id)

            var signer_pubkeys_added = {};
            // if(signer_pubkeys) {
            //
            //     // Balance claims are by address, only the private
            //     // key holder can know about these additional
            //     // potential keys.
            //     var pubkeys = accountLogin.getPubKeys()
            //     if( ! pubkeys.length)
            //         throw new Error("Missing signing key")
            //
            //     for(let pubkey_string of pubkeys) {
            //         var private_key = cwallet.getPrivateKey(pubkey_string)
            //         this.add_signer(private_key, pubkey_string)
            //         signer_pubkeys_added[pubkey_string] = true
            //     }
            // }

            // return this.get_potential_signatures().then( (pubkeys)=> {
            var my_pubkeys = accountLogin.getPubKeys();

            //{//Testing only, don't send All public keys!
            //    var pubkeys_all = PrivateKeyStore.getPubkeys() // All public keys
            //    this.get_required_signatures(pubkeys_all).then( required_pubkey_strings =>
            //        console.log('get_required_signatures all\t',required_pubkey_strings.sort(), pubkeys_all))
            //    this.get_required_signatures(my_pubkeys).then( required_pubkey_strings =>
            //        console.log('get_required_signatures normal\t',required_pubkey_strings.sort(), pubkeys))
            //}


            return this.get_required_signatures(my_pubkeys).then(function (required_pubkeys) {
                // console.log("required_pubkeys", required_pubkeys);
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = my_pubkeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var pubkey_string = _step.value;

                        // console.log("pubkey_string", pubkey_string);

                        if (signer_pubkeys_added[pubkey_string]) continue;

                        accountLogin.signTransaction(_this, signer_pubkeys_added, required_pubkeys);
                        // var private_key = cwallet.getPrivateKey(pubkey_string)
                        // if( ! private_key)
                        //     // This should not happen, get_required_signatures will only
                        //     // returned keys from my_pubkeys
                        //     throw new Error("Missing signing key for " + pubkey_string)
                        // this.add_signer(private_key, pubkey_string)
                    }

                    // console.log("signer_pubkeys_added", signer_pubkeys_added);
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }).then(function () {
                if (broadcast) {
                    return _this.broadcast();
                } else {
                    return _this.serialize();
                }
            });
        }

        /** Typically this is called automatically just prior to signing.  Once finalized this transaction can not be changed. */

    }, {
        key: "finalize",
        value: function finalize() {
            var _this2 = this;

            // console.log("Try to finalize", "expiration:", this.expiration);
            return new Promise(function (resolve, reject) {

                if (_this2.tr_buffer) {
                    throw new Error("already finalized");
                }

                resolve(Api.database_api().exec("get_dynamic_global_properties", []).then(function (r) {
                    head_block_time_string = r.time;
                    if (_this2.expiration === 0) _this2.expiration = base_expiration_sec() + ChainConfig.expire_in_secs;
                    // console.log("new expiration:", this.expiration);
                    _this2.ref_block_num = r.head_block_number & 0xFFFF;
                    _this2.ref_block_prefix = new Buffer(r.head_block_id, 'hex').readUInt32LE(4);
                    //DEBUG console.log("ref_block",@ref_block_num,@ref_block_prefix,r)

                    var iterable = _this2.operations;
                    for (var i = 0, op; i < iterable.length; i++) {
                        op = iterable[i];
                        if (op[1]["finalize"]) {
                            op[1].finalize();
                        }
                    }
                    _this2.tr_buffer = ops.transaction.toBuffer(_this2);
                }).catch(function (err) {
                    console.log("get_dynamic_global_properties err:", err);
                }));
            });
        }

        /** @return {string} hex transaction ID */

    }, {
        key: "id",
        value: function id() {
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            return hash.sha256(this.tr_buffer).toString('hex').substring(0, 40);
        }

        /**
            Typically one will use {@link this.add_type_operation} instead.
            @arg {array} operation - [operation_id, operation]
        */

    }, {
        key: "add_operation",
        value: function add_operation(operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(operation, "operation");
            if (!Array.isArray(operation)) {
                throw new Error("Expecting array [operation_id, operation]");
            }
            this.operations.push(operation);
            return;
        }
    }, {
        key: "get_type_operation",
        value: function get_type_operation(name, operation) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            assert(name, "name");
            assert(operation, "operation");
            var _type = ops[name];
            assert(_type, "Unknown operation " + name);
            var operation_id = ChainTypes.operations[_type.operation_name];
            if (operation_id === undefined) {
                throw new Error("unknown operation: " + _type.operation_name);
            }
            if (!operation.fee) {
                operation.fee = { amount: 0, asset_id: 0 };
            }
            if (name === 'proposal_create') {
                operation.expiration_time || (operation.expiration_time = base_expiration_sec() + ChainConfig.expire_in_secs_proposal);
            }
            var operation_instance = _type.fromObject(operation);
            return [operation_id, operation_instance];
        }

        /** optional: there is a deafult expiration */

    }, {
        key: "set_expire_seconds",
        value: function set_expire_seconds(sec) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            return this.expiration = base_expiration_sec() + sec;
        }

        /* Wraps this transaction in a proposal_create transaction */

    }, {
        key: "propose",
        value: function propose(proposal_create_options) {
            if (this.tr_buffer) {
                throw new Error("already finalized");
            }
            if (!this.operations.length) {
                throw new Error("add operation first");
            }

            assert(proposal_create_options, "proposal_create_options");
            assert(proposal_create_options.fee_paying_account, "proposal_create_options.fee_paying_account");

            var proposed_ops = this.operations.map(function (op) {
                return { op: op };
            });

            this.operations = [];
            this.signatures = [];
            this.signer_private_keys = [];
            proposal_create_options.proposed_ops = proposed_ops;
            this.add_type_operation("proposal_create", proposal_create_options);
            return this;
        }
    }, {
        key: "has_proposed_operation",
        value: function has_proposed_operation() {
            var hasProposed = false;
            for (var i = 0; i < this.operations.length; i++) {
                if ("proposed_ops" in this.operations[i][1]) {
                    hasProposed = true;
                    break;
                }
            }

            return hasProposed;
        }
    }, {
        key: "get_potential_signatures",
        value: function get_potential_signatures() {
            var tr_object = ops.signed_transaction.toObject(this);
            return Api.database_api().exec("get_potential_signatures", [tr_object]).then(function (pubkeys) {
                return { pubkeys: pubkeys };
            });
        }
    }, {
        key: "get_required_signatures",
        value: function get_required_signatures(available_keys) {

            if (!available_keys.length) {
                return Promise.resolve([]);
            }
            var tr_object = ops.signed_transaction.toObject(this);
            //console.log('... tr_object',tr_object);
            //DEBUG console.log('... tr_object',tr_object)
            return Api.database_api().exec("get_required_signatures", [tr_object, available_keys]).then(function (required_public_keys) {
                // DEBUG console.log('... get_required_signatures',required_public_keys)
                //console.log('... get_required_signatures',required_public_keys);
                return required_public_keys;
            });
        }
    }, {
        key: "add_signer",
        value: function add_signer(private_key) {
            var public_key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : private_key.toPublicKey();


            assert(private_key.d, "required PrivateKey object");

            if (this.signed) {
                throw new Error("already signed");
            }
            if (!public_key.Q) {
                public_key = PublicKey.fromPublicKeyString(public_key);
            }
            // prevent duplicates
            var spHex = private_key.toHex();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
                for (var _iterator2 = this.signer_private_keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var sp = _step2.value;

                    if (sp[0].toHex() === spHex) return;
                }
            } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                        _iterator2.return();
                    }
                } finally {
                    if (_didIteratorError2) {
                        throw _iteratorError2;
                    }
                }
            }

            this.signer_private_keys.push([private_key, public_key]);
        }
    }, {
        key: "sign",
        value: function sign() {
            var chain_id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.chain_id;

            console.log(chain_id);
            if (!this.tr_buffer) {
                throw new Error("not finalized");
            }
            if (this.signed) {
                throw new Error("already signed");
            }
            var end = this.signer_private_keys.length;
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                var _signer_private_keys$ = _slicedToArray(this.signer_private_keys[i], 2),
                    private_key = _signer_private_keys$[0],
                    public_key = _signer_private_keys$[1];

                var sig = Signature.signBuffer(Buffer.concat([new Buffer(chain_id, 'hex'), this.tr_buffer]), private_key, public_key);
                this.signatures.push(sig.toBuffer());
            }
            this.signer_private_keys = [];
            this.signed = true;
            return;
        }
    }, {
        key: "serialize",
        value: function serialize() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "toObject",
        value: function toObject() {
            return ops.signed_transaction.toObject(this);
        }
    }, {
        key: "broadcast",
        value: function broadcast(was_broadcast_callback) {
            var _this3 = this;

            if (this.tr_buffer) {
                return this._broadcast(was_broadcast_callback);
            } else {
                return this.finalize().then(function () {
                    return _this3._broadcast(was_broadcast_callback);
                });
            }
        }
    }]);

    return TransactionBuilder;
}();

var base_expiration_sec = function base_expiration_sec() {
    var head_block_sec = Math.ceil(getHeadBlockDate().getTime() / 1000);
    var now_sec = Math.ceil(Date.now() / 1000);
    // The head block time should be updated every 3 seconds.  If it isn't
    // then help the transaction to expire (use head_block_sec)
    if (now_sec - head_block_sec > 30) {
        return head_block_sec;
    }
    // If the user's clock is very far behind, use the head block time.
    return Math.max(now_sec, head_block_sec);
};

function _broadcast(was_broadcast_callback) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
        if (!_this4.signed) {
            _this4.sign();
        }
        if (!_this4.tr_buffer) {
            reject(new Error("not finalized"));
        }
        if (!_this4.signatures.length) {
            reject(new Error("not signed"));
        }
        if (!_this4.operations.length) {
            reject(new Error("no operations"));
        }

        if (!("network_broadcast_api" in Api)) {
            reject(new Error("Api does not include network_broadcast_api"));
        }
        var tr_object = ops.signed_transaction.toObject(_this4);

        return Api.network_broadcast_api().exec("broadcast_transaction_with_callback", [{ reject: reject, resolve: resolve }, tr_object]).then(function () {
            // console.log('... broadcast success, waiting for callback')
            if (was_broadcast_callback) was_broadcast_callback();
            return;
        }).catch(function (error) {
            // console.log may be redundant for network errors, other errors could occur
            // console.log(error);
            var message = error.message;
            if (!message) {
                message = "";
            }
            reject(new Error(message + "\n" + 'graphene-crypto ' + ' digest ' + hash.sha256(_this4.tr_buffer).toString('hex') + ' transaction ' + _this4.tr_buffer.toString('hex') + ' ' + JSON.stringify(tr_object)));
        });
    });
}

function getHeadBlockDate() {
    return timeStringToDate(head_block_time_string);
}

function timeStringToDate(time_string) {
    if (!time_string) return new Date("1970-01-01T00:00:00.000Z");
    if (!/Z$/.test(time_string)) //does not end in Z
        // https://github.com/cryptonomex/graphene/issues/368
        time_string = time_string + "Z";
    return new Date(time_string);
}

module.exports = TransactionBuilder;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/TransactionBuilder.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../chain/src/ChainConfig":37,"../../ecc":44,"../../serializer":57,"./ChainTypes":38,"assert":1,"buffer":11,"bytebuffer":12,"pBGvAp":74,"steem-rpc":88}],43:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var helper;
module.exports = helper = {};

var secureRandom = require('secure-random');

//Promise = require '../common/Promise'

var _require = require('bytebuffer'),
    Long = _require.Long;

var _require2 = require("../../ecc"),
    Signature = _require2.Signature;

var _require3 = require("../../serializer"),
    ops = _require3.ops;

helper.unique_nonce_entropy = null;
helper.unique_nonce_uint64 = function () {
    var entropy = helper.unique_nonce_entropy = function () {

        if (helper.unique_nonce_entropy === null) {
            //console.log('... secureRandom.randomUint8Array(1)[0]',secureRandom.randomUint8Array(1)[0])
            return parseInt(secureRandom.randomUint8Array(1)[0]);
        } else {
            return ++helper.unique_nonce_entropy % 256;
        }
    }();
    var long = Long.fromNumber(Date.now());
    //console.log('unique_nonce_uint64 date\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    //console.log('unique_nonce_uint64 entropy\t',ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))
    long = long.shiftLeft(8).or(Long.fromNumber(entropy));
    //console.log('unique_nonce_uint64 shift8\t',ByteBuffer.allocate(8).writeUint64(long).toHex(0))
    return long.toString();
};

/* Todo, set fees */
helper.to_json = function (tr) {
    var broadcast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return function (tr, broadcast) {
        var tr_object = ops.signed_transaction.toObject(tr);
        if (broadcast) {
            var net = Apis.instance().network_api();
            console.log('... tr_object', JSON.stringify(tr_object));
            return net.exec("broadcast_transaction", [tr_object]);
        } else {
            return tr_object;
        }
    }(tr, broadcast);
};

helper.signed_tr_json = function (tr, private_keys) {
    var tr_buffer = ops.transaction.toBuffer(tr);
    tr = ops.transaction.toObject(tr);
    tr.signatures = function () {
        var result = [];
        for (var i = 0; 0 < private_keys.length ? i < private_keys.length : i > private_keys.length; 0 < private_keys.length ? i++ : i++) {
            var private_key = private_keys[i];
            result.push(Signature.signBuffer(tr_buffer, private_key).toHex());
        }
        return result;
    }();
    return tr;
};

helper.expire_in_min = function (min) {
    return Math.round(Date.now() / 1000) + min * 60;
};

helper.seconds_from_now = function (timeout_sec) {
    return Math.round(Date.now() / 1000) + timeout_sec;
};

/**
    Print to the console a JSON representation of any object in
    @graphene/serializer { types }
*/
helper.template = function (serializer_operation_type_name) {
    var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: true, annotate: true };

    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    return so.toObject(undefined, debug);
};

helper.new_operation = function (serializer_operation_type_name) {
    var so = type[serializer_operation_type_name];
    if (!so) {
        throw new Error('unknown serializer_operation_type ' + serializer_operation_type_name);
    }
    var object = so.toObject(undefined, { use_default: true, annotate: true });
    return so.fromObject(object);
};

helper.instance = function (ObjectId) {
    return ObjectId.substring("0.0.".length);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/chain/src/TransactionHelper.js","/../node_modules/esteem-lib/dist/chain/src")
},{"../../ecc":44,"../../serializer":57,"buffer":11,"bytebuffer":12,"pBGvAp":74,"secure-random":76}],44:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = {
    Address: require("./src/address"),
    Aes: require("./src/aes"),
    PrivateKey: require("./src/PrivateKey"),
    PublicKey: require("./src/PublicKey"),
    Signature: require("./src/signature"),
    brainKey: require("./src/BrainKey"),
    hash: require("./src/hash"),
    key: require("./src/KeyUtils")
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/index.js","/../node_modules/esteem-lib/dist/ecc")
},{"./src/BrainKey":45,"./src/KeyUtils":46,"./src/PrivateKey":47,"./src/PublicKey":48,"./src/address":49,"./src/aes":50,"./src/hash":54,"./src/signature":55,"buffer":11,"pBGvAp":74}],45:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function normalize(brainKey) {
    if (typeof brainKey !== 'string') {
        throw new Error("string required for brainKey");
    }
    brainKey = brainKey.trim();
    return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/BrainKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],46:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var key;
var PrivateKey = require('./PrivateKey');
var PublicKey = require('./PublicKey');
var Address = require('./address');
var Aes = require('./aes');

var hash = require('./hash');
// var dictionary = require('./dictionary_en');
var secureRandom = require('secure-random');
var ChainConfig = require("../../chain/src/ChainConfig");

// hash for .25 second
var HASH_POWER_MILLS = 250;

module.exports = key = {

    /** Uses 1 second of hashing power to create a key/password checksum.  An
    implementation can re-call this method with the same password to re-match
    the strength of the CPU (either after moving from a desktop to a mobile,
    mobile to desktop, or N years from now when CPUs are presumably stronger).
     A salt is used for all the normal reasons...
     @return object {
        aes_private: Aes,
        checksum: "{hash_iteration_count},{salt},{checksum}"
    }
    */
    aes_checksum: function aes_checksum(password) {
        if (!(typeof password === "string")) {
            throw new "password string required"();
        }
        var salt = secureRandom.randomBuffer(4).toString('hex');
        var iterations = 0;
        var secret = salt + password;
        // hash for .1 second
        var start_t = Date.now();
        while (Date.now() - start_t < HASH_POWER_MILLS) {
            secret = hash.sha256(secret);
            iterations += 1;
        }

        var checksum = hash.sha256(secret);
        var checksum_string = [iterations, salt.toString('hex'), checksum.slice(0, 4).toString('hex')].join(',');

        return { aes_private: Aes.fromSeed(secret),
            checksum: checksum_string
        };
    },


    /** Provide a matching password and key_checksum.  A "wrong password"
    error is thrown if the password does not match.  If this method takes
    much more or less than 1 second to return, one should consider updating
    all encyrpted fields using a new key.key_checksum.
    */
    aes_private: function aes_private(password, key_checksum) {
        var _key_checksum$split = key_checksum.split(','),
            _key_checksum$split2 = _slicedToArray(_key_checksum$split, 3),
            iterations = _key_checksum$split2[0],
            salt = _key_checksum$split2[1],
            checksum = _key_checksum$split2[2];

        var secret = salt + password;
        for (var i = 0; 0 < iterations ? i < iterations : i > iterations; 0 < iterations ? i++ : i++) {
            secret = hash.sha256(secret);
        }
        var new_checksum = hash.sha256(secret);
        if (!(new_checksum.slice(0, 4).toString('hex') === checksum)) {
            throw new Error("wrong password");
        }
        return Aes.fromSeed(secret);
    },


    /**
        A week random number generator can run out of entropy.  This should ensure even the worst random number implementation will be reasonably safe.
         @param1 string entropy of at least 32 bytes
    */
    random32ByteBuffer: function random32ByteBuffer() {
        var entropy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.browserEntropy();


        if (!(typeof entropy === 'string')) {
            throw new Error("string required for entropy");
        }

        if (entropy.length < 32) {
            throw new Error("expecting at least 32 bytes of entropy");
        }

        var start_t = Date.now();

        while (Date.now() - start_t < HASH_POWER_MILLS) {
            entropy = hash.sha256(entropy);
        }var hash_array = [];
        hash_array.push(entropy);

        // Hashing for 1 second may helps the computer is not low on entropy (this method may be called back-to-back).
        hash_array.push(secureRandom.randomBuffer(32));

        return hash.sha256(Buffer.concat(hash_array));
    },


    suggest_brain_key: function suggest_brain_key() {
        var dictionary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ",";
        var entropy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.browserEntropy();


        var randomBuffer = this.random32ByteBuffer(entropy);

        var word_count = 16;
        var dictionary_lines = dictionary.split(',');

        if (!(dictionary_lines.length === 49744)) {
            throw new Error('expecting ' + 49744 + ' but got ' + dictionary_lines.length + ' dictionary words');
        }

        var brainkey = [];
        var end = word_count * 2;

        for (var i = 0; i < end; i += 2) {

            // randomBuffer has 256 bits / 16 bits per word == 16 words
            var num = (randomBuffer[i] << 8) + randomBuffer[i + 1];

            // convert into a number between 0 and 1 (inclusive)
            var rndMultiplier = num / Math.pow(2, 16);
            var wordIndex = Math.round(dictionary_lines.length * rndMultiplier);

            brainkey.push(dictionary_lines[wordIndex]);
        }
        return this.normalize_brainKey(brainkey.join(' '));
    },

    get_random_key: function get_random_key(entropy) {
        return PrivateKey.fromBuffer(this.random32ByteBuffer(entropy));
    },
    get_brainPrivateKey: function get_brainPrivateKey(brainKey) {
        var sequence = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (sequence < 0) {
            throw new Error("invalid sequence");
        }
        brainKey = key.normalize_brainKey(brainKey);
        return PrivateKey.fromBuffer(hash.sha256(hash.sha512(brainKey + " " + sequence)));
    },


    // Turn invisible space like characters into a single space
    normalize_brainKey: function normalize_brainKey(brainKey) {
        if (!(typeof brainKey === 'string')) {
            throw new Error("string required for brainKey");
        }

        brainKey = brainKey.trim();
        return brainKey.split(/[\t\n\v\f\r ]+/).join(' ');
    },
    browserEntropy: function browserEntropy() {

        var entropyStr = "";
        try {
            entropyStr = new Date().toString() + " " + window.screen.height + " " + window.screen.width + " " + window.screen.colorDepth + " " + " " + window.screen.availHeight + " " + window.screen.availWidth + " " + window.screen.pixelDepth + navigator.language + " " + window.location + " " + window.history.length;

            for (var i = 0, mimeType; i < navigator.mimeTypes.length; i++) {
                mimeType = navigator.mimeTypes[i];
                entropyStr += mimeType.description + " " + mimeType.type + " " + mimeType.suffixes + " ";
            }
            console.log("INFO\tbrowserEntropy gathered");
        } catch (error) {
            //nodejs:ReferenceError: window is not defined
            entropyStr = hash.sha256(new Date().toString());
        }

        var b = new Buffer(entropyStr);
        entropyStr += b.toString('binary') + " " + new Date().toString();
        return entropyStr;
    },


    // @return array of 5 legacy addresses for a pubkey string parameter.
    addresses: function addresses(pubkey) {
        var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

        var public_key = PublicKey.fromPublicKeyString(pubkey, address_prefix);
        // S L O W
        var address_string = [Address.fromPublic(public_key, false, 0).toString(address_prefix), // btc_uncompressed
        Address.fromPublic(public_key, true, 0).toString(address_prefix), // btc_compressed
        Address.fromPublic(public_key, false, 56).toString(address_prefix), // pts_uncompressed
        Address.fromPublic(public_key, true, 56).toString(address_prefix), // pts_compressed
        public_key.toAddressString(address_prefix) // bts_short, most recent format
        ];
        return address_string;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/KeyUtils.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./PrivateKey":47,"./PublicKey":48,"./address":49,"./aes":50,"./hash":54,"buffer":11,"pBGvAp":74,"secure-random":76}],47:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecurve = require('ecurve');

var _require = require('ecurve'),
    Point = _require.Point,
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var BigInteger = require('bigi');

var _require2 = require('bs58'),
    encode = _require2.encode,
    decode = _require2.decode;

var assert = require('assert');
var hash = require('./hash');
var PublicKey = require('./PublicKey');
var deepEqual = require("deep-equal");

var G = secp256k1.G,
    n = secp256k1.n;

var PrivateKey = function () {

    /**
        @private see static functions
        @param {BigInteger}
    */
    function PrivateKey(d) {
        _classCallCheck(this, PrivateKey);

        this.d = d;
    }

    _createClass(PrivateKey, [{
        key: 'toWif',
        value: function toWif() {
            var private_key = this.toBuffer();
            // checksum includes the version
            private_key = Buffer.concat([new Buffer([0x80]), private_key]);
            var checksum = hash.sha256(private_key);
            checksum = hash.sha256(checksum);
            checksum = checksum.slice(0, 4);
            var private_wif = Buffer.concat([private_key, checksum]);
            return encode(private_wif);
        }

        /**
            @return {Point}
        */

    }, {
        key: 'toPublicKeyPoint',
        value: function toPublicKeyPoint() {
            var Q;
            return Q = secp256k1.G.multiply(this.d);
        }
    }, {
        key: 'toPublicKey',
        value: function toPublicKey() {
            if (this.public_key) {
                return this.public_key;
            }
            return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer() {
            return this.d.toBuffer(32);
        }

        /** ECIES */

    }, {
        key: 'get_shared_secret',
        value: function get_shared_secret(public_key) {
            var legacy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

            public_key = toPublic(public_key);
            var KB = public_key.toUncompressed().toBuffer();
            var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x
            BigInteger.fromBuffer(KB.slice(33, 65)) // y
            );
            var r = this.toBuffer();
            var P = KBP.multiply(BigInteger.fromBuffer(r));
            var S = P.affineX.toBuffer({ size: 32 });
            /*
            the input to sha512 must be exactly 32-bytes, to match the c++ implementation
            of get_shared_secret.  Right now S will be shorter if the most significant
            byte(s) is zero.  Pad it back to the full 32-bytes
            */
            if (!legacy && S.length < 32) {
                pad = new Buffer(32 - S.length).fill(0);
                S = Buffer.concat([pad, S]);
            }

            // SHA512 used in ECIES
            return hash.sha512(S);
        }

        // /** ECIES (does not always match the Point.fromAffine version above) */
        // get_shared_secret(public_key){
        //     public_key = toPublic(public_key)
        //     var P = public_key.Q.multiply( this.d );
        //     var S = P.affineX.toBuffer({size: 32});
        //     // ECIES, adds an extra sha512
        //     return hash.sha512(S);
        // }

        /** @throws {Error} - overflow of the key could not be derived */

    }, {
        key: 'child',
        value: function child(offset) {
            offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);
            offset = hash.sha256(offset);
            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var derived = this.d.add(c); //.mod(n)

            if (derived.signum() === 0) throw new Error("Child offset derived to an invalid key, try again");

            return new PrivateKey(derived);
        }

        /* <helper_functions> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }

        /* </helper_functions> */

    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            if (!Buffer.isBuffer(buf)) {
                throw new Error("Expecting paramter to be a Buffer type");
            }
            if (32 !== buf.length) {
                console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);
            }
            if (buf.length === 0) {
                throw new Error("Empty buffer");
            }
            return new PrivateKey(BigInteger.fromBuffer(buf));
        }

        /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */

    }, {
        key: 'fromSeed',
        value: function fromSeed(seed) {
            // generate_private_key
            if (!(typeof seed === 'string')) {
                throw new Error('seed must be of type string');
            }
            return PrivateKey.fromBuffer(hash.sha256(seed));
        }

        /** @return {string} Wallet Import Format (still a secret, Not encrypted) */

    }, {
        key: 'fromWif',
        value: function fromWif(_private_wif) {
            var private_wif = new Buffer(decode(_private_wif));
            var version = private_wif.readUInt8(0);
            assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);
            // checksum includes the version
            var private_key = private_wif.slice(0, -4);
            var checksum = private_wif.slice(-4);
            var new_checksum = hash.sha256(private_key);
            new_checksum = hash.sha256(new_checksum);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            private_key = private_key.slice(1);
            return PrivateKey.fromBuffer(private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }]);

    return PrivateKey;
}();

module.exports = PrivateKey;

var toPublic = function toPublic(data) {
    return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/PrivateKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./PublicKey":48,"./hash":54,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":66,"ecurve":32,"pBGvAp":74}],48:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BigInteger = require('bigi');

var _require = require('ecurve'),
    Point = _require.Point,
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');

var _require2 = require('bs58'),
    encode = _require2.encode,
    decode = _require2.decode;

var hash = require('./hash');
var ChainConfig = require("../../chain/src/ChainConfig");
var assert = require('assert');
var deepEqual = require("deep-equal");

var G = secp256k1.G,
    n = secp256k1.n;

var PublicKey = function () {

    /** @param {Point} public key */
    function PublicKey(Q) {
        _classCallCheck(this, PublicKey);

        this.Q = Q;
    }

    _createClass(PublicKey, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;

            if (this.Q === null) return new Buffer('000000000000000000000000000000000000000000000000000000000000000000', 'hex');
            return this.Q.getEncoded(compressed);
        }
    }, {
        key: 'toUncompressed',
        value: function toUncompressed() {
            var buf = this.Q.getEncoded(false);
            var point = Point.decodeFrom(secp256k1, buf);
            return PublicKey.fromPoint(point);
        }

        /** bts::blockchain::address (unique but not a full public key) */

    }, {
        key: 'toBlockchainAddress',
        value: function toBlockchainAddress() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            return hash.ripemd160(pub_sha);
        }

        /** Alias for {@link toPublicKeyString} */

    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            return this.toPublicKeyString(address_prefix);
        }

        /**
            Full public key
            {return} string
        */

    }, {
        key: 'toPublicKeyString',
        value: function toPublicKeyString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var checksum = hash.ripemd160(pub_buf);
            var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @return PublicKey or `null` (if the public_key string is invalid)
        */

    }, {
        key: 'toAddressString',
        value: function toAddressString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha512(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            var checksum = hash.ripemd160(addy);
            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }, {
        key: 'toPtsAddy',
        value: function toPtsAddy() {
            var pub_buf = this.toBuffer();
            var pub_sha = hash.sha256(pub_buf);
            var addy = hash.ripemd160(pub_sha);
            addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)

            var checksum = hash.sha256(addy);
            checksum = hash.sha256(checksum);

            addy = Buffer.concat([addy, checksum.slice(0, 4)]);
            return encode(addy);
        }
    }, {
        key: 'child',
        value: function child(offset) {

            assert(Buffer.isBuffer(offset), "Buffer required: offset");
            assert.equal(offset.length, 32, "offset length");

            offset = Buffer.concat([this.toBuffer(), offset]);
            offset = hash.sha256(offset);

            var c = BigInteger.fromBuffer(offset);

            if (c.compareTo(n) >= 0) throw new Error("Child offset went out of bounds, try again");

            var cG = G.multiply(c);
            var Qprime = this.Q.add(cG);

            if (secp256k1.isInfinity(Qprime)) throw new Error("Child offset derived to an invalid key, try again");

            return PublicKey.fromPoint(Qprime);
        }

        /* <HEX> */

    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer() {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString('hex');
        }
    }], [{
        key: 'fromBinary',
        value: function fromBinary(bin) {
            return PublicKey.fromBuffer(new Buffer(bin, 'binary'));
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            if (buffer.toString('hex') === '000000000000000000000000000000000000000000000000000000000000000000') return new PublicKey(null);
            return new PublicKey(Point.decodeFrom(secp256k1, buffer));
        }
    }, {
        key: 'fromPoint',
        value: function fromPoint(point) {
            return new PublicKey(point);
        }
    }, {
        key: 'fromPublicKeyString',
        value: function fromPublicKeyString(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            try {
                return PublicKey.fromStringOrThrow(public_key, address_prefix);
            } catch (e) {
                return null;
            }
        }

        /**
            @arg {string} public_key - like GPHXyz...
            @arg {string} address_prefix - like GPH
            @throws {Error} if public key is invalid
            @return PublicKey
        */

    }, {
        key: 'fromStringOrThrow',
        value: function fromStringOrThrow(public_key) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = public_key.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            public_key = public_key.slice(address_prefix.length);

            public_key = new Buffer(decode(public_key), 'binary');
            var checksum = public_key.slice(-4);
            public_key = public_key.slice(0, -4);
            var new_checksum = hash.ripemd160(public_key);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return PublicKey.fromBuffer(public_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return PublicKey.fromBuffer(new Buffer(hex, 'hex'));
        }
    }, {
        key: 'fromPublicKeyStringHex',
        value: function fromPublicKeyStringHex(hex) {
            return PublicKey.fromPublicKeyString(new Buffer(hex, 'hex'));
        }

        /* </HEX> */

    }]);

    return PublicKey;
}();

module.exports = PublicKey;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/PublicKey.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./hash":54,"assert":1,"bigi":6,"bs58":10,"buffer":11,"deep-equal":66,"ecurve":32,"pBGvAp":74}],49:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');
var ChainConfig = require("../../chain/src/ChainConfig");
var hash = require('./hash');

var _require = require('bs58'),
    encode = _require.encode,
    decode = _require.decode;

var deepEqual = require("deep-equal");

/** Addresses are shortened non-reversable hashes of a public key.  The full PublicKey is preferred.
    @deprecated
*/

var Address = function () {
    function Address(addy) {
        _classCallCheck(this, Address);

        this.addy = addy;
    }

    _createClass(Address, [{
        key: 'toBuffer',
        value: function toBuffer() {
            return this.addy;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ChainConfig.address_prefix;

            var checksum = hash.ripemd160(this.addy);
            var addy = Buffer.concat([this.addy, checksum.slice(0, 4)]);
            return address_prefix + encode(addy);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var _hash = hash.sha512(buffer);
            var addy = hash.ripemd160(_hash);
            return new Address(addy);
        }
    }, {
        key: 'fromString',
        value: function fromString(string) {
            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ChainConfig.address_prefix;

            var prefix = string.slice(0, address_prefix.length);
            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);
            var addy = string.slice(address_prefix.length);
            addy = new Buffer(decode(addy), 'binary');
            var checksum = addy.slice(-4);
            addy = addy.slice(0, -4);
            var new_checksum = hash.ripemd160(addy);
            new_checksum = new_checksum.slice(0, 4);
            var isEqual = deepEqual(checksum, new_checksum); //, 'Invalid checksum'
            if (!isEqual) {
                throw new Error("Checksum did not match");
            }
            return new Address(addy);
        }
    }, {
        key: 'fromPublic',


        /** @return Address - Compressed PTS format (by default) */
        value: function fromPublic(public_key) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 56;

            var sha2 = hash.sha256(public_key.toBuffer(compressed));
            var rep = hash.ripemd160(sha2);
            var versionBuffer = new Buffer(1);
            versionBuffer.writeUInt8(0xFF & version, 0);
            var addr = Buffer.concat([versionBuffer, rep]);
            var check = hash.sha256(addr);
            check = hash.sha256(check);
            var buffer = Buffer.concat([addr, check.slice(0, 4)]);
            return new Address(hash.ripemd160(buffer));
        }
    }]);

    return Address;
}();

module.exports = Address;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/address.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"../../chain/src/ChainConfig":37,"./hash":54,"assert":1,"bs58":10,"buffer":11,"deep-equal":66,"pBGvAp":74}],50:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// https://code.google.com/p/crypto-js
var AES = require("crypto-js/aes");
var encHex = require("crypto-js/enc-hex");
var encBase64 = require("crypto-js/enc-base64");
var assert = require("assert");

var _require = require("bytebuffer"),
    Long = _require.Long;

var hash = require('./hash');

/** Provides symetric encrypt and decrypt via AES. */

var Aes = function () {

    /** @private */
    function Aes(iv, key) {
        _classCallCheck(this, Aes);

        this.iv = iv, this.key = key;
    }

    /** This is an excellent way to ensure that all references to Aes can not operate anymore (example: a wallet becomes locked).  An application should ensure there is only one Aes object instance for a given secret `seed`. */


    _createClass(Aes, [{
        key: "clear",
        value: function clear() {
            return this.iv = this.key = undefined;
        }

        /** @arg {string} seed - secret seed may be used to encrypt or decrypt. */

    }, {
        key: "_decrypt_word_array",


        /** @private */
        value: function _decrypt_word_array(cipher) {
            // https://code.google.com/p/crypto-js/#Custom_Key_and_IV
            // see wallet_records.cpp master_key::decrypt_key
            return AES.decrypt({ ciphertext: cipher, salt: null }, this.key, { iv: this.iv });
        }

        /** @private */

    }, {
        key: "_encrypt_word_array",
        value: function _encrypt_word_array(plaintext) {
            //https://code.google.com/p/crypto-js/issues/detail?id=85
            var cipher = AES.encrypt(plaintext, this.key, { iv: this.iv });
            return encBase64.parse(cipher.toString());
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} ciphertext
            @return {Buffer} binary
        */

    }, {
        key: "decrypt",
        value: function decrypt(ciphertext) {
            if (typeof ciphertext === "string") {
                ciphertext = new Buffer(ciphertext, 'binary');
            }
            if (!Buffer.isBuffer(ciphertext)) {
                throw new Error("buffer required");
            }
            assert(ciphertext, "Missing cipher text");
            // hex is the only common format
            var hex = this.decryptHex(ciphertext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plaintext
            @return {Buffer} binary
        */

    }, {
        key: "encrypt",
        value: function encrypt(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            var hex = this.encryptHex(plaintext.toString('hex'));
            return new Buffer(hex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string|Buffer} plaintext
            @return {string} hex
        */

    }, {
        key: "encryptToHex",
        value: function encryptToHex(plaintext) {
            if (typeof plaintext === "string") {
                plaintext = new Buffer(plaintext, 'binary');
            }
            if (!Buffer.isBuffer(plaintext)) {
                throw new Error("buffer required");
            }
            //assert plaintext, "Missing plain text"
            // hex is the only common format
            return this.encryptHex(plaintext.toString('hex'));
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {string} binary (could easily be readable text)
        */

    }, {
        key: "decryptHex",
        value: function decryptHex(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            return encHex.stringify(plainwords);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @return {Buffer} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToBuffer",
        value: function decryptHexToBuffer(cipher) {
            assert(cipher, "Missing cipher text");
            // Convert data into word arrays (used by Crypto)
            var cipher_array = encHex.parse(cipher);
            var plainwords = this._decrypt_word_array(cipher_array);
            var plainhex = encHex.stringify(plainwords);
            return new Buffer(plainhex, 'hex');
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} cipher - hex
            @arg {string} [encoding = 'binary'] - a valid Buffer encoding
            @return {String} encoded as specified by the parameter
        */

    }, {
        key: "decryptHexToText",
        value: function decryptHexToText(cipher) {
            var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'binary';

            return this.decryptHexToBuffer(cipher).toString(encoding);
        }

        /** This method does not use a checksum, the returned data must be validated some other way.
            @arg {string} plainhex - hex format
            @return {String} hex
        */

    }, {
        key: "encryptHex",
        value: function encryptHex(plainhex) {
            var plain_array = encHex.parse(plainhex);
            var cipher_array = this._encrypt_word_array(plain_array);
            return encHex.stringify(cipher_array);
        }
    }], [{
        key: "fromSeed",
        value: function fromSeed(seed) {
            if (seed === undefined) {
                throw new Error("seed is required");
            }
            var _hash = hash.sha512(seed);
            _hash = _hash.toString('hex');
            // DEBUG console.log('... fromSeed _hash',_hash)
            return Aes.fromSha512(_hash);
        }
    }, {
        key: "fromSha512",


        /** @arg {string} hash - A 128 byte hex string, typically one would call {@link fromSeed} instead. */
        value: function fromSha512(hash) {
            assert.equal(hash.length, 128, "A Sha512 in HEX should be 128 characters long, instead got " + hash.length);
            var iv = encHex.parse(hash.substring(64, 96));
            var key = encHex.parse(hash.substring(0, 64));
            return new Aes(iv, key);
        }
    }, {
        key: "fromBuffer",
        value: function fromBuffer(buf) {
            assert(Buffer.isBuffer(buf), "Expecting Buffer");
            assert.equal(buf.length, 64, "A Sha512 Buffer should be 64 characters long, instead got " + buf.length);
            return Aes.fromSha512(buf.toString("hex"));
        }
        /**
            @throws {Error} - "Invalid Key, ..."
            @arg {PrivateKey} private_key - required and used for decryption
            @arg {PublicKey} public_key - required and used to calcualte the shared secret
            @arg {string} [nonce = ""] optional but should always be provided and be unique when re-using the same private/public keys more than once.  This nonce is not a secret.
            @arg {string|Buffer} message - Encrypted message containing a checksum
            @return {Buffer}
        */

    }, {
        key: "decrypt_with_checksum",
        value: function decrypt_with_checksum(private_key, public_key, nonce, message) {
            var legacy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string
            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'hex');
            }

            var S = private_key.get_shared_secret(public_key, legacy);
            // D E B U G
            // console.log('decrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString(),
            //     pub: public_key.toPublicKeyString(),
            //     nonce: nonce,
            //     message: message.length,
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));

            var planebuffer = aes.decrypt(message);
            if (!(planebuffer.length >= 4)) {
                throw new Error("Invalid key, could not decrypt message(1)");
            }

            // DEBUG console.log('... planebuffer',planebuffer)
            var checksum = planebuffer.slice(0, 4);
            var plaintext = planebuffer.slice(4);

            // console.log('... checksum',checksum.toString('hex'))
            // console.log('... plaintext',plaintext.toString())

            var new_checksum = hash.sha256(plaintext);
            new_checksum = new_checksum.slice(0, 4);
            new_checksum = new_checksum.toString('hex');

            if (!(checksum.toString('hex') === new_checksum)) {
                throw new Error("Invalid key, could not decrypt message(2)");
            }

            return plaintext;
        }
    }, {
        key: "encrypt_with_checksum",


        /** Identical to {@link decrypt_with_checksum} but used to encrypt.  Should not throw an error.
            @return {Buffer} message - Encrypted message which includes a checksum
        */
        value: function encrypt_with_checksum(private_key, public_key, nonce, message) {

            // Warning: Do not put `nonce = ""` in the arguments, in es6 this will not convert "null" into an emtpy string

            if (nonce == null) // null or undefined
                nonce = "";

            if (!Buffer.isBuffer(message)) {
                message = new Buffer(message, 'binary');
            }

            var S = private_key.get_shared_secret(public_key);

            // D E B U G
            // console.log('encrypt_with_checksum', {
            //     priv_to_pub: private_key.toPublicKey().toString()
            //     pub: public_key.toPublicKeyString()
            //     nonce: nonce
            //     message: message.length
            //     S: S.toString('hex')
            // })

            var aes = Aes.fromSeed(Buffer.concat([
            // A null or empty string nonce will not effect the hash
            new Buffer("" + nonce), new Buffer(S.toString('hex'))]));
            // DEBUG console.log('... S',S.toString('hex'))
            var checksum = hash.sha256(message).slice(0, 4);
            var payload = Buffer.concat([checksum, message]);
            // DEBUG console.log('... payload',payload.toString())
            return aes.encrypt(payload);
        }
    }]);

    return Aes;
}();

module.exports = Aes;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/aes.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./hash":54,"assert":1,"buffer":11,"bytebuffer":12,"crypto-js/aes":18,"crypto-js/enc-base64":21,"crypto-js/enc-hex":22,"pBGvAp":74}],51:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa
var crypto = require('./hash');
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');
var ECSignature = require('./ecsignature');

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK(curve, hash, d, checkSig, nonce) {

  enforceType('Buffer', hash);
  enforceType(BigInteger, d);

  if (nonce) {
    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));
  }

  // sanity check
  assert.equal(hash.length, 32, 'Hash must be 256 bit');

  var x = d.toBuffer(32);
  var k = new Buffer(32);
  var v = new Buffer(32);

  // Step B
  v.fill(1);

  // Step C
  k.fill(0);

  // Step D
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);

  // Step E
  v = crypto.HmacSHA256(v, k);

  // Step F
  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);

  // Step G
  v = crypto.HmacSHA256(v, k);

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = crypto.HmacSHA256(v, k);

  var T = BigInteger.fromBuffer(v);

  // Step H3, repeat until T is within the interval [1, n - 1]
  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {
    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);
    v = crypto.HmacSHA256(v, k);

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = crypto.HmacSHA256(v, k);

    T = BigInteger.fromBuffer(v);
  }

  return T;
}

function sign(curve, hash, d, nonce) {

  var e = BigInteger.fromBuffer(hash);
  var n = curve.n;
  var G = curve.G;

  var r, s;
  var k = deterministicGenerateK(curve, hash, d, function (k) {
    // find canonically valid signature
    var Q = G.multiply(k);

    if (curve.isInfinity(Q)) return false;

    r = Q.affineX.mod(n);
    if (r.signum() === 0) return false;

    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);
    if (s.signum() === 0) return false;

    return true;
  }, nonce);

  var N_OVER_TWO = n.shiftRight(1);

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.compareTo(N_OVER_TWO) > 0) {
    s = n.subtract(s);
  }

  return new ECSignature(r, s);
}

function verifyRaw(curve, e, signature, Q) {
  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1]
  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;
  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;

  // c = s^-1 mod n
  var c = s.modInverse(n);

  // 1.4.4 Compute u1 = es^1 mod n
  //               u2 = rs^1 mod n
  var u1 = e.multiply(c).mod(n);
  var u2 = r.multiply(c).mod(n);

  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q
  var R = G.multiplyTwo(u1, Q, u2);

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (curve.isInfinity(R)) return false;

  // 1.4.6 Convert the field element R.x to an integer
  var xR = R.affineX;

  // 1.4.7 Set v = xR mod n
  var v = xR.mod(n);

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.equals(r);
}

function verify(curve, hash, signature, Q) {
  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  var e = BigInteger.fromBuffer(hash);
  return verifyRaw(curve, e, signature, Q);
}

/**
  * Recover a public key from a signature.
  *
  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, "Public
  * Key Recovery Operation".
  *
  * http://www.secg.org/download/aid-780/sec1-v2.pdf
  */
function recoverPubKey(curve, e, signature, i) {
  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');

  var n = curve.n;
  var G = curve.G;

  var r = signature.r;
  var s = signature.s;

  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');
  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = i & 1;

  // The more significant bit specifies whether we should use the
  // first or second candidate key.
  var isSecondKey = i >> 1;

  // 1.1 Let x = r + jn
  var x = isSecondKey ? r.add(n) : r;
  var R = curve.pointFromX(isYOdd, x);

  // 1.4 Check that nR is at infinity
  var nR = R.multiply(n);
  assert(curve.isInfinity(nR), 'nR is not a valid curve point');

  // Compute -e from e
  var eNeg = e.negate().mod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  var rInv = r.modInverse(n);

  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);
  curve.validate(Q);

  return Q;
}

/**
  * Calculate pubkey extraction parameter.
  *
  * When extracting a pubkey from a signature, we have to
  * distinguish four different cases. Rather than putting this
  * burden on the verifier, Bitcoin includes a 2-bit value with the
  * signature.
  *
  * This function simply tries all four cases and returns the value
  * that resulted in a successful pubkey recovery.
  */
function calcPubKeyRecoveryParam(curve, e, signature, Q) {
  for (var i = 0; i < 4; i++) {
    var Qprime = recoverPubKey(curve, e, signature, i);

    // 1.6.2 Verify Q
    if (Qprime.equals(Q)) {
      return i;
    }
  }

  throw new Error('Unable to find valid recovery factor');
}

module.exports = {
  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,
  deterministicGenerateK: deterministicGenerateK,
  recoverPubKey: recoverPubKey,
  sign: sign,
  verify: verify,
  verifyRaw: verifyRaw
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/ecdsa.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./ecsignature":52,"./enforce_types":53,"./hash":54,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],52:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var assert = require('assert'); // from https://github.com/bitcoinjs/bitcoinjs-lib
var enforceType = require('./enforce_types');

var BigInteger = require('bigi');

function ECSignature(r, s) {
  enforceType(BigInteger, r);
  enforceType(BigInteger, s);

  this.r = r;
  this.s = s;
}

// Import operations
ECSignature.parseCompact = function (buffer) {
  assert.equal(buffer.length, 65, 'Invalid signature length');
  var i = buffer.readUInt8(0) - 27;

  // At most 3 bits
  assert.equal(i, i & 7, 'Invalid signature parameter');
  var compressed = !!(i & 4);

  // Recovery param only
  i = i & 3;

  var r = BigInteger.fromBuffer(buffer.slice(1, 33));
  var s = BigInteger.fromBuffer(buffer.slice(33));

  return {
    compressed: compressed,
    i: i,
    signature: new ECSignature(r, s)
  };
};

ECSignature.fromDER = function (buffer) {
  assert.equal(buffer.readUInt8(0), 0x30, 'Not a DER sequence');
  assert.equal(buffer.readUInt8(1), buffer.length - 2, 'Invalid sequence length');
  assert.equal(buffer.readUInt8(2), 0x02, 'Expected a DER integer');

  var rLen = buffer.readUInt8(3);
  assert(rLen > 0, 'R length is zero');

  var offset = 4 + rLen;
  assert.equal(buffer.readUInt8(offset), 0x02, 'Expected a DER integer (2)');

  var sLen = buffer.readUInt8(offset + 1);
  assert(sLen > 0, 'S length is zero');

  var rB = buffer.slice(4, offset);
  var sB = buffer.slice(offset + 2);
  offset += 2 + sLen;

  if (rLen > 1 && rB.readUInt8(0) === 0x00) {
    assert(rB.readUInt8(1) & 0x80, 'R value excessively padded');
  }

  if (sLen > 1 && sB.readUInt8(0) === 0x00) {
    assert(sB.readUInt8(1) & 0x80, 'S value excessively padded');
  }

  assert.equal(offset, buffer.length, 'Invalid DER encoding');
  var r = BigInteger.fromDERInteger(rB);
  var s = BigInteger.fromDERInteger(sB);

  assert(r.signum() >= 0, 'R value is negative');
  assert(s.signum() >= 0, 'S value is negative');

  return new ECSignature(r, s);
};

// FIXME: 0x00, 0x04, 0x80 are SIGHASH_* boundary constants, importing Transaction causes a circular dependency
ECSignature.parseScriptSignature = function (buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  var hashTypeMod = hashType & ~0x80;

  assert(hashTypeMod > 0x00 && hashTypeMod < 0x04, 'Invalid hashType');

  return {
    signature: ECSignature.fromDER(buffer.slice(0, -1)),
    hashType: hashType
  };
};

// Export operations
ECSignature.prototype.toCompact = function (i, compressed) {
  if (compressed) i += 4;
  i += 27;

  var buffer = new Buffer(65);
  buffer.writeUInt8(i, 0);

  this.r.toBuffer(32).copy(buffer, 1);
  this.s.toBuffer(32).copy(buffer, 33);

  return buffer;
};

ECSignature.prototype.toDER = function () {
  var rBa = this.r.toDERInteger();
  var sBa = this.s.toDERInteger();

  var sequence = [];

  // INTEGER
  sequence.push(0x02, rBa.length);
  sequence = sequence.concat(rBa);

  // INTEGER
  sequence.push(0x02, sBa.length);
  sequence = sequence.concat(sBa);

  // SEQUENCE
  sequence.unshift(0x30, sequence.length);

  return new Buffer(sequence);
};

ECSignature.prototype.toScriptSignature = function (hashType) {
  var hashTypeBuffer = new Buffer(1);
  hashTypeBuffer.writeUInt8(hashType, 0);

  return Buffer.concat([this.toDER(), hashTypeBuffer]);
};

module.exports = ECSignature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/ecsignature.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./enforce_types":53,"assert":1,"bigi":6,"buffer":11,"pBGvAp":74}],53:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function enforce(type, value) {
  // Copied from https://github.com/bitcoinjs/bitcoinjs-lib
  switch (type) {
    case 'Array':
      {
        if (Array.isArray(value)) return;
        break;
      }

    case 'Boolean':
      {
        if (typeof value === 'boolean') return;
        break;
      }

    case 'Buffer':
      {
        if (Buffer.isBuffer(value)) return;
        break;
      }

    case 'Number':
      {
        if (typeof value === 'number') return;
        break;
      }

    case 'String':
      {
        if (typeof value === 'string') return;
        break;
      }

    default:
      {
        if (getName(value.constructor) === getName(type)) return;
      }
  }

  throw new TypeError('Expected ' + (getName(type) || type) + ', got ' + value);
};

function getName(fn) {
  // Why not fn.name: https://kangax.github.io/compat-table/es6/#function_name_property
  var match = fn.toString().match(/function (.*?)\(/);
  return match ? match[1] : null;
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/enforce_types.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"pBGvAp":74}],54:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var createHash = require("create-hash");
var createHmac = require("create-hmac");

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha1(data, encoding) {
    return createHash('sha1').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha256(data, encoding) {
    return createHash('sha256').update(data).digest(encoding);
}

/** @arg {string|Buffer} data
    @arg {string} [digest = null] - 'hex', 'binary' or 'base64'
    @return {string|Buffer} - Buffer when digest is null, or string
*/
function sha512(data, encoding) {
    return createHash('sha512').update(data).digest(encoding);
}

function HmacSHA256(buffer, secret) {
    return createHmac('sha256', secret).update(buffer).digest();
}

function ripemd160(data) {
    return createHash('rmd160').update(data).digest();
}

// function hash160(buffer) {
//   return ripemd160(sha256(buffer))
// }
//
// function hash256(buffer) {
//   return sha256(sha256(buffer))
// }

//
// function HmacSHA512(buffer, secret) {
//   return crypto.createHmac('sha512', secret).update(buffer).digest()
// }

module.exports = {
    sha1: sha1,
    sha256: sha256,
    sha512: sha512,
    HmacSHA256: HmacSHA256,
    ripemd160: ripemd160
    // hash160: hash160,
    // hash256: hash256,
    // HmacSHA512: HmacSHA512
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/hash.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"buffer":11,"create-hash":14,"create-hmac":17,"pBGvAp":74}],55:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ecdsa = require('./ecdsa');
var hash = require('./hash');

var _require = require('ecurve'),
    getCurveByName = _require.getCurveByName;

var secp256k1 = getCurveByName('secp256k1');
var assert = require('assert');
var BigInteger = require('bigi');
var PublicKey = require('./PublicKey');

var Signature = function () {
    function Signature(r1, s1, i1) {
        _classCallCheck(this, Signature);

        this.r = r1;
        this.s = s1;
        this.i = i1;
        assert.equal(this.r != null, true, 'Missing parameter');
        assert.equal(this.s != null, true, 'Missing parameter');
        assert.equal(this.i != null, true, 'Missing parameter');
    }

    _createClass(Signature, [{
        key: 'toBuffer',
        value: function toBuffer() {
            var buf;
            buf = new Buffer(65);
            buf.writeUInt8(this.i, 0);
            this.r.toBuffer(32).copy(buf, 1);
            this.s.toBuffer(32).copy(buf, 33);
            return buf;
        }
    }, {
        key: 'recoverPublicKeyFromBuffer',
        value: function recoverPublicKeyFromBuffer(buffer) {
            return this.recoverPublicKey(hash.sha256(buffer));
        }
    }, {
        key: 'recoverPublicKey',


        /**
            @return {PublicKey}
        */
        value: function recoverPublicKey(sha256_buffer) {
            var Q = void 0,
                e = void 0,
                i = void 0;
            e = BigInteger.fromBuffer(sha256_buffer);
            i = this.i;
            i -= 27;
            i = i & 3;
            Q = ecdsa.recoverPubKey(secp256k1, e, this, i);
            return PublicKey.fromPoint(Q);
        }
    }, {
        key: 'verifyBuffer',


        /**
            @param {Buffer} un-hashed
            @param {./PublicKey}
            @return {boolean}
        */
        value: function verifyBuffer(buf, public_key) {
            var _hash = hash.sha256(buf);
            return this.verifyHash(_hash, public_key);
        }
    }, {
        key: 'verifyHash',
        value: function verifyHash(hash, public_key) {
            assert.equal(hash.length, 32, "A SHA 256 should be 32 bytes long, instead got " + hash.length);
            return ecdsa.verify(secp256k1, hash, {
                r: this.r,
                s: this.s
            }, public_key.Q);
        }
    }, {
        key: 'toByteBuffer',


        /* <HEX> */

        value: function toByteBuffer() {
            var b;
            b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toHex',
        value: function toHex() {
            return this.toBuffer().toString("hex");
        }
    }, {
        key: 'verifyHex',
        value: function verifyHex(hex, public_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return this.verifyBuffer(buf, public_key);
        }
    }], [{
        key: 'fromBuffer',
        value: function fromBuffer(buf) {
            var i, r, s;
            assert.equal(buf.length, 65, 'Invalid signature length');
            i = buf.readUInt8(0);
            assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');
            r = BigInteger.fromBuffer(buf.slice(1, 33));
            s = BigInteger.fromBuffer(buf.slice(33));
            return new Signature(r, s, i);
        }
    }, {
        key: 'signBuffer',


        /**
            @param {Buffer} buf
            @param {PrivateKey} private_key
            @return {Signature}
        */
        value: function signBuffer(buf, private_key) {
            var _hash = hash.sha256(buf);
            return Signature.signBufferSha256(_hash, private_key);
        }

        /** Sign a buffer of exactally 32 bytes in size (sha256(text))
            @param {Buffer} buf - 32 bytes binary
            @param {PrivateKey} private_key
            @return {Signature}
        */

    }, {
        key: 'signBufferSha256',
        value: function signBufferSha256(buf_sha256, private_key) {
            if (buf_sha256.length !== 32 || !Buffer.isBuffer(buf_sha256)) throw new Error("buf_sha256: 32 byte buffer requred");
            var der, e, ecsignature, i, lenR, lenS, nonce;
            i = null;
            nonce = 0;
            e = BigInteger.fromBuffer(buf_sha256);
            while (true) {
                ecsignature = ecdsa.sign(secp256k1, buf_sha256, private_key.d, nonce++);
                der = ecsignature.toDER();
                lenR = der[3];
                lenS = der[5 + lenR];
                if (lenR === 32 && lenS === 32) {
                    i = ecdsa.calcPubKeyRecoveryParam(secp256k1, e, ecsignature, private_key.toPublicKey().Q);
                    i += 4; // compressed
                    i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)
                    break;
                }
                if (nonce % 10 === 0) {
                    console.log("WARN: " + nonce + " attempts to find canonical signature");
                }
            }
            return new Signature(ecsignature.r, ecsignature.s, i);
        }
    }, {
        key: 'sign',
        value: function sign(string, private_key) {
            return Signature.signBuffer(new Buffer(string), private_key);
        }
    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            return Signature.fromBuffer(new Buffer(hex, "hex"));
        }
    }, {
        key: 'signHex',
        value: function signHex(hex, private_key) {
            var buf;
            buf = new Buffer(hex, 'hex');
            return Signature.signBuffer(buf, private_key);
        }
    }]);

    return Signature;
}();

module.exports = Signature;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/ecc/src/signature.js","/../node_modules/esteem-lib/dist/ecc/src")
},{"./PublicKey":48,"./ecdsa":51,"./hash":54,"assert":1,"bigi":6,"buffer":11,"ecurve":32,"pBGvAp":74}],56:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

module.exports = Object.assign(require("./chain"), require("./ecc"), require("./serializer"));
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/index.js","/../node_modules/esteem-lib/dist")
},{"./chain":35,"./ecc":44,"./serializer":57,"buffer":11,"pBGvAp":74}],57:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = {

    // Primary class for creating operations
    Serializer: require('./src/serializer'),

    // helper functions for creating operations
    fp: require('./src/FastParser'),

    // Low level types
    types: require('./src/types'),

    // Higher level operations (made out of generic types)
    ops: require('./src/operations'),

    // Utility that generates JSON examples
    template: require('./src/template'),

    // Serializer validation
    SerializerValidation: require('./src/SerializerValidation')
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/index.js","/../node_modules/esteem-lib/dist/serializer")
},{"./src/FastParser":58,"./src/SerializerValidation":59,"./src/operations":62,"./src/serializer":63,"./src/template":64,"./src/types":65,"buffer":11,"pBGvAp":74}],58:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PublicKey = require("../../ecc/src/PublicKey");

var FastParser = function () {
    function FastParser() {
        _classCallCheck(this, FastParser);
    }

    _createClass(FastParser, null, [{
        key: 'fixed_data',
        value: function fixed_data(b, len, buffer) {
            if (!b) {
                return;
            }
            if (buffer) {
                var data = buffer.slice(0, len).toString('binary');
                b.append(data, 'binary');
                while (len-- > data.length) {
                    b.writeUint8(0);
                }
            } else {
                var b_copy = b.copy(b.offset, b.offset + len);
                b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        }
    }, {
        key: 'public_key',
        value: function public_key(b, _public_key) {
            if (!b) {
                return;
            }
            if (_public_key) {
                var buffer = _public_key.toBuffer();
                b.append(buffer.toString('binary'), 'binary');
                return;
            } else {
                buffer = FastParser.fixed_data(b, 33);
                return PublicKey.fromBuffer(buffer);
            }
        }
    }, {
        key: 'ripemd160',
        value: function ripemd160(b, _ripemd) {
            if (!b) {
                return;
            }
            if (_ripemd) {
                FastParser.fixed_data(b, 20, _ripemd);
                return;
            } else {
                return FastParser.fixed_data(b, 20);
            }
        }
    }, {
        key: 'time_point_sec',
        value: function time_point_sec(b, epoch) {
            if (epoch) {
                epoch = Math.ceil(epoch / 1000);
                b.writeInt32(epoch);
                return;
            } else {
                epoch = b.readInt32(); // fc::time_point_sec
                return new Date(epoch * 1000);
            }
        }
    }]);

    return FastParser;
}();

module.exports = FastParser;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/FastParser.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../ecc/src/PublicKey":48,"buffer":11,"pBGvAp":74}],59:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _my;
var is_empty;
var is_digits;
var to_number;
var require_match;
var require_object_id;
var require_object_type;
var get_instance;
var require_relative_type;
var get_relative_instance;
var require_protocol_type;
var get_protocol_instance;
var get_protocol_type;
var require_implementation_type;
var get_implementation_instance;
var Long = require('bytebuffer').Long;
// var BigInteger = require('bigi');

var chain_types = require('../../chain/src/ChainTypes');

var MAX_SAFE_INT = 9007199254740991;
var MIN_SAFE_INT = -9007199254740991;

/**
    Most validations are skipped and the value returned unchanged when an empty string, null, or undefined is encountered (except "required"). 
    Validations support a string format for dealing with large numbers.
*/
module.exports = _my = {

    is_empty: is_empty = function is_empty(value) {
        return value === null || value === undefined;
    },

    required: function required(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            throw new Error('value required ' + field_name + ' ' + value);
        }
        return value;
    },
    require_long: function require_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (!Long.isLong(value)) {
            throw new Error('Long value required ' + field_name + ' ' + value);
        }
        return value;
    },
    string: function string(value) {
        if (is_empty(value)) {
            return value;
        }
        if (typeof value !== "string") {
            throw new Error('string required: ' + value);
        }
        return value;
    },
    number: function number(value) {
        if (is_empty(value)) {
            return value;
        }
        if (typeof value !== "number") {
            throw new Error('number required: ' + value);
        }
        return value;
    },
    whole_number: function whole_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (/\./.test(value)) {
            throw new Error('whole number required ' + field_name + ' ' + value);
        }
        return value;
    },
    unsigned: function unsigned(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (/-/.test(value)) {
            throw new Error('unsigned required ' + field_name + ' ' + value);
        }
        return value;
    },


    is_digits: is_digits = function is_digits(value) {
        if (typeof value === "numeric") {
            return true;
        }
        return (/^[0-9]+$/.test(value)
        );
    },

    to_number: to_number = function to_number(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        _my.no_overflow53(value, field_name);
        var int_value = function () {
            if (typeof value === "number") {
                return value;
            } else {
                return parseInt(value);
            }
        }();
        return int_value;
    },

    to_long: function to_long(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (Long.isLong(value)) {
            return value;
        }

        _my.no_overflow64(value, field_name);
        if (typeof value === "number") {
            value = "" + value;
        }
        return Long.fromString(value);
    },
    to_string: function to_string(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (is_empty(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value;
        }
        if (typeof value === "number") {
            _my.no_overflow53(value, field_name);
            return "" + value;
        }
        if (Long.isLong(value)) {
            return value.toString();
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },
    require_test: function require_test(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (is_empty(value)) {
            return value;
        }
        if (!regex.test(value)) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_match: require_match = function require_match(regex, value) {
        var field_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";

        if (is_empty(value)) {
            return value;
        }
        var match = value.match(regex);
        if (match === null) {
            throw new Error('unmatched ' + regex + ' ' + field_name + ' ' + value);
        }
        return match;
    },

    // require_object_id: require_object_id=function(value, field_name){
    //     return require_match(
    //         /^([0-9]+)\.([0-9]+)\.([0-9]+)$/,
    //         value,
    //         field_name
    //     );
    // },

    // Does not support over 53 bits
    require_range: function require_range(min, max, value) {
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (is_empty(value)) {
            return value;
        }
        var number = to_number(value);
        if (value < min || value > max) {
            throw new Error('out of range ' + value + ' ' + field_name + ' ' + value);
        }
        return value;
    },


    require_object_type: require_object_type = function require_object_type() {
        var reserved_spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var type = arguments[1];
        var value = arguments[2];
        var field_name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";

        if (is_empty(value)) {
            return value;
        }
        var object_type = chain_types.object_type[type];
        if (!object_type) {
            throw new Error('Unknown object type: ' + type + ', ' + field_name + ', ' + value);
        }
        var re = new RegExp(reserved_spaces + '.' + object_type + '.[0-9]+$');
        if (!re.test(value)) {
            throw new Error('Expecting ' + type + ' in format ' + (reserved_spaces + '.' + object_type + '.[0-9]+ ') + ('instead of ' + value + ' ' + field_name + ' ' + value));
        }
        return value;
    },

    get_instance: get_instance = function get_instance(reserve_spaces, type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(reserve_spaces, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    require_relative_type: require_relative_type = function require_relative_type(type, value, field_name) {
        require_object_type(0, type, value, field_name);
        return value;
    },

    get_relative_instance: get_relative_instance = function get_relative_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(0, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    require_protocol_type: require_protocol_type = function require_protocol_type(type, value, field_name) {
        require_object_type(1, type, value, field_name);
        return value;
    },

    get_protocol_instance: get_protocol_instance = function get_protocol_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(1, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    get_protocol_type: get_protocol_type = function get_protocol_type(value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_id(value, field_name);
        var values = value.split('.');
        return to_number(values[1]);
    },

    get_protocol_type_name: function get_protocol_type_name(value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        var type_id = get_protocol_type(value, field_name);
        return Object.keys(chain_types.object_type)[type_id];
    },


    require_implementation_type: require_implementation_type = function require_implementation_type(type, value, field_name) {
        require_object_type(2, type, value, field_name);
        return value;
    },

    get_implementation_instance: get_implementation_instance = function get_implementation_instance(type, value, field_name) {
        if (is_empty(value)) {
            return value;
        }
        require_object_type(2, type, value, field_name);
        return to_number(value.split('.')[2]);
    },

    // signed / unsigned decimal
    no_overflow53: function no_overflow53(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "string") {
            var int = parseInt(value);
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (Long.isLong(value)) {
            // typeof value.toInt() is 'number'
            _my.no_overflow53(value.toInt(), field_name);
            return;
        }
        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    },


    // signed / unsigned whole numbers only
    no_overflow64: function no_overflow64(value) {
        var field_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

        // https://github.com/dcodeIO/Long.js/issues/20
        if (Long.isLong(value)) {
            return;
        }

        // BigInteger#isBigInteger https://github.com/cryptocoinjs/bigi/issues/20
        if (value.t !== undefined && value.s !== undefined) {
            _my.no_overflow64(value.toString(), field_name);
            return;
        }

        if (typeof value === "string") {
            // remove leading zeros, will cause a false positive
            value = value.replace(/^0+/, '');
            // remove trailing zeros
            while (/0$/.test(value)) {
                value = value.substring(0, value.length - 1);
            }
            if (/\.$/.test(value)) {
                // remove trailing dot
                value = value.substring(0, value.length - 1);
            }
            if (value === "") {
                value = "0";
            }
            var long_string = Long.fromString(value).toString();
            if (long_string !== value.trim()) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }
        if (typeof value === "number") {
            if (value > MAX_SAFE_INT || value < MIN_SAFE_INT) {
                throw new Error('overflow ' + field_name + ' ' + value);
            }
            return;
        }

        throw 'unsupported type ' + field_name + ': (' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)) + ') ' + value;
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/SerializerValidation.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../chain/src/ChainTypes":38,"buffer":11,"bytebuffer":12,"pBGvAp":74}],60:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Exception nesting.  */
var ErrorWithCause = function () {
    function ErrorWithCause(message, cause) {
        _classCallCheck(this, ErrorWithCause);

        this.message = message;
        if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
            this.message = "cause\t" + cause.message + "\t" + this.message;
        }

        var stack = ""; //(new Error).stack
        if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
            stack = "caused by\n\t" + cause.stack + "\t" + stack;
        }

        this.stack = this.message + "\n" + stack;
    }

    _createClass(ErrorWithCause, null, [{
        key: "throw",
        value: function _throw(message, cause) {
            var msg = message;
            if (typeof cause !== "undefined" && cause !== null ? cause.message : undefined) {
                msg += "\t cause: " + cause.message + " ";
            }
            if (typeof cause !== "undefined" && cause !== null ? cause.stack : undefined) {
                msg += "\n stack: " + cause.stack + " ";
            }
            throw new Error(msg);
        }
    }]);

    return ErrorWithCause;
}();

module.exports = ErrorWithCause;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/error_with_cause.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],61:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var assert = require("assert");

/**
    Convert 12.34 with a precision of 3 into 12340

    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign
    @arg {number} precision - number of implied decimal places (usually causes right zero padding)
    @return {string} -
*/
module.exports = {
    toImpliedDecimal: function toImpliedDecimal(number, precision) {

        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        assert(typeof number === "string", "number should be an actual number or string: " + (typeof number === "undefined" ? "undefined" : _typeof(number)));
        number = number.trim();
        assert(/^[0-9]*\.?[0-9]*$/.test(number), "Invalid decimal number " + number);

        var _number$split = number.split("."),
            _number$split2 = _slicedToArray(_number$split, 2),
            _number$split2$ = _number$split2[0],
            whole = _number$split2$ === undefined ? "" : _number$split2$,
            _number$split2$2 = _number$split2[1],
            decimal = _number$split2$2 === undefined ? "" : _number$split2$2;

        var padding = precision - decimal.length;
        assert(padding >= 0, "Too many decimal digits in " + number + " to create an implied decimal of " + precision);

        for (var i = 0; i < padding; i++) {
            decimal += "0";
        }while (whole.charAt(0) === "0") {
            whole = whole.substring(1);
        }return whole + decimal;
    },

    fromImpliedDecimal: function fromImpliedDecimal(number, precision) {
        if (typeof number === "number") {
            assert(number <= 9007199254740991, "overflow");
            number = "" + number;
        } else if (number.toString) number = number.toString();

        while (number.length < precision + 1) {
            // 0.123
            number = "0" + number;
        } // 44000 => 44.000
        var dec_string = number.substring(number.length - precision);
        return number.substring(0, number.length - precision) + (dec_string ? "." + dec_string : "");
    }
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/numberUtils.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"assert":1,"buffer":11,"pBGvAp":74}],62:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var types = require("./types");
var SerializerImpl = require("./serializer");

var int16 = types.int16,
    uint16 = types.uint16,
    uint32 = types.uint32,
    int64 = types.int64,
    uint64 = types.uint64,
    string = types.string,
    bytes = types.bytes,
    bool = types.bool,
    array = types.array,
    fixed_array = types.fixed_array,
    object_id_type = types.object_id_type,
    vote_id = types.vote_id,
    string_binary = types.string_binary,
    future_extensions = types.future_extensions,
    hardfork_version_vote = types.hardfork_version_vote,
    version = types.version,
    static_variant = types.static_variant,
    map = types.map,
    set = types.set,
    public_key = types.public_key,
    address = types.address,
    time_point_sec = types.time_point_sec,
    optional = types.optional,
    asset = types.asset;

future_extensions = types.void;
hardfork_version_vote = types.void;
version = types.void;

// Place-holder, their are dependencies on "operation" .. The final list of
// operations is not avialble until the very end of the generated code.
// See: operation.st_operations = ...
var operation = static_variant();
module.exports["operation"] = operation;

// For module.exports
var Serializer = function Serializer(operation_name, serilization_types_object) {
    var s = new SerializerImpl(operation_name, serilization_types_object);
    return module.exports[operation_name] = s;
};

// Custom-types follow Generated code:

// ##  Generated code follows
// # npm i -g decaffeinate
// # programs/js_operation_serializer > ops.coffee && decaffeinate ops.coffee
// # open ops.txt, copy to Chain/ChainTypes and operations.js
// ## -------------------------------

var beneficiaries = new Serializer("beneficiaries", {
    account: string,
    weight: uint16
});

var comment_payout_beneficiaries = new Serializer(0, {
    beneficiaries: set(beneficiaries)
});

var signed_transaction = new Serializer("signed_transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions),
    signatures: array(bytes(65))
});

var signed_block = new Serializer("signed_block", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
    witness_signature: bytes(65),
    transactions: array(signed_transaction)
});

var block_header = new Serializer("block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote]))
});

var signed_block_header = new Serializer("signed_block_header", {
    previous: bytes(20),
    timestamp: time_point_sec,
    witness: string,
    transaction_merkle_root: bytes(20),
    extensions: set(static_variant([future_extensions, version, hardfork_version_vote])),
    witness_signature: bytes(65)
});

var vote = new Serializer("vote", {
    voter: string,
    author: string,
    permlink: string,
    weight: int16
});

var comment = new Serializer("comment", {
    parent_author: string,
    parent_permlink: string,
    author: string,
    permlink: string,
    title: string,
    body: string,
    json_metadata: string
});

var transfer = new Serializer("transfer", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_to_vesting = new Serializer("transfer_to_vesting", {
    from: string,
    to: string,
    amount: asset
});

var withdraw_vesting = new Serializer("withdraw_vesting", {
    account: string,
    vesting_shares: asset
});

var limit_order_create = new Serializer("limit_order_create", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    min_to_receive: asset,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var limit_order_cancel = new Serializer("limit_order_cancel", {
    owner: string,
    orderid: uint32
});

var price = new Serializer("price", {
    base: asset,
    quote: asset
});

var feed_publish = new Serializer("feed_publish", {
    publisher: string,
    exchange_rate: price
});

var convert = new Serializer("convert", {
    owner: string,
    requestid: uint32,
    amount: asset
});

var authority = new Serializer("authority", {
    weight_threshold: uint32,
    account_auths: map(string, uint16),
    key_auths: map(public_key, uint16)
});

var account_create = new Serializer("account_create", {
    fee: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string
});

var account_update = new Serializer("account_update", {
    account: string,
    owner: optional(authority),
    active: optional(authority),
    posting: optional(authority),
    memo_key: public_key,
    json_metadata: string
});

var chain_properties = new Serializer("chain_properties", {
    account_creation_fee: asset,
    maximum_block_size: uint32,
    sbd_interest_rate: uint16
});

var witness_update = new Serializer("witness_update", {
    owner: string,
    url: string,
    block_signing_key: public_key,
    props: chain_properties,
    fee: asset
});

var account_witness_vote = new Serializer("account_witness_vote", {
    account: string,
    witness: string,
    approve: bool
});

var account_witness_proxy = new Serializer("account_witness_proxy", {
    account: string,
    proxy: string
});

var pow = new Serializer("pow", {
    worker: public_key,
    input: bytes(32),
    signature: bytes(65),
    work: bytes(32)
});

var custom = new Serializer("custom", {
    required_auths: set(string),
    id: uint16,
    data: bytes()
});

var report_over_production = new Serializer("report_over_production", {
    reporter: string,
    first_block: signed_block_header,
    second_block: signed_block_header
});

var delete_comment = new Serializer("delete_comment", {
    author: string,
    permlink: string
});

var custom_json = new Serializer("custom_json", {
    required_auths: set(string),
    required_posting_auths: set(string),
    id: string,
    json: string
});

var comment_options = new Serializer("comment_options", {
    author: string,
    permlink: string,
    max_accepted_payout: asset,
    percent_steem_dollars: uint16,
    allow_votes: bool,
    allow_curation_rewards: bool,
    extensions: set(static_variant([comment_payout_beneficiaries]))
});

var set_withdraw_vesting_route = new Serializer("set_withdraw_vesting_route", {
    from_account: string,
    to_account: string,
    percent: uint16,
    auto_vest: bool
});

var limit_order_create2 = new Serializer("limit_order_create2", {
    owner: string,
    orderid: uint32,
    amount_to_sell: asset,
    exchange_rate: price,
    fill_or_kill: bool,
    expiration: time_point_sec
});

var challenge_authority = new Serializer("challenge_authority", {
    challenger: string,
    challenged: string,
    require_owner: bool
});

var prove_authority = new Serializer("prove_authority", {
    challenged: string,
    require_owner: bool
});

var request_account_recovery = new Serializer("request_account_recovery", {
    recovery_account: string,
    account_to_recover: string,
    new_owner_authority: authority,
    extensions: set(future_extensions)
});

var recover_account = new Serializer("recover_account", {
    account_to_recover: string,
    new_owner_authority: authority,
    recent_owner_authority: authority,
    extensions: set(future_extensions)
});

var change_recovery_account = new Serializer("change_recovery_account", {
    account_to_recover: string,
    new_recovery_account: string,
    extensions: set(future_extensions)
});

var escrow_transfer = new Serializer("escrow_transfer", {
    from: string,
    to: string,
    sbd_amount: asset,
    steem_amount: asset,
    escrow_id: uint32,
    agent: string,
    fee: asset,
    json_meta: string,
    ratification_deadline: time_point_sec,
    escrow_expiration: time_point_sec
});

var escrow_dispute = new Serializer("escrow_dispute", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32
});

var escrow_release = new Serializer("escrow_release", {
    from: string,
    to: string,
    agent: string,
    who: string,
    receiver: string,
    escrow_id: uint32,
    sbd_amount: asset,
    steem_amount: asset
});

var pow2_input = new Serializer("pow2_input", {
    worker_account: string,
    prev_block: bytes(20),
    nonce: uint64
});

var pow2 = new Serializer("pow2", {
    input: pow2_input,
    pow_summary: uint32
});

var equihash_proof = new Serializer("equihash_proof", {
    n: uint32,
    k: uint32,
    seed: bytes(32),
    inputs: array(uint32)
});

var equihash_pow = new Serializer("equihash_pow", {
    input: pow2_input,
    proof: equihash_proof,
    prev_block: bytes(20),
    pow_summary: uint32
});

var escrow_approve = new Serializer("escrow_approve", {
    from: string,
    to: string,
    agent: string,
    who: string,
    escrow_id: uint32,
    approve: bool
});

var transfer_to_savings = new Serializer("transfer_to_savings", {
    from: string,
    to: string,
    amount: asset,
    memo: string
});

var transfer_from_savings = new Serializer("transfer_from_savings", {
    from: string,
    request_id: uint32,
    to: string,
    amount: asset,
    memo: string
});

var cancel_transfer_from_savings = new Serializer("cancel_transfer_from_savings", {
    from: string,
    request_id: uint32
});

var custom_binary = new Serializer("custom_binary", {
    required_owner_auths: set(string),
    required_active_auths: set(string),
    required_posting_auths: set(string),
    required_auths: array(authority),
    id: string,
    data: bytes()
});

var decline_voting_rights = new Serializer("decline_voting_rights", {
    account: string,
    decline: bool
});

var reset_account = new Serializer("reset_account", {
    reset_account: string,
    account_to_reset: string,
    new_owner_authority: authority
});

var set_reset_account = new Serializer("set_reset_account", {
    account: string,
    current_reset_account: string,
    reset_account: string
});

var claim_reward_balance = new Serializer("claim_reward_balance", {
    account: string,
    reward_steem: asset,
    reward_sbd: asset,
    reward_vests: asset
});

var delegate_vesting_shares = new Serializer("delegate_vesting_shares", {
    delegator: string,
    delegatee: string,
    vesting_shares: asset
});

var account_create_with_delegation = new Serializer("account_create_with_delegation", {
    fee: asset,
    delegation: asset,
    creator: string,
    new_account_name: string,
    owner: authority,
    active: authority,
    posting: authority,
    memo_key: public_key,
    json_metadata: string,
    extensions: set(future_extensions)
});

var fill_convert_request = new Serializer("fill_convert_request", {
    owner: string,
    requestid: uint32,
    amount_in: asset,
    amount_out: asset
});

var author_reward = new Serializer("author_reward", {
    author: string,
    permlink: string,
    sbd_payout: asset,
    steem_payout: asset,
    vesting_payout: asset
});

var curation_reward = new Serializer("curation_reward", {
    curator: string,
    reward: asset,
    comment_author: string,
    comment_permlink: string
});

var comment_reward = new Serializer("comment_reward", {
    author: string,
    permlink: string,
    payout: asset
});

var liquidity_reward = new Serializer("liquidity_reward", {
    owner: string,
    payout: asset
});

var interest = new Serializer("interest", {
    owner: string,
    interest: asset
});

var fill_vesting_withdraw = new Serializer("fill_vesting_withdraw", {
    from_account: string,
    to_account: string,
    withdrawn: asset,
    deposited: asset
});

var fill_order = new Serializer("fill_order", {
    current_owner: string,
    current_orderid: uint32,
    current_pays: asset,
    open_owner: string,
    open_orderid: uint32,
    open_pays: asset
});

var shutdown_witness = new Serializer("shutdown_witness", { owner: string });

var fill_transfer_from_savings = new Serializer("fill_transfer_from_savings", {
    from: string,
    to: string,
    amount: asset,
    request_id: uint32,
    memo: string
});

var hardfork = new Serializer("hardfork", { hardfork_id: uint32 });

var comment_payout_update = new Serializer("comment_payout_update", {
    author: string,
    permlink: string
});

var return_vesting_delegation = new Serializer("return_vesting_delegation", {
    account: string,
    vesting_shares: asset
});

var comment_benefactor_reward = new Serializer("comment_benefactor_reward", {
    benefactor: string,
    author: string,
    permlink: string,
    reward: asset
});

operation.st_operations = [vote, comment, transfer, transfer_to_vesting, withdraw_vesting, limit_order_create, limit_order_cancel, feed_publish, convert, account_create, account_update, witness_update, account_witness_vote, account_witness_proxy, pow, custom, report_over_production, delete_comment, custom_json, comment_options, set_withdraw_vesting_route, limit_order_create2, challenge_authority, prove_authority, request_account_recovery, recover_account, change_recovery_account, escrow_transfer, escrow_dispute, escrow_release, pow2, escrow_approve, transfer_to_savings, transfer_from_savings, cancel_transfer_from_savings, custom_binary, decline_voting_rights, reset_account, set_reset_account, claim_reward_balance, delegate_vesting_shares, account_create_with_delegation, fill_convert_request, author_reward, curation_reward, comment_reward, liquidity_reward, interest, fill_vesting_withdraw, fill_order, shutdown_witness, fill_transfer_from_savings, hardfork, comment_payout_update, return_vesting_delegation, comment_benefactor_reward];

var transaction = new Serializer("transaction", {
    ref_block_num: uint16,
    ref_block_prefix: uint32,
    expiration: time_point_sec,
    operations: array(operation),
    extensions: set(future_extensions)
});

//# -------------------------------
//#  Generated code end  S T O P
//# -------------------------------

// Custom Types (do not over-write)

var encrypted_memo = new Serializer("encrypted_memo", { from: public_key,
    to: public_key,
    nonce: uint64,
    check: uint32,
    encrypted: string_binary });
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/operations.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"./serializer":63,"./types":65,"buffer":11,"pBGvAp":74}],63:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ByteBuffer = require('bytebuffer');
var EC = require('./error_with_cause');

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

var Serializer = function () {
    function Serializer(operation_name, types) {
        _classCallCheck(this, Serializer);

        this.operation_name = operation_name;
        this.types = types;
        if (this.types) this.keys = Object.keys(this.types);

        Serializer.printDebug = true;
    }

    _createClass(Serializer, [{
        key: 'fromByteBuffer',
        value: function fromByteBuffer(b) {
            var object = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    try {
                        if (HEX_DUMP) {
                            if (type.operation_name) {
                                console.error(type.operation_name);
                            } else {
                                var o1 = b.offset;
                                type.fromByteBuffer(b);
                                var o2 = b.offset;
                                b.offset = o1;
                                //b.reset()
                                var _b = b.copy(o1, o2);
                                console.error(this.operation_name + '.' + field + '\t', _b.toHex());
                            }
                        }
                        object[field] = type.fromByteBuffer(b);
                    } catch (e) {
                        if (Serializer.printDebug) {
                            console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');
                            b.printDebug();
                        }
                        throw e;
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return object;
        }
    }, {
        key: 'appendByteBuffer',
        value: function appendByteBuffer(b, object) {
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    type.appendByteBuffer(b, object[field]);
                }
            } catch (error) {
                try {
                    EC.throw(this.operation_name + '.' + field + " = " + JSON.stringify(object[field]), error);
                } catch (e) {
                    // circular ref
                    EC.throw(this.operation_name + '.' + field + " = " + object[field], error);
                }
            }
            return;
        }
    }, {
        key: 'fromObject',
        value: function fromObject(serialized_object) {
            var result = {};
            var field = null;
            try {
                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var value = serialized_object[field];
                    //DEBUG value = value.resolve if value.resolve
                    //DEBUG console.log('... value',field,value)
                    var object = type.fromObject(value);
                    result[field] = object;
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /**
            @arg {boolean} [debug.use_default = false] - more template friendly
            @arg {boolean} [debug.annotate = false] - add user-friendly information
        */

    }, {
        key: 'toObject',
        value: function toObject() {
            var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: false, annotate: false };

            var result = {};
            var field = null;
            try {
                if (!this.types) return result;

                var iterable = this.keys;
                for (var i = 0, field; i < iterable.length; i++) {
                    field = iterable[i];
                    var type = this.types[field];
                    var object = type.toObject(typeof serialized_object !== "undefined" && serialized_object !== null ? serialized_object[field] : undefined, debug);
                    result[field] = object;
                    if (HEX_DUMP) {
                        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
                        var has_value = typeof serialized_object !== "undefined" && serialized_object !== null;
                        if (has_value) {
                            var value = serialized_object[field];
                            if (value) type.appendByteBuffer(b, value);
                        }
                        b = b.copy(0, b.offset);
                        console.error(this.operation_name + '.' + field, b.toHex());
                    }
                }
            } catch (error) {
                EC.throw(this.operation_name + '.' + field, error);
            }

            return result;
        }

        /** Sort by the first element in a operation */

    }, {
        key: 'compare',
        value: function compare(a, b) {

            var first_key = this.keys[0];
            var first_type = this.types[first_key];

            var valA = a[first_key];
            var valB = b[first_key];

            if (first_type.compare) return first_type.compare(valA, valB);

            if (typeof valA === "number" && typeof valB === "number") return valA - valB;

            var encoding = void 0;
            if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {
                // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.
                encoding = "hex";
            }

            var strA = valA.toString(encoding);
            var strB = valB.toString(encoding);
            return strA > strB ? 1 : strA < strB ? -1 : 0;
        }

        // <helper_functions>

    }, {
        key: 'fromHex',
        value: function fromHex(hex) {
            var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'fromBuffer',
        value: function fromBuffer(buffer) {
            var b = ByteBuffer.fromBinary(buffer.toString("binary"), ByteBuffer.LITTLE_ENDIAN);
            return this.fromByteBuffer(b);
        }
    }, {
        key: 'toHex',
        value: function toHex(object) {
            // return this.toBuffer(object).toString("hex")
            var b = this.toByteBuffer(object);
            return b.toHex();
        }
    }, {
        key: 'toByteBuffer',
        value: function toByteBuffer(object) {
            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);
            this.appendByteBuffer(b, object);
            return b.copy(0, b.offset);
        }
    }, {
        key: 'toBuffer',
        value: function toBuffer(object) {
            return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');
        }
    }]);

    return Serializer;
}();

module.exports = Serializer;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/serializer.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"./error_with_cause":60,"buffer":11,"bytebuffer":12,"pBGvAp":74}],64:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

/** Console print any transaction object with zero default values. */
module.exports = function template(op) {

    var object = op.toObject(void 0, { use_default: true, annotate: true });

    // visual (with descriptions)
    console.error(JSON.stringify(object, null, 4));

    // usable in a copy-paste

    object = op.toObject(void 0, { use_default: true, annotate: false });

    // copy-paste one-lineer
    console.error(JSON.stringify(object));
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/template.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"buffer":11,"pBGvAp":74}],65:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Low-level types that make up operations

var v = require('./SerializerValidation');
var fp = require('./FastParser');

var ChainTypes = require("../../chain/src/ChainTypes");
var ObjectId = require("../../chain/src/ObjectId");

var _require = require("../../ecc"),
    PublicKey = _require.PublicKey,
    Address = _require.Address;

var ChainConfig = require("../../chain/src/ChainConfig");

var _require2 = require("./numberUtils"),
    fromImpliedDecimal = _require2.fromImpliedDecimal;

var Types = {};
module.exports = Types;

var HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;

/**
* Asset symbols contain the following information
*
*  4 bit PRECISION
*  4 bit RESERVED
*  CHAR[6] up to 6 upper case alpha numeric ascii characters,
*  char = \0  null terminated
*
*  It is treated as a uint64_t for all internal operations, but
*  is easily converted to something that can be displayed.
*/
Types.asset = {
    fromByteBuffer: function fromByteBuffer(b) {
        var amount = b.readInt64();
        var precision = b.readUint8();
        var b_copy = b.copy(b.offset, b.offset + 7);
        var symbol = new Buffer(b_copy.toBinary(), "binary").toString().replace(/\x00/g, "");
        b.skip(7);
        // "1.000 STEEM" always written with full precision
        var amount_string = fromImpliedDecimal(amount, precision);
        return amount_string + " " + symbol;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        object = object.trim();
        if (!/^[0-9]+\.?[0-9]* [A-Za-z0-9]+$/.test(object)) throw new Error("Expecting amount like '99.000 SYMBOL', instead got '" + object + "'");

        var _object$split = object.split(" "),
            _object$split2 = _slicedToArray(_object$split, 2),
            amount = _object$split2[0],
            symbol = _object$split2[1];

        if (symbol.length > 6) throw new Error("Symbols are not longer than 6 characters " + symbol + "-" + symbol.length);

        b.writeInt64(v.to_long(amount.replace(".", "")));
        var dot = amount.indexOf("."); // 0.000
        var precision = dot === -1 ? 0 : amount.length - dot - 1;
        b.writeUint8(precision);
        b.append(symbol.toUpperCase(), 'binary');
        for (var i = 0; i < 7 - symbol.length; i++) {
            b.writeUint8(0);
        }return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.000 STEEM";
        }
        return object;
    }
};

Types.uint8 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        b.writeUint8(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFF, object, 'uint8 ' + object);
        return parseInt(object);
    }
};

Types.uint16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        b.writeUint16(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFF, object, 'uint16 ' + object);
        return parseInt(object);
    }
};

Types.uint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(0, 0xFFFFFFFF, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

var MIN_SIGNED_32 = -1 * Math.pow(2, 31);
var MAX_SIGNED_32 = Math.pow(2, 31) - 1;

Types.varint32 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readVarint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        b.writeVarint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        v.require_range(MIN_SIGNED_32, MAX_SIGNED_32, object, 'uint32 ' + object);
        return parseInt(object);
    }
};

Types.int16 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt16();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeInt16(object);
        return;
    },
    fromObject: function fromObject(object) {
        return object;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return 0;
        }
        return parseInt(object);
    }
};

Types.int64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readInt64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeInt64(v.to_long(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return v.to_long(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        v.required(object);
        return v.to_long(object).toString();
    }
};

Types.uint64 = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint64();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeUint64(v.to_long(v.unsigned(object)));
        return;
    },
    fromObject: function fromObject(object) {
        return v.to_long(v.unsigned(object));
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0";
        }
        return v.to_long(object).toString();
    }
};

Types.string = {
    fromByteBuffer: function fromByteBuffer(b) {
        return new Buffer(b.readVString(), 'utf8');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        b.writeVString(object.toString());
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object, 'utf8');
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString('utf8');
    }
};

Types.string_binary = {
    fromByteBuffer: function fromByteBuffer(b) {
        var b_copy;
        var len = b.readVarint32();
        b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
        return new Buffer(b_copy.toBinary(), 'binary');
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        b.writeVarint32(object.length);
        b.append(object.toString('binary'), 'binary');
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        return new Buffer(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "";
        }
        return object.toString();
    }
};

Types.bytes = function (size) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (size === undefined) {
                var b_copy;
                var len = b.readVarint32();
                b_copy = b.copy(b.offset, b.offset + len), b.skip(len);
                return new Buffer(b_copy.toBinary(), 'binary');
            } else {
                b_copy = b.copy(b.offset, b.offset + size), b.skip(size);
                return new Buffer(b_copy.toBinary(), 'binary');
            }
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (typeof object === "string") object = new Buffer(object, "hex");

            if (size === undefined) {
                b.writeVarint32(object.length);
            }
            b.append(object.toString('binary'), 'binary');
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (Buffer.isBuffer(object)) return object;

            return new Buffer(object, 'hex');
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                var zeros = function zeros(num) {
                    return new Array(num).join("00");
                };
                return zeros(size);
            }
            v.required(object);
            return object.toString('hex');
        }
    };
};

Types.bool = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint8() === 1;
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        // supports boolean or integer
        b.writeUint8(JSON.parse(object) ? 1 : 0);
        return;
    },
    fromObject: function fromObject(object) {
        return JSON.parse(object) ? true : false;
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return false;
        }
        return JSON.parse(object) ? true : false;
    }
};

Types.void = {
    fromByteBuffer: function fromByteBuffer(b) {
        throw new Error("(void) undefined type");
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        throw new Error("(void) undefined type");
    },
    fromObject: function fromObject(object) {
        throw new Error("(void) undefined type");
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return undefined;
        }
        throw new Error("(void) undefined type");
    }
};

Types.array = function (st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            var result = [];
            for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                result.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(result, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                st_operation.appendByteBuffer(b, o);
            }
        },
        fromObject: function fromObject(object) {
            v.required(object);
            object = sortOperation(object, st_operation);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.fromObject(o));
            }
            return result;
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            v.required(object);
            object = sortOperation(object, st_operation);

            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push(st_operation.toObject(o, debug));
            }
            return result;
        }
    };
};

Types.time_point_sec = {
    fromByteBuffer: function fromByteBuffer(b) {
        return b.readUint32();
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        if (typeof object !== "number") object = Types.time_point_sec.fromObject(object);

        b.writeUint32(object);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);

        if (typeof object === "number") return object;

        if (object.getTime) return Math.floor(object.getTime() / 1000);

        if (typeof object !== "string") throw new Error("Unknown date type: " + object);

        if (typeof object === "string" && !/Z$/.test(object)) object = object + "Z";

        return Math.floor(new Date(object).getTime() / 1000);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) return new Date(0).toISOString().split('.')[0];

        v.required(object);

        if (typeof object === "string") return object;

        if (object.getTime) return object.toISOString().split('.')[0];

        var int = parseInt(object);
        v.require_range(0, 0xFFFFFFFF, int, 'uint32 ' + object);
        return new Date(int * 1000).toISOString().split('.')[0];
    }
};

Types.set = function (st_operation) {
    return {
        validate: function validate(array) {
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (ref = typeof o === 'undefined' ? 'undefined' : _typeof(o), ['string', 'number'].indexOf(ref) >= 0) {
                    if (dup_map[o] !== undefined) {
                        throw new Error("duplicate (set)");
                    }
                    dup_map[o] = true;
                }
            }
            return sortOperation(array, st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var size = b.readVarint32();
            if (HEX_DUMP) {
                console.log("varint32 size = " + size.toString(16));
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0; 0 < size ? i < size : i > size; 0 < size ? i++ : i++) {
                    result.push(st_operation.fromByteBuffer(b));
                }
                return result;
            }());
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (!object) {
                object = [];
            }
            b.writeVarint32(object.length);
            var iterable = this.validate(object);
            for (var i = 0, o; i < iterable.length; i++) {
                o = iterable[i];
                st_operation.appendByteBuffer(b, o);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.fromObject(o));
                }
                return result;
            }());
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [st_operation.toObject(object, debug)];
            }
            if (!object) {
                object = [];
            }
            return this.validate(function () {
                var result = [];
                for (var i = 0, o; i < object.length; i++) {
                    o = object[i];
                    result.push(st_operation.toObject(o, debug));
                }
                return result;
            }());
        }
    };
};

// global_parameters_update_operation current_fees
Types.fixed_array = function (count, st_operation) {
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            var i, j, ref, results;
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromByteBuffer(b));
            }
            return sortOperation(results, st_operation);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            var i, j, ref;
            if (count !== 0) {
                v.required(object);
                object = sortOperation(object, st_operation);
            }
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                st_operation.appendByteBuffer(b, object[i]);
            }
        },
        fromObject: function fromObject(object) {
            var i, j, ref, results;
            if (count !== 0) {
                v.required(object);
            }
            results = [];
            for (i = j = 0, ref = count; j < ref; i = j += 1) {
                results.push(st_operation.fromObject(object[i]));
            }
            return results;
        },
        toObject: function toObject(object, debug) {
            var i, j, k, ref, ref1, results, results1;
            if (debug == null) {
                debug = {};
            }
            if (debug.use_default && object === void 0) {
                results = [];
                for (i = j = 0, ref = count; j < ref; i = j += 1) {
                    results.push(st_operation.toObject(void 0, debug));
                }
                return results;
            }
            if (count !== 0) {
                v.required(object);
            }
            results1 = [];
            for (i = k = 0, ref1 = count; k < ref1; i = k += 1) {
                results1.push(st_operation.toObject(object[i], debug));
            }
            return results1;
        }
    };
};

/* Supports instance numbers (11) or object types (1.2.11).  Object type
validation is enforced when an object type is used. */
var id_type = function id_type(reserved_spaces, object_type) {
    v.required(reserved_spaces, "reserved_spaces");
    v.required(object_type, "object_type");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            return b.readVarint32();
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            // convert 1.2.n into just n
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }
            b.writeVarint32(v.to_number(object));
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (v.is_digits(object)) {
                return v.to_number(object);
            }
            return v.get_instance(reserved_spaces, object_type, object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            var object_type_id = chain_types.object_type[object_type];
            if (debug.use_default && object === undefined) {
                return reserved_spaces + '.' + object_type_id + '.0';
            }
            v.required(object);
            if (object.resolve !== undefined) {
                object = object.resolve;
            }
            if (/^[0-9]+\.[0-9]+\.[0-9]+$/.test(object)) {
                object = v.get_instance(reserved_spaces, object_type, object);
            }

            return reserved_spaces + '.' + object_type_id + '.' + object;
        }
    };
};

Types.protocol_id_type = function (name) {
    v.required(name, "name");
    return id_type(chain_types.reserved_spaces.protocol_ids, name);
};

Types.object_id_type = {
    fromByteBuffer: function fromByteBuffer(b) {
        return ObjectId.fromByteBuffer(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        object.appendByteBuffer(b);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return ObjectId.fromString(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0.0.0";
        }
        v.required(object);
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        object = ObjectId.fromString(object);
        return object.toString();
    }
};

Types.vote_id = { TYPE: 0x000000FF,
    ID: 0xFFFFFF00,
    fromByteBuffer: function fromByteBuffer(b) {
        var value = b.readUint32();
        return {
            type: value & this.TYPE,
            id: value & this.ID
        };
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        if (object === "string") object = Types.vote_id.fromObject(object);

        var value = object.id << 8 | object.type;
        b.writeUint32(value);
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object, "(type vote_id)");
        if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) === "object") {
            v.required(object.type, "type");
            v.required(object.id, "id");
            return object;
        }
        v.require_test(/^[0-9]+:[0-9]+$/, object, 'vote_id format ' + object);

        var _object$split3 = object.split(':'),
            _object$split4 = _slicedToArray(_object$split3, 2),
            type = _object$split4[0],
            id = _object$split4[1];

        v.require_range(0, 0xff, type, 'vote type ' + object);
        v.require_range(0, 0xffffff, id, 'vote id ' + object);
        return { type: type, id: id };
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return "0:0";
        }
        v.required(object);
        if (typeof object === "string") object = Types.vote_id.fromObject(object);

        return object.type + ":" + object.id;
    },
    compare: function compare(a, b) {
        if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== "object") a = Types.vote_id.fromObject(a);
        if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) !== "object") b = Types.vote_id.fromObject(b);
        return parseInt(a.id) - parseInt(b.id);
    }
};

Types.optional = function (st_operation) {
    v.required(st_operation, "st_operation");
    return {
        fromByteBuffer: function fromByteBuffer(b) {
            if (!(b.readUint8() === 1)) {
                return undefined;
            }
            return st_operation.fromByteBuffer(b);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            if (object !== null && object !== undefined) {
                b.writeUint8(1);
                st_operation.appendByteBuffer(b, object);
            } else {
                b.writeUint8(0);
            }
            return;
        },
        fromObject: function fromObject(object) {
            if (object === undefined) {
                return undefined;
            }
            return st_operation.fromObject(object);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            // toObject is only null save if use_default is true
            var result_object = function () {
                if (!debug.use_default && object === undefined) {
                    return undefined;
                } else {
                    return st_operation.toObject(object, debug);
                }
            }();

            if (debug.annotate) {
                if ((typeof result_object === 'undefined' ? 'undefined' : _typeof(result_object)) === "object") {
                    result_object.__optional = "parent is optional";
                } else {
                    result_object = { __optional: result_object };
                }
            }
            return result_object;
        }
    };
};

Types.static_variant = function (_st_operations) {
    return {
        nosort: true,
        st_operations: _st_operations,
        opTypeId: function opTypeId(value) {
            var pos = 0,
                type_id = void 0;
            if (typeof value === "number") type_id = value;else {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.st_operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var op = _step.value;

                        if (op.operation_name === value) {
                            type_id = pos;
                            break;
                        }
                        pos++;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
            return type_id;
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var type_id = b.readVarint32();
            var st_operation = this.st_operations[type_id];
            if (HEX_DUMP) {
                console.error('static_variant id 0x' + type_id.toString(16) + ' (' + type_id + ')');
            }
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromByteBuffer(b)];
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            b.writeVarint32(type_id);
            st_operation.appendByteBuffer(b, object[1]);
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [type_id, st_operation.fromObject(object[1])];
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [this.st_operations[0].operation_name, this.st_operations[0].toObject(undefined, debug)];
            }
            v.required(object);
            var type_id = this.opTypeId(object[0]);
            var st_operation = this.st_operations[type_id];
            v.required(st_operation, 'operation ' + type_id);
            return [st_operation.operation_name, st_operation.toObject(object[1], debug)];
        },
        compare: function compare(a, b) {
            return strCmp(this.opTypeId(a[0]), this.opTypeId(b[0]));
        }
    };
};

Types.map = function (key_st_operation, value_st_operation) {
    return {
        validate: function validate(array) {
            if (!Array.isArray(array)) {
                throw new Error("expecting array");
            }
            var dup_map = {};
            for (var i = 0, o; i < array.length; i++) {
                o = array[i];
                var ref;
                if (!(o.length === 2)) {
                    throw new Error("expecting two elements");
                }
                if (ref = _typeof(o[0]), ['number', 'string'].indexOf(ref) >= 0) {
                    if (dup_map[o[0]] !== undefined) {
                        throw new Error("duplicate (map)");
                    }
                    dup_map[o[0]] = true;
                }
            }
            return sortOperation(array, key_st_operation);
        },
        fromByteBuffer: function fromByteBuffer(b) {
            var result = [];
            var end = b.readVarint32();
            for (var i = 0; 0 < end ? i < end : i > end; 0 < end ? i++ : i++) {
                result.push([key_st_operation.fromByteBuffer(b), value_st_operation.fromByteBuffer(b)]);
            }
            return this.validate(result);
        },
        appendByteBuffer: function appendByteBuffer(b, object) {
            this.validate(object);
            b.writeVarint32(object.length);
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                key_st_operation.appendByteBuffer(b, o[0]);
                value_st_operation.appendByteBuffer(b, o[1]);
            }
            return;
        },
        fromObject: function fromObject(object) {
            v.required(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.fromObject(o[0]), value_st_operation.fromObject(o[1])]);
            }
            return this.validate(result);
        },
        toObject: function toObject(object) {
            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            if (debug.use_default && object === undefined) {
                return [[key_st_operation.toObject(undefined, debug), value_st_operation.toObject(undefined, debug)]];
            }
            v.required(object);
            object = this.validate(object);
            var result = [];
            for (var i = 0, o; i < object.length; i++) {
                o = object[i];
                result.push([key_st_operation.toObject(o[0], debug), value_st_operation.toObject(o[1], debug)]);
            }
            return result;
        }
    };
};

Types.public_key = {
    toPublic: function toPublic(object) {
        if (object.resolve !== undefined) {
            object = object.resolve;
        }
        return object == null ? object : object.Q ? object : PublicKey.fromStringOrThrow(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return fp.public_key(b);
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        v.required(object);
        fp.public_key(b, Types.public_key.toPublic(object));
        return;
    },
    fromObject: function fromObject(object) {
        v.required(object);
        if (object.Q) {
            return object;
        }
        return Types.public_key.toPublic(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM";
        }
        v.required(object);
        return object.toString();
    },
    compare: function compare(a, b) {
        return strCmp(a.toString(), b.toString());
    }
};

Types.address = {
    _to_address: function _to_address(object) {
        v.required(object);
        if (object.addy) {
            return object;
        }
        return Address.fromString(object);
    },
    fromByteBuffer: function fromByteBuffer(b) {
        return new Address(fp.ripemd160(b));
    },
    appendByteBuffer: function appendByteBuffer(b, object) {
        fp.ripemd160(b, Types.address._to_address(object).toBuffer());
        return;
    },
    fromObject: function fromObject(object) {
        return Types.address._to_address(object);
    },
    toObject: function toObject(object) {
        var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (debug.use_default && object === undefined) {
            return ChainConfig.address_prefix + "664KmHxSuQyDsfwo4WEJvWpzg1QKdg67S";
        }
        return Types.address._to_address(object).toString();
    },
    compare: function compare(a, b) {
        // sort decending
        return -1 * strCmp(a.toString(), b.toString());
    }
};

var strCmp = function strCmp(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
};
var firstEl = function firstEl(el) {
    return Array.isArray(el) ? el[0] : el;
};
var sortOperation = function sortOperation(array, st_operation) {
    return st_operation.nosort ? array : st_operation.compare ? array.sort(function (a, b) {
        return st_operation.compare(firstEl(a), firstEl(b));
    }) : // custom compare operation
    array.sort(function (a, b) {
        return typeof firstEl(a) === "number" && typeof firstEl(b) === "number" ? firstEl(a) - firstEl(b) :
        // A binary string compare does not work. Performanance is very good so HEX is used..  localeCompare is another option.
        Buffer.isBuffer(firstEl(a)) && Buffer.isBuffer(firstEl(b)) ? strCmp(firstEl(a).toString("hex"), firstEl(b).toString("hex")) : strCmp(firstEl(a).toString(), firstEl(b).toString());
    });
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/dist/serializer/src/types.js","/../node_modules/esteem-lib/dist/serializer/src")
},{"../../chain/src/ChainConfig":37,"../../chain/src/ChainTypes":38,"../../chain/src/ObjectId":41,"../../ecc":44,"./FastParser":58,"./SerializerValidation":59,"./numberUtils":61,"buffer":11,"pBGvAp":74}],66:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var pSlice = Array.prototype.slice;
var objectKeys = require('./lib/keys.js');
var isArguments = require('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/index.js","/../node_modules/esteem-lib/node_modules/deep-equal")
},{"./lib/is_arguments.js":67,"./lib/keys.js":68,"buffer":11,"pBGvAp":74}],67:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/lib/is_arguments.js","/../node_modules/esteem-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],68:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/esteem-lib/node_modules/deep-equal/lib/keys.js","/../node_modules/esteem-lib/node_modules/deep-equal/lib")
},{"buffer":11,"pBGvAp":74}],69:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/events/events.js","/../node_modules/events")
},{"buffer":11,"pBGvAp":74}],70:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ieee754/index.js","/../node_modules/ieee754")
},{"buffer":11,"pBGvAp":74}],71:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/inherits/inherits_browser.js","/../node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],72:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/long/dist/long.js","/../node_modules/long/dist")
},{"buffer":11,"pBGvAp":74}],73:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/object-assign/index.js","/../node_modules/object-assign")
},{"buffer":11,"pBGvAp":74}],74:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/process/browser.js","/../node_modules/process")
},{"buffer":11,"pBGvAp":74}],75:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/ripemd160/lib/ripemd160.js","/../node_modules/ripemd160/lib")
},{"buffer":11,"pBGvAp":74}],76:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
!function(globals){
'use strict'

//*** UMD BEGIN
if (typeof define !== 'undefined' && define.amd) { //require.js / AMD
  define([], function() {
    return secureRandom
  })
} else if (typeof module !== 'undefined' && module.exports) { //CommonJS
  module.exports = secureRandom
} else { //script / browser
  globals.secureRandom = secureRandom
}
//*** UMD END

//options.type is the only valid option
function secureRandom(count, options) {
  options = options || {type: 'Array'}
  //we check for process.pid to prevent browserify from tricking us
  if (typeof process != 'undefined' && typeof process.pid == 'number') {
    return nodeRandom(count, options)
  } else {
    var crypto = window.crypto || window.msCrypto
    if (!crypto) throw new Error("Your browser does not support window.crypto.")
    return browserRandom(count, options)
  }
}

function nodeRandom(count, options) {
  var crypto = require('crypto')
  var buf = crypto.randomBytes(count)

  switch (options.type) {
    case 'Array':
      return [].slice.call(buf)
    case 'Buffer':
      return buf
    case 'Uint8Array':
      var arr = new Uint8Array(count)
      for (var i = 0; i < count; ++i) { arr[i] = buf.readUInt8(i) }
      return arr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

function browserRandom(count, options) {
  var nativeArr = new Uint8Array(count)
  var crypto = window.crypto || window.msCrypto
  crypto.getRandomValues(nativeArr)

  switch (options.type) {
    case 'Array':
      return [].slice.call(nativeArr)
    case 'Buffer':
      try { var b = new Buffer(1) } catch(e) { throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.')}
      return new Buffer(nativeArr)
    case 'Uint8Array':
      return nativeArr
    default:
      throw new Error(options.type + " is unsupported.")
  }
}

secureRandom.randomArray = function(byteCount) {
  return secureRandom(byteCount, {type: 'Array'})
}

secureRandom.randomUint8Array = function(byteCount) {
  return secureRandom(byteCount, {type: 'Uint8Array'})
}

secureRandom.randomBuffer = function(byteCount) {
  return secureRandom(byteCount, {type: 'Buffer'})
}


}(this);

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/secure-random/lib/secure-random.js","/../node_modules/secure-random/lib")
},{"buffer":11,"crypto":8,"pBGvAp":74}],77:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/hash.js","/../node_modules/sha.js")
},{"buffer":11,"pBGvAp":74}],78:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/index.js","/../node_modules/sha.js")
},{"./sha":79,"./sha1":80,"./sha224":81,"./sha256":82,"./sha384":83,"./sha512":84,"buffer":11,"pBGvAp":74}],79:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],80:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha1.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],81:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha224.js","/../node_modules/sha.js")
},{"./hash":77,"./sha256":82,"buffer":11,"inherits":71,"pBGvAp":74}],82:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha256.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],83:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha384.js","/../node_modules/sha.js")
},{"./hash":77,"./sha512":84,"buffer":11,"inherits":71,"pBGvAp":74}],84:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/sha.js/sha512.js","/../node_modules/sha.js")
},{"./hash":77,"buffer":11,"inherits":71,"pBGvAp":74}],85:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WsRpc = require("./WebSocketRpc");
var SteemApi = require("./SteemApi");

var defaultOptions = {
    url: "wss://node.steem.ws",
    user: "",
    pass: "",
    debug: false,
    apis: ["database_api", "network_broadcast_api", "follow_api", "market_history_api", "login_api", "private_message_api"]
};

var objectAssign = require('object-assign');

var apiInstance;

module.exports = {

    reset: function reset() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        if (apiInstance) {
            this.close();
        }
        apiInstance = new ApiInstance(options);
        apiInstance.connect();

        return apiInstance;
    },

    get: function get() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
        var connect = arguments[1];

        if (!apiInstance) {
            apiInstance = new ApiInstance(options);
        }

        if (connect) {
            apiInstance.setOptions(options);
            apiInstance.connect();
        }

        return apiInstance;
    },


    close: function close() {
        apiInstance.close();apiInstance = null;
    }
};

var ApiInstance = function () {
    function ApiInstance(options) {
        _classCallCheck(this, ApiInstance);

        this.setOptions(options);
        this.statusCallback = options.statusCallback;
    }

    _createClass(ApiInstance, [{
        key: "setOptions",
        value: function setOptions(options) {
            this.options = objectAssign({}, defaultOptions, options);//Object.assign({}, defaultOptions, options);
            if (this.options.apis.indexOf("database_api") === -1) {
                this.options.apis.unshift("database_api");
            }
        }
    }, {
        key: "connect",
        value: function connect() {
            if (this.wsRpc) {
                return;
            }

            try {
                this.wsRpc = new WsRpc(this.options, this.onReconnect.bind(this), this.onStatusChange.bind(this));
                return this.login();
            } catch (err) {
                console.error("wsRpc open error:", err);
            }
        }
    }, {
        key: "login",
        value: function login() {
            var _this = this;

            return this.initPromise = this.wsRpc.login(this.options.user, this.options.pass).then(function () {
                var apiPromises = [];

                _this.options.apis.forEach(function (api) {
                    _this["_" + api] = new SteemApi(_this.wsRpc, api);
                    _this[api] = function () {
                        return this["_" + api];
                    };
                    apiPromises.push(_this["_" + api].init().then(function () {
                        if (api === "database_api") {
                            return _this[api]().exec("get_config", []).then(function (res) {
                                console.log(res.STEEMIT_CHAIN_ID);
                                _this.chainId = res.STEEMIT_CHAIN_ID;
                                return "connected to " + api;
                            });
                        } else {
                            return "connected to " + api;
                        }
                    }));
                });
                return Promise.all(apiPromises);
            }).catch(function (err) {
                // console.error("Unable to connect to", this.options.url);
                throw new Error("Unable to connect to " + _this.options.url);
            });
        }
    }, {
        key: "onReconnect",
        value: function onReconnect() {
            this.login();
        }
    }, {
        key: "onStatusChange",
        value: function onStatusChange(e) {
            if (this.statusCallback) {
                this.statusCallback(e);
            }
        }
    }, {
        key: "close",
        value: function close() {
            if (this.wsRpc) {
                this.wsRpc.close();
                this.wsRpc = null;
            }
        }
    }]);

    return ApiInstance;
}();
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/ApiInstance.js","/../node_modules/steem-rpc/lib")
},{"./SteemApi":86,"./WebSocketRpc":87,"buffer":11,"object-assign":73,"pBGvAp":74}],86:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SteemApi = function () {
	function SteemApi(wsRpc, apiName) {
		_classCallCheck(this, SteemApi);

		this.wsRpc = wsRpc;
		this.apiName = apiName;
	}

	_createClass(SteemApi, [{
		key: "init",
		value: function init() {
			var _this = this;

			return this.wsRpc.getApiByName(this.apiName).then(function (response) {
				_this.apiId = response;
				return _this;
			});
		}
	}, {
		key: "exec",
		value: function exec(method, params) {
			return this.wsRpc.call([this.apiId, method, params]).catch(function (error) {
				console.error("Api error:", method, params, JSON.stringify(error));
				var newErr = new Error("Api error:" + method + params + JSON.stringify(error));
				newErr.original = error;
				localStorage.error = 1;
				localStorage.errormessage = error.message?error.message.split("\n")[1]:'Connection lost, reconnecting...';
				throw newErr;
			});
		}
	}]);

	return SteemApi;
}();

module.exports = SteemApi;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/SteemApi.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],87:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RWebSocket = require("./reconnecting-websocket");

var WebSocketRpc = function () {
	function WebSocketRpc(options) {
		var _this = this;

		var rcCallback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
		var statusCallback = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

		_classCallCheck(this, WebSocketRpc);

		this.rcCallback = rcCallback;
		this.statusCallback = statusCallback;

		if (typeof WebSocket !== "undefined") {
			options.WebSocket = WebSocket;
			options.idleTreshold = "idleTreshold" in options ? options.idleTreshold : 60000; // Only use idle threshold in browsers
		} else {
				options.WebSocket = require("ws");
				options.idleTreshold = 0; // Always reconnect in node.js
			}
		options.reconnectInterval = 1000;
		options.reconnectDecay = 1.2;

		this.ws = new RWebSocket(options);
		this.ws.timeoutInterval = 15000;

		var initialConnect = true;

		this.connectPromise = new Promise(function (resolve, reject) {

			_this.ws.onopen = function () {
				if (_this.statusCallback) _this.statusCallback("open");
				if (initialConnect) {
					initialConnect = false;
					resolve();
				} else {
					if (_this.rcCallback) _this.rcCallback();
				}
			};

			_this.ws.onerror = function (err) {
				if (_this.statusCallback) _this.statusCallback("error");
				reject(err);
			};

			_this.ws.onmessage = function (message) {
				var data = {};
				try {
					data = JSON.parse(message.data);
				} catch (e) {
					console.log("Unable to parse API response:", e);
					data.error = "Unable to parse response " + JSON.stringify(message);
				}
				_this.listener(data);
			};

			_this.ws.onclose = function () {
				// web socket may re-connect
				_this.cbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.methodCbs.forEach(function (value) {
					value.reject('connection closed');
				});

				_this.cbs.clear();
				_this.methodCbs.clear();
				_this.cbId = 0;

				if (_this.statusCallback) _this.statusCallback("closed");
			};
		});

		this.cbId = 0;
		this.cbs = new Map();
		this.methodCbs = new Map();

		if (typeof window !== "undefined") {
			window.onbeforeunload = function () {
				_this.close();
			};
		}
	}

	_createClass(WebSocketRpc, [{
		key: "listener",
		value: function listener(message) {
			var callback = this.cbs.get(message.id);
			var methodCallback = this.methodCbs.get(message.id);

			if (methodCallback) {
				this.methodCbs.delete(message.id);
				if ("error" in message && "reject" in methodCallback) {
					methodCallback.reject(message.error);
				} else if ("resolve" in methodCallback) {
					methodCallback.resolve();
				}
			}

			if (callback) {
				this.cbs.delete(message.id);
				if ("error" in message) {
					callback.reject(message.error);
				} else {
					callback.resolve(message.result);
				}
			}
		}
	}, {
		key: "call",
		value: function call(params) {
			var _this2 = this;

			var request = {
				method: "call",
				params: params,
				id: this.cbId++
			};

			return new Promise(function (resolve, reject) {

				_this2.cbs.set(request.id, {
					time: new Date(),
					resolve: resolve,
					reject: reject
				});

				if (request.params[1] === "broadcast_transaction_with_callback" && request.params[2][0]) {
					_this2.methodCbs.set(request.id, request.params[2][0]);
					request.params[2][0] = request.params[2][0].resolve;
				}

				_this2.ws.onerror = function (error) {
					reject(error);
				};

				_this2.ws.send(JSON.stringify(request));
			});
		}
	}, {
		key: "getApiByName",
		value: function getApiByName(api) {
			return this.call([1, "get_api_by_name", [api]]);
		}
	}, {
		key: "login",
		value: function login(user, password) {
			var _this3 = this;

			return this.connectPromise.then(function () {
				return _this3.call([1, "login", [user, password]]);
			});
		}
	}, {
		key: "close",
		value: function close() {
			console.log('closing ws');
			if (this.ws) {
				this.ws.onclose();
				this.ws.close();
				this.ws = null;
			}
		}
	}]);

	return WebSocketRpc;
}();

module.exports = WebSocketRpc;
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/WebSocketRpc.js","/../node_modules/steem-rpc/lib")
},{"./reconnecting-websocket":89,"buffer":11,"pBGvAp":74,"ws":8}],88:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
"use strict";

var Client = require("./ApiInstance");

module.exports = {
	Client: Client
};
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/index.js","/../node_modules/steem-rpc/lib")
},{"./ApiInstance":85,"buffer":11,"pBGvAp":74}],89:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

// MIT License:
//
// Copyright (c) 2010-2012, Joe Walnes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * This behaves like a WebSocket in every way, except if it fails to connect,
 * or it gets disconnected, it will repeatedly poll until it successfully connects
 * again.
 *
 * It is API compatible, so when you have:
 *   ws = new WebSocket('ws://....');
 * you can replace with:
 *   ws = new ReconnectingWebSocket('ws://....');
 *
 * The event stream will typically look like:
 *  onconnecting
 *  onopen
 *  onmessage
 *  onmessage
 *  onclose // lost connection
 *  onconnecting
 *  onopen  // sometime later...
 *  onmessage
 *  onmessage
 *  etc...
 *
 * It is API compatible with the standard WebSocket API, apart from the following members:
 *
 * - `bufferedAmount`
 * - `extensions`
 * - `binaryType`
 *
 * Latest version: https://github.com/joewalnes/reconnecting-websocket/
 * - Joe Walnes
 *
 * Syntax
 * ======
 * var socket = new ReconnectingWebSocket(url, protocols, options);
 *
 * Parameters
 * ==========
 * url - The url you are connecting to.
 * protocols - Optional string or array of protocols.
 * options - See below
 *
 * Options
 * =======
 * Options can either be passed upon instantiation or set after instantiation:
 *
 * var socket = new ReconnectingWebSocket(url, null, { debug: true, reconnectInterval: 4000 });
 *
 * or
 *
 * var socket = new ReconnectingWebSocket(url);
 * socket.debug = true;
 * socket.reconnectInterval = 4000;
 *
 * debug
 * - Whether this instance should log debug messages. Accepts true or false. Default: false.
 *
 * automaticOpen
 * - Whether or not the websocket should attempt to connect immediately upon instantiation. The socket can be manually opened or closed at any time using ws.open() and ws.close().
 *
 * reconnectInterval
 * - The number of milliseconds to delay before attempting to reconnect. Accepts integer. Default: 1000.
 *
 * maxReconnectInterval
 * - The maximum number of milliseconds to delay a reconnection attempt. Accepts integer. Default: 30000.
 *
 * reconnectDecay
 * - The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. Accepts integer or float. Default: 1.5.
 *
 * timeoutInterval
 * - The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. Accepts integer. Default: 2000.
 *
 */
(function (global, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    } else {
        global.ReconnectingWebSocket = factory();
    }
})(undefined, function () {

    //if (!('WebSocket' in window)) {
    //    return;
    //}

    var WebSocket;

    function ReconnectingWebSocket(options) {

        // Default settings
        var settings = {

            /** Whether this instance should log debug messages. */
            debug: false,

            /** Whether or not the websocket should attempt to connect immediately upon instantiation. */
            automaticOpen: true,

            /** The number of milliseconds to delay before attempting to reconnect. */
            reconnectInterval: 2000,
            /** The maximum number of milliseconds to delay a reconnection attempt. */
            maxReconnectInterval: 300000,
            /** The rate of increase of the reconnect delay. Allows reconnect attempts to back off when problems persist. */
            reconnectDecay: 1.5,

            /** The maximum time in milliseconds to wait for a connection to succeed before closing and retrying. */
            timeoutInterval: 2000,

            /** The maximum number of reconnection attempts to make. Unlimited if null. */
            maxReconnectAttempts: 100,

            /** The binary type, possible values 'blob' or 'arraybuffer', default 'blob'. */
            binaryType: 'arraybuffer',

            /** Don't reconnect if idle (no user activity after idleTreshold), pass 0 to always reconnect **/
            idleTreshold: 0
        };
        if (!options) {
            options = {};
        }

        WebSocket = options.WebSocket;
        ReconnectingWebSocket.CONNECTING = WebSocket.CONNECTING;
        ReconnectingWebSocket.OPEN = WebSocket.OPEN;
        ReconnectingWebSocket.CLOSING = WebSocket.CLOSING;
        ReconnectingWebSocket.CLOSED = WebSocket.CLOSED;
        if (!console.debug) console.debug = console.log;

        // Overwrite and define settings with options if they exist.
        for (var key in settings) {
            if (typeof options[key] !== 'undefined') {
                this[key] = options[key];
            } else {
                this[key] = settings[key];
            }
        }

        // These should be treated as read-only properties

        /** The URL as resolved by the constructor. This is always an absolute URL. Read only. */
        this.url = options.url;

        /** The number of attempted reconnects since starting, or the last successful connection. Read only. */
        this.reconnectAttempts = 0;

        /**
         * The current state of the connection.
         * Can be one of: WebSocket.CONNECTING, WebSocket.OPEN, WebSocket.CLOSING, WebSocket.CLOSED
         * Read only.
         */
        this.readyState = WebSocket.CONNECTING;

        /**
         * A string indicating the name of the sub-protocol the server selected; this will be one of
         * the strings specified in the protocols parameter when creating the WebSocket object.
         * Read only.
         */
        this.protocol = null;

        // Private state variables

        var self = this;
        var ws;
        var forcedClose = false;
        var timedOut = false;
        var handlers = {};
        var eventTarget = {
            addEventListener: function addEventListener(event, handler) {
                handlers[event] = handler;
            },
            removeEventListener: function removeEventListener(event) {
                delete handlers[event];
            },
            dispatchEvent: function dispatchEvent(event) {
                var handler = handlers[event.name];
                if (handler) handler(event);
            }
        }; //document.createElement('div');

        // Wire up "on*" properties as event handlers

        eventTarget.addEventListener('open', function (event) {
            self.onopen(event);
        });
        eventTarget.addEventListener('close', function (event) {
            self.onclose(event);
        });
        eventTarget.addEventListener('connecting', function (event) {
            self.onconnecting(event);
        });
        eventTarget.addEventListener('message', function (event) {
            self.onmessage(event);
        });
        eventTarget.addEventListener('error', function (event) {
            self.onerror(event);
        });

        // Expose the API required by EventTarget

        this.addEventListener = eventTarget.addEventListener.bind(eventTarget);
        this.removeEventListener = eventTarget.removeEventListener.bind(eventTarget);
        this.dispatchEvent = eventTarget.dispatchEvent.bind(eventTarget);

        /**
         * This function generates an event that is compatible with standard
         * compliant browsers and IE9 - IE11
         *
         * This will prevent the error:
         * Object doesn't support this action
         *
         * http://stackoverflow.com/questions/19345392/why-arent-my-parameters-getting-passed-through-to-a-dispatched-event/19345563#19345563
         * @param s String The name that the event should use
         * @param args Object an optional object that the event will use
         */
        function generateEvent(s, args) {
            //var evt = document.createEvent("CustomEvent");
            //evt.initCustomEvent(s, false, false, args);
            //return evt;
            return { name: s };
        };

        self.pendingReconnect = false;
        self.idleSince = new Date();

        if (this.idleTreshold) {
            if (typeof document !== 'undefined') {
                document.onkeypress = document.onmousemove = document.onclick = document.onscroll = document.touchstart = function () {
                    self.idleSince = new Date();
                    if (self.pendingReconnect) {
                        self.pendingReconnect = false;
                        self.reconnect();
                    }
                };
            }
        }

        this.reconnect = function () {
            var timeout = self.reconnectInterval * Math.pow(self.reconnectDecay, self.reconnectAttempts);
            timeout = timeout > self.maxReconnectInterval ? self.maxReconnectInterval : timeout;
            if (self.debug) {
                console.debug('WebSocket: will try to reconnect in ' + parseInt(timeout / 1000) + ' sec, attempt #' + (self.reconnectAttempts + 1));
            }
            setTimeout(function () {
                self.reconnectAttempts++;
                self.open(true);
            }, timeout);
        };

        this.open = function (reconnectAttempt) {
            if (reconnectAttempt) {
                if (this.maxReconnectAttempts && this.reconnectAttempts > this.maxReconnectAttempts) {
                    return;
                }
            } else {
                eventTarget.dispatchEvent(generateEvent('connecting'));
                this.reconnectAttempts = 0;
            }

            var surl = self.url;
            if (Array.isArray(self.url)) {
                surl = self.url[this.reconnectAttempts % self.url.length];
            }

            if (self.debug) {
                console.debug('connecting to', surl);
            }
            ws = new WebSocket(surl);
            ws.binaryType = this.binaryType;

            if (self.debug || ReconnectingWebSocket.debugAll) {
                console.debug('ReconnectingWebSocket', 'attempt-connect', self.url);
            }

            var localWs = ws;
            var timeout = setTimeout(function () {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'connection-timeout', self.url);
                }
                timedOut = true;
                localWs.close();
                timedOut = false;
            }, self.timeoutInterval);

            ws.onopen = function (event) {
                clearTimeout(timeout);
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket**', 'onopen', self.url);
                }
                self.protocol = ws.protocol;
                self.readyState = WebSocket.OPEN;
                self.reconnectAttempts = 0;
                var e = generateEvent('open');
                e.isReconnect = reconnectAttempt;
                reconnectAttempt = false;
                eventTarget.dispatchEvent(e);
            };

            ws.onclose = function (event) {
                if (event.code !== 1000 && self.debug) console.log('WARNING! ws connection', surl, 'closed');
                clearTimeout(timeout);
                ws = null;
                if (forcedClose) {
                    self.readyState = WebSocket.CLOSED;
                    eventTarget.dispatchEvent(generateEvent('close'));
                } else {
                    self.readyState = WebSocket.CONNECTING;
                    var e = generateEvent('connecting');
                    e.code = event.code;
                    e.reason = event.reason;
                    e.wasClean = event.wasClean;
                    eventTarget.dispatchEvent(e);
                    if (!reconnectAttempt && !timedOut) {
                        if (self.debug || ReconnectingWebSocket.debugAll) {
                            console.debug('ReconnectingWebSocket', 'onclose', self.url);
                        }
                        eventTarget.dispatchEvent(generateEvent('close'));
                    }

                    if (!self.idleTreshold || new Date() - self.idleSince < self.idleTreshold) {
                        self.reconnect();
                    } else {
                        if (self.debug) {
                            console.debug('idle - will reconnect later');
                        }
                        self.pendingReconnect = true;
                    }
                }
            };
            ws.onmessage = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onmessage', self.url);
                }
                var e = generateEvent('message');
                e.data = event.data;
                eventTarget.dispatchEvent(e);
            };
            ws.onerror = function (event) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'onerror', self.url, event);
                }
                eventTarget.dispatchEvent(generateEvent(event));
            };
        };

        // Whether or not to create a websocket upon instantiation
        if (this.automaticOpen == true) {
            this.open(false);
        }

        /**
         * Transmits data to the server over the WebSocket connection.
         *
         * @param data a text string, ArrayBuffer or Blob to send to the server.
         */
        this.send = function (data) {
            if (ws) {
                if (self.debug || ReconnectingWebSocket.debugAll) {
                    console.debug('ReconnectingWebSocket', 'send', self.url, data);
                }
                return ws.send(data);
            } else {
                throw 'INVALID_STATE_ERR : Pausing to reconnect websocket';
            }
        };

        /**
         * Closes the WebSocket connection or connection attempt, if any.
         * If the connection is already CLOSED, this method does nothing.
         */
        this.close = function (code, reason) {
            // Default CLOSE_NORMAL code
            if (typeof code == 'undefined') {
                code = 1000;
            }
            forcedClose = true;
            if (ws) {
                ws.close(code, reason);
            }
        };

        /**
         * Additional public API method to refresh the connection if still open (close, re-open).
         * For example, if the app suspects bad data / missed heart beats, it can try to refresh.
         */
        this.refresh = function () {
            if (ws) {
                ws.close();
            }
        };
    }

    /**
     * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
     * this indicates that the connection is ready to send and receive data.
     */
    ReconnectingWebSocket.prototype.onopen = function (event) {};
    /** An event listener to be called when the WebSocket connection's readyState changes to CLOSED. */
    ReconnectingWebSocket.prototype.onclose = function (event) {};
    /** An event listener to be called when a connection begins being attempted. */
    ReconnectingWebSocket.prototype.onconnecting = function (event) {};
    /** An event listener to be called when a message is received from the server. */
    ReconnectingWebSocket.prototype.onmessage = function (event) {};
    /** An event listener to be called when an error occurs. */
    ReconnectingWebSocket.prototype.onerror = function (event) {};

    /**
     * Whether all instances of ReconnectingWebSocket should log debug messages.
     * Setting this to true is the equivalent of setting all instances of ReconnectingWebSocket.debug to true.
     */
    ReconnectingWebSocket.debugAll = false;

    return ReconnectingWebSocket;
});
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/steem-rpc/lib/reconnecting-websocket.js","/../node_modules/steem-rpc/lib")
},{"buffer":11,"pBGvAp":74}],90:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/duplex.js","/../node_modules/stream-browserify")
},{"./readable.js":94,"./writable.js":96,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":92}],91:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/index.js","/../node_modules/stream-browserify")
},{"./duplex.js":90,"./passthrough.js":93,"./readable.js":94,"./transform.js":95,"./writable.js":96,"buffer":11,"events":69,"inherits":71,"pBGvAp":74}],92:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/node_modules/process/browser.js","/../node_modules/stream-browserify/node_modules/process")
},{"buffer":11,"pBGvAp":74}],93:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/passthrough.js","/../node_modules/stream-browserify")
},{"./transform.js":95,"buffer":11,"inherits":71,"pBGvAp":74}],94:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/readable.js","/../node_modules/stream-browserify")
},{"./index.js":91,"buffer":11,"events":69,"inherits":71,"pBGvAp":74,"process/browser.js":92,"string_decoder":9}],95:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/transform.js","/../node_modules/stream-browserify")
},{"./duplex.js":90,"buffer":11,"inherits":71,"pBGvAp":74}],96:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/stream-browserify/writable.js","/../node_modules/stream-browserify")
},{"./index.js":91,"buffer":11,"inherits":71,"pBGvAp":74,"process/browser.js":92}],97:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/node_modules/inherits/inherits_browser.js","/../node_modules/util/node_modules/inherits")
},{"buffer":11,"pBGvAp":74}],98:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/support/isBufferBrowser.js","/../node_modules/util/support")
},{"buffer":11,"pBGvAp":74}],99:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/util/util.js","/../node_modules/util")
},{"./support/isBuffer":98,"buffer":11,"inherits":97,"pBGvAp":74}],100:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
require('./posts')
//require('steemjs-lib')

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_cc388a33.js","/")
},{"./posts":103,"buffer":11,"pBGvAp":74}],101:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
	app.constant('API_END_POINT','http://api.esteem.ws:8080');
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/config.js","/posts")
},{"buffer":11,"pBGvAp":74}],102:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = function (app) {
//angular.module('steem.controllers', [])

app.controller('AppCtrl', function($scope, $ionicModal, $timeout, $rootScope, $state, $ionicHistory, $cordovaSocialSharing, ImageUploadService, $cordovaCamera, $ionicSideMenuDelegate, $ionicPlatform, $filter, APIs, $window, $ionicPopover) {

  $scope.loginData = {};

  $ionicModal.fromTemplateUrl('templates/login.html', {
    scope: $scope  }).then(function(modal) {
    $scope.loginModal = modal;
  });

  $ionicPopover.fromTemplateUrl('templates/popover.html', {
    scope: $scope,
  }).then(function(popover) {
    $scope.menupopover = popover;
  });

  $scope.openMenuPopover = function($event) {
    $scope.menupopover.show($event);
  };
  $scope.closeMenuPopover = function() {
    $scope.menupopover.hide();
  };

  $rootScope.$on('close:popover', function(){
    console.log('close:popover');
    $scope.menupopover.hide();

    $ionicHistory.nextViewOptions({
      disableBack: true
    });
    //$scope.closeMenuPopover();
    //$scope.fetchPosts();
  });

  $scope.$on('$destroy', function() {
    $scope.menupopover.remove();
  });

  $scope.changeUsername = function(){
    $scope.loginData.username = angular.lowercase($scope.loginData.username);
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  }
  $scope.open = function(item) {
    item.json_metadata = angular.fromJson(item.json_metadata);
    $rootScope.$storage.sitem = item;
    //console.log(item);

    //$state.go('app.single');*/
    $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});
  };

  $rootScope.$on('openComments', function(e, args) {
    $scope.open(args.data);
  });


  $scope.advancedChange = function() {
    $rootScope.log(angular.toJson($scope.loginData.advanced));
    if ($scope.loginData.advanced) {
      $scope.loginData.password = null;
    }
  }
  $scope.closeLogin = function() {
    $scope.loginModal.hide();
  };
  
  $scope.openSignUP = function() {
    $scope.chainurl = $rootScope.$storage.chain=='steem'?'https://steemit.com/create_account':'https://golos.io/create_account';
    window.open($scope.chainurl, '_blank', 'location=yes');
    return false;  
  }
  $scope.openLogin = function() {
    if ($rootScope.$storage.language == 'ru-RU') {
      $scope.loginData.chain = "golos";
    } else {
      $scope.loginData.chain = "steem";
    }
    setTimeout(function() {
      $scope.loginModal.show();
    }, 1);
  };
  $scope.goProfile = function() {
    $state.go("app.profile", {username:$rootScope.$storage.user.username});
    //$ionicSideMenuDelegate.toggleLeft();
  }
  $scope.share = function() {
    var host = "";
    if ($rootScope.$storage.chain == 'steem') {
      host = "https://steemit.com/";
    } else {
      host = "https://golos.io/";
    }
    var link = host+$rootScope.$storage.sitem.category+"/@"+$rootScope.$storage.sitem.author+"/"+$rootScope.$storage.sitem.permlink;
    var message = "Hey! Checkout blog post on Steem "+link;
    var subject = "Via eSteem Mobile";
    var file = null;
    $cordovaSocialSharing.share(message, subject, file, link) // Share via native share sheet
    .then(function(result) {
      // Success!
      $rootScope.log("shared");
    }, function(err) {
      // An error occured. Show a message to the user
      $rootScope.log("not shared");
    });
  }


  $scope.loginChain = function(x){
    console.log(x);
    $scope.loginData.chain = x;

  }
  
  $scope.doLogin = function() {
    $rootScope.log('Doing login');
    if ($scope.loginData.password || $scope.loginData.privatePostingKey) {
      $rootScope.$broadcast('show:loading');
      $scope.loginData.username = $scope.loginData.username.trim();
      console.log('doLogin'+$scope.loginData.username+$scope.loginData.password);
      
      if ($scope.loginData.chain !== $rootScope.$storage.chain) {
        window.Api.close();
        window.Api = null;
        window.steemRPC.Client.close();
        
        var socketUrl = $rootScope.$storage["socket"+$scope.loginData.chain];
        //console.log(socketUrl);

        window.Api = window.steemRPC.Client.get({url:socketUrl}, true);
      }
      setTimeout(function() {
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_accounts", [[$scope.loginData.username]]).then(function(dd){
            dd = dd[0];
            console.log(dd);
            $scope.loginData.id = dd.id;
            $scope.loginData.owner = dd.owner;
            $scope.loginData.active = dd.active;
            $scope.loginData.reputation = dd.reputation;
            $scope.loginData.posting = dd.posting;
            $scope.loginData.memo_key = dd.memo_key;
            $scope.loginData.post_count = dd.post_count;
            $scope.loginData.voting_power = dd.voting_power;
            $scope.loginData.witness_votes = dd.witness_votes;
            $scope.login = new window.ejs.Login();
            $scope.login.setRoles(["posting"]);
            
            var loginSuccess = $scope.login.checkKeys({
                accountName: $scope.loginData.username,
                password: $scope.loginData.password || null,
                auths: {
                    posting: dd.posting.key_auths
                },
                privateKey: $scope.loginData.privatePostingKey || null
              }
            );

            if (!loginSuccess) {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('PASSWORD_INCORRECT'));
            } else {
              $rootScope.$storage.user = $scope.loginData;
              $scope.loginData = {};
              var found = false;

              if ($rootScope.$storage.users.length>0){
                for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
                  var v = $rootScope.$storage.users[i];
                  if (v.username == $rootScope.$storage.user.username && v.chain == $rootScope.$storage.user.chain){
                    found = true;
                  }
                }
              }
              if (found) {

              } else {
                $rootScope.$storage.users.push($rootScope.$storage.user);  
              }
              $rootScope.$storage.mylogin = $scope.login;
              APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, {device: ionic.Platform.platform(), timestamp: $filter('date')(new Date(), 'medium'), appversion: $rootScope.$storage.appversion}).then(function(res){
                $rootScope.$broadcast('hide:loading');
                
                $scope.loginModal.hide();
                $rootScope.$broadcast('refreshLocalUserData');
                  
                if ($rootScope.$storage.chain !== $rootScope.$storage.user.chain) {
                  $rootScope.$storage.chain = $rootScope.$storage.user.chain;  
                  $rootScope.$broadcast('changedChain');
                  $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
                }

                setTimeout(function() {
                  //$window.location.reload(true);
                  $state.go('app.posts',{renew:true},{reload: true});
                  $rootScope.$broadcast('fetchPosts');
                }, 1000);

              });
            }
            /*if(!$scope.$$phase) {
              $scope.$apply();
            }*/
          });
        });
      }, 500);
      
    } else {
      $scope.loginModal.hide();
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_FAIL'));
    }
  };

  $scope.selectAccount = function(user) {
    $rootScope.$storage.user = user;
    $ionicHistory.nextViewOptions({
      disableBack: true
    });
    if ($rootScope.$storage.chain !== user.chain) {
      $scope.data = {};
      $rootScope.$storage.chain = user.chain;  
      $rootScope.$broadcast('changedChain');
    }
    setTimeout(function() {
      $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
    
      $rootScope.$broadcast('refreshLocalUserData');  
    }, 100);
    
    
    setTimeout(function() {
      //$window.location.reload(true);
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
      $state.go('app.posts',{renew:true},{reload: true});
    }, 500);
  }

  $rootScope.$on('refreshLocalUserData', function() {
    $rootScope.log('refreshLocalUserData');
    if ($rootScope.$storage.user && $rootScope.$storage.user.username && $rootScope.$storage.user.chain == $rootScope.$storage.chain) {
      window.Api.initPromise.then(function(response) {
        if (typeof window.Api.database_api === "function") {
          window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
            dd = dd[0];
            if (dd && dd.json_metadata) {
              dd.json_metadata = angular.fromJson(dd.json_metadata);
            }
            angular.merge($rootScope.$storage.user, dd);

            $scope.mcss = ($rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
            
            if (!$scope.$$phase) {
              $scope.$apply();
            }
            if (!$rootScope.$$phase) {
              $rootScope.$apply();
            }
          });
        }
      });
    }
  })

  $scope.openPostModal = function() {
    $state.go('app.posts');
    $rootScope.$broadcast('openPostModal');
  }

  $scope.changeView = function(view) {
    $rootScope.$storage.view = view;
    $rootScope.$broadcast('changeView');
  }
  $scope.changeLight = function(light) {
    $rootScope.$storage.theme = light;
    $rootScope.$broadcast('changeLight');
  }

  $scope.$on("$ionicView.enter", function(){
    $rootScope.$broadcast('refreshLocalUserData');
    $scope.theme = $rootScope.$storage.theme;
  });

  // get app version
  $ionicPlatform.ready(function(){
    if (window.cordova) {
      cordova.getAppVersion.getVersionNumber(function (version) {
        $rootScope.$storage.appversion = version;
      });
    } else {
      $rootScope.$storage.appversion = '1.4.1';
    }
  });

  $scope.logout = function() {
    for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
      var v = $rootScope.$storage.users[i];
      if (v.chain == $rootScope.$storage.user.chain && v.username == $rootScope.$storage.user.username) {
        $rootScope.$storage.users.splice(i,1);
      }
    };
    if ($rootScope.$storage.users.length>1) {
      $rootScope.$storage.user = $rootScope.$storage.users[0];
    } else {
      $rootScope.$storage.user = undefined;
      $rootScope.$storage.user = null;
      $rootScope.$storage.mylogin = undefined;
      $rootScope.$storage.mylogin = null;
    }
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        //$window.location.reload(true);
        $state.go('app.posts',{renew:true},{reload: true});
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      //$window.location.reload(true);
      $state.go('app.posts',{renew:true},{reload: true});
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
  };
  $scope.data = {};
  $ionicModal.fromTemplateUrl('templates/search.html', {
    scope: $scope,
    animation: 'slide-in-down'
  }).then(function(modal) {
    $scope.smodal = modal;
  });

  // Triggered in the login modal to close it
  $scope.closeSmodal = function() {
    $scope.smodal.hide();
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  // Open the login modal
  $scope.openSmodal = function() {
    //if(!$scope.smodal) return;
    $rootScope.$broadcast('close:popover');
    setTimeout(function() {
      $scope.data.type="tag";
      $scope.data.searchResult = [];
      $scope.smodal.show();
    }, 5);
  };
  $scope.clearSearch = function() {
    if ($rootScope.$storage.tag) {
      $rootScope.$storage.tag = undefined;
      $rootScope.$storage.taglimits = undefined;
      $rootScope.$broadcast('close:popover');
      $rootScope.$broadcast('fetchPosts');
    }
  };
  $scope.showMeExtra = function() {
    if ($scope.showExtra) {
      $scope.showExtra = false;
    } else {
      $scope.showExtra = true;
    }
  }
  $scope.search = function() {
    $rootScope.log('Doing search '+$scope.data.search);
    $scope.data.search = angular.lowercase($scope.data.search);
    setTimeout(function() {
      if ($scope.data.search.length > 1) {
        if ($scope.data.type == "tag"){
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("get_trending_tags", [$scope.data.search, 15]).then(function(result){
              var ee = [];
              //console.log(result);
              /*if (result){
                var ll = result.length;
                for (var i = ll - 1; i >= 0; i--) {
                  if (result[i].name.indexOf($scope.data.search) > -1){
                    ee.push(result[i]);
                  }
                }
                $scope.data.searchResult = ee;
              }*/
              $scope.data.searchResult = result;

              if (!$scope.$$phase) {
                $scope.$apply();
              }
            });
          });
        }
        if ($scope.data.type == "user"){
          var ee = [];
          window.Api.initPromise.then(function(response) {
            window.Api.database_api().exec("lookup_accounts", [$scope.data.search, 15]).then(function(result){
              if (result){
                $scope.data.searchResult = result;
              }

                if (!$scope.$$phase) {
                  $scope.$apply();
                }
            });
          });
        }

      }
    }, 5);

  };
  $scope.typechange = function() {
    $scope.data.searchResult = undefined;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $rootScope.log("changing search type");
  }
  $scope.openTag = function(xx, yy) {
    $rootScope.log("opening tag "+xx);
    $rootScope.$storage.tag = xx;
    $rootScope.$storage.filter = 'created';
    $rootScope.$storage.taglimits = yy;
    if ($scope.smodal.isShown()){
      $scope.closeSmodal();
    }
    $rootScope.$broadcast('close:popover');
    //$rootScope.$broadcast('filter:change');
    $state.go("app.posts", {tags: xx});
  };
  $scope.openUser = function(xy) {
    $rootScope.log("opening user "+xy);
    $scope.closeSmodal();
    $rootScope.$broadcast('close:popover');
    $state.go("app.profile", {username: xy});
  };
  $scope.testfunction = function() {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_account_history", [$rootScope.$storage.user.username, -1, 25]).then(function(response){
        $rootScope.log(angular.toJson(response));
      });
    });
  }

})

app.controller('SendCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $filter, $q, $timeout, $cordovaBarcodeScanner, $ionicPlatform, $ionicModal, APIs) {

  if ($rootScope.$storage.chain == "steem") {
    $scope.data = {types: [{type: "steem", name:"Steem", id:1},{type: "sbd", name:"Steem Dollar", id:2}, {type: "sp", name:"Steem Power", id:3}], type: "steem", amount: 0.001, etypes: [{type: "approve", name: $filter('translate')("APPROVE"), id:1},{type: "dispute", name: $filter('translate')("DISPUTE"), id:2},{type: "release", name: $filter('translate')("RELEASE"), id:3}]};
  } else {
    $scope.data = {types: [{type: "golos", name: "", id:1},{type: "gbg", name:"", id:2}, {type: "golosp", name:" ", id:3}], type: "golos", amount: 0.001, etypes: [{type: "approve", name: $filter('translate')("APPROVE"), id:1},{type: "dispute", name: $filter('translate')("DISPUTE"), id:2},{type: "release", name: $filter('translate')("RELEASE"), id:3}]};
  }
  $scope.ttype = 'transfer';
  $scope.changeTransfer = function(type){
    $scope.ttype = type;
    $scope.data.advanced = false;
  }
  $ionicModal.fromTemplateUrl('my-modal.html', {
    scope: $scope,
    animation: 'slide-in-up'
  }).then(function(modal) {
    $scope.modal = modal;
  });
  $scope.openUModal = function() {
    $scope.modal.show();
  };
  $scope.closeUModal = function() {
    $scope.modal.hide();
  };
  // Cleanup the modal when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.modal.remove();
  });
  // Execute action on hide modal
  $scope.$on('modal.hidden', function() {
    // Execute action
  });
  $scope.showLiquid = function (token) {
    return token.type !== $filter('lowercase')($rootScope.$storage.platformpunit);
  }
  $scope.searchUser = function(query) {
    return window.Api.initPromise.then(function(response) {
      return window.Api.database_api().exec("lookup_accounts", [query, 15]).then(function(response){
        return response;
      });
    });
  }
  $scope.selectAgent = function(agent) {
    $scope.data.agent = agent;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.closeUModal();
  }
  $scope.getUserAgent = function(query){
    query = angular.lowercase(query);
    $scope.res = [];
    if (query) {
      window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("lookup_account_names", [[query]]).then(function(response){
        //console.log(response)
        var dd = response[0];
        if (dd && dd.json_metadata) {
          var vv = angular.fromJson(dd.json_metadata);
          if (vv.escrow) {
            console.log('escrow');
            $scope.res.push({name: query, escrow: vv.escrow});
          } else {
            console.log('noescrow');
            $scope.res.push({name: query, escrow: {terms: "-", fees: {"STEEM": 0.001, "SBD": 0.001, "GBG": 0.001, "GOLOS": 0.001}} });
          }
        }
      });
      });
      setTimeout(function() {
        if (query && $scope.res) {
          $scope.data.searchResult = $scope.res;
        } else {
          $scope.data.searchResult = [];  
        }
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      }, 500);   
    }
  }
  $scope.changeUsername = function(typed) {
    $rootScope.log('searching');
    $scope.data.username = angular.lowercase($scope.data.username);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("lookup_account_names", [[$scope.data.username]]).then(function(response){
        $scope.users = response[0];
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.qrScan = function() {
    $ionicPlatform.ready(function() {
      $cordovaBarcodeScanner.scan({
          "preferFrontCamera" : false, // iOS and Android
          "showFlipCameraButton" : false, // iOS and Android
          "prompt" : $filter('translate')('QR_TEXT'), // supported on Android only
          "formats" : "QR_CODE" // default: all but PDF_417 and RSS_EXPANDED
          //"orientation" : "landscape" // Android only (portrait|landscape), default unset so it rotates with the device
        }).then(function(barcodeData) {
        //alert(barcodeData);
        if (barcodeData.text.indexOf('?amount')>-1) {
          //steem dollar:blocktrades?amount=12.080

          $scope.data.username = barcodeData.text.split(':')[1].split('?')[0].trim();
          $scope.data.amount = Number(barcodeData.text.split('=')[1]);
          if (barcodeData.text.split(':')[0]==='steem dollar') {
            $scope.data.type = 'sbd';
          }
          if (barcodeData.text.split(':')[0]==='steem') {
            $scope.data.type = 'steem';
          }
          if (barcodeData.text.split(':')[0]==='steem power') {
            $scope.data.type = 'sp';
          }

        } else {
          $scope.data.username = barcodeData.text;
        }
        $scope.changeUsername();
      }, function(error) {
        $rootScope.showMessage('Error',angular.toJson(error));
      });
    });
  };
  $scope.advancedEChange = function(){
    console.log('advancedEChange', $scope.data.advanced);
    $scope.data.etype = "";
    $scope.escrow = {};
    if (!$scope.$$phase){
      $scope.$apply();
    }
  }
  $scope.actionEChange = function(){
    console.log('actionEChange', $scope.data.etype);
    if (!$scope.$$phase){
      $scope.$apply();
    }
  }

  $scope.escrowAction = function(){
    console.log($scope.data.etype);
    if ($scope.data.etype && $scope.escrow.escrow_id) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('CONFIRMATION'),
        template: ""
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          $rootScope.$broadcast('show:loading');

          var mylogin = new window.ejs.Login();
          mylogin.setRoles(["active"]);
          var loginSuccesss = mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password,
              auths: {
                active: $rootScope.$storage.user.active.key_auths
              },
              privateKey: $rootScope.$storage.user.privateActiveKey || null
            }
          );
          if (loginSuccesss) {
            var tre = new window.ejs.TransactionBuilder();
            if ($scope.data.etype == "approve") {
              tre.add_type_operation("escrow_approve", { 
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id,
                approve: true
              });
            } else if ($scope.data.etype == "dispute") {
              tre.add_type_operation("escrow_dispute", { 
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id
              });
            } else if ($scope.data.etype == "release") {
              tre.add_type_operation("escrow_release", {
                from: $scope.escrow.from,
                to: $scope.escrow.to,
                agent: $scope.escrow.agent,
                who: $rootScope.$storage.user.username,
                escrow_id: $scope.escrow.escrow_id,
                receiver: $scope.escrow.receiver,
                sbd_amount: $scope.escrow.sbd_amount+" "+angular.uppercase($rootScope.$storage.platformdunit),
                steem_amount: $scope.escrow.steem_amount+" "+angular.uppercase($rootScope.$storage.platformlunit) 
              });
            }
            
            localStorage.error = 0;
            tre.process_transaction(mylogin, null, true);  

            setTimeout(function() {
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
              } else {
                $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                  $scope.data.type=$rootScope.$storage.chain;
                  $scope.data.amount= 0.001;
                });
              }
            }, 3000);
          }
        }
      });
    } 
  }
  $scope.escrow = {};
  $scope.searchEscrowID = function(id){
    if (id.length>3){
      APIs.searchEscrow(id).then(function(res){
        //console.log(res.data);
        $scope.escrow = res.data[0];
        $scope.escrow.json_meta = angular.fromJson($scope.escrow.json_meta);
      });  
    }
  }
  $scope.transfer = function (type) {
    if ($rootScope.$storage.user) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('ACTIVE_KEY_REQUIRED_TEXT'));
      } else {
        if ($scope.data.type === 'sbd' || $scope.data.type === 'gbg') {
          if ($scope.data.amount > Number($scope.balance.sbd_balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if ($scope.data.type === 'sp' || $scope.data.type === 'steem' || $scope.data.type === 'golos' || $scope.data.type === 'golosp') {
          if ($scope.data.amount > Number($scope.balance.balance.split(" ")[0])) {
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('BALANCE_TEXT'));
          } else {
            $scope.okbalance = true;
          }
        }
        if (!$scope.users || $scope.users.name !== $scope.data.username) {
          $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('NONEXIST_USER'));
        } else {
          $scope.okuser = true;
        }
        if ($scope.okbalance && $scope.okuser) {
          var confirmPopup = $ionicPopup.confirm({
            title: $filter('translate')('CONFIRMATION'),
            template: $filter('translate')('TRANSFER_TEXT')
          });

          confirmPopup.then(function(res) {
            if(res) {
              $rootScope.log('You are sure');
              $rootScope.$broadcast('show:loading');
              
              if (type == 'transfer') {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  //transfer
                  if ($scope.data.type !== 'sp' && $scope.data.type !== 'golosp') {
                    var tt = $filter('number')($scope.data.amount, 3) +" "+angular.uppercase($scope.data.type);
                    tr.add_type_operation("transfer", {
                      from: $rootScope.$storage.user.username,
                      to: $scope.data.username,
                      amount: tt,
                      memo: $scope.data.memo || ""
                    });
                    localStorage.error = 0;
                    tr.process_transaction($scope.mylogin, null, true);
                    setTimeout(function() {
                      if (localStorage.error == 1) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                      } else {
                        $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                          $scope.data.type=$rootScope.$storage.chain;
                          $scope.data.amount= 0.001;
                        });
                      }
                    }, 3000);
                  } else {
                    var tt = $filter('number')($scope.data.amount, 3) + " "+$filter('uppercase')($rootScope.$storage.chain);
                    tr.add_type_operation("transfer_to_vesting", {
                      from: $rootScope.$storage.user.username,
                      to: $scope.data.username,
                      amount: tt
                    });
                    localStorage.error = 0;
                    tr.process_transaction($scope.mylogin, null, true);
                    setTimeout(function() {
                      if (localStorage.error == 1) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                      } else {
                        $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED')).then(function(){
                          $scope.data.type=$rootScope.$storage.chain;
                          $scope.data.amount= 0.001;
                        });
                      }
                    }, 3000);
                  }
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              }

              if (type == 'escrow') {
                console.log($rootScope.$storage.user.active.key_auths, $rootScope.$storage.user.password, $rootScope.$storage.user.privateActiveKey);

                var mylogin = new window.ejs.Login();
                mylogin.setRoles(["active"]);
                var loginSuccesss = mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccesss) {
                  var tre = new window.ejs.TransactionBuilder();
                  var escrow_id = (new Date().getTime())>>>0;
                  var tt = $filter('number')($scope.data.amount, 3) +" "+angular.uppercase($scope.data.type);
                  var sbd = ($scope.data.type=='sbd'||$scope.data.type=='gbg')?tt:("0.000 "+angular.uppercase($rootScope.$storage.platformdunit));
                  var stem = ($scope.data.type=='steem'||$scope.data.type=='golos')?tt:("0.000 "+angular.uppercase($rootScope.$storage.platformlunit));
                  var fe = $scope.data.agent.escrow.fees[angular.uppercase($scope.data.type)]+" "+angular.uppercase($scope.data.type);
                  var rt = new Date($scope.data.ratification);
                  var et = new Date($scope.data.expiration);
                  var jn = {
                    terms: $scope.data.agent.escrow.terms, 
                    memo: ($scope.data.memo||"")+" "+escrow_id
                  }
                  tre.add_type_operation("escrow_transfer", { 
                    from: $rootScope.$storage.user.username, 
                    to: $scope.data.username, 
                    agent: $scope.data.agent.name, 
                    escrow_id: escrow_id, 
                    sbd_amount: sbd, 
                    steem_amount: stem, 
                    fee: fe, 
                    ratification_deadline: rt, 
                    escrow_expiration: et, 
                    json_meta: angular.toJson(jn) 
                  });

                  localStorage.error = 0;

                  //tre.process_transaction($scope.mylogin, null, true);
                  //mylogin.signTransaction(tre);
                  
                  tre.process_transaction(mylogin, null, true);  
                  
                  
                  /*tre.finalize().then(function() {
                      tre.sign();
                      console.log('signed');
                      tre.broadcast(true);
                      console.log('broadcasted');
                  });*/


                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
                    } else {
                      $rootScope.showAlert($filter('translate')('INFO'), $filter('translate')('TX_BROADCASTED') + " "+$filter('translate')('ESCROW')+" "+$filter('translate')('ID')+": "+escrow_id).then(function(){
                        $scope.data.type=$rootScope.$storage.chain;
                        $scope.data.amount= 0.001;
                      });
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              }
              $rootScope.$broadcast('hide:loading');
             } else {
               $rootScope.log('You are not sure');
             }
          });
        }
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  };


  $scope.refresh = function() {
    $rootScope.$broadcast('show:loading');
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        console.log($scope.balance);
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
    $rootScope.$broadcast('hide:loading');
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [ [ $rootScope.$storage.user.username ] ]).then(function(dd){
        $scope.balance = dd[0];
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    });
  });

});
app.controller('PostsCtrl', function($scope, $rootScope, $state, $ionicPopup, $ionicPopover, $interval, $ionicScrollDelegate, $ionicModal, $filter, $stateParams, $ionicSlideBoxDelegate, $ionicActionSheet, $ionicPlatform, $cordovaCamera, ImageUploadService, $filter, $ionicHistory, $timeout, APIs, $translate) {

  var formatToPercentage = function (value) {
    return value + '%';
  };

  $scope.pslider = {
    value: $rootScope.$storage.voteWeight/100,
    options: {
      floor: 1,
      ceil: 100,
      hideLimitLabels: true
      //translate: formatToPercentage,
      //showSelectionBar: true,
    }
  };

  $ionicPopover.fromTemplateUrl('popoverSlider.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSlider.show($event);
  };
  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.votePostS = function() {
    $scope.tooltipSlider.hide();
    $scope.votePost($scope.votingPost);
  }
  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }


  $rootScope.$on('filter:change', function() {
    //$rootScope.$broadcast('show:loading');
    $rootScope.log($rootScope.$storage.filter);
    var type = $rootScope.$storage.filter || "trending";
    var tag = $rootScope.$storage.tag || "";
    console.log(type, $scope.limit, tag);
    $scope.fetchPosts(type, $scope.limit, tag);
  });

  $scope.filterChanged = function(t) {
    var fil = $scope.mymenu[t].custom;
    $rootScope.$storage.filter = fil;
    for (var i = 0, len = $scope.mymenu.length; i < len; i++) {
      var v = $scope.mymenu[i];
      if (v.custom == fil) {
        $rootScope.$storage.filterName = v.text;
      }
    }
    $scope.data = [];
    $scope.error = false;
    $rootScope.$broadcast('filter:change');
  }
  $scope.showFilter = function() {
    var filterSheet = $ionicActionSheet.show({
     buttons: $scope.mymenu,
     titleText: $filter('translate')('SORT_POST_BY'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.filterChanged(index);
        return true;
     }
    });
  }

  $ionicPopover.fromTemplateUrl('popoverT.html', {
      scope: $scope
  }).then(function(popover) {
    $scope.tooltip = popover;
  });

  $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.tooltip.show($event);
  };

  $scope.closeTooltip = function() {
      $scope.tooltip.hide();
  };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
      $scope.tooltipText = undefined;
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $ionicModal.fromTemplateUrl('templates/story.html', { scope: $scope  }).then(function(modal) {
      $scope.modalp = modal;
  });
  $scope.lastFocused;

  $rootScope.$on('openPostModal', function() {

    $rootScope.$broadcast('close:popover');

    $scope.spost = $rootScope.$storage.spost || $scope.spost;

    

    $timeout(function(){
      if (!$scope.spost.operation_type) {
        $scope.spost.operation_type = 'default';
      }
      $scope.tagsChange();

      $scope.modalp.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        //console.log(document);
      });*/
    }, 10);
    //$scope.modalp.show();
  });

  $rootScope.$on('closePostModal', function() {
    $scope.modalp.hide();
  });

  $scope.closePostModal = function() {
    //$scope.$broadcast('close:popover');
    $scope.modalp.hide();
  };


  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    //console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }


  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};

    if (type == 0 || type == 1) {
      options = {
        quality: 50,
        destinationType: Camera.DestinationType.FILE_URI,
        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
        allowEdit: (type===0)?true:false,
        encodingType: Camera.EncodingType.JPEG,
        popoverOptions: CameraPopoverOptions,
        saveToPhotoAlbum: false
        //correctOrientation:true
      };
      $cordovaCamera.getPicture(options).then(function(imageData) {
        setTimeout(function() {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var final = " ![image](" + url + ")";
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, 10);
      }, function(err) {
        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
      });
    } else if (type == 2){
      $ionicPopup.prompt({
        title: $filter('translate')('SET_URL'),
        template: $filter('translate')('DIRECT_LINK_PICTURE'),
        inputType: 'text',
        inputPlaceholder: 'http://example.com/image.jpg'
      }).then(function(res) {
        $rootScope.log('Your url is' + res);
        if (res) {
          var url = res.trim();
          var final = " ![image](" + url + ")";
          /*if ($scope.spost.body) {
            $scope.spost.body += final;
          } else {
            $scope.spost.body = final;
          }*/
          $scope.insertText(final);
        }
      });
    } else {
      $scope.gallery = [];
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        var imgs = res.data;
        if (imgs.length>0){
          $scope.showgallery = true;
          $scope.gallery.images = imgs;
        } else {
          $scope.showgallery = false;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
          console.log('no images available')
        }
      });
    }
  };
  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $rootScope.$broadcast('closePostModal');
    $state.go('app.images');
  }
  function slug(text) {
    return getSlug(text, {truncate: 128});
  };
  function createPermlink(title) {
    var permlink;
    var t = new Date();
    var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
    if (title && title.trim() !== '') {
      var s = slug(title);
      permlink = s.toString()+"-"+timeformat;
      if(permlink.length > 255) {
        // STEEMIT_MAX_PERMLINK_LENGTH
        permlink = permlink.substring(permlink.length - 255, permlink.length)
      }
      // only letters numbers and dashes shall survive
      permlink = permlink.toLowerCase().replace(/[^a-z0-9-]+/g, '')
      return permlink;
    }
  };
  //$scope.operation_type = 'default';
  $scope.spost = {};
  $scope.tagsChange = function() {
    $rootScope.log("tagsChange");
    $scope.spost.tags = $filter('lowercase')($scope.spost.tags);
    $scope.spost.category = $scope.spost.tags?$scope.spost.tags.split(" "):[];
    for (var i = 0, len = $scope.spost.category.length; i < len; i++) {
      var v = $scope.spost.category[i];
      if(/^[-]/.test(v)) {
        v = 'ru--' + $filter('detransliterate')(v, true);
        $scope.spost.category[i] = v;
      }
    }

    //console.log($scope.spost.category);
    if ($scope.spost.category.length > 5) {
      $scope.disableBtn = true;
    } else {
      $scope.disableBtn = false;
    }
  }
  $scope.contentChanged = function (editor, html, text) {
    //console.log($scope.spost.body);
    //console.log('editor: ', editor, 'html: ', html, 'text:', text);
  };

  $scope.submitStory = function() {
    //console.log($scope.spost.body);
    $scope.tagsChange();
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($rootScope.$storage.user) {
      $scope.mylogin = new window.ejs.Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window.ejs.TransactionBuilder();
        var permlink = createPermlink($scope.spost.title);
        var json = $filter("metadata")($scope.spost.body);
        angular.merge(json, {tags: $scope.spost.category, app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });

        if (!$scope.spost.operation_type) {
          $scope.spost.operation_type = 'default';
        }
        if ($scope.spost.operation_type !== 'default') {
          //console.log('NOT Default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            max_accepted_payout: $scope.spost.operation_type==='sp'?"1000000.000 "+$rootScope.$storage.platformdunit:"0.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: $scope.spost.operation_type==='sp'?0:10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
        } else {
          //console.log('default');
          tr.add_type_operation("comment", {
            parent_author: "",
            parent_permlink: $scope.spost.category[0],
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            title: $scope.spost.title,
            body: $scope.spost.body,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: permlink,
            max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: 10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
        }

        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();
            $rootScope.$broadcast('closePostModal');

            //$scope.menupopover.hide();
            $rootScope.$broadcast('close:popover');
            $scope.spost = {};
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closeMenuPopover();
            $state.go("app.profile", {username: $rootScope.$storage.user.username});
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.savePost = function() {
    console.log($scope.modalp);
    $rootScope.$storage.spost = $scope.spost;
    //adddraft
    var dr = {title:$scope.spost.title, body: $scope.spost.body, tags: $scope.spost.tags, post_type: $scope.spost.operation_type};
    APIs.addDraft($rootScope.$storage.user.username, dr).then(function(res){
      console.log(res.data);
      //$scope.drafts = res.data;
    });
    $rootScope.$broadcast('closePostModal');
    $rootScope.$broadcast('close:popover');
    $scope.modalp.hide();
    $rootScope.showMessage($filter('translate')('SAVED'), $filter('translate')('POST_LATER'));
  }
  $scope.clearPost = function() {
    $rootScope.$storage.spost = {};
    $scope.spost = {};
    $rootScope.showMessage($filter('translate')('CLEARED'), $filter('translate')('POST'));
  }


  $rootScope.$on('fetchPosts', function(){
    $scope.fetchPosts();
  });

  $rootScope.$on('fetchContent', function(event, args) {
    var post = args.any;
    //console.log(post);
    $scope.fetchContent(post.author, post.permlink);
  });

  $scope.votePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'fetchContent');
    if (!$scope.$$phase) {
      $scope.$apply();
    }
  };

  $scope.downvotePost = function(post) {

    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'fetchContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });

  };

  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'fetchContent');
  };


  $rootScope.$on("user:logout", function(){
    $scope.fetchPosts();
    $rootScope.$broadcast('filter:change');
  });

  $scope.loadMore = function() {
    //$rootScope.$broadcast('show:loading');
    $scope.limit += 5;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    //}
  };
  $scope.refresh = function(){
    $scope.limit = 10;
    //if (!$scope.error) {
    $scope.fetchPosts(null, $scope.limit, null);
    $scope.$broadcast('scroll.refreshComplete');
  }

  $scope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {
    console.log('stateChangeSuccess', $stateParams.renew);
    if (from.name == 'app.posts' && to.name == 'app.post') {

    } else {
      if (from.name == 'app.post' && to.name == 'app.posts') {
        $rootScope.$storage.sitem = null;
      }
      if (from.name !== 'app.post') {
        if ($stateParams.renew) {
          $scope.data = null;
          $scope.data = [];
        }
        $scope.loadMore();
      }
    }
  });

  $scope.moreDataCanBeLoaded = function(){
    return !$scope.error;
  }

  $rootScope.$on('changeView', function(){
    //$scope.menupopover.hide();
    //$rootScope.$broadcast('close:popover');
    $scope.menupopover.hide();
    if (!$scope.$$phase){
      $scope.$apply();
    }
    if ($rootScope.$storage.view === 'card') {
      for (var i = 0, len = $scope.data.length; i < len; i++) {
        var v = $scope.data[i];
        v.json_metadata = angular.fromJson(v.json_metadata);
      };
    }
  });

  $rootScope.$on('changeLight', function(){
    $scope.menupopover.hide();
    //$rootScope.$broadcast('close:popover');
    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  function arrayObjectIndexOf(myArray, searchTerm, property) {
    var llen = myArray.length;
    for(var i = 0; i < llen; i++) {
        if (myArray[i][property] === searchTerm) return i;
    }
    return -1;
  }
  $scope.data = [];
  $scope.tempData = [];

  $scope.dataChanged = function(newValue) {
    if (newValue) {
      var lenn = newValue.length;
      var user = $rootScope.$storage.user || null;
      var view = $rootScope.$storage.view;

      if (user){
        for (var i = 0; i < lenn; i++) {
          if (newValue[i] && newValue[i].active_votes) {
            var len = newValue[i].active_votes.length-1;
            for (var j = len; j >= 0; j--) {
              if (newValue[i].active_votes[j].voter === user.username) {
                if (newValue[i].active_votes[j].percent > 0) {
                  newValue[i].upvoted = true;
                } else if (newValue[i].active_votes[j].percent < 0) {
                  newValue[i].downvoted = true;
                } else {
                  newValue[i].downvoted = false;
                  newValue[i].upvoted = false;
                }
              }
            }
          }
          if (view === 'card') {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      } else {
        if (view === 'card') {
          for (var i = 0; i < lenn; i++) {
            if (newValue[i].json_metadata){
              newValue[i].json_metadata = angular.fromJson(newValue[i].json_metadata);
            }
          }
        }
      }
      return newValue;
    }
  }

  $scope.fetchContent = function(author, permlink) {
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        for (var i = 0, len = $scope.data.length; i < len; i++) {
          var v = $scope.data[i];
          if (v.permlink === result.permlink) {
            $scope.data[i] = result;
          }
        }
        $rootScope.$broadcast('hide:loading');
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
  }
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.length; i++) {
      if ($scope.data[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.fetchPosts = function(type, limit, tag) {
    type = type || $rootScope.$storage.filter || "trending";
    tag = tag || $rootScope.$storage.tag || "";
    limit = 10;//limit || $scope.limit || 10;

    var params = {};

    if (type === "feed" && $rootScope.$storage.user) {
      params = {tag: $rootScope.$storage.user.username, limit: limit, filter_tags:[]};
    } else {
      if ($rootScope.$storage.filter === "feed") {
        $rootScope.$storage.filter = "trending";
        type = "trending";
      }
      params = {tag: tag, limit: limit, filter_tags:[]};
    }
    if ($scope.data && $scope.data.length>0) {
      params.start_author = $scope.data[$scope.data.length-1].author;
      params.start_permlink = $scope.data[$scope.data.length-1].permlink;
    }
    if ($scope.error) {
      //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
      $scope.$broadcast('scroll.infiniteScrollComplete');
      $rootScope.$broadcast('hide:loading');
    } else {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("fetching..."+type+" "+limit+" "+tag);
        if (typeof window.Api.database_api === "function") {
          /*window.Api.database_api().exec("get_state", ["/"+type]).then(function(response){
            console.log(response);
          });*/
          if ($rootScope.$storage.chain == 'golos' && type == 'feed') {
            params.select_authors = [$rootScope.$storage.user.username]; 
            delete params.tags; 
          }
          window.Api.database_api().exec("get_discussions_by_"+type, [params]).then(function(response){
            $rootScope.log(response);
            if (response.length <= 1) {
              $scope.error = true;
            }
            if (response) {
              for (var i = 0; i < response.length; i++) {
                response[i].json_metadata = response[i].json_metadata?angular.fromJson(response[i].json_metadata):response[i].json_metadata;
                var permlink = response[i].permlink;
                if (!$scope.ifExists(permlink)) {
                  var user = $rootScope.$storage.user || undefined;
                  if (user) {
                    //console.log('exist');
                    if (response[i] && response[i].active_votes) {
                      var len = response[i].active_votes.length-1;
                      for (var j = 0; j < len; j++) {
                        if (response[i].active_votes[j].voter === user.username) {
                          if (response[i].active_votes[j].percent > 0) {
                            response[i].upvoted = true;
                          } else if (response[i].active_votes[j].percent < 0) {
                            response[i].downvoted = true;
                          } else {
                            response[i].downvoted = false;
                            response[i].upvoted = false;
                          }
                        }
                      }
                    }
                  }
                  //if (!/bm.*/.test(response[i].category)) {
                    $scope.data.push(response[i]);
                  //}
                }
              }
            }

            if (!$scope.$$phase) {
              $scope.$apply();
            }
            //console.log($scope.data.length);
            $scope.$broadcast('scroll.infiniteScrollComplete');
            $rootScope.$broadcast('hide:loading');
          });
        }
      });
    }
  };

  $scope.$on('$ionicView.loaded', function(){
    $scope.limit = 10;
    //$rootScope.$broadcast('show:loading');
    if (!$rootScope.$storage["socket"+$rootScope.$storage.chain]) {
      $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    }
    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'card';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (window.Api) {
      /*if (!angular.isDefined($rootScope.timeint)) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          $rootScope.timeint = $interval(function(){
            window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
              $rootScope.log("get_dynamic_global_properties "+ response.head_block_number);
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["posting"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        posting: $rootScope.$storage.user.posting.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privatePostingKey || null
                  }
                );
                $rootScope.log("login "+loginSuccess);
              }
            });
          }, 15000);
          $rootScope.$broadcast('fetchPosts');
        });
      }*/
    }

    /*setTimeout(function() {
      $ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();
    }, 10);*/
  });
  
  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.theme = $rootScope.$storage.theme;
    if ($stateParams.tags) {
      $rootScope.$storage.tag = $stateParams.tags;
    }

    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use((language.value).split("-")[0]).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  $rootScope.$storage.language = language.value.split('-')[0];
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }

    $scope.activeMenu = $rootScope.$storage.filter || "trending";
    $scope.mymenu = $rootScope.$storage.user ? [{text: $filter('translate')('FEED'), custom:'feed'}, {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}] : [ {text: $filter('translate')('TRENDING'), custom:'trending'}, {text: $filter('translate')('HOT'), custom:'hot'}, {text: $filter('translate')('NEW'), custom:'created'}, {text: $filter('translate')('ACTIVE'), custom:'active'}, {text: $filter('translate')('PROMOTED'), custom: 'promoted'}, {text:$filter('translate')('VOTES'), custom:'votes'}, {text: $filter('translate')('COMMENTS'), custom:'children'}, {text: $filter('translate')('PAYOUT'), custom: 'cashout'}];
    for (var i = 0, len = $scope.mymenu.length; i < len; i++) {
      var v = $scope.mymenu[i];
      if (v.custom === $rootScope.$storage.filter) {
        $rootScope.$storage.filterName = v.text;
      }
    }

  });

})

app.controller('PostCtrl', function($scope, $stateParams, $rootScope, $interval, $ionicScrollDelegate, $ionicModal, $filter, $ionicActionSheet, $cordovaCamera, $ionicPopup, ImageUploadService, $ionicPlatform, $ionicSlideBoxDelegate, $ionicPopover, $filter, $state, APIs, $ionicHistory, $ionicPosition) {
  $scope.post = $rootScope.$storage.sitem;
  $scope.data = {};
  $scope.spost = {};
  $scope.replying = false;

  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSliderr = popover;
  });
  
  $scope.openSliderr = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSliderr.show($event);
  };
  $scope.votePostS = function() {
    $scope.tooltipSliderr.hide();
    $scope.upvotePost($scope.votingPost);
  }
  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  };

  $scope.closeSliderr = function() {
    $scope.tooltipSliderr.hide();
  };

  $scope.isBookmarked = function() {
    var bookm = $rootScope.$storage.bookmark || undefined;
    if (bookm && $rootScope.$storage.sitem) {
      var len = bookm.length;
      for (var i = 0; i < len; i++) {
        if (bookm[i] && bookm[i].permlink === $rootScope.$storage.sitem.permlink) {
          return true;
        }
      }
    } else {
      return false;
    }
  };
  $scope.options = {
    loop: false,
    speed: 500,
    /*pagination: false,*/
    showPager: false,
    slidesPerView: 3,
    spaceBetween: 20,
    breakpoints: {
      1024: {
          slidesPerView: 5,
          spaceBetween: 15
      },
      768: {
          slidesPerView: 4,
          spaceBetween: 10
      },
      640: {
          slidesPerView: 3,
          spaceBetween: 5
      },
      320: {
          slidesPerView: 3,
          spaceBetween: 3
      }
    }
  }
  $scope.bookmark = function() {
    var book = $rootScope.$storage.bookmark;
    if ($scope.isBookmarked()) {
      var len = book.length;
      var id = undefined;
      for (var i = 0; i < len; i++) {
        if (book[i].permlink === $rootScope.$storage.sitem.permlink) {
          id = book[i]._id;
          book.splice(i, 1);
        }
      }
      if (id){
        APIs.removeBookmark(id,$rootScope.$storage.user.username).then(function(res){
          $rootScope.$storage.bookmark = book;
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
        });
      }
    } else {
      if (book) {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark.push(oo);
        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      } else {
        var oo = { author:$rootScope.$storage.sitem.author,permlink:$rootScope.$storage.sitem.permlink};
        $rootScope.$storage.bookmark = [oo];

        APIs.addBookmark($rootScope.$storage.user.username, oo ).then(function(res){
          $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
        });
      }
      //$rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_BOOKMARK'));
    }
  };

  $scope.lastFocused;


  //http://stackoverflow.com/questions/1064089/inserting-a-text-where-cursor-is-using-javascript-jquery
  $scope.insertText = function(text) {
    var input = $scope.lastFocused;
    //console.log(input);
    if (input == undefined) { return; }
    var scrollPos = input.scrollTop;
    var pos = 0;
    var browser = ((input.selectionStart || input.selectionStart == "0") ?
                   "ff" : (document.selection ? "ie" : false ) );
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      pos = range.text.length;
    }
    else if (browser == "ff") { pos = input.selectionStart };

    var front = (input.value).substring(0, pos);
    var back = (input.value).substring(pos, input.value.length);
    input.value = front+text+back;
    pos = pos + text.length;
    if (browser == "ie") {
      input.focus();
      var range = document.selection.createRange();
      range.moveStart ("character", -input.value.length);
      range.moveStart ("character", pos);
      range.moveEnd ("character", 0);
      range.select();
    }
    else if (browser == "ff") {
      input.selectionStart = pos;
      input.selectionEnd = pos;
      input.focus();
    }
    input.scrollTop = scrollPos;
    console.log(angular.element(input).val());
    angular.element(input).trigger('input');
  }

  $ionicPopover.fromTemplateUrl('popoverTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });


  $scope.isImages = function() {
    if ($rootScope.$storage.sitem) {
      var len = $rootScope.$storage.sitem.json_metadata.image?$rootScope.$storage.sitem.json_metadata.image.length:0;
      if (len > 0) {
        $scope.images = $rootScope.$storage.sitem.json_metadata.image;
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  };
  $scope.zoomMin = 1;
  $scope.showImages = function(index) {
    $scope.activeSlide = index;
    $rootScope.log(angular.toJson($scope.images[index]));
    $scope.showGalleryModal('templates/gallery_images.html');
  };

  $scope.showGalleryModal = function(templateUrl) {
    $ionicModal.fromTemplateUrl(templateUrl, {
      scope: $scope
    }).then(function(modal) {
      $scope.modalg = modal;
      $scope.modalg.show();
    });
  }

  $scope.closeGalleryModal = function() {
    $scope.modalg.hide();
    $scope.modalg.remove()
  };

  $scope.updateSlideStatus = function(slide) {
    var zoomFactor = $ionicScrollDelegate.$getByHandle('scrollHandle' + slide).getScrollPosition().zoom;
    if (zoomFactor == $scope.zoomMin) {
      $ionicSlideBoxDelegate.enableSlide(true);
    } else {
      $ionicSlideBoxDelegate.enableSlide(false);
    }
  };

  $scope.showImg = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
       { text: $filter('translate')('GALLERY') }
     ],
     titleText: $filter('translate')('INSERT_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
        $scope.insertImage(index);
        return true;
     }
   });
  };
  $scope.insertImage = function(type) {
    var options = {};
    if ($scope.edit) {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.spost.body) {
                $scope.spost.body += final;
              } else {
                $scope.spost.body = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.spost.body) {
              $scope.spost.body += final;
            } else {
              $scope.spost.body = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    } else {
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          setTimeout(function() {
            ImageUploadService.uploadImage(imageData).then(function(result) {
              //var url = result.secure_url || '';
              var url = result.imageUrl || '';
              var final = " ![image](" + url + ")";
              $rootScope.log(final);
              /*if ($scope.data.comment) {
                $scope.data.comment += final;
              } else {
                $scope.data.comment = final;
              }*/
              $scope.insertText(final);
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            },
            function(err) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
              if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                $cordovaCamera.cleanup();
              }
            });
          }, 10);
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else if (type == 2){
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is' + res);
          if (res) {
            var url = res.trim();
            var final = " ![image](" + url + ")";
            $rootScope.log(final);
            /*if ($scope.data.comment) {
              $scope.data.comment += final;
            } else {
              $scope.data.comment = final;
            }*/
            $scope.insertText(final);
          }
        });
      } else {
        $scope.gallery = [];
        APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
          var imgs = res.data;
          if (imgs.length>0){
            $scope.showgallery = true;
            $scope.gallery.images = imgs;
          } else {
            $scope.showgallery = false;
            $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('NO_IMAGE'));
            console.log('no images available')
          }
        });
      }
    }
  };

  $ionicModal.fromTemplateUrl('templates/story.html', {
    scope: $scope  }).then(function(modal) {
    $scope.pmodal = modal;
  });
  $scope.openPostModal = function() {
    //if(!$scope.pmodal) return;
    setTimeout(function() {
      $scope.pmodal.show();
      /*angular.element("textarea").focus(function() {
        $scope.lastFocused = document.activeElement;
        console.log(document);
      });*/
    }, 10);
  };

  $rootScope.$on('closePostModal', function(){
    $scope.pmodal.hide();
  });

  $scope.closeGallery = function(){
    $scope.showgallery = false;
  }
  $scope.manageGallery = function(){
    $scope.modal.hide();
    $state.go('app.images');
  }
  var dmp = new window.diff_match_patch();

  function createPatch(text1, text2) {
      if (!text1 && text1 === '') return undefined;
      var patches = dmp.patch_make(text1, text2);
      var patch = dmp.patch_toText(patches);
      return patch;
  }
  $scope.cfocus = function(){
    $scope.lastFocused = document.activeElement;
  }
  $scope.deletePost = function(xx) {
    $rootScope.log('delete post '+ angular.toJson(xx));
    var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('DELETE_COMMENT')
    });
    confirmPopup.then(function(res) {
        if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["posting"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();

                tr.add_type_operation("delete_comment", {
                  author: xx.author,
                  permlink: xx.permlink
                });
                //$rootScope.log(my_pubkeys);
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                    $state.go('app.posts');
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.$broadcast('hide:loading');
              }
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
        } else {
          $rootScope.log('You are not sure');
        }
    });
  }
  $scope.edit = false;
  $scope.editPost = function(xx) {
    $scope.edit = true;
    $scope.openPostModal();
    angular.element("textarea").focus(function() {
      $scope.lastFocused = document.activeElement;
      console.log(document);
    });
    setTimeout(function() {
      if (!$scope.spost.body) {
        $scope.spost = xx;
        $scope.patchbody = xx.body;
      }
      $scope.spost.tags = angular.fromJson(xx.json_metadata).tags.join().replace(/\,/g,' ');
    }, 10);
  }

  $scope.submitStory = function() {
    if (!$scope.$$phase){
      $scope.$apply();
    }
    $rootScope.$broadcast('show:loading');
    if ($scope.edit) {
      var patch = createPatch($scope.patchbody, $scope.spost.body)
      // Putting body into buffer will expand Unicode characters into their true length
      if (patch && patch.length < new Buffer($scope.spost.body, 'utf-8').length) {
        $scope.spost.body2 = patch;
      }
      //$rootScope.log(patch);
    } else {
      $scope.spost.body2 = undefined;
    }

    if ($rootScope.$storage.user) {
      $scope.mylogin = new window.ejs.Login();
      $scope.mylogin.setRoles(["posting"]);
      var loginSuccess = $scope.mylogin.checkKeys({
          accountName: $rootScope.$storage.user.username,
          password: $rootScope.$storage.user.password || null,
          auths: {
              posting: $rootScope.$storage.user.posting.key_auths
          },
          privateKey: $rootScope.$storage.user.privatePostingKey || null
        }
      );
      if (loginSuccess) {
        var tr = new window.ejs.TransactionBuilder();
        var permlink = $scope.spost.permlink;
        var jjson = $filter("metadata")($scope.spost.body);
        //console.log(jjson);
        //$scope.spost.tags = $filter('lowercase')($scope.spost.tags);
        var json = angular.merge(jjson, {tags: $scope.spost.tags.split(" "), app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' });
        //console.log(json);
        tr.add_type_operation("comment", {
          parent_author: "",
          parent_permlink: $scope.spost.parent_permlink,
          author: $rootScope.$storage.user.username,
          permlink: $scope.spost.permlink,
          title: $scope.spost.title,
          body: $scope.spost.body2 || $scope.spost.body,
          json_metadata: angular.toJson(json)
        });
        tr.add_type_operation("comment_options", {
          allow_curation_rewards: true,
          allow_votes: true,
          author: $rootScope.$storage.user.username,
          permlink: $scope.spost.permlink,
          max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
          percent_steem_dollars: 10000,
          extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
        });
        //$rootScope.log(my_pubkeys);
        localStorage.error = 0;
        tr.process_transaction($scope.mylogin, null, true);
        $scope.replying = false;
        setTimeout(function() {
          $rootScope.$broadcast('hide:loading');
          if (localStorage.error == 1) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
          } else {
            //$scope.closePostModal();

            $rootScope.$broadcast('closePostModal');

            setTimeout(function() {
              $scope.spost = {};
              $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_SUBMITTED'));
            //$scope.closePostPopover();
              $state.go("app.profile", {username: $rootScope.$storage.user.username});
            }, 1);
          }
        }, 3000);
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
      }
    } else {
      $rootScope.$broadcast('hide:loading');
      $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
    }
  }
  $scope.addImage = function(url) {
    $scope.data.comment += ' ![image]('+url+') ';
  }
  $scope.reply = function (xx) {
    //$rootScope.log(xx);
    if (!$scope.$$phase){
      $scope.$apply();
    }
    window.Api.initPromise.then(function(response) {
      $rootScope.$broadcast('show:loading');
      if ($rootScope.$storage.user) {
        $scope.mylogin = new window.ejs.Login();
        $scope.mylogin.setRoles(["posting"]);
        var loginSuccess = $scope.mylogin.checkKeys({
            accountName: $rootScope.$storage.user.username,
            password: $rootScope.$storage.user.password || null,
            auths: {
                posting: $rootScope.$storage.user.posting.key_auths
            },
            privateKey: $rootScope.$storage.user.privatePostingKey || null
          }
        );
        if (loginSuccess) {
          var tr = new window.ejs.TransactionBuilder();
          var t = new Date();
          var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";
          var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || ["esteem"] , app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
          tr.add_type_operation("comment", {
            parent_author: $scope.post.author,
            parent_permlink: $scope.post.permlink,
            author: $rootScope.$storage.user.username,
            permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
            title: "",
            body: $scope.data.comment,
            json_metadata: angular.toJson(json)
          });
          tr.add_type_operation("comment_options", {
            allow_curation_rewards: true,
            allow_votes: true,
            author: $rootScope.$storage.user.username,
            permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,  
            max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
            percent_steem_dollars: 10000,
            extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
          });
          localStorage.error = 0;
          tr.process_transaction($scope.mylogin, null, true);
          $scope.replying = false;
          setTimeout(function() {
            $rootScope.$broadcast('hide:loading');
            if (localStorage.error == 1) {
              $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
            } else {
              $scope.closeModal();
              $scope.data.comment = "";

              $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
              window.Api.initPromise.then(function(response) {
                window.Api.database_api().exec("get_content_replies", [$rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink]).then(function(result){
                  if (result)
                    $scope.comments = result;
                  if (!$scope.$$phase) {
                    $scope.$apply();
                  }
                });
              });
            }
          }, 3000);
        } else {
          $rootScope.$broadcast('hide:loading');
          $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
        }
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    });
  }
  $rootScope.$on("update:content", function(){
    $rootScope.log("update:content");
    setTimeout(function() {
      $scope.getContent($scope.post.author, $scope.post.permlink);  

    /*window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content_replies", [$scope.post.author, $scope.post.permlink]).then(function(result){
        //todo fix active_votes
        console.log(result);
        if (result) {
          $scope.comments = result;
          console.log(result);
        }
        $rootScope.$broadcast('hide:loading');
      });
    });*/
    $rootScope.$broadcast('hide:loading');



    }, 100);



    $rootScope.$broadcast('hide:loading');
  });
  $ionicModal.fromTemplateUrl('templates/reply.html', {
    scope: $scope  }).then(function(modal) {
    $scope.modal = modal;
  });

  $scope.openModal = function(item) {
    //if(!$scope.modal) return;
    setTimeout(function() {
      $scope.modal.show();
    }, 5);
  };

  $scope.closeModal = function() {
    $scope.replying = false;
    $scope.modal.hide();
  };

  $scope.isreplying = function(cho, xx) {
    $scope.replying = xx;
    angular.merge($scope.post, cho);
    if (xx) {
      $scope.openModal();
    } else {
      $scope.closeModal();
    }
  };
  $scope.accounts = {};
  $scope.getContent = function(author, permlink) {
    //console.time('someFunction1');
    var url = "/"+$stateParams.category+"/@"+author+"/"+permlink;
    //console.log(url);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content", [author, permlink]).then(function(result){
        //console.log(result);
        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }
        if ($rootScope.$storage.postAccounts && $rootScope.$storage.postAccounts.indexOf(result.author) == -1) {
          $rootScope.$storage.postAccounts.push(result.author);
        }
        result.json_metadata = angular.fromJson(result.json_metadata);
        //$scope.post.body = result.body;
        $rootScope.$storage.sitem = result;
        
        setTimeout(function() {
          $scope.$broadcast('postAccounts');
        }, 10);
      });
      
      
      /*window.Api.database_api().exec("get_state", [url]).then(function(dd){
        //console.log(dd);
        var con = dd.content;
        var acon = dd.accounts;

        angular.forEach(con, function(v,k){
          v.comments = [];
        });
        //setTimeout(function() {
        angular.forEach(con, function(v,k){
          var vparent = v.parent_author==""?v.author:v.parent_author;
          var vperm = v.parent_author==""?v.permlink:v.parent_permlink;
          var keyy = vparent+"/"+vperm;
          if (v.depth > 7) {
            v.showChildren = false;
          }
          if (v.parent_permlink!==v.category) {
            if (con[keyy]) {
              //console.log(v);
              var llen = v.active_votes.length;
              var luser = $rootScope.$storage.user;
              if (luser) {
                for (var jl = llen - 1; jl >= 0; jl--) {
                  if (v.active_votes[jl].voter === luser.username) {
                    if (v.active_votes[jl].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[jl].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.downvoted = false;
                      v.upvoted = false;
                    }
                  }
                }
              }
              
              con[keyy].comments.push(v);  
            }
          }
          if (!$scope.$$phase) {
            $scope.$apply();
          }
        });
        //console.log(acon);  
        //}, 1);
        angular.forEach(acon, function(v,k){
          //console.log(v.json_metadata);
          if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
            if (v.json_metadata) {
              if (v.json_metadata.indexOf("created_at")>-1) {
                v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
              } else {
                v.json_metadata = angular.fromJson(v.json_metadata);
              }
            }
          }
        });
        var result = con[author+"/"+permlink];

        var len = result.active_votes.length;
        var user = $rootScope.$storage.user;
        if (user) {
          for (var j = len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
        }

        result.json_metadata = angular.fromJson(result.json_metadata);
        
        //console.log(result);
        $rootScope.$broadcast('hide:loading');
        $scope.post = result;
        $rootScope.$storage.sitem = result;
        $rootScope.$storage.paccounts = acon;

        if (!$scope.$$phase) {
          $scope.$apply();
        }

      });
      if (!$scope.$$phase) {
        $scope.$apply();
      }*/
    });
  //$rootScope.$broadcast('hide:loading');
  //console.timeEnd('someFunction1');

  };
  
  $scope.fetchComments = function(author, permlink){
    $rootScope.fetching = true;
    //console.log(author,permlink);
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_content_replies", [author, permlink]).then(function(dd){
        /*for (var i = 0; i < dd.length; i++) {
          window.Api.database_api().exec("get_active_votes", [dd[i].author, dd[i].permlink]).then(function(res){
            //console.log(res);
            dd[i].active_votes = res;
          });
        }*/
        $scope.comments = dd;
        $rootScope.$storage.comments = dd;
        //console.log(dd.active_votes);
        $rootScope.fetching = false;
        for (var i = 0, len = dd.length; i < len; i++) {
          var v = dd[i];
          if ($rootScope.$storage.postAccounts && $rootScope.$storage.postAccounts.indexOf(v.author) == -1) {
            $rootScope.$storage.postAccounts.push(v.author);
          }  
        }
        setTimeout(function() {
          var p2 = document.querySelector('.my-handle');
          $scope.quotePosition = $ionicPosition.position(angular.element(p2));
          $ionicScrollDelegate.$getByHandle('mainScroll').scrollTo(0,$scope.quotePosition.top, true);  
          $scope.$broadcast('postAccounts');
          if (!$scope.$$phase){
            $scope.$apply();
          }
        }, 10);
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
      if (!$scope.$$phase){
        $scope.$apply();
      }
    });
  }
  $scope.$on('postAccounts', function(){
    $rootScope.$storage.paccounts = {};
    //console.log(window.Api);
    //window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);

    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_accounts", [$rootScope.$storage.postAccounts]).then(function(res){
        for (var i = 0, len = res.length; i < len; i++) {
          var v = res[i];
          if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
            if (v.json_metadata) {
              if (v.json_metadata.indexOf("created_at")>-1) {
                v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
              } else {
                v.json_metadata = angular.fromJson(v.json_metadata);
              }
              var key = v.name;
              $rootScope.$storage.paccounts[key] = v.json_metadata;
            }
          }
        }
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
      if (!$scope.$$phase){
        $scope.$apply();
      }
    });
  });
  
  $scope.$on('$ionicView.enter', function(ev){
    //console.log(ev);
    //if(ev.targetScope !== $scope)
    //  return;
    $rootScope.log('enter postctrl');
    $rootScope.$storage.postAccounts = [];
    $rootScope.$storage.paccounts = [];
    //$rootScope.$broadcast('show:loading');
    if ($stateParams.category === '111') {
      var ttemp = $rootScope.$storage.sitem;
      $scope.post = ttemp;
      $rootScope.$broadcast('update:content');
    } else {
      if ($stateParams.author.indexOf('@')>-1){
        $stateParams.author = $stateParams.author.substr(1);
      }
      console.log('someFunction');
      $scope.getContent($stateParams.author, $stateParams.permlink);
    }
  });
  
  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'getContent');
  };
  $rootScope.$on('getContent', function() {
    setTimeout(function() {
      $scope.getContent($rootScope.$storage.sitem.author, $rootScope.$storage.sitem.permlink);  
    }, 100);
  });
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'getContent');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'getContent');
  };


  $scope.pauseVideo = function() {
    var iframe = document.getElementsByTagName("iframe")[0].contentWindow;
    iframe.postMessage('{"event":"command","func":"' + 'pauseVideo' +   '","args":""}', '*');
  }


  $scope.playVideo = function() {
    var iframe = document.getElementsByTagName("iframe")[0].contentWindow;
    iframe.postMessage('{"event":"command","func":"' + 'playVideo' +   '","args":""}', '*');
  }


  $scope.$on('$ionicView.beforeLeave', function(){
    $scope.pauseVideo();
  });

})
app.controller('BookmarkCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {

  $scope.removeBookmark = function(index) {
    if ($rootScope.$storage.bookmark) {
      APIs.removeBookmark($rootScope.$storage.bookmark[index]._id,$rootScope.$storage.user.username).then(function(res){
        $rootScope.$storage.bookmark.splice(index,1);
        $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNBOOKMARK'));
      });
    }
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getBookmarks($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $rootScope.$storage.bookmark = res.data;
    });
  });
});

app.controller('DraftsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeDraft = function(_id) {
    APIs.removeDraft(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.drafts = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('POST_IS_UNDRAFT'));
    });
  };

  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.getDrafts($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.drafts = res.data;
    });
  });
});

app.controller('ImagesCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate, $filter) {
  //JSON.stringify({
  $scope.removeImage = function(_id) {
    APIs.removeImage(_id,$rootScope.$storage.user.username).then(function(res){
      APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
        //console.log(res);
        $scope.images = res.data;
      });
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('IMAGE_REMOVED'));
    });
  };
  $scope.copyImage = function(url){
    cordova.plugins.clipboard.copy(url);
  };
  $scope.$on('$ionicView.beforeEnter', function(){
    APIs.fetchImages($rootScope.$storage.user.username).then(function(res){
      //console.log(res);
      $scope.images = res.data;
    });
  });
});

app.controller('NotificationsCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {

  $scope.removeNotification = function(index) {
    if ($rootScope.$storage.notifications) {
      $rootScope.$storage.notifications.splice(index,1);
    }
  };
})
app.controller('FollowCtrl', function($scope, $stateParams, $rootScope, $state, APIs, $interval, $ionicScrollDelegate) {
  $scope.searchu = {};

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = "followers";
    $scope.followers = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {ruser:"", duser:""};

    $scope.rfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_followers", [$rootScope.$storage.user.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.ruser = res[res.length-1].follower;
          }
          //console.log(res);
          var ll = res.length;
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.followers.push(res[i]);
          }
          if (res.length < $scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.rfetching, 5);
          }
        });
      });
    };

    $scope.dfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_following", [$rootScope.$storage.user.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.duser = res[res.length-1].following;
          }
          var ll = res.length;

          //console.log(res);
          for (var i = 0; i < ll; i++) {
            res[i].id += 1;
            $scope.following.push(res[i]);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            setTimeout($scope.dfetching, 5);
          }
        });
      });
    };

    $scope.rfetching();
    $scope.dfetching();

  });

  $scope.$on('$ionicView.leave', function(){
    /*if (angular.isDefined($scope.dfetching)){
      $interval.cancel($scope.dfetching);
      $scope.dfetching = undefined;
      $scope.following = undefined;
    }
    if (angular.isDefined($scope.rfetching)){
      $interval.cancel($scope.rfetching);
      $scope.rfetching = undefined;
      $scope.followers = undefined;
    }*/
  });
  $scope.isFollowed = function(x) {
    var len = $scope.following.length;
    for (var i = 0; i < len; i++) {
      if ($scope.following[i].following == x) {
        return true;
      }
    }
    return false;
  };
  $scope.isFollowing = function(x) {
    var len = $scope.followers.length;
    for (var i = 0; i < len; i++) {
      if ($scope.followers[i].follower == x) {
        return true;
      }
    }
    return false;
  };
  $scope.change = function(type){
    $scope.active = type;
    console.log(type);

    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $ionicScrollDelegate.$getByHandle('listScroll').scrollTop();
    //$scope.loadMore(type);
  }

  $scope.$on('current:reload', function(){
    $rootScope.log('current:reload');
    //$state.go($state.current, {}, {reload: true});
    $scope.followers = [];
    $scope.following = [];
    $scope.rfetching();
    $scope.dfetching();
  });

  $scope.unfollowUser = function(xx){
    $rootScope.following(xx, "unfollow");
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.profileView = function(xx){
    $state.go('app.profile', {username: xx});
  };

})

app.controller('ProfileCtrl', function($scope, $stateParams, $rootScope, $ionicActionSheet, $cordovaCamera, ImageUploadService, $ionicPopup, $ionicSideMenuDelegate, $ionicHistory, $state, APIs, $ionicPopover, $filter, $ionicModal) {

  $ionicPopover.fromTemplateUrl('popoverSliderrp.html', {
      scope: $scope
  }).then(function(popover) {
      $scope.tooltipSlider = popover;
  });
  
  $scope.openSlider = function($event, d) {
    $scope.votingPost = d;
    if (!$scope.$$phase) {
      $scope.$apply();
    }
    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
    $scope.tooltipSlider.show($event);
  };

  $scope.drag = function(v) {
    //console.log(v);
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.votePostS = function() {
    $scope.tooltipSlider.hide();
    $scope.upvotePost($scope.votingPost);
  };

  $scope.closeSlider = function() {
    $scope.tooltipSlider.hide();
  };

  $scope.translationData = { platformname: $rootScope.$storage.platformname, platformpower: $rootScope.$storage.platformpower, platformsunit:"$1.00" };

  $scope.goBack = function() {
    var viewHistory = $ionicHistory.viewHistory();
    if (!viewHistory.backView) {
      $scope.openMenu();
    } else {
      $ionicHistory.goBack();
    }
  };
  $scope.followUser = function(xx){
    $rootScope.following(xx, "follow");
  };
  $scope.unfollowUser = function(xx){
    $rootScope.log(xx);
    $rootScope.following(xx, "unfollow");
  };

  $scope.$on('current:reload', function(){
    $state.go($state.current, {}, {reload: true});
  });

  $ionicPopover.fromTemplateUrl('popoverPTr.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });

   $scope.openTooltip = function($event, d) {
    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PROMOTED')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(p,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('AUTHOR_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(ar,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('CURATION_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(crp,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
    $scope.tooltipText = texth;
    $scope.tooltip.show($event);
   };

   $scope.closeTooltip = function() {
      $scope.tooltip.hide();
   };

   //Cleanup the popover when we're done with it!
   $scope.$on('$destroy', function() {
      $scope.tooltip.remove();
   });

   // Execute action on hide popover
   $scope.$on('popover.hidden', function() {
      // Execute action
   });

   // Execute action on remove popover
   $scope.$on('popover.removed', function() {
      // Execute action
   });

  $ionicModal.fromTemplateUrl('my-edit.html', {
    scope: $scope,
    animation: 'slide-in-up'
  }).then(function(modal) {
    $scope.modalEdit = modal;
  });
  $scope.closeEdits = function() {
    $scope.modalEdit.hide();
  };
  // Cleanup the modal when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.modalEdit.remove();
  });
  // Execute action on hide modal
  $scope.$on('modal.hidden', function() {
    // Execute action
  });
  $scope.edit = {};
  $scope.showEdits = function() {
    //showedits
    $scope.edit = {};
    $scope.edit = $rootScope.$storage.user.json_metadata || {};
    $scope.modalEdit.show();
  }
  $scope.saveEdit = function(){
    console.log($scope.edit);
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: ""
    });
    confirmPopup.then(function(res) {
      if(res) {
        if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
          $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
        } else {
          var update = $rootScope.$storage.user.json_metadata;
          angular.merge(update, $scope.edit);
          if (update.profilePicUrl) {delete update.profilePicUrl;}
          $rootScope.log('You are sure');
          if ($rootScope.$storage.user) {
            $scope.mylogin = new window.ejs.Login();
            $scope.mylogin.setRoles(["active"]);
            var loginSuccess = $scope.mylogin.checkKeys({
                accountName: $rootScope.$storage.user.username,
                password: $rootScope.$storage.user.password || null,
                auths: {
                  active: $rootScope.$storage.user.active.key_auths
                },
                privateKey: $rootScope.$storage.user.privateActiveKey || null
              }
            );
            //todo: if json_metadata already exist make sure to keep it.
            if (loginSuccess) {
              var tr = new window.ejs.TransactionBuilder();
              tr.add_type_operation("account_update", {
                account: $rootScope.$storage.user.username,
                memo_key: $rootScope.$storage.user.memo_key,
                json_metadata: JSON.stringify(update)
              });
              localStorage.error = 0;
              tr.process_transaction($scope.mylogin, null, true);
              setTimeout(function() {
                $scope.modalEdit.hide();
                if (localStorage.error == 1) {
                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                } else {
                  $rootScope.$broadcast('refreshLocalUserData');
                }
              }, 3000);
            } else {
              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
            }
            $rootScope.$broadcast('hide:loading');
          } else {
            $rootScope.$broadcast('hide:loading');
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
          }
        }
      }
    });
  }
  $scope.showProfile = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'profile');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {profile_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            if (update.profilePicUrl) {delete update.profilePicUrl;}

            update.profile.profile_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $scope.changeProfileInfo = function(type, which) {
    if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
      $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
    } else {
      var options = {};
      if (type == 0 || type == 1) {
        options = {
          quality: 50,
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
          allowEdit: (type===0)?true:false,
          encodingType: Camera.EncodingType.JPEG,
          targetWidth: which==='profile'?500:1000,
          targetHeight: 500,
          popoverOptions: CameraPopoverOptions,
          saveToPhotoAlbum: false
          //correctOrientation:true
        };
        $cordovaCamera.getPicture(options).then(function(imageData) {
          ImageUploadService.uploadImage(imageData).then(function(result) {
            //var url = result.secure_url || '';
            var url = result.imageUrl || '';
            var update = { profile: { cover_image: "", profile_image: ""} };
            if (which === 'profile') {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = url;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = url;
            }

            setTimeout(function() {
              $rootScope.$broadcast('show:loading');
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });

                  localStorage.error = 0;

                  tr.process_transaction($scope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage);
                    } else {
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
              $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          },
          function(err) {
            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
              $cordovaCamera.cleanup();
            }
          });
        }, function(err) {
          $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
        });
      } else {
        $ionicPopup.prompt({
          title: $filter('translate')('SET_URL'),
          template: $filter('translate')('DIRECT_LINK_PICTURE'),
          inputType: 'text',
          inputPlaceholder: 'http://example.com/image.jpg'
        }).then(function(res) {
          $rootScope.log('Your url is'+ res);
          if (res) {
            var update = { profile: { profile_image: "", cover_image:"" } };
            if (which==="profile") {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              if (update.profilePicUrl) {delete update.profilePicUrl;}
              update.profile.profile_image = res;
            } else {
              angular.merge(update, $rootScope.$storage.user.json_metadata);
              update.profile.cover_image = res;
            }

            setTimeout(function() {
              if ($rootScope.$storage.user) {
                $scope.mylogin = new window.ejs.Login();
                $scope.mylogin.setRoles(["active"]);
                var loginSuccess = $scope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                      active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null,
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_update", {
                    account: $rootScope.$storage.user.username,
                    memo_key: $rootScope.$storage.user.memo_key,
                    json_metadata: JSON.stringify(update)
                  });
                  localStorage.error = 0;
                  tr.process_transaction($scope.mylogin, null, true);
                  setTimeout(function() {
                    if (localStorage.error == 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshLocalUserData();
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
                }
                $rootScope.$broadcast('hide:loading');
              } else {
                $rootScope.$broadcast('hide:loading');
                $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
              }
            }, 5);
          }
        });
      }
    }
  };

  $scope.showCover = function() {
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: $filter('translate')('CAPTURE_PICTURE') },
       { text: $filter('translate')('SELECT_PICTURE') },
       { text: $filter('translate')('SET_CUSTOM_URL') },
     ],
     destructiveText: $filter('translate')('RESET'),
     titleText: $filter('translate')('MODIFY_COVER_PICTURE'),
     cancelText: $filter('translate')('CANCEL'),
     cancel: function() {
        // add cancel code..
      },
     buttonClicked: function(index) {
      if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
        $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
      } else {
        $scope.changeProfileInfo(index, 'cover');
      }
      return true;
     },
     destructiveButtonClicked: function(index){
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('RESET_COVER_PICTURE_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          if (!$rootScope.$storage.user.password && !$rootScope.$storage.user.privateActiveKey) {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
          } else {
            var update = {profile: {cover_image:""} };
            angular.merge(update, $rootScope.$storage.user.json_metadata);
            update.profile.cover_image = "";

            $rootScope.log('You are sure');
            if ($rootScope.$storage.user) {
              $scope.mylogin = new window.ejs.Login();
              $scope.mylogin.setRoles(["active"]);
              var loginSuccess = $scope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                    active: $rootScope.$storage.user.active.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privateActiveKey || null
                }
              );
              //todo: if json_metadata already exist make sure to keep it.
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                tr.add_type_operation("account_update", {
                  account: $rootScope.$storage.user.username,
                  memo_key: $rootScope.$storage.user.memo_key,
                  json_metadata: JSON.stringify(update)
                });
                localStorage.error = 0;
                tr.process_transaction($scope.mylogin, null, true);
                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                  } else {
                    $rootScope.$broadcast('refreshLocalUserData');
                  }
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL_A'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
      return true;
     }
   });
  };


  $rootScope.$on('profileRefresh', function(){
    $scope.refresh();
  });
  $scope.upvotePost = function(post) {
    $rootScope.votePost(post, 'upvote', 'profileRefresh');
  };
  $scope.downvotePost = function(post) {
    var confirmPopup = $ionicPopup.confirm({
      title: $filter('translate')('ARE_YOU_SURE'),
      template: $filter('translate')('FLAGGING_TEXT')
    });
    confirmPopup.then(function(res) {
      if(res) {
        $rootScope.log('You are sure');
        $rootScope.votePost(post, 'downvote', 'profileRefresh');
      } else {
        $rootScope.log('You are not sure');
      }
    });
  };
  $scope.unvotePost = function(post) {
    $rootScope.votePost(post, 'unvote', 'profileRefresh');
  };

  $scope.isAmFollowing = function(xx) {
    if ($scope.following && $scope.following.indexOf(xx)!==-1) {
      return true;
    } else {
      return false;
    }
  };
  /*$scope.$watch('following', function() {
    console.log('hey, myVar has changed!');
  });*/
  $scope.ifExists = function(xx){
    for (var i = 0; i < $scope.data.profile.length; i++) {
      if ($scope.data.profile[i].permlink === xx){
        return true;
      }
    }
    return false;
  }
  $scope.end = false;
  $scope.clen = 20;
  $scope.moreDataCanBeLoaded = function(){
    return ($scope.data.profile && $scope.data.profile.length>0) && !$scope.end;
  }

  $scope.loadmore = function() {
    //console.log('loadmore');
    var params = {tag: $stateParams.username, limit: 20, filter_tags:[]};
    var len = $scope.data.profile?$scope.data.profile.length:0;

    //console.log($scope.data.profile);

    if (len>0) {
      delete params.limit;
      params.start_author = $scope.data.profile[len-1].author;
      params.start_permlink = $scope.data.profile[len-1].permlink;

      if ($scope.end) {
        //$rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REQUEST_LIMIT_TEXT'));
        $scope.$broadcast('scroll.infiniteScrollComplete');
        $rootScope.$broadcast('hide:loading');
      } else {
        //console.log(params);
        //$rootScope.log("fetching profile...blog 20 ");
        window.Api.initPromise.then(function(response) {
          if (typeof window.Api.database_api === "function") {
            if ($scope.active == 'blog') {
              if ($rootScope.$storage.chain == 'golos') {
                params.select_authors = [$stateParams.username];
                delete params.tags;   
              }
              window.Api.database_api().exec("get_discussions_by_blog", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'posts') {
              window.Api.database_api().exec("get_discussions_by_comments", [params]).then(function(response){

                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            if ($scope.active == 'recent-replies') {
              var pp = [$scope.data.profile[$scope.data.profile.length-1].author, $scope.data.profile[$scope.data.profile.length-1].permlink, 20];
              window.Api.database_api().exec("get_replies_by_last_update", [pp]).then(function(response){
                //console.log(response);
                if (response) {
                  for (var j = 0; j < response.length; j++) {
                    var v = response[j];
                    v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
                    !$scope.$$phase?$scope.$apply():console.log('phased');
                    var found = false;
                    for (var i = $scope.data.profile.length-1; i >= 0; i--) {
                      if ($scope.data.profile[i].id === v.id){
                        found = true;
                        //console.log($scope.data.profile[i].id, v.id);
                      }
                    }
                    if (!found){
                      //console.log(v.id);
                      $scope.data.profile.push(v);
                    }
                    if (response.length <= 1) {
                      $scope.end = true;
                    } else {
                      $scope.end = false;
                    }
                  }
                }
              });
              $scope.$broadcast('scroll.infiniteScrollComplete');
            }
            //console.log($scope.profile);
          }
        });
      }
    }

  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.user = {username: $stateParams.username};
    $scope.follower = [];
    $scope.following = [];
    $scope.limit = 100;
    $scope.tt = {duser: "", ruser: ""};

    $scope.refresh = function() {
      if (!$scope.active) {
        $scope.active = "blog";
      }
      if ($scope.active != "blog") {
        $scope.rest = "/"+$scope.active;
      } else {
        $scope.rest = "";
      }

      $scope.nonexist = false;
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
          $scope.data = {profile: []};
          //console.log(res);
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
            if(!$scope.$$phase){
              $scope.$apply();
            }
          } else {
            $scope.nonexist = true;
          }
        });
      });
    };
    $scope.dfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_following", [$rootScope.$storage.user.username, $scope.tt.duser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.duser = res[res.length-1].following;
          }
          var len = res.length;
          for (var i = 0; i < len; i++) {
            $scope.following.push(res[i].following);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          } else {
            setTimeout($scope.dfetching, 5);
          }
        });
      });
    };
    $scope.rfetching = function(){
      window.Api.initPromise.then(function(response) {
        window.Api.follow_api().exec("get_followers", [$rootScope.$storage.user.username, $scope.tt.ruser, "blog", $scope.limit]).then(function(res){
          if (res && res.length===$scope.limit) {
            $scope.tt.ruser = res[res.length-1].follower;
          }
          var len = res.length;
          for (var i = 0; i < len; i++) {
            $scope.follower.push(res[i].follower);
          }
          if (res.length<$scope.limit) {
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          } else {
            setTimeout($scope.rfetching, 10);
          }
        });
      });
    };
    $scope.getFollows = function(r,d) {      
      if (r) {
        $rootScope.log("rfetching");
        $scope.rfetching();
      }
      if (d) {
        $rootScope.log("dfetching");
        $scope.dfetching();
      }
    };
    $scope.getOtherUsersData = function() {
      console.log("getOtherUsersData");
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_accounts", [[$stateParams.username]]).then(function(dd){
          dd = dd[0];
          if (dd && dd.json_metadata) {
            dd.json_metadata = angular.fromJson(dd.json_metadata);
          }
          angular.merge($scope.user, dd);
          //console.log(angular.toJson($scope.user));
          //console.log($scope.user.json_metadata.profile.cover_image);

          if ($rootScope.$storage.user) {
            $scope.css = ($rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
          } else {
            $scope.css = null;
          }
          if (!$scope.$$phase){
            $scope.$apply();
          }
        });
        window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
          //console.log(res);
          $scope.followdetails = res;
        });
      });
      $scope.getFollows(null, "d");
      if(!$scope.$$phase){
        $scope.$apply();
      }
    };

    $scope.refresh();
    if ($rootScope.$storage.user) {
      if ($rootScope.$storage.user.username !== $stateParams.username) {
        $scope.getOtherUsersData();
      } else {
          $rootScope.log("get follows counts");
          window.Api.initPromise.then(function(response) {
            window.Api.follow_api().exec("get_follow_count", [$stateParams.username]).then(function(res){
              //console.log(res);
              $scope.followdetails = res;
            });
          });
      }
    } else {
      if ($stateParams.username) {
        $scope.getOtherUsersData();
      }
    }

    //setTimeout(function() {
      $scope.css = ($rootScope.$storage.user&& $rootScope.$storage.user.username === $scope.user.username && $rootScope.$storage.user.json_metadata && $rootScope.$storage.user.json_metadata.profile && $rootScope.$storage.user.json_metadata.profile.cover_image) ? {'background': 'url('+$rootScope.$storage.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : ($rootScope.$storage.user && $rootScope.$storage.user.username !== $scope.user.username && ($scope.user.json_metadata && $scope.user.json_metadata.profile && $scope.user.json_metadata.profile.cover_image)) ? {'background': 'url('+$scope.user.json_metadata.profile.cover_image+')', 'background-size': 'cover', 'background-position':'fixed'} : null;
      //console.log($scope.css);
    //}, 1);

  });
  $scope.openMenu = function() {
    $ionicSideMenuDelegate.toggleLeft();
  }
  $scope.change = function(type){
    $scope.data = undefined;
    console.log(type);
    $scope.data = {profile: []};
    $scope.accounts = [];
    $scope.active = type;
    $scope.end = false;
    
    if(!$scope.$$phase){
      $scope.$apply();
    }

    if (type != "blog") {
      $scope.rest = "/"+type;
    } else {
      $scope.rest = "";
    }
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_state", ["/@"+$stateParams.username+$scope.rest]).then(function(res){
        //console.log(res);
        if (res.content) {
          if (Object.keys(res.content).length>0) {
            angular.forEach(res.content, function(v,k){
              v.json_metadata = v.json_metadata?angular.fromJson(v.json_metadata):v.json_metadata;
              if ($rootScope.$storage.user){
                if ($rootScope.$storage.user.username !== v.author) {
                  v.reblogged = true;
                }
                var len = v.active_votes.length;
                for (var j = len - 1; j >= 0; j--) {
                  if (v.active_votes[j].voter === $rootScope.$storage.user.username) {
                    if (v.active_votes[j].percent > 0) {
                      v.upvoted = true;
                    } else if (v.active_votes[j].percent < 0) {
                      v.downvoted = true;
                    } else {
                      v.upvoted = false;
                      v.downvoted = false;
                    }
                  }
                }
              }
              $scope.data.profile.push(v);
            });
            $scope.nonexist = false;
          } else {
            $scope.nonexist = true;
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
        if (type==="transfers" || type==="permissions") {
          for (var property in res.accounts) {
            if (res.accounts.hasOwnProperty(property)) {
              $scope.accounts = res.accounts[property];
              //$rootScope.log(angular.toJson(res.accounts[property].transfer_history));

              $scope.transfers = res.accounts[property].transfer_history;
              //console.log($scope.transfers);
              $scope.nonexist = false;
            }
          }
          if(!$scope.$$phase){
            $scope.$apply();
          }
        }
      });
    });
  }

})

app.controller('ExchangeCtrl', function($scope, $stateParams, $rootScope) {
  $scope.username = $stateParams.username;

  $scope.$on('$ionicView.beforeEnter', function(){
    $scope.active = 'buy';
    $scope.orders = [];
    window.Api.initPromise.then(function(response) {
      window.Api.database_api().exec("get_order_book", [15]).then(function(res){
        $scope.orders = res;
        if (!$scope.$$phase) {
          $scope.$apply();
        }
      });
    });
    $scope.change = function(type){
      $scope.active = type;
      if (type == "open"){
        window.Api.initPromise.then(function(response) {
          window.Api.database_api().exec("get_open_orders", [$stateParams.username]).then(function(res){
            $scope.openorders = res;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
      if (type == "history"){
        $scope.history = [];
        window.Api.initPromise.then(function(response) {
          window.Api.market_history_api().exec("get_recent_trades", [15]).then(function(r){
            $scope.recent_trades = r;
            if (!$scope.$$phase) {
              $scope.$apply();
            }
          });
        });
      }
    };
  });

});
app.controller('MarketCtrl', function($scope, $rootScope, $state, $ionicPopover, $ionicPopup, $filter, $translate, $ionicPlatform, $window) {

  $scope.requestApp = function(name) {
    $ionicPlatform.ready(function() {
      if (name == 'New') {
        window.open("mailto:info@esteem.ws?subject=Suggesting%20New%20App%20for%20Market%20Place&body=Hello!%0D%0A%0D%0AAppName:%0D%0AAppAuthor:%0D%0AAppLink:%0D%0A%0D%0A", "_system");
      }
      if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('id1158918690');
          window.open("itms-apps://itunes.apple.com/app/id1158918690", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('id1171371708');
          window.open("itms-apps://itunes.apple.com/app/id1171371708", "_system");
        }
      } else {
        if (name == 'SteemMonitor') {
          //cordova.plugins.market.open('com.netsolutions.esteemwitness');
          window.open("market://details?id=com.netsolutions.esteemwitness", "_system");
        }
        if (name == 'SteemFest') {
          //cordova.plugins.market.open('com.netsolutions.steemfest');
          window.open("market://details?id=com.netsolutions.steemfest", "_system");
        }
      }
    });
  }

});

app.controller('SettingsCtrl', function($scope, $stateParams, $rootScope, $ionicHistory, $state, $ionicPopover, $ionicPopup, APIs, $filter, $translate, $window, $ionicSideMenuDelegate) {

   $ionicPopover.fromTemplateUrl('popover.html', {
      scope: $scope
   }).then(function(popover) {
      $scope.tooltip = popover;
   });
   if ($rootScope.$storage.chain == 'steem'){
    $scope.options = ['wss://steemd.steemit.com', 'wss://node.steem.ws']; 
   } else {
    $scope.options = ['wss://ws.golos.io', 'wss://node.golos.ws'];
   }
   

   $scope.openTooltip = function($event, d) {
      var texth = d;
      $scope.tooltipText = texth;
      $scope.tooltip.show($event);
   };

  function getDate(xx) {
    for (var i = 0, len = $rootScope.$storage.currencies.length; i < len; i++) {
      var v = $rootScope.$storage.currencies[i];
      if (v.id == xx) {
        return true;
      }
    }
  }

  function searchObj(nameKey, myArray) {
    for (var i=0; i < myArray.length; i++) {
        if (myArray[i].id === nameKey) {
            return myArray[i];
        }
    }
  }

  $scope.changeCurrency = function(xx, ignore) {
    $rootScope.$broadcast('changedCurrency', {currency: xx, enforce: ignore});
  }
  $scope.changeChain = function() {
    $scope.restart = true;
    if ($rootScope.$storage.chain == 'steem'){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      $scope.socket = "wss://steemd.steemit.com";
    } else {
      $rootScope.$storage.platformname = "";
      $rootScope.$storage.platformpower = " ";
      $rootScope.$storage.platformsunit = "";
      $rootScope.$storage.platformdollar = "";
      $rootScope.$storage.platformdunit = "GBG";
      $rootScope.$storage.platformpunit = "GOLOSP";
      $rootScope.$storage.platformlunit = "GOLOS";
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
      //$scope.socket = "wss://golos.steem.ws";
      $scope.socket = "wss://ws.golos.io/";
    }
    window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);

    $scope.changeCurrency($rootScope.$storage.currency, true);
  }
  $scope.restart = false;
  $scope.closeTooltip = function() {
    $scope.tooltip.hide();
  };

  //Cleanup the popover when we're done with it!
  $scope.$on('$destroy', function() {
    $scope.tooltip.remove();
  });

  $scope.changeLanguage = function(locale){
    setTimeout(function() {
      if (locale == 'ar-SA' || locale == 'he-IL' || locale == 'fa-IR') {
        $rootScope.$storage.dir = 'rtl';
      } else {
        $rootScope.$storage.dir = 'ltr';
      }
      $translate.use(locale);
      if (!$scope.$$phase) {
        $scope.$apply();
      }
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    }, 1);
  }
  $scope.drag = function(v) {
    $rootScope.$storage.voteWeight = v*100;
  }
  $scope.$on('$ionicView.beforeEnter', function(){
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = localStorage.socketUrl;
    $scope.data = {};
    if (!$rootScope.$storage.voteWeight){
      $rootScope.$storage.voteWeight = 10000;
      $scope.vvalue = 100;
    } else {
      $scope.vvalue = $rootScope.$storage.voteWeight/100;
    }
    if(!$scope.$$phase){
      $scope.$apply();
    }
    
    if ($rootScope.$storage.pincode) {
      $scope.data = {pin: true};
    } else {
      $scope.data = {pin: false};
    }

    if ($rootScope.$storage.user && $rootScope.$storage.deviceid) {
      APIs.getSubscriptions($rootScope.$storage.deviceid).then(function(res){
        $rootScope.log(angular.toJson(res.data));
        var d = res.data;
        //angular.forEach(d, function(v,k){
        for (var i = 0, len = d.length; i < len; i++) {
          var v = d[i];
          if (v.username == $rootScope.$storage.user.username) {
            angular.merge($scope.data, {vote: v.subscription.vote, follow: v.subscription.follow, comment: v.subscription.comment, mention: v.subscription.mention, resteem: v.subscription.resteem});    
          }          
        }
        
        if (!$scope.$$phase){
          $scope.$apply();
        }
      });
    }

    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $scope.notificationChange = function() {
    $rootScope.$storage.subscription = {
      vote: $scope.data.vote,
      comment: $scope.data.comment,
      follow: $scope.data.follow,
      mention: $scope.data.mention,
      resteem: $scope.data.resteem,
      device: ionic.Platform.platform(),
      timestamp: $filter('date')(new Date(), 'medium'),
      appversion: '1.3.9'
    }
    APIs.updateSubscription($rootScope.$storage.deviceid, $rootScope.$storage.user.username, $rootScope.$storage.subscription).then(function(res){
      console.log(angular.toJson(res));
    });

  }

  $scope.pinChange = function() {
    $rootScope.log("pinChange");
    if ($rootScope.$storage.pincode) {
      $rootScope.$broadcast("pin:check");
    } else {
      $rootScope.$broadcast("pin:new");
    }
  }

  $rootScope.$on("pin:correct", function(){
    $rootScope.log("pin:correct " + $scope.data.pin);
    if (!$scope.data.pin) {
        $rootScope.$storage.pincode = undefined;
    }
    if ($rootScope.$storage.pincode) {
      $scope.data.pin = true;
    } else {
      $scope.data.pin = false;
    }
    if (!$scope.$$phase){
      $scope.$apply();
    }
  });

  $rootScope.$on("pin:failed", function(){
    $rootScope.log("pin:failed");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $scope.data.pin = true;
      } else {
        $scope.data.pin = false;
      }
      if (!$scope.$$phase){
        $scope.$apply();
      }
    }, 10);

  });
  $scope.logouts = function() {
    $rootScope.$storage.user = undefined;
    $rootScope.$storage.user = null;
    $rootScope.$storage.mylogin = undefined;
    $rootScope.$storage.mylogin = null;
    //make sure user credentials cleared.
    if ($rootScope.$storage.deviceid) {
      APIs.deleteSubscription($rootScope.$storage.deviceid).then(function(res){
        $ionicSideMenuDelegate.toggleLeft();
        //$window.location.reload(true);
        $state.go('app.posts',{renew:true},{reload: true});
      });
    } else {
      $ionicSideMenuDelegate.toggleLeft();
      //$window.location.reload(true);
      $state.go('app.posts',{renew:true},{reload: true});
    }
    $rootScope.$storage.filter = undefined;
    $rootScope.$storage.tag = undefined;

    $ionicHistory.clearCache();
    $ionicHistory.clearHistory();
    setTimeout(function() {
      ionic.Platform.exitApp(); // stops the app
    }, 100);
  };
  $scope.socket = $rootScope.$storage["socket"+$rootScope.$storage.chain];
  $scope.socketChange = function(xx){
    console.log(xx);
    $rootScope.$storage["socket"+$rootScope.$storage.chain] = xx;
    localStorage.socketUrl = xx;
    $scope.restart = true;
  }
  $scope.save = function(){
    if ($scope.restart) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('UPDATE_REQUIRES_RESTART')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          localStorage.socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
          //$scope.logouts();
          setTimeout(function() {
            window.Api.close();
            window.Api = null;
            window.steemRPC.Client.close();
            var socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
            window.Api = window.steemRPC.Client.get({url:socketUrl}, true);
            if ($rootScope.$storage.user.chain != $rootScope.$storage.chain) {
              for (var i = 0, len = $rootScope.$storage.users.length; i < len; i++) {
                var v = $rootScope.$storage.users[i];
                if (v.chain == $rootScope.$storage.chain){
                  $rootScope.$storage.user = v;
                }
              }
            }
            window.Api.initPromise.then(function(response) {
              $state.go('app.posts',{renew:true},{reload: true});
            });
          }, 500);
        } else {
          $rootScope.log('You are not sure');
        }
      });
    } else {
      $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('SETTINGS_UPDATED'));
      $ionicHistory.nextViewOptions({
        disableBack: true
      });
      //$window.location.reload(true);  
      $state.go('app.posts',{renew:true},{reload: true});
    }
  };

});
}

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/controllers.js","/posts")
},{"buffer":11,"pBGvAp":74}],103:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){


var app = angular.module('steem', [
	'ionic',
	'ngStorage',
	'ngCordova',
  'ion-floating-menu',
  'pascalprecht.translate',
  'ja.qr',
  'ion-datetime-picker'
]);

if (localStorage.getItem("socketUrl") === null) {
  localStorage.setItem("socketUrl", "wss://steemd.steemit.com");
} else if (localStorage.getItem("socketUrl") == "wss://steemit.com/wspa") {
  localStorage.socketUrl="wss://steemd.steemit.com";
}

localStorage.golosId = "782a3039b478c839e4cb0c941ff4eaeb7df40bdd68bd441afd444b9da763de12";
localStorage.steemId = "0000000000000000000000000000000000000000000000000000000000000000";

window.steemRPC = require("steem-rpc");
window.Api = window.steemRPC.Client.get({url:localStorage.socketUrl}, true);
//window.steemJS = require("steemjs-lib");

window.ejs = require("esteem-lib");

//window.golosJS = require("golosjs-lib");
window.diff_match_patch = require('diff-match-patch');
window.getSymbol = require('currency-symbol-map');

require('./config')(app);
require('./services')(app);
require('./controllers')(app);


app.config(function($stateProvider, $urlRouterProvider, $ionicConfigProvider, $sceDelegateProvider, $logProvider, $compileProvider, $animateProvider, $translateProvider) {
  $stateProvider

  .state('app', {
    url: '/app',
    abstract: true,
    template: "<ion-side-menus enable-menu-with-back-views=\"true\" view-cache=\"false\">\n  <ion-side-menu-content drag-content=\"false\">\n    <ion-nav-bar class=\"bar-positive\">\n      <ion-nav-back-button>\n      </ion-nav-back-button>\n      <ion-nav-buttons side=\"left\">\n        <button class=\"button button-icon button-clear ion-navicon\" menu-toggle=\"left\">\n        </button>\n      </ion-nav-buttons>\n    </ion-nav-bar>\n    <ion-nav-view name=\"menuContent\"></ion-nav-view>\n  </ion-side-menu-content>\n  <ion-side-menu side=\"left\">\n    <!--<ion-header-bar class=\"bar-positive\" ng-if=\"!$root.$storage.user\">\n      <h1 class=\"title center\">eSteem</h1>\n    </ion-header-bar>-->\n    <ion-content>\n      <div ng-if=\"!$root.$storage.user\">\n        <center>\n          <p>\n            <img ng-src=\"img/esteem.png\" width=\"150\" />\n          </p>\n        </center>\n      </div>\n      <div ng-if=\"$root.$storage.user\" ng-style=\"$root.$storage.user.json_metadata.profile.cover_image ? mcss : null\">\n      <br>\n        <center>\n          <a menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-myavatar\" ng-if=\"$root.$storage.user\">\n            <span class=\"item-myavatar\" ng-if=\"!$root.$storage.user.json_metadata.user_image && !$root.$storage.user.json_metadata.profile.profile_image\"><img src=\"img/user_profile.png\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" />\n          </a>\n          <div>\n            <div class=\"h4\">@{{$root.$storage.user.username}}&nbsp;<div class=\"reputation\">{{$root.$storage.user.reputation|reputation:true|number:1}}</div></div>\n            <div ng-click=\"showMeExtra()\" class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{$root.$storage.user.post_count}}&nbsp;&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{$root.$storage.user.voting_power/100|number:2}} <i class=\"icon pull-right\" ng-class=\"{'ion-arrow-down-b':!showExtra, 'ion-arrow-up-b':showExtra}\"></i></div>\n          </div>\n        </center>\n      </div>\n      <div ng-if=\"showExtra\">\n        <ion-list>\n          <ion-item menu-close class=\"item-icon-left\" ng-if=\"$root.$storage.users\" ng-repeat=\"user in $root.$storage.users\" ng-click=\"selectAccount(user)\" ng-class=\"{'active': (user.username==$root.$storage.user.username&&user.chain==$root.$storage.user.chain) }\">\n            <img class=\"icon logos\" ng-src=\"{{'img/'+user.chain+'_icon.png'}}\" />\n            {{user.username}}\n            <!--<span class=\"badge badge-assertive\">{{user.chain}}</span>-->\n          </ion-item>\n          <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-plus-round\"></i>\n            {{'ADD_ACCOUNT'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"openPostModal()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-android-create\"></i>\n            {{'SUBMIT_A_STORY'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/profile/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person\"></i>\n            {{'PROFILE'|translate}}\n          </ion-item>\n          <ion-item menu-close href=\"#/app/follow\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-person-stalker\"></i>\n            {{'FOLLOW'|translate}}\n          </ion-item>\n          <ion-item menu-close ng-click=\"logout()\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n            <i class=\"icon ion-log-out\"></i>\n            {{'LOGOUT'|translate}}\n          </ion-item>\n        </ion-list>\n      </div>\n      <ion-list>\n        <ion-item menu-close ng-click=\"openLogin()\" class=\"item-icon-left\" ng-if=\"!$root.$storage.user\">\n          <i class=\"icon ion-log-in\"></i>\n          {{'LOGIN'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/posts/\" class=\"item-icon-left\">\n          <i class=\"icon ion-home\"></i>\n          {{'HOME'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/bookmark\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'BOOKMARKS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/drafts\" ng-if=\"$root.$storage.user\" class=\"item-icon-left\">\n          <i class=\"icon ion-compose\"></i>\n          {{'DRAFTS'|translate}}\n        </ion-item>\n        <!--<ion-item menu-close href=\"#/app/notifications\" class=\"item-icon-left\" ng-if=\"$root.$storage.notifications && $root.$storage.notifications.length>0\">\n          <i class=\"icon ion-bookmark\"></i>\n          {{'NOTIFICATIONS'|translate}}\n        </ion-item>-->\n        <ion-item menu-close href=\"#/app/send\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-android-send\"></i>\n          {{'TRANSFER'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/exchange/{{$root.$storage.user.username}}\" class=\"item-icon-left\" ng-if=\"$root.$storage.user\">\n          <i class=\"icon ion-arrow-swap\"></i>\n          {{'EXCHANGE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/market\" class=\"item-icon-left\">\n          <i class=\"icon ion-cube\"></i>\n          {{'MARKETPLACE'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/settings\" class=\"item-icon-left\">\n          <i class=\"icon ion-android-settings\"></i>\n          {{'SETTINGS'|translate}}\n        </ion-item>\n        <ion-item menu-close href=\"#/app/about\" class=\"item-icon-left\">\n          <i class=\"icon ion-information\"></i>\n          {{'ABOUT'|translate}}\n        </ion-item>\n      </ion-list>\n    </ion-content>\n    <!-- align to the bottom of the page -->\n    <div style=\"position: absolute; bottom: 0px; width: 100%\" ng-if=\"$root.$storage.appversion\">\n        <div style=\"text-align: center; color:#ccc;\">\n          <p>{{$root.$storage.appversion}}</p>\n        </div>\n    </div>\n  </ion-side-menu>\n</ion-side-menus>\n",
    //templateUrl: 'templates/menu.html',
    controller: 'AppCtrl'
  })

  .state('app.settings', {
    url: '/settings',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'SETTINGS'|translate}}\">\n  <ion-content class=\"padding has-header settings\">\n    <br/>\n    <div class=\"item item-divider\">\n      {{'SECURITY'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"PIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'PIN_CODE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.pin\" ng-change=\"pinChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div ng-if=\"$root.$storage.user\">\n    <div class=\"item item-divider\">\n      {{'NOTIFICATIONS'|translate}}\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTE_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'VOTE'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.vote\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"COMMENT_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'COMMENT'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.comment\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"FOLLOW_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'FOLLOW'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.follow\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"MENTIONS_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'MENTIONS'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.mention\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"RESTEEM_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'RESTEEM'|translate}}</span>\n      </div>\n      <div class=\"col pull-right tright\">\n        <label class=\"toggle toggle-positive\">\n         <input type=\"checkbox\" ng-model=\"data.resteem\" ng-change=\"notificationChange()\">\n         <div class=\"track\">\n           <div class=\"handle\"></div>\n         </div>\n        </label>\n      </div>\n    </div>\n    </div>\n    <div class=\"item item-divider\">\n      {{'CONFIGURATIONS'|translate}}\n    </div>\n\n    <div class=\"row\" ng-if=\"$root.$storage.user\">\n      <div class=\"col col-33\">\n      <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"VOTING_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'VOTING'|translate}} (%)</span>\n      </div>\n      <div class=\"col\">\n        <div class = \"item range range-positive\">\n           {{vvalue}} <input type=\"range\" name=\"range1\" min=\"1\" max=\"100\" ng-model=\"vvalue\" ng-change=\"drag(vvalue)\">\n        </div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"LANGUAGES_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'LANGUAGES'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.language\" ng-change='changeLanguage($root.$storage.language)'>\n          <option ng-repeat=\"option in $root.$storage.languages\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CURRENCY_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'CURRENCY'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.currency\" ng-change='changeCurrency($root.$storage.currency)'>\n          <option ng-repeat=\"option in $root.$storage.currencies\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"{{\"CHAIN_TEXT\"|translate}}\")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'CHAIN'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <select ng-model=\"$root.$storage.chain\" ng-change='changeChain($root.$storage.chain)'>\n          <option ng-repeat=\"option in $root.$storage.chains\" value=\"{{option.id}}\">{{option.name}}</option>\n        </select>\n        <!--<div class=\"capital\">{{$root.$storage.language}} <div class=\"pull-right\"><i class=\"icon ion-chevron-right\"></i></div></div>-->\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col col-33\">\n        <span class=\"slabel\" ng-click='openTooltip($event,\"<span class=\\\"bold\\\">{{\"SERVER_TEXT\"|translate}}:</span><br><span class=\\\"wrap\\\">[steemit] wss://steemd.steemit.com</span><br/><br/><span class=\\\"wrap\\\">[steem.ws] wss://node.steem.ws</span><br/><br/><span class=\\\"wrap\\\">[piston] wss://this.piston.rocks</span><br/><br/><span class=\\\"wrap\\\">[golos] wss://ws.golos.io</span><br/><br/><span class=\\\"wrap\\\">[golos.ws] wss://node.golos.ws</span>\n        \")'><i class=\"icon ion-ios-information-outline gray\"></i>&nbsp;{{'SERVER'|translate}}</span>\n      </div>\n      <div class=\"col\">\n        <!--<input type=\"text\" placeholder=\"Server\" ng-model=\"socket\" style=\"width:100%;\" ng-change=\"socketChange(socket)\">-->\n        <select-input ng-model=\"socket\" select-options=\"options\" ></select-input>\n      </div>\n    </div>\n\n    <!--<div class=\"row\">\n      <div class=\"col\">\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n    <button class=\"button button-positive\" ng-click=\"changeLanguage('ru')\">Change RU</button>-->\n    <br/>\n    <script id = \"popover.html\" type=\"text/ng-template\">\n      <ion-popover-view>\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <div class=\"tcenter\">\n      <button class=\"button button-positive\" ng-click=\"save()\">{{'SAVE_CHANGES'|translate}}</button>\n    </div>\n  </ion-content>\n</ion-view>\n",
        controller: 'SettingsCtrl'
      }
    }
  })

  .state('app.about', {
    url: '/about',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'ABOUT' | translate}} - v{{$root.$storage.appversion}}\">\n  <ion-content class=\"padding\">\n    <center><img src=\"img/about.png\"></center>\n    <p><b>eSteem</b> {{'ABOUT_2'|translate}} <div ng-bind-html=\"'ABOUT_11'|translate\"></div>\n    </p>\n    <p ng-if=\"$root.$storage.user\">{{\"FOUNDER\"|translate}} <a href=\"#app/profile/good-karma\">good-karma</a></p>\n    <div class=\"tcenter\" ng-if=\"$root.$storage.user\"><span ng-if=\"!$root.isWitnessVoted()\"><button class=\"button button-positive\" ng-click=\"$root.voteWitness()\">{{'ABOUT_8'|translate}}</button></span></div>\n    <p>\n    <b><u>{{'ABOUT_9'|translate}}</u></b>\n    <br><a href=\"mailto:info@esteem.ws?Subject=Feedback\">info@esteem.ws</a>\n    <br><a href=\"http://esteem.ws\">http://esteem.ws</a>\n    </p>\n    <p>\n        <b><u>{{'TRANSLATIONS'|translate}}</u></b><br>\n         - <a href=\"#app/profile/testz\">testz</a>, <a href=\"#app/profile/on0tole\">on0tole</a><br>\n        Deutsch - <a href=\"#app/profile/dez1337\">dez1337</a>, <a href=\"#app/profile/homosapiens\">homosapiens</a>, <a href=\"#app/profile/uwelang\">uwelang</a>, <a href=\"#app/profile/alexpfeiffer\">alexpfeiffer</a><br>\n        Franais - <a href=\"#app/profile/pickoum\">pickoum</a><br>\n        Espaol - <a href=\"#app/profile/dresden\">dresden</a>, <a href=\"#app/profile/pgarcgo\">pgarcgo</a><br>\n         - <a href=\"#app/profile/liondani\">liondani</a>, <a href=\"#app/profile/steemychicken1\">steemychicken1</a><br>\n         - <a href=\"#app/profile/rossenpavlov\">rossenpavlov</a><br>\n        Nederlands - <a href=\"#app/profile/maxse\">maxse</a>, <a href=\"#app/profile/edje\">edje</a><br>\n        Magyar - <a href=\"#app/profile/tibonova\">tibonova</a><br>\n        etina - <a href=\"#app/profile/valtr\">valtr</a><br>\n         - <a href=\"#app/profile/bosrad\">bosrad</a><br>\n        Polski - <a href=\"#app/profile/knittybynature\">knittybynature</a>, <a href=\"#app/profile/gtg\">gtg</a><br>\n        Portugus - <a href=\"#app/profile/alamyrjunior\">alamyrjunior</a>, <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Portugus BR - <a href=\"#app/profile/charlie777pt\">charlie777pt</a><br>\n        Bahasa Indonesia - <a href=\"#app/profile/levycore\">levycore</a>, <a href=\"#app/profile/happyphoenix\">happyphoenix</a><br>\n         - <a href=\"#app/profile/deanliu\">deanliu</a><br>\n         - <a href=\"#app/profile/huangdashuang\">huangdashuang</a>, <a href=\"#app/profile/oflyhigh\">oflyhigh</a>, <a href=\"#app/profile/lucid\">lucid</a><br>\n        Dolan - <a href=\"#app/profile/maxse\">maxse</a><br>\n        Svensk - <a href=\"#app/profile/acidyo\">acidyo</a>, <a href=\"#app/profile/the-ego-you\">the-ego-is-you</a><br>\n         - <a href=\"#app/profile/erikaflynn\">erikaflynn</a>, <a href=\"#app/profile/artem-sokoloff\">artem-sokoloff</a><br>\n        Bahasa Melayu - <a href=\"#app/profile/kevinwong\">kevinwong</a>, <a href=\"#app/profile/killuminatic\">killuminatic</a><br>\n        Hrvatski - <a href=\"#app/profile/fibra59\">fibra59</a><br>\n        Frsi - <a href=\"#app/profile/meysam\">meysam</a><br>\n        Italiano - <a href=\"#app/profile/bhuz\">bhuz</a>, <a href=\"#app/profile/duranzo89\">duranzo89</a>, <a href=\"#app/profile/silviabeneforti\">silviabeneforti</a><br>\n        Wikang Filipino - <a href=\"#app/profile/themanualbot\">themanualbot</a><br>\n         - <a href=\"#app/profile/bbkoopsta\">bbkoopsta</a><br>\n        \n        <!--\n        malay-killuminatic\n        Wikang Filipino - themanualbot\n        -->\n    </p>\n    <p>\n    <b><u>{{'ABOUT_10'|translate}}</u></b>\n    <br><a href=\"https://steem.io\">https://steem.io</a>\n    <br><a href=\"https://golos.io\">https://golos.io</a>\n    </p>\n  </ion-content>\n</ion-view>\n"
      }
    }
  })

	.state('app.market', {
		url: '/market',
		views: {
			'menuContent': {
				//templateUrl: 'templates/settings.html'
				template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKETPLACE' | translate}}\">\n  <ion-content class=\"padding\">\n    <h4>{{'EXTERNAL_APPS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('SteemMonitor')\">\n        <center>\n          <img src=\"img/logo_steemmonitor.png\" alt=\"Steem Monitor\" style=\"width: 100%;\">\n          <b>Steem Monitor</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a></p>\n        </center>\n      </div>\n      <div class=\"col\" ng-click=\"requestApp('SteemFest')\">\n        <center>\n          <img src=\"img/logo_steemfest.png\" alt=\"Steem Fest\" style=\"width: 100%;\">\n          <b>Steem Fest</b>\n          <p class=\"gray\">{{'BY'|translate}} <a href=\"#app/profile/good-karma\">Feruz</a>, <a href=\"#app/profile/roelandp\">Roeland</a> &amp; <a href=\"#app/profile/cass\">Cass</a></p>\n        </center>\n      </div>\n    </div><br/>\n    <h4>{{'PLUGINS'|translate}}</h4>\n    <div class=\"row\">\n      <div class=\"col italic\">\n        <center>\n          {{'COMING_SOON'|translate}}...\n        </center>\n      </div>\n    </div>\n    <br/>\n    <h4>{{'SUGGEST'|translate}}</h4><br/>\n    <div class=\"row\">\n      <div class=\"col\" ng-click=\"requestApp('New')\">\n        <center>\n          <img src=\"img/plus.png\" alt=\"Suggest New\" style=\"width: 100%;\">\n          <b>{{'NEW'|translate}}</b>\n        </center>\n      </div>\n      <div class=\"col\">\n      </div>\n    </div>\n  </ion-content>\n</ion-view>\n",
				controller: 'MarketCtrl'
			}
		}
	})

  .state('app.send', {
    url: '/send',
    views: {
      'menuContent': {
        //templateUrl: 'templates/settings.html'
        template: "<ion-view view-cache=\"false\" view-title=\"{{'TRANSFER'|translate}}\">\n  <div class=\"tabs-striped tabs-top tabs-background-positive tabs-color-light\">\n    <div class=\"tabs\">\n      <a class=\"tab-item\" href ng-click=\"changeTransfer('transfer')\" ng-class=\"{'active': ttype=='transfer'}\">\n        {{\"TRANSFER\"|translate}}\n      </a>\n      <a class=\"tab-item\" href ng-click=\"changeTransfer('escrow')\" ng-class=\"{'active': ttype=='escrow'}\">\n        {{\"ESCROW\"|translate}}\n      </a>\n    </div>\n  </div>\n\n  <ion-content class=\"padding has-tabs-top\">\n\n    <div class=\"list\">\n      <div class=\"item item-input item-icon-right\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'TO'|translate}}</span>\n        <input type=\"text\" ng-model=\"data.username\" placeholder=\"{{'TO_DESC'|translate}}\" ng-change=\"changeUsername()\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n        <i class=\"icon ion-ios-camera-outline\" ng-click=\"qrScan()\" ng-if=\"ttype=='transfer'\"></i>\n      </div>\n      <label class=\"item item-input\" ng-if=\"ttype=='escrow'&&!data.advanced\">\n          <span class=\"input-label\">{{\"ESCROW_AGENT\"|translate}}</span>\n          <input type=\"text\" readonly=\"readonly\" placeholder=\"{{'USERNAME'|translate}}\" ng-model=\"data.agent.name\" ng-click=\"openUModal(data.agent)\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"/>\n      </label>\n      <div class=\"item item-input item-icon-right\" ng-if=\"ttype=='escrow'&&data.advanced\">\n        <span class=\"input-label\">{{'ESCROW'|translate}} {{'ID'|translate}}</span>\n        <input type=\"text\" ng-model=\"data.escrow_id\" placeholder=\"{{'SEARCH'|translate}}\" ng-change=\"searchEscrowID(data.escrow_id)\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </div>\n      <label class=\"item item-input item-select\" ng-if=\"data.advanced\">\n        <span class=\"input-label\">{{'OPTIONS'|translate}}</span>\n        <select ng-model=\"data.etype\" ng-if=\"ttype=='escrow'\" ng-options=\"item.type as item.name for item in data.etypes track by item.id\" ng-change=\"actionEChange()\"></select>\n      </label>\n      <label class=\"item item-input item-select\" ng-if=\"data.advanced&&data.etype=='release'\">\n        <span class=\"input-label\">{{'RECEIVER'|translate}}</span>\n        <select ng-model=\"escrow.receiver\">\n          <option value=\"{{escrow.to}}\" ng-if=\"escrow.to!=$root.$storage.user.username\">{{escrow.to}}</option>\n          <option value=\"{{escrow.from}}\" ng-if=\"escrow.from!=$root.$storage.user.username\">{{escrow.from}}</option>\n        </select>\n      </label>\n      <label class=\"item item-input item-select\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'ASSET'|translate}}</span>\n        <select ng-model=\"data.type\" ng-if=\"ttype=='escrow'\" ng-options=\"item.type as item.name for item in data.types | filter:showLiquid track by item.id\"></select>\n        <select ng-model=\"data.type\" ng-if=\"ttype=='transfer'\" ng-options=\"item.type as item.name for item in data.types track by item.id\"></select>\n      </label>\n      <label class=\"item item-input\" ng-if=\"!data.advanced\">\n        <span class=\"input-label\">{{'AMOUNT'|translate}}</span>\n        <input type=\"number\" placeholder=\"{{'AMOUNT'|translate}}\" step=\"0.001\" ng-model=\"data.amount\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n      <label class=\"item item-input\" ng-if=\"data.type != 'sp'&&data.type != 'golosp' && !data.advanced\">\n        <span class=\"input-label\">{{'MEMO'|translate}}</span>\n        <textarea ng-model=\"data.memo\" rows=\"3\" placeholder=\"{{'PUBLIC_MEMO'|translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\"></textarea>\n      </label>\n      <div class=\"item\" ion-datetime-picker ng-model=\"data.ratification\" only-valid=\"{'after': 'today', 'inclusive': true}\" ng-if=\"ttype=='escrow'&&!data.advanced\">{{'RATIFICATION_DEADLINE'|translate}}: {{data.ratification| date: \"yyyy-MM-dd H:mm:ss\"}}</div>\n      <div class=\"item\" ion-datetime-picker ng-model=\"data.expiration\" only-valid=\"{'after': 'today', 'inclusive': false}\" ng-if=\"ttype=='escrow'&&!data.advanced\">{{'ESCROW_EXPIRATION'|translate}}: {{data.expiration| date: \"yyyy-MM-dd H:mm:ss\"}}</div>\n      <ion-toggle ng-if=\"ttype=='escrow'\" ng-model=\"data.advanced\" toggle-class=\"toggle-calm\" ng-change=\"advancedEChange()\">{{'ADVANCED'|translate}}</ion-toggle>\n      <p class=\"item\" ng-if=\"balance && !data.advanced\">{{'AVAILABLE'|translate}}: {{balance.balance}}, {{balance.sbd_balance}} <i class=\"icon ion-refresh pull-right\" ng-click=\"refresh()\"></i></p>\n      <br>\n      <div ng-if=\"ttype=='escrow' && data.advanced && escrow.escrow_id\">\n        <div class=\"row\"><div class=\"col\">{{\"FROM\"|translate}}:</div><div class=\"col\">{{escrow.from}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"TO\"|translate}}:</div><div class=\"col\">{{escrow.to}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_AGENT\"|translate}}:</div><div class=\"col\">{{escrow.agent}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_FEE\"|translate}}:</div><div class=\"col\">{{escrow.fee}} {{escrow.fee_symbol}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'RATIFICATION_DEADLINE'|translate}}:</div><div class=\"col\">{{escrow.ratification_deadline|date:'short'}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'ESCROW_EXPIRATION'|translate}}:</div><div class=\"col\">{{escrow.escrow_expiration|date:'short'}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{\"ESCROW_TERMS\"|translate}}:</div><div class=\"col\">{{escrow.json_meta.terms}}</div></div>\n        <div class=\"row\"><div class=\"col\">{{'MEMO'|translate}}:</div><div class=\"col\">{{escrow.json_meta.memo}}</div></div>\n      </div>\n      <center ng-if=\"ttype=='transfer'\"><button class=\"button button-positive\" ng-click=\"transfer('transfer')\">\n        {{'SEND'|translate}}\n      </button></center>\n      <center ng-if=\"ttype=='escrow'&&!data.advanced\"><button class=\"button button-positive\" ng-click=\"transfer('escrow')\">\n        {{'SEND'|translate}}\n      </button></center>\n      <center ng-if=\"ttype=='escrow'&&data.advanced\"><button class=\"button button-positive\" ng-click=\"escrowAction()\">\n        {{'SUBMIT'|translate}}\n      </button></center>\n      <br>\n      <center ng-if=\"ttype=='transfer'\"><qr text=\"$root.$storage.user.username\"></qr></center>\n      <center ng-if=\"ttype=='transfer'\"><i class=\"italic\">{{$root.$storage.user.username}}</i></center>\n    </div>\n  </ion-content>\n  <script id=\"my-modal.html\" type=\"text/ng-template\">\n    <ion-modal-view>\n      <div class=\"bar bar-header bar-positive item-input-inset\">\n        <label class=\"item-input-wrapper\">\n          <i class=\"icon ion-ios-search placeholder-icon\"></i>\n          <input type=\"search\" placeholder=\"{{'SEARCH'|translate}}\" ng-change=\"getUserAgent(data.query)\" ng-model=\"data.query\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n        </label>\n        <button class=\"button button-clear button-outline\" ng-click=\"closeUModal()\">\n          {{\"CANCEL\"|translate}}\n        </button>\n      </div>\n      <ion-content class=\"has-header\">\n        <div class=\"list\" ng-if=\"data.searchResult.length>0\">\n          <a class=\"item\" ng-repeat=\"x in data.searchResult\" ng-click=\"selectAgent(x)\">\n            <h2>{{'ESCROW_AGENT'|translate}}: {{x.name}}</h2>\n            <div ng-if=\"x.escrow\" class=\"wrap\">{{'ESCROW_TERMS'|translate}}: {{x.escrow.terms}}</div>\n            <p class=\"wrap\">{{'ESCROW_FEE'|translate}}: {{x.escrow.fees[$root.$storage.platformlunit]}} {{$root.$storage.platformlunit}} / {{x.escrow.fees[$root.$storage.platformdunit]}} {{$root.$storage.platformdunit}}\n            </p>\n          </a>\n        </div>\n        <center class=\"padding\" ng-if=\"data.searchResult.length==0\">\n          {{\"USER_NOTFOUND\"|translate}}\n        </center>\n      </ion-content>\n    </ion-modal-view>\n\n  </script>\n</ion-view>\n",
        controller: 'SendCtrl'
      }
    }
  })

  .state('app.follow', {
    url: '/follow',
    views: {
      'menuContent': {
        //templateUrl: 'templates/follow.html',
        template: "<ion-view view-cache=\"false\" view-title=\"{{'FOLLOW' | translate}}\">\n  <ion-content class=\"padding has-footer\" delegate-handle=\"listScroll\">\n    <div class=\"list list-inset\" ng-if=\"active=='followers'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.follower\" placeholder=\"{{'SEARCH_FOLLOWERS' | translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n    </div>\n    <div class=\"list list-inset\" ng-if=\"active=='following'\">\n      <label class=\"item item-input\">\n        <i class=\"icon ion-search placeholder-icon\"></i>\n        <input type=\"text\" ng-model=\"searchu.following\" placeholder=\"{{'SEARCH_FOLLOWING' | translate}}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\n      </label>\n    </div>\n    <div class=\"list\" ng-if=\"active=='followers' && followers.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in followers | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.follower)\">{{f.follower}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowed(f.follower)\" ng-click=\"followUser(f.follower)\">\n        {{'FOLLOW_BACK' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowed(f.follower)\" ng-click=\"unfollowUser(f.follower)\">\n        {{'FOLLOWED' | translate}}\n        </button>\n      </div>\n    </div>\n    <div class=\"list\" ng-if=\"active=='following' && following.length>0\">\n      <div class=\"item item-button-right\" ng-repeat=\"f in following | filter:searchu  track by $index\">\n        <span ng-click=\"profileView(f.following)\">{{f.following}}</span>\n        <button class=\"button button-positive button-outline\" ng-if=\"!isFollowing(f.following)\" ng-click=\"unfollowUser(f.following)\">\n        {{'UNFOLLOW' | translate}}\n        </button>\n        <button class=\"button button-positive\" ng-if=\"isFollowing(f.following)\">\n        {{'FOLLOWING' | translate}}\n        </button>\n      </div>\n    </div>\n    <!--<ion-infinite-scroll on-infinite=\"loadMore()\" ng-if=\"lastd\" distance=\"2%\"></ion-infinite-scroll>-->\n  </ion-content>\n  <div class=\"bar profile bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-ios-people\" ng-class=\"{'active':active=='followers'}\" ng-click=\"change('followers')\"> {{'FOLLOWERS' | translate}} <span ng-if=\"followers.length>0\">({{followers.length}})</span></a>\n      <a class=\"button button-royal icon ion-person-add\" ng-class=\"{'active':active=='following'}\" ng-click=\"change('following')\"> {{'FOLLOWED' | translate}} <span ng-if=\"following.length>0\">({{following.length}})</span></a>\n    </div>\n  </div>\n</ion-view>\n",
        controller: 'FollowCtrl'
      }
    }
  })


  .state('app.exchange', {
    url: '/exchange/:username',
    views: {
      'menuContent': {
      	template: "<ion-view view-cache=\"false\" view-title=\"{{'MARKET_VIEW' | translate}}\">\n  <ion-content class=\"padding has-footer exchange\">\n    <div class=\"\" ng-if=\"active=='buy'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.bids\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='sell'\">\n      <div class=\"row header\">\n        <div class=\"col\">{{'PRICE' | translate}}</div>\n        <div class=\"col\">{{'AMOUNT' | translate}}</div>\n        <div class=\"col\">{{'TOTAL' | translate}}</div>\n      </div>\n      <div class=\"row\" ng-repeat=\"(key, f) in orders.asks\">\n        <div class=\"col\">{{f.real_price|number:4}}</div>\n        <div class=\"col\">{{f.order_price.quote}}</div>\n        <div class=\"col\">{{f.order_price.base}}</div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='open'\">\n      <p class=\"padding\" ng-if=\"openorders.length<1\">\n        {{'NOORDERS' | translate}} @{{username}}\n      </p>\n      <div ng-if=\"openorders.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{'AMOUNT' | translate}}</div>\n          <div class=\"col\">{{'TOTAL' | translate}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in openorders\">\n          <div class=\"col\">{{f.real_price|number:4}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.seller==$root.$storage.user.username\">{{f.sell_price.base}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.quote}}</div>\n          <div class=\"col\" ng-if=\"f.buyer==$root.$storage.user.username\">{{f.buy_price.base}}</div>\n        </div>\n      </div>\n    </div>\n    <div class=\"\" ng-if=\"active=='history'\">\n      <!--<p class=\"padding\">Nothing here, yet...</p>-->\n      <div ng-if=\"recent_trades.length>0\">\n        <div class=\"row header\">\n          <div class=\"col\">{{'DATE' | translate}}</div>\n          <div class=\"col\">{{'PRICE' | translate}}</div>\n          <div class=\"col\">{{$root.$storage.platformsunit}}</div>\n          <div class=\"col\">{{$root.$storage.platformdollar}}</div>\n        </div>\n        <div class=\"row\" ng-repeat=\"(key, f) in recent_trades\">\n          <div class=\"col\">{{f.date|timeago}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]/f.open_pays.split(\" \")[0]|number:6}}</div>\n          <div class=\"col\">{{f.current_pays.split(\" \")[0]|number:3}}</div>\n          <div class=\"col\">{{f.open_pays.split(\" \")[0]|number:3}}</div>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <a class=\"button button-large button-royal icon ion-arrow-down-a\" ng-class=\"{'active':active=='buy'}\" ng-click=\"change('buy')\"> {{'BUY' | translate}}</a>\n      <a class=\"button button-royal icon ion-arrow-up-a\" ng-class=\"{'active':active=='sell'}\" ng-click=\"change('sell')\"> {{'SELL' | translate}}</a>\n      <a class=\"button button-royal icon ion-flag\" ng-class=\"{'active':active=='open'}\" ng-click=\"change('open')\">{{'OPEN' | translate}}</a>\n      <a class=\"button button-royal icon ion-ios-clock\" ng-class=\"{'active':active=='history'}\"  ng-click=\"change('history')\">{{'HISTORY' | translate}}</a>\n    </div>\n  </div>\n</ion-view>\n",
        //templateUrl: 'templates/exchange.html',
        controller: 'ExchangeCtrl'
      }
    }
  })

  .state('app.profile', {
    url: '/profile/:username',
    views: {
      'menuContent': {
        //templateUrl: 'templates/profile.html',
        template: "<ion-view view-title=\"\" hide-nav-bar=\"true\" view-cache=\"false\"><!--ng-class=\"{'mpb':$root.$storage.user.json_metadata.profile.cover_image}\"-->\n  <ion-content class=\"has-footer\" overflow-scroll=\"true\">\n    <div class=\"bar bar-subheader mysubheader bar-positive\" ng-style=\"$root.$storage.user.username != user.username?css:mcss\">\n      <button class=\"button button-icon button-clear ion-ios-arrow-back profilebtn\" on-tap=\"goBack()\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"followUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && !isAmFollowing(user.username)\"><!--<i class=\"fa fa-user-plus fa-lg\"></i>-->{{'FOLLOW'|translate}}</button>\n      <button class=\"button button-clear profilebtn_edit button-icon ion-ios-compose-outline\" on-tap=\"showEdits()\" ng-if=\"$root.$storage.user && $root.$storage.user.username === user.username\"></button>\n      <button class=\"button button-clear profilebtn_follow button-icon ion-camera\" on-tap=\"showCover()\" ng-if=\"$root.$storage.user && $root.$storage.user.username === user.username\"></button>\n      <button class=\"button button-outline button-light profilebtn_follow\" on-tap=\"unfollowUser(user.username)\" ng-if=\"$root.$storage.user && $root.$storage.user.username != user.username && isAmFollowing(user.username)\"><!--button-icon button-clear<i class=\"fa fa-user-times fa-lg\"></i>-->{{'UNFOLLOW'|translate}}</button>&nbsp;\n      <div class=\"center\">\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user && $root.$storage.user.username == user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!($root.$storage.user.json_metadata.profile.profile_image||$root.$storage.user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" on-tap=\"showProfile()\"></span>\n            <img ng-src=\"{{$root.$storage.user.json_metadata.profile.profile_image || $root.$storage.user.json_metadata.user_image}}\" ng-if=\"$root.$storage.user.json_metadata.user_image || $root.$storage.user.json_metadata.profile.profile_image\" on-tap=\"showProfile()\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\">\n                <span class=\"light\">@{{$root.$storage.user.username}}</span>\n                &nbsp;\n                <div class=\"reputation\">{{$root.$storage.user.reputation|reputation}}\n                </div>\n              </h4>\n              <div class=\"about\">{{$root.$storage.user.json_metadata.profile.about}}</div>\n              <div class=\"padding\">\n                <i class=\"icon ion-android-list\"></i>&nbsp;\n                {{$root.$storage.user.post_count}}&nbsp;\n                |&nbsp;\n                <i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;\n                {{$root.$storage.user.voting_power/100|number:2}}&nbsp;\n                |&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n                {{followdetails.follower_count}}&nbsp;\n                |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n                {{followdetails.following_count}}\n              </div>\n              <p><span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{$root.$storage.user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"$root.$storage.user.json_metadata.profile && $root.$storage.user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{$root.$storage.user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"$root.$storage.user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{$root.$storage.user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n          <div class=\"item-myavatar\" ng-if=\"$root.$storage.user.username !== user.username\">\n            <span class=\"item-myavatar\" ng-if=\"!(user.json_metadata.profile.profile_image||user.json_metadata.user_image)\"><img src=\"img/user_profile.png\" /></span>\n            <img ng-src=\"{{user.json_metadata.profile.profile_image || user.json_metadata.user_image}}\" ng-if=\"user.json_metadata.profile.profile_image || user.json_metadata.user_image\" />\n            <div class=\"footprofileinfo\">\n              <h4 class=\"center\"><span class=\"light\">@{{user.username}}</span>&nbsp;<div class=\"reputation\">{{user.reputation|reputation}}</div></h4>\n              <p>{{user.json_metadata.profile.about}}</p>\n              <div class=\"padding\"><i class=\"icon ion-android-list\"></i>&nbsp;{{user.post_count}}&nbsp;|&nbsp;<i class=\"icon ion-arrow-graph-up-right\"></i>&nbsp;{{user.voting_power/100|number:2}}&nbsp;|&nbsp;<i class=\"icon ion-ios-people\"></i>&nbsp;\n              {{followdetails.follower_count}}&nbsp;\n              |&nbsp;<i class=\"ion-person-add\"></i>&nbsp;\n              {{followdetails.following_count}}</div>\n              <p><span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.location\">\n                <i class=\"icon ion-location\"></i>&nbsp;\n                {{user.json_metadata.profile.location}}\n                &nbsp;\n              </span>&nbsp;\n              <span ng-if=\"user.json_metadata.profile && user.json_metadata.profile.website\">\n                <i class=\"icon ion-link\"></i>&nbsp;\n                <a on-tap=\"window.open('{{user.json_metadata.profile.website}}', '_system');\" style=\"color:white!important;text-decoration: underline;\">WebSite</a>\n                &nbsp;\n              </span>\n              <span ng-if=\"user.created\">\n                <i class=\"icon ion-calendar\"></i>&nbsp;\n                {{user.created|date}}\n                &nbsp;\n              </span></p>\n            </div>\n          </div>\n      </div>\n    </div>\n    <div class=\"has-mysubheader\">\n        <div class=\"box blue\" ng-if=\"active!='wallet'||active!='permissions'\">\n          <p class=\"padding\" ng-if=\"nonexist\">{{'NOTHING_HERE'|translate}}</p>\n          <ion-list>\n            <!--<div ng-repeat=\"(key, playlist) in profile\" class=\"item wrap\" on-tap=\"open(playlist)\">\n            <h3 class=\"bold\">{{playlist.root_title}}</h3>\n            <span ng-bind-html=\"playlist.body.substring(0,100)|parseUrl\"></span>\n            </div>-->\n            <div class=\"item\" ng-repeat=\"playlist in data.profile | orderBy:'-created' | limitTo:25 track by $index\" ng-class=\"{'item-thumbnail-left': playlist.json_metadata.image}\">\n              <img ng-src=\"{{playlist.json_metadata.image[0]}}\" on-tap=\"open(playlist)\" ng-if=\"playlist.json_metadata.image\" onerror=\"this.src='img/noimage.png'\"/>\n                <div on-tap=\"open(playlist)\">\n                <div class=\"wrap\">\n                  <h2><i class=\"fa fa-money positive\" ng-if=\"playlist.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"playlist.percent_steem_dollars === 0\"></i>{{playlist.root_title}}</h2>\n                </div>\n                <p ng-bind-html=\"playlist.body|limitTo:50|ldots|parseUrl\" ng-if=\"active!='blog'\"></p>\n                <div class=\"postdetails\"><i class=\"icon ion-android-time\"></i>&nbsp;{{playlist.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<i class=\"icon ion-android-person\"></i>&nbsp;{{playlist.author}}&nbsp;<div class=\"reputation\">{{playlist.author_reputation|reputation|number:0}}</div></div>\n                </div>\n                <div class=\"row gray profile\">\n                  <div class=\"col\"><ion-spinner ng-if=\"playlist.invoting\"></ion-spinner>\n                  <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost(playlist)\" ng-if=\"!playlist.upvoted\" on-hold=\"openSlider($event, playlist)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.upvoted\"></i>&nbsp;&nbsp;<span on-tap=\"$root.openInfo(playlist)\">{{playlist.net_votes}}</span>&nbsp;&nbsp;\n                   <!--<i class=\"fa fa-chevron-circle-down fa-lg\" on-tap=\"downvotePost(playlist)\" ng-if=\"!playlist.downvoted\"></i><i class=\"fa fa-chevron-circle-down fa-lg positive\" on-tap=\"unvotePost(playlist)\" ng-if=\"playlist.downvoted\"></i>--></div>\n                  <div class=\"col\" on-tap=\"openTooltip($event,playlist)\">&nbsp; <b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"playlist.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"playlist.max_accepted_payout.split(' ')[0] !== '0.000'\">{{playlist | sumPostTotal:$root.$storage.currencyRate | number}}</span></div>\n                  <div class=\"col\">&nbsp; <i class=\"icon ion-chatbubbles\"></i>&nbsp;{{playlist.children}}</div>\n                  <div class=\"col\" ng-if=\"playlist.author!==user.username && active!=='recent-replies'\">&nbsp; <i class=\"icon ion-arrow-return-right\"></i></div>\n                </div>\n            </div>\n          </ion-list>\n          <ion-infinite-scroll on-infinite=\"loadmore()\" ng-if=\"moreDataCanBeLoaded()\" distance=\"15%\"></ion-infinite-scroll>\n        </div>\n\n        <div class=\"padding\" ng-if=\"active=='transfers'\">\n          <p class=\"bold uppercase\">\n            {{'BALANCES'|translate}}\n          </p>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformname}} <br><span class=\"gray wrap\">{{'PROFILE_1'|translate:translationData }}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.balance | st | number}} {{$root.$storage.platformlunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformpower}} <br><span class=\"gray wrap\">{{'PROFILE_2'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.vesting_shares | sp | number}} {{$root.$storage.platformpunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{$root.$storage.platformdollar}} <br><span class=\"gray wrap\">{{'PROFILE_3'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{accounts.sbd_balance | sbd | number}} {{$root.$storage.platformdunit}}\n            </div>\n          </div>\n          <div class=\"row\">\n            <div class=\"col col-67\">\n            {{'ESTIMATED_VALUE'|translate}} <br><span class=\"gray wrap\">{{'PROFILE_4'|translate:translationData}}</span>\n            </div>\n            <div class=\"col col-33\">\n            {{$root.$storage.currency|getCurrencySymbol}} {{accounts.vesting_shares | sd:accounts.balance:accounts.sbd_balance | number}}\n            </div>\n          </div>\n          <p class=\"bold\">{{'TRANSACTION_HISTORY'|translate}}</p>\n          <div class=\"list list-inset\">\n            <div class=\"item\" ng-repeat=\"tr in transfers | orderBy:'-[0]' | limitTo:15 track by $index\">\n              <span>{{tr[1].timestamp | timeago}} - {{tr[1].op[0]}}</span>\n              <div ng-if=\"tr[1].op[0]=='comment_reward'\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='author_reward'\" class=\"wrap\">{{tr[1].op[1].sbd_payout}} | {{tr[1].op[1].steem_payout}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='curation_reward'\">{{tr[1].op[1].reward}} | {{tr[1].op[1].vesting_payout}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='interest'\">{{tr[1].op[1].interest}}</div>\n              <div ng-if=\"tr[1].op[0]=='transfer_to_vesting'\">{{tr[1].op[1].amount}} | {{tr[1].op[1].memo}}</div>\n              <div ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].vesting_shares}} | {{tr[1].op[1].memo}}</div>\n              <p ng-if=\"tr[1].op[0]=='comment_reward'\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='author_reward'\" class=\"wrap\">@{{tr[1].op[1].author}}/{{tr[1].op[1].permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='curation_reward'\" class=\"wrap\">@{{tr[1].op[1].comment_author}}/{{tr[1].op[1].comment_permlink}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer'\">{{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='transfer_to_vesting'\"> {{tr[1].op[1].from}} {{'TO'|translate}}  {{tr[1].op[1].to}}</p>\n              <p ng-if=\"tr[1].op[0]=='withdraw_vesting'\">{{tr[1].op[1].account}}</p>\n\n            </div>\n          </div>\n        </div>\n\n        <div class=\"box pink\" ng-if=\"active=='permissions'\">\n          <div class=\"list card\">\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'POSTING'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.posting.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.posting.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_5'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'OWNER'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.owner.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.owner.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_6'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'ACTIVE'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.active.key_auths[0][0]}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.active.key_auths[0][0]}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_7'|translate}}\n              </p>\n            </div>\n            <div class=\"item\">\n              <h2><div class=\"bold\">{{'MEMO'|translate}}</div></h2>\n              <p class=\"wrap\">{{$root.$storage.user.memo_key}}</p>\n            </div>\n            <div class=\"item item-body\">\n              <center><qrcode class=\"full-image\" text=\"{{$root.$storage.user.memo_key}}\"></qrcode></center>\n              <p>\n                {{'PROFILE_8'|translate}}\n              </p>\n            </div>\n          </div>\n        </div>\n    </div>\n    <script id = \"popoverPTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderrp.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          <div class=\"row\">\n              <div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n              <div class=\"col\">\n                <div class = \"item range range-positive\">\n             {{rangeValue}} <input type=\"range\" name=\"range2\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n                </div>\n              </div>\n              <div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSlider()\"></button></div>\n          </div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n  <div class=\"profile bar bar-footer\">\n    <div class=\"button-bar\">\n      <!--<a class=\"button button-large button-positive icon ion-ios-heart\" ng-class=\"{'active':active=='feed'}\" on-tap=\"change('feed')\">&nbsp;Feeds</a>-->\n      <a class=\"button button-large button-positive icon ion-compose\" ng-class=\"{'active':active=='blog'}\" on-tap=\"change('blog')\">&nbsp;{{'BLOG'|translate}}</a>\n      <a class=\"button button-positive icon ion-document-text\" ng-class=\"{'active':active=='posts'}\" on-tap=\"change('posts')\">&nbsp;{{'POSTS'|translate}}</a>\n      <a class=\"button button-positive icon ion-chatbubbles\" ng-class=\"{'active':active=='recent-replies'}\" on-tap=\"change('recent-replies')\">&nbsp;{{'REPLIES'|translate}}</a>\n      <a class=\"button button-positive icon ion-card\" ng-class=\"{'active':active=='transfers'}\"  on-tap=\"change('transfers')\">&nbsp;{{'WALLET'|translate}}</a>\n      <!--<a class=\"button button-royal icon ion-lock-combination\" ng-class=\"{'active':active=='permissions'}\" on-tap=\"change('permissions')\">Keys</a>-->\n    </div>\n  </div>\n  <script id=\"my-edit.html\" type=\"text/ng-template\">\n    <ion-modal-view>\n      <ion-header-bar class='bar-positive'>\n         <h1 class=\"title\">{{\"EDIT\"|translate}}</h1>\n         <button class=\"button button-clear button-outline\" ng-click=\"closeEdits()\">\n          {{\"CANCEL\"|translate}}\n        </button>\n      </ion-header-bar>\n      <ion-content class=\"has-header\">\n        <div class=\"list\">\n          <div class=\"item item-divider\">\n            {{\"PROFILE\"|translate}}\n          </div>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ABOUT'|translate}}</span>\n            <textarea placeholder=\"{{'ABOUT'|translate}}\" ng-model=\"edit.profile.about\"></textarea>\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'LOCATION'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'LOCATION'|translate}}\" ng-model=\"edit.profile.location\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'DISPLAY_NAME'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'DISPLAY_NAME'|translate}}\" ng-model=\"edit.profile.name\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'WEBSITE'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'WEBSITE'|translate}}\" ng-model=\"edit.profile.website\">\n          </label>\n          <div class=\"item item-divider\">\n            {{\"ESCROW\"|translate}}\n          </div>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_TERMS'|translate}}</span>\n            <input type=\"text\" placeholder=\"{{'ESCROW_TERMS'|translate}}\" ng-model=\"edit.escrow.terms\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_FEE'|translate}} </span>\n            <input type=\"text\" placeholder=\"{{$root.$storage.platformlunit}}\" ng-model=\"edit.escrow.fees[$root.$storage.platformlunit]\">\n          </label>\n          <label class=\"item item-input\">\n            <span class=\"input-label\">{{'ESCROW_FEE'|translate}} </span>\n            <input type=\"text\" placeholder=\"{{$root.$storage.platformdunit}}\" ng-model=\"edit.escrow.fees[$root.$storage.platformdunit]\">\n          </label><br>\n          <center>\n            <button class=\"button button-positive\" ng-click=\"saveEdit()\">\n            {{'SAVE_CHANGES'|translate}}\n            </button>\n          </center>\n      </div>\n      </ion-content>\n    </ion-modal-view>\n\n  </script>\n</ion-view>\n",
        controller: "ProfileCtrl"
      }
    }
  })

  .state('app.posts', {
    url: '/posts/:tags/:renew',
    params: {renew: true},
    views: {
      'menuContent': {
        //templateUrl: 'templates/posts.html',
        template: "<ion-view view-cache=\"false\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t<ion-nav-back-button>\n  \t\t</ion-nav-back-button>\n\t    <ion-nav-buttons side=\"left\">\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n\t      <a href class=\"button button-icon button-clear ion-navicon\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n\t    <ion-nav-title on-tap=\"showFilter()\">\n          <div class=\"page-title\">{{$root.$storage.filterName}} {{$root.$storage.tag}} &emsp; <i class=\"icon ion-arrow-down-b\"></i></div>\n        </ion-nav-title>\n\t    <ion-nav-buttons side=\"right\">\n\t      <!--<button class=\"button\" on-tap=\"testfunction()\">Test</button>-->\n\t      <button class=\"button button-icon ion-more\" ng-if=\"!$root.voiceOver\" on-tap=\"openMenuPopover($event)\"></button>\n\t      <a href class=\"button button-icon ion-more\" on-tap=\"openMenuPopover($event)\" ng-if=\"$root.voiceOver\">{{'OPTIONS'|translate}}</a>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-content class=\"has-header\" scroll=\"true\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t<ion-refresher pulling-text=\"{{'PULL_DOWN_TO_REFRESH'|translate}}\" on-refresh=\"refresh()\">\n  \t</ion-refresher>\n  \t\t<div ng-if=\"$root.$storage.view=='compact' && data.length>0\" class=\"masonry-layout\">\n\t    \t<div ng-repeat=\"d in data | regex:'category':'bm.*' track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list masonry-layout__panel-content\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t    \t<div class=\"item\">\n\t\t\t\t    <div on-tap=\"open(d)\">\n\t\t\t\t    <span ng-if=\"d.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{d.reblogged_by}}</span>\n\t\t\t\t    <p><h2 class=\"wrapword\"><i class=\"fa fa-money positive\" ng-if=\"d.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"d.percent_steem_dollars === 0\"></i> {{d.title}}</h2></p>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{d.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{d.author}}</b>&nbsp;<div class=\"reputation\">{{d.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{d.category|detransliterate:false}} &middot; {{d.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t    </div>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t    <div class=\"col\">\n\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event, d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!d.upvoted\" on-tap=\"votePost(d)\" on-hold=\"openSlider($event, d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!d.invoting\"></i>{{'UPVOTE'|translate}}</a><a href=\"#\" class=\"subdued\" ng-if=\"d.upvoted\" on-tap=\"unvotePost(d)\"><ion-spinner ng-if=\"d.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!d.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,d)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"d.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{d | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"d.max_accepted_payout.split(' ')[0] !== '0.000'\">{{d | sumPostTotal:$root.$storage.currencyRate | number}}</span></span></span>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(d)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{d.net_votes}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{d.children}}</a>\n\t\t\t\t      </div>\n\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(s.author, s.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t      </div>\n\t\t\t\t    </div>\n\t\t\t  \t</div>\n\t\t\t  </div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div ng-if=\"$root.$storage.view=='card' && data.length>0\" class=\"masonry-layout\">\n\t\t\t<div ng-repeat=\"ds in data | regex:'category':'bm.*' track by $index\" class=\"masonry-layout__panel\">\n\t    \t   <div class=\"list card masonry-layout__panel-content\" ng-if=\"ds\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\n\t\t\t\t<div class=\"item\" on-tap=\"open(ds)\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\">\n\t\t\t\t\t<span ng-if=\"ds.reblogged_by.length>0\"><i class=\"icon ion-arrow-return-right\"></i> {{'RESTEEMED_BY'|translate}} {{ds.reblogged_by}}</span>\n\t\t\t\t    <h2 class=\"wrapword\"><i class=\"fa fa-money positive\" ng-if=\"ds.promoted.split(' ')[0] !== '0.000'\"></i> <i class=\"fa fa-fire positive\" ng-if=\"ds.percent_steem_dollars === 0\"></i> {{ds.title}}</h2>\n\t\t\t\t    <div class=\"row postdetails wrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{ds.created|timeago}}&nbsp;{{'BY'|translate}}&nbsp;<b>{{ds.author}}</b>&nbsp;<div class=\"reputation\">{{ds.author_reputation|reputation|number:0}}</div> {{'IN'|translate}} {{ds.category|detransliterate:false}} &middot; {{ds.body|readingtime}} {{'MIN_READ'|translate}}</div></div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"item-body\">\n\t\t\t\t    <img class=\"full-image\" ng-src=\"{{ds.json_metadata.image[0]}}\" on-tap=\"open(ds)\" ng-if=\"ds.json_metadata.image[0]\" onerror=\"this.src='img/noimage.png'\"/>\n\t\t\t\t    <div class=\"row\">\n\t\t\t\t\t    <div class=\"col\">\n\t\t\t\t\t      <span ng-if=\"!$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event, ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i></a><a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner>\n\t\t\t\t\t\t\t\t\t<i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i></a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      <span ng-if=\"$root.voiceOver\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"!ds.upvoted\" on-tap=\"votePost(ds)\" on-hold=\"openSlider($event, ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg\" ng-if=\"!ds.invoting\"></i>{{'UPVOTE'|translate}}</a>\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" ng-if=\"ds.upvoted\" on-tap=\"unvotePost(ds)\"><ion-spinner ng-if=\"ds.invoting\"></ion-spinner><i class=\"fa fa-chevron-circle-up fa-lg positive\" ng-if=\"!ds.invoting\"></i>{{'UNVOTE'|translate}}</a>&nbsp;<span class=\"gray\" on-tap=\"openTooltip($event,ds)\">\n\t\t\t\t\t\t\t\t\t<b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if=\"ds.max_accepted_payout.split(' ')[0] === '0.000'\"><del>0.000</del></span><span ng-if=\"ds.max_accepted_payout.split(' ')[0] !== '0.000'\">{{ds | sumPostTotal:$root.$storage.currencyRate | number}}</span></span>\n\t\t\t\t\t      </span>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.openInfo(ds)\"><i class=\"icon ion-person-stalker\"></i>&nbsp;{{ds.net_votes}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-25 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\"><i class=\"icon ion-chatbubbles\"></i>&nbsp;{{ds.children}}</a>\n\t\t\t\t\t      </div>\n\t\t\t\t\t      <div class=\"col col-10 tright\">\n\t\t\t\t\t      <a href=\"#\" class=\"subdued\" on-tap=\"$root.reBlog(ds.author, ds.permlink)\"><i class=\"icon ion-arrow-return-right\"></i>&nbsp;</a>\n\t\t\t\t\t      </div>\n\t\t\t\t      </div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n    <ion-infinite-scroll ng-if=\"moreDataCanBeLoaded()\" on-infinite=\"loadMore()\" distance=\"15%\"></ion-infinite-scroll>\n    <br>\n    <script id = \"popoverT.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSlider.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content>\n          \t<div class=\"row\">\n          \t\t<div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n          \t\t<div class=\"col\">\n          \t\t\t<div class = \"item range range-positive\">\n\t\t\t\t\t   {{rangeValue}} <input type=\"range\" name=\"range1\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n\t\t\t\t\t</div>\n          \t\t</div>\n          \t\t<div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSlider()\"></button></div>\n          \t</div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostsCtrl'
      }
    }
  })

  .state('app.bookmark', {
    url: '/bookmark',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'BOOKMARKS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.bookmark\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.bookmark\" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.author}}</h2></p>\n        <p>{{item.permlink}}</p>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}</div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeBookmark($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray padding\" ng-if=\"$root.$storage.bookmark.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'BookmarkCtrl'
      }
    }
  })

	.state('app.drafts', {
    url: '/drafts',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'DRAFTS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"drafts\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in drafts\" ng-click=\"$root.openDraft(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'TAGS' | translate}}:&nbsp;<b>{{item.tags}}</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeDraft(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"drafts.length==0\">{{'NOTHING_HERE'|translate}}</p>\n\n  </ion-content>\n</ion-view>\n",
        controller: 'DraftsCtrl'
      }
    }
  })

	.state('app.images', {
    url: '/images',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'MANAGE' | translate}} {{'GALLERY' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"images\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in images\" class=\"item-thumbnail-left\">\n        <img ng-src=\"{{item.url}}\"/>\n        <p><h2>{{item.url}}</h2></p>\n\t\t\t  <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;</div></div>\n        <ion-option-button class=\"button-assertive\" ng-click=\"removeImage(item._id)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n\t\t    <ion-option-button class=\"button-calm\" ng-click=\"copyImage(item.url)\">{{'COPY' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n    <p class=\"tcenter gray\" ng-if=\"images.length>0\">{{'SWIPE_LEFT'|translate}}</p>\n    <p class=\"tcenter gray\" ng-if=\"images.length==0\">{{'NOTHING_HERE'|translate}}</p>\n  </ion-content>\n</ion-view>\n",
        controller: 'ImagesCtrl'
      }
    }
  })

  .state('app.notifications', {
    url: '/notifications',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"{{'NOTIFICATIONS' | translate}}\">\n  <ion-content class=\"has-header\">\n\t<ion-list ng-if=\"$root.$storage.notifications\" can-swipe=\"true\">\n  \t\t<ion-item ng-repeat=\"item in $root.$storage.notifications | orderBy: '-created' \" ng-click=\"$root.getContentAndOpen(item)\">\n\t\t    <p><h2>{{item.title}}</h2></p>\n\t\t    <span>{{item.message}}</span>\n\t\t    <div class=\"row postdetails twrap\"><div class=\"col\"><i class=\"icon ion-android-time\"></i> {{item.created|timeago}}&nbsp;{{'BY' | translate}}&nbsp;<b>{{item.author}}&nbsp;</b></div></div>\n\t\t    <ion-option-button class=\"button-assertive\" ng-click=\"removeNotification($index)\">{{'REMOVE' | translate}}\n\t\t    </ion-option-button>\n    \t</ion-item>\n    </ion-list>\n  </ion-content>\n</ion-view>\n",
        controller: 'NotificationsCtrl'
      }
    }
  })


  .state('app.post', {
    url: '/post/:category/:author/:permlink',
    views: {
      'menuContent': {
        //templateUrl: 'templates/post.html',
        template: "<ion-view view-title=\"\">\n\t<ion-nav-bar class=\"bar-positive\">\n\t\t  <ion-nav-back-button>\n    \t</ion-nav-back-button>\n\t    <ion-nav-buttons side='left'>\n\t      <button class=\"button button-icon button-clear ion-navicon\" ng-if=\"!$root.voiceOver\" menu-toggle=\"left\"></button>\n        <a href class=\"button button-icon ion-more\" ng-if=\"$root.voiceOver\" menu-toggle=\"left\">{{'MENU'|translate}}</a>\n\t    </ion-nav-buttons>\n      <ion-nav-title>\n      </ion-nav-title>\n\t    <ion-nav-buttons side='right'>\n      <span ng-if=\"!$root.voiceOver\">\n        <button class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i></button> &nbsp; \n\t      <button class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\"></button>\n      </span>\n      <span ng-if=\"$root.voiceOver\">\n        <a href class=\"button button-icon button-clear\" on-tap=\"bookmark()\"><i class=\"icon\" ng-class=\"{'ion-ios-bookmarks':isBookmarked(), 'ion-ios-bookmarks-outline':!isBookmarked()}\"></i>{{'BOOKMARK'|translate}}</a> &nbsp; \n        <a href class=\"button button-icon button-clear ion-android-share-alt\" on-tap=\"share()\">{{'SHARE'|translate}}</a>\n      </span>\n\t    </ion-nav-buttons>\n\t</ion-nav-bar>\n  <ion-floating-menu menu-color=\"#387ef5\" menu-open-color=\"#387ef5\" has-footer=\"true\">\n    <ion-floating-item icon=\"ion-chatbubbles\" click=\"isreplying($root.$storage.sitem, true)\" ng-if=\"$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REPLY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-android-arrow-dropup-circle\" click=\"upvotePost($root.$storage.sitem)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'UPVOTE'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-edit\" click=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.author==$root.$storage.user.username\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'EDIT'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-image\" click=\"showImages(0)\" ng-if=\"isImages()\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'GALLERY'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n    <ion-floating-item icon=\"ion-arrow-return-right\" ng-if=\"$root.$storage.user.username !== $root.$storage.sitem.author\" click=\"$root.reBlog($root.$storage.sitem.author, $root.$storage.sitem.permlink)\" button-color=\"#387ef5\" icon-color=\"#fff\" text=\"{{'REBLOG'|translate}}\" text-class=\"text-class\"></ion-floating-item>\n  </ion-floating-menu>\n  <ion-content class=\"padding has-header\" delegate-handle=\"mainScroll\" overflow-scroll=\"true\" ng-class=\"{'theme-dark':$root.$storage.theme == 'night'}\"><!---->\n    <div ng-if='$root.$storage.sitem'>\n      <p class=\"title h3\" ng-if=\"$root.$storage.sitem.root_title && $root.$storage.sitem.title==''\"><a href=\"#/app/post{{$root.$storage.sitem.url.split('#')[0]}}\">{{\"VIEW_CONTEXT\"|translate}}</a></p>\n    \t<p class=\"title h3\">{{$root.$storage.sitem.title}}</p>\n    \t<div class=\"stitle row gray\"><div class=\"col\">\n        <img class=\"round-avatar\" src=\"img/user_profile.png\" ng-src=\"{{$root.$storage.paccounts[$root.$storage.sitem.author].user_image||$root.$storage.paccounts[$root.$storage.sitem.author].profile.profile_image}}\" onerror=\"this.src=\\'img/user_profile.png\\'\" onabort=\"this.src=\\'img/user_profile.png\\'\" /> <b><a href=\"#/app/profile/{{$root.$storage.sitem.author}}\">{{$root.$storage.sitem.author}}</a></b>&nbsp;<div class=\"reputation\">{{$root.$storage.sitem.author_reputation|reputation|number:0}}</div>&middot;{{$root.$storage.sitem.created|timeago}} {{'IN'|translate}}&nbsp;{{$root.$storage.sitem.category|detransliterate:false}}</div><div class=\"pull-right\"><span ng-if=\"$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\">{{'DOWNVOTE'|translate}}</i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\">{{'UNVOTE_DOWNVOTED'|translate}}</i></span><span ng-if=\"!$root.voiceOver\"><i class=\"fa fa-flag\" on-tap=\"downvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.downvoted\"></i><i class=\"fa fa-flag positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.downvoted\"></i></span></div></div>\n    \t<br><!---->\n      <div class=\"bodytext selectable\" ng-bind-html=\"$root.$storage.sitem.body | parseUrl \">\n      </div>\n\n      <div ng-if='$root.$storage.sitem.json_metadata.tags' class=\"tags\">\n        <div ng-repeat='tag in $root.$storage.sitem.json_metadata.tags'>\n          <span><div class=\"tag\" on-tap=\"openTag(tag, 5)\">{{tag|detransliterate:false}}</div></li>\n        </div>\n      </div>\n\n      <div class=\"row gray\">\n        <div class=\"col col-33\" ng-if=\"!$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"fa fa-chevron-circle-up fa-lg\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\" on-hold=\"openSliderr($event, $root.$storage.sitem)\"></i><i class=\"fa fa-chevron-circle-up fa-lg positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted && !$root.$storage.sitem.invoting\"></i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n\n        <div class=\"col col-33\" ng-if=\"$root.voiceOver\"><ion-spinner ng-if=\"$root.$storage.sitem.invoting\"></ion-spinner>\n        <i class=\"icon ion-android-arrow-dropup-circle\" on-tap=\"upvotePost($root.$storage.sitem)\" ng-if=\"!$root.$storage.sitem.upvoted\" on-hold=\"openSliderr($event, $root.$storage.sitem)\">{{'UPVOTE'|translate}}</i><i class=\"icon ion-android-arrow-dropup-circle positive\" on-tap=\"unvotePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.upvoted\">{{'UNVOTE_UPVOTED'|translate}}</i>&nbsp;&nbsp;&nbsp;<span on-tap=\"$root.openInfo($root.$storage.sitem)\">{{$root.$storage.sitem.net_votes}}</span></div>\n        <div class=\"col col-33\" on-tap=\"openTooltip($event,$root.$storage.sitem)\"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> {{$root.$storage.sitem | sumPostTotal:$root.$storage.currencyRate | number}}</div>\n        <div class=\"col\" on-tap=\"isreplying($root.$storage.sitem, true)\"><i class=\"fa fa-reply\"></i> {{$root.$storage.sitem.children}}</div>\n        <div class=\"col\" on-tap=\"editPost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa  fa-pencil-square-o\"></i></div>\n        <div class=\"col\" on-tap=\"deletePost($root.$storage.sitem)\" ng-if=\"$root.$storage.sitem.net_votes==0 && $root.$storage.sitem.author==$root.$storage.user.username\"><i class=\"fa fa-trash-o\"></i></div>\n      </div>\n      <center><button class=\"button button-positive button-outline button-icon ion-refresh icon-right\" on-tap=\"fetchComments($root.$storage.sitem.author, $root.$storage.sitem.permlink)\"><ion-spinner class=\"spinner-positive\" ng-if=\"$root.fetching\"></ion-spinner> {{\"COMMENTS\"|translate}}</button></center>\n      <br>\n      <div class=\"my-handle\"></div>\n      \n      <ion-thread comments=\"comments\"></ion-thread>\n    </div>\n    <script id = \"popoverTr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedPost\">\n        <ion-content>\n          <div class=\"padding\" ng-bind-html=\"tooltipText\"></div>\n        </ion-content>\n      \n      </ion-popover-view>\n    </script>\n    <script id = \"popoverSliderr.html\" type=\"text/ng-template\">\n      <ion-popover-view class=\"detailedSlide\">\n        <ion-content class=\"padding\">\n          <div class=\"row\">\n              <div class=\"col col-10\"><button class=\"button button-icon fa fa-chevron-circle-up fa-lg\" on-tap=\"votePostS()\"></button></div>\n              <div class=\"col\">\n                <div class = \"item range range-positive\">\n             {{rangeValue}} <input type=\"range\" name=\"range2\" min=\"1\" max=\"100\" ng-model=\"rangeValue\" ng-change=\"drag(rangeValue)\">\n                </div>\n              </div>\n              <div class=\"col col-10\"><button class=\"button button-icon ion-close-round\" ng-click=\"closeSliderr()\"></button></div>\n          </div>\n        </ion-content>\n      </ion-popover-view>\n    </script>\n  </ion-content>\n</ion-view>\n",
        controller: 'PostCtrl'
      }
    }
  });
  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/app/posts//true');
  $ionicConfigProvider.navBar.alignTitle('left')
  $ionicConfigProvider.backButton.text('').icon('ion-chevron-left');
  $ionicConfigProvider.views.swipeBackEnabled(false);
  $ionicConfigProvider.views.maxCache(3);

  $animateProvider.classNameFilter( /\banimated\b/ );
  $ionicConfigProvider.scrolling.jsScrolling(false);

  if (window.cordova) {
      $logProvider.debugEnabled(false);
      $compileProvider.debugInfoEnabled(false);
  }

  $translateProvider.translations('en-US', require('./locales/ready/en')); //English
  $translateProvider.translations('ru-RU', require('./locales/ready/ru-RU')); //Russian
  $translateProvider.translations('de-DE', require('./locales/ready/de-DE')); //German
  $translateProvider.translations('fr-FR', require('./locales/ready/fr-FR')); //French
  $translateProvider.translations('es-ES', require('./locales/ready/es-ES')); //Spanish
  $translateProvider.translations('el-GR', require('./locales/ready/el-GR')); //Greek
  $translateProvider.translations('bg-BG', require('./locales/ready/bg-BG')); //Bulgarian
  $translateProvider.translations('nl-NL', require('./locales/ready/nl-NL')); //Dutch
  $translateProvider.translations('hu-HU', require('./locales/ready/hu-HU')); //Hungarian
  $translateProvider.translations('cs-CZ', require('./locales/ready/cs-CZ')); //Czech
  $translateProvider.translations('he-IL', require('./locales/ready/he-IL')); //Hebrew
  $translateProvider.translations('pl-PL', require('./locales/ready/pl-PL')); //Polish
  $translateProvider.translations('pt-PT', require('./locales/ready/pt-PT')); //Portuguese
  $translateProvider.translations('pt-BR', require('./locales/ready/pt-BR')); //Portuguese Brazil
  $translateProvider.translations('id-ID', require('./locales/ready/id-ID')); //Indonesian
  $translateProvider.translations('zh-TW', require('./locales/ready/zh-TW')); //Chinese traditional
  $translateProvider.translations('zh-CN', require('./locales/ready/zh-CN')); //Chinese simplified
  $translateProvider.translations('dolan', require('./locales/ready/dolan')); //Dolan
  $translateProvider.translations('sv-SE', require('./locales/ready/sv-SE')); //Chinese simplified
  $translateProvider.translations('uk-UA', require('./locales/ready/uk-UA')); //Ukrainian
  $translateProvider.translations('ms-MY', require('./locales/ready/ms-MY')); //Malay
  $translateProvider.translations('hr-HR', require('./locales/ready/hr-HR')); //Croatian
  $translateProvider.translations('fa-IR', require('./locales/ready/fa-IR')); //Persian
  $translateProvider.translations('it-IT', require('./locales/ready/it-IT')); //Italian
  $translateProvider.translations('fil-PH', require('./locales/ready/fil-PH')); //Filipino
  $translateProvider.translations('ar-SA', require('./locales/ready/ar-SA')); //Arabic

  $translateProvider.useSanitizeValueStrategy(null);

  $translateProvider.preferredLanguage('en-US');
  $translateProvider.fallbackLanguage('en-US');

});

app.run(function($ionicPlatform, $rootScope, $localStorage, $interval, $ionicPopup, $ionicLoading, $cordovaSplashscreen, $ionicModal, $timeout, $cordovaToast, APIs, $state, $log, $ionicScrollDelegate, $filter, $translate) {
  $rootScope.$storage = $localStorage;
  $rootScope.log = function(message) {
    $log.info(message);
  };

  $ionicPlatform.registerBackButtonAction(function (event) {
  if ( ($state.$current.name=="app.posts") ){
          // H/W BACK button is disabled for these states (these views)
          // Do not go to the previous state (or view) for these states. 
          // Do nothing here to disable H/W back button.
      } else {
          // For all other states, the H/W BACK button is enabled
          navigator.app.backHistory();
      }
  }, 100);
  $ionicPlatform.ready(function() {
    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
    // for form inputs)
    if (window.cordova && window.cordova.plugins.Keyboard) {
      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
      cordova.plugins.Keyboard.disableScroll(true);
    }
    if (window.StatusBar) {
      // org.apache.cordova.statusbar required
      StatusBar.styleDefault();
    }
    if (!$rootScope.$storage.users) {
      $rootScope.$storage.users = [];
    }
    
    if (!$rootScope.$storage.theme) {
      $rootScope.$storage.theme = 'day';
    }

    if (!$rootScope.$storage.socketgolos)
      $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
    if (!$rootScope.$storage.socketsteem)
      $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";

    window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);

    if (!angular.isDefined($rootScope.$storage.language)) {
      if(typeof navigator.globalization !== "undefined") {
          navigator.globalization.getPreferredLanguage(function(language) {
              $translate.use(language.value).then(function(data) {
                  console.log("SUCCESS -> " + data);
                  if (language.value.indexOf("en") == 0) {
                    $rootScope.$storage.language = 'en';            
                  }
                  $rootScope.$storage.language = language.value;
              }, function(error) {
                  console.log("ERROR -> " + error);
              });
          }, null);
      } else {
        $rootScope.$storage.language = 'en';
      }
    } else {
      $translate.use($rootScope.$storage.language);
    }
    if (!$rootScope.$storage.chain){
      $rootScope.$storage.platformname = "Steem";
      $rootScope.$storage.platformpower = "Steem Power";
      $rootScope.$storage.platformsunit = "Steem";
      $rootScope.$storage.platformdollar = "Steem Dollar";
      $rootScope.$storage.platformdunit = "SBD";
      $rootScope.$storage.platformpunit = "SP";
      $rootScope.$storage.platformlunit = "STEEM";
      $rootScope.$storage.chain = "steem";
      $rootScope.$storage.currency = "usd";
      $rootScope.$storage.currencyRate = 1;
    }
    $rootScope.$storage.languages = [
      {id:'en', name: 'English'}, 
      {id:'es-ES', name: 'Espaol'}, 
      {id:'el-GR', name: ''}, 
      {id:'fr-FR', name: 'Franais'}, 
      {id:'de-DE', name: 'Deutsch'}, 
      {id:'ru-RU', name: ''}, 
      {id:'bg-BG', name: ''}, 
      {id:'nl-NL', name: 'Nederlands'}, 
      {id:'hu-HU', name: 'Magyar'}, 
      {id:'cs-CZ', name: 'etina'}, 
      {id:'he-IL', name: ''}, 
      {id:'pl-PL', name: 'Polski'}, 
      {id:'pt-PT', name: 'Portugus'}, 
      {id:'pt-BR', name: 'Portugus BR'},
      {id:'sv-SE', name: 'Svensk'},
      {id:'id-ID', name: 'Bahasa Indonesia'}, 
      {id:'zh-CN', name: ''}, 
      {id:'zh-TW', name: ''},
      {id:'dolan', name: 'Dolan'},
      {id:'uk-UA', name: ''},
      {id:'ms-MY', name: 'Bahasa Melayu'},
      {id:'hr-HR', name: 'Hrvatski'},
      {id:'fa-IR', name: 'Frsi'},
      {id:'it-IT', name: 'Italiano'},
      {id:'fil-PH', name: 'Wikang Filipino'},
      {id:'ar-SA', name: ''}
      
    ];
    if (!$rootScope.$storage.dir) {
      $rootScope.$storage.dir = 'ltr';
    }
    $rootScope.$storage.chains = [{id:'steem', name: 'Steem'}, {id:'golos', name: 'Golos'}];

    if (!$rootScope.$storage.currencies) {
      $rootScope.$storage.currencies = [
        {id:'btc', name: 'BTC', rate: 0, date: "1/1/2016"}, 
        {id:'usd', name: 'USD', rate: 0, date: "1/1/2016"}, 
        {id:'eur', name: 'EUR', rate: 0, date: "1/1/2016"}, 
        {id:'rub', name: 'RUB', rate: 0, date: "1/1/2016"}, 
        {id:'gbp', name: 'GBP', rate: 0, date: "1/1/2016"}, 
        {id:'jpy', name: 'JPY', rate: 0, date: "1/1/2016"}, 
        {id:'krw', name: 'KRW', rate: 0, date: "1/1/2016"}, 
        {id:'inr', name: 'INR', rate: 0, date: "1/1/2016"}, 
        {id:'cny', name: 'CNY', rate: 0, date: "1/1/2016"}, 
        {id:'uah', name: 'UAH', rate: 0, date: "1/1/2016"}, 
        {id:'sek', name: 'SEK', rate: 0, date: "1/1/2016"}, 
        {id:'try', name: 'TRY', rate: 0, date: "1/1/2016"},
        {id:'cad', name: 'CAD', rate: 0, date: "1/1/2016"},
        {id:'chf', name: 'CHF', rate: 0, date: "1/1/2016"},
        {id:'aud', name: 'AUD', rate: 0, date: "1/1/2016"},
        {id:'nok', name: 'NOK', rate: 0, date: "1/1/2016"},
        {id:'pln', name: 'PLN', rate: 0, date: "1/1/2016"},
        {id:'php', name: 'PHP', rate: 0, date: "1/1/2016"}
      ];
    } else {
      if (!$rootScope.$storage.addition) {
        $rootScope.$storage.addition = [
          {id:'cad', name: 'CAD', rate: 0, date: "1/1/2016"},
          {id:'chf', name: 'CHF', rate: 0, date: "1/1/2016"},
          {id:'aud', name: 'AUD', rate: 0, date: "1/1/2016"},
          {id:'nok', name: 'NOK', rate: 0, date: "1/1/2016"},
          {id:'pln', name: 'PLN', rate: 0, date: "1/1/2016"},
          {id:'php', name: 'PHP', rate: 0, date: "1/1/2016"}];
        $rootScope.$storage.currencies = $rootScope.$storage.currencies.concat($rootScope.$storage.addition);
      }
    }

    if (window.cordova) {
      if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {
        MobileAccessibility.isVoiceOverRunning(function(bool) {
          if (bool) {
              $rootScope.log("Screen reader: ON");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('center');
          } else {
              $rootScope.log("Screen reader: OFF");
              $rootScope.voiceOver = bool;
              //$ionicConfigProvider.navBar.alignTitle('left');
          }
        });

      } else {
        $rootScope.voiceOver = false;
      }
    } else {
      $rootScope.voiceOver = false;
    }

    if (!$rootScope.$storage.view) {
      $rootScope.$storage.view = 'compact';
    }
    if (!$rootScope.$storage.filter) {
      $rootScope.$storage.filter = "trending";
    }
    if (navigator.splashscreen) {
      setTimeout(function() {
        navigator.splashscreen.hide();
      }, 1000);
    }
    $rootScope.log("app start ready");
    setTimeout(function() {
      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }
    }, 1000);
    $rootScope.showAlert = function(title, msg) {
      var alertPopup = $ionicPopup.alert({
        title: title,
        template: msg
      });
      if (msg.indexOf("error")>-1) {
        //window.Api.initPromise.then(function(response) {
        $rootScope.log("broadcast error");
        //});
      }
      return alertPopup/*.then(function(res) {
        $rootScope.log('Thank you ...');
      });*/
    };
    $rootScope.showMessage = function(title, msg) {
      if (title) {
        if (window.cordova) {
          $cordovaToast.showLongBottom(title+": "+msg).then(function(success) {
            // success
            $rootScope.log("toast"+success);
          }, function (error) {
            // error
            $rootScope.log("toast"+error);
          });
        } else {
          $rootScope.showAlert(title, msg);
        }
      }
    };
    $rootScope.$on('show:loading', function(event, args){
      $rootScope.log('show:loading');
      $ionicLoading.show({
        noBackdrop : true,
        template: '<ion-spinner icon="ripple" class="spinner-energized"></ion-spinner>'
      });
    });
    $rootScope.$on('hide:loading', function(event, args){
      $rootScope.log('hide:loading');
      setTimeout(function() {
        $ionicLoading.hide();
      }, 1000);
    });

    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams){
      $rootScope.log("from "+fromState.name+" to "+toState.name);
    });

    $ionicPlatform.on('resume', function(){
      $rootScope.log("app resume");
      var steemRPC = require("steem-rpc");
      if (localStorage.getItem("socketUrl") === null) {
        localStorage.setItem("socketUrl", "wss://steemd.steemit.com");
      }
      window.Api = steemRPC.Client.get({url:localStorage.socketUrl}, true);
      //window.steemJS = require("steemjs-lib");
      //window.golosJS = require("golosjs-lib");

      //if (!angular.isDefined($rootScope.timeint)) {
      window.Api.initPromise.then(function(response) {
        $rootScope.log("Api ready state change: "+angular.toJson(response));
        $rootScope.timeint = $interval(function(){
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(response){
            $rootScope.log("get_dynamic_global_properties " + response.head_block_number);
          });
        }, 15000);
      });
      //}
      /*window.FirebasePlugin.onNotificationOpen(function(data) {
        $rootScope.log(angular.toJson(data));
        if(data.tap){
          //Notification was received on device tray and tapped by the user.
          //console.log(JSON.stringify(data));
          if (data.author && data.permlink) {
            if (!$rootScope.$storage.pincode) {

              var alertPopup = $ionicPopup.confirm({
                title: data.title,
                template: data.body + $filter('translate')('OPENING_POST')
              });

              alertPopup.then(function(res) {
                $rootScope.log('Thank you for seeing alert from tray');
                if (res) {
                  setTimeout(function() {
                    $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                  }, 10);
                } else {
                  $rootScope.log("not sure to open alert");
                }
              });

            } else {
              $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
              $rootScope.pinenabled = true;
            }
          }
        } else{
          //Notification was received in foreground. Maybe the user needs to be notified.
          //alert( JSON.stringify(data) );
          if (data.author && data.permlink) {
            $rootScope.showMessage(data.title, data.body+" "+data.permlink);
          } else {
            $rootScope.showMessage(data.title, data.body);
          }
        }
      }, function(error) {
          console.error(error);
      });*/

      if ($rootScope.$storage.pincode) {
        $rootScope.pincheck = true;
        $rootScope.$broadcast("pin:check");
      }

      if (window.cordova) {
        if (ionic.Platform.isIPad() || ionic.Platform.isIOS()) {

          MobileAccessibility.isVoiceOverRunning(function(bool) {
            if (bool) {
                $rootScope.log("Screen reader: ON");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('center');
            } else {
                $rootScope.log("Screen reader: OFF");
                $rootScope.voiceOver = bool;
                //$ionicConfigProvider.navBar.alignTitle('left');
            }
          });
        } else {
          $rootScope.voiceOver = false;
        }
      } else {
        $rootScope.voiceOver = false;
      }

    });
    $ionicPlatform.on('pause', function(){
      $rootScope.log("app pause");
      if (angular.isDefined($rootScope.timeint)) {
        $rootScope.log("cancel interval");
        $interval.cancel($rootScope.timeint);
        $rootScope.timeint = undefined;
        window.Api.close();
      }
    });

    $ionicPlatform.on('offline', function(){
      $rootScope.log("app offline");
    });

    $rootScope.init = function() {
      $rootScope.passcode = "";
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    };

    $rootScope.add = function(value) {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length < 4) {
        $rootScope.passcode = $rootScope.passcode + value;
        if($rootScope.passcode.length == 4) {
          $timeout(function() {
            $rootScope.log("PIN "+$rootScope.passcode);
            if ($rootScope.pintype == 3) {
              if ($rootScope.$storage.pincode == $rootScope.passcode) {
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('NOT_MATCH')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.pincode = undefined;
                  $rootScope.pintry = 0;
                  $rootScope.$broadcast("pin:failed");
                  $rootScope.closePin();
                }
              }
            }
            if ($rootScope.pintype == 0) {
              $rootScope.log("type 0: set pin");
              if ($rootScope.$storage.pincode) {
                $rootScope.pincheck = true;
                $rootScope.$broadcast("pin:check");
                $rootScope.closePin();
              } else {
                $rootScope.$storage.pincode = $rootScope.passcode;
                $rootScope.pinsubtitle = $filter('translate')('CONFIRM_PIN');
                $rootScope.passcode = "";
                $rootScope.pintype = 3;
                $rootScope.pintry = 0;
              }
            }
            if ($rootScope.pintype == 1) {
              $rootScope.log("type 1: check pin");
              if ($rootScope.$storage.pincode == $rootScope.passcode){
                $rootScope.$broadcast('pin:correct');
                $rootScope.passcode = "";
                $rootScope.closePin();
              } else {
                $rootScope.pintry += 1;
                $rootScope.pinerror = $filter('translate')('INCORRECT')+"("+$rootScope.pintry+")";
                if ($rootScope.pintry>3) {
                  $rootScope.$storage.$reset();
                  $rootScope.closePin();
                }
              }
            }

          }, 50);
        }
      }
    };

    $rootScope.delete = function() {
      $rootScope.pinerror = "";
      if($rootScope.passcode.length > 0) {
        $rootScope.passcode = $rootScope.passcode.substring(0, $rootScope.passcode.length - 1);
      }
    }

    $ionicModal.fromTemplateUrl('templates/pincode.html', {
      scope: $rootScope
    }).then(function(modal) {
      $rootScope.pinmodal = modal;
    });
    $rootScope.closePin = function() {
      $rootScope.pinmodal.hide();
      if ($rootScope.pinenabled) {
        if ($rootScope.$storage.notifData) {
          var alertPopup = $ionicPopup.confirm({
            title: $rootScope.$storage.notifData.title,
            template: $rootScope.$storage.notifData.body + $filter('translate')('OPENING_POST')
          });
          alertPopup.then(function(res) {
            $rootScope.log('Thank you for seeing alert from tray');
            if (res) {
              $rootScope.getContentAndOpen({author:$rootScope.$storage.notifData.author, permlink:$rootScope.$storage.notifData.permlink});
              $rootScope.$storage.notifData = undefined;
            } else {
              $rootScope.log("not sure to open alert");
              $rootScope.$storage.notifData = undefined;
            }
            $rootScope.pinenabled = false;
          });
        }
      }
    };
    $rootScope.openPin = function(type) {
      $rootScope.passcode = "";
      if (type == 0) {
        $rootScope.pintype = 0;
        $rootScope.pintitle = $filter('translate')('SET_PIN');
        $rootScope.pinsubtitle = $filter('translate')('SET_PIN');
      }
      if (type == 1) {
        $rootScope.pintype = 1;
        $rootScope.pintry = 0;
        $rootScope.pintitle = $filter('translate')('ENTER_PIN');
        $rootScope.pinsubtitle = $filter('translate')('ENTER_PIN');
      }
      $rootScope.pinmodal.show();
    };
    $rootScope.$on("pin:new", function(){
      $rootScope.pincheck = false;
      $rootScope.openPin(0);
    });
    $rootScope.$on("pin:check", function(){
      $rootScope.pincheck = true;
      $rootScope.openPin(1);
    });


    $ionicModal.fromTemplateUrl('templates/info.html', {
      scope: $rootScope
      //animation: "null"
    }).then(function(modal) {
      $rootScope.infomodal = modal;
    });
    $rootScope.openInfo = function(xx) {
      if (xx.active_votes.length==0) {
        window.Api.database_api().exec("get_active_votes", [xx.author, xx.permlink]).then(function(dd){
          xx.active_votes = dd;
        });
      }
      $rootScope.voters = xx;
      $rootScope.infomodal.show();
    };

    $rootScope.closeInfo = function() {
      $rootScope.infomodal.hide();
      //$rootScope.infomodal.remove();
    };

    String.prototype.replaceAt=function(index, character) {
        return this.substr(0, index) + character + this.substr(index+character.length);
    }
		$rootScope.openDraft = function(item){
			item.operation_type = item.post_type;
			$rootScope.$storage.spost = item;
			$state.go('app.posts');
			$rootScope.$broadcast('openPostModal');
		}
    $rootScope.getContentAndOpen = function(item) {

      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_content", [item.author, item.permlink]).then(function(result){
          var _len = result.active_votes.length;
          for (var j = _len - 1; j >= 0; j--) {
            if (result.active_votes[j].voter === $rootScope.$storage.user.username) {
              if (result.active_votes[j].percent > 0) {
                result.upvoted = true;
              } else if (result.active_votes[j].percent < 0) {
                result.downvoted = true;
              } else {
                result.downvoted = false;
                result.upvoted = false;
              }
            }
          }
          result.json_metadata = angular.fromJson(result.json_metadata);
          var item = result;
          $rootScope.$storage.sitem = item;
          setTimeout(function() {
            //$state.go('app.post');
            $state.go('app.post', {category: item.category, author: item.author, permlink: item.permlink});

          }, 5);

          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      });
      $rootScope.$broadcast('hide:loading');
    };

    $rootScope.reBlog = function(author, permlink) {
      var confirmPopup = $ionicPopup.confirm({
        title: $filter('translate')('ARE_YOU_SURE'),
        template: $filter('translate')('REBLOG_TEXT')
      });
      confirmPopup.then(function(res) {
        if(res) {
          $rootScope.log('You are sure');
          $rootScope.$broadcast('show:loading');
          if ($rootScope.$storage.user) {
              $rootScope.mylogin = new window.ejs.Login();
              $rootScope.mylogin.setRoles(["posting"]);
              var loginSuccess = $rootScope.mylogin.checkKeys({
                  accountName: $rootScope.$storage.user.username,
                  password: $rootScope.$storage.user.password || null,
                  auths: {
                      posting: $rootScope.$storage.user.posting.key_auths
                  },
                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                }
              );
              if (loginSuccess) {
                var tr = new window.ejs.TransactionBuilder();
                var json;

                json = ["reblog",{account:$rootScope.$storage.user.username, author:author, permlink:permlink}];

                tr.add_type_operation("custom_json", {
                  id: 'follow',
                  required_posting_auths: [$rootScope.$storage.user.username],
                  json: JSON.stringify(json)
                });
                localStorage.error = 0;
                tr.process_transaction($rootScope.mylogin, null, true);

                setTimeout(function() {
                  if (localStorage.error == 1) {
                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('REBLOG_TEXT')+" "+localStorage.errormessage)
                  } else {
                    //$scope.refreshFollowers();
                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('REBLOGGED_POST'));
                  }
                  $rootScope.$broadcast('hide:loading');
                }, 3000);
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
            $rootScope.$broadcast('hide:loading');
          } else {
            $rootScope.$broadcast('hide:loading');
            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
          }
        } else {
          $rootScope.log('You are not sure');
        }
      });
    };

    $rootScope.votePost = function(post, type, afterward) {
      post.invoting = true;
      var tt = 1;
      if (type === "upvote") {
        tt = 1;
      }
      if (type === "downvote") {
        tt = -1;
      }
      if (type === "unvote") {
        tt = 0;
      }
      $rootScope.log('voting '+tt);
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
      if ($rootScope.$storage.user) {
        window.Api.initPromise.then(function(response) {
          $rootScope.log("Api ready:" + angular.toJson(response));
          var mylogin = new window.ejs.Login();
          mylogin.setRoles(["posting"]);
          //console.log($rootScope.$storage.user);
          var loginSuccess = mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window.ejs.TransactionBuilder();
            tr.add_type_operation("vote", {
                voter: $rootScope.$storage.user.username,
                author: post.author,
                permlink: post.permlink,
                weight: $rootScope.$storage.voteWeight*tt || 10000*tt
            });
            localStorage.error = 0;
            tr.process_transaction(mylogin, null, true);  

            setTimeout(function() {
              post.invoting = false;
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
								if (tt>0){
									post.upvoted = true;
								} else if (tt<0) {
									post.downvoted = true;
								} else {
									post.upvoted = false;
									post.downvoted = false;
								}
                if (afterward === 'fetchContent') {
                  $rootScope.$broadcast(afterward, { any: {author: post.author, permlink: post.permlink} });
                } else {
                  $rootScope.$broadcast(afterward);
                }
              }
              $rootScope.$broadcast('hide:loading');

            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
            $rootScope.$broadcast('hide:loading');
            post.invoting = false;
          }
          $rootScope.$broadcast('hide:loading');
          if (!$rootScope.$$phase) {
            $rootScope.$apply();
          }
        });
      } else {
        $rootScope.$broadcast('hide:loading');
        post.invoting = false;
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    $rootScope.isWitnessVoted = function() {
      if ($rootScope.$storage.user && $rootScope.$storage.user.witness_votes.indexOf("good-karma")>-1) {
        return true;
      } else {
        return false;
      }
    };
    $rootScope.voteWitness = function() {
        var confirmPopup = $ionicPopup.confirm({
          title: $filter('translate')('ARE_YOU_SURE'),
          template: $filter('translate')('VOTE_FOR_WITNESS')+" @good-karma"
        });
        confirmPopup.then(function(res) {
          if(res) {
            $rootScope.log('You are sure');
            $rootScope.$broadcast('show:loading');
            if ($rootScope.$storage.user) {
              if ($rootScope.$storage.user.password || $rootScope.$storage.user.privateActiveKey) {
                $rootScope.mylogin = new window.ejs.Login();
                $rootScope.mylogin.setRoles(["active"]);
                var loginSuccess = $rootScope.mylogin.checkKeys({
                    accountName: $rootScope.$storage.user.username,
                    password: $rootScope.$storage.user.password || null,
                    auths: {
                        active: $rootScope.$storage.user.active.key_auths
                    },
                    privateKey: $rootScope.$storage.user.privateActiveKey || null
                  }
                );
                if (loginSuccess) {
                  var tr = new window.ejs.TransactionBuilder();
                  tr.add_type_operation("account_witness_vote", {
                      account: $rootScope.$storage.user.username,
                      approve: true,
                      witness: "good-karma"
                  });
                  localStorage.error = 0;

                  tr.process_transaction($rootScope.mylogin, null, true);

                  setTimeout(function() {
                    if (localStorage.error === 1) {
                      $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                    } else {
                      //$scope.refreshFollowers();
                      $rootScope.showMessage($filter('translate')('SUCCESS'),$filter('translate')('VOTED_FOR_WITNESS')+' @good-karma');
                      $rootScope.$broadcast('refreshLocalUserData');
                    }
                  }, 3000);
                } else {
                  $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                }
              } else {
                $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
              }
              $rootScope.$broadcast('hide:loading');
            } else {
              $rootScope.$broadcast('hide:loading');
              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
            }
          } else {
            $rootScope.log('You are not sure');
          }
        });
    };

    $rootScope.following = function(xx, mtype) {
      $rootScope.$broadcast('show:loading');
      $rootScope.log(xx);
      if ($rootScope.$storage.user) {
          $rootScope.mylogin = new window.ejs.Login();
          $rootScope.mylogin.setRoles(["posting"]);
          var loginSuccess = $rootScope.mylogin.checkKeys({
              accountName: $rootScope.$storage.user.username,
              password: $rootScope.$storage.user.password || null,
              auths: {
                  posting: $rootScope.$storage.user.posting.key_auths
              },
              privateKey: $rootScope.$storage.user.privatePostingKey || null
            }
          );
          if (loginSuccess) {
            var tr = new window.ejs.TransactionBuilder();
            var json;
            if (mtype === "follow") {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: ["blog"]}];
            } else {
              json = ['follow',{follower:$rootScope.$storage.user.username, following:xx, what: []}];
            }

            tr.add_type_operation("custom_json", {
              id: 'follow',
              required_posting_auths: [$rootScope.$storage.user.username],
              json: angular.toJson(json)
            });
            localStorage.error = 0;
            tr.process_transaction($rootScope.mylogin, null, true);

            setTimeout(function() {
              if (localStorage.error == 1) {
                $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
              } else {
                //$scope.refreshFollowers();
                $rootScope.$broadcast('current:reload');
              }
            }, 3000);
          } else {
            $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
          }
        $rootScope.$broadcast('hide:loading');
      } else {
        $rootScope.$broadcast('hide:loading');
        $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
      }
    };

    setTimeout(function() {
      window.Api.initPromise.then(function(response) {
        window.Api.database_api().exec("get_feed_history", []).then(function(r){
        //$rootScope.log(r);
          $rootScope.$storage.base = r.current_median_history.base.split(" ")[0];
          window.Api.database_api().exec("get_dynamic_global_properties", []).then(function(r){
            $rootScope.log(r);
            $rootScope.$storage.steem_per_mvests = (Number(r.total_vesting_fund_steem.substring(0, r.total_vesting_fund_steem.length - 6)) / Number(r.total_vesting_shares.substring(0, r.total_vesting_shares.length - 6))) * 1e6;
          });
        });
      });
    }, 10);
    if (!angular.isDefined($rootScope.$storage.notifications)) {
      $rootScope.$storage.notifications = [];
    }
    $rootScope.$on('changedChain', function(){
      console.log('chain differs');
      localStorage.socketUrl = $rootScope.$storage["socket"+$rootScope.$storage.chain];
      window.ejs.ChainConfig.setChainId(localStorage[$rootScope.$storage.chain+"Id"]);
      window.Api.close();
      window.Api = window.steemRPC.Client.get({url: localStorage.socketUrl}, true);
      
      window.Api.initPromise.then(function(response) {  
        angular.forEach($rootScope.$storage.users, function(v,k){
          if (v.chain == $rootScope.$storage.chain){
            $rootScope.$storage.user = v;
          }
        });
        if (!$rootScope.$$phase) {
          $rootScope.$apply();
        }
      });
    
      if ($rootScope.$storage.chain == 'steem'){
        $rootScope.$storage.platformname = "Steem";
        $rootScope.$storage.platformpower = "Steem Power";
        $rootScope.$storage.platformsunit = "Steem";
        $rootScope.$storage.platformdollar = "Steem Dollar";
        $rootScope.$storage.platformdunit = "SBD";
        $rootScope.$storage.platformpunit = "SP";
        $rootScope.$storage.platformlunit = "STEEM";
        $rootScope.$storage.socketsteem = "wss://steemd.steemit.com";
      } else {
        $rootScope.$storage.platformname = "";
        $rootScope.$storage.platformpower = " ";
        $rootScope.$storage.platformsunit = "";
        $rootScope.$storage.platformdollar = "";
        $rootScope.$storage.platformdunit = "GBG";
        $rootScope.$storage.platformpunit = "GOLOSP";
        $rootScope.$storage.platformlunit = "GOLOS";
        $rootScope.$storage.socketgolos = "wss://ws.golos.io/";
        //$scope.socket = "wss://golos.steem.ws";
      }
      
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    });
    function checkDate(date, ignore) {
      var eold = 86400000; //1 * 24 * 60 * 60 * 1000; //1 day old
      var now = new Date().getTime();
      var old = new Date(date).getTime();
      return ignore||now-old>=eold;
    }
    $rootScope.$on('changedCurrency', function(event, args){
      var xx = args.currency;
      var ignore = args.enforce;
      console.log(xx);
      var resultObject = $rootScope.$storage.currencies.filter(function ( obj ) {
          return obj.id === xx;
      })[0];
      //searchObj(xx, $rootScope.$storage.currencies);
      if (checkDate(resultObject.date, ignore)) {
        if ($rootScope.$storage.chain == 'steem'){
          APIs.getCurrencyRate("USD", xx ).then(function(res){
            $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate);
            $rootScope.$storage.currencies.filter(function(obj){
              if (obj.id == xx) {
                obj.rate = $rootScope.$storage.currencyRate;
                obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
              }
            });
          });
        } else {
          APIs.getCurrencyRate("XAU", xx ).then(function(res){
            //XAU - 31.1034768g
            //GBG rate in mg. so exchangeRate/31103.4768
            $rootScope.$storage.currencyRate = Number(res.data.query.results.rate.Rate)/31103.4768;
            $rootScope.$storage.currencies.filter(function(obj){
              if (obj.id == xx) {
                obj.rate = $rootScope.$storage.currencyRate;
                obj.date = res.data.query.results.rate.Date==="N/A"?new Date() : res.data.query.results.rate.Date;
              }
            });
            //console.log($rootScope.$storage.currencyRate);
          });
        }
      } else {
        $rootScope.$storage.currencyRate = resultObject.rate;
      }
      if (!$rootScope.$$phase) {
        $rootScope.$apply();
      }
    });

    if (window.cordova) {
      if (!ionic.Platform.isWindowsPhone()) {
        if (ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
          //window.FirebasePlugin.grantPermission();
        }

        /*window.FirebasePlugin.getToken(function(token) {
            // save this server-side and use it to push notifications to this device
            $rootScope.log("device "+token);
            $rootScope.$storage.deviceid = token;
            if ($rootScope.$storage.user) {
              APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            } else {
              APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
                $rootScope.log(angular.toJson(res));
              });
            }
        }, function(error) {
            console.error(error);
        });*/

        FCMPlugin.getToken(function(token){
          // save this server-side and use it to push notifications to this device
          $rootScope.log("device "+token);
          $rootScope.$storage.deviceid = token;
          if ($rootScope.$storage.user) {
            APIs.saveSubscription(token, $rootScope.$storage.user.username, { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          } else {
            APIs.saveSubscription(token, "", { device: ionic.Platform.platform() }).then(function(res){
              $rootScope.log(angular.toJson(res));
            });
          }
        });

        /*window.FirebasePlugin.onTokenRefresh(function(token) {
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        }, function(error) {
          console.error(error);
        });*/
        FCMPlugin.onTokenRefresh(function(token){
          APIs.updateToken($rootScope.$storage.deviceid, token).then(function(res){
            console.log(angular.toJson(res));
            if (res.status) {
              $rootScope.$storage.deviceid = token  
            }
          });
          if (!$rootScope.$$phase){
            $rootScope.$apply();
          }
        });

        /*window.FirebasePlugin.onNotificationOpen(function(data) {
            $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.tap){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        }, function(error) {
            console.error(error);
        });
        */

        //FCMPlugin.onNotification( onNotificationCallback(data), successCallback(msg), errorCallback(err) )
        //Here you define your application behaviour based on the notification data.
        FCMPlugin.onNotification(function(data){
          $rootScope.log(angular.toJson(data));

            //console.log(angular.toJson(data));

            //$rootScope.$storage.notifications.push({title:data.title, message: data.body, author: data.author, permlink: data.permlink, created: new Date()});

            if(data.wasTapped){
              //Notification was received on device tray and tapped by the user.
              if (data.author && data.permlink) {
                if (!$rootScope.$storage.pincode) {

                  var alertPopup = $ionicPopup.confirm({
                    title: data.title,
                    template: data.body + $filter('translate')('OPENING_POST')
                  });

                  alertPopup.then(function(res) {
                    $rootScope.log('Thank you for seeing alert from tray');
                    if (res) {
                      if (data.chain !== $rootScope.$storage.chain) {
                        $rootScope.$storage.chain = data.chain;
                        $rootScope.$broadcast('changedChain');
                        $rootScope.$broadcast('changedCurrency', {currency: $rootScope.$storage.currency, enforce: true});
                      }
                      setTimeout(function() {
                        $rootScope.getContentAndOpen({author:data.author, permlink:data.permlink});
                      }, 10);
                    } else {
                      $rootScope.log("not sure to open alert");
                    }
                  });

                } else {
                  $rootScope.$storage.notifData = {title:data.title, body: data.body, author: data.author, permlink: data.permlink};
                  $rootScope.pinenabled = true;
                }
              }
            } else{
              //Notification was received in foreground. Maybe the user needs to be notified.
              //alert( JSON.stringify(data) );
              if (data.author && data.permlink) {
                $rootScope.showMessage(data.title, data.body+" "+data.permlink);
              } else {
                $rootScope.showMessage(data.title, data.body);
              }
            }
        });
      }

    }

  });
});

}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/index.js","/posts")
},{"./config":101,"./controllers":102,"./locales/ready/ar-SA":104,"./locales/ready/bg-BG":105,"./locales/ready/cs-CZ":106,"./locales/ready/de-DE":107,"./locales/ready/dolan":108,"./locales/ready/el-GR":109,"./locales/ready/en":110,"./locales/ready/es-ES":111,"./locales/ready/fa-IR":112,"./locales/ready/fil-PH":113,"./locales/ready/fr-FR":114,"./locales/ready/he-IL":115,"./locales/ready/hr-HR":116,"./locales/ready/hu-HU":117,"./locales/ready/id-ID":118,"./locales/ready/it-IT":119,"./locales/ready/ms-MY":120,"./locales/ready/nl-NL":121,"./locales/ready/pl-PL":122,"./locales/ready/pt-BR":123,"./locales/ready/pt-PT":124,"./locales/ready/ru-RU":125,"./locales/ready/sv-SE":126,"./locales/ready/uk-UA":127,"./locales/ready/zh-CN":128,"./locales/ready/zh-TW":129,"./services":130,"buffer":11,"currency-symbol-map":27,"diff-match-patch":29,"esteem-lib":56,"pBGvAp":74,"steem-rpc":88}],104:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": " ",
	"LOGOUT": " ",
	"PROFILE": " ",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "          ",
	"ABOUT_2": "  { } . ",
	"ABOUT_3": "        .                  {{platformname}}  {{sitename}}.",
	"ABOUT_4": "",
	"ABOUT_5": "2.                  .",
	"ABOUT_6": "        ",
	"ABOUT_7": "       ",
	"ABOUT_8": "  good-karma ",
	"ABOUT_9": "/ ",
	"ABOUT_10": "  ",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "  ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": " ",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ",
	"POST_2": "     ",
	"OPTIONS": "",
	"RESTEEMED_BY": "  ",
	"NOTHING_HERE": "     ",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}}         .   {{platformname}}  {{platformpower}}     .",
	"PROFILE_2": "{{platformpower}}              .               .",
	"PROFILE_3": "      {{platformsunit}} {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7 ",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "     .         .",
	"OWNER": "",
	"PROFILE_6": "          .              .",
	"ACTIVE": "",
	"PROFILE_7": "          .",
	"MEMO": "",
	"PROFILE_8": "      .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": "  good-karma",
	"PIN_CODE": " ",
	"PIN_TEXT": "  PIN     . <br/> <br/> <b>:</b>      4        pin         .       .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "          ! <br/> </b>:/b>        . (        ).",
	"VOTE": "",
	"COMMENT_TEXT": "             ! <br/> <b>:</b>      <b></b>  .",
	"COMMENT": "",
	"FOLLOW_TEXT": "        !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "       /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "         !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "                 . <br/> <br/> <b>:</b>     /       ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " ",
	"LOGIN_1": "       ",
	"LOGIN_2": "                  .",
	"LOGIN_3": "        .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": "  ",
	"SIGN_UP_NOW": "  ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "  ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": " 50%/50%",
	"POWERUP": "  100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": "  ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": "  ",
	"INCORRECT": " ",
	"OPENING_POST": "  ",
	"SET_PIN": "  ",
	"ENTER_PIN": " ",
	"ARE_YOU_SURE": "  ",
	"REBLOG_TEXT": "      ",
	"BROADCAST_ERROR": "    !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !                        .",
	"LOGIN_FAIL_A": "  !                        .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": " ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": "",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": "  ",
	"SET_CUSTOM_URL": "  ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "   ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": "  ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "     ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": "  ",
	"UPLOAD_COMPLETED": "  ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "       ",
	"INFO": "",
	"QR_TEXT": "       ",
	"BALANCE_TEXT": "        ",
	"NONEXIST_USER": "       !",
	"TRANSFER_TEXT": "     ",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": " ",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": " ",
	"VOTES": "  ",
	"PAYOUT": " ",
	"COMMENTS": "",
	"TRENDING_30": "  ",
	"SORT_POST_BY": "  ",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": "  ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": "   ",
	"POST_LATER": "  !",
	"SAVED": " ",
	"CLEARED": " ",
	"FLAGGING_TEXT": "            . <br><br>     : <ul><li>  </li> <li>   </li> <li>      </li></ul>",
	"REQUEST_LIMIT_TEXT": "    .  / !",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": " ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "           !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "    !",
	"SETTINGS_UPDATED": "  ",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     ",
	"LOGIN_TO_X": "          /.      .",
	"GALLERY": "",
	"TRANSLATIONS": "  ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "    !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": "   ",
	"MANAGE": " ",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    !",
	"PULL_DOWN_TO_REFRESH": "  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .    /  .",
	"ABOUT_11": "<b><br> <br></b>-          .<br>-        .<br>-          .<br>-             .<br>-             .<br>-         .<br>-     .<br>-              <br>-    . <br> -      .<br>-            .<br>-      /   .<br>-   .<br>-    .<b><br><br> <br></b>.        .<br>.                           .<br>.        <br>.         <br><br>     .<br>",
	"FOUNDER": "  ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": " ",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "",
	"DISPLAY_NAME": " "
}
},{}],105:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ",
	"ABOUT_1": "       !",
	"ABOUT_2": "  ,     ,   .",
	"ABOUT_3": "      .       , , , ,       .. ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "1.        .",
	"ABOUT_5": "2.         ,   ,            .",
	"ABOUT_6": "3.       .",
	"ABOUT_7": "4.          .",
	"ABOUT_8": "  good-karma.",
	"ABOUT_9": "   :",
	"ABOUT_10": " ",
	"REMOVE": "",
	"MARKET_VIEW": "  ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "  ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": " ",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": " ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "  ,    ",
	"POST_2": "  ,    -  .",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": "  ...",
	"BALANCES": "  ",
	"PROFILE_1": "{{platformname}}   ,         . {{platformname}}      {{platformpower}}    .",
	"PROFILE_2": "{{platformpower}}   .    ,        .",
	"PROFILE_3": " {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "     7      {{platformname}}.",
	"TRANSACTION_HISTORY": "  ",
	"POSTING": "",
	"PROFILE_5": "        .         .",
	"OWNER": "",
	"PROFILE_6": "              .              .",
	"ACTIVE": "",
	"PROFILE_7": "   ,          .",
	"MEMO": "",
	"PROFILE_8": "          .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "-",
	"PIN_TEXT": "-     . <br/><br/> ,   4     ,     -      ,        .         .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,      . <br/>        .",
	"VOTE": "",
	"COMMENT_TEXT": "  ,       !<br/>        .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,          !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,         !",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,     !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "      .\n <br/><br/>     ,   ,   .",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": ", !",
	"LOGIN_1": "        .",
	"LOGIN_2": "      , ,   .",
	"LOGIN_3": "          .",
	"LOGIN_4": "        .     !",
	"DONT_HAVE": " ?",
	"SIGN_UP_NOW": "  !",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "   ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": "50% / 50%",
	"POWERUP": " 100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  -",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "  ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " -",
	"INCORRECT": "",
	"OPENING_POST": "  .",
	"SET_PIN": " -.",
	"ENTER_PIN": " -.",
	"ARE_YOU_SURE": "  ?",
	"REBLOG_TEXT": "  ,    ?",
	"BROADCAST_ERROR": "  ,  !",
	"SUCCESS": "!",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": " ! ,  ,                ,     .",
	"LOGIN_FAIL_A": " ! ,  ,               ,     .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  witness",
	"VOTED_FOR_WITNESS": "  witness",
	"AGO": "-",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "- .",
	"DOWNVOTE_FLAG": "     .",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": " URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": "   .",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "    ",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": "  ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "     ",
	"INFO": "",
	"QR_TEXT": "  QR     ",
	"BALANCE_TEXT": " ,      !",
	"NONEXIST_USER": " ,        !",
	"TRANSFER_TEXT": "  ,     ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ...",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "   30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": "  ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": "  ",
	"POST_SUBMITTED": "  ",
	"POST_LATER": " -!",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "             .<br><br>        ,  ,  ,      .",
	"REQUEST_LIMIT_TEXT": "    .   /!",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": "",
	"MODIFY_PICTURE": "   ",
	"MODIFY_COVER_PICTURE": "   ",
	"ACTIVE_KEY_REQUIRED_TEXT": ",    ,       !",
	"RESET_PICTURE_TEXT": "    ",
	"RESET_COVER_PICTURE_TEXT": "    ",
	"UPDATE_REQUIRES_RESTART": "    !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "      .",
	"LOGIN_TO_X": "          ,  / . ,    .",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "    !",
	"POST_IS_DRAFT": "    !",
	"SWIPE_LEFT": "   ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "     !",
	"PULL_DOWN_TO_REFRESH": "   ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "\n",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "a",
	"CURRENCY_TEXT": "          .",
	"ABOUT_11": "<br><b>  eSteem</b><br>-      ,   . <br>-       ,      .<br>-  ,    ,    .         .<br>-      o.     .<br>-   .         - .<br>-   \"\",     -.<br>-    .<br>-        , , ,   .<br>-  .<br>-    ,  .<br>-  .     ,  ,   .<br>-   /  . <br> -   . <br>    . <br><br><b></b> <br>1.       . <br>2.         .            .          . <br>3.       . <br>4.        - <br><br>eSteem   Steem  Golos.<br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": "   ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": "Escrow ",
	"RATIFICATION_DEADLINE": "   ",
	"ESCROW_EXPIRATION": "  Escrow",
	"ESCROW_FEE": "Escrow ",
	"ESCROW_TERMS": "Escrow ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "   ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "O",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "",
	"DISPLAY_NAME": ""
}
},{}],106:[function(require,module,exports){
module.exports={
	"HOME": "Dom",
	"LOGIN": "Pihlen",
	"LOGOUT": "Odhlen",
	"PROFILE": "Profil",
	"FOLLOW": "Nsleduj",
	"BOOKMARKS": "Zloky",
	"TRANSFER": "Pevod",
	"MARKET": "Trh",
	"SETTINGS": "Nastaven",
	"ABOUT": "O ns",
	"ABOUT_1": "kde kdokoliv me zskat odmnu za svj obsah!",
	"ABOUT_2": "je postaven na {{platformname}} platform. Aplikaci vytvoil",
	"ABOUT_3": "a je to komunitn, open-source mobiln projekt. Nabz pstup k obsahu pro ten, komentovn, hlasovn, vystavovn pspvk, pevod vdlk atd. poskytovan {{platformname}} blockchainem a {{sitename}}.",
	"ABOUT_4": "1. Aplikace nem pstup k uivatelovm fondm ani je nikdy nevlastn.",
	"ABOUT_5": "2. Aplikace nabz bezpenostn model na stran klienta. Privtn kle jsou dreny lokln a nikdy nejsou poslny dnm serverm.",
	"ABOUT_6": "3. Aplikace nabz jednoduch, atraktivn uivatelsk rozhran a zitky.",
	"ABOUT_7": "4. Aplikace po uivatelch nikdy nepoaduje dn osobn informace.",
	"ABOUT_8": "Hlasujte pro svdka good-karma",
	"ABOUT_9": "Kontakt/Zptn vazba:",
	"ABOUT_10": "Vce informac:",
	"REMOVE": "Odstranit",
	"MARKET_VIEW": "Zobrazen trhu",
	"PRICE": "Cena",
	"AMOUNT": "Suma",
	"TOTAL": "Celkem",
	"NOORDERS": "dn oteven objednvky pro",
	"DATE": "Datum",
	"BUY": "Nkup",
	"SELL": "Prodej",
	"OPEN": "Oteveno",
	"HISTORY": "Historie",
	"FOLLOW_BACK": "Sledovat",
	"FOLLOWED": "Sledovn",
	"UNFOLLOW": "Pestat sledovat",
	"FOLLOWING": "Sledovan",
	"FOLLOWERS": "Sledujc",
	"SEARCH_FOLLOWERS": "Hledej sledujc",
	"SEARCH_FOLLOWING": "Hledej sledovan",
	"BY": "km",
	"IN": "v",
	"MENU": "Menu",
	"BOOKMARK": "Zloka",
	"REBLOG": "Reblog",
	"UPVOTE": "Hlasujte pro",
	"DOWNVOTE": "Hlasujte proti",
	"UNVOTE_DOWNVOTED": "Vrate hlas proti",
	"UNVOTE_UPVOTED": "Vrate hlas pro",
	"REPLY": "Odpovzte",
	"EDIT": "Upravte",
	"POST_1": "Pro zobrazen voleb peje vlevo na komente",
	"POST_2": "Pro zobrazen subkoment klepnte na komente",
	"OPTIONS": "Volby",
	"RESTEEMED_BY": "Resteemovno km",
	"NOTHING_HERE": "Pipravuje se",
	"BALANCES": "Zstatky",
	"PROFILE_1": "{{platformname}}, obchodovateln tokeny, kter mohou bt kdykoliv pevedeny. {{platformname}} mohou bt pevedeny na {{platformpower}} v procesu zvanm powering up.",
	"PROFILE_2": "{{platformpower}}, vlivov tokeny, kter posiluj pi dlouhodobm dren a hlasovn o pspvcch. m vce jich nkdo dr, tm vce me ovlivnit odmny druhch a sm zskat odmnu za sprvn hlasovn.",
	"PROFILE_3": "Tokeny v cen okolo {{platformsunit}} v {{platformname}}.",
	"ESTIMATED_VALUE": "Oekvan cena",
	"PROFILE_4": "Oekvan cena je zaloena na 7 denn prmrn cen {{platformname}}.",
	"TRANSACTION_HISTORY": "Historie transakc",
	"POSTING": "Odesln",
	"PROFILE_5": "Odeslac kl je pouvn pro odesln pspvk a hlasovn. Ml by bt rozdln od aktivnho a vlastnickho kle.",
	"OWNER": "Vlastnk",
	"PROFILE_6": "Vlastnick kl je hlavn kl tu a je poadovn pro zmnu ostatnch t. Privtn kl nebo heslo pro vlastnick kl by mly bt dreny pokud mono co nejvce offline.",
	"ACTIVE": "Aktivn",
	"PROFILE_7": "Aktivn kl se pouv pro pevody a zadn objednvek na vnitnm trhu.",
	"MEMO": "Poznmka",
	"PROFILE_8": "Poznmkov kl se pouv pro tvorbu a ten poznmek.",
	"BLOG": "Blog",
	"POSTS": "Pspvky",
	"REPLIES": "Odpovdi",
	"WALLET": "Penenka",
	"TAG": "ttek",
	"USER": "Uivatel",
	"CLOSE": "Zavt",
	"TO": "do",
	"ASSET": "Aktivum",
	"SEND": "Poslat",
	"SECURITY": "Zabezpeen",
	"AVAILABLE": "Dostupn",
	"PUBLIC_MEMO": "Veejn poznmka",
	"TO_DESC": "Uivatel nap. good-karma",
	"PIN_CODE": "Pin kd",
	"PIN_TEXT": "PIN kd pomh zabezpeit aplikaci a data. <br/><br/><b>Poznmka:</b> Jakmile je aktivn, mte maximln 4 pokusy na odemen. Pokud pin zapomenete nebo neuspjete, aplikace odstran uivatelsk data tohoto pihlen. Mete se opt pihlsit a pokraovat v prci.",
	"NOTIFICATIONS": "Oznmen",
	"VOTE_TEXT": "Pokud nkdo hlasuje pro V pspvek, obdrte upozornn! <br/> <b>Poznmka:</b> Tato oznmen obsahuj vhu hlasu (a u je to hlas pro, proti, nebo odvoln hlasovn).",
	"VOTE": "Hlasujte",
	"COMMENT_TEXT": "Pokud nkdo komentuje V pspvek nebo koment, obdrte oznmen! <br/> <b>Poznmka:</b> Upozornn je zaslno t pokud nkdo <b>edituje</b> svj koment.",
	"COMMENT": "Poznmka",
	"FOLLOW_TEXT": "Obdrte upozornn kdy vs nkdo zane sledovat, nebo sledovn zru!",
	"MENTIONS": "Zmnky",
	"MENTIONS_TEXT": "Pokud vs nkdo zmn v pspvku/komenti, obdrte upozornn!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Pokud nkdo resteemuje v pspvek, dostanete oznmen!",
	"CONFIGURATIONS": "Konfigurace",
	"VOTING": "Hlasovn",
	"VOTING_TEXT": "Vha hlasu nebo procento ovlivuje hlasovac slu aplikace, take mete regulovat vi odmny vaeho hlasovn. <br/><br/><b>Poznmka:</b> To ovlivn vhu hlasu/procento i pi hlasovn proti a je to platn v cel aplikaci.",
	"SERVER": "Server",
	"SERVER_TEXT": "Doporuen",
	"SAVE_CHANGES": "Uloit zmny",
	"VOTERS_INFO": "Informace o volii",
	"WELCOME_BACK": "Vtejte zpt!",
	"LOGIN_1": "Pro pokraovn se pihlate svm uivatelskm jmnem a heslem.",
	"LOGIN_2": "Odeslac kl je uren pro vystavovan pspvk, komente, hlasovn, sledovn.",
	"LOGIN_3": "Aktivn kl je uren pro pevody a aktualizaci profilovho obrzku.",
	"LOGIN_4": "Uivatelovy pihlaovac daje jsou dreny lokln v pstroji. Po odhlen jsou odstranny!",
	"DONT_HAVE": "Nemte et?",
	"SIGN_UP_NOW": "Zite si et",
	"CANCEL": "Zruit",
	"ADVANCED": "Pokroil",
	"ACTIVE_PRIKEY": "Aktivn soukrom kl",
	"POSTING_PRIKEY": "Odeslac soukrom kl",
	"MASTER_PASS": "Hlavn heslo",
	"USERNAME": "Uivatelsk jmno",
	"CARD_VIEW": "Zobrazen karta",
	"COMPACT_VIEW": "Zobrazen kompakt",
	"SEARCH": "Hledat",
	"SUBMIT_A_STORY": "Vlo lnek",
	"REPLYTO": "Odpovzte",
	"POST": "Odeslat",
	"PREVIEW": "Nhled",
	"DEFAULT": "Nastaven 50% / 50%",
	"POWERUP": "100% Steem Power",
	"DECLINE_PAYOUT": "Odmtnou vplatu",
	"SAVE_FOR_LATER": "Uschovat na pozdji",
	"CLEAR": "Vyistit",
	"POST_CONTENT": "Odeslat obsah",
	"COMMENT_CONTENT": "Komentovat obsah",
	"TITLE": "Nadpis",
	"TAGS": "ttky",
	"NOT_MATCH": "Neshoduje se",
	"CONFIRM_PIN": "Potvrte PIN",
	"INCORRECT": "Nesprvn",
	"OPENING_POST": "vodn pspvek",
	"SET_PIN": "Nastavte PIN",
	"ENTER_PIN": "Vlote PIN",
	"ARE_YOU_SURE": "Urit?",
	"REBLOG_TEXT": "Reblog je nevratn, pejete si pokraovat?",
	"BROADCAST_ERROR": "Chyba odesln, zkuste znovu!",
	"SUCCESS": "spch",
	"REBLOGGED_POST": "Reblogovan pspvek!",
	"LOGIN_FAIL": "Pihlen selhalo! Ujistte se, e jste se pihlsili hlavnm heslem, nebo e jste pi pihlen zadali Odeslac kl, pokud jste zvolili Pokroil reim.",
	"LOGIN_FAIL_A": "Pihlen selhalo! Ujistte se, e jste se pihlsili hlavnm heslem, nebo e jste pi pihlen zadali Aktivn kl, pokud jste zvolili Pokroil reim.",
	"WARNING": "Vstraha",
	"VOTE_FOR_WITNESS": "Hlasovn o svdcch",
	"VOTED_FOR_WITNESS": "Hlasoval pro svdka",
	"AGO": "ped",
	"FROM_NOW": "od te",
	"SECS": "vteiny",
	"A_MIN": "minuta",
	"MINS": "minuty",
	"AN_HOUR": "hodina",
	"HOURS": "hodiny",
	"A_DAY": "den",
	"DAYS": "dny",
	"A_MONTH": "msc",
	"MONTHS": "msce",
	"A_YEAR": "rok",
	"YEARS": "roky",
	"MIN_READ": "minut ten",
	"DOWNVOTE_FLAG": "Hlasujte proti nebo oznate jako zvadn",
	"CAPTURE_PICTURE": "Zachyte obrzek",
	"SELECT_PICTURE": "Vyberte obrzek",
	"SET_CUSTOM_URL": "Nastavte zkaznick URL",
	"INSERT_PICTURE": "Vlote obrzek",
	"ERROR": "Chyba",
	"UPLOAD_ERROR": "Nahrajte chybu",
	"CAMERA_CANCELLED": "Fotoapart zruen",
	"SET_URL": "Nastavte URL",
	"DIRECT_LINK_PICTURE": "Pm odkaz na obrzek",
	"COMMENT_SUBMITTED": "Koment vloen!",
	"DELETE_COMMENT": "Mazn komente je nevratn...",
	"DELETED_COMMENT": "Odstrann koment",
	"UPLOADING_PICTURE": "Nahrvn obrzku",
	"UPLOAD_COMPLETED": "Nahrvn hotovo",
	"UPLOAD_FAILED": "Nahrvn selhalo",
	"PASSWORD_INCORRECT": "Heslo nebo jmno tu bylo nesprvn",
	"INFO": "Informace",
	"QR_TEXT": "QR kd umstte do oblasti pro sken",
	"BALANCE_TEXT": "Ujistte se, e mte dostaten zstatek pro transakci!",
	"NONEXIST_USER": "Uivatel, ktermu se snate pevst fondy neexistuje!",
	"TRANSFER_TEXT": "Jste si jisti, e si pejete provst pevod?",
	"CONFIRMATION": "Potvrzen",
	"TX_BROADCASTED": "Transakce je odeslna",
	"FEED": "Zdroj",
	"TRENDING": "V trendu",
	"HOT": "hav",
	"NEW": "Nov",
	"PROMOTED": "Propagovan",
	"VOTES": "Hlasy",
	"PAYOUT": "Vplata",
	"COMMENTS": "Komente",
	"TRENDING_30": "V trendu po 30 dn",
	"SORT_POST_BY": "Roztdit pspvky dle",
	"PAYOUT_CYCLE": "Cyklus vplaty",
	"POTENTIAL_PAYOUT": "Potenciln vplata",
	"PAST_PAYOUT": "Minul vplata",
	"AUTHOR_PAYOUT": "Autorsk odmna",
	"CURATION_PAYOUT": "Kurtorsk odmna",
	"POST_SUBMITTED": "lnek je odesln!",
	"POST_LATER": "Uschovat pro pozdj odesln!",
	"SAVED": "Uloen",
	"CLEARED": "Vyitno",
	"FLAGGING_TEXT": "Oznaen pspvku za zvadn me odebrat odmny a uinit tento materil mn viditelnm.<br><br>Toto oznaen by mlo bt pouito na nsledujc: <ul><li>podvod nebo plagitorstv</li><li>projevy nenvisti nebo internetov trolovn</li><li>zmrn chybn kategorizace obsahu nebo spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limit poadavk dosaen. Zkontrolujte ostatn trendy/ttky!",
	"POST_IS_UNBOOKMARK": "Pspvek je odstrann ze zloek!",
	"POST_IS_BOOKMARK": "Pspvek je pidn do zloek!",
	"RESET": "Resetovat",
	"MODIFY_PICTURE": "Upravit profilov obrzek",
	"MODIFY_COVER_PICTURE": "Upravit tituln obrzek",
	"ACTIVE_KEY_REQUIRED_TEXT": "Zadejte Aktivn soukrom kl, pokud jste vybrali pokroil md pstupu!",
	"RESET_PICTURE_TEXT": "Tmto resetujete profilov obrzek uivatele!",
	"RESET_COVER_PICTURE_TEXT": "Tmto resetujete tituln obrzek uivatele!",
	"UPDATE_REQUIRES_RESTART": "Aktualizace serveru vyaduje restart!",
	"SETTINGS_UPDATED": "Nastaven jsou aktualizovna.",
	"LANGUAGES": "Jazyky",
	"LANGUAGES_TEXT": "Zde mete zmnit jazyk aplikace.",
	"LOGIN_TO_X": "Tato operace vyaduje pihlen uivatele hlavnm heslem, Aktivnm/Odeslacm klem. Prosm pihlate se a opakujte pokus.",
	"GALLERY": "Galerie",
	"TRANSLATIONS": "Peloili",
	"SHARE": "Akcie",
	"MARKETPLACE": "Trh",
	"EXCHANGE": "Burza",
	"DRAFTS": "Koncepty",
	"POST_IS_UNDRAFT": "Pspvek je z koncept odstrann !",
	"POST_IS_DRAFT": "Pspvek je pidn do koncept!",
	"SWIPE_LEFT": "Pro zobrazen monost peje vlevo",
	"MANAGE": "Spravovat",
	"IMAGE_REMOVED": "Obraz je odstrann",
	"COPY": "Koprovat",
	"NO_IMAGE": "Dosud jste nenahrl dn obraz.",
	"PULL_DOWN_TO_REFRESH": "Pro obnoven zathni dol",
	"EXTERNAL_APPS": "Extern aplikace",
	"PLUGINS": "Pdavn moduly",
	"SUGGEST": "Nvrh",
	"COMING_SOON": "Ji brzy chystme",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Zde mete zmnit blockchain nebo vchoz platformu.",
	"CURRENCY": "Mna",
	"CURRENCY_TEXT": "Zde mete zmnit svoji vchoz mnu. V tto mn se pot budou zobrazovat odmny za pspvky/komente.",
	"ABOUT_11": "<br><b>Seznam funkc</b> <br>-Pstup k jedinenm lnkm v kadm tmatu, kter jsou zajmav ke ten<br>Angaovn se s autory komentovnm a diskutovnm tmat.<br>Hlasovnm pspvk odmovat autory stejn tak jako zskvat kurtorsk odmny. <br>Publikovat lnky, pspvky do blogu a hostovat je zdarma, dostvat odmny za publikovn a zskvat stoupence. <br>Pst lnky kdekoliv a kdykoliv a mt monost uloit jejich koncepty pro pozdj publikaci. <br>Uloit si oblben lnky do zloek pro pozdj peten. <br>Vmna nebo proplacen vaeho vdlku. <br>Monost poslat vae prostedky jakmukoliv autorovi, uivatelovi, pteli, stoupencm atd.<br>Nsledovat zajmav autory, bloggery. <br>Prohlet si pspvky stoupenc a autor, kter sledujete. <br>Dostvat oznmen, abyste zstali v kontaktu se svmi stoupenci a diskuzemi, ve kterch jste zapojen<br>Prohledvat zajmav tagy/kategorie lnk a zajmav autory. <br>Pizpsobte si svj profil. <br>A mnohem vce funkc, kter pijdou <br><br><b>Bezpenost</b> <br>1. Aplikace nem pstup ani nedr penn prostedky uivatel. <br>2. Aplikace nabz model zabezpeen na stran klienta se soukrommi kli umstn lokln a nikdy je neodesl na server, jste sami zodpovdn za zlohovn Vaich hesel. <br>3. Aplikace nabz jednoduch, atraktivn uivatelsk rozhran. <br>4. Aplikace nabz dal vrstvu zabezpeen pomoc pin-kdu <br><br>eSteem podporuje platformy Steem a Golos. <br>",
	"FOUNDER": "Zakladatel a hlavn vvoj",
	"ADD_ACCOUNT": "Pidat et",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow zprostedkovatel",
	"RATIFICATION_DEADLINE": "Konen termn ratifikace",
	"ESCROW_EXPIRATION": "Escrow expirace",
	"ESCROW_FEE": "Escrow poplatek",
	"ESCROW_TERMS": "Escrow podmnky",
	"NIGHT_MODE": "Non reim",
	"DAY_MODE": "Denn reim",
	"VIEW_CONTEXT": "Zobrazit pln kontext",
	"USER_NOTFOUND": "Uivatel nenalezen",
	"APPROVE": "Schvlit",
	"DISPUTE": "Odporovat",
	"RELEASE": "Vydat",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Odeslat",
	"RECEIVER": "Pjemce",
	"LOCATION": "Umstn",
	"WEBSITE": "Web",
	"DISPLAY_NAME": "Zobrazovan jmno"
}
},{}],107:[function(require,module,exports){
module.exports={
	"HOME": "Startseite",
	"LOGIN": "Anmelden",
	"LOGOUT": "Abmelden",
	"PROFILE": "Profil",
	"FOLLOW": "Folgen",
	"BOOKMARKS": "Lesezeichen",
	"TRANSFER": "bertragen",
	"MARKET": "Markt",
	"SETTINGS": "Einstellungen",
	"ABOUT": "Info",
	"ABOUT_1": "die Plattform, bei der jeder fr seine Inhalte vergtet wird!",
	"ABOUT_2": "wird untersttzt durch die {{platformname}} Plattform. Anwendung erstellt von",
	"ABOUT_3": "und ist eine mobile Open Source Anwendung, die durch die Community untersttzt wird. Die Anwendung erlaubt den Zugriff auf die Inhalte fr das Lesen, Kommentieren, Abstimmen, Posten, bertragen von Einknften etc. Die Funktionen werden durch die {{platformname}} Blockchain und {{sitename}} bereitgestellt.",
	"ABOUT_4": "1. Die Anwendung greift niemals auf Ihre Mittel zu.",
	"ABOUT_5": "2. Die Anwendung nutzt ein Client-basiertes Sicherheitskonzept, dass auf Schlsseln basiert, die lokal vorhanden sind und niemals an einen Server bertragen werden.",
	"ABOUT_6": "3. Die Anwendung bietet ein simples, attraktives Interface.",
	"ABOUT_7": "4. Die Anwendung fragt niemals nach persnlichen Daten.",
	"ABOUT_8": "Good-Karma als Zeuge abstimmen",
	"ABOUT_9": "Kontakt/Feedback:",
	"ABOUT_10": "Weitere Informationen:",
	"REMOVE": "Entfernen",
	"MARKET_VIEW": "Marktansicht",
	"PRICE": "Preis",
	"AMOUNT": "Menge",
	"TOTAL": "Gesamt",
	"NOORDERS": "Keine offenen Order",
	"DATE": "Datum",
	"BUY": "Kaufen",
	"SELL": "Verkaufen",
	"OPEN": "Offen",
	"HISTORY": "Historie",
	"FOLLOW_BACK": "Ebenfalls folgen",
	"FOLLOWED": "Sie folgen nun diesem Nutzer",
	"UNFOLLOW": "Nicht mehr folgen",
	"FOLLOWING": "Sie folgen diesem Nutzer",
	"FOLLOWERS": "Personen, die Ihnen folgen",
	"SEARCH_FOLLOWERS": "Durchsuchen der Nutzer, die Ihnen folgen",
	"SEARCH_FOLLOWING": "Durchsuchen der Nutzer, denen Sie folgen",
	"BY": "von",
	"IN": "in",
	"MENU": "Men",
	"BOOKMARK": "Lesezeichen",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Downvote entfernen",
	"UNVOTE_UPVOTED": "Upvote entfernen",
	"REPLY": "Antworten",
	"EDIT": "Editieren",
	"POST_1": "Nach links wischen um Kommentare zu sehen",
	"POST_2": "Auf Kommentare tippen um dessen Antworten zu sehen",
	"OPTIONS": "Optionen",
	"RESTEEMED_BY": "Resteemed von",
	"NOTHING_HERE": "Hier gibt es noch nichts zu sehen...",
	"BALANCES": "Kontostand",
	"PROFILE_1": "{{platformname}}, handelbare Tokens die zu jeder Zeit bertragen werden knnen. {{platformname}} kann in {{platformpower}} konvertiert werden. Dieser Prozess heit \"powering up\".",
	"PROFILE_2": "{{platformpower}}, tokens die sich automatisch vermehren, wenn Sie besessen werden und beeinflussen, wie viel Ihre Stimme wert ist. Desto mehr Sie besitzen, desto mehr Einfluss hat Ihre Stimme.",
	"PROFILE_3": "Tokens mit einem Wert von etwa {{platformsunit}} in {{platformname}}.",
	"ESTIMATED_VALUE": "Geschtzter Wert",
	"PROFILE_4": "Der geschtzte Wert basiert auf einem 7-Tage-Durchschnittswert von {{platformname}}.",
	"TRANSACTION_HISTORY": "Transaktions Historie",
	"POSTING": "Beitrag",
	"PROFILE_5": "Der \"posting key\" wird fr das Verffentlichen und Abstimmen bentigt. Er sollte sich vom \"active key\" und vom \"owner key\" unterscheiden.",
	"OWNER": "Besitzer",
	"PROFILE_6": "Der \"owner key\" ist der Hauptschlssel fr den Account und wird bentigt, um andere Schlssel zu ndern. Der \"private key\" oder das Passwort sollten nur offline verfgbar sein.",
	"ACTIVE": "Aktiv",
	"PROFILE_7": "Der \"active key\" wird benutzt, um bertragungen durchzufhren oder Gebote auf dem Markt zu platzieren.",
	"MEMO": "Notiz",
	"PROFILE_8": "Der \"memo key\" wird bentigt, um Memos zu lesen und zu speichern.",
	"BLOG": "Blog",
	"POSTS": "Beitrge",
	"REPLIES": "Antworten",
	"WALLET": "Brieftasche",
	"TAG": "Tag",
	"USER": "Benutzer",
	"CLOSE": "Schlieen",
	"TO": "Empfnger",
	"ASSET": "Zusatz",
	"SEND": "Senden",
	"SECURITY": "Sicherheit",
	"AVAILABLE": "Verfgbar",
	"PUBLIC_MEMO": "ffentliche Notiz",
	"TO_DESC": "Benutzer z.B. good-karma",
	"PIN_CODE": "Pin",
	"PIN_TEXT": "Der PIN dient der Sicherheit der Anwendung, sowie deren Daten. <br/><br/><b>Hinweis:</b> Nach Aktivierung stehen maximal 4 Anmeldeversuche zur Verfgung. Danach werden die Daten des aktuell angemeldeten Nutzers gelscht und die Anwendung kann wieder normal genutzt werden.",
	"NOTIFICATIONS": "Benachrichtigungen",
	"VOTE_TEXT": "Sie werden informiert, sobald jemand fr Ihre Beitrge abgestimmt hat! <br/> <b>Hinweis:</b> Die Notifikation gibt aufschluss ber die Art der Abstimmung (Positiv, Negativ, wieder entfernt) und die Gewichtung der Stimme.",
	"VOTE": "Abstimmen",
	"COMMENT_TEXT": "Sie werden informiert, sobald jemand auf Ihre Beitrge oder Kommentare antwortet!<br/> <b>Hinweis:</b> Sie werden auch beim ndern eines Beitrags/Kommentars erneut informiert.",
	"COMMENT": "Kommentar",
	"FOLLOW_TEXT": "Sie werden benachrichtigt, sobald Ihnen jemand folgt oder nicht mehr folgt!",
	"MENTIONS": "Erwhnungen",
	"MENTIONS_TEXT": "Sie werden benachrichtigt, sobald Sie von jemanden in Kommentaren oder Beitragen erwhnt werden!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Sie werden benachrichtigt sobald jemand Ihren Post erneut verffentlicht hat!",
	"CONFIGURATIONS": "Einstellungen",
	"VOTING": "Abstimmung",
	"VOTING_TEXT": "Das Gewicht / der prozentuale Anteil der Stimme beeinflusst die Menge der Vergtung fr den Autor. <br/><br/><b>Hinweis:</b> Diese Einstellung ndert auch die Gewichtung/ den prozentualen Anteil fr negative Stimmen. Diese Einstellung wird in der gesamten Anwendung verwendet.",
	"SERVER": "Server",
	"SERVER_TEXT": "Empfohlen",
	"SAVE_CHANGES": "nderungen speichern",
	"VOTERS_INFO": "Abstimmungsinformationen",
	"WELCOME_BACK": "Willkommen zurck!",
	"LOGIN_1": "Melden Sie sich mit Ihrem Benutzernamen und Passwort an, um fortzufahren.",
	"LOGIN_2": "Der \"Posting key\" wird fr das Verffentlichen von Beitragen, Kommentaren und Abstimmungen, sowie dem Folgen von Nutzern bentigt.",
	"LOGIN_3": "Der \"Active key\" wird fr die bertragung und das aktualisieren des Profilbilds bentigt.",
	"LOGIN_4": "Zugangsdaten werden local im Gert gespeichert und nach dem Logout gelscht!",
	"DONT_HAVE": "Noch keinen Account?",
	"SIGN_UP_NOW": "Jetzt registrieren",
	"CANCEL": "Abbrechen",
	"ADVANCED": "Erweitert",
	"ACTIVE_PRIKEY": "Aktiver privater Zugangsschlssel",
	"POSTING_PRIKEY": "Privater Zugangsschlssel fr das Verffentlichen von Inhalten",
	"MASTER_PASS": "Master- /Haupt-Passwort",
	"USERNAME": "Benutzername",
	"CARD_VIEW": "Karten-Ansicht",
	"COMPACT_VIEW": "Kompaktansicht",
	"SEARCH": "Suchen",
	"SUBMIT_A_STORY": "Beitrag erstellen",
	"REPLYTO": "Antworten",
	"POST": "Verffentlichen",
	"PREVIEW": "Vorschau",
	"DEFAULT": "Standard 50% / 50%",
	"POWERUP": "Power erhhen mit 100%",
	"DECLINE_PAYOUT": "Auf die Auszahlung verzichten",
	"SAVE_FOR_LATER": "Fr einen spteren Zeitpunkt speichern",
	"CLEAR": "LSCHEN",
	"POST_CONTENT": "Inhalt verffentlichen",
	"COMMENT_CONTENT": "Inhalt kommentieren",
	"TITLE": "Titel",
	"TAGS": "Tags",
	"NOT_MATCH": "KEINE BEREINSTIMMUNG",
	"CONFIRM_PIN": "PIN besttigen",
	"INCORRECT": "FALSCH",
	"OPENING_POST": "ffne Beitrag",
	"SET_PIN": "Setzen Sie Ihren PIN",
	"ENTER_PIN": "Bitte geben Sie Ihren PIN ein",
	"ARE_YOU_SURE": "Sind Sie sicher?",
	"REBLOG_TEXT": "Das neu verffentlichen kann nicht rckgngig gemacht werden, wollen Sie weiter machen?",
	"BROADCAST_ERROR": "Fehler beim verffentlichen, bitte versuchen Sie es erneut!",
	"SUCCESS": "Erfolgreich",
	"REBLOGGED_POST": "Neu verffentlicht!",
	"LOGIN_FAIL": "Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, fr den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
	"LOGIN_FAIL_A": "Anmeldung fehlgeschlagen! Bitte stellen Sie sich sicher, dass Sie das Master-Passwort oder, fr den erweiterten Anmelde-Modus, den bereitgestellten \"Active private key\" verwenden.",
	"WARNING": "Warnung",
	"VOTE_FOR_WITNESS": "Fr einen Witness abstimmen",
	"VOTED_FOR_WITNESS": "Erfolgreich fr einen Witness abgestimmt",
	"AGO": "seit",
	"FROM_NOW": "ab jetzt",
	"SECS": "Sekunden",
	"A_MIN": "eine Minute",
	"MINS": "Minuten",
	"AN_HOUR": "eine Stunde",
	"HOURS": "Stunden",
	"A_DAY": "einen Tag",
	"DAYS": "Tage",
	"A_MONTH": "einen Monat",
	"MONTHS": "Monate",
	"A_YEAR": "ein Jahr",
	"YEARS": "Jahre",
	"MIN_READ": "min. lesen",
	"DOWNVOTE_FLAG": "Negativ bewerten oder markieren",
	"CAPTURE_PICTURE": "Bild aufnehmen",
	"SELECT_PICTURE": "Bild auswhlen",
	"SET_CUSTOM_URL": "Eigene URL",
	"INSERT_PICTURE": "Bild einfgen",
	"ERROR": "Fehler",
	"UPLOAD_ERROR": "Upload fehlgeschlagen",
	"CAMERA_CANCELLED": "Kamera geschlossen",
	"SET_URL": "URL setzen",
	"DIRECT_LINK_PICTURE": "Direkter Link zum Bild",
	"COMMENT_SUBMITTED": "Kommentar abgegeben!",
	"DELETE_COMMENT": "Gelschte Kommentare knnen nicht widerhergestellt werden...",
	"DELETED_COMMENT": "Kommentar gelscht",
	"UPLOADING_PICTURE": "Bild wird hochgeladen",
	"UPLOAD_COMPLETED": "Hochladen abgeschlossen",
	"UPLOAD_FAILED": "Hochladen fehlgeschlagen",
	"PASSWORD_INCORRECT": "Passwort oder Benutzername nicht korrekt",
	"INFO": "Information",
	"QR_TEXT": "Platzieren Sie einen QR code innerhalb des Bereichs",
	"BALANCE_TEXT": "Stellen Sie sicher, dass Sie ber ausreichende Mittel verfgen!",
	"NONEXIST_USER": "Sie verfgen nicht ber ausreichende Mittel fr diese Aktion!",
	"TRANSFER_TEXT": "Wollen Sie wirklich bertragen?",
	"CONFIRMATION": "Besttigungen",
	"TX_BROADCASTED": "Die Transaktion wurde bertragen",
	"FEED": "Feed",
	"TRENDING": "Im Trend",
	"HOT": "Beliebt",
	"NEW": "Neu",
	"PROMOTED": "Beworben",
	"VOTES": "Stimmen",
	"PAYOUT": "Auszahlung",
	"COMMENTS": "Kommentare",
	"TRENDING_30": "Seit 30 Tagen im Trend",
	"SORT_POST_BY": "Sortieren der Posts nach:",
	"PAYOUT_CYCLE": "Auszahlungskreislauf",
	"POTENTIAL_PAYOUT": "Voraussichtliche Auszahlungen",
	"PAST_PAYOUT": "Vergangene Auszahlungen",
	"AUTHOR_PAYOUT": "Auszahlung an den Autor",
	"CURATION_PAYOUT": "Kurationsauszahlungen",
	"POST_SUBMITTED": "Post wurde verffentlicht!",
	"POST_LATER": "Posts zur spteren Verffentlichung!",
	"SAVED": "Gespeichert",
	"CLEARED": "Geleert",
	"FLAGGING_TEXT": "Das markieren eines Posts kann zum Verlust der Vergtung fhren und verringert die Sichtbarkeit des Posts.<br><br>Sie sollten Posts nur unter markieren, wenn einer der folgenden Punkte zutrifft: <ul><li>Betrug oder Plagiat</li><li>Vulgre Ausdrucke oder \"Trolling\"</li><li>Mutwillig falsch kategorisiert oder Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Maximale Anzahl von Anfragen erreicht. Bitte schauen Sie sich andere trend/tags an!",
	"POST_IS_UNBOOKMARK": "Post von den Lesezeichen entfernt!",
	"POST_IS_BOOKMARK": "Post zu den Lesezeichen hinzugefgt!",
	"RESET": "Zurcksetzen",
	"MODIFY_PICTURE": "Profilbild ndern",
	"MODIFY_COVER_PICTURE": "Titelbild ndern",
	"ACTIVE_KEY_REQUIRED_TEXT": "Bitte tragen Sie den \"Active private key\" ein, wenn Sie den erweiterten Login Modus gewhlt haben!",
	"RESET_PICTURE_TEXT": "Zurcksetzen des Profilbilds",
	"RESET_COVER_PICTURE_TEXT": "Zurcksetzen des Titelbilds.",
	"UPDATE_REQUIRES_RESTART": "Aufgrund eines Serverupdates muss ein die Anwendung neugestartet werden!",
	"SETTINGS_UPDATED": "Einstellungen aktualisiert!",
	"LANGUAGES": "Sprachen",
	"LANGUAGES_TEXT": "Hier kann die Sprache der Anwendung gendert werden.",
	"LOGIN_TO_X": "Fr die gewnschte Operation mssen Sie angemeldet sein. Bitte melden Sie sich mit Ihrem Passwort oder dem \"active/posting\"-Schlssel sein",
	"GALLERY": "Gallerie",
	"TRANSLATIONS": "Mitwirkende an der bersetzung",
	"SHARE": "Teilen",
	"MARKETPLACE": "Marktplatz",
	"EXCHANGE": "Brse",
	"DRAFTS": "Entwrfe",
	"POST_IS_UNDRAFT": "Beitrag aus Entwrfen entfernt!",
	"POST_IS_DRAFT": "Beitrag zu Entwrfen hinzugefgt!",
	"SWIPE_LEFT": "Links wischen fr Optionen",
	"MANAGE": "Verwalten",
	"IMAGE_REMOVED": "Bild entfernt",
	"COPY": "Kopieren",
	"NO_IMAGE": "Sie haben noch kein Foto hochgeladen!",
	"PULL_DOWN_TO_REFRESH": "Nach unten ziehen zum aktualisieren",
	"EXTERNAL_APPS": "Externe Apps",
	"PLUGINS": "Plug-Ins",
	"SUGGEST": "Vorschlagen",
	"COMING_SOON": "Kommt bald",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Hier kannst du die Blockchain oder die Standardplattform wechseln.",
	"CURRENCY": "Whrung",
	"CURRENCY_TEXT": "Hier knnen Sie Ihre Standardwhrung ndern. Sie sehen all Ihre Verdienste fr Beitrge / Kommentare in dieser Standardwhrung.",
	"ABOUT_11": "<br><b>Feature Liste</b><br>- Zugang erhalten zu einzigartigen Artikeln all der Themengebiete, die Sie gerne lesen mchten.<br>- Interagieren Sie mit den Autoren, in dem Sie die Beitrge kommentieren und mit anderen diskutieren.<br>- Stimmen Sie fr Artikel um Autoren zu belohnen und selbst Curation Rewards zu verdienen.<br>- Verffentlichen Sie Ihre Artikel, Blog Posts, die kostenlos gehosted werden und erhalten Sie Entgelt fr Interagieren und gewinnen Sie zustzlich Anhnger fr Ihre Inhalte.<br>- Schreiben Sie Artikel von unterwegs. Speichern Sie eine Vielzahl von Entwrfen um diese spter zu verffentlichen.<br>- Bookmarken Sie Ihre Lieblingsartikel, um diese spter zu lesen.<br>- Einnahmen tauschen oder auszahlen.<br>- berweisen Sie Guthaben an Autoren, Nutzer, Freunde, Anhnger, etc.<br>- Folgen Sie interessanten Autoren, Bloggern.<br>- Durchsuchen Sie Inhalte Ihrer Follower und Autoren.<br>- Erhalten Sie Benachrichtigungen von Ihren Follower und Diskussionen, an denen Sie teilgenommen haben.<br>- Suchen Sie interessante Tags / Kategorien aller Artikel und Autoren.<br>- Personalisieren Sie Ihre Profil.<br>- Viele neue Features werden demnchst vorgestellt.<br><br><b>Sicherheit</b><br>1. App hat keinen Zugriff auf Ihre Einnahmen.<br>2. App bieten einfliet-side Sicherheits-Modell mit privaten Schlsseln, die lokal gehostet und niemals an andere Server geschickt werden. Sie sind lediglich dafr verantwortlich Ihre Passwort zu sichern.<br>3. Die App bietet simples Nutzer Interface und attraktive User Erfahrungen<br>4. Die App beinhaltet eine zustzliche Sicherheitsebene durch einen Pin-Code<br><br>eSteem untersttz die Plattformen Steem sowie Golos.<br>",
	"FOUNDER": "Grnder und leitender Entwickler",
	"ADD_ACCOUNT": "Account hinzufgen",
	"PLATFORM": "Plattform",
	"ESCROW": "Treuhandservice",
	"ESCROW_AGENT": "Escrow Agent",
	"RATIFICATION_DEADLINE": "Ratifizierungsfrist",
	"ESCROW_EXPIRATION": "Escrow Ablaufdatum",
	"ESCROW_FEE": "Escrow Gebhr",
	"ESCROW_TERMS": "Escrow Bedingungen",
	"NIGHT_MODE": "Nachtmodus",
	"DAY_MODE": "Tagmodus",
	"VIEW_CONTEXT": "Den ganzen Artikel ansehen",
	"USER_NOTFOUND": "Benutzer nicht gefunden",
	"APPROVE": "Zustimmen",
	"DISPUTE": "Anfechten",
	"RELEASE": "Verffentlichung",
	"FROM": "Von",
	"ID": "iD",
	"SUBMIT": "Senden",
	"RECEIVER": "Empfnger",
	"LOCATION": "Position",
	"WEBSITE": "Webseite",
	"DISPLAY_NAME": "Angezeigter Name"
}
},{}],108:[function(require,module,exports){
module.exports={
	"HOME": "hom",
	"LOGIN": "lgin",
	"LOGOUT": "lgootu",
	"PROFILE": "porfli",
	"FOLLOW": "fluw",
	"BOOKMARKS": "bkumakrz",
	"TRANSFER": "tarnsefr",
	"MARKET": "mrakte",
	"SETTINGS": "stetignz",
	"ABOUT": "abut",
	"ABOUT_1": "wer anyon cna eran rwardz fer thir cntnt!",
	"ABOUT_2": "iz pwered bi {{platformname}} paltfrom. app iz crated bi",
	"ABOUT_3": "and it iz opn-src, cmounti dirvne mbil prjct. it offezr cntnt accezs fer rdng, coemntng, vtoign, pstng, tarnsefr eranignz, etc. ftrz offered bi {{platformname}} blckchin and {{sitename}}.",
	"ABOUT_4": "1. app nver accezs or hlod otno uesr fndz.",
	"ABOUT_5": "2. app offezr a clnt-sid sceurti mdel, wtih pirvta kyez hsotde lcoail and nver snet tu ani srvrz.",
	"ABOUT_6": "3. app offezr smpl, atrtaciv uesr inetrfcz and exprncz.",
	"ABOUT_7": "4. app nver rqeuri usrz tu inpt ani presoanl infrmatn.",
	"ABOUT_8": "vot good-karma az witnsez",
	"ABOUT_9": "kontakt/fedbak:",
	"ABOUT_10": "mur inf:",
	"REMOVE": "rmov",
	"MARKET_VIEW": "mrakte veiw",
	"PRICE": "pirc",
	"AMOUNT": "aomutn",
	"TOTAL": "ttal",
	"NOORDERS": "no oepn odrezr fer",
	"DATE": "dat",
	"BUY": "bui",
	"SELL": "sel",
	"OPEN": "oepn",
	"HISTORY": "hstr",
	"FOLLOW_BACK": "fluw bak",
	"FOLLOWED": "flowed",
	"UNFOLLOW": "unfolow",
	"FOLLOWING": "floownig",
	"FOLLOWERS": "floowrez",
	"SEARCH_FOLLOWERS": "saerhc floowrez",
	"SEARCH_FOLLOWING": "saerhc floownig",
	"BY": "bi",
	"MENU": "mneu",
	"BOOKMARK": "bkmrk",
	"REBLOG": "rbelgo",
	"UPVOTE": "upvt",
	"DOWNVOTE": "dwnvot",
	"UNVOTE_DOWNVOTED": "unvt donwvoed",
	"UNVOTE_UPVOTED": "unvt upvoed",
	"REPLY": "rpli",
	"EDIT": "eidt",
	"POST_1": "siwp lfet on cmentz tu c optinz",
	"POST_2": "tap on cmentz tu c sub-cmntz",
	"OPTIONS": "optinz",
	"RESTEEMED_BY": "rseteemd bi",
	"NOTHING_HERE": "nthng hir, yet...",
	"BALANCES": "blancz",
	"PROFILE_1": "{{platformname}}, traedbal $$ dat cn b trnsfred anytiem. {{platformname}} cn b covnered 2 {{platformpower}} in a prcsz cled pwoernig up.",
	"PROFILE_2": "{{platformpower}}, ifnlunec $$ dat ern mur pwer fer hldng lnog tiem and votign on postz. teh mur u holdz teh mur u cna ifnlunec otherz rwardz and ern rwardz fer accurat votign.",
	"PROFILE_3": "$$ wrth abut {{platformsunit}} of {{platformname}}.",
	"ESTIMATED_VALUE": "esitmaed vlau",
	"PROFILE_4": "teh esitmaed vlau iz bsed on a 7 dai aevrga vlau of {{platformname}}.",
	"TRANSACTION_HISTORY": "transactn hstr",
	"POSTING": "pstng",
	"PROFILE_5": "teh pstng kei iz uesd fer pstng and vtoign. it sohudl b differnt frum teh actv and ownr kyez.",
	"OWNER": "ownr",
	"PROFILE_6": "teh ownr kei iz teh msatre kei fer teh accont and iz rqeuierd tu chng teh othr kyez. teh pirvta kei or psaswrod fer teh ownr kei sohudl b kpet offlni az mcuh az pssbl.",
	"ACTIVE": "actv",
	"PROFILE_7": "teh actv kei iz uesd tu maek trnasfrz and palc odrezr in teh itneranl mrakte.",
	"MEMO": "mmeo",
	"PROFILE_8": "teh mmeo kei iz uesd tu crat and raed mmoz.",
	"BLOG": "bolg",
	"POSTS": "pstz",
	"REPLIES": "rplies",
	"WALLET": "wlet",
	"TAG": "tagg",
	"USER": "uesr",
	"CLOSE": "cols",
	"TO": "to",
	"ASSET": "asst",
	"SEND": "snd",
	"SECURITY": "sceurti",
	"AVAILABLE": "aavilbal",
	"PUBLIC_MEMO": "pbulci mmeo",
	"TO_DESC": "uesr e.g. good-karma",
	"PIN_CODE": "pin cod",
	"PIN_TEXT": "pin cod hlpz yu tu scur app and ur dtaa. <br/><br/><b>note:</b> onc enbled, yu hev max 4 tirz tu unlk, if yu frgt pin or fial, app wil rmov lgogde in uesr dtaa. yu cna r-eloign and cntn usng app.",
	"NOTIFICATIONS": "notifikationz",
	"VOTE_TEXT": "yu wil get notfikatin wehn smoeno vtoz ur cntnt! <br/> <b>nt:</b> notifikationz icnldu vtoign wiegth az wel in alrt messig. (b it upvt, dwnvot, unvt).",
	"VOTE": "vot",
	"COMMENT_TEXT": "yu wil get notfikatin wehn smoeno cmentz on ur pstz or koments!<br/> <b>nt:</b> notifikationz icnldu wehn smoeno <b>dts</b> thir cmentz az wel.",
	"COMMENT": "cmoetn",
	"FOLLOW_TEXT": "yu wil get notfikatin wehn smoeno fluw or unfolow yu!",
	"MENTIONS": "mnetinoz",
	"MENTIONS_TEXT": "yu wil get notfikatin wehn smoeno mnetinoz yu in thir pst/cmnt!",
	"CONFIGURATIONS": "konfguratonz",
	"VOTING": "vtoign",
	"VOTING_TEXT": "vot wiegth or pecrenag affectz vtoign pwer on app, so yu cna rgulat ur vtoign rweadr. <br/><br/><b>note:</b> diz wil chng vtoign weight/percentag fer dwnvting az wel and it iz evreywer on app",
	"SERVER": "srevre",
	"SERVER_TEXT": "rcmnded",
	"SAVE_CHANGES": "sav cahnzg",
	"VOTERS_INFO": "vtoezr ifno",
	"WELCOME_BACK": "wlcum bak!",
	"LOGIN_1": "sgin in wtih ur usrnam and psaswrod tu cntn.",
	"LOGIN_2": "pstng kei iz uesd fer psot, cmoetn, vot, fluw.",
	"LOGIN_3": "actv kei iz uesd fer trnasfrz and porfli pcitru updt.",
	"LOGIN_4": "uesr crdntalz ar kpet lcoail on teh dvic. uopn lgootu crdntalz ar rmoved!",
	"DONT_HAVE": "dnt hev an accont?",
	"SIGN_UP_NOW": "sgin up now",
	"CANCEL": "cnacle",
	"ADVANCED": "avdanecd",
	"ACTIVE_PRIKEY": "actv pirvta kei",
	"POSTING_PRIKEY": "pstng pirvta kei",
	"MASTER_PASS": "mastr/man psaswrod",
	"USERNAME": "usrnam",
	"CARD_VIEW": "crad veiw",
	"COMPACT_VIEW": "cmpct veiw",
	"SEARCH": "saerhc",
	"SUBMIT_A_STORY": "sbumti a stri",
	"REPLYTO": "rpli tu",
	"POST": "psot",
	"PREVIEW": "prvew",
	"DEFAULT": "dfalt 50% / 50%",
	"POWERUP": "pwer up 100%",
	"DECLINE_PAYOUT": "dcelni pyaotu",
	"SAVE_FOR_LATER": "sav fer lter",
	"POST_CONTENT": "psot cntnt",
	"COMMENT_CONTENT": "cmoetn cntnt",
	"TITLE": "ttil",
	"TAGS": "tegz",
	"NOT_MATCH": "not mtch",
	"CONFIRM_PIN": "cnfrm pin",
	"OPENING_POST": "opnng psot",
	"SET_PIN": "set pin",
	"ENTER_PIN": "entr pin",
	"ARE_YOU_SURE": "ar yu sur?",
	"BROADCAST_ERROR": "braodcst eorr, tri agn!",
	"SUCCESS": "sccsz",
	"REBLOGGED_POST": "relboged psot!",
	"LOGIN_FAIL": "lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd pstng pirvta kei on lgin if yu hev cuhsde avdanecd mod.",
	"LOGIN_FAIL_A": "lgin fialde! plz maek sur yu hev lgogde in wtih msatre psaswrod or porviedd actv pirvta kei on lgin if yu hev cohsne avdanecd mod.",
	"WARNING": "wrnng",
	"VOTE_FOR_WITNESS": "vtoign fer wtnsz",
	"VOTED_FOR_WITNESS": "vted fer wtnsz",
	"FROM_NOW": "frum now",
	"SECS": "secz",
	"MINS": "minz",
	"AN_HOUR": "an hrz",
	"HOURS": "hrz",
	"A_DAY": "a dai",
	"DAYS": "dyaz",
	"A_MONTH": "a mnth",
	"MONTHS": "mnotzh",
	"A_YEAR": "a yaer",
	"YEARS": "yarz",
	"MIN_READ": "min raed",
	"DOWNVOTE_FLAG": "dwnvot or falg",
	"CAPTURE_PICTURE": "cpatru pcitur",
	"SELECT_PICTURE": "silect pcitur",
	"SET_CUSTOM_URL": "set csutmo url",
	"INSERT_PICTURE": "isnetr pcitru",
	"ERROR": "eorr",
	"UPLOAD_ERROR": "ulpoda eorr",
	"CAMERA_CANCELLED": "cmaear cnaceeld",
	"SET_URL": "set url",
	"DIRECT_LINK_PICTURE": "drietc web lnik fer teh pcitru",
	"COMMENT_SUBMITTED": "cmoetn iz sumbited!",
	"DELETE_COMMENT": "dleetnig cmentz ar irvrsbl...",
	"DELETED_COMMENT": "dleted cmoetn",
	"UPLOADING_PICTURE": "upoladng pcitru",
	"UPLOAD_COMPLETED": "ulpoda copmleed",
	"UPLOAD_FAILED": "ulpoda fialde",
	"PASSWORD_INCORRECT": "teh psaswrod or accont nam waz icnorcet",
	"INFO": "ifno",
	"QR_TEXT": "palc a qr cod insd teh sacn aera",
	"BALANCE_TEXT": "maek sur yu hev eonuhg $$ fer transactn!",
	"NONEXIST_USER": "uesr yu ar tyrign tu tarnsefr $$, dsn't exst!",
	"TRANSFER_TEXT": "ar yu sur yu wanan tu tarnsefr?",
	"CONFIRMATION": "konfrmatin",
	"TX_BROADCASTED": "transactn iz bradcastd",
	"FEED": "fed",
	"TRENDING": "terndnig",
	"HOT": "hot",
	"NEW": "new",
	"PROMOTED": "pormoetd",
	"VOTES": "vtoz",
	"PAYOUT": "pyaotu",
	"COMMENTS": "cmentz",
	"TRENDING_30": "terndnig fer 30 dyaz",
	"SORT_POST_BY": "srot pstz by:",
	"PAYOUT_CYCLE": "pyaotu ccyl",
	"POTENTIAL_PAYOUT": "poetntal pyaotu",
	"PAST_PAYOUT": "psat pyaotu",
	"AUTHOR_PAYOUT": "atuhro pyaotu",
	"CURATION_PAYOUT": "cruatoin pyaotu",
	"POST_SUBMITTED": "psot iz sumbited!",
	"POST_LATER": "psot fer lter sbmsson!",
	"SAVED": "sved",
	"CLEARED": "clared",
	"FLAGGING_TEXT": "falggnig a psot cna rmov rwardz and maek diz mtaerail lsez visible.<br><br>th falg sohudl b uesd fer teh foolwig: <ul><li>fraut or plagiarism</li><li>hat spch or itnerent troling</li><li>intentional mskategorzed cntnt or spam</l></ul>",
	"REQUEST_LIMIT_TEXT": "rqust lmit rched. cehk out othr trnd/tegz!",
	"POST_IS_UNBOOKMARK": "psot iz rmoved frum bkumakrz!",
	"POST_IS_BOOKMARK": "psot iz addd tu bkumakrz!",
	"RESET": "rset",
	"MODIFY_PICTURE": "chng porfli pcitru",
	"MODIFY_COVER_PICTURE": "chng cver pcitru",
	"ACTIVE_KEY_REQUIRED_TEXT": "plz porvdi actv pirvta kei if yu hev cohsne avdanecd lgin mod!",
	"RESET_PICTURE_TEXT": "diz wil rset uesr porfli pcitru",
	"RESET_COVER_PICTURE_TEXT": "diz wil rset uesr cver pcitru",
	"UPDATE_REQUIRES_RESTART": "srevre updt rqurz rstrt!",
	"SETTINGS_UPDATED": "stetignz ar updated!",
	"LANGUAGES": "lnagugaz",
	"LANGUAGES_TEXT": "hir yu cna chng lngag of teh app.",
	"LOGIN_TO_X": "diz opreaton rqurz uesr tu b lgogde in wtih mian psaswrod, aktve/postng kei. plz lgin and tri agn.",
	"GALLERY": "glaeir",
	"TRANSLATIONS": "translatn kontrbutrz",
	"SHARE": "shre",
	"MARKETPLACE": "mrakte palc",
	"EXCHANGE": "exchng",
	"DRAFTS": "darfzt",
	"POST_IS_UNDRAFT": "psot iz rmoved frum darfzt!",
	"POST_IS_DRAFT": "psot iz addd tu darfzt!",
	"SWIPE_LEFT": "siwp lfet tu c optinz",
	"MANAGE": "mnag",
	"IMAGE_REMOVED": "iamg iz rmoved",
	"COPY": "cpoi",
	"NO_IMAGE": "yu hev not ulpoaedd ani iamg, yet!",
	"PULL_DOWN_TO_REFRESH": "pul dwon tu rfrsh",
	"EXTERNAL_APPS": "etxeranl appz",
	"PLUGINS": "plgnz",
	"SUGGEST": "sggst",
	"COMING_SOON": "cmoign sun",
	"CHAIN": "chin",
	"CHAIN_TEXT": "hir yu cna chng blckchin or dfalt paltfrom."
}
},{}],109:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "          !",
	"ABOUT_2": "    {{platformname}}.   ",
	"ABOUT_3": "   ,    .,     , , , ,  , .      {{platformname}} blockchain   {{sitename}}.",
	"ABOUT_4": "1.            .",
	"ABOUT_5": "2.             ,      \"\"        .",
	"ABOUT_6": "3.          .",
	"ABOUT_7": "4,        .",
	"ABOUT_8": " good-karma  witness",
	"ABOUT_9": "/",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "    ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": " ",
	"SEARCH_FOLLOWERS": "   ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": " ",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": " -",
	"UNVOTE_UPVOTED": " -",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "       ",
	"POST_2": "      -",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": " , ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},  ,      . {{platformname}}     {{platformpower}}      powering up. ",
	"PROFILE_2": "{{platformpower}},        ,      .       ,             .",
	"PROFILE_3": "   {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": "   ",
	"PROFILE_4": "          {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "          .        \"\"     \"\".",
	"OWNER": "",
	"PROFILE_6": "                 .                  .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": " - ",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": " . good-karma",
	"PIN_CODE": " PIN",
	"PIN_TEXT": " PIN          . <br/><br/><b>:</b>   ,  max 4   .     PIN  ,         .          .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "        . <br/> <b>:</b>            . ( ,  , -).",
	"VOTE": "",
	"COMMENT_TEXT": "         !<br/> <b>:</b>        <b></b>   .",
	"COMMENT": "",
	"FOLLOW_TEXT": "           .",
	"MENTIONS": "",
	"MENTIONS_TEXT": "        / .",
	"RESTEEM": "",
	"RESTEEM_TEXT": "       .",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "\"\"         ,       <br/><br/><b>:</b>     \"\"/            ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": " ",
	"WELCOME_BACK": "  !",
	"LOGIN_1": "         .",
	"LOGIN_2": "     , ,       .",
	"LOGIN_3": "          .",
	"LOGIN_4": "      .       .",
	"DONT_HAVE": "  ?",
	"SIGN_UP_NOW": "  ",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "/ ",
	"USERNAME": " ",
	"CARD_VIEW": "  ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"POWERUP": "  100%",
	"DECLINE_PAYOUT": " ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " PIN",
	"ENTER_PIN": " PIN",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "    ,   ?",
	"BROADCAST_ERROR": " ,  !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !                   .",
	"LOGIN_FAIL_A": "  !                   .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  witness",
	"VOTED_FOR_WITNESS": "  witness",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": ".",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": " ",
	"DAYS": "",
	"A_MONTH": " ",
	"MONTHS": "",
	"A_YEAR": " ",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "    Flag",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "    ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "     ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": " ",
	"PASSWORD_INCORRECT": "       ",
	"INFO": "",
	"QR_TEXT": "  QR    ",
	"BALANCE_TEXT": "      !",
	"NONEXIST_USER": "      ,  !",
	"TRANSFER_TEXT": "      ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "    ",
	"TRENDING": " ",
	"HOT": "   ",
	"NEW": " ",
	"PROMOTED": "",
	"VOTES": " ",
	"PAYOUT": " ",
	"COMMENTS": " ",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": "  Curation",
	"POST_SUBMITTED": "  !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "             .<br><br>       : <ul><li>    </li><li>   Trolling</li><li>       Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "     .   /",
	"POST_IS_UNBOOKMARK": "     !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": "  ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "  /Active       !",
	"RESET_PICTURE_TEXT": "       ",
	"RESET_COVER_PICTURE_TEXT": "     ",
	"UPDATE_REQUIRES_RESTART": "     !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "       .",
	"LOGIN_TO_X": "             active/posting key.    .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "\n",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "     ",
	"POST_IS_DRAFT": "    ",
	"SWIPE_LEFT": "      ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    ",
	"PULL_DOWN_TO_REFRESH": "     ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "           .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "       .      /     .",
	"ABOUT_11": "<br><b>   </b> <br>-        . <br> -\"\"     . <br>-         . <br>-   ,              . <br>-       ,    . <br>-         . <br>-     . <br>-    , , ,   <br>-  , bloggers. <br> -       . <br>-               . <br>-  / , . <br> -   . <br>-     . <br><br><b></b> <br>1.             . <br>2.           -,              ,            . <br>3.           <br>4.          pin <br><br>   Steem  Golos. <br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": ""
}
},{}],110:[function(require,module,exports){
module.exports={
	"HOME": "Home",
	"LOGIN": "Login",
	"LOGOUT": "Logout",
	"PROFILE": "Profile",
	"FOLLOW": "Follow",
	"BOOKMARKS": "Bookmarks",
	"TRANSFER": "Transfer",
	"MARKET": "Market",
	"SETTINGS": "Settings",
	"ABOUT": "About",
	"ABOUT_1": "where anyone can earn rewards for their content!",
	"ABOUT_2": "is social application where you get paid for blogging, commenting and curating.",
	"ABOUT_3": "and it is open-source, community driven mobile project. It offers content access for reading, commenting, voting, posting, transfer earnings, etc. features offered by {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. App never access or hold onto user funds.",
	"ABOUT_5": "2. App offers a client-side security model, with private keys hosted locally and never sent to any servers.",
	"ABOUT_6": "3. App offers simple, attractive user interfaces and experiences.",
	"ABOUT_7": "4. App never require users to input any personal information.",
	"ABOUT_8": "Vote good-karma as witness",
	"ABOUT_9": "Contact/Feedback:",
	"ABOUT_10": "More info:",
	"REMOVE": "Remove",
	"MARKET_VIEW": "Market View",
	"PRICE": "Price",
	"AMOUNT": "Amount",
	"TOTAL": "Total",
	"NOORDERS": "No open orders for",
	"DATE": "Date",
	"BUY": "Buy",
	"SELL": "Sell",
	"OPEN": "Open",
	"HISTORY": "History",
	"FOLLOW_BACK": "Follow back",
	"FOLLOWED": "Followed",
	"UNFOLLOW": "Unfollow",
	"FOLLOWING": "Following",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Search followers",
	"SEARCH_FOLLOWING": "Search following",
	"BY": "by",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Unvote Downvoted",
	"UNVOTE_UPVOTED": "Unvote upvoted",
	"REPLY": "Reply",
	"EDIT": "Edit",
	"POST_1": "Swipe left on comments to see options",
	"POST_2": "Tap on comments to see sub-comments",
	"OPTIONS": "Options",
	"RESTEEMED_BY": "Reblogged by",
	"NOTHING_HERE": "Nothing here, yet...",
	"BALANCES": "Balances",
	"PROFILE_1": "{{platformname}}, tradeable tokens that may be transferred at anytime. {{platformname}} can be converted to {{platformpower}} in a process called powering up.",
	"PROFILE_2": "{{platformpower}}, influence tokens that earn more power for holding long term and voting on posts. The more one holds the more one can influence others rewards and earn rewards for accurate voting.",
	"PROFILE_3": "Tokens worth about {{platformsunit}} of {{platformname}}.",
	"ESTIMATED_VALUE": "Estimated Value",
	"PROFILE_4": "The estimated value is based on a 7 day average value of {{platformname}}.",
	"TRANSACTION_HISTORY": "Transaction History",
	"POSTING": "Posting",
	"PROFILE_5": "The posting key is used for posting and voting. It should be different from the active and owner keys.",
	"OWNER": "Owner",
	"PROFILE_6": "The owner key is the master key for the account and is required to change the other keys. The private key or password for the owner key should be kept offline as much as possible.",
	"ACTIVE": "Active",
	"PROFILE_7": "The active key is used to make transfers and place orders in the internal market.",
	"MEMO": "Memo",
	"PROFILE_8": "The memo key is used to create and read memos.",
	"BLOG": "Blog",
	"POSTS": "Posts",
	"REPLIES": "Replies",
	"WALLET": "Wallet",
	"TAG": "Tag",
	"USER": "User",
	"CLOSE": "Close",
	"TO": "To",
	"ASSET": "Asset",
	"SEND": "Send",
	"SECURITY": "Security",
	"AVAILABLE": "Available",
	"PUBLIC_MEMO": "Public Memo",
	"TO_DESC": "User e.g. good-karma",
	"PIN_CODE": "Pin Code",
	"PIN_TEXT": "PIN code helps you to secure app and your data. <br/><br/><b>Note:</b> Once enabled, you have max 4 tries to unlock, if you forgot pin or fail, app will remove logged in user data. You can re-login and continue using app.",
	"NOTIFICATIONS": "Notifications",
	"VOTE_TEXT": "You will get notification when someone votes your content! <br/> <b>Note:</b> Notifications include voting weight as well in alert message. (be it up-vote, down-vote, un-vote).",
	"VOTE": "Vote",
	"COMMENT_TEXT": "You will get notification when someone comments on your posts or comments!<br/> <b>Note:</b> Notifications include when someone <b>edits</b> their comments as well.",
	"COMMENT": "Comment",
	"FOLLOW_TEXT": "You will get notification when someone Follow or Unfollow you!",
	"MENTIONS": "Mentions",
	"MENTIONS_TEXT": "You will get notification when someone mentions you in their post/comment!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "You will get notification when someone reblogs your post!",
	"CONFIGURATIONS": "Configurations",
	"VOTING": "Voting",
	"VOTING_TEXT": "Vote weight or percentage affects voting power on app, so you can regulate your voting reward. <br/><br/><b>Note:</b> This will change voting weight/percentage for downvoting as well and it is everywhere on app",
	"SERVER": "Server",
	"SERVER_TEXT": "Recommended",
	"SAVE_CHANGES": "Save Changes",
	"VOTERS_INFO": "Voters info",
	"WELCOME_BACK": "Welcome back!",
	"LOGIN_1": "Sign in with your username and password to continue.",
	"LOGIN_2": "Posting key is used for post, comment, vote, follow.",
	"LOGIN_3": "Active key is used for transfers and profile picture update.",
	"LOGIN_4": "User credentials are kept locally on the device. Upon Logout credentials are removed!",
	"DONT_HAVE": "Don't have an account?",
	"SIGN_UP_NOW": "Sign up now",
	"CANCEL": "Cancel",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Active private key",
	"POSTING_PRIKEY": "Posting private key",
	"MASTER_PASS": "Master/main password",
	"USERNAME": "Username",
	"CARD_VIEW": "Card view",
	"COMPACT_VIEW": "Compact view",
	"SEARCH": "Search",
	"SUBMIT_A_STORY": "Submit a story",
	"REPLYTO": "Reply to",
	"POST": "Post",
	"PREVIEW": "Preview",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Decline Payout",
	"SAVE_FOR_LATER": "SAVE FOR LATER",
	"CLEAR": "CLEAR",
	"POST_CONTENT": "Post content",
	"COMMENT_CONTENT": "Comment content",
	"TITLE": "Title",
	"TAGS": "Tags",
	"NOT_MATCH": "NOT MATCH",
	"CONFIRM_PIN": "Confirm PIN",
	"INCORRECT": "INCORRECT",
	"OPENING_POST": "opening post",
	"SET_PIN": "Set PIN",
	"ENTER_PIN": "Enter PIN",
	"ARE_YOU_SURE": "Are you sure?",
	"REBLOG_TEXT": "Reblog is irreversible, do you want to continue?",
	"BROADCAST_ERROR": "Broadcast error, try again!",
	"SUCCESS": "Success",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Login failed! Please make sure you have logged in with master password or provided Posting private key on Login if you have choosed Advanced mode.",
	"LOGIN_FAIL_A": "Login failed! Please make sure you have logged in with master password or provided Active private key on Login if you have chosen Advanced mode.",
	"WARNING": "Warning",
	"VOTE_FOR_WITNESS": "Voting for witness",
	"VOTED_FOR_WITNESS": "Voted for witness",
	"AGO": "ago",
	"FROM_NOW": "from now",
	"SECS": "secs",
	"A_MIN": "a min",
	"MINS": "mins",
	"AN_HOUR": "an hr",
	"HOURS": "hrs",
	"A_DAY": "a day",
	"DAYS": "days",
	"A_MONTH": "a month",
	"MONTHS": "months",
	"A_YEAR": "a year",
	"YEARS": "years",
	"MIN_READ": "min read",
	"DOWNVOTE_FLAG": "Downvote or Flag",
	"CAPTURE_PICTURE": "Capture Picture",
	"SELECT_PICTURE": "Select Picture",
	"SET_CUSTOM_URL": "Set Custom URL",
	"INSERT_PICTURE": "Insert Picture",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Upload Error",
	"CAMERA_CANCELLED": "Camera Cancelled",
	"SET_URL": "Set URL",
	"DIRECT_LINK_PICTURE": "Direct web link for the picture",
	"COMMENT_SUBMITTED": "Comment is submitted!",
	"DELETE_COMMENT": "Deleting comments are irreversible...",
	"DELETED_COMMENT": "Deleted comment",
	"UPLOADING_PICTURE": "Uploading Picture",
	"UPLOAD_COMPLETED": "Upload Completed",
	"UPLOAD_FAILED": "Upload Failed",
	"PASSWORD_INCORRECT": "The password or account name was incorrect",
	"INFO": "Info",
	"QR_TEXT": "Place a QR code inside the scan area",
	"BALANCE_TEXT": "Make sure you have enough balance for transaction!",
	"NONEXIST_USER": "User you are trying to transfer fund, doesn't exist!",
	"TRANSFER_TEXT": "Are you sure you want to transfer?",
	"CONFIRMATION": "Confirmation",
	"TX_BROADCASTED": "Transaction is broadcasted",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "Hot",
	"NEW": "New",
	"PROMOTED": "Promoted",
	"VOTES": "Votes",
	"PAYOUT": "Payout",
	"COMMENTS": "Comments",
	"TRENDING_30": "Trending for 30 days",
	"SORT_POST_BY": "Sort Posts By:",
	"PAYOUT_CYCLE": "Payout Cycle",
	"POTENTIAL_PAYOUT": "Potential Payout",
	"PAST_PAYOUT": "Past Payout",
	"AUTHOR_PAYOUT": "Author Payout",
	"CURATION_PAYOUT": "Curation Payout",
	"POST_SUBMITTED": "Post is submitted!",
	"POST_LATER": "Post for later submission!",
	"SAVED": "Saved",
	"CLEARED": "Cleared",
	"FLAGGING_TEXT": "Flagging a post can remove rewards and make this material less visible.<br><br>The flag should be used for the following: <ul><li>Fraud or Plagiarism</li><li>Hate Speech or Internet Trolling</li><li>Intentional miscategorized content or Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Request limit reached. Check out other trend/tags!",
	"POST_IS_UNBOOKMARK": "Post is removed from bookmarks!",
	"POST_IS_BOOKMARK": "Post is added to bookmarks!",
	"RESET": "Reset",
	"MODIFY_PICTURE": "Modify Profile Picture",
	"MODIFY_COVER_PICTURE": "Modify Cover Picture",
	"ACTIVE_KEY_REQUIRED_TEXT": "Please provide Active private key if you have chosen Advanced login mode!",
	"RESET_PICTURE_TEXT": "This will reset user profile picture",
	"RESET_COVER_PICTURE_TEXT": "This will reset user cover picture",
	"UPDATE_REQUIRES_RESTART": "Server update requires Restart!",
	"SETTINGS_UPDATED": "Settings are updated!",
	"LANGUAGES": "Languages",
	"LANGUAGES_TEXT": "Here you can change language of the app.",
	"LOGIN_TO_X": "This operation requires user to be logged in with main password, active/posting key. Please login and try again.",
	"GALLERY": "Gallery",
	"TRANSLATIONS": "Translation contributors",
	"SHARE": "Share",
	"MARKETPLACE": "Market Place",
	"EXCHANGE": "Exchange",
	"DRAFTS": "Drafts",
	"POST_IS_UNDRAFT": "Post is removed from drafts!",
	"POST_IS_DRAFT": "Post is added to drafts!",
	"SWIPE_LEFT": "Swipe left to see options",
	"MANAGE": "Manage",
	"IMAGE_REMOVED": "Image is removed",
	"COPY": "Copy",
	"NO_IMAGE": "You have not uploaded any image, yet!",
	"PULL_DOWN_TO_REFRESH": "Pull down to refresh",
	"EXTERNAL_APPS": "External Apps",
	"PLUGINS": "Plugins",
	"SUGGEST": "Suggest",
	"COMING_SOON": "Coming soon",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Here you can change blockchain or default platform.",
	"CURRENCY": "Currency",
	"CURRENCY_TEXT": "Here you can change your default currency. You will see post/comment reward value in this currency.",
	"ABOUT_11": "<br><b>Feature list</b><br>- Access unique articles in any subject you are interested reading.<br>- Engage with authors by commenting, discussing topics.<br>- Voting for posts to reward author as well as earn curation reward.<br>- Publish your articles, blog posts and host them for free and earn rewards by engaging and gain followers.<br>- Write articles on go, save multiple drafts of the post for later publication.<br>- Bookmark favorite articles to read later.<br>- Exchange or cash out your earnings.<br>- Send your funds to any authors or users, friends, followers, etc.<br>- Follow interesting authors, bloggers.<br>- Search your followers and authors you are following.<br>- Get notifications to stay in touch with your followers and discussions you are involved in.<br>- Search for interesting tags/categories of articles, authors.<br>- Personalize your profile.<br>- Many more features to come.<br><br><b>Security</b><br>1. App never access or hold onto user funds.<br>2. App offer a client-side security model, with private keys hosted locally and never sent to any servers, you are responsible to backing up your passwords.<br>3. App offers simple, attractive user interfaces and experiences<br>4. App offers extra layer of security with pin-code<br><br>eSteem supports Steem and Golos platforms.<br>",
	"FOUNDER": "Founder and Lead developer",
	"ADD_ACCOUNT": "Add account",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Ratification deadline",
	"ESCROW_EXPIRATION": "Escrow expiration",
	"ESCROW_FEE": "Escrow fee",
	"ESCROW_TERMS": "Escrow terms",
	"NIGHT_MODE": "Night mode",
	"DAY_MODE": "Day mode",
	"VIEW_CONTEXT": "View the full context",
	"USER_NOTFOUND": "User Not Found",
	"APPROVE": "Approve",
	"DISPUTE": "Dispute",
	"RELEASE": "Release",
	"FROM": "From",
	"ID": "id",
	"SUBMIT": "Submit",
	"RECEIVER": "Receiver",
	"LOCATION": "Location",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Display name"
}
},{}],111:[function(require,module,exports){
module.exports={
	"HOME": "Hogar",
	"LOGIN": "Iniciar Sesin",
	"LOGOUT": "Cerrar Sesin",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Marcadores",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Ajustes",
	"ABOUT": "Acerca de",
	"ABOUT_1": "donde todo el mundo puede obtener ganancias por su contenido",
	"ABOUT_2": "provisto por la plataforma {{platformname}}. App creada por",
	"ABOUT_3": "es un proyecto de mvil impulsado por la comunidad, de cdigo abierto. Ofrece acceso al contenido para su lectura, comentarios, votos, publicaciones, transferencia de ganancias, etc; caractersticas ofrecidas por la cadena de bloques {{platformname}} y {{sitename}}.",
	"ABOUT_4": "1. La App nunca accede o retiene fondos de los usuarios.",
	"ABOUT_5": "2. La App ofrece un modelo de seguridad del cliente con contraseas privadas almacenadas localmente y que no son nunca enviadas a ningn servidor.",
	"ABOUT_6": "3. La App ofrece una experiencia y una interfaz simple y atractica.",
	"ABOUT_7": "4. La App nunca pide que los usuarios introduzcan ninguna informacin personal.",
	"ABOUT_8": "Vota a good-karma como testigo",
	"ABOUT_9": "Contacto/Sugerencias",
	"ABOUT_10": "Ms informacin",
	"REMOVE": "Eliminar",
	"MARKET_VIEW": "Vista de Mercado",
	"PRICE": "Precio",
	"AMOUNT": "Cantidad",
	"TOTAL": "Total",
	"NOORDERS": "Sin rdenes abiertas para",
	"DATE": "Fecha",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Historial",
	"FOLLOW_BACK": "Devolver Seguimiento",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Dejar de Seguir",
	"FOLLOWING": "Siguiendo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Buscar seguidores",
	"SEARCH_FOLLOWING": "Buscar seguidos",
	"BY": "por",
	"IN": "en",
	"MENU": "Men",
	"BOOKMARK": "Marcador",
	"REBLOG": "Rebloguear",
	"UPVOTE": "Voto Positivo",
	"DOWNVOTE": "Voto Negativo",
	"UNVOTE_DOWNVOTED": "Deshacer Voto Negativo",
	"UNVOTE_UPVOTED": "Deshacer Voto Positivo",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Desliza a la izquierda en los comentarios para ver las opciones",
	"POST_2": "Pulsa en los comentarios para ver los subcomentarios",
	"OPTIONS": "Opciones",
	"RESTEEMED_BY": "Resteemed por",
	"NOTHING_HERE": "Nada por aqu an...",
	"BALANCES": "Saldos",
	"PROFILE_1": "{{platformname}}, fichas comerciables que pueden ser transferidas en cualquier momento. {{platformname}} pueden ser convertidas a {{platformpower}} en un proceso llamado power up.",
	"PROFILE_2": "{{platformpower}}, fichas de influencia que consiguen ms poder por mantenerlas a largo plazo y votar en los posts. Cuantas ms tengas ms influencia tendrs en las recompensas que le das al resto de usuarios y ms recompensas obtendrs por tus votos.",
	"PROFILE_3": "Valor de las fichas {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor Estimado",
	"PROFILE_4": "El valor estimado se basa en un valor promedio de 7 das de {{platformname}}.",
	"TRANSACTION_HISTORY": "Historial de Transacciones",
	"POSTING": "Publicacin",
	"PROFILE_5": "La clave de publicacin es utilizada para publicar y votar. Tiene que ser diferente a la clave activa y a la clave de propietario.",
	"OWNER": "Propietario",
	"PROFILE_6": "La clave de propietario es la clave maestra de la cuenta y se requiere para cambiar las otras claves. La clave o contrasea privada de la clave de propietario debera ser mantenida \"offline\" tanto como sea posible.",
	"ACTIVE": "Activa",
	"PROFILE_7": "La clave activa se utiliza para hacer transferencias y hacer pedidos en el mercado interno.",
	"MEMO": "Memorndum",
	"PROFILE_8": "La clave de memorndums se utiliza para crear y leer memorndums.",
	"BLOG": "Escribe",
	"POSTS": "Publicaciones",
	"REPLIES": "Respuestas",
	"WALLET": "Monedero",
	"TAG": "Etiqueta",
	"USER": "Usuario",
	"CLOSE": "Cerrar",
	"TO": "A",
	"ASSET": "Posesin de Capital",
	"SEND": "Enviar",
	"SECURITY": "Seguridad",
	"AVAILABLE": "Disponible",
	"PUBLIC_MEMO": "Memorndum Pblico",
	"TO_DESC": "Usuario ej. good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "El cdigo PIN te ayuda a dar seguridad a la app y a tus datos.\n<br/><br/><b>Nota:</b> Una vez activado, tienes un mximo de 4 intentos para desbloquearlo; si te olvidas de tu pin o fallas, la app eliminar los registros en los datos de usuario. Puedes volver a iniciar sesin y continuar usando la app.",
	"NOTIFICATIONS": "Notificaciones",
	"VOTE_TEXT": "Recibirs una notificacin cuando alguien vote tu contenido! <br/> <b>Nota:</b> Las notificaciones incluyen tambin el peso de la votacin en el mensaje de alerta. (ya sea por votacin positiva, votacin negativa, deshacer votacin).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Recibirs una notificacin cuando alguien comente en tus publicaciones o comentarios!<br/> <b>Note:</b> Las notificaciones incluyen cuando alguien <b>edita</b> sus comentarios tambin.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Recibirs una notificacin cuando alguien te siga o te deje de seguir!",
	"MENTIONS": "Menciones",
	"MENTIONS_TEXT": "Recibirs una notificacin cuando alguien te mencione en su publicacin/comentario!",
	"RESTEEM": "Rebloguear",
	"RESTEEM_TEXT": "Recibirs una notificacin cuando alguien haga reblog a tu publicacin!",
	"CONFIGURATIONS": "Configuraciones",
	"VOTING": "Voto",
	"VOTING_TEXT": "El peso o porcentaje del voto afecta al poder de votacin en la app, de tal manera que puedes regular tu recompensa de votacin. <br/><br/><b>Nota:</b> Esto cambiar tambin el peso/porcentaje del voto a la hora de hacer un voto negativo",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Guardar Cambios",
	"VOTERS_INFO": "Info de votantes",
	"WELCOME_BACK": "Bienvenido!",
	"LOGIN_1": "Regstrate con tu nombre de usuario y contrasea para continuar.",
	"LOGIN_2": "La clave de publicacin se usa para publicar, comentar, votar, seguir.",
	"LOGIN_3": "La clave activa se usa para las transferencias y la actualizacin de la foto de perfil.",
	"LOGIN_4": "Las credenciales del usuario se guardan localmente en el dispositivo. Al cerrar la sesin las credenciales son eliminadas!",
	"DONT_HAVE": "No tienes una cuenta?",
	"SIGN_UP_NOW": "Regstrate ahora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanzado",
	"ACTIVE_PRIKEY": "Clave activa privada",
	"POSTING_PRIKEY": "Clave de publicacin privada",
	"MASTER_PASS": "Contrasea maestra/principal",
	"USERNAME": "Nombre de Usuario",
	"CARD_VIEW": "Vista de casillas",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Buscar",
	"SUBMIT_A_STORY": "Publicar un artculo",
	"REPLYTO": "Responder a",
	"POST": "Publicar",
	"PREVIEW": "Previsualizacin",
	"DEFAULT": "Por defecto 50% / 50%",
	"POWERUP": "Potenciacin 100%",
	"DECLINE_PAYOUT": "Rechazar Pago",
	"SAVE_FOR_LATER": "GUARDAR PARA MS TARDE",
	"CLEAR": "BORRAR",
	"POST_CONTENT": "Publicar contenido",
	"COMMENT_CONTENT": "Comentar contenido",
	"TITLE": "Ttulo",
	"TAGS": "Etiquetas",
	"NOT_MATCH": "NO COINCIDE",
	"CONFIRM_PIN": "Confirmar PIN",
	"INCORRECT": "INCORRECTO",
	"OPENING_POST": "Post inicial",
	"SET_PIN": "Establecer PIN",
	"ENTER_PIN": "Introducir PIN",
	"ARE_YOU_SURE": "Ests seguro?",
	"REBLOG_TEXT": "Reblogear es irreversible deseas continuar?",
	"BROADCAST_ERROR": "Error de transmisin, intntalo de nuevo!",
	"SUCCESS": "Conseguido",
	"REBLOGGED_POST": "Publicacin Reblogueada",
	"LOGIN_FAIL": "Inicio de sesin fallido! Por favor asegrate de que has iniciado sesin con tu contrasea maestra o con la clave de Publicacin privada proporcionada en el apartado Iniciar Sesin si elegiste el Modo Avanzado.",
	"LOGIN_FAIL_A": "Inicio de sesin fallido! Por favor asegrate de que has iniciado sesin con tu contrasea maestra o con la clave Activa privada en el apartado Iniciar Sesin si elegiste el Modo Avanzado.",
	"WARNING": "Advertencia",
	"VOTE_FOR_WITNESS": "Votar a testigo",
	"VOTED_FOR_WITNESS": "Votado a testigo",
	"AGO": "hace",
	"FROM_NOW": "desde ahora",
	"SECS": "segundos",
	"A_MIN": "un minuto",
	"MINS": "minutos",
	"AN_HOUR": "una hora",
	"HOURS": "horas",
	"A_DAY": "un da",
	"DAYS": "das",
	"A_MONTH": "un mes",
	"MONTHS": "meses",
	"A_YEAR": "un ao",
	"YEARS": "aos",
	"MIN_READ": "minutos de lectura",
	"DOWNVOTE_FLAG": "Votar Negativamente o Marcar Como Inapropiado",
	"CAPTURE_PICTURE": "Tomar foto",
	"SELECT_PICTURE": "Seleccionar Imagen",
	"SET_CUSTOM_URL": "Establecer URL personalizada",
	"INSERT_PICTURE": "Insertar Imagen",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Error al Cargar",
	"CAMERA_CANCELLED": "Cmara Cancelada",
	"SET_URL": "Establecer URL",
	"DIRECT_LINK_PICTURE": "Enlace web directo a la imagen",
	"COMMENT_SUBMITTED": "El comentario se ha entregado!",
	"DELETE_COMMENT": "Eliminar comentarios es irreversible...",
	"DELETED_COMMENT": "Eliminar comentario",
	"UPLOADING_PICTURE": "Subiendo Imagen",
	"UPLOAD_COMPLETED": "Subida Completada",
	"UPLOAD_FAILED": "La subida ha fallado",
	"PASSWORD_INCORRECT": "La contrasea o el nombre de cuenta son incorrectos",
	"INFO": "Informacin",
	"QR_TEXT": "Coloca el cdigo QR dentro de la zona de escaneo",
	"BALANCE_TEXT": "Asegrate de que tienes suficiente saldo para la transaccin!",
	"NONEXIST_USER": "El usuario al que ests intentando transferir fondos no existe!",
	"TRANSFER_TEXT": "Ests seguro de que quieres hacer la transferencia?",
	"CONFIRMATION": "Confirmacin",
	"TX_BROADCASTED": "Transaccin transmitida",
	"FEED": "Inicio",
	"TRENDING": "Tendencias",
	"HOT": "Caliente",
	"NEW": "Nuevo",
	"PROMOTED": "Promocionado",
	"VOTES": "Votos",
	"PAYOUT": "Pago",
	"COMMENTS": "Comentarios",
	"TRENDING_30": "Siendo Tendencia durante 30 das",
	"SORT_POST_BY": "Ordenar Publicaciones Por",
	"PAYOUT_CYCLE": "Ciclo de Pago",
	"POTENTIAL_PAYOUT": "Pago Potencial",
	"PAST_PAYOUT": "Pago Pasado",
	"AUTHOR_PAYOUT": "Pago de Autor",
	"CURATION_PAYOUT": "Pago de Curacin",
	"POST_SUBMITTED": "La publicacin fue enviada!",
	"POST_LATER": "Publicacin para posterior presentacin!",
	"SAVED": "Guardado",
	"CLEARED": "Borrado",
	"FLAGGING_TEXT": "Marcar como inapropiada una publicacin puede eliminar las recompensas y hacer que el material marcado sea menos visible.<br><br> Marcar como inapropiado debe utilizarse en los siguientes casos: <ul><li>Fraude o Plagio</li><li>Discursos de Odio o Actitudes de Provocacin y Molestia Constantes</li><li>Contenido categrizado mal intencionadamente o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Lmite de solicitud alcanzado. Revisa otras etiquetas/tendencias!",
	"POST_IS_UNBOOKMARK": "Publicacin eliminada de los marcadores!",
	"POST_IS_BOOKMARK": "Publicacin aadida a marcadores!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar Foto de Perfil",
	"MODIFY_COVER_PICTURE": "Modificar Foto de Portada",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor proporciona la clave Activa privada si has elegido el modo de Inicio de Sesin Avanzado!",
	"RESET_PICTURE_TEXT": "Esto reiniciar la foto de perfil del usuario",
	"RESET_COVER_PICTURE_TEXT": "Esto reiniciar la foto de portada del usuario",
	"UPDATE_REQUIRES_RESTART": "La actualizacin del servidor requiere un reinicio!",
	"SETTINGS_UPDATED": "Ajustes actualizados!",
	"LANGUAGES": "Idiomas",
	"LANGUAGES_TEXT": "Aqu puedes cambiar el idioma de la app",
	"LOGIN_TO_X": "Esta operacin requiere que el usuario inicie sesin con la contrasea maestra/principal, clave activa/publicar. Por favor inicia sesin y vuelve a intentarlo.",
	"GALLERY": "Galera",
	"TRANSLATIONS": "Colaboradores de traducciones",
	"SHARE": "Compartir",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cambio",
	"DRAFTS": "Borradores",
	"POST_IS_UNDRAFT": "La publicacin se ha eliminado de borradores!",
	"POST_IS_DRAFT": "La publicacin se ha aadido a borradores!",
	"SWIPE_LEFT": "Deslice hacia la izquierda para ver las opciones",
	"MANAGE": "Gestionar",
	"IMAGE_REMOVED": "La foto se ha eliminado",
	"COPY": "Copiar",
	"NO_IMAGE": "An no has subido ninguna foto!",
	"PULL_DOWN_TO_REFRESH": "Tire hacia abajo para actualizar",
	"EXTERNAL_APPS": "Apps externas",
	"PLUGINS": "Extensiones",
	"SUGGEST": "Sugerir",
	"COMING_SOON": "Muy pronto",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Aqu puedes cambiar la blockchain o la plataforma por defecto.",
	"CURRENCY": "Divisa",
	"CURRENCY_TEXT": "Aqu puede cambiar su moneda por defecto. Ver el valor de recompensa post/comentario en esta moneda.",
	"ABOUT_11": "<br><b>Lista de Caractersticas</b><br> Accede a artculos nicos de cualquier tema en los que ests interesado <br> Comparte con los autores comentando, discutiendo temas.<br> Votar los artculos recompensa al autor tanto como gana recompensas por curacin de contenidos. <br> Publica tus artculos, notas de blog, hospeda gratuitamente y gana recompensas al atraer y ganar seguidores.<br> Escribe artculos en vivo, as como tambin guardar mltiples borradores del articulo para futura publicacin.<br> Marca tus artculos favoritos para leerlos mas tarde.<br> Intercambia o saca dinero de tus ganancias<br> Envia fondos a cualquier autor o usuario, amigos, seguidores, etc.<br> Sigue autores interesantes, bloggers.<br> Busca tus seguidores y autores que sigues.<br> Recibe notificaciones para mantenerte en contacto con tus seguidores y discusiones en las que estes involucrado. <br> Busca categoras/etiquetas de artculos y autores.<br>Personaliza tu perfil.<br> Muchas mas funcionalidades por venir.<br><br><b>Seguridad</b><br>1. La aplicacin nunca acceder o mantendr fondos de usuarios. <br>2. La aplicacin ofrece un modelo de seguridad lado-cliente, con claves privadas hospedadas localmente y nunca enviadas a ningn servidor, usted es responsable de respaldar sus contraseas.<br>3. La aplicacin ofrece una experiencia del usuario simple y atractiva, a travs de su interfaz. <br>4. La aplicacin ofrece una capa extra de seguridad con un cdigo-pin<br><br>Soporte de eSteem soporta Steem y Plataformas Golos.<br>",
	"FOUNDER": "Fundador y desarrollador Principal",
	"ADD_ACCOUNT": "Aadir cuenta",
	"PLATFORM": "Plataforma",
	"ESCROW": "Depsito de garanta",
	"ESCROW_AGENT": "Agente Escrow",
	"RATIFICATION_DEADLINE": "Fecha lmite de ratificacin",
	"ESCROW_EXPIRATION": "Vencimiento Escrow",
	"ESCROW_FEE": "Tarifa de Escrow",
	"ESCROW_TERMS": "Trminos de Escrow",
	"NIGHT_MODE": "Modo Noche",
	"DAY_MODE": "Modo Da",
	"VIEW_CONTEXT": "Ver el texto completo",
	"USER_NOTFOUND": "Usuario No Encontrado",
	"APPROVE": "Aprobada",
	"DISPUTE": "Conflicto",
	"RELEASE": "Liberar",
	"FROM": "Desde",
	"ID": "ID",
	"SUBMIT": "Enviar",
	"RECEIVER": "Recibir",
	"LOCATION": "Localizacin",
	"WEBSITE": "Pgina Web",
	"DISPLAY_NAME": "Mostrar nombre"
}
},{}],112:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": " ",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "           !",
	"ABOUT_2": "   {{ }}   .     ",
	"ABOUT_3": "                 .                      .     {{ }}  {{ }}   .",
	"ABOUT_4": ".              .",
	"ABOUT_5": ".                       .",
	"ABOUT_6": ".         .",
	"ABOUT_7": ".        .",
	"ABOUT_8": " good-karma     ",
	"ABOUT_9": "/:",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "  ",
	"FOLLOWED": " ",
	"UNFOLLOW": "  ",
	"FOLLOWING": " ",
	"FOLLOWERS": " ",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "  ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": " ",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "       .",
	"POST_2": "       .",
	"OPTIONS": "",
	"RESTEEMED_BY": "  ",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{ }}            . {{ }}            {{  }}  .",
	"PROFILE_2": "{{  }}               .                        .",
	"PROFILE_3": "    {{platformsunit}}  {{ }}.",
	"ESTIMATED_VALUE": "  ",
	"PROFILE_4": "         {{ }} .",
	"TRANSACTION_HISTORY": " ",
	"POSTING": " ",
	"PROFILE_5": "           .         .",
	"OWNER": "",
	"PROFILE_6": "              .              .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": "",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": " ",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": "  good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "         . <br/><br/><b>:</b>                              .           .",
	"NOTIFICATIONS": " ",
	"VOTE_TEXT": "             ! <br/> <b>:</b>          . (      ).",
	"VOTE": " ",
	"COMMENT_TEXT": "             !<br/> <b>:</b>         <b></b>   .",
	"COMMENT": " ",
	"FOLLOW_TEXT": "                !",
	"MENTIONS": " ",
	"MENTIONS_TEXT": "       /        !",
	"RESTEEM": "  ",
	"RESTEEM_TEXT": "              !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "                  . <br/><br/><b>:</b>  /                 ",
	"SERVER": "",
	"SERVER_TEXT": " ",
	"SAVE_CHANGES": "  ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": "         .",
	"LOGIN_2": "               .",
	"LOGIN_3": "           .",
	"LOGIN_4": "        .      !",
	"DONT_HAVE": " ",
	"SIGN_UP_NOW": "  ",
	"CANCEL": " ",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "   ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": "  ",
	"REPLYTO": "  ",
	"POST": " ",
	"PREVIEW": "",
	"DEFAULT": "  / ",
	"POWERUP": "   ",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "   ",
	"CLEAR": " ",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " ",
	"INCORRECT": "",
	"OPENING_POST": "  ",
	"SET_PIN": " ",
	"ENTER_PIN": "  ",
	"ARE_YOU_SURE": "",
	"REBLOG_TEXT": "        ",
	"BROADCAST_ERROR": "    !",
	"SUCCESS": "",
	"REBLOGGED_POST": "   !",
	"LOGIN_FAIL": "    !                            .",
	"LOGIN_FAIL_A": "    !                           .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "   ",
	"VOTED_FOR_WITNESS": "    ",
	"AGO": "",
	"FROM_NOW": " ",
	"SECS": "",
	"A_MIN": " ",
	"MINS": "",
	"AN_HOUR": " ",
	"HOURS": "",
	"A_DAY": " ",
	"DAYS": "",
	"A_MONTH": " ",
	"MONTHS": "",
	"A_YEAR": " ",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "    ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "   ",
	"INSERT_PICTURE": "  ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": "  ",
	"SET_URL": "  ",
	"DIRECT_LINK_PICTURE": "    ",
	"COMMENT_SUBMITTED": "  !",
	"DELETE_COMMENT": "    ...",
	"DELETED_COMMENT": "  ",
	"UPLOADING_PICTURE": "    ",
	"UPLOAD_COMPLETED": "  ",
	"UPLOAD_FAILED": "    ",
	"PASSWORD_INCORRECT": "     ",
	"INFO": "",
	"QR_TEXT": "        ",
	"BALANCE_TEXT": "        !",
	"NONEXIST_USER": "       !",
	"TRANSFER_TEXT": "     ",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "  ",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "   ",
	"SORT_POST_BY": "  :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": "  !",
	"POST_LATER": "    !",
	"SAVED": " ",
	"CLEARED": " ",
	"FLAGGING_TEXT": "                  .<br><br>       : <ul><li>   </li><li>   </li><li>     </li></ul>",
	"REQUEST_LIMIT_TEXT": "   .  /   !",
	"POST_IS_UNBOOKMARK": "    !",
	"POST_IS_BOOKMARK": "    !",
	"RESET": " ",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "               !",
	"RESET_PICTURE_TEXT": "       ",
	"RESET_COVER_PICTURE_TEXT": "       ",
	"UPDATE_REQUIRES_RESTART": "     !",
	"SETTINGS_UPDATED": "  !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "       .",
	"LOGIN_TO_X": "           /    .       .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": " ",
	"MARKETPLACE": "",
	"EXCHANGE": " ",
	"DRAFTS": " ",
	"POST_IS_UNDRAFT": "       !",
	"POST_IS_DRAFT": "       !",
	"SWIPE_LEFT": "      ",
	"MANAGE": "",
	"IMAGE_REMOVED": "  ",
	"COPY": "",
	"NO_IMAGE": "    !",
	"PULL_DOWN_TO_REFRESH": "      ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": " ",
	"CHAIN": "",
	"CHAIN_TEXT": "         .",
	"CURRENCY": " ",
	"CURRENCY_TEXT": "             /          .",
	"ABOUT_11": "<br><b>  </b><br>-                  .<br>-               .<br>-                   .<br>-                               .<br>-                      .<br>-             .<br>-               .<br>-          .<br>-          .<br>-             .<br>-                   .<br>-                  .<br>-      .<br>-      .<br><br><b></b><br>1.         .<br>2.                                     .<br>3.             <br>4.             .<br><br>esteem    Steem  Golos   .<br>",
	"FOUNDER": "    ",
	"ADD_ACCOUNT": "  ",
	"PLATFORM": "",
	"ESCROW": " ",
	"ESCROW_AGENT": "   ",
	"RATIFICATION_DEADLINE": " ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": " ",
	"FROM": " ",
	"ID": " ",
	"SUBMIT": "",
	"RECEIVER": " ",
	"LOCATION": "",
	"WEBSITE": " ",
	"DISPLAY_NAME": "     "
}
},{}],113:[function(require,module,exports){
module.exports={
	"HOME": "Bahay",
	"LOGIN": "Mag-Login",
	"LOGOUT": "Lumabas",
	"PROFILE": "Iyong Profile",
	"FOLLOW": "sundan",
	"BOOKMARKS": "Mga Bookmark",
	"TRANSFER": "Ilipat",
	"MARKET": "Merkado",
	"SETTINGS": "Mga Setting",
	"ABOUT": "Tungkol dito",
	"ABOUT_1": "kung saan na kahit sino ang puwedeng kumita sa kanilang nilathala!",
	"ABOUT_2": "ay sosyal na aplikasyon kung saan babayaran ka sa pag-boblog, pag-kukumentaryo at pagpili ng tama.",
	"ABOUT_3": "at ito ay open-source, proyektong pang kumunindad. Nag o-offer ng akses sa pagbasa ng mga nilathala, pagkumentaryo, pagboto, paglathala, paglipat ng pera at iba pa na ino-offer ng {{platformname}} at ng {{sitename}}.",
	"ABOUT_4": "1. Di pinapayagan ng App ang pag-akses o pag-hawak ng pondo ng may-ari.",
	"ABOUT_5": "2. Ang App ay nag o-offer ng client-side na seguridad, na may pribadong keys na lokal at hindi nagpapadala sa anumang server.",
	"ABOUT_6": "3. Ang App ay nag o-offer ng payak, mga atraktib na user interfaces at mga karanasan.",
	"ABOUT_7": "Ang App ay hindi kailanman pumipilit sa mga may-ari na maglagay ng personal na impormasyon.",
	"ABOUT_8": "Iboto ang good-karma bilang tistigo",
	"ABOUT_9": "Kontak/Tugon:",
	"ABOUT_10": "Maraming info:",
	"REMOVE": "Tinangal",
	"MARKET_VIEW": "Tanawin ng Merkado",
	"PRICE": "Presyo",
	"AMOUNT": "Halagd",
	"TOTAL": "Kabuohan",
	"NOORDERS": "Walang bukas na order",
	"DATE": "Petsa",
	"BUY": "Bili",
	"SELL": "Benta",
	"OPEN": "Bukas",
	"HISTORY": "Kasaysayan",
	"FOLLOW_BACK": "Sundan_pabalik",
	"FOLLOWED": "sinundan",
	"UNFOLLOW": "Wag sundan",
	"FOLLOWING": "sinusundan",
	"FOLLOWERS": "sumusunod",
	"SEARCH_FOLLOWERS": "hanapin ang mga sumusunod",
	"SEARCH_FOLLOWING": "hanapin ang mga sinusundan",
	"BY": "ni",
	"IN": "sa",
	"MENU": "pagpipilian",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Uliting i-blog",
	"UPVOTE": "Pagboto ng mataas",
	"DOWNVOTE": "Pagboto ng mababa",
	"UNVOTE_DOWNVOTED": "Tanggalin ang Pagboto ng mababa",
	"UNVOTE_UPVOTED": "Tanggalin ang Pagboto ng mataas",
	"REPLY": "sagot",
	"EDIT": "Baguhin",
	"POST_1": "padulasin pakaliwa sa kumentaryo para makita ang pagpipilian",
	"POST_2": "I-tap ang mga komento para makita ang iba pang komentong nakapaloob",
	"OPTIONS": "pagpipilian",
	"RESTEEMED_BY": "Inulit na i-blog ni",
	"NOTHING_HERE": "wala pa dito",
	"BALANCES": "Balanse",
	"PROFILE_1": "{{platformname}}, mga tradeable na token na puwedeng ilipat kahit anumang oras.{{platformname}} puwedeng i-convert sa {{platformpower}} na isang prosesong tinatawag na powering up.",
	"PROFILE_2": "{{platformpower}}, impluwensya ng mga token na kumita ng higit pang power sa paghahawak ng matagal at pagboto sa mga ipinost. Kapag marami ang hinawakan mas malaki ang puwedeng maibigay na rewards.",
	"PROFILE_3": "Kahalagahan ng mga token tungkol sa{{platformsunit}} ng {{platformname}}.",
	"ESTIMATED_VALUE": "enistimang halaga",
	"PROFILE_4": "Ang tinatayang halaga ay nakabase sa isang 7-araw na karaniwang halaga ng {{platformname}}.",
	"TRANSACTION_HISTORY": "Kasaysayan ng mga Transaksyon",
	"POSTING": "Pag-post",
	"PROFILE_5": "Ang susi sa pagpost ay ginagamit sa pag-popost at pagboto. Dapat iba ito sa aktib na susi at susi ng may-ari.",
	"OWNER": "may ari",
	"PROFILE_6": "Ang susi ng may-ari ay ang master key para sa account at kailangan ito para sa pag-iba ng ibang keys. Ang pribadong key o ang password ng susi ng may-ari ay dapat itago offline.",
	"ACTIVE": "aktibo",
	"PROFILE_7": "Ang aktib na susi ay ginagamit sa paglipat at paglagay ng order sa internal na merkado.",
	"MEMO": "Tala",
	"PROFILE_8": "Ang susi ng tala ay ginagamit sa paggawa at pagbasa ng mga tala.",
	"BLOG": "Blog",
	"POSTS": "Posts",
	"REPLIES": "mga sagot",
	"WALLET": "pitaka",
	"TAG": "Tag",
	"USER": "Gumagamit",
	"CLOSE": "sara",
	"TO": "para kay",
	"ASSET": "Asset",
	"SEND": "pinadala",
	"SECURITY": "seguridad",
	"AVAILABLE": "Nagagamit",
	"PUBLIC_MEMO": "Publikong Tala",
	"TO_DESC": "Gumagamit halimbawa, good-karma",
	"PIN_CODE": "Pin Code",
	"PIN_TEXT": "Ang PIN code ay tumutulong sa pag siguro ng app at ng iyong mga datos.<br/><br/><b> Tandaan:</b> Kapag naka enable, may higit 4 na beses ka mag unlock, kapag nakalimutan mo ito, ang datos ng gumagamit ay tatanggalin ng app. Maaari kang mag re-login at magpatuloy sa paggamit ng app.",
	"NOTIFICATIONS": "Mga Abiso",
	"VOTE_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao na boboto sa ipinost mo! <br/><b>Tandaan:</b> Nakapaloob din sa mga abiso ang bigat ng iyong pagboto at mga mensaheng may alerto.",
	"VOTE": "boto",
	"COMMENT_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao na magkukumento sa mga pinost at mga komento mo!<br/><b>Tandaan:</b>Nakapaloob din sa mga abiso kung may sino mang tao <b>ang mag bago</b> sa kanilang mga komento.",
	"COMMENT": "kumentaryo",
	"FOLLOW_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang susunod at di susunod sa iyo!",
	"MENTIONS": "sinabi",
	"MENTIONS_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang babanggit sa pangalan mo sa posts/komento nila!",
	"RESTEEM": "Uliting i-blog",
	"RESTEEM_TEXT": "Makakakuha ka ng abiso kapag may sino mang tao ang mag uulit sa pagblog ng iyong ipinost!",
	"CONFIGURATIONS": "Configurations",
	"VOTING": "binoboto",
	"VOTING_TEXT": "Ang bigat ng pagboto ay nakakaapekto sa power ng pagboto, kaya puwede mong ma-iregulate ang reward sa pagboto.<br/><br/><b>Tandaan:</b>Makakaiba ito sa bigat ng pagboto kapag bumoto ka ng mababa",
	"SERVER": "Server",
	"SERVER_TEXT": "Nirerekomenda",
	"SAVE_CHANGES": "I-save ang mga Pagbabago",
	"VOTERS_INFO": "Impormasyon ng mga botante",
	"WELCOME_BACK": "maligayang pagbabalik",
	"LOGIN_1": "Mag-sign in gamit ang iyong username at password para magpatuloy.",
	"LOGIN_2": "Ang susi ng pag-post ay ginagamit sa pag-post, komento, pagboto, pag-sunod.",
	"LOGIN_3": "Ang aktib na susi ay ginagamit sa paglipat at pag-update ng larawan ng may-ari.",
	"LOGIN_4": "Ang mga kredensyal ng gumagamit ay lokal na tinatago sa device. Kapag nag-logout, ang mga kredensyal ay tinatanggal!",
	"DONT_HAVE": "Wala pang account?",
	"SIGN_UP_NOW": "Mag-sign up",
	"CANCEL": "Kaselahin",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Pribadong aktib na susi",
	"POSTING_PRIKEY": "Pribadong susi sa pag-post",
	"MASTER_PASS": "Master/main password",
	"USERNAME": "Username",
	"CARD_VIEW": "Tanawin ng card",
	"COMPACT_VIEW": "Tanawing compact",
	"SEARCH": "hanapin",
	"SUBMIT_A_STORY": "magpapasa ng storya",
	"REPLYTO": "sumagot kay",
	"POST": "Post",
	"PREVIEW": "Preview",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Tanggihan ang Payout",
	"SAVE_FOR_LATER": "I-SAVE PARA MAMAYA",
	"CLEAR": "BURAHIN",
	"POST_CONTENT": "Pag-post ng nilalaman",
	"COMMENT_CONTENT": "Magkumento sa nilalaman",
	"TITLE": "titolo",
	"TAGS": "Tags",
	"NOT_MATCH": "HINDI TUGMA",
	"CONFIRM_PIN": "Kumpirhamin ang PIN",
	"INCORRECT": "hindi tama",
	"OPENING_POST": "ang post ay binubuksan",
	"SET_PIN": "Mag-set ng PIN",
	"ENTER_PIN": "ipasok ang pin",
	"ARE_YOU_SURE": "sigurado ka?",
	"REBLOG_TEXT": "Ang pagulit sa pagblog ay hindi mawawalan ng bisa, gusto mo bang magpatuloy?",
	"BROADCAST_ERROR": "Error sa pag-broadcast, subukang muli!",
	"SUCCESS": "Tagumpay",
	"REBLOGGED_POST": "Ang post ay nai-blogged ulit!",
	"LOGIN_FAIL": "Bigo sa pag-login! Mangyaring tiyakin ang master password o ang pribadong susi sa pag-post kung pinili mo ang Advanced mode.",
	"LOGIN_FAIL_A": "Bigo sa pag-login! Mangyaring tiyakin ang master password o ang pribadong aktib na susi kung pinili mo ang Advanced mode.",
	"WARNING": "babala",
	"VOTE_FOR_WITNESS": "ibinoto para maging testigo",
	"VOTED_FOR_WITNESS": "binoto para maging testigo",
	"AGO": "nakalipas",
	"FROM_NOW": "mula ngayon",
	"SECS": "segondo",
	"A_MIN": "isang minuto",
	"MINS": "mga minuto",
	"AN_HOUR": "isang oras",
	"HOURS": "mga oras",
	"A_DAY": "isang araw",
	"DAYS": "mga araw",
	"A_MONTH": "isang buwan",
	"MONTHS": "mga buwan",
	"A_YEAR": "isang taon",
	"YEARS": "mga taon",
	"MIN_READ": "minuto sa pagbasa",
	"DOWNVOTE_FLAG": "Pagboto ng mababa o Flag",
	"CAPTURE_PICTURE": "Kunan ng Larawan",
	"SELECT_PICTURE": "pili ng litrato",
	"SET_CUSTOM_URL": "Mag-set ng Custom URL",
	"INSERT_PICTURE": "Mag-insert ng Larawan",
	"ERROR": "Error",
	"UPLOAD_ERROR": "Error sa Pag-upload",
	"CAMERA_CANCELLED": "Kinansela ang Camera",
	"SET_URL": "I-set ang URL",
	"DIRECT_LINK_PICTURE": "Direkta na web link para sa larawan",
	"COMMENT_SUBMITTED": "kumento ay napasa na",
	"DELETE_COMMENT": "bura ang kumento",
	"DELETED_COMMENT": "nabura na ang kumento",
	"UPLOADING_PICTURE": "Ang larawan ay ina-upload",
	"UPLOAD_COMPLETED": "Ang pag-upload ay nakumpleto",
	"UPLOAD_FAILED": "Bigo ang pag-upload",
	"PASSWORD_INCORRECT": "Ang password o account ay hindi tama",
	"INFO": "Impormasyon",
	"QR_TEXT": "Ilagay ang QR code sa loob ng scan area",
	"BALANCE_TEXT": "Siguraduhing may sapat na balanse para sa transaksyon!",
	"NONEXIST_USER": "Ang gumagamit na gusto mong lipatan ng pondo ay di matagpuan!",
	"TRANSFER_TEXT": "sigurado ka na gusto mo ilipat?",
	"CONFIRMATION": "Kompirmasyon",
	"TX_BROADCASTED": "Ang transaksyon ay nai-broadcast",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "mainit",
	"NEW": "bago",
	"PROMOTED": "Promoted",
	"VOTES": "mga boto",
	"PAYOUT": "bayad",
	"COMMENTS": "kumento",
	"TRENDING_30": "Trending sa 30 araw",
	"SORT_POST_BY": "Uriin ang mga post ng:",
	"PAYOUT_CYCLE": "Payout Cycle",
	"POTENTIAL_PAYOUT": "Potensyal na Payout",
	"PAST_PAYOUT": "nakaraang bayaad",
	"AUTHOR_PAYOUT": "bayad sa may akda",
	"CURATION_PAYOUT": "Curation Payout",
	"POST_SUBMITTED": "Ang post ay nai-submit!",
	"POST_LATER": "Post para sa mamayang pag-submit!",
	"SAVED": "Nai-save",
	"CLEARED": "Nai-bura",
	"FLAGGING_TEXT": "Sa pag-flag ng post na ito ay maaring matanggal ang rewards at ang material ay di na makikita.<br><br>Ang pag-flag ay puwedeng gamitin laban sa: <ul><li>Kasinungalingan o Pagkopya</li><li>Hate Speech o Internet Trolling</li><li>Di categorado na nilalaman o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Umabot sa limitasyon ang hinihiling. Tignan ang ibang trends/tags!",
	"POST_IS_UNBOOKMARK": "Ang post ay natanggal sa mga bookmarks!",
	"POST_IS_BOOKMARK": "Ang post ay naidagdag sa mga bookmarks!",
	"RESET": "I-reset",
	"MODIFY_PICTURE": "Baguhin ang larawan ng may-ari",
	"MODIFY_COVER_PICTURE": "Baguhin ang Cover ng Larawan",
	"ACTIVE_KEY_REQUIRED_TEXT": "Mangyaring magbigay ng pribadong aktib na susi kung pinili mo ang Advanced login mode!",
	"RESET_PICTURE_TEXT": "Iri-reset nito ang larawan ng gumagamit",
	"RESET_COVER_PICTURE_TEXT": "Iri-reset nito ang cover na larawan ng gumagamit",
	"UPDATE_REQUIRES_RESTART": "Kailangan i-restart para sa server update!",
	"SETTINGS_UPDATED": "Na-update ang mga settings!",
	"LANGUAGES": "lenguage",
	"LANGUAGES_TEXT": "Dito mo puwedeng ibahin ang lingguwahe ng app.",
	"LOGIN_TO_X": "Main password ang kailangan sa operasyon na ito. Mangyaring mag-login at subukang muli.",
	"GALLERY": "Gallery",
	"TRANSLATIONS": "Mga nag-ambag ng pagsasalin",
	"SHARE": "Ibahagi",
	"MARKETPLACE": "Lugar ng Merkado",
	"EXCHANGE": "magpalit",
	"DRAFTS": "Mga Borador",
	"POST_IS_UNDRAFT": "Ang post ay tinanggal sa mga borador!",
	"POST_IS_DRAFT": "Ang post ay naidagdag sa mga borador!",
	"SWIPE_LEFT": "padulasin pakaliwa para makita ang pagpipilian",
	"MANAGE": "Pamahalaan",
	"IMAGE_REMOVED": "natangal na ang imahe",
	"COPY": "copya",
	"NO_IMAGE": "walang larawan",
	"PULL_DOWN_TO_REFRESH": "Hilahin para mai-refresh",
	"EXTERNAL_APPS": "Panlabas na mga App",
	"PLUGINS": "Plugins",
	"SUGGEST": "Magmungkahi",
	"COMING_SOON": "Malapit na",
	"CHAIN": "Kadena",
	"CHAIN_TEXT": "Dito mi puwedeng baguhin ang blockchain o default na platform.",
	"CURRENCY": "Pera",
	"CURRENCY_TEXT": "Dito mo puwedeng baguhin ang iyong default na pera.",
	"ABOUT_11": "<br><b>Tampok na listahan</b> <br>-Akses sa kakaibang artikulo sa anumang paksa mo ay interesado sa pagbabasa. <br> -Makisali sa may-akda sa pamamagitan ng pagkumento, pagtalakay ng mga paksa. <br>-Pagboto para sa post na may rewards sa mga awtor pati rewards sa curation. <br>-Paglathala ng mga artikulo, blog post at mag-host sa kanila nang libre at kumita ng premyo sa pagsali at magkaroon ng tagasunod. <br>-Sumulat ng artikulo tungkol sa mga bagay, maliban sa maraming borador ng ang post na ito para sa mga mamaya publikasyon. <br>-Bookmark paborito ninyong mga artikulo para basahin sa ibang pagkakataon. <br>-Exchange o cash out sa iyong kita. <br>-Padala mong pera para sa anumang mga may-akda o mga gumagamit, mga kaibigan, mga tagasunod, at kung anu-ano pa <br>Follow kawili-wiling mga may-akda, blogger. <br> -Saliksikin ang inyong mga tagasunod at sinusunod mo ang mga may-akda. Kumuha ng mga <br>notification na manatiling may ugnayan sa iyong mga tagasunod at talakayan kayo ay kasangkot. pa <br>-Search para sa kawili-wiling tags/kategorya ng artikulo, may-akda. <br> -I-personalize ang iyong profile. <br>Sa maraming karagdagang tampok na darating. <br><br><b>Security</b> <br>1 I-access ang app kailanman o humawak ng mga gumagamit ng mga pondo. <br>2. app ay nag-aalok ng isang modelo ng seguridad sa client side, may pribadong susi na naka-host sa kanilang lugar at hindi nagpadala sa anumang mga server, ikaw ay responsable para sa pag-back up ng iyong password. <br>3. app ay nag-aalok ng mga gumagamit ng simple at kaakit-akit na interfaces at <br>4 mga karanasan. App ay nag-aalok ng dagdag na patong ng seguridad sa Kodigo ng pin <br><br>pagpapahalaga ay sumusuporta sa Steem at Golos na platform. <br>",
	"FOUNDER": "Tagapagtatag at Nangungunang Developer",
	"ADD_ACCOUNT": "Magdagdag ng account",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Deadline sa pagpapatibay",
	"ESCROW_EXPIRATION": "Escrow expiration",
	"ESCROW_FEE": "Bayad sa Escrow",
	"ESCROW_TERMS": "Mga tuntunin sa Escrow",
	"NIGHT_MODE": "Pang-gabi na mode",
	"DAY_MODE": "Pang-umagang mode",
	"VIEW_CONTEXT": "Tignan ang buong konteksto",
	"USER_NOTFOUND": "Hindi mahanap ang gumagamit",
	"APPROVE": "Aprubahan",
	"DISPUTE": "Pagtatalo",
	"RELEASE": "Release",
	"FROM": "Mula sa",
	"ID": "id",
	"SUBMIT": "Isumite",
	"RECEIVER": "Tagatanggap",
	"LOCATION": "Lokasyon",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Pangalan na nakadisplay"
}
},{}],114:[function(require,module,exports){
module.exports={
	"HOME": "Accueil",
	"LOGIN": "Connexion",
	"LOGOUT": "Dconnexion",
	"PROFILE": "Profil",
	"FOLLOW": "Suivre",
	"BOOKMARKS": "Signets",
	"TRANSFER": "Transfert",
	"MARKET": "March",
	"SETTINGS": "Paramtres",
	"ABOUT": "A propos",
	"ABOUT_1": "o n'importe qui peut gagner des rcompenses pour son contenu!",
	"ABOUT_2": "est support par la plate-forme {{platformname}}. Application cre par",
	"ABOUT_3": "Il s'agit d'un projet pour la communaut mobile et il est open-source. Il offre un accs pour lire, commenter, voter, poster, afficher le transfert de rcompense, etc. Toutes les fonctionnalits offertes par {{sitename}} et la blockchain {{platformname}}.",
	"ABOUT_4": "1. L'application n'a jamais accs aux fonds de l'utilisateur.",
	"ABOUT_5": "2. L'application offre un modle de scurit  ses client, avec des cls prives hberges localement et jamais envoyes  aucun serveurs.",
	"ABOUT_6": "3. L'application offre une interface simple et des expriences attrayantes aux utilisateurs.",
	"ABOUT_7": "4. L'application ne demande jamais  ce que les utilisateurs saisissent des informations personnelles.",
	"ABOUT_8": "Votez pour good-karma comme tmoin",
	"ABOUT_9": "Contact/Raction:",
	"ABOUT_10": "Plus d'infos:",
	"REMOVE": "Supprimer",
	"MARKET_VIEW": "Vue du march",
	"PRICE": "Prix",
	"AMOUNT": "Montant",
	"NOORDERS": "Pas d'ordres ouverts pour",
	"BUY": "Achat",
	"SELL": "Vente",
	"OPEN": "Ouvert",
	"HISTORY": "Historique",
	"FOLLOW_BACK": "Suivre",
	"FOLLOWED": "Abonn",
	"UNFOLLOW": "Dsabonner",
	"SEARCH_FOLLOWERS": "Chercher followers",
	"SEARCH_FOLLOWING": "Chercher following",
	"BY": "par",
	"IN": "dans",
	"BOOKMARK": "Signet",
	"UNVOTE_DOWNVOTED": "Retirer Downvote",
	"UNVOTE_UPVOTED": "Retirer Upvote",
	"REPLY": "Rpondre",
	"EDIT": "Editer",
	"POST_1": "Glisser vers la gauche sur les commentaires pour voir les options",
	"POST_2": "Appuyez sur les commentaires pour voir les sous-commentaires",
	"RESTEEMED_BY": "Resteem par",
	"NOTHING_HERE": "Rien ici encore...",
	"BALANCES": "Soldes",
	"PROFILE_1": "Les {{platformname}}, jetons ngociables qui peuvent tre transfrs  tout moment. Le {{platformname}} peut tre converti en {{platformpower}} dans un processus appel power-up.",
	"PROFILE_2": "{{platformpower}}, jetons d'influence, vous gagnez plus de Steem Power en le concervant  long terme et en votant sur les postes. Plus on le conserve, plus on a d'influence sur les rcompenses des autres et dans l'obtention de rcompense pour un vote en particulier.",
	"PROFILE_3": "Jetons d'une valeur d'environ {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valeur estime",
	"PROFILE_4": "La valeur estime est calcule sur une moyenne de 3.5 jours de la valeur du {{platformname}}.",
	"TRANSACTION_HISTORY": "Historique des Transactions",
	"POSTING": "Poste",
	"PROFILE_5": "La cl de post est utilise pour poster et voter. Elle doit tre diffrente des cls actives et propritaires.",
	"OWNER": "Propritaire",
	"PROFILE_6": "La cl propritaire est la cl principale du compte et est requise pour changer les autres cls. La cl prive ou le mot de passe de la cl propritaire doivent tre mis hors ligne autant que possible.",
	"PROFILE_7": "La cl active est utilise pour effectuer des transferts et passer des ordres dans le march intrieur.",
	"MEMO": "Mmo",
	"PROFILE_8": "La cl mmo permet de crer et de lire des mmos.",
	"REPLIES": "Rponses",
	"WALLET": "Portefeuille",
	"USER": "Utilisateur",
	"CLOSE": "Fermer",
	"TO": "",
	"ASSET": "Type",
	"SEND": "Envoyer",
	"SECURITY": "Scurit",
	"AVAILABLE": "Disponible",
	"PUBLIC_MEMO": "Mmo publique",
	"TO_DESC": "Utilisateur par ex. good-karma",
	"PIN_CODE": "Code PIN",
	"PIN_TEXT": "Le code PIN vous aide  scuriser l'application et vos donnes. <br/><br/><b>Note:</b> Une fois activ, vous avez 4 tentatives maximum pour dverrouiller, si vous avez oubli le pin ou si vous chouez, l'application supprimera les donnes utilisateur enregistres. Vous pouvez vous reconnecter et continuer  utiliser l'application.",
	"VOTE_TEXT": "Vous recevrez une notification quand quelqu'un votera pour un des vos contenus! <br/> <b>Note:</b> Les notifications incluent le poids du vote dans le message d'alerte. (Qu'il s'agisse d'un upvote, d' un downvote ou d'un vote retir).",
	"COMMENT_TEXT": "Vous recevrez une notification quand quelqu'un commentera un des vos posts ou un de vos commentaires!<br/> <b>Note:</b> Les notifications incluent quand quelqu'un <b>dite</b> ses propres commentaires aussi.",
	"COMMENT": "Commentaire",
	"FOLLOW_TEXT": "Vous recevrez une notification quand quelqu'un s'abonnera ou se dsabonnera de vous!",
	"MENTIONS_TEXT": "Vous recevrez une notification quand quelqu'un vous mentionnera dans un post/commentaire!",
	"VOTING": "Vote",
	"VOTING_TEXT": "Le poids ou le pourcentage du vote affecte le pouvoir de vote dans l'application, de telle manire vous pouvez rgler votre rcompense de vote. <br/><br/><b>Note:</b> Cela changera le poids/pourcentage du vote pour le downvote partout dans l'application",
	"SERVER": "Serveur",
	"SERVER_TEXT": "Recommand",
	"SAVE_CHANGES": "Sauvegarder les changements",
	"VOTERS_INFO": "Info vote",
	"WELCOME_BACK": "Bienvenue  nouveau!",
	"LOGIN_1": "Connectez-vous avec votre nom d'utilisateur et votre mot de passe pour continuer.",
	"LOGIN_2": "La cl de posts est utilise pour poster, commenter, voter, suivre.",
	"LOGIN_3": "La cl active est utilise pour les transferts et la mise  jour de l'image de profil.",
	"LOGIN_4": "Les informations d'identification de l'utilisateur sont conserves localement sur votre appareil. Lors de la dconnexion elles sont supprimes!",
	"DONT_HAVE": "Pas encore de compte?",
	"SIGN_UP_NOW": "Enregistrez-vous maintenant",
	"CANCEL": "Supprimer",
	"ADVANCED": "Avanc",
	"ACTIVE_PRIKEY": "Cl prive active",
	"POSTING_PRIKEY": "Cl prive de posts",
	"MASTER_PASS": "Mot de passe principal",
	"USERNAME": "Nom d'utilisateur",
	"CARD_VIEW": "Vue thuile",
	"COMPACT_VIEW": "Vue compacte",
	"SEARCH": "Rechercher",
	"SUBMIT_A_STORY": "Proposer un post",
	"REPLYTO": "Rpondre ",
	"PREVIEW": "Aperu",
	"DEFAULT": "Par dfaut 50% / 50%",
	"DECLINE_PAYOUT": "Refuser le payement",
	"SAVE_FOR_LATER": "Sauvegarder pour plus tard",
	"CLEAR": "Effacer",
	"POST_CONTENT": "Poster le contenu",
	"COMMENT_CONTENT": "Commenter",
	"TITLE": "Titre",
	"NOT_MATCH": "Pas de concordance",
	"CONFIRM_PIN": "Confirmer PIN",
	"OPENING_POST": "Ouverture du post",
	"SET_PIN": "Configurer PIN",
	"ENTER_PIN": "Entrer PIN",
	"ARE_YOU_SURE": "Vous tes sur?",
	"BROADCAST_ERROR": "Erreur de diffusion, essayer  nouveau!",
	"SUCCESS": "Russite",
	"REBLOGGED_POST": "Post reblog!",
	"LOGIN_FAIL": "Echec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou votre cl prive de post si vous avez choisi le mode avanc.",
	"LOGIN_FAIL_A": "chec de la connexion! Veuillez vous assurer d'avoir ouvert une session avec le mot de passe principal ou avoir fourni une cl prive active lors de la connexion si vous avez choisi le mode Avanc.",
	"WARNING": "Attention",
	"VOTE_FOR_WITNESS": "Vote pour tmoin",
	"VOTED_FOR_WITNESS": "a vot pour tmoin",
	"AGO": "depuis",
	"FROM_NOW": " partir de maintenant",
	"SECS": "Secondes",
	"A_MIN": "une min",
	"AN_HOUR": "une heure",
	"HOURS": "h",
	"A_DAY": "un jour",
	"DAYS": "jours",
	"A_MONTH": "un mois",
	"MONTHS": "mois",
	"A_YEAR": "une anne",
	"YEARS": "annes",
	"MIN_READ": "min temps lecture",
	"DOWNVOTE_FLAG": "Downvote",
	"CAPTURE_PICTURE": "Capturer Image",
	"SELECT_PICTURE": "Slectionner Image",
	"SET_CUSTOM_URL": "Configurer URL personnalise",
	"INSERT_PICTURE": "Insrer Image",
	"ERROR": "Erreur",
	"UPLOAD_ERROR": "Erreur tlchargement",
	"CAMERA_CANCELLED": "Camra supprime",
	"SET_URL": "Configurer URL",
	"DIRECT_LINK_PICTURE": "Lien direct pour l'image",
	"COMMENT_SUBMITTED": "Commentaire envoy!",
	"DELETE_COMMENT": "La suppression des commentaires est irrversible.",
	"DELETED_COMMENT": "Commentaire supprim",
	"UPLOADING_PICTURE": "Tlchargement de l'image",
	"UPLOAD_COMPLETED": "Tlchargement termin",
	"UPLOAD_FAILED": "Tlchargement chou",
	"PASSWORD_INCORRECT": "Mot de passe ou nom d'utilisateur incorrect",
	"QR_TEXT": "Placer le QR code dans la zone de scan",
	"BALANCE_TEXT": "Soyez sur d'avoir un solde suffisant pour la transaction!",
	"NONEXIST_USER": "L'utilisateur auquel vous essayez d'envoyer des fonds n'existe pas!",
	"TRANSFER_TEXT": "Etes-vous sur de vouloir transfrer?",
	"TX_BROADCASTED": "La transaction est diffuse",
	"FEED": "Suivis",
	"TRENDING": "Tendance",
	"NEW": "Nouveau",
	"PROMOTED": "Promu",
	"PAYOUT": "Paiement",
	"COMMENTS": "Commentaires",
	"TRENDING_30": "Tendance depuis 30 jours",
	"SORT_POST_BY": "Classer posts par:",
	"PAYOUT_CYCLE": "Cycle de Paiement",
	"POTENTIAL_PAYOUT": "Paiement potentiel",
	"PAST_PAYOUT": "Paiement pass",
	"AUTHOR_PAYOUT": "Paiement auteur",
	"CURATION_PAYOUT": "Paiement votes",
	"POST_SUBMITTED": "Post envoy!",
	"POST_LATER": "Soumettre le post plus tard!",
	"SAVED": "Sauvegard",
	"CLEARED": "Supprim",
	"FLAGGING_TEXT": "Downvote un post peut enlever les rcompenses et rendre celui-ci moins visible.<br><br>Le Downvote devrait tre utilis pour ceci: <ul><li>Fraude ou Plagiarisme</li><li>Trolls ou discours de haine</li><li>Contenu inappropri intentionnel ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite atteinte. Dcouvrez d'autres tags/tendances!",
	"POST_IS_UNBOOKMARK": "Post enlev des signets!",
	"POST_IS_BOOKMARK": "Post ajout au signets!",
	"RESET": "Rinitialiser",
	"MODIFY_PICTURE": "Modifier l'image du profil",
	"MODIFY_COVER_PICTURE": "Modifier l'image de couverture",
	"ACTIVE_KEY_REQUIRED_TEXT": "SVP, veuillez indiquer la cl prive active si vous avez choisi le mode de connexion avanc.",
	"RESET_PICTURE_TEXT": "Ceci va rinitialiser l'image profil de l'utilisateur",
	"RESET_COVER_PICTURE_TEXT": "Ceci va rinitialiser l'image de couverture de l'utilisateur",
	"UPDATE_REQUIRES_RESTART": "La mise  jour du serveur ncessite un redmarrage!",
	"SETTINGS_UPDATED": "Paramtres mis  jour!",
	"LANGUAGES": "Langues",
	"LANGUAGES_TEXT": "Vous pouvez changer ici la langue de l'application",
	"LOGIN_TO_X": "Cette opration requiert que l'utilisateur soit connect avec le mot de passe principal, la cl de post/cl active. Veuillez vous connecter et ressayer.",
	"GALLERY": "Gallerie",
	"TRANSLATIONS": "Contributeurs de traduction",
	"SHARE": "Partage",
	"MARKETPLACE": "March",
	"EXCHANGE": "Echange",
	"DRAFTS": "Brouillons",
	"POST_IS_UNDRAFT": "Post supprim des brouillons!",
	"POST_IS_DRAFT": "Post ajout aux brouillons!",
	"SWIPE_LEFT": "Glisser vers la gauche pour voir les options",
	"MANAGE": "Grer",
	"IMAGE_REMOVED": "Image enleve",
	"COPY": "copi",
	"NO_IMAGE": "Vous n'avez pas encore tlcharger d'images pour le moment!",
	"PULL_DOWN_TO_REFRESH": "Tirez vers le bas pour rafrachir",
	"EXTERNAL_APPS": "Apps externe",
	"SUGGEST": "Suggestion",
	"COMING_SOON": "Bientt",
	"CHAIN_TEXT": "Ici vous pouvez changer pour la blockchain ou la plate-forme par dfaut."
}
},{}],115:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "        !",
	"ABOUT_2": "   {{platformname}}.    ",
	"ABOUT_3": " ,    .    ,  , ,   '.     '  {{platformname}}   {{sitename}}",
	"ABOUT_4": "1.      .",
	"ABOUT_5": "2.   ,        .",
	"ABOUT_6": "3.      .",
	"ABOUT_7": "4.      .",
	"ABOUT_8": " -good-karma  ",
	"ABOUT_9": " ",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": " ",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": " ",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "  ",
	"SEARCH_FOLLOWING": "    ",
	"BY": " ",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": " ",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": " ",
	"UNVOTE_UPVOTED": " ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "     ",
	"POST_2": "     -",
	"OPTIONS": "",
	"RESTEEMED_BY": " ",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},     .   {{platformname}} -{{platformpower}}    -.",
	"PROFILE_2": "{{platformpower}},      .    ,             .",
	"PROFILE_3": "  {{platformsunit}}  {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "      -7    {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": " ",
	"PROFILE_5": "     .       .",
	"OWNER": "",
	"PROFILE_6": "            .            .",
	"ACTIVE": "",
	"PROFILE_7": "         .",
	"MEMO": "",
	"PROFILE_8": "     .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "        . :  ,     4 .    ,      .     .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "     ! :       (  , ,   ).",
	"VOTE": "",
	"COMMENT_TEXT": "       ! :        .",
	"COMMENT": "",
	"FOLLOW_TEXT": "       !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "       !",
	"RESTEEM": " ",
	"RESTEEM_TEXT": "      !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "       . :        ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": "       .",
	"LOGIN_2": "     , .",
	"LOGIN_3": "      .",
	"LOGIN_4": "      .   !",
	"DONT_HAVE": "   ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": " ",
	"POSTING_PRIKEY": " ",
	"MASTER_PASS": " ",
	"USERNAME": " ",
	"CARD_VIEW": " ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " -",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": "  50% / 50%",
	"POWERUP": "- 100%",
	"DECLINE_PAYOUT": " ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " ",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " ",
	"ENTER_PIN": " ",
	"ARE_YOU_SURE": "?",
	"REBLOG_TEXT": "   ,  ?",
	"BROADCAST_ERROR": " ,  !",
	"SUCCESS": "",
	"REBLOGGED_POST": "  !",
	"LOGIN_FAIL": " !                .",
	"LOGIN_FAIL_A": " !                .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": " ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": " ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": " ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": " ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "    ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": " ",
	"PASSWORD_INCORRECT": "    ",
	"INFO": "",
	"QR_TEXT": "  QR   ",
	"BALANCE_TEXT": "     !",
	"NONEXIST_USER": "      !",
	"TRANSFER_TEXT": "    ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": " ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": " -30  ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "  ",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "       .    : , ,  , , ",
	"REQUEST_LIMIT_TEXT": "   .   !",
	"POST_IS_UNBOOKMARK": "  !",
	"POST_IS_BOOKMARK": "  !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": "        !",
	"RESET_PICTURE_TEXT": "  ",
	"RESET_COVER_PICTURE_TEXT": "  ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "    .",
	"LOGIN_TO_X": "             .    .",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "  !",
	"POST_IS_DRAFT": "  !",
	"SWIPE_LEFT": "   ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "   !",
	"PULL_DOWN_TO_REFRESH": "   ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": " ",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "   '    ",
	"CURRENCY": "",
	"CURRENCY_TEXT": "       .   \\   .",
	"ABOUT_11": "<br><b>  </b> <br>-       . <br> -    . <br>-    ,    . <br>-  ,        . <br>-  ,       . <br>-      . <br>-    . <br>-      <br>-     . <br> -     . <br>-            . <br>- /    . <br> -    . <br>-   . <br><br><b></b> <br>1.     . <br>2.      ,         ,     . <br>3.       <br>4.         <br><br> eSteem   Steem -Golos. <br>",
	"FOUNDER": "  ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": ""
}
},{}],116:[function(require,module,exports){
module.exports={
	"HOME": "Poetna stranica",
	"LOGIN": "Prijava",
	"LOGOUT": "Odjava",
	"PROFILE": "Profil",
	"FOLLOW": "Prati",
	"BOOKMARKS": "Oznake",
	"TRANSFER": "Prijenos",
	"MARKET": "Trgovina",
	"SETTINGS": "Postavke",
	"ABOUT": "O aplikaciji",
	"ABOUT_1": "gdje svatko moe zaraditi nagrade za svoj sadraj!",
	"ABOUT_2": "je drutvena aplikacija gdje si plaen za bloganje, komentiranje i kuracije.",
	"ABOUT_3": "i ona je otvorenog-izvora, zajednica pokree mobilni projekt. Nudi sadraj koji je dostupan za itanje, komentiranje, glasanje, objavljivanje, prijenos zarade i druge pogodnosti koje nam nudi {{platformname}} blockchain i {{sitename}}.",
	"ABOUT_4": "Aplikacija nikad ne pristupa ili zadrava korisnika sredstva.",
	"ABOUT_5": "2. Aplikacija nudi sigurnosni model na strani klijenta. Privatni kljuevi su spremeljani lokalno i nikad se ne alju na servere.",
	"ABOUT_6": "3. Aplikacija nudi jednostavno, atraktivno korisniko suelje i doivljaj.",
	"ABOUT_7": "4. Aplikacija nikad ne zahtjeva od korisnika da unosi privatne informacije.",
	"ABOUT_8": "Glasaj za good-karma kao svjedoka",
	"ABOUT_9": "Kontakt/feedback:",
	"ABOUT_10": "Vie informacija:",
	"REMOVE": "Ukloni",
	"MARKET_VIEW": "Pregled trita",
	"PRICE": "Cijena",
	"AMOUNT": "Iznos",
	"TOTAL": "Ukupno",
	"NOORDERS": "Nema otvorenih narudbi za",
	"DATE": "Datum",
	"BUY": "Kupi",
	"SELL": "Prodaj",
	"OPEN": "Otvori",
	"HISTORY": "Povijest",
	"FOLLOW_BACK": "Uzvrati praenje",
	"FOLLOWED": "Pratim",
	"UNFOLLOW": "Prestani pratiti",
	"FOLLOWING": "Praenje",
	"FOLLOWERS": "Pratitelji",
	"SEARCH_FOLLOWERS": "Pretrai pratitelje",
	"SEARCH_FOLLOWING": "Pretrai one koje pratite",
	"BY": "od",
	"IN": "u",
	"MENU": "Izbornik",
	"BOOKMARK": "Oznaka",
	"REBLOG": "Podijeli",
	"UPVOTE": "Svia mi se",
	"DOWNVOTE": "Ne svia mi se",
	"UNVOTE_DOWNVOTED": "Poniti glas",
	"UNVOTE_UPVOTED": "Poniti glas",
	"REPLY": "Odgovor",
	"EDIT": "Uredi",
	"POST_1": "Povucite u lijevo komentare da bi ste vidjeli opcije",
	"POST_2": "Dodirnite komentare da bi ste vidjeli pod-komentare",
	"OPTIONS": "Opcije",
	"RESTEEMED_BY": "Podjeljeno od",
	"NOTHING_HERE": "Jo uvijek nemate nita ovdje...",
	"BALANCES": "Stanje",
	"PROFILE_1": "{{platformname}}, Trgovinski tokeni koji se mogu prebaciti u bilo koje vrijeme.{{platformname}} moe biti prebaen u {{platformpower}} u procesu koji se zove Jaanje profila.",
	"PROFILE_2": "{{platformpower}}, tokeni koji prezentiraju jainu vaeg profila. to ih vie netko ima to ima vei utjecaj na nagradu objave za koju glasuje i zarauje vee nagrade za glasovanje.",
	"PROFILE_3": "Tokeni vrijede otprilike {{platformsunit}} od {{platformname}}.",
	"ESTIMATED_VALUE": "Procijenjena vrijednost",
	"PROFILE_4": "Procijenjena vrijednost bazirana na 7 dnevnoj prosjenoj vrijednosti od {{platformname}}.",
	"TRANSACTION_HISTORY": "Povijest transakcija",
	"POSTING": "Objavljivanje",
	"PROFILE_5": "Klju za objavljivanje se koristi za objave i glasanje. Trebao bi biti drugaiji od aktivnog i vlasnikog kljua.",
	"OWNER": "Vlasnik",
	"PROFILE_6": "Vlasniki klju je master klju za raun i potreban je za promjenu drugih kljueva. Privatni klju ili lozinka za vlasniki klju trebala bi biti van mree to je vie mogue.",
	"ACTIVE": "Aktivnosti",
	"PROFILE_7": "Aktivni klju se koristi za transakcije i zadavanje narudbi u ugraenom tritu.",
	"MEMO": "Biljeka",
	"PROFILE_8": "Klju za biljeku se koristi za izradu i itanje biljeki.",
	"BLOG": "Blog",
	"POSTS": "Objave",
	"REPLIES": "Odgovori",
	"WALLET": "Novanik",
	"TAG": "Tagovi",
	"USER": "Korisnik",
	"CLOSE": "Zatvori",
	"TO": "Za",
	"ASSET": "Imovina",
	"SEND": "Poalji",
	"SECURITY": "Sigurnost",
	"AVAILABLE": "Dostupno",
	"PUBLIC_MEMO": "Javna biljeka",
	"TO_DESC": "Korisnik npr. good-karma",
	"PIN_CODE": "Pin kod",
	"PIN_TEXT": "PIN kod vam pomae zatititi aplikaciju i vae podatke.<br/><br/><b>Napomena:</b>Kad se jednom ukljui, imate maksimalno 4 pokuaja za otkljuati, ako zaboravite pin ili pogrijeite, aplikacija e maknuti podatke logiranja. Moete se ponovo logirati i nastaviti koristiti aplikaciju.",
	"NOTIFICATIONS": "Obavijesti",
	"VOTE_TEXT": "Dobit ete obavijest kada netko glasuje za va sadraj! <br/><b>Napomena:</b> Obavijesti takoer sadre postotak glasa i opis glasa. (Svia mi se, Ne svia mi se, Ponitavanje glasa).",
	"VOTE": "Glas",
	"COMMENT_TEXT": "Dobit ete obavijest kad netko komentira vau objavu ili komentar!<br/><b>Napomena:</b>Obavijesti e takoer sadravati i <b>promjene</b> njihovih komentara.",
	"COMMENT": "Komentar",
	"FOLLOW_TEXT": "Dobit ete obavijest kad vas netko pone ili prestane pratiti!",
	"MENTIONS": "Spominjanja",
	"MENTIONS_TEXT": "Dobit ete obavijest kad vas netko spomene u objavi ili komentaru!",
	"RESTEEM": "Podijeli",
	"RESTEEM_TEXT": "Dobit ete obavijest kada netko podijeli tvoju objavu!",
	"CONFIGURATIONS": "Konfiguracija",
	"VOTING": "Glasovanje",
	"VOTING_TEXT": "Postotak glasa utjee na glasanja u aplikaciji, znai moete regulirati nagradu koju predajete objavi.<br/><br/><b>Napomena:</b> Ovo e takoer promijeniti postotak i \"Nesvianja\" i to svugdje u aplikaciji",
	"SERVER": "Server",
	"SERVER_TEXT": "Preporueno",
	"SAVE_CHANGES": "Spremi promjene",
	"VOTERS_INFO": "Informacije glasaa",
	"WELCOME_BACK": "Dobro doli natrag!",
	"LOGIN_1": "Prijavite se sa svojim korisnikim imenon i lozinkom za nastavak.",
	"LOGIN_2": "Klju za objave se koristi za objave, komentare, glasovanje, praenje.",
	"LOGIN_3": "Aktivni klju se koristi za prijenos sredstava i promjenu profilne slike.",
	"LOGIN_4": "Korisniki podatci prijave uvaju se lokalno na ureaju. Nakon odjave podatci za prijavu nestaju!",
	"DONT_HAVE": "Nemate korisniki raun?",
	"SIGN_UP_NOW": "Registrirajte se odmah",
	"CANCEL": "Odustani",
	"ADVANCED": "Napredno",
	"ACTIVE_PRIKEY": "Aktivni privatni klju",
	"POSTING_PRIKEY": "Privatni klju za objave",
	"MASTER_PASS": "Master/glavna lozinka",
	"USERNAME": "Korisniko ime",
	"CARD_VIEW": "Kartini pregled",
	"COMPACT_VIEW": "Kompaktni pregled",
	"SEARCH": "Pretrai",
	"SUBMIT_A_STORY": "Objavi novu priu",
	"REPLYTO": "Odgovor na",
	"POST": "Objava",
	"PREVIEW": "Predpregled",
	"DEFAULT": "Zadano 50% / 50%",
	"POWERUP": "Jaanje profila 100%",
	"DECLINE_PAYOUT": "Otkai isplatu",
	"SAVE_FOR_LATER": "SPREMI ZA KASNIJE",
	"CLEAR": "OISTI",
	"POST_CONTENT": "Sadraj objave",
	"COMMENT_CONTENT": "Komentirajte sadraj",
	"TITLE": "Naslov",
	"TAGS": "Tagovi",
	"NOT_MATCH": "NE ODGOVARA",
	"CONFIRM_PIN": "Potvrdite PIN",
	"INCORRECT": "NEISPRAVNO",
	"OPENING_POST": "otvaranje objave",
	"SET_PIN": "Postavi PIN",
	"ENTER_PIN": "Unesite PIN",
	"ARE_YOU_SURE": "Jeste li sigurni?",
	"REBLOG_TEXT": "Dijeljenje posta je nepovratno, elite li nastaviti?",
	"BROADCAST_ERROR": "Pogreka prilikom emitiranja, pokuajte ponovo!",
	"SUCCESS": "Uspjeno",
	"REBLOGGED_POST": "Objava je podijeljena!",
	"LOGIN_FAIL": "Prijava nije uspjela. Molimo provjerite jeste li prijavljeni sa master lozinkom ili kljuem za objave ako ste odabrali napredni nain rada.",
	"LOGIN_FAIL_A": "Prijava nije uspjela! Molimo vas provjerite jeste li prijavljeni sa master lozinkom ili aktivnim privatnim kljuem ako ste odabrali napredni nain.",
	"WARNING": "Upozorenje",
	"VOTE_FOR_WITNESS": "Glasovanje za svjedoka",
	"VOTED_FOR_WITNESS": "Glasali ste za svjedoka",
	"AGO": "prije",
	"FROM_NOW": "od sada",
	"SECS": "sekundi",
	"A_MIN": "1 min",
	"MINS": "min",
	"AN_HOUR": "1 sat",
	"HOURS": "sati",
	"A_DAY": "1 dan",
	"DAYS": "dana",
	"A_MONTH": "mjesec dana",
	"MONTHS": "mjeseci",
	"A_YEAR": "godinu dana",
	"YEARS": "godine",
	"MIN_READ": "min itanja",
	"DOWNVOTE_FLAG": "Nesvianje ili prijava",
	"CAPTURE_PICTURE": "Snimi sliku",
	"SELECT_PICTURE": "Odaberite sliku",
	"SET_CUSTOM_URL": "Postavljanje prilagoenog URL-a",
	"INSERT_PICTURE": "Umetni sliku",
	"ERROR": "Greka",
	"UPLOAD_ERROR": "Pogreka pri prijenosu",
	"CAMERA_CANCELLED": "Kamera otkazana",
	"SET_URL": "Postavi URL",
	"DIRECT_LINK_PICTURE": "Direktni web link na sliku",
	"COMMENT_SUBMITTED": "Komentar je poslan!",
	"DELETE_COMMENT": "Brisanje komentara je nepovratno...",
	"DELETED_COMMENT": "Izbrisani komentar",
	"UPLOADING_PICTURE": "Uitavanje slike",
	"UPLOAD_COMPLETED": "Uitavanje zavreno",
	"UPLOAD_FAILED": "Neuspjean prijenos",
	"PASSWORD_INCORRECT": "Pogreno korisniko ime ili lozinka",
	"INFO": "Info",
	"QR_TEXT": "Postavi QR kod unutar podruja skeniranja",
	"BALANCE_TEXT": "Provjerite imate li dovoljno sredstava za transakciju!",
	"NONEXIST_USER": "Korisnik kojem elite poslati sredstva ne postoji!",
	"TRANSFER_TEXT": "Jeste li sigurni da elite obaviti transakciju?",
	"CONFIRMATION": "Potvrda",
	"TX_BROADCASTED": "Tranksacija je provedena",
	"FEED": "Novosti",
	"TRENDING": "Popularno",
	"HOT": "Aktualno",
	"NEW": "Novo",
	"PROMOTED": "Promovirano",
	"VOTES": "Glasovi",
	"PAYOUT": "Isplata",
	"COMMENTS": "Komentari",
	"TRENDING_30": "Popularno zadnjih 30 dana",
	"SORT_POST_BY": "Rasporedi postove po:",
	"PAYOUT_CYCLE": "Isplatni ciklus",
	"POTENTIAL_PAYOUT": "Mogua isplata",
	"PAST_PAYOUT": "Prola isplata",
	"AUTHOR_PAYOUT": "Autorska isplata",
	"CURATION_PAYOUT": "Kuracijska isplata",
	"POST_SUBMITTED": "Objava je objavljena!",
	"POST_LATER": "Objava za objavljivanje kasnije!",
	"SAVED": "Spremljeno",
	"CLEARED": "Izbrisano",
	"FLAGGING_TEXT": "Prijava objave moe maknuti nagrade i uiniti njen sadraj manje vidljiv.<br><br>Prijava bi se trebala koristiti za:<ul><li>Prevare i plagijate</li><li>Govor mrnje ili provociranje</li><li>pogren</ul></ul>o kategorizirani sadraj ili spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Nema sadraja. Pogledajte druge stranice/tagove!",
	"POST_IS_UNBOOKMARK": "Objava je izbrisana iz oznaka!",
	"POST_IS_BOOKMARK": "Objava je dodana u oznake!",
	"RESET": "Resetiraj",
	"MODIFY_PICTURE": "Promijeni sliku profila",
	"MODIFY_COVER_PICTURE": "Promijeni naslovnu sliku",
	"ACTIVE_KEY_REQUIRED_TEXT": "Molimo unesite aktivni klju ako ste odabrali napredni nain logiranja!",
	"RESET_PICTURE_TEXT": "Ovo e resetirati korisniku profilnu sliku",
	"RESET_COVER_PICTURE_TEXT": "Ovo e resetirati korisniku naslovnu sliku",
	"UPDATE_REQUIRES_RESTART": "Auriranje servera zahtjeva Restart!",
	"SETTINGS_UPDATED": "Postavke su aurirane!",
	"LANGUAGES": "Jezici",
	"LANGUAGES_TEXT": "Ovdje moete promijeniti jezik aplikacije.",
	"LOGIN_TO_X": "Ovaj postupak zahtjeva da korisnik bude prijavljen sa glavnom lozinkom, aktivnim/kljuem za objave. Molimo prijavite se i pokuajte ponovo.",
	"GALLERY": "Galerija",
	"TRANSLATIONS": "Preveli i prilagodili:",
	"SHARE": "Podijeli",
	"MARKETPLACE": "Trgovina",
	"EXCHANGE": "Burza",
	"DRAFTS": "Skice",
	"POST_IS_UNDRAFT": "Objava je maknuta iz skica!",
	"POST_IS_DRAFT": "Objava je dodana u skice!",
	"SWIPE_LEFT": "Povuci u lijevo za vidjeti opcije",
	"MANAGE": "Upravljanje",
	"IMAGE_REMOVED": "Slika je uklonjena",
	"COPY": "Kopiraj",
	"NO_IMAGE": "Jo niste postavili nijednu sliku!",
	"PULL_DOWN_TO_REFRESH": "Povucite dolje za osvjeavanje",
	"EXTERNAL_APPS": "Vanjske aplikacije",
	"PLUGINS": "Dodatci",
	"SUGGEST": "Predloi",
	"COMING_SOON": "Uskoro dolazi",
	"CHAIN": "Lanac",
	"CHAIN_TEXT": "Ovdje moete promijeniti blockchain ili zadanu platformu.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Ovdje moeze promijeniti vau zadanu valutu. Nagrade na objavama i komentarima e vam biti prikazane u ovoj valuti.",
	"ABOUT_11": "<br><b>Lista mogunosti</b><br>-Pristupite bilo kojoj objavi u bilo kojoj temi koja vas zanima.<br>Ukljuite se sa autorima s komentiranjem i raspravljanjem o temama.<br>-Glasujte za objave tako da nagradite autora i da zaradite na kuracijama.<br>-Objavite vae lanke,objave besplatno i zaradite nagrade s privlaenjem i dobivanjem pratitelja.<br>-Piite lanke za putu, spremite vie skica za kasniju objavu.<br>-Oznai najdrae lanke za proitati kasnije.<br>-Razmjeni ili isplati svoju zaradu.<br>-Poaljite vaa sredstva bilo kojem autoru ili korisniku, prijatelju, pratitelju, itd.<br>-Prati zanimljive autore, blogere.<br>-Pretrai svoje pratitelje i autore koje pratite.<br>-Dobivajte obavijesti da bi ste ostali u kontaktu sa svojim pratiteljima i raspravama u kojima ste ukljueni.<br>-Pretraite zanimljive tagove/kategorije lanaka, autora.<br>Personalizirajte va profil.<br>-Jo puno novosti stie.<br><br><b>Sigurnost</b><br>1.Aplikacija nikad ne pristupa ili zadrava na korisnikim sredstvima.<br>2.Aplikacija nudi sigurnosni model na strani klijenta, s privatnim kljuevima pohranjenima lokalno i nikad se ne alju na server, vi ste odgovorni za uvanje vaih lozinki.<br>3. Aplikacija nudi jednostavano, atraktivano korisniko suelje i doivljaj<br>4.Aplikacija nudi dodatan sloj zatite sa PIN kodom<br><br>eSteem podrava Steem i Golos platforme.<br>",
	"FOUNDER": "Osniva i glavni programer",
	"ADD_ACCOUNT": "Dodaj raun",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Rok potvrivanja",
	"ESCROW_EXPIRATION": "Escrow istek",
	"ESCROW_FEE": "Escrow honorar",
	"ESCROW_TERMS": "Escrow uvjeti",
	"NIGHT_MODE": "Noni nain",
	"DAY_MODE": "Dnevni nain",
	"VIEW_CONTEXT": "Pogledaj cijeli sadraj",
	"USER_NOTFOUND": "Korisnik nije pronaen",
	"APPROVE": "Dozvoli",
	"DISPUTE": "Raspravi",
	"RELEASE": "Izdanje",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Objavi",
	"RECEIVER": "Primatelj",
	"LOCATION": "Lokacija",
	"WEBSITE": "Web stranica",
	"DISPLAY_NAME": "Prikazani naziv"
}
},{}],117:[function(require,module,exports){
module.exports={
	"HOME": "Kezdlap",
	"LOGIN": "Bejelentkezs",
	"LOGOUT": "Kijelentkezs",
	"PROFILE": "Profil",
	"FOLLOW": "Kvets",
	"BOOKMARKS": "Knyvjelzk",
	"TRANSFER": "tutals",
	"MARKET": "Piac",
	"SETTINGS": "Belltsok",
	"ABOUT": "Rlunk",
	"ABOUT_1": "ahol brki kaphat jutalmakat a tartalmairt!",
	"ABOUT_2": "a {{platformname}} platform zemelteti. Az alkalmazs ksztje",
	"ABOUT_3": "s nylt forrskd, kzssg ltal mkdtetett projekt. Tmogatja a tartalomhozzfrst olvassrt, a hozzszlst, szavazst, posztolst, fizetsg tutalst, stb. funkcikat, amiket a {{platformname}} blokklnc s a {{sitename}} knlnak.",
	"ABOUT_4": "1. Az alkalmazs soha nem fr hozz vagy trolja a felhasznlk pnzt.",
	"ABOUT_5": "2. Az alkalmazs kliens oldali biztonsgi modellt knl, a privt kulcsok helybeni trolsval, amik soha nem kerlnek elkldsre semmilyen szerverre.",
	"ABOUT_6": "3. Az alkalmazs egyszer, tetszets felhasznli felletet s -lmnyt nyjt.",
	"ABOUT_7": "4. Az alkalmazs soha nem kri a felhasznlkat a szemlyes adataik megadsra.",
	"ABOUT_8": "Szavazz good-karma -ra mint tan",
	"ABOUT_9": "Kapcsolat/Visszajelzs:",
	"ABOUT_10": "Tbb inf:",
	"REMOVE": "Eltvolts",
	"MARKET_VIEW": "Piac Nzet",
	"PRICE": "r",
	"AMOUNT": "sszeg",
	"TOTAL": "sszesen",
	"NOORDERS": "Nincs nyitott megbzs",
	"DATE": "Dtum",
	"BUY": "Vtel",
	"SELL": "Elads",
	"OPEN": "Nyits",
	"HISTORY": "Trtnet",
	"FOLLOW_BACK": "Visszakvets",
	"FOLLOWED": "Kvetve",
	"UNFOLLOW": "Kvets megszntetse",
	"FOLLOWING": "Kvetettek",
	"FOLLOWERS": "Kvetk",
	"SEARCH_FOLLOWERS": "Kvetk keresse",
	"SEARCH_FOLLOWING": "Kvetettek keresse",
	"BY": "ltal",
	"IN": "itt:",
	"MENU": "Men",
	"BOOKMARK": "Knyvjelzk",
	"REBLOG": "jrablogols",
	"UPVOTE": "Felszavazs",
	"DOWNVOTE": "Leszavazs",
	"UNVOTE_DOWNVOTED": "Leszavazs eltvoltsa",
	"UNVOTE_UPVOTED": "Felszavazs eltvoltsa",
	"REPLY": "Vlasz",
	"EDIT": "Szerkeszts",
	"POST_1": "Cssztass balra a hozzszlsokon, hogy lsd az opcikat",
	"POST_2": "Koppints a hozzszlsokon, hogy lsd az al-hozzszlsokat",
	"OPTIONS": "Opcik",
	"RESTEEMED_BY": "jraosztva ltala:",
	"NOTHING_HERE": "Semmi sincs itt mg...",
	"BALANCES": "Egyenlegek",
	"PROFILE_1": "{{platformname}}, eladhat tokenek, amelyeket t lehet utalni brmikor.\n{{platformname}} konvertlhat {{platformpower}} - egy folyamatban, amit feltltsnek neveznk.",
	"PROFILE_2": "{{platformpower}}, befolysol tokenek, amik tbb ert kapnak a hossz tv birtoklsukrt s a posztok felszavazsrt. Minl tbbet birtokol belle valaki, annl jobban tudja befolysolni msok jutalmait s kap tbb jutalmat az alapos szavazsrt.",
	"PROFILE_3": "Tokenek, amik krlbell {{platformsunit}} -nyi {{platformname}} -et rnek.",
	"ESTIMATED_VALUE": "Becslt rtk",
	"PROFILE_4": "A becslt rtk a {{platformname}} 7 napos tlagos rtkn alapszik.",
	"TRANSACTION_HISTORY": "tutals Trtnet",
	"POSTING": "Posztols",
	"PROFILE_5": "A posztol kulcs posztolsra s szavazsra hasznlatos. Klnbznek kell lennie az aktv s a tulajdonosi kulcsoktl.",
	"OWNER": "Tulajdonos",
	"PROFILE_6": "A tulajdonos kulcs egy mesterkulcs a szmlhoz s ktelez a tbbi kulcs megvltoztatshoz. A tulajdonosi kulcs privt kulcst vagy jelszavt titokban s offline kell tartani, amennyire csak lehetsges.",
	"ACTIVE": "Aktv",
	"PROFILE_7": "Az aktv kulcs hasznlatos az tutalsok indtshoz s a megbzsok bejegyzshez a bels piacon.",
	"MEMO": "Feljegyzs",
	"PROFILE_8": "A feljegyzs kulcs hasznlatos feljegyzsek ksztsre s olvassra.",
	"BLOG": "Blog",
	"POSTS": "Posztok",
	"REPLIES": "Vlaszok",
	"WALLET": "Trca",
	"TAG": "Cmke",
	"USER": "Felhasznl",
	"CLOSE": "Bezr",
	"TO": "Neki",
	"ASSET": "Vagyontrgy",
	"SEND": "Kld",
	"SECURITY": "Biztonsg",
	"AVAILABLE": "Rendelkezsre ll",
	"PUBLIC_MEMO": "Nyilvnos feljegyzs",
	"TO_DESC": "Felhasznl, pl. good-karma",
	"PIN_CODE": "PIN-kd",
	"PIN_TEXT": "A PIN-kd segt hogy megvd az alkalmazsod s az adataid. <br/><br/><b>Megjegyzs:</b> Miutn alkalmazva van, max. 4 prblkozsi lehetsged van hogy felnyisd; ha elfelejted a PIN-t vagy hibzol, az alkalmazs el fogja tvoltani minden bejelentkezett felhasznli adatot. Vissza tudsz jelentkezni s folytathatod az alkalmazs hasznlatt.",
	"NOTIFICATIONS": "rtestsek",
	"VOTE_TEXT": "rtestseket kapsz, amikor valaki szavaz a bejegyzsedre! br/> <b>Megjegyzs:</b> Az rtestsek tartalmazzk a szavazs slyozst a figyelmeztet zenetben is (Legyen az felszavazs, leszavazs vagy szavazat visszavonsa).",
	"VOTE": "Szavazs",
	"COMMENT_TEXT": "rtestst kapsz ha valaki hozzszl a posztodhoz vagy a hozzszlsodhoz! <br/> <b>Megjegyzs:</b> Az rtestsek tartalmazzk azt is, amikor valaki <b>szerkeszti</b> a hozzszlsait.",
	"COMMENT": "Hozzszls",
	"FOLLOW_TEXT": "rtestst kapsz, amikor valaki Kvet tged vagy Visszavonja a kvetst!",
	"MENTIONS": "Emltsek",
	"MENTIONS_TEXT": "rtestseket kapsz, amikor valaki megemlt tged egy posztban/hozzszlsban!",
	"RESTEEM": "jrablogols",
	"RESTEEM_TEXT": "rtestst kapsz, amikor valaki resteemeli a posztodat!",
	"CONFIGURATIONS": "Konfigurci",
	"VOTING": "Szavazs",
	"VOTING_TEXT": "A szavazat slyozsa vagy szzalka a szavazati erre van kihatssal az alkalmazsban, gy szablyozni tudod a szavazsi jutalmaid. <br/><br/><b>Megjegyzs:</b> Ez a leszavazs szavazati erejt/szzalkt is meg fogja vltoztatni s mindentt rvnyes az alkalmazson bell.",
	"SERVER": "Szerver",
	"SERVER_TEXT": "Ajnlott",
	"SAVE_CHANGES": "Vltoztatsok Mentse",
	"VOTERS_INFO": "Inf a szavazkrl",
	"WELCOME_BACK": "dv jra!",
	"LOGIN_1": "A folytatshoz jelentkezz be a felhasznlneveddel s jelszavaddal.",
	"LOGIN_2": "A posztol kulcs a posztokhoz, hozzszlsokhoz, szavazshoz s kvetshez hasznlatos.",
	"LOGIN_3": "Az aktv kulcs az utalsokhoz s a profilkp frisstshez hasznlatos.",
	"LOGIN_4": "A felhasznl bejelentkezsi adatai helyileg vannak trolva a kszlken. Kijelentkezskor a bejelentkezsi adatok eltvoltdnak!",
	"DONT_HAVE": "Nincs mg fikod?",
	"SIGN_UP_NOW": "Regisztrlj most",
	"CANCEL": "Mgse",
	"ADVANCED": "Halad",
	"ACTIVE_PRIKEY": "Aktv privt kulcs",
	"POSTING_PRIKEY": "Posztol privt kulcs",
	"MASTER_PASS": "Mester/f jelsz",
	"USERNAME": "Felhasznlnv",
	"CARD_VIEW": "Krtya nzet",
	"COMPACT_VIEW": "Kompakt nzet",
	"SEARCH": "Keress",
	"SUBMIT_A_STORY": "Cikk bekldse",
	"REPLYTO": "Vlasz neki",
	"POST": "Poszt",
	"PREVIEW": "Elnzet",
	"DEFAULT": "Alaprtelmezett 50% / 50%",
	"POWERUP": "Feltlts 100%",
	"DECLINE_PAYOUT": "Kifizets Elutastsa",
	"SAVE_FOR_LATER": "MENTS KSBBRE",
	"CLEAR": "TRLS",
	"POST_CONTENT": "Tartalom posztolsa",
	"COMMENT_CONTENT": "Hozzszls tartalomhoz",
	"TITLE": "Cm",
	"TAGS": "Cmkk",
	"NOT_MATCH": "NEM ILLIK SSZE",
	"CONFIRM_PIN": "PIN megerstse",
	"INCORRECT": "NEM MEGFELEL",
	"OPENING_POST": "nyit poszt",
	"SET_PIN": "PIN belltsa",
	"ENTER_PIN": "PIN megadsa",
	"ARE_YOU_SURE": "Biztos vagy benne?",
	"REBLOG_TEXT": "A resteem visszavonhatatlan, biztos vagy benne?",
	"BROADCAST_ERROR": "Terjesztsi hiba, prbld jra.",
	"SUCCESS": "Siker",
	"REBLOGGED_POST": "jrablogolt poszt!",
	"LOGIN_FAIL": "A belps nem sikerlt! Krlek gyzdj meg rla, hogy a mesterjelszavaddal lptl be vagy megadtad a Posztol privt kulcsot, ha a Halad mdot vlasztottad Bejelentkezskor.",
	"LOGIN_FAIL_A": "A belps nem sikerlt! Krlek gyzdj meg rla, hogy a mesterjelszavaddal lptl be vagy megadtad az Aktv privt kulcsot, ha a Halad mdot vlasztottad Bejelentkezskor.",
	"WARNING": "Figyelmeztets",
	"VOTE_FOR_WITNESS": "Szavazs tanra",
	"VOTED_FOR_WITNESS": "Szavaztl tanra",
	"AGO": "ta",
	"FROM_NOW": "mostantl",
	"SECS": "msodperc",
	"A_MIN": "egy perc",
	"MINS": "percek",
	"AN_HOUR": "egy ra",
	"HOURS": "ra",
	"A_DAY": "egy nap",
	"DAYS": "napok",
	"A_MONTH": "egy hnap",
	"MONTHS": "hnapok",
	"A_YEAR": "egy v",
	"YEARS": "vek",
	"MIN_READ": "perc olvass",
	"DOWNVOTE_FLAG": "Leszavazs vagy Jelents",
	"CAPTURE_PICTURE": "Kp Kszts",
	"SELECT_PICTURE": "Kp Kivlaszts",
	"SET_CUSTOM_URL": "Egyedi URL Bellts",
	"INSERT_PICTURE": "Kp Beilleszts",
	"ERROR": "Hiba",
	"UPLOAD_ERROR": "Feltltsi Hiba",
	"CAMERA_CANCELLED": "Kamera Trlve",
	"SET_URL": "URL bellts",
	"DIRECT_LINK_PICTURE": "Direkt web link a kphez",
	"COMMENT_SUBMITTED": "A hozszls elkldve!",
	"DELETE_COMMENT": "A hozzszlsok trlse visszavonhatatlan...",
	"DELETED_COMMENT": "Trlt hozzszls",
	"UPLOADING_PICTURE": "Kp feltltse",
	"UPLOAD_COMPLETED": "Feltlts Ksz",
	"UPLOAD_FAILED": "Feltlts Meghisult",
	"PASSWORD_INCORRECT": "A jelsz vagy felhasznlnv hibs volt",
	"INFO": "Inf",
	"QR_TEXT": "Helyezz egy QR-kdot a leolvassi terletbe",
	"BALANCE_TEXT": "Gyzdj meg rla, hogy elegend egyenleged van az utalshoz!",
	"NONEXIST_USER": "A felhasznl, akinek utalni prblsz, nem ltezik!",
	"TRANSFER_TEXT": "Biztos vagy benne, hogy utalni akarsz?",
	"CONFIRMATION": "Megersts",
	"TX_BROADCASTED": "A tranzakci kzvettve",
	"FEED": "Hrfolyam",
	"TRENDING": "Npszer",
	"HOT": "Forr",
	"NEW": "j",
	"PROMOTED": "Tmogatott",
	"VOTES": "Szavazatok",
	"PAYOUT": "Kifizets",
	"COMMENTS": "Hozzszlsok",
	"TRENDING_30": "Npszer 30 napra",
	"SORT_POST_BY": "Posztok rendezse:",
	"PAYOUT_CYCLE": "Kifizetsi Ciklus",
	"POTENTIAL_PAYOUT": "Lehetsges Kifizets",
	"PAST_PAYOUT": "Rgi Kifizets",
	"AUTHOR_PAYOUT": "Szerzi Kifizets",
	"CURATION_PAYOUT": "Kurtori Kifizets",
	"POST_SUBMITTED": "A poszt bekldve!",
	"POST_LATER": "Poszt ksbbi bekldsre!",
	"SAVED": "Mentve",
	"CLEARED": "Trlve",
	"FLAGGING_TEXT": "Egy poszt jelentse el tudja tvoltani a jutalmakat s kevsb lthatv teszi ezt az anyagot.<br><br>A jelentst a kvetkezkre kellene hasznlni: <ul><li>Csals vagy Plagizls</li><li>Gyllet beszd vagy Internet Trollkods</li><li>Tudatosan flrekategorizlt tartalom vagy Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Krsi limit elrve. Nzz meg ms trendet/cmkt!",
	"POST_IS_UNBOOKMARK": "A poszt eltvoltva a knyvjelzk kzl!",
	"POST_IS_BOOKMARK": "A poszt hozzadva a knyvjelzkhz!",
	"RESET": "Visszallts",
	"MODIFY_PICTURE": "Profilkp Mdostsa",
	"MODIFY_COVER_PICTURE": "Bortkp Mdostsa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Krlek add meg az Aktv privt kulcsot, ha a Halad belpsi mdot vlasztottad!",
	"RESET_PICTURE_TEXT": "Ez vissza fogja lltani a profilkpet",
	"RESET_COVER_PICTURE_TEXT": "Ez vissza fogja lltani a bortkpet",
	"UPDATE_REQUIRES_RESTART": "A szerver frisstse megkveteli az jraindtst.",
	"SETTINGS_UPDATED": "Belltsok frisstve!",
	"LANGUAGES": "Nyelvek",
	"LANGUAGES_TEXT": "Itt tudod megvltoztatni az alkalmazs nyelvt.",
	"LOGIN_TO_X": "Ez a mvelet megkveteli, hogy a felhasznl a f jelszavval, aktv/posztol kulcsval legyen bejelentkezve. Krlek lpj be s prbld jra.",
	"GALLERY": "Galria",
	"TRANSLATIONS": "A fordts kzremkdi",
	"SHARE": "Megoszts",
	"MARKETPLACE": "Piactr",
	"EXCHANGE": "Vlt",
	"DRAFTS": "Piszkozat",
	"POST_IS_UNDRAFT": "A bejegyzs eltvoltva a piszkozatokbl!",
	"POST_IS_DRAFT": "A bejegyzs hozzadva a piszkozatokhoz!",
	"SWIPE_LEFT": "Cssztass balra az opcikrt",
	"MANAGE": "Kezels",
	"IMAGE_REMOVED": "Kp trlve",
	"COPY": "Msols",
	"NO_IMAGE": "Mg nem tltttl fel semmilyen kpet!",
	"PULL_DOWN_TO_REFRESH": "Hzd le a frisstshez",
	"EXTERNAL_APPS": "Kls Alkalmazsok",
	"PLUGINS": "Beplk",
	"SUGGEST": "Javasol",
	"COMING_SOON": "Hamarosan megjelenik",
	"CHAIN": "Lnc",
	"CHAIN_TEXT": "Itt tudsz blokklncot vagy alaprtelmezett felletet cserlni.",
	"CURRENCY": "Pnznem",
	"CURRENCY_TEXT": "Itt tudod megvltoztatni az alaprtelmezett pnznemet. Ebben a pnznemben fogod ltni a bejegyzseid jutalmait.",
	"ABOUT_11": "<br><b>Funkci lista</b><br>- Frj hozz egyedi cikkekhez brmilyen tmban, ami csak rdekel.<br>- Kerlj kzelebb a szerzkhz hozzszlsokkal, beszlgetsekkel.<br>- Szavazz bejegyzsekre, hogy megjutalmazd a szerzket s ekzben kurtori jutalmat kapj.<br>- Publikld a cikkeid s blog posztjaid, trold ket ingyen s rj el jutalmakat azzal, hogy kvetket szerzel s foglalkozol velk.<br>- rj cikkeket menet kzben, ments el tbb piszkozatot a ksbbi publikcihoz.<br>- Knyvjelzzd a kedvenc cikkeid a ksbbi olvasshoz.<br>- Vltsd t vagy vedd ki a fizetsged.<br>- Kldj pnzt brmely szerznek, felhasznlnak, bartnak, kvetnek, stb.<br>- Kvess rdekes szerzket, bloggereket.<br>- Keress r a kvetidre s az ltalad kvetettekre.<br>- Kapj rtestseket, hogy kapcsolatban maradhass a kvetiddel s a beszlgetsekkel, amikben rszt veszel.<br>- Keress cikkeket s szerzket rdekes cmkk/kategrik alatt.<br>- Szabd szemlyre a profilodat.<br>- s mg sok j funkci vrhat.<br><br><b>Biztonsg</b><br>1. Az alkalmazs soha nem fr hozz a felhasznl pnzhez.<br>2. Az alkalmazs kliens-oldali hitelestst hasznl, a privt kulcsok helyben vannak trolva s soha nem kerlnek elkldsre semmilyen szerverre; te vagy a felels a jelszavaid biztonsgi mentseirt.<br>3. Az alkalmazs egyszer, tetszets felhasznli felletet s lmnyt nyjt<br>4. Az alkalmazs extra biztonsgi rteget knl a PIN-kddal<br><br>Az eSteem tmogatja a Steem s a Golos platformokat.<br>",
	"FOUNDER": "Alapt s Vezet fejleszt",
	"ADD_ACCOUNT": "Fik hozzadsa",
	"PLATFORM": "Platform",
	"ESCROW": "Lett",
	"ESCROW_AGENT": "Letti gynk",
	"RATIFICATION_DEADLINE": "Megerstsi hatrid",
	"ESCROW_EXPIRATION": "Lett lejrta",
	"ESCROW_FEE": "Letti dj",
	"ESCROW_TERMS": "Letti felttelek",
	"NIGHT_MODE": "jszakai md",
	"DAY_MODE": "Nappali md",
	"VIEW_CONTEXT": "Mutasd szvegkrnyezetben",
	"USER_NOTFOUND": "A Felhasznl Nem Tallhat",
	"APPROVE": "Jvhagy",
	"DISPUTE": "Vita",
	"RELEASE": "Kiads",
	"FROM": "Felad",
	"ID": "id",
	"SUBMIT": "Kld",
	"RECEIVER": "Fogad",
	"LOCATION": "Hely",
	"WEBSITE": "Weboldal",
	"DISPLAY_NAME": "Megjelentend nv"
}
},{}],118:[function(require,module,exports){
module.exports={
	"HOME": "Beranda",
	"LOGIN": "Masuk",
	"LOGOUT": "Keluar",
	"PROFILE": "Profil",
	"FOLLOW": "Ikuti",
	"BOOKMARKS": "Tandai",
	"TRANSFER": "Transfer",
	"MARKET": "Pasar",
	"SETTINGS": "Setelan",
	"ABOUT": "Tentang",
	"ABOUT_1": "Siapapun bisa mendapatkan keuntungan dari konten",
	"ABOUT_2": "Applikasi dibuat oleh",
	"ABOUT_3": "dan ini adalah open source, proyek mobile berbasis masyarakat. Ini menawarkan akses konten untuk membaca, berkomentar, voting, posting, mentransfer pendapatan, dll fitur yang ditawarkan oleh {{platformname}} blockchain dan {{sitename}}.",
	"ABOUT_4": "1. Aplikasi tidak pernah mengakses atau memegang dana pengguna.",
	"ABOUT_5": "2. Aplikasi menawarkan model keamanan client-side, dengan kunci pribadi host secara lokal dan tidak pernah dikirim ke server.",
	"ABOUT_6": "3. Aplikasi menawarkan sederhana, user interface yang menarik dan pengalaman.",
	"ABOUT_7": "4. Aplikasi tidak pernah mengharuskan pengguna untuk memasukkan informasi pribadi apapun.",
	"ABOUT_8": "Pilih good-karma sebagai witness",
	"ABOUT_9": "Kontak/Saran:",
	"ABOUT_10": "Info lebih lanjut:",
	"REMOVE": "Menghapus",
	"MARKET_VIEW": "Pasar",
	"PRICE": "Harga",
	"AMOUNT": "Jumlah",
	"TOTAL": "Jumlah",
	"NOORDERS": "No open order untuk",
	"DATE": "Tanggal",
	"BUY": "Beli",
	"SELL": "Jual",
	"OPEN": "Buka",
	"HISTORY": "Riwayat",
	"FOLLOW_BACK": "Mengikuti kembali",
	"FOLLOWED": "Diikuti",
	"UNFOLLOW": "Berhenti mengikuti",
	"FOLLOWING": "Mengikuti",
	"FOLLOWERS": "Pengikut",
	"SEARCH_FOLLOWERS": "Mencari Pengikut",
	"SEARCH_FOLLOWING": "Mencari Mengikuti",
	"BY": "oleh",
	"IN": "dalam",
	"MENU": "Menu",
	"BOOKMARK": "Bookmark",
	"REBLOG": "Reblog",
	"UPVOTE": "Upvote",
	"DOWNVOTE": "Downvote",
	"UNVOTE_DOWNVOTED": "Batalkan Downvote\n",
	"UNVOTE_UPVOTED": "Batalkan Upvoted\n",
	"REPLY": "Balas",
	"EDIT": "Edit",
	"POST_1": "Geser ke kiri pada komentar untuk melihat opsi",
	"POST_2": "Ketuk pada komentar untuk melihat sub-komentar",
	"OPTIONS": "Opsi",
	"RESTEEMED_BY": "Resteemed Oleh",
	"NOTHING_HERE": "Tidak ada di sini...",
	"BALANCES": "Saldo",
	"PROFILE_1": "{{Platformname}}, token tradeable yang dapat ditransfer kapan saja. {{Platformname}} dapat dikonversi ke {{kekuatan platform yang}} dalam proses yang disebut powering up.",
	"PROFILE_2": "{{Platformpower}}, mempengaruhi token yang mendapatkan lebih banyak kekuatan untuk memegang jangka panjang dan suara pada posting. Semakin satu memegang lebih satu dapat mempengaruhi imbalan lain dan mendapatkan imbalan untuk voting akurat.",
	"PROFILE_3": "Token bernilai sekitar {{platformsunit}} dari {{platformname}}.",
	"ESTIMATED_VALUE": "Perkiraan Nilai",
	"PROFILE_4": "Nilai estimasi ini didasarkan pada nilai rata-rata 7 hari {{platformname}}.",
	"TRANSACTION_HISTORY": "Sejarah Transaksi",
	"POSTING": "Postingan",
	"PROFILE_5": "Kunci postingan digunakan untuk posting dan voting. Ini harus berbeda dari tombol aktif dan pemilik.",
	"OWNER": "Pemilik",
	"PROFILE_6": "Kunci pemilik adalah kunci master untuk account dan diperlukan untuk mengubah kunci lainnya. Kunci pribadi atau password untuk kunci pemilik harus disimpan secara offline sebanyak mungkin.",
	"ACTIVE": "Aktif",
	"PROFILE_7": "Kunci aktif digunakan untuk melakukan transfer dan tempat order di pasar internal.",
	"MEMO": "Memo",
	"PROFILE_8": "Kunci memo digunakan untuk membuat dan membaca memo.",
	"BLOG": "Blog",
	"POSTS": "Post",
	"REPLIES": "Balasan",
	"WALLET": "Dompet",
	"TAG": "Tag",
	"USER": "Pengguna",
	"CLOSE": "Tutup",
	"TO": "Kepada",
	"ASSET": "Aset",
	"SEND": "Kirim",
	"SECURITY": "Keamanan",
	"AVAILABLE": "Tersedia",
	"PUBLIC_MEMO": "Memo publik",
	"TO_DESC": "Pengguna misalnya good-karma",
	"PIN_CODE": "Kode Pin",
	"PIN_TEXT": "Kode PIN membantu Anda untuk mengamankan aplikasi dan data Anda. <br/><br/> <b>Catatan:</b> Setelah diaktifkan, Anda memiliki max 4 mencoba untuk membuka, jika Anda lupa pin atau gagal, aplikasi akan hapus login data pengguna. Anda dapat login kembali dan terus menggunakan aplikasi.",
	"NOTIFICATIONS": "Notifikasi",
	"VOTE_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang memberikan suara konten Anda! <br/> <b>Catatan:</b> Pemberitahuan termasuk suara berat serta dalam pesan peringatan. (Baik itu up-vote, down-vote, un-vote).",
	"VOTE": "Voting",
	"COMMENT_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang komentar pada posting atau komentar!<br/> <b>Catatan:</b> Pemberitahuan termasuk ketika seseorang <b>Sunting</b> komentar mereka juga.",
	"COMMENT": "Komentar",
	"FOLLOW_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang Follow atau Unfollow Anda!",
	"MENTIONS": "Menyebutkan",
	"MENTIONS_TEXT": "Anda akan mendapatkan pemberitahuan bila seseorang menyebutkan Anda dalam postingan mereka/komentar!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Anda akan mendapatkan notifikasi ketika seseorang reblogs posting Anda!",
	"CONFIGURATIONS": "Konfigurasi",
	"VOTING": "Voting",
	"VOTING_TEXT": "Kekuatan Voting atau persentase mempengaruhi hak suara pada aplikasi, sehingga Anda dapat mengatur reward Voting Anda. <br/><br/><b>Catatan:</b> ini akan mengubah kekuatan voting/persentase untuk downvoting juga dan itu adalah di mana-mana pada aplikasi",
	"SERVER": "Server",
	"SERVER_TEXT": "Direkomendasikan",
	"SAVE_CHANGES": "Simpan perubahan",
	"VOTERS_INFO": "Voters info",
	"WELCOME_BACK": "Selamat Datang kembali!",
	"LOGIN_1": "Masuk dengan nama pengguna dan password untuk melanjutkan.",
	"LOGIN_2": "Posting kunci digunakan untuk posting, komentar, voting, follow.",
	"LOGIN_3": "Active kunci digunakan untuk transfer dan memperbarui gambar profil.",
	"LOGIN_4": "kredensial pengguna disimpan secara lokal pada perangkat. Setelah Keluar kredensial dihapus!",
	"DONT_HAVE": "Tidak memiliki akun?",
	"SIGN_UP_NOW": "Daftar Sekarang",
	"CANCEL": "Batal",
	"ADVANCED": "Lanjutan",
	"ACTIVE_PRIKEY": "Kunci aktif pribadi",
	"POSTING_PRIKEY": "Kunci Posting Pribadi",
	"MASTER_PASS": "Master/password utama",
	"USERNAME": "Nama Pengguna",
	"CARD_VIEW": "Lihat kartu",
	"COMPACT_VIEW": "Compact View",
	"SEARCH": "Cari",
	"SUBMIT_A_STORY": "Masukkan cerita",
	"REPLYTO": "Balas ke",
	"POST": "posting",
	"PREVIEW": "Tinjauan",
	"DEFAULT": "Default 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Menolak pembayaran",
	"SAVE_FOR_LATER": "SIMPAN UNTUK NANTI",
	"CLEAR": "BERSIHKAN",
	"POST_CONTENT": "Posting konten",
	"COMMENT_CONTENT": "Konten komentar",
	"TITLE": "Judul",
	"TAGS": "Tags",
	"NOT_MATCH": "TIDAK COCOK",
	"CONFIRM_PIN": "Konfirmasi Pin",
	"INCORRECT": "SALAH",
	"OPENING_POST": "Post pembukaan",
	"SET_PIN": "Atur PIN",
	"ENTER_PIN": "Masukan PIN",
	"ARE_YOU_SURE": "Apakah anda yakin?",
	"REBLOG_TEXT": "Reblog ireversibel, apakah Anda ingin melanjutkan?",
	"BROADCAST_ERROR": "Siaran error, coba lagi!",
	"SUCCESS": "Sukses",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Gagal masuk! Pastikan Anda telah login dengan password master atau tersedia Posting kunci pribadi pada Login jika Anda telah choosed mode Advanced.",
	"LOGIN_FAIL_A": "Gagal masuk! Pastikan Anda telah login dengan password master atau disediakan kunci pribadi Aktif di Login jika Anda telah memilih mode Advanced.",
	"WARNING": "Peringatan",
	"VOTE_FOR_WITNESS": "Voting untuk witness",
	"VOTED_FOR_WITNESS": "Voted untuk witness",
	"AGO": "lalu",
	"FROM_NOW": "dari sekarang",
	"SECS": "detik",
	"A_MIN": "semenit",
	"MINS": "menit",
	"AN_HOUR": "sejam",
	"HOURS": "jam",
	"A_DAY": "sehari",
	"DAYS": "hari",
	"A_MONTH": "sebulan",
	"MONTHS": "bulan",
	"A_YEAR": "setahun",
	"YEARS": "tahun",
	"MIN_READ": "min baca",
	"DOWNVOTE_FLAG": "Downvote atau bendera",
	"CAPTURE_PICTURE": "Ambil Gambar",
	"SELECT_PICTURE": "Pilih Gambar",
	"SET_CUSTOM_URL": "Menetapkan URL kustom",
	"INSERT_PICTURE": "Masukan Gambar",
	"ERROR": "kesalahan",
	"UPLOAD_ERROR": "kesalahan Mengupload ",
	"CAMERA_CANCELLED": "Kamera Dibatalkan",
	"SET_URL": "Menetapkan URL",
	"DIRECT_LINK_PICTURE": "Direct web link utuk Gambar",
	"COMMENT_SUBMITTED": "Komentar disampaikan!",
	"DELETE_COMMENT": "Menghapus komentar adalah ireversibel...",
	"DELETED_COMMENT": "Menghapus komentar",
	"UPLOADING_PICTURE": "Upload Gambar",
	"UPLOAD_COMPLETED": "Upload Selesai",
	"UPLOAD_FAILED": "Upload Gagal",
	"PASSWORD_INCORRECT": "Password atau nama akun tidak benar",
	"INFO": "Info",
	"QR_TEXT": "Tempatkan kode QR di dalam area pindai",
	"BALANCE_TEXT": "Pastikan Anda memiliki saldo yang cukup untuk transaksi!",
	"NONEXIST_USER": "Pengguna yang Anda ccoba untuk mentransfer dana, tidak ada!",
	"TRANSFER_TEXT": "Apakah Anda yakin Anda ingin mentransfer?",
	"CONFIRMATION": "Konfirmasi",
	"TX_BROADCASTED": "Transaksi disiarkan",
	"FEED": "Umpan",
	"TRENDING": "Trending",
	"HOT": "Hot",
	"NEW": "Baru",
	"PROMOTED": "Promosi",
	"VOTES": "Vote",
	"PAYOUT": "Dibayar",
	"COMMENTS": "Komentar",
	"TRENDING_30": "Trending 30 Hari",
	"SORT_POST_BY": "Urutkan Postingan:",
	"PAYOUT_CYCLE": "Siklus pembayaran",
	"POTENTIAL_PAYOUT": "Potensi Pembayaran",
	"PAST_PAYOUT": "Pembayaran terakhir",
	"AUTHOR_PAYOUT": "Pembayaran Penulis",
	"CURATION_PAYOUT": "Pembayaran Kurasi",
	"POST_SUBMITTED": "Post ditayangkan!",
	"POST_LATER": "Posting untuk diajukan nanti!",
	"SAVED": "Disimpan",
	"CLEARED": "Dibersihkan",
	"FLAGGING_TEXT": "Flagging postingan dapat menghapus imbalan dan membuat bahan ini kurang terlihat <br> bendera harus digunakan untuk berikut: <ul><li>Penipuan atau Plagiarisme</li><li>Kata kasar atau Internet Trolling </li><li>Konten Disengaja dikategorikan atau Spam</li> </ul>",
	"REQUEST_LIMIT_TEXT": "Batas permintaan tercapai. Lihat tren/tag lainnya!",
	"POST_IS_UNBOOKMARK": "Posting dihilangkan dari bookmark!",
	"POST_IS_BOOKMARK": "Posting ditambahkan ke bookmark!",
	"RESET": "Setel Ulang",
	"MODIFY_PICTURE": "Modifikasi gambar Profil",
	"MODIFY_COVER_PICTURE": "Memodifikasi Sampul gambar",
	"ACTIVE_KEY_REQUIRED_TEXT": "Harap memberikan kunci pribadi Active jika Anda telah memilih modus masuk Lanjutan!",
	"RESET_PICTURE_TEXT": "Ini akan menyetel ulang gambar profil",
	"RESET_COVER_PICTURE_TEXT": "Ini akan mereset gambar sampul",
	"UPDATE_REQUIRES_RESTART": "Update server memerlukan Restart!",
	"SETTINGS_UPDATED": "Pengaturan diperbarui!",
	"LANGUAGES": "Bahasa",
	"LANGUAGES_TEXT": "Di sini Anda dapat mengubah bahasa aplikasi.",
	"LOGIN_TO_X": "Operasi ini mengharuskan pengguna untuk login dengan password utama, aktif/postingan kunci. Silahkan login dan coba lagi.",
	"GALLERY": "Galeri",
	"TRANSLATIONS": "Kontributor terjemahan",
	"SHARE": "Bagikan\n",
	"MARKETPLACE": "Pasar",
	"EXCHANGE": "Pertukaran",
	"DRAFTS": "draft",
	"POST_IS_UNDRAFT": "Posting akan dihapus dari draft!",
	"POST_IS_DRAFT": "Posting ditambahkan ke draft!",
	"SWIPE_LEFT": "Geser ke kiri untuk melihat opsi",
	"MANAGE": "Mengelola\n",
	"IMAGE_REMOVED": "Gambar dihapus",
	"COPY": "copy",
	"NO_IMAGE": "Anda belum mengunggah gambar apapun, belum!",
	"PULL_DOWN_TO_REFRESH": "Tarik ke bawah untuk menyegarkan",
	"EXTERNAL_APPS": "\n External Apps",
	"PLUGINS": "Plugins",
	"SUGGEST": "Saran",
	"COMING_SOON": "Segera hadir",
	"CHAIN": "Chain\n",
	"CHAIN_TEXT": "Di sini Anda dapat mengubah blockchain atau platform default.\nChain_Text",
	"CURRENCY": "Mata uang",
	"CURRENCY_TEXT": "Di sini Anda dapat mengubah mata uang default Anda. Anda akan melihat nilai hadiah posting/komentar pada mata uang ini.",
	"ABOUT_11": "<br><b>Daftar fitur</b> <br>-akses unik artikel dalam subjek Anda tertarik membaca. <br> -Terlibat dengan penulis dengan komentar, membahas topik. <br>-Voting untuk posting ke penulis hadiah serta mendapatkan pahala pengkurasian. <br>-Publish artikel, posting blog dan host mereka secara gratis dan mendapatkan imbalan dengan melibatkan dan mendapatkan pengikut. <br>-Menulis artikel tentang pergi, menyimpan draf beberapa posting untuk kemudian publikasi. <br>-Bookmark favorit artikel untuk dibaca nanti. <br>-Exchange atau uang tunai penghasilan Anda. <br>-Mengirim dana kepada penulis atau pengguna, temanmu, pengikutmu, dll <br>-ikuti menarik penulis, blogger. <br> -Cari pengikutnya dan penulis Anda mengikuti Anda. <br>-Get pemberitahuan untuk tetap berhubungan dengan pengikut Anda dan diskusi Anda yang terlibat in. <br>-pencarian untuk menarik tags/Kategori artikel, penulis. <br> -Mempersonalisasikan profil Anda. <br>-Banyak lebih banyak fitur untuk datang. <br><br><b>Keamanan</b> <br>1. App tidak pernah mengakses atau memegang pengguna dana. <br>2. app menawarkan model keamanan sisi klien dengan private key host secara lokal dan tidak pernah dikirimkan ke server apapun, Anda bertanggung jawab untuk membuat cadangan password Anda. <br>3. app menawarkan antarmuka pengguna yang sederhana, menarik dan pengalaman <br>4. App menawarkan lapisan tambahan keamanan dengan kode pin <br><br>harga mendukung platform Steem dan Golos. <br>",
	"FOUNDER": "Pendiri dan pengembang",
	"ADD_ACCOUNT": "Tambah akun",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Agen escrow",
	"RATIFICATION_DEADLINE": "Ratifikasi tenggat waktu",
	"ESCROW_EXPIRATION": "Escrow kadaluarsa",
	"ESCROW_FEE": "Escrow biaya",
	"ESCROW_TERMS": "Escrow persyaratan",
	"NIGHT_MODE": "Mode malam",
	"DAY_MODE": "Mode Siang",
	"VIEW_CONTEXT": "Lihat konteks lengkap",
	"USER_NOTFOUND": "Pengguna tidak ditemukan",
	"APPROVE": "Disetujui",
	"DISPUTE": "Sengketa",
	"RELEASE": "Rilis",
	"FROM": "Dari",
	"ID": "id",
	"SUBMIT": "Submit",
	"RECEIVER": "Penerima",
	"LOCATION": "Lokasi",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Nama tampilan"
}
},{}],119:[function(require,module,exports){
module.exports={
	"HOME": "Pagina Iniziale",
	"LOGIN": "Accedi",
	"LOGOUT": "Esci",
	"PROFILE": "Profilo",
	"FOLLOW": "Chi Segui",
	"BOOKMARKS": "Preferiti",
	"TRANSFER": "Trasferimenti",
	"MARKET": "Mercato",
	"SETTINGS": "Impostazioni",
	"ABOUT": "Info",
	"ABOUT_1": "dove chiunque pu guadagnare ricompense per i propri contenuti!",
	"ABOUT_2": " offerto dalla piattaforma {{platformname}}. L'app  creata da",
	"ABOUT_3": "ed  un progetto per dispositivi mobili, open-source e portato avanti dalla community. Offre l'accesso per la lettura, il commento, il voto, e la pubblicazione di contenuti. Caratteristiche offerte dalla {{platformname}} blockchain e da {{sitename}}",
	"ABOUT_4": "1. L'app non ha mai l'accesso n il controllo sui fondi dell'utente.",
	"ABOUT_5": "2. L'app offre un modello di sicurezza \"lato cliente\", grazie alle chiavi private memorizzate localmente e mai trasmesse ad alcun server.",
	"ABOUT_6": "3. L'app offre un'esperienza e un'inferfaccia grafica semplice e attraente.",
	"ABOUT_7": "4. L'app non richiede mai l'inserimento di informazioni personali da parte dell'utente",
	"ABOUT_8": "Vota good-karma come testimonial",
	"ABOUT_9": "Contatti/Feedback:",
	"ABOUT_10": "Maggiori informazioni:",
	"REMOVE": "Elimina",
	"MARKET_VIEW": "Mercato",
	"PRICE": "Prezzo",
	"AMOUNT": "Importo",
	"TOTAL": "Totale",
	"NOORDERS": "Nessun ordine aperto",
	"DATE": "Data",
	"BUY": "Compra",
	"SELL": "Vendi",
	"OPEN": "Apri",
	"HISTORY": "Cronologia",
	"FOLLOW_BACK": "Segui",
	"FOLLOWED": "Seguito",
	"UNFOLLOW": "Smetti di seguire",
	"FOLLOWING": "Seguito",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Cerca tra i tuoi followers",
	"SEARCH_FOLLOWING": "Cerca tra chi segui",
	"BY": "da",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Aggiungi ai preferiti",
	"REBLOG": "Condividi",
	"UPVOTE": "Vota",
	"DOWNVOTE": "Disapprova",
	"UNVOTE_DOWNVOTED": "Rimuovi Downvote",
	"UNVOTE_UPVOTED": "Rimuovi Upvote",
	"REPLY": "Rispondi",
	"EDIT": "Modifica",
	"POST_1": "Swipe a sinistra sui commenti per visualizzare le opzioni",
	"POST_2": "Clicca sui commenti per visualizzare i sotto-commenti",
	"OPTIONS": "Opzioni",
	"RESTEEMED_BY": "Contdiviso da",
	"NOTHING_HERE": "Non c' ancora niente qui...",
	"BALANCES": "Saldi",
	"PROFILE_1": "{{platformname}}, sono tokens che possono essere scambiati. {{platformname}} possono essere convertiti in {{platformpower}} attraverso un processo chiamato powering up.",
	"PROFILE_2": " \n",
	"PROFILE_3": "I tokens valgono circa {{platformsunit}} di {{platformname}}. ",
	"ESTIMATED_VALUE": "Valore Stimato",
	"PROFILE_4": "Il valore stimato si basa sulla media degli ultimi 7 giorni di {{platformname}}.",
	"TRANSACTION_HISTORY": "Cronologia delle transazioni",
	"POSTING": "Pubblicazione",
	"PROFILE_5": "La \"posting key\"  utilizzata per la pubblicazione e la votazione di contenuti. Essa dovrebbe essere diversa dall'active e dall'owner key.",
	"OWNER": "Proprietario",
	"PROFILE_6": "La \"owner key\"  la chiave maestra dell'account ed  richiesta per modificare le altre chiavi. Tale chiave privata, cos come la password principale, dovrebbero essere tenute offline il pi possibile.",
	"ACTIVE": "Attivit",
	"PROFILE_7": "La \"active key\"  utilizzata per effettuare trasferimenti e piazzare ordini nel mercato interno.",
	"MEMO": "Memo",
	"PROFILE_8": "La \"memo key\"  utilizzata per la creazione e lettura dei memo.",
	"BLOG": "Blog",
	"POSTS": "Commenti",
	"REPLIES": "Risposte",
	"WALLET": "Portafoglio",
	"TAG": "Tag",
	"USER": "Utente",
	"CLOSE": "Chiudi",
	"TO": "A",
	"ASSET": "Asset",
	"SEND": "Invia",
	"SECURITY": "Sicurezza",
	"AVAILABLE": "Disponibile",
	"PUBLIC_MEMO": "Memo pubblica",
	"TO_DESC": "Utente ad esempio good-karma",
	"PIN_CODE": "Codice PIN",
	"PIN_TEXT": "Il codice PIN ti aiuta a rendere sicuri l'applicazione e i tuoi dati. <br/><br/><b>Attenzione:</b> una volta attivato, hai al massimo 4 tentativi per sbloccare l'app, se ti dimentichi il PIN o fallisci i tentativi, l'applicazione rimuover i dati utente. Potrai fare nuovamente il login e continuare ad usare l'applicazione.",
	"NOTIFICATIONS": "Notifiche",
	"VOTE_TEXT": "Riceverai una notifica quando qualcuno vota i tuoi contenuti!<br/><br>Nota:</b> La notifica includer il tipo di voto. (up-vote, down-vote, un-vote).",
	"VOTE": "Voto",
	"COMMENT_TEXT": "Riceverai una notifica quando qualcuno commenta un tuo post o risponde ad un tuo commento!<br/><br>Nota:</b> Riceverai una notifica anche quando qualcuno modifica il suo commento!",
	"COMMENT": "Commento",
	"FOLLOW_TEXT": "Riceverai una notifica quando qualcuno inizia o smette di seguirti!",
	"MENTIONS": "Menzione",
	"MENTIONS_TEXT": "Riceverai una notifica quando qualcuno ti menziona in un suo post o commento!",
	"RESTEEM": "Condividi",
	"RESTEEM_TEXT": "Riceverai una notifica quando qualcuno condivide il tuo post!",
	"CONFIGURATIONS": "Configurazioni",
	"VOTING": "Voto",
	"VOTING_TEXT": "Il peso del voto o la percentuale influenzano il potere di voto nell'app, cos puoi regolare il premio del tuo voto. <br/><br/><b>Nota:</b> questo cambier anche peso/percentuale del downvote.",
	"SERVER": "Server",
	"SERVER_TEXT": "Raccomandati",
	"SAVE_CHANGES": "Salva le modifiche",
	"VOTERS_INFO": "Info Votanti",
	"WELCOME_BACK": "Bentornato!",
	"LOGIN_1": "Accedi fornendo il tuo Nome Utente e la tua Password per continuare.",
	"LOGIN_2": "La \"posting key\" viene usata per pubblicare nuovi post e commenti, per votare, e per gestire chi segui",
	"LOGIN_3": "La \"active key\"  utilizzata per i trasferimenti e per aggiornare la foto del profilo.",
	"LOGIN_4": "Le tue credenziali sono memorizzate localmente sul dispositivo. Se fai il Logout le credenziali verranno rimosse!",
	"DONT_HAVE": "Non hai un account?",
	"SIGN_UP_NOW": "Registrati ora",
	"CANCEL": "Cancella",
	"ADVANCED": "Avanzate",
	"ACTIVE_PRIKEY": "Chiave privata attiva",
	"POSTING_PRIKEY": "Chiave Privata per pubblicazione",
	"MASTER_PASS": "Password principale",
	"USERNAME": "Nome Utente",
	"CARD_VIEW": "Vista estesa",
	"COMPACT_VIEW": "Vista compatta",
	"SEARCH": "Cerca",
	"SUBMIT_A_STORY": "Inserisci un articolo",
	"REPLYTO": "Rispondi a",
	"POST": "Pubblica",
	"PREVIEW": "Anteprima",
	"DEFAULT": "Predefinito 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Rifiuta ricompensa",
	"SAVE_FOR_LATER": "SALVA PER DOPO",
	"CLEAR": "CANCELLA",
	"POST_CONTENT": "Testo del post",
	"COMMENT_CONTENT": "Testo del commento",
	"TITLE": "Titolo",
	"TAGS": "Tags",
	"NOT_MATCH": "NON TROVATO",
	"CONFIRM_PIN": "Conferma PIN",
	"INCORRECT": "INCORRETTO",
	"OPENING_POST": "apertura post",
	"SET_PIN": "Imposta PIN",
	"ENTER_PIN": "Inserisci PIN",
	"ARE_YOU_SURE": "Sei sicuro?",
	"REBLOG_TEXT": "Il reblog  irreversibile, vuoi continuare?",
	"BROADCAST_ERROR": "Errore di trasmissione, riprova!",
	"SUCCESS": "Successo",
	"REBLOGGED_POST": "Post condiviso!",
	"LOGIN_FAIL": "Accesso fallito! Per favore, assicurati di aver richiesto l'accesso tramite la tua password principale o avendo inserito la \"Posting private key\" se hai scelto la modalit Avanzata.",
	"LOGIN_FAIL_A": "Accesso fallito! Per favore, assicurati di aver richiesto l'accesso tramite la tua password principale o avendo inserito la tua \"Active private key\" se hai scelto la modalit Avanzata.",
	"WARNING": "Attenzione",
	"VOTE_FOR_WITNESS": "Votazione per il witness",
	"VOTED_FOR_WITNESS": "Votato per il testimonial",
	"AGO": "fa",
	"FROM_NOW": "da ora",
	"SECS": "secondi",
	"A_MIN": "un minuto",
	"MINS": "minuti",
	"AN_HOUR": "un'ora",
	"HOURS": "ore",
	"A_DAY": "un giorno",
	"DAYS": "giorni",
	"A_MONTH": "un mese",
	"MONTHS": "mesi",
	"A_YEAR": "un anno",
	"YEARS": "anni",
	"MIN_READ": "minuti di lettura.",
	"DOWNVOTE_FLAG": "Downvote o segnala",
	"CAPTURE_PICTURE": "Scatta Foto",
	"SELECT_PICTURE": "Seleziona foto",
	"SET_CUSTOM_URL": "Imposta URL personalizzata",
	"INSERT_PICTURE": "Inserisci Immagine",
	"ERROR": "Errore",
	"UPLOAD_ERROR": "Errore durante il caricamento",
	"CAMERA_CANCELLED": "Camera cancellata",
	"SET_URL": "Imposta URL",
	"DIRECT_LINK_PICTURE": "Link web diretto per l'immagine",
	"COMMENT_SUBMITTED": "Commento inserito!",
	"DELETE_COMMENT": "La cancellazione dei commenti  irreversibile...",
	"DELETED_COMMENT": "Commento rimosso",
	"UPLOADING_PICTURE": "Sto caricando l'immagine",
	"UPLOAD_COMPLETED": "Caricamento completato",
	"UPLOAD_FAILED": "Caricamento fallito",
	"PASSWORD_INCORRECT": "Nome Utente o Password errati",
	"INFO": "Info",
	"QR_TEXT": "Posiziona un codice QR all'interno dell'area di scansione",
	"BALANCE_TEXT": "Assicurati che il tuo bilancio sia sufficiente per la transazione",
	"NONEXIST_USER": "L'utente a cui stai cercando di trasferire dei fondi non esiste!",
	"TRANSFER_TEXT": "Sei sicuro di voler procedere con il trasferimento?",
	"CONFIRMATION": "Conferma",
	"TX_BROADCASTED": "La transazione  stata trasmessa",
	"FEED": "Feed",
	"TRENDING": "Di tendenza",
	"HOT": "Popolari",
	"NEW": "Nuovo",
	"PROMOTED": "Sponsorizzati",
	"VOTES": "Voti",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Commenti",
	"TRENDING_30": "Trending per 30 giorni",
	"SORT_POST_BY": "Ordina per:",
	"PAYOUT_CYCLE": "Ciclo dei pagamenti",
	"POTENTIAL_PAYOUT": "Payout potenziale",
	"PAST_PAYOUT": "Payout passato",
	"AUTHOR_PAYOUT": "Ricompensa dell'autore",
	"CURATION_PAYOUT": "Ricompensa dei curatori",
	"POST_SUBMITTED": "L'articolo  stato inserito!",
	"POST_LATER": "Inserisci Port pi tardi!",
	"SAVED": "Salvato",
	"CLEARED": "Cancellato",
	"FLAGGING_TEXT": "Segnalare un post pu annullare le ricompense e rendere questo materiale meno visibile. <br><br> La segnalazione dovrebbe essere usata per i seguenti motivi: <ul> truffa o Plagio </li><li> incitazione all'odio o Trolling </li><li> post inseriti intenzionalmente in categorie errate o Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite raggiunto. Verifica altri trend/tags!",
	"POST_IS_UNBOOKMARK": "Il post  stato rimosso dai segnalibri!",
	"POST_IS_BOOKMARK": "Il post  stato aggiunto ai segnalibri!",
	"RESET": "Reimposta",
	"MODIFY_PICTURE": "Modifica la Foto del Profilo",
	"MODIFY_COVER_PICTURE": "Modifica l'immagine di copertina",
	"ACTIVE_KEY_REQUIRED_TEXT": "Per favore, inserisci la tua \"Active private key\" se hai scelto l'accesso in modalit Avanzata!",
	"RESET_PICTURE_TEXT": "Questa azione resetter l'immagine del profilo",
	"RESET_COVER_PICTURE_TEXT": "Questa azione resetter l'immagine di copertina",
	"UPDATE_REQUIRES_RESTART": "Un aggiornamento lato server richiede il Riavvio dell'applicazione!",
	"SETTINGS_UPDATED": "Impostazioni aggiornate!",
	"LANGUAGES": "Lingua",
	"LANGUAGES_TEXT": "Qui puoi cambiare la lingua dell'app",
	"LOGIN_TO_X": "Questa operazioni richiede che l'utente abbia effettuato l'accesso. Per favore, accedi e riprova.",
	"GALLERY": "Galleria Immagini",
	"TRANSLATIONS": "Traduttori",
	"SHARE": "Condividi",
	"MARKETPLACE": "Altre applicazioni",
	"EXCHANGE": "Scambio",
	"DRAFTS": "Bozze",
	"POST_IS_UNDRAFT": "Il post  stato rimosso dalle bozze!",
	"POST_IS_DRAFT": "Il post  stato aggiunto alle bozze!",
	"SWIPE_LEFT": "Trascina a sinistra per vedere le opzioni",
	"MANAGE": "Gestisci",
	"IMAGE_REMOVED": "Immagine rimossa",
	"COPY": "Copia",
	"NO_IMAGE": "Non hai ancora caricato un'immagine!",
	"PULL_DOWN_TO_REFRESH": "Trascina in basso per aggiornare",
	"EXTERNAL_APPS": "Applicazioni esterne",
	"PLUGINS": "PlugIns",
	"SUGGEST": "Suggerisci",
	"COMING_SOON": "Prossimamente",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Qui puoi cambiare la blockchain o la piattaforma predefinita.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Qui puoi modificare la tua valuta predefinita. Vedrai il valore di ricompensa post/commento in questa valuta.",
	"ABOUT_11": "<br><b>Lista delle funzionalit</b><br>- Accesso agli articoli sulle tematiche di vostro interesse. <br>- Interazione con gli autori degli articoli commentando e discutendo sugli argomenti.<br>- Possibilit di votare i post per ricompensare gli autori e, allo stesso tempo, guadagnare ricompense dai voti dati.<br>- Possibilit di pubblicare i vostri articoli, postarli sul blog gratuitamente e guadagnare ricompense interagendo e incrementando il numero dei followers. <br>- Possibilit di scrivere articoli da pubblicare, salvando le bozze per pubblicarli in seguito.<br>- Utilizzo di un \"segnalibro\" per gli articoli preferiti, in modo da poterli leggere successivamente.<br>- Possibilit di scambiare o incassare i vostri guadagni.<br>- Possibilit di inviare i vostri fondi ad altri autori o utenti, amici, followers, etc. <br>- Ricerca dei vostri followers e degli autori che seguite.<br>- Ricezione di notifiche per rimanere aggiornati sui vostri followers e sulle discussioni in cui siete coinvolti. <br>- Ricerca di articoli per tags/categorie di vostro interesse e autori.<br>- Possibilit di personalizzare il proprio profilo.<br>- Molte altre funzionalit sono in fase di sviluppo.<br><br><b>Sicurezza</b><br>1. L'Applicazione non avr mai accesso ai fondi degli utenti n li potr detenere. <br>2. L'Applicazione offre un modello di sicurezza Client-side, con Chiavi private detenute localmente e mai inviate ad alcun server. Tu stesso sarai responsabile di fare il backup delle tue Chiavi Private/Passwords. <br>3. L'Applicazione offre interfaccia ed esperienze semplice e attraenti per l'utente. <br>4. L'Applicazione offre un ulteriore livello di sicurezza tramite l'uso di codice Pin. <br><br>eSteem supporta le piattaforme di Steem e di Golos.<br>",
	"FOUNDER": "Fondatore e responsabile dello sviluppo",
	"ADD_ACCOUNT": "Aggiungi account",
	"PLATFORM": "Piattaforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Depositario",
	"RATIFICATION_DEADLINE": "Scadenza della ratificazione",
	"ESCROW_EXPIRATION": "Scadenza del deposito",
	"ESCROW_FEE": "Tassa del deposito",
	"ESCROW_TERMS": "Condizioni e termini del Deposito",
	"NIGHT_MODE": "Modalit notturna",
	"DAY_MODE": "Modalit diurna",
	"VIEW_CONTEXT": "Mostra il testo completo",
	"USER_NOTFOUND": "Utente non trovato",
	"APPROVE": "Approva",
	"DISPUTE": "Controversia",
	"RELEASE": "Rilascia",
	"FROM": "Da",
	"ID": "id",
	"SUBMIT": "Inserisci",
	"RECEIVER": "Destinatario",
	"LOCATION": "Localit",
	"WEBSITE": "Sito Web",
	"DISPLAY_NAME": "Visualizza nome"
}
},{}],120:[function(require,module,exports){
module.exports={
	"HOME": "Kediaman",
	"LOGIN": "Log Masuk",
	"LOGOUT": "Log Keluar",
	"PROFILE": "Profil",
	"FOLLOW": "Ikut",
	"BOOKMARKS": "Penanda buku",
	"TRANSFER": "Pindah",
	"MARKET": "Pasar",
	"SETTINGS": "Tetapan",
	"ABOUT": "Mengenai",
	"ABOUT_1": "di mana anda terima ganjaran untuk isi kandundan anda!",
	"ABOUT_2": "dikuasai oleh platform {{platformname}}, aplikasi dicipta oleh.",
	"ABOUT_3": "dan ianya sumber terbuka, komuniti yang didorong oleh projek mudah alih. Ia menawarkan akses kandungan untuk membaca, mengulas, mengundi, posting, pemindahan pendapatan, dan lain-lain ciri-ciri yang ditawarkan oleh {{platformname}} blockchain dan {{sitename}}.",
	"ABOUT_4": "1. Aplikasi ini tidak mempynyai akses ke akaun anda.",
	"ABOUT_5": "2. Aplikasi menawarkan keselamatan-klien, dengan kunci peribadi yang dihoskan dalam tempatan dan tidak akan dihantar ke mana-mana server lain.",
	"ABOUT_6": "3. Aplikasi menawarkan antaramuka pengguna yang mudah dan menarik.",
	"ABOUT_7": "4. Aplikasi tidak akan memerlukan pengguna untuk memasukkan maklumat peribadi.",
	"ABOUT_8": "Undi good-karma sebagai saksi",
	"ABOUT_9": "Hubungi/Maklum balas:",
	"ABOUT_10": "Info lanjut:",
	"REMOVE": "Membuang",
	"MARKET_VIEW": "Gambaran Pasaran",
	"PRICE": "Harga",
	"AMOUNT": "Jumlah",
	"TOTAL": "Jumlah",
	"NOORDERS": "Pesanan tidak terbuka untuk",
	"DATE": "Tarikh",
	"BUY": "Beli",
	"SELL": "Menjual",
	"OPEN": "Dibuka",
	"HISTORY": "Sejarah",
	"FOLLOW_BACK": "Ikut kembali",
	"FOLLOWED": "Diikuti",
	"UNFOLLOW": "Berhenti",
	"FOLLOWING": "Berikut",
	"FOLLOWERS": "Followers",
	"SEARCH_FOLLOWERS": "Cari pengikut",
	"SEARCH_FOLLOWING": "Cari pengikut",
	"BY": "oleh",
	"IN": "dalam",
	"MENU": "Menu",
	"BOOKMARK": "Penanda buku",
	"REBLOG": "Reblog",
	"UPVOTE": "Undi naik",
	"DOWNVOTE": "Undi (negatif)",
	"UNVOTE_DOWNVOTED": "Batalkan undi (negatif)",
	"UNVOTE_UPVOTED": "Batalkan undi",
	"REPLY": "Jawapan",
	"EDIT": "Edit",
	"POST_1": "Sapu ke kiri atas komen untuk melihat opsyen",
	"POST_2": "Ketuk atas komen untuk melihat sub-komen",
	"OPTIONS": "Pilihan",
	"RESTEEMED_BY": "Reblogged oleh",
	"NOTHING_HERE": "TIADA APA DI SINI",
	"BALANCES": "Baki",
	"PROFILE_1": "{{platformname}}, token cair yang boleh dipindahkan pada bila-bila masa. {{platformname}} boleh ditukar kepada {{platformpower}} di dalam proses yang dipanggil menjanakan.",
	"PROFILE_2": "{{platformpower}}, pengaruh token yang mendapat kuasa yang lebih untuk pegangan jangka panjang dan pengundian ke atas posting. Lebih banyak seseorang memegang lebih banyak yang boleh mempengaruhi ganjaran lain dan mendapat ganjaran untuk undian yang tepat.",
	"PROFILE_3": "Token bernilai kira-kira {{platformsunit}} daripada {{platformname}}.",
	"ESTIMATED_VALUE": "Anggaran nilai",
	"PROFILE_4": "Nilai anggaran ini adalah berdasarkan nilai purata 7 hari {{platformname}}.",
	"TRANSACTION_HISTORY": "Urus niaga",
	"POSTING": "PENEMPATAN",
	"PROFILE_5": "Kekunci posting digunakan untuk posting dan mengundi. Ia harus berbeza daripada kekunci aktif dan pemilik.",
	"OWNER": "Pemilik",
	"PROFILE_6": "Kekunci pemilik adalah kunci utama untuk akaun dan dikehendaki menukar kekunci yang lain. Kunci peribadi dan kata laluan untuk pemilik kunci perlu disimpan di luar talian sebanyak mungkin.",
	"ACTIVE": "Aktif",
	"PROFILE_7": "Kekunci yang aktif digunakan untuk membuat pemindahan dan membuat pesanan dalam pasaran dalaman.",
	"MEMO": "Memo",
	"PROFILE_8": "Kekunci memo digunakan untuk mencipta dan membaca memo.",
	"BLOG": "Blog",
	"POSTS": "Jawatan",
	"REPLIES": "Balasan",
	"WALLET": "Wallet",
	"TAG": "Tag",
	"USER": "Pengguna",
	"CLOSE": "Tutup",
	"TO": "To",
	"ASSET": "Aset",
	"SEND": "Hantar",
	"SECURITY": "Keselamatan",
	"AVAILABLE": "Tersedia",
	"PUBLIC_MEMO": "Memo awam",
	"TO_DESC": "Pengguna contohnya good-karma",
	"PIN_CODE": "Kod Pin",
	"PIN_TEXT": "Kod PIN membantu anda untuk mendapatkan aplikasi dan data anda. <br/> <br/> <b>Nota:</b> Sebaik sahaja dibolehkan, anda mempunyai maksimum 4 cuba untuk membuka, jika anda terlupa pin atau gagal, aplikasi akan memadam log masuk data pengguna. Anda boleh login semula dan terus menggunakan aplikasi.",
	"NOTIFICATIONS": "Warta",
	"VOTE_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang undi kandungan anda! <br/> <b>Nota:</b> pemberitahuan termasuk mengundi berat serta mesej amaran. (sama ada undi (positif), undi (negatif), membatalkan undi).",
	"VOTE": "Vote",
	"COMMENT_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang atau memberi komen pada posting atau komen anda! <br/> <b>Nota:</b> Pemberitahuan termasuk apabila seseorang <b>suntingan</b> komen mereka juga.",
	"COMMENT": "Komen",
	"FOLLOW_TEXT": "Anda akan mendapatkan pemberitahuan apabila seseorang mengikuti atau ikut anda!",
	"MENTIONS": "Menyebut",
	"MENTIONS_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang menyebut anda di post/komen!",
	"RESTEEM": "Reblog",
	"RESTEEM_TEXT": "Anda akan mendapat pemberitahuan apabila seseorang reblog post anda!",
	"CONFIGURATIONS": "Konfigurasi",
	"VOTING": "Mengundi",
	"VOTING_TEXT": "Berat undi atau peratus menjejaskan kuasa mengundi pada aplikasi, supaya anda boleh mengawal ganjaran mengundi. <br/> <br/> <b>Nota:</b> Ini akan mengubah berat/peratusan undian untuk undi (negatif) juga dan ia adalah di mana-mana aplikasi",
	"SERVER": "Server",
	"SERVER_TEXT": "Disyorkan",
	"SAVE_CHANGES": "Simpan perubahan",
	"VOTERS_INFO": "Info pengundi",
	"WELCOME_BACK": "Selamat kembali!",
	"LOGIN_1": "Daftar Masuk dengan username dan password anda untuk teruskan.",
	"LOGIN_2": "Kunci posting digunakan untuk pos komen, undi, ikut.",
	"LOGIN_3": "Kunci aktif digunakan untuk pemindahan dan kemaskini gambar profil.",
	"LOGIN_4": "Kelayakan pengguna disimpan secara tempatan pada peranti. Apabila log keluar kelayakan akan dikeluarkan!",
	"DONT_HAVE": "Tidak ada akaun?",
	"SIGN_UP_NOW": "Daftarlah sekarang",
	"CANCEL": "Batal",
	"ADVANCED": "Advanced",
	"ACTIVE_PRIKEY": "Kunci aktif persendirian",
	"POSTING_PRIKEY": "Kunci posting persendirian",
	"MASTER_PASS": "Kata laluan induk/utama",
	"USERNAME": "Nama Pengguna",
	"CARD_VIEW": "Kad paparan",
	"COMPACT_VIEW": "Paparan yang padat",
	"SEARCH": "Carian",
	"SUBMIT_A_STORY": "Hantar cerita",
	"REPLYTO": "Balas kepada",
	"POST": "Hantar",
	"PREVIEW": "Preview",
	"DEFAULT": "Lalai 50% / 50%",
	"POWERUP": "Mengekuasai 100%",
	"DECLINE_PAYOUT": "Menolak bayaran",
	"SAVE_FOR_LATER": "SIMPAN UNTUK KEMUDIAN",
	"CLEAR": "JELAS",
	"POST_CONTENT": "Post kandungan",
	"COMMENT_CONTENT": "Komen kandungan",
	"TITLE": "Tajuk",
	"TAGS": "Tags",
	"NOT_MATCH": "TIDAK PADAN",
	"CONFIRM_PIN": "Sahkan PIN",
	"INCORRECT": "BETUL",
	"OPENING_POST": "pembukaan post",
	"SET_PIN": "Tetapkan PIN",
	"ENTER_PIN": "Masukkan PIN",
	"ARE_YOU_SURE": "Adakah anda pasti?",
	"REBLOG_TEXT": "Reblog tidak boleh dibalikkan, adakah anda pasti hendak meneruskan?",
	"BROADCAST_ERROR": "Disiarkan ralat, cuba lagi!",
	"SUCCESS": "Kejayaan",
	"REBLOGGED_POST": "Reblogged post!",
	"LOGIN_FAIL": "Log masuk gagal! Sila pastikan anda telah log masuk dengan kata laluan induk atau kunci peribadi posting anda ke atas log masuk jika anda telah memilih mod Advanced.",
	"LOGIN_FAIL_A": "Log masuk gagal! Sila pastikan anda telah log masuk dengan kata laluan induk atau kunci peribadi posting anda ke atas log masuk jika anda telah memilih mod Advanced.",
	"WARNING": "Amaran",
	"VOTE_FOR_WITNESS": "Mengundi untuk saksi",
	"VOTED_FOR_WITNESS": "Mengundi untuk saksi",
	"AGO": "Lalu",
	"FROM_NOW": "dari sekarang",
	"SECS": "saat",
	"A_MIN": "minit",
	"MINS": "minit",
	"AN_HOUR": "sejam",
	"HOURS": "jam",
	"A_DAY": "satu hari",
	"DAYS": "hari",
	"A_MONTH": "sebulan",
	"MONTHS": "bulan",
	"A_YEAR": "setahun",
	"YEARS": "tahun",
	"MIN_READ": "minit membaca",
	"DOWNVOTE_FLAG": "Vote (negatif) atau Menandai",
	"CAPTURE_PICTURE": "Tangkap gambar",
	"SELECT_PICTURE": "Pilih gambar",
	"SET_CUSTOM_URL": "Tetapkan URL boleh-ubah",
	"INSERT_PICTURE": "Masukkan gambar",
	"ERROR": "Ralat",
	"UPLOAD_ERROR": "Ralat muat naik",
	"CAMERA_CANCELLED": "Kamera Telah Dibatalkan",
	"SET_URL": "Tetapkan URL",
	"DIRECT_LINK_PICTURE": "Pautan web langsung gambar",
	"COMMENT_SUBMITTED": "Komen dihantar!",
	"DELETE_COMMENT": "Menghapuskan komen tidak boleh dibalikkan...",
	"DELETED_COMMENT": "Komen dihapuskan",
	"UPLOADING_PICTURE": "Muat Naik Gambar",
	"UPLOAD_COMPLETED": "Muat Naik Selesai",
	"UPLOAD_FAILED": "Muat Naik Gagal",
	"PASSWORD_INCORRECT": "Nama akaun atau kata laluan tidak betul",
	"INFO": "Maklumat",
	"QR_TEXT": "Letakkan Kod QR di dalam kawasan imbasan",
	"BALANCE_TEXT": "Pastikan anda mempunyai baki yang mencukupi untuk transaksi!",
	"NONEXIST_USER": "Pengguna yang anda cuba untuk memindahkan dana, tidak wujud!",
	"TRANSFER_TEXT": "Adakah anda pasti anda mahu memindahkan?",
	"CONFIRMATION": "Pengesahan",
	"TX_BROADCASTED": "Urus niaga disiarkan",
	"FEED": "Suapan",
	"TRENDING": "Tren",
	"HOT": "Panas",
	"NEW": "Baru",
	"PROMOTED": "Digalakkan",
	"VOTES": "Undi",
	"PAYOUT": "Pembayaran",
	"COMMENTS": "KOMENTAR",
	"TRENDING_30": "Tren untuk 30 hari",
	"SORT_POST_BY": "Posting susun oleh:",
	"PAYOUT_CYCLE": "Kitaran pembayaran",
	"POTENTIAL_PAYOUT": "Potensi Pembayaran",
	"PAST_PAYOUT": "Pembayaran Masa Lalu",
	"AUTHOR_PAYOUT": "Bayaran Penulis",
	"CURATION_PAYOUT": "Pembayaran Curation",
	"POST_SUBMITTED": "Pos dihantar!",
	"POST_LATER": "Pos untuk penghantaran lewat!",
	"SAVED": "tersimpan",
	"CLEARED": "DIPADAMKAN",
	"FLAGGING_TEXT": "Menanda atau undian (negatif) pos boleh keluarkan ganjaran dan jadikan bahan ini kurang kelihatan. <br><br>Bendera hendaklah digunakan untuk perkara-perkara berikut: <ul><li>penipuan atau plagiat</li> <li>ucapan benci atau Internet Trolling</li> <li>Kategori yang mengelirukan atau Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Had pemintaan dicapai. Menyemak aliran tag lain!",
	"POST_IS_UNBOOKMARK": "Pos dialih keluar daripada penanda!",
	"POST_IS_BOOKMARK": "Post ditambah ke penanda!",
	"RESET": "Tetapkan semula",
	"MODIFY_PICTURE": "Tukar Gambar Profil",
	"MODIFY_COVER_PICTURE": "Tukar Gambar Cover",
	"ACTIVE_KEY_REQUIRED_TEXT": "Sila berikan kunci peribadi yang aktif jika anda telah memilih mod login maju!",
	"RESET_PICTURE_TEXT": "Ini akan menetapkan semula gambar profil pengguna",
	"RESET_COVER_PICTURE_TEXT": "Ini akan menetapkan semula gambar profil pengguna",
	"UPDATE_REQUIRES_RESTART": "Kemaskini pelayan memerlukan reset!",
	"SETTINGS_UPDATED": "Tetapan dikemaskini!",
	"LANGUAGES": "BAHASA",
	"LANGUAGES_TEXT": "Di sini anda boleh menukar bahasa daripada aplikasi ini.",
	"LOGIN_TO_X": "Operasi ini memerlukan pengguna log masuk dengan kata laluan utama, kekunci aktif/posting. Sila log masuk dan cuba lagi.",
	"GALLERY": "GALERI",
	"TRANSLATIONS": "TERJEMAHAN",
	"SHARE": "Kongsi",
	"MARKETPLACE": "Pasaran",
	"EXCHANGE": "Pertukaran",
	"DRAFTS": "Draf",
	"POST_IS_UNDRAFT": "Pos dialih keluar daripada draf!",
	"POST_IS_DRAFT": "Post ditambah kepada draf!",
	"SWIPE_LEFT": "Sapu kiri untuk melihat opsyen",
	"MANAGE": "Urus",
	"IMAGE_REMOVED": "Imej dikeluarkan",
	"COPY": "Salin",
	"NO_IMAGE": "Anda tidak upload gambar apa-apa, lagi!",
	"PULL_DOWN_TO_REFRESH": "Tarik ke bawah untuk memuat semula",
	"EXTERNAL_APPS": "Aplikasi luaran",
	"PLUGINS": "Plugin",
	"SUGGEST": "Cadangkan",
	"COMING_SOON": "Akan datang",
	"CHAIN": "Chain",
	"CHAIN_TEXT": "Di sini anda boleh menukar platform blockchain atau lalai.",
	"CURRENCY": "Matawang",
	"CURRENCY_TEXT": "Di sini anda boleh menukar Mata Wang lalai anda. Anda akan melihat post/komen ganjaran nilai Mata Wang ini.",
	"ABOUT_11": "<br><b>Senarai ciri-ciri</b> <br>akses unik artikel dalam mana-mana subjek anda berminat membaca. <br> -Melibatkan diri dengan penulis oleh mengulas, membincangkan topik. <br>-Pengundian bagi jawatan kepada pengarang ganjaran serta mendapat ganjaran curation. <br>-Siarkan artikel, posting blog anda dan host mereka secara percuma dan mendapat ganjaran dengan melibatkan dan mendapat pengikut. <br>Tulis artikel mengenai pergi, simpan beberapa Draf jawatan untuk penerbitan kemudian. <br>-Bookmark artikel kegemaran membaca kemudian. <br>-Pertukaran atau Wang Tunai daripada pendapatan anda. <br>Menghantar dana anda kepada mana-mana pengarang atau pengguna, rakan-rakan, pengikut, dan lain-lain <br>-ikut penulis menarik, Blogger. <br> -Cari pengikut dan penulis anda mengikuti anda. <br>-Dapatkan pemberitahuan untuk kekal berhubung dengan pengikut dan perbincangan anda anda akan terlibat in. <br>-Cari label/kategori menarik artikel, pengarang. <br> -Memperibadikan profil anda. <br>-Banyak lebih banyak ciri untuk datang. <br><br><b>Keselamatan</b> <br>1. Aplikasi tidak pernah mencapai atau memegang wang pengguna. <br>2. aplikasi menawarkan model Keselamatan-klien, dengan kunci peribadi yang dihoskan dalam negara dan tidak pernah dihantar ke mana-mana pelayan, anda bertanggungjawab untuk menyandarkan kata laluan anda. <br>3. aplikasi menawarkan antara muka pengguna yang mudah, menarik dan pengalaman <br>4. Aplikasi menawarkan tambahan lapisan Keselamatan dengan harga <br><br>kod pin menyokong platform Steem dan Golos. <br>",
	"FOUNDER": "Pengasas dan pemaju utama",
	"ADD_ACCOUNT": "Tambah akaun",
	"PLATFORM": "Platform",
	"ESCROW_AGENT": "Ejen escrow",
	"RATIFICATION_DEADLINE": "Tarikh akhir kelulusan",
	"ESCROW_EXPIRATION": "Escrow tamat",
	"ESCROW_FEE": "Yuran escrow",
	"ESCROW_TERMS": "Terma-terma escrow"
}
},{}],121:[function(require,module,exports){
module.exports={
	"HOME": "Home",
	"LOGIN": "Log in",
	"LOGOUT": "Log uit",
	"PROFILE": "Profiel",
	"FOLLOW": "Volgen",
	"BOOKMARKS": "Bladwijzers",
	"TRANSFER": "Overschrijven",
	"MARKET": "Markt",
	"SETTINGS": "Instellingen",
	"ABOUT": "Over",
	"ABOUT_1": "waar iedereen een beloning kan verdienen!",
	"ABOUT_2": "is social media dienst waar je betaald wordt voor het bloggen, antwoorden en cureren.",
	"ABOUT_3": "en het is een open-source, communitie gedreven project. Het biedt mogelijkheden tot lezen, reageren, stemmen, plaatsen van berichten, overschrijven van inkomsten, etc. functies worden aangeboden door {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. De app heeft geen toegang tot tegoeden van de gebruiker.",
	"ABOUT_5": "2. De app biedt een client beveiligingsmodel, met priv sleutels die lokaal worden opgeslagen en nooit naar servers worden verzonden.",
	"ABOUT_6": "3. De app biedt simpele, aantrekkelijke gebruikersomgevingen en ervaringen.",
	"ABOUT_7": "4. De app vraagt u nooit om persoonlijke informatie.",
	"ABOUT_8": "Stem op good-karma als witness",
	"ABOUT_9": "Contact/Terugkoppeling:",
	"ABOUT_10": "Meer informatie:",
	"REMOVE": "Verwijderen",
	"MARKET_VIEW": "Markt Weergave",
	"PRICE": "Prijs",
	"AMOUNT": "Bedrag",
	"TOTAL": "Totaal",
	"NOORDERS": "Geen uitstaande bestellingen voor",
	"DATE": "Datum",
	"BUY": "Kopen",
	"SELL": "Verkopen",
	"OPEN": "Open",
	"HISTORY": "Geschiedenis",
	"FOLLOW_BACK": "Terugvolgen",
	"FOLLOWED": "Gevolgd",
	"UNFOLLOW": "Ontvolgen",
	"FOLLOWING": "Volgen",
	"FOLLOWERS": "Volgers",
	"SEARCH_FOLLOWERS": "Zoek volgers",
	"SEARCH_FOLLOWING": "Zoek volgen",
	"BY": "door",
	"IN": "in",
	"MENU": "Menu",
	"BOOKMARK": "Bladwijzer",
	"REBLOG": "Herblog",
	"UPVOTE": "Stem Omhoog",
	"DOWNVOTE": "Stem Omlaag",
	"UNVOTE_DOWNVOTED": "Downvote weghalen",
	"UNVOTE_UPVOTED": "Stem Omhaag weghalen",
	"REPLY": "Reageer",
	"EDIT": "Wijzigen",
	"POST_1": "Swipe naar links op een reactie om opties te zien",
	"POST_2": "Tik op reacties om sub-reacties te zien",
	"OPTIONS": "Opties",
	"RESTEEMED_BY": "Herblogd door",
	"NOTHING_HERE": "Nog niets te zien hier...",
	"BALANCES": "Tegoeden",
	"PROFILE_1": "{{platformname}}, verhandelbare tokens die altijd overgemaakt kan worden. {{platformname}} kan worden omgezet naar {{platformpower}} in een proces genaamd powering up.",
	"PROFILE_2": "{{platformpower}}, invloed tokens die meer kracht krijgen door het op lange termijn te bewaren en door het stemmen op bercihten. Hoe meer tokens u vasthoudt, hoe meer invloed u heeft op andermans opbrengsten en hoe hoger de opbrengsten bij cureren.",
	"PROFILE_3": "Tokens zijn ongeveer {{platformsunit}} {{platformname}} waard.",
	"ESTIMATED_VALUE": "Geschatte waarde",
	"PROFILE_4": "De geschatte waarde is gebaseerd op een 7-daags gemiddelde waarde van {{platformname}}.",
	"TRANSACTION_HISTORY": "Transactie geschiedenis",
	"POSTING": "Plaatsen",
	"PROFILE_5": "De berichten sleutel wordt gebruikt voor het plaatsen van en voor het stemmen op berichten. Deze zou anders moeten zijn dan de actieve- en eigenaar sleutels.",
	"OWNER": "Eigenaar",
	"PROFILE_6": "De eigenaars sleutel is de hoofdsleutel voor het account en is nodig om andere sleutels aan te passen. De priv sleutel of wachtwoord voor de eigenaars sleutel zou zo veel mogelijk offline opgeslagen moeten worden.",
	"ACTIVE": "Actief",
	"PROFILE_7": "De actieve sleutel wordt gebruikt om transacties en bestellingen te plaatsen in de interne markt.",
	"MEMO": "Memo",
	"PROFILE_8": "De memo sleutel wordt gebruikt voor het maken en lezen van memo's.",
	"BLOG": "Blog",
	"POSTS": "Berichten",
	"REPLIES": "Reacties",
	"WALLET": "Portemonnee",
	"TAG": "Label",
	"USER": "Gebruiker",
	"CLOSE": "Afsluiten",
	"TO": "Naar",
	"ASSET": "Bezitting",
	"SEND": "Verzenden",
	"SECURITY": "Beveiliging",
	"AVAILABLE": "Beschikbaar",
	"PUBLIC_MEMO": "Publiekelijke memo",
	"TO_DESC": "Gebruiker bijv. good-karma",
	"PIN_CODE": "Pincode",
	"PIN_TEXT": "PIN code helpt u uw app en gegevens te beschermen. <br/><br/><b>Opmerking:</b> Eenmaal ingesteld heeft u maximaal 4 kansen, wanneer u de PIN bent vergeten of u het 4 keer verkeerd heeft ingevoerd zal de app uw gebruikersgegevens verwijderen. U kunt dan opnieuw inloggen om de app weer te kunnen gebruiken.",
	"NOTIFICATIONS": "Notificaties",
	"VOTE_TEXT": "U krijgt een notificatie wanneer iemand voor uw bericht stemt.<br/> <b>Opmerking:</b> Notificaties geeft stemgewicht aan alsook in het meldingsbericht. (zowel voor stem omhoog, stem omlaag, verwijder stem).",
	"VOTE": "Stem",
	"COMMENT_TEXT": "U krijgt een notificatie wanneer iemand reageert op uw berichten of reacties. <br/> <b>Opmerking:</b> Notificaties ook wanneer iemand zijn/haar reacties <b>aanpast</b>.",
	"COMMENT": "Commentaar",
	"FOLLOW_TEXT": "U krijgt een notificatie wanneer iemand u volgt of stopt met volgen!",
	"MENTIONS": "Vermeldingen",
	"MENTIONS_TEXT": "U krijgt een notificatie wanneer iemand u noemt in zijn of haar bericht/reactie!",
	"RESTEEM": "Herblog",
	"RESTEEM_TEXT": "U krijgt een notificatie wanneer iemand uw bericht herblogd!",
	"CONFIGURATIONS": "Configuraties",
	"VOTING": "Stemmen",
	"VOTING_TEXT": "Stemgewicht of percentage hebben invloed op Stemkracht in de app, zodat u uw stemopbrengsten kunt reguleren. <br/><br/><b>Opmerking:</b> Dit zal uw stemgewicht/percentage voor het omlaag stemmen ook aantasten en geldt voor de gehele app",
	"SERVER": "Server",
	"SERVER_TEXT": "Aanbevolen",
	"SAVE_CHANGES": "Wijzigingen opslaan",
	"VOTERS_INFO": "Stemmers informatie",
	"WELCOME_BACK": "Welkom terug!",
	"LOGIN_1": "Log in met uw gebruikersnaam en wachtwoord om verder te gaan.",
	"LOGIN_2": "Posting sleutel wordt gebruikt voor het plaatsen van berichten, reacties, stemmen en het volgen van gebruikers.",
	"LOGIN_3": "Actieve sleutel wordt gebruikt voor overmaken en aanpassingen van de profiel foto.",
	"LOGIN_4": "Gebruikersgegevens worden lokaal op uw apparaat opgeslagen. Bij het uitloggen worden de gegevens verwijderd!",
	"DONT_HAVE": "Heeft u geen account?",
	"SIGN_UP_NOW": "Meld je nu aan",
	"CANCEL": "Annuleren",
	"ADVANCED": "Uitgebreid",
	"ACTIVE_PRIKEY": "Actieve priv sleutel",
	"POSTING_PRIKEY": "Posting priv sleutel",
	"MASTER_PASS": "Hoofdwachtwoord",
	"USERNAME": "Gebruikersnaam",
	"CARD_VIEW": "Kaart weergave",
	"COMPACT_VIEW": "Compacte weergave",
	"SEARCH": "Zoeken",
	"SUBMIT_A_STORY": "Plaats een bericht",
	"REPLYTO": "Reageer op",
	"POST": "Bericht",
	"PREVIEW": "Preview",
	"DEFAULT": "Standaard 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Uitbetaling Afwijzen",
	"SAVE_FOR_LATER": "OPSLAAN VOOR LATER",
	"CLEAR": "LEEGMAKEN",
	"POST_CONTENT": "Plaats bericht",
	"COMMENT_CONTENT": "Reageer op bericht",
	"TITLE": "Titel",
	"TAGS": "Labels",
	"NOT_MATCH": "KOMT NIET OVEREEN",
	"CONFIRM_PIN": "Bevestig PIN",
	"INCORRECT": "ONJUIST",
	"OPENING_POST": "Bericht openen",
	"SET_PIN": "Instellen PIN",
	"ENTER_PIN": "Invoeren PIN",
	"ARE_YOU_SURE": "Weet u het zeker?",
	"REBLOG_TEXT": "Herbloggen is definitief, wilt u doorgaan?",
	"BROADCAST_ERROR": "Verzendfout, probeer opnieuw!",
	"SUCCESS": "Succesvol",
	"REBLOGGED_POST": "Bericht herblogd!",
	"LOGIN_FAIL": "Inloggen mislukt! Controleer of u geprobeerd heeft in te loggen met uw hoofdwachtwoord of Posting priv sleutel als u voor geavanceerde modus heeft gekozen.",
	"LOGIN_FAIL_A": "Inloggen mislukt! Controleer of u geprobeerd heeft in te loggen met uw hoofdwachtwoord of Actieve priv sleutel als u voor geavanceerde modus heeft gekozen.",
	"WARNING": "Waarschuwing",
	"VOTE_FOR_WITNESS": "Stemmen voor witness",
	"VOTED_FOR_WITNESS": "Gestemd voor witness",
	"AGO": "geleden",
	"FROM_NOW": "vanaf nu",
	"SECS": "secs",
	"A_MIN": "een minuut",
	"MINS": "minuten",
	"AN_HOUR": "een uur",
	"HOURS": "uren",
	"A_DAY": "een dag",
	"DAYS": "dagen",
	"A_MONTH": "een maand",
	"MONTHS": "maanden",
	"A_YEAR": "een jaar",
	"YEARS": "jaren",
	"MIN_READ": "min. leestijd",
	"DOWNVOTE_FLAG": "Stem Omlaag of Vlag",
	"CAPTURE_PICTURE": "Neem Beeld",
	"SELECT_PICTURE": "Selecteer Foto",
	"SET_CUSTOM_URL": "Stel Eigen URL in",
	"INSERT_PICTURE": "Foto Invoegen",
	"ERROR": "Fout",
	"UPLOAD_ERROR": "Upload Fout",
	"CAMERA_CANCELLED": "Camera Geannuleerd",
	"SET_URL": "Stel URL in",
	"DIRECT_LINK_PICTURE": "Directe web link voor de foto",
	"COMMENT_SUBMITTED": "Commentaar is verstuurd!",
	"DELETE_COMMENT": "Het verwijderen van reacties is definitief...",
	"DELETED_COMMENT": "Verwijderde reactie",
	"UPLOADING_PICTURE": "Foto is aan het uploaden",
	"UPLOAD_COMPLETED": "Upload Geslaagd",
	"UPLOAD_FAILED": "Upload Mislukt",
	"PASSWORD_INCORRECT": "Het wachtwoord of gebruikersnaam is fout",
	"INFO": "Info",
	"QR_TEXT": "Plaats een QR code in het scangebied",
	"BALANCE_TEXT": "Controleer of u genoeg tegoed heeft voor de transactie!",
	"NONEXIST_USER": "De gebruiker naar wie u probeert over te maken, bestaat niet!",
	"TRANSFER_TEXT": "Weet u zeker dat u wilt overmaken?",
	"CONFIRMATION": "Bevestiging",
	"TX_BROADCASTED": "Transactie is verstuurd",
	"FEED": "Feed",
	"TRENDING": "Trending",
	"HOT": "Populair",
	"NEW": "Nieuw",
	"PROMOTED": "Gesponsord",
	"VOTES": "Stemmen",
	"PAYOUT": "Uitbetaling",
	"COMMENTS": "Reacties",
	"TRENDING_30": "Trending laatste 30 dagen",
	"SORT_POST_BY": "Sorteer berichten op:",
	"PAYOUT_CYCLE": "Uitbetalingscyclus",
	"POTENTIAL_PAYOUT": "Potentile Uitbetaling",
	"PAST_PAYOUT": "Verleden Uitbetaling",
	"AUTHOR_PAYOUT": "Auteur Uitbetaling",
	"CURATION_PAYOUT": "Curatie Uitbetaling",
	"POST_SUBMITTED": "Bericht is verzonden!",
	"POST_LATER": "Te versturen berichten!",
	"SAVED": "Opgeslagen",
	"CLEARED": "Gewist",
	"FLAGGING_TEXT": "Een bericht vlaggen of omlaag stemmen kan de opbrengsten weghalen en minder zichtbaar maken.<br><br>De vlag mag alleen in de volgende gevallen gebruikt worden: <ul><li>Fraude of Plagiaat</li><li>Haatspraak of Internet Trolling</li><li>Met intentie in verkeerde categorie geplaatst of Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limiet verzoek bereikt. Bekijk ook andere trends/tags!",
	"POST_IS_UNBOOKMARK": "Bericht is van bladwijzers verwijderd!",
	"POST_IS_BOOKMARK": "Bericht is aan bladwijzers toegevoegd!",
	"RESET": "Herstellen",
	"MODIFY_PICTURE": "Pas profielfoto aan",
	"MODIFY_COVER_PICTURE": "Pas omslagfoto aan",
	"ACTIVE_KEY_REQUIRED_TEXT": "Gelieve een actieve sleutel te gberuiken wanneer u kiest voor geavanceerde inlog modus!",
	"RESET_PICTURE_TEXT": "Dit zal de profielfoto van de gebruiker herstellen",
	"RESET_COVER_PICTURE_TEXT": "Dit zal de omslagfoto van de gebruiker herstellen",
	"UPDATE_REQUIRES_RESTART": "Server update vereist herstart!",
	"SETTINGS_UPDATED": "Instellingen zijn bijgewerkt!",
	"LANGUAGES": "Talen",
	"LANGUAGES_TEXT": "Hier kunt u de taal van de app veranderen.",
	"LOGIN_TO_X": "Om dit te doen dient u in te loggen met uw hoofdwachtwoord, actieve/posting sleutel. Log alstublieft in en probeer opnieuw.",
	"GALLERY": "Gallerij",
	"TRANSLATIONS": "Vertalers",
	"SHARE": "Delen",
	"MARKETPLACE": "Marktplaats",
	"EXCHANGE": "Beurs",
	"DRAFTS": "Concepten",
	"POST_IS_UNDRAFT": "Bericht is uit concepten verwijderd!",
	"POST_IS_DRAFT": "Bericht toegevoegd aan concepten!",
	"SWIPE_LEFT": "Veeg naar links voor opties",
	"MANAGE": "Beheer",
	"IMAGE_REMOVED": "Afbeelding is verwijderd",
	"COPY": "Kopiren",
	"NO_IMAGE": "Je hebt nog geen afbeelding geupload!",
	"PULL_DOWN_TO_REFRESH": "Trek omlaag om te verversen",
	"EXTERNAL_APPS": "Externe applicaties",
	"PLUGINS": "Plugins",
	"SUGGEST": "Suggereer",
	"COMING_SOON": "Binnenkort",
	"CHAIN": "Keten",
	"CHAIN_TEXT": "Hier kunt u veranderen van blockchain of standaard platform.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Verander hier uw standaard valuta. Beloningen voor berichten/reacties in deze valuta.",
	"ABOUT_11": "<br><b>Functies</b><br>- Toegang tot unieke artikelen met uiteenlopende onderwerpen.<br>- Converseer met auteurs door te reageren en te discussiren.<br>- Stemmen voor berichten om zo de auteur te belonen alsook beloning te ontvangen voor cureren.<br>- Publiceren van uw artikelen en berichten en verdien beloningen door interactie en groei van volgers.<br>- Schrijf artikelen, sla meerdere concepten op een later tijdstip te publiceren.<br>- Sla favoriete artikelen op onder bladwijzers om deze later te lezen.<br>- Wissel of verzilver je inkomsten.<br>- Maak tegoeden over aan andere auteurs of gebruikers, vrienden, volgers, etc.<br>- Volg interessante auteurs, bloggers.<br>- Zoek je volgers en auteurs die je volgt.<br>- Ontvang notificaties om in contact te blijven met je volgers en discussies waarin je betrokken bent.<br>- Zoek op interestante labels/categorien van artikelen, auteurs.<br>- Personaliseer je profiel.<br>- Vele andere functies die nog zullen worden toegevoegd.<br><br><b>Veiligheid</b><br>1. App zal nooit tegoeden van de gebruiker aanraken of opslaan.<br>2. App heeft een client-side beveiligingsmodel, met priv sleutels die lokaal opgeslagen worden en nooit naar andere servers toegestuurd worden, u bent zelf verantwoordelijk om het wachtwoord op te slaan.<br>3. App biedt een simpele en aansprekende gebruikerstoegang.<br>4. App biedt een extra beveiliging door middel van een pincode<br><br>eSteem ondersteund Steem en Golos platformen.<br>",
	"FOUNDER": "Oprichter en Hoofdontwikkelaar",
	"ADD_ACCOUNT": "Account toevoegen",
	"PLATFORM": "Platform",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Escrow-agent",
	"RATIFICATION_DEADLINE": "Ratificatie termijn",
	"ESCROW_EXPIRATION": "Escrow verlopen",
	"ESCROW_FEE": "Escrow vergoeding",
	"ESCROW_TERMS": "Escrow voorwaarden",
	"NIGHT_MODE": "Nacht modus",
	"DAY_MODE": "Dag modus",
	"VIEW_CONTEXT": "Bekijk de volledige context",
	"USER_NOTFOUND": "Gebruiker niet gevonden",
	"APPROVE": "Goedkeuren",
	"DISPUTE": "Geschil",
	"RELEASE": "Versie",
	"FROM": "Van",
	"ID": "id",
	"SUBMIT": "Verzend",
	"RECEIVER": "Ontvanger",
	"LOCATION": "Plaats",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Toon naam"
}
},{}],122:[function(require,module,exports){
module.exports={
	"HOME": "Strona gwna",
	"LOGIN": "Zaloguj",
	"LOGOUT": "Wyloguj",
	"PROFILE": "Profil",
	"FOLLOW": "Obserwuj",
	"BOOKMARKS": "Zakadki",
	"TRANSFER": "Przelew",
	"MARKET": "Gieda",
	"SETTINGS": "Ustawienia",
	"ABOUT": "O Nas",
	"ABOUT_1": "gdzie kady moe zdobywa wynagrodzenie za swoje wpisy!",
	"ABOUT_2": "funkcjonuje w oparciu o patform {{platformname}}. Aplikacja jest stworzona przez",
	"ABOUT_3": "i jest ona otwartym i prowadzonym przez spoeczno projektem. Oferuje dostp do czytania, komentowania, oddawania gosu na treci oraz udostpniania wpisw, a take na zarzdzanie zarobkami oraz innymi dostpnymi opcjami oferowanymi przez acuch blokw {{platformname}} i {{sitename}}.",
	"ABOUT_4": "Aplikacja nigdy nie ma dostpu i nie przetrzymuje rodkw finansowych uytkownika.",
	"ABOUT_5": "Aplikacja oferuje model bezpieczestwa po stronie klienta, gdzie klucze prywatne s przechowywane lokalnie i nigdy nie s przesyane na jakiekolwiek serwery.",
	"ABOUT_6": "Aplikacja oferuje atwy i przyjemny w obsudze interfejs.",
	"ABOUT_7": "Aplikacja nigdy nie wymaga podania danych osobowych od swoich uytkownikw.",
	"ABOUT_8": "Zagosuj na good-karma na wiadka",
	"ABOUT_9": "Kontakt/Opinie",
	"ABOUT_10": "Wicej informacji:",
	"REMOVE": "Usu",
	"MARKET_VIEW": "Widok na gied",
	"PRICE": "Cena",
	"AMOUNT": "Ilo",
	"TOTAL": "Suma",
	"NOORDERS": "Brak otwartych zlece dla",
	"DATE": "Data",
	"BUY": "Kup",
	"SELL": "Sprzedaj",
	"OPEN": "W toku",
	"HISTORY": "Historia",
	"FOLLOW_BACK": "Obserwuj rwnie",
	"FOLLOWED": "Obserwowany",
	"UNFOLLOW": "Przesta obserwowa",
	"FOLLOWING": "Obserwujesz",
	"FOLLOWERS": "Obserwuj ci",
	"SEARCH_FOLLOWERS": "Szukaj wrd obserwujcych",
	"SEARCH_FOLLOWING": "Szukaj wrd obserwowanych",
	"BY": "przez",
	"IN": "w",
	"MENU": "Menu",
	"BOOKMARK": "Zakadki",
	"REBLOG": "Rebloguj",
	"UPVOTE": "Gos za",
	"DOWNVOTE": "Gos przeciw",
	"UNVOTE_DOWNVOTED": "Anuluj gos przeciw",
	"UNVOTE_UPVOTED": "Anuluj gos za",
	"REPLY": "Odpowied",
	"EDIT": "Edytuj",
	"POST_1": "Przecignij komentarz w lewo, aby zobaczy dostpne opcje",
	"POST_2": "Nacinij na komentarze, aby rozwin",
	"OPTIONS": "Opcje",
	"RESTEEMED_BY": "Resteemowany przez",
	"NOTHING_HERE": "Na razie nic tu nie ma...",
	"BALANCES": "Salda",
	"PROFILE_1": "{{platformname}} wymienialne tokeny, ktre mog by przetransferowane w dowolnym momencie. {{platformname}} mog by wymienione na {{platformpower}} w procesie zwanym Power-up.\n",
	"PROFILE_2": "{{platformpower}} tokeny wpywu, ktre umoliwiaj na zdobywanie wikszej iloci mocy za trzymanie ich duoterminowo oraz za gosowanie na wpisy. Im wicej si ich posiada, tym bardziej wpywa si na wynagrodzenie innych wpisw i na zdobywanie nagrd zwizane z oddaniem gosu.",
	"PROFILE_3": "Tokeny warte okoo {{platformsunit}} platformy {{platformname}}.",
	"ESTIMATED_VALUE": "Szacowana warto",
	"PROFILE_4": "Warto jest szacowana na podstawie redniej wartoci z 7-miu dni.",
	"TRANSACTION_HISTORY": "Historia transakcji",
	"POSTING": "Udostpnianie",
	"PROFILE_5": "Klucz udostpnienia jest uywany przy udostpnianiu wpisw i oddawaniu gosw. Powinien by inny ni klucz aktywny i klucz wasnoci.",
	"OWNER": "Waciciel",
	"PROFILE_6": "Klucz wasnoci jest kluczem gwnym konta i jest wymagany do zmiany pozostaych kluczy. Klucz prywatny lub haso do klucza wasnoci powinno by trzymane offline, gdy jest to tylko moliwe.",
	"ACTIVE": "Aktywny",
	"PROFILE_7": "Klucz aktywny jest uywany do wykonywania przeleww i skadania zamwie na wewntrznej giedzie.",
	"MEMO": "Notatka",
	"PROFILE_8": "Klucz notatki jest uyty, aby sporzdza i czyta notatki.",
	"BLOG": "Blog",
	"POSTS": "Wpisy",
	"REPLIES": "Odpowiedzi",
	"WALLET": "Portfel",
	"TAG": "Etykieta",
	"USER": "Uytkownik",
	"CLOSE": "Zamknij",
	"TO": "Do",
	"ASSET": "Kapita",
	"SEND": "Wylij",
	"SECURITY": "Bezpieczestwo",
	"AVAILABLE": "Dostpny",
	"PUBLIC_MEMO": "Notatka publiczna",
	"TO_DESC": "Uytkownik np. good-karma",
	"PIN_CODE": "Kod PIN",
	"PIN_TEXT": "Kod PIN pozwala Ci zabezpieczy aplikacj oraz twoje dane. <br/><br/> <b>Uwaga:</> Masz maksymalnie 4 prby aby wpisa poprawne haso i odblokowa konto, jeeli zapomniae kodu PIN lub wpisae ze haso wicej razy, aplikacja usunie wszystkie dane uytkownika. Moesz si wtedy zalogowa ponownie i kontynuowa uytkowanie aplikacji.",
	"NOTIFICATIONS": "Powiadomienia",
	"VOTE_TEXT": "Otrzymasz powiadomienie, gdy kto odda gos na twj wpis! <br/><b>Uwaga:</b>Powiadomienia zawieraj take typ gosu (tzn. gos za, gos przeciw, anuluj gos).",
	"VOTE": "Zagosuj",
	"COMMENT_TEXT": "Otrzymasz powadomienie, gdy kto skomentuje twj wpis lub komentarz!<br/> <b>Uwaga:</b>Zostaniesz rwnie powiadomiony, gdy kto <b>edytuje</b> swj komentarz.",
	"COMMENT": "Komentarz",
	"FOLLOW_TEXT": "Otrzymasz powiadomienie, gdy kto zacznie lub przestanie ci obserwowa!",
	"MENTIONS": "Wzmianki",
	"MENTIONS_TEXT": "Zostaniesz powiadomiony, gdy kto wspomni ci w swoim wpisie/komentarzu!",
	"RESTEEM": "Rebloguj",
	"RESTEEM_TEXT": "Otrzymasz powiadomienie, gdy kto resteemuje twj wpis!",
	"CONFIGURATIONS": "Konfiguracje",
	"VOTING": "Oddanie gosu",
	"VOTING_TEXT": "Moc lub procent gosu wpywa na moc oddanego gosu i umoliwia ci na regulowanie swojego wynagrodzenia za oddane gosy. <br/><br/><b>Uwaga:</b> Zmiana wpynie na moc/procent gosu caej aplikacji, dotyczy to rwnie gosw oddanych przeciw",
	"SERVER": "Serwer",
	"SERVER_TEXT": "Rekomendowane",
	"SAVE_CHANGES": "Zachowaj zmiany",
	"VOTERS_INFO": "Gosowali",
	"WELCOME_BACK": "Witaj ponownie!",
	"LOGIN_1": "Aby kontynuowa, zaloguj si przy uyciu loginu i hasa.",
	"LOGIN_2": "Klucz udostpniajcy jest uywany do udostpniania wpisw, komentowania, gosowania i ledzenia.",
	"LOGIN_3": "Klucz aktywny uywany jest do wykonywania przeleww i zmian zdjcia profilowego.",
	"LOGIN_4": "Dane uytkownika s trzymane lokalnie przy uycia twojego urzdzenia. Po wylogowaniu dane zostaj usunite!",
	"DONT_HAVE": "Nie masz jeszcze konta?",
	"SIGN_UP_NOW": "Za konto",
	"CANCEL": "Anuluj",
	"ADVANCED": "Zaawansowane",
	"ACTIVE_PRIKEY": "Klucz aktywny prywatny",
	"POSTING_PRIKEY": "Klucz udostpniajcy prywatny",
	"MASTER_PASS": "Haso gwne",
	"USERNAME": "Login",
	"CARD_VIEW": "Widok karty",
	"COMPACT_VIEW": "Widok kompaktowy",
	"SEARCH": "Szukaj",
	"SUBMIT_A_STORY": "Opublikuj tre",
	"REPLYTO": "Odpowiedz",
	"POST": "Opublikuj",
	"PREVIEW": "Podgld",
	"DEFAULT": "Standardowe 50% / 50%",
	"POWERUP": "Power Up 100%",
	"DECLINE_PAYOUT": "Odmw wynagrodzenia",
	"SAVE_FOR_LATER": "ZACHOWAJ NA PNIEJ",
	"CLEAR": "WYCZY",
	"POST_CONTENT": "Opublikuj wpis",
	"COMMENT_CONTENT": "Skomentuj",
	"TITLE": "Tytu",
	"TAGS": "Etykiety",
	"NOT_MATCH": "BRAK ZGODNOCI",
	"CONFIRM_PIN": "Powtrz PIN",
	"INCORRECT": "NIEPOPRAWNY",
	"OPENING_POST": "otwieranie wpisu",
	"SET_PIN": "Ustaw PIN",
	"ENTER_PIN": "Podaj PIN",
	"ARE_YOU_SURE": "Czy jeste pewien?",
	"REBLOG_TEXT": "Reblog jest nieodwracalne, czy chcesz kontynuowa?",
	"BROADCAST_ERROR": "Bd poczenia, sprbuj ponownie!",
	"SUCCESS": "Zakoczono powodzeniem",
	"REBLOGGED_POST": "Rebloguj wpis!",
	"LOGIN_FAIL": "Bd logowania! Upewnij si czy zalogowae si przy uyciu klucza gwnego lub czy uye aktywnego klucza prywatnego przy logowaniu w trybie zaawansowanym.",
	"LOGIN_FAIL_A": "Bd logowania! Upewnij si czy zalogowae si przy uyciu klucza gwnego lub czy uye prywatnego klucza udostpniajcego przy logowaniu w trybie zaawansowanym.",
	"WARNING": "Uwaga",
	"VOTE_FOR_WITNESS": "Gosujesz na wiadka",
	"VOTED_FOR_WITNESS": "Zagosowae na wiadka",
	"AGO": "temu",
	"FROM_NOW": "od teraz",
	"SECS": "sekund(y)",
	"A_MIN": "minut",
	"MINS": "minut(y)",
	"AN_HOUR": "godzin",
	"HOURS": "godzin(y)",
	"A_DAY": "dzie",
	"DAYS": "dni",
	"A_MONTH": "miesic",
	"MONTHS": "miesicy",
	"A_YEAR": "rok",
	"YEARS": "lat(a)",
	"MIN_READ": "minut temu zostao przeczytane",
	"DOWNVOTE_FLAG": "Gosuj przeciw lub oflaguj",
	"CAPTURE_PICTURE": "Zrb zdjcie",
	"SELECT_PICTURE": "Wybierz obraz",
	"SET_CUSTOM_URL": "Ustaw wybrany URL",
	"INSERT_PICTURE": "Wstaw obraz",
	"ERROR": "Bd",
	"UPLOAD_ERROR": "Bd przy wrzucaniu pliku",
	"CAMERA_CANCELLED": "Aparat nieaktywna",
	"SET_URL": "Ustaw URL",
	"DIRECT_LINK_PICTURE": "Bezporedni link na stron ze zdjciem",
	"COMMENT_SUBMITTED": "Komentarz zosta opublikowany!",
	"DELETE_COMMENT": "Usunicie komentarzy jest nieodwracalne...",
	"DELETED_COMMENT": "Usu komentarz",
	"UPLOADING_PICTURE": "Wstaw zdjcie",
	"UPLOAD_COMPLETED": "Wstawienie zakoczone",
	"UPLOAD_FAILED": "Wrzucenie nie powiodo si",
	"PASSWORD_INCORRECT": "Nieprawidowy login lub haso",
	"INFO": "Informacja",
	"QR_TEXT": "Umie kod QR w obrbie pola skanowania",
	"BALANCE_TEXT": "Upewnij si, czy masz wystarczajc ilo rodkw aby wykona transakcj!",
	"NONEXIST_USER": "Uytkownik do ktrego prbujesz przesa rodki, nie istnieje!",
	"TRANSFER_TEXT": "Czy na pewno chcesz wysa rodki?",
	"CONFIRMATION": "Potwierdzenie",
	"TX_BROADCASTED": "Transakcja w toku",
	"FEED": "Aktualnoci",
	"TRENDING": "Trendy",
	"HOT": "Na topie",
	"NEW": "Nowe",
	"PROMOTED": "Promowane",
	"VOTES": "Ilo gosw",
	"PAYOUT": "Przychd",
	"COMMENTS": "Ilo Komentarzy",
	"TRENDING_30": "Trendy z 30 dni",
	"SORT_POST_BY": "Uporzdkuj wedug:",
	"PAYOUT_CYCLE": "Cykl przychodu",
	"POTENTIAL_PAYOUT": "Potencjalny przychd",
	"PAST_PAYOUT": "Wczeniej wypacono",
	"AUTHOR_PAYOUT": "Przychd autora",
	"CURATION_PAYOUT": "Przychd za mecenat",
	"POST_SUBMITTED": "Wpis zosta opublikowany!",
	"POST_LATER": "Opublikuj wpis pniej!",
	"SAVED": "Zapamitaj",
	"CLEARED": "Wyczy",
	"FLAGGING_TEXT": "Oflagowanie wpisu moe spowodowa usunicie wynagrodzenia i zmniejszenie jego widocznoci.<br><br>Flaga powinna by uyta w sytuacjach takich jak: <ul><li>Oszustwo lub Plagiat</li><li>Mow nienawici lub Internetowy trolling</li><li>Wpis celowo le skatagoryzowany lub Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limit zosta osignity. Sprawd inne etykiety/trendy!",
	"POST_IS_UNBOOKMARK": "Wpis zosta usunity z zakadek!",
	"POST_IS_BOOKMARK": "Wpis zosta dodany do zakadek!",
	"RESET": "Zresetuj",
	"MODIFY_PICTURE": "Zmodyfikuj zdjcie profilowe",
	"MODIFY_COVER_PICTURE": "Zmie zdjcie w tle",
	"ACTIVE_KEY_REQUIRED_TEXT": "Podaj aktywny klucz prywatny jeli wybrae tryb zaawansowanego logowania!",
	"RESET_PICTURE_TEXT": "Spowoduje zresetowanie zdjcia profilowego",
	"RESET_COVER_PICTURE_TEXT": "Spowoduje zresetowanie zdjcia w tle",
	"UPDATE_REQUIRES_RESTART": "Aktualizacja serwera wymaga zresetowania!",
	"SETTINGS_UPDATED": "Ustawienia zostay zaktualizowane",
	"LANGUAGES": "Jzyk",
	"LANGUAGES_TEXT": "Tu moesz zmieni jzyk aplikacji.",
	"LOGIN_TO_X": "Ta operacja wymaga zalogowania hasem gwnym, kluczem akytwnym/udostpniajcym. Zaloguj si i sprbuj ponownie.",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Przetumaczyli",
	"SHARE": "Pole",
	"MARKETPLACE": "Sklep",
	"EXCHANGE": "Wymiana",
	"DRAFTS": "Wersje robocze",
	"POST_IS_UNDRAFT": "Wpis zosta usunity z roboczych!",
	"POST_IS_DRAFT": "Wpis zosta zapisany jako wersja robocza!",
	"SWIPE_LEFT": "Przecignij w lewo, aby zobaczy opcje",
	"MANAGE": "Zarzdzaj",
	"IMAGE_REMOVED": "Obraz zosta usunity",
	"COPY": "Kopiuj",
	"NO_IMAGE": "Nie opublikowae jeszcze adnego obrazu!",
	"PULL_DOWN_TO_REFRESH": "Przecignij w d, aby odwiey.",
	"EXTERNAL_APPS": "Aplikacje zewntrzne",
	"PLUGINS": "Pluginy",
	"SUGGEST": "Zasugeruj",
	"COMING_SOON": "Ju wkrtce",
	"CHAIN": "acuch",
	"CHAIN_TEXT": "Tutaj moesz zmieni acuch blokw lub domyln platform.",
	"CURRENCY": "Waluta",
	"CURRENCY_TEXT": "Tutaj mona zmieni domyln walut. Warto nagrody za post/komentarz zostanie wywietlona w tej walucie.",
	"ABOUT_11": "<br><b>Lista funkcji</b><br>- Dostp do unikalnych treci z krgw Twoich zainteresowa.<br>- Zaangauj si w dyskusje z autorami.<br> - Gosuj na posty by nagrodzi autorw, zdobywaj wynagrodzenie za znajdowanie wartociowych treci.<br> - Publikuj artykuy i zarabiaj na nich zdobywajc zwolennikw<br> - Pisz podczas podry, zapisuj wiele kopii roboczych do pniejszej publikacji.<br> - Dodaj ulubione artykuy do zakadek by przeczyta je pniej.<br> - Wymie lub wypa swoje zarobki. <br> - Wylij swoje rodki do autorw, uytkownikw, przyjaci, zwolennikw, etc.<br> -led ciekawych autorw.<br> - Wyszukiwanie wrd postw swoich zwolennikw oraz ledzonych autorw..<br> - Otrzymuj powiadomienia by nie przegapi dyskusji w ktre jeste zaangaowany.<br> - Szukaj ciekawych tagw / kategorii. <br> -Spersonalizuj swj profil. <br> Jeszcze wicej funkcji wkrtce.. <br><br><b>Bezpieczestwo</b> <br>1. Aplikacja nigdy nie siga do Twoich rodkw.. <br>2. Aplikacja oferuje model zabezpiecze po stronie klienta, z kluczami prywatnymi trzymanymi lokalnie i nigdy nie wysya ich do adnego serwera. Jeste odpowiedzialny za wykonywanie kopii zapasowych swoich hase. <br>3. Aplikacja oferuje prosty, atrakcyjny interfejs uytkownika. <br>4. Dodatkowa warstwa zabezpiecze w postaci kodu Pin <br><br>eSteem obsuguje platformy Steem oraz Golos. <br>",
	"FOUNDER": "Zaoyciel i gwny programista",
	"ADD_ACCOUNT": "Dodaj konto",
	"PLATFORM": "Platforma",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": "Agent Escrow",
	"RATIFICATION_DEADLINE": "Termin ratyfikacji",
	"ESCROW_EXPIRATION": "Wyganicie Escrow",
	"ESCROW_FEE": "Opata za usug Escrow",
	"ESCROW_TERMS": "Warunki usugi Escrow",
	"NIGHT_MODE": "Tryb Nocny",
	"DAY_MODE": "Tryb dzienny",
	"VIEW_CONTEXT": "Zobacz peny kontekst",
	"USER_NOTFOUND": "Nie znaleziono uytkownika",
	"APPROVE": "Zatwierd",
	"DISPUTE": "Spr",
	"RELEASE": "Uwolnij",
	"FROM": "Od",
	"ID": "id",
	"SUBMIT": "Przelij",
	"RECEIVER": "Odbiorca",
	"LOCATION": "Lokalizacja",
	"WEBSITE": "Witryna internetowa",
	"DISPLAY_NAME": "Nazwa wywietlana"
}
},{}],123:[function(require,module,exports){
module.exports={
	"HOME": "Pgina Inicial",
	"LOGIN": "Entrar",
	"LOGOUT": "Sair",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Favoritos",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Configuraes",
	"ABOUT": "Sobre",
	"ABOUT_1": "onde qualquer um pode ganhar recompensas pelo seu contedo",
	"ABOUT_2": " patrocinado pela plataforma {{platformname}}. Aplicativo criado por",
	"ABOUT_3": "e  cdigo-aberto, projecto orientado para a comunidade mvel. Oferece acesso ao contedo para leitura, comentrios, votos, publicar, tranferir ganhos etc. Caratersticas oferecidas pel {{platformname}} blockchain e {{sitename}}.",
	"ABOUT_4": "1. O aplicativo nunca acessa ou guarda o dinheiro dos usurios.",
	"ABOUT_5": "2. A App oferee um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca envida a outros servidores.",
	"ABOUT_6": "3. O Aplicativo oferece simplicidade, interfaces de usurio e experincias atrativas.",
	"ABOUT_7": "4. O Aplicativo requer que os usurios insiram informaes pessoais.",
	"ABOUT_8": "Vote bom-karma como testemunha",
	"ABOUT_9": "Contato/Comentrios",
	"ABOUT_10": "Mais informaes:",
	"REMOVE": "Remover",
	"MARKET_VIEW": "Viso do Mercado",
	"PRICE": "Preo",
	"AMOUNT": "Quantidade",
	"NOORDERS": "Sem ordens abertas para",
	"DATE": "Data",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Hitrico",
	"FOLLOW_BACK": "Seguir de volta",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Deixar de seguir",
	"FOLLOWING": "Seguindo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Procurar seguidores",
	"SEARCH_FOLLOWING": "Procurar quem estou seguindo",
	"BY": "por",
	"IN": "no",
	"BOOKMARK": "Favoritos",
	"REBLOG": "Repostar",
	"UPVOTE": "Upvote",
	"UNVOTE_DOWNVOTED": "Cancelar Downvote",
	"UNVOTE_UPVOTED": "Cancelar Upvote",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Deslize para esquerda nos comentrios para ver as opes",
	"POST_2": "Toque nos comentrios para ver os sub-comentrios",
	"OPTIONS": "Opes",
	"RESTEEMED_BY": "Repostado por",
	"NOTHING_HERE": "Nada por aqui, ainda...",
	"BALANCES": "Balano",
	"PROFILE_1": "{{platformname}}, provas transacionveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
	"PROFILE_2": "{{platformpower}}, provas de influencia par ganhar mais poder por guardar a longo prazo e votar nas publicaes. Quanto mais se possui mais se pode influenciar as recompensas a outros e ganhar mais recompensas por votar.",
	"PROFILE_3": "Provas valendo cerca de {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor estimado",
	"PROFILE_4": "O valor estimado  baseado numa mdia do valor de 7 dias de {{platformname}}.",
	"TRANSACTION_HISTORY": "Histrico de Transaes",
	"POSTING": "Postando",
	"PROFILE_5": "A chave de postagem  usada para postar e votar. Ela dever ser diferente da chave de ativao e da chave de proprietrio.",
	"OWNER": "Proprietrio",
	"PROFILE_6": "A chave de proprietrio  a chave mestra para conta e  exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietrio dever ser mantida offline assim que possvel.",
	"ACTIVE": "Ativo",
	"PROFILE_7": "A chave de ativao  usada para fazer transferncias e colocar ordens no mercado interno.",
	"MEMO": "Anotaes",
	"PROFILE_8": "A chave de anotaes  usada para criar e ler anotaes.",
	"POSTS": "Postagens",
	"REPLIES": "Respostas",
	"WALLET": "Carteira",
	"USER": "Usurio",
	"CLOSE": "Fechado",
	"TO": "Para",
	"ASSET": "Ativo",
	"SEND": "Enviar",
	"SECURITY": "Segurana",
	"AVAILABLE": "Disponvel",
	"PUBLIC_MEMO": "Memorando Pblico",
	"TO_DESC": "Utilizador ex: good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "Cdigo Pin ajuda voc a assegurar o aplicativo e suas informaes. <br/><br/> Uma vez ativado, voc ter no mximo 4 tentativas para destravar, se voce esquecero pin ou errar, o aplicativo ir remover suas informaes de usurio. Voc pode entrar de novo e continuar a usar o aplicativo.",
	"NOTIFICATIONS": "Notificaes",
	"VOTE_TEXT": "Voc receber uma notificao quando algum voter no seu contedo! Notificaes tambm incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Voc receber notificao quando algum comentar nas suas postagens ou comentrios.<br/> Notificaes incluem quando algum edita os comentrios tambm.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Voc receber uma notificao quando algum Seguir ou Deixar de seguir voc!",
	"MENTIONS": "Menes",
	"MENTIONS_TEXT": "Voc receber uma notificao quando algum mencionar voc em alguma postagem ou comentrio!",
	"CONFIGURATIONS": "Configuraes",
	"VOTING": "Votando",
	"VOTING_TEXT": "O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto ir modificar o pseso/percentagem para votar para baixo tambm e em todo o lado na App",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Salvar mudanas",
	"VOTERS_INFO": "Informaes dos eleitores",
	"WELCOME_BACK": "Bem vindo de Volta!",
	"LOGIN_1": "Conecte-se com seu nome de usurio e senha para continuar.",
	"LOGIN_2": "Chave de postagem  usada para postar, comentar, votar, seguir.",
	"LOGIN_3": "Chave de ativao  usada para tranferncias e atualizao de fotos de perfil.",
	"LOGIN_4": "As credenciais do utilizador so guardadas localmente no seu aparelho. Depis de desligar as suas cerdenciais so removidas!",
	"DONT_HAVE": "No possui uma conta?\n",
	"SIGN_UP_NOW": "Cadastre-se agora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanado",
	"ACTIVE_PRIKEY": "Chave de ativao privada",
	"POSTING_PRIKEY": "Chave de postagem privada",
	"MASTER_PASS": "Senha Mestra/Principal",
	"USERNAME": "Usurio",
	"CARD_VIEW": "Viso de Carto",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Procurar",
	"SUBMIT_A_STORY": "Postar uma histria",
	"REPLYTO": "Responder para",
	"POST": "Postagem",
	"PREVIEW": "Vizualizao",
	"DEFAULT": "Padro 50% / 50%",
	"POWERUP": "Fora Total 100%",
	"DECLINE_PAYOUT": "Recusar Pagamento",
	"SAVE_FOR_LATER": "Guardar pra mais tarde",
	"CLEAR": "Terminado",
	"POST_CONTENT": "Contedo da postagem",
	"COMMENT_CONTENT": "Contedo do comentrio",
	"TITLE": "Ttulo",
	"NOT_MATCH": "No condiz",
	"CONFIRM_PIN": "Confirmar Pin",
	"INCORRECT": "Incorreto",
	"OPENING_POST": "Abrindo postagem",
	"SET_PIN": "Configure PIN",
	"ENTER_PIN": "Entrar com Pin",
	"ARE_YOU_SURE": "Voc tem certeza?",
	"REBLOG_TEXT": "Republicar  irreversvel, quer mesmo continuar?",
	"BROADCAST_ERROR": "Erro de difuso, tente novamente!",
	"SUCCESS": "Sucesso",
	"REBLOGGED_POST": "Publucao republicada",
	"LOGIN_FAIL": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave publicao privada no Login se escolheu o modo avanado.",
	"LOGIN_FAIL_A": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avanado.",
	"WARNING": "Cuidado",
	"VOTE_FOR_WITNESS": "Votando por uma Testemunha",
	"VOTED_FOR_WITNESS": "Votou por uma Testemunha",
	"AGO": "atrs",
	"FROM_NOW": "de agora",
	"SECS": "segs",
	"A_MIN": "um minuto",
	"AN_HOUR": "uma hora",
	"HOURS": "horas",
	"A_DAY": "um dia",
	"DAYS": "dias",
	"A_MONTH": "um ms",
	"MONTHS": "meses",
	"A_YEAR": "um ano",
	"YEARS": "anos",
	"MIN_READ": "ler min",
	"DOWNVOTE_FLAG": "Vote abaixo ou bandeire",
	"CAPTURE_PICTURE": "Capturar imagem",
	"SELECT_PICTURE": "Escolher uma imagem",
	"SET_CUSTOM_URL": "Configure URL costumizada",
	"INSERT_PICTURE": "Inserir uma imagem",
	"ERROR": "Erro",
	"UPLOAD_ERROR": "Erro no carregamento",
	"CAMERA_CANCELLED": "Camera cancelada",
	"SET_URL": "Configural URL",
	"DIRECT_LINK_PICTURE": "Link web direto para a imagem",
	"COMMENT_SUBMITTED": "Comentrio postado!",
	"DELETE_COMMENT": "Deletar comentrios  irreversvel",
	"DELETED_COMMENT": "Comentrio deletado",
	"UPLOADING_PICTURE": "Carregabdo imagem",
	"UPLOAD_COMPLETED": "Carregamento compeleto",
	"UPLOAD_FAILED": "Carregamento falhou",
	"PASSWORD_INCORRECT": "A senha ou nome da conta esto incorretos",
	"INFO": "Informaes",
	"QR_TEXT": "Ponha o cdigo QR dentro da rea de scan",
	"BALANCE_TEXT": "Certifique-se que possui saldo suficiente para a transao!",
	"NONEXIST_USER": "O utilizador para quem est a tentar transferir fundos, no existe",
	"TRANSFER_TEXT": "Tem certeza que quer transferir?",
	"CONFIRMATION": "Confirmao",
	"TX_BROADCASTED": "Transao foi difundida",
	"TRENDING": "Tendencia",
	"HOT": "Quente",
	"NEW": "Novidades",
	"PROMOTED": "Promovidos",
	"VOTES": "Votos",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Comentrios",
	"TRENDING_30": "Tendencia a 30 dias",
	"SORT_POST_BY": "Ordenar publicaes por:",
	"PAYOUT_CYCLE": "Ciclo de Pagamento",
	"POTENTIAL_PAYOUT": "Pagamento em potencial",
	"PAST_PAYOUT": "ltimo Pagamento",
	"AUTHOR_PAYOUT": "Pagamento do Autor",
	"CURATION_PAYOUT": "Pagamento de curadoria",
	"POST_SUBMITTED": "Postagem enviada!",
	"POST_LATER": "Publique para futura submisso",
	"SAVED": "Salvo",
	"CLEARED": "Limpo",
	"FLAGGING_TEXT": "Por Bandeira numa publicao pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira dev ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de dio ou Internet Trolling</li><li>Categorizao mal feita intencionalmente ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite de pedidos atingido. verifique outro assunto/etiqueta!",
	"POST_IS_UNBOOKMARK": "Postagem removida dos favoritos!",
	"POST_IS_BOOKMARK": "Postagem adicionada aos favoritos!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar foto de perfil",
	"MODIFY_COVER_PICTURE": "Modificar foto de capa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor fornaa a chave de activao privada que escolheu, Modo de Login Avanado",
	"RESET_PICTURE_TEXT": "Isto reconfigura a imagem do perfil ultizador",
	"RESET_COVER_PICTURE_TEXT": "Isto reconfigura a imagem do ultizador",
	"UPDATE_REQUIRES_RESTART": "Atualizao do server obriga a Reiniciar!",
	"SETTINGS_UPDATED": "Configuraes foram atualizadas",
	"LANGUAGES": "Lnguas",
	"LANGUAGES_TEXT": "Aqui pode mudar a lngua da App",
	"LOGIN_TO_X": "Est operao obriga que o utilizador estaja ligado com a senha prinipal, chave activao/publicao",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Tradutores que contribuiram",
	"SHARE": "Partilhar",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cambio",
	"DRAFTS": "Rascunhos",
	"POST_IS_UNDRAFT": "Postagem removida dos Rascunhos!",
	"POST_IS_DRAFT": "Postagem adicionada a Rascunhos!",
	"SWIPE_LEFT": "Role para a esquerda para opes",
	"MANAGE": "Gerir",
	"IMAGE_REMOVED": "Image. removida",
	"COPY": "Copiar",
	"NO_IMAGE": "No carregou nenhuma imagem, ainda",
	"PULL_DOWN_TO_REFRESH": "Carregue para refrescar",
	"EXTERNAL_APPS": "Apps Externas",
	"SUGGEST": "Sugira",
	"COMING_SOON": "Brevemente",
	"CHAIN_TEXT": "Aqui pode escolher blockchain ou a plataforma por defeito"
}
},{}],124:[function(require,module,exports){
module.exports={
	"HOME": "Pgina Inicial",
	"LOGIN": "Entrar",
	"LOGOUT": "Sair",
	"PROFILE": "Perfil",
	"FOLLOW": "Seguir",
	"BOOKMARKS": "Favoritos",
	"TRANSFER": "Transferir",
	"MARKET": "Mercado",
	"SETTINGS": "Configuraes",
	"ABOUT": "Sobre",
	"ABOUT_1": "Onde qualquer um pode ganhar recompensas pelo seu contedo",
	"ABOUT_2": " uma aplicao social onde voc  pago por publicar, comentar e curar.",
	"ABOUT_3": "e  cdigo-aberto, projecto orientado para a comunidade mvel. Oferece acesso ao contedo para leitura, comentrios, votos, publicar, tranferir ganhos etc. Carateristicas oferecidas por {{platformname}} blockchain and {{sitename}}.",
	"ABOUT_4": "1. O aplicativo nunca acessa ou guarda o dinheiro dos utilizadores.",
	"ABOUT_5": "2. A App oferece um modelo seguro do lado-cliente, com chaves privadas, guardadas localmente e nunca enviada para outros servidores.",
	"ABOUT_6": "3. O Aplicativo oferece simplicidade, interfaces de utilizador e experincias atrativas.",
	"ABOUT_7": "4. O Aplicativo requer que os utilizadores insiram informaes pessoais.",
	"ABOUT_8": "Vote bom-karma como testemunha",
	"ABOUT_9": "Contato/Comentrios",
	"ABOUT_10": "Mais informaes:",
	"REMOVE": "Remover",
	"MARKET_VIEW": "Viso do Mercado",
	"PRICE": "Preo",
	"AMOUNT": "Quantidade",
	"TOTAL": "Total",
	"NOORDERS": "Sem ordens abertas para",
	"DATE": "Data",
	"BUY": "Comprar",
	"SELL": "Vender",
	"OPEN": "Abrir",
	"HISTORY": "Hitrico",
	"FOLLOW_BACK": "Voltar a seguir",
	"FOLLOWED": "Seguido",
	"UNFOLLOW": "Deixar de seguir",
	"FOLLOWING": "Seguindo",
	"FOLLOWERS": "Seguidores",
	"SEARCH_FOLLOWERS": "Procurar seguidores",
	"SEARCH_FOLLOWING": "Procurar por quem estou a seguir",
	"BY": "por",
	"IN": "no",
	"MENU": "Menu",
	"BOOKMARK": "Favoritos",
	"REBLOG": "Repostar",
	"UPVOTE": "Voto positivo",
	"DOWNVOTE": "Voto negativo",
	"UNVOTE_DOWNVOTED": "Cancelar voto negativo",
	"UNVOTE_UPVOTED": "Cancelar voto positivo",
	"REPLY": "Responder",
	"EDIT": "Editar",
	"POST_1": "Deslize para esquerda nos comentrios para ver as opes",
	"POST_2": "Toque nos comentrios para ver os sub-comentrios",
	"OPTIONS": "Opes",
	"RESTEEMED_BY": "Repostado por",
	"NOTHING_HERE": "Nada por aqui, ainda...",
	"BALANCES": "Balano",
	"PROFILE_1": "{{platformname}}, provas transacionveis que podem ser transferidas em qualquer altura. {{platformname}} podem ser convertidas {{platformpower}} num processo chamado poder abaixo.",
	"PROFILE_2": "{{platformpower}}, tokens de influencia para ganhar mais poder para guardar a longo prazo e votar nas publicaes. Quanto mais se possui mais se pode influenciar as recompensas para outros e ganhar mais recompensas por votar.",
	"PROFILE_3": "Provas que valem cerca de {{platformsunit}} de {{platformname}}.",
	"ESTIMATED_VALUE": "Valor estimado",
	"PROFILE_4": "O valor estimado  baseado numa mdia do valor de 7 dias de {{platformname}}.",
	"TRANSACTION_HISTORY": "Histrico de Transao",
	"POSTING": "Publicando",
	"PROFILE_5": "A chave de publicao  usada para publicar e votar. Ela deve ser diferente da chave de ativao e da chave de proprietrio.",
	"OWNER": "Proprietrio",
	"PROFILE_6": "A chave de proprietrio  a chave mestra para conta e  exigida para mudar as outras chaves. Uma chave privada ou senha para a chave de proprietrio dever ser mantida offline assim que possvel.",
	"ACTIVE": "Ativo",
	"PROFILE_7": "A chave de ativao  usada para fazer transferncias e colocar ordens no mercado interno.",
	"MEMO": "Anotaes",
	"PROFILE_8": "A chave de anotaes  usada para criar e ler anotaes.",
	"BLOG": "Blogue",
	"POSTS": "Publicaes",
	"REPLIES": "Respostas",
	"WALLET": "Carteira",
	"TAG": "Etiqueta",
	"USER": "Utilizador",
	"CLOSE": "Fechado",
	"TO": "Para",
	"ASSET": "Ativo",
	"SEND": "Enviar",
	"SECURITY": "Segurana",
	"AVAILABLE": "Disponvel",
	"PUBLIC_MEMO": "Memorando Pblico",
	"TO_DESC": "Utilizador ex: good-karma",
	"PIN_CODE": "Cdigo Pin",
	"PIN_TEXT": "Cdigo Pin ajuda a assegurar o aplicativo e suas informaes. <br/><br/> Uma vez ativado, ter no mximo 4 tentativas para destravar, se esquecer o pin ou errar, o aplicativo ir remover suas informaes de utilizador. Pode entrar de novo e continuar a usar o aplicativo.",
	"NOTIFICATIONS": "Notificaes",
	"VOTE_TEXT": "Voc receber uma notificao quando algum votar no seu contedo! Notificaes tambm incluem peso de voto no alerta da mensagem.) seja voto positivo, voto negativo, voto nulo).",
	"VOTE": "Votar",
	"COMMENT_TEXT": "Recebe uma notificao quando algum comentar nas suas publicaes ou comentrios.<br/> Notificaes incluem quando algum edita os comentrios tambm.",
	"COMMENT": "Comentar",
	"FOLLOW_TEXT": "Recebe sempre uma notificao quando algum Seguir ou Deixar de segui-lo!",
	"MENTIONS": "Menes",
	"MENTIONS_TEXT": "Recebe sempre uma notificao quando algum o mencionar nalguma publicao ou comentrio!",
	"RESTEEM": "Repostar",
	"RESTEEM_TEXT": "Ir receber uma notificao quando algum partilhar a sua publicao!",
	"CONFIGURATIONS": "Configuraes",
	"VOTING": "Votando",
	"VOTING_TEXT": "O peso de voto ou percentagem afeta o poder de voto na app, por isso pode regular o seu recompensa de voto <br/><br/><b>Nota:</b> Isto ir modificar o peso/percentagem para votar para baixo tambm e em todo o lado na App",
	"SERVER": "Servidor",
	"SERVER_TEXT": "Recomendado",
	"SAVE_CHANGES": "Salvar mudanas",
	"VOTERS_INFO": "Informaes dos eleitores",
	"WELCOME_BACK": "Bem vindo de Volta!",
	"LOGIN_1": "Conecte-se com seu nome de utilizador e senha para continuar.",
	"LOGIN_2": "Chave de publicao  usada para publicar, comentar, votar, seguir.",
	"LOGIN_3": "Chave de ativao  usada para tranferncias e atualizao de fotos de perfil.",
	"LOGIN_4": "As credenciais do utilizador so guardadas localmente no seu aparelho. Depis de desligar as suas credenciais so removidas",
	"DONT_HAVE": "No possui conta?\n",
	"SIGN_UP_NOW": "Registe-se agora",
	"CANCEL": "Cancelar",
	"ADVANCED": "Avanado",
	"ACTIVE_PRIKEY": "Chave de ativao privada",
	"POSTING_PRIKEY": "Chave de publicao privada",
	"MASTER_PASS": "Senha Mestra/Principal",
	"USERNAME": "Utilizador",
	"CARD_VIEW": "Viso de Carto",
	"COMPACT_VIEW": "Vista compacta",
	"SEARCH": "Procurar",
	"SUBMIT_A_STORY": "Publicar uma histria",
	"REPLYTO": "Responder para",
	"POST": "Publicao",
	"PREVIEW": "Vizualizar",
	"DEFAULT": "Padro 50% / 50%",
	"POWERUP": "Fora Total 100%",
	"DECLINE_PAYOUT": "Recusar Pagamento",
	"SAVE_FOR_LATER": "Guardar pra mais tarde",
	"CLEAR": "Terminado",
	"POST_CONTENT": "Contedo da publicao",
	"COMMENT_CONTENT": "Contedo do comentrio",
	"TITLE": "Ttulo",
	"TAGS": "Etiquetas\nMarcadores",
	"NOT_MATCH": "No condiz",
	"CONFIRM_PIN": "Confirmar Pin",
	"INCORRECT": "Incorreto",
	"OPENING_POST": "Abrindo postagem",
	"SET_PIN": "Configure PIN",
	"ENTER_PIN": "Entrar com Pin",
	"ARE_YOU_SURE": "Tem a certeza?",
	"REBLOG_TEXT": "Republicar  irreversvel, quer mesmo continuar?",
	"BROADCAST_ERROR": "Erro de difuso, tente novamente!",
	"SUCCESS": "Sucesso",
	"REBLOGGED_POST": "Publicao republicada",
	"LOGIN_FAIL": "Login falhou! por favor certifique-se que est ligado com a senha master ou a chave publicao privada no Login se escolheu o modo avanado.",
	"LOGIN_FAIL_A": "Login falhou! por favor certifique-se que est conetado com a senha master ou a chave ativa privada no Login se escolheu o modo avanado.",
	"WARNING": "Cuidado",
	"VOTE_FOR_WITNESS": "Votando por uma Testemunha",
	"VOTED_FOR_WITNESS": "Votou por uma Testemunha",
	"AGO": "atrs",
	"FROM_NOW": "de agora",
	"SECS": "segs",
	"A_MIN": "um minuto",
	"MINS": "minutos",
	"AN_HOUR": "uma hora",
	"HOURS": "horas",
	"A_DAY": "um dia",
	"DAYS": "dias",
	"A_MONTH": "um ms",
	"MONTHS": "meses",
	"A_YEAR": "um ano",
	"YEARS": "anos",
	"MIN_READ": "ler min",
	"DOWNVOTE_FLAG": "Vote para baixo ou bandeira",
	"CAPTURE_PICTURE": "Capturar imagem",
	"SELECT_PICTURE": "Escolher uma imagem",
	"SET_CUSTOM_URL": "Configure URL costumizada",
	"INSERT_PICTURE": "Inserir uma imagem",
	"ERROR": "Erro",
	"UPLOAD_ERROR": "Erro no carregamento",
	"CAMERA_CANCELLED": "Camera cancelada",
	"SET_URL": "Configurarl URL",
	"DIRECT_LINK_PICTURE": "Link web direto para a imagem",
	"COMMENT_SUBMITTED": "Comentrio publicado!",
	"DELETE_COMMENT": "Apagar comentrios  irreversvel",
	"DELETED_COMMENT": "Comentrio apagado",
	"UPLOADING_PICTURE": "Carregando imagem",
	"UPLOAD_COMPLETED": "Carregamento completo",
	"UPLOAD_FAILED": "Carregamento falhou",
	"PASSWORD_INCORRECT": "A senha ou nome da conta so incorretos",
	"INFO": "Informaes",
	"QR_TEXT": "Ponha o cdigo QR dentro da rea de scan",
	"BALANCE_TEXT": "Certifique-se que possui saldo suficiente para a transao!",
	"NONEXIST_USER": "O utilizador para quem est a tentar transferir fundos, no existe",
	"TRANSFER_TEXT": "Tem certeza que quer transferir?",
	"CONFIRMATION": "Confirmao",
	"TX_BROADCASTED": "Transao foi difundida",
	"FEED": "Contedo de notcias",
	"TRENDING": "Tendencia",
	"HOT": "Quente",
	"NEW": "Novidades",
	"PROMOTED": "Promovidos",
	"VOTES": "Votos",
	"PAYOUT": "Pagamento",
	"COMMENTS": "Comentrios",
	"TRENDING_30": "Tendencia a 30 dias",
	"SORT_POST_BY": "Ordenar publicaes por:",
	"PAYOUT_CYCLE": "Ciclo de Pagamento",
	"POTENTIAL_PAYOUT": "Pagamento em potencial",
	"PAST_PAYOUT": "ltimo Pagamento",
	"AUTHOR_PAYOUT": "Pagamento do Autor",
	"CURATION_PAYOUT": "Pagamento de curadoria",
	"POST_SUBMITTED": "Publicao enviada!",
	"POST_LATER": "Publique para futura submisso",
	"SAVED": "Salvo",
	"CLEARED": "Limpo",
	"FLAGGING_TEXT": "Por uma bandeira numa publicao pode remover recompensas e tornar o material menos visivel.<br><br>A bandeira deve ser usada para : <ul><li>Fraude ou Plagiarismo</li><li>Discurso de dio ou Internet Trolling</li><li>Categorizao mal feita intencionalmente ou Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Limite de pedidos atingido. verifique outro assunto/etiqueta!",
	"POST_IS_UNBOOKMARK": "Publicao removida dos favoritos!",
	"POST_IS_BOOKMARK": "Publicao adicionada aos favoritos!",
	"RESET": "Reiniciar",
	"MODIFY_PICTURE": "Modificar a fotografia de perfil",
	"MODIFY_COVER_PICTURE": "Modificar fotografia da capa",
	"ACTIVE_KEY_REQUIRED_TEXT": "Por favor insira a chave de activao privada que escolheu, Modo de Login Avanado",
	"RESET_PICTURE_TEXT": "Isto reconfigura a imagem do perfil ultizador",
	"RESET_COVER_PICTURE_TEXT": "Isto reconfigura a imagem do ultizador",
	"UPDATE_REQUIRES_RESTART": "Atualizao do server obriga a Reiniciar!",
	"SETTINGS_UPDATED": "Configuraes foram atualizadas",
	"LANGUAGES": "Lngua",
	"LANGUAGES_TEXT": "Aqui pode mudar a lngua da App",
	"LOGIN_TO_X": "Esta operao obriga que o utilizador estaja ligado com a senha principal, chave activao/publicao",
	"GALLERY": "Galeria",
	"TRANSLATIONS": "Tradutores que contribuiram",
	"SHARE": "Partilhar",
	"MARKETPLACE": "Mercado",
	"EXCHANGE": "Cmbio",
	"DRAFTS": "Rascunhos",
	"POST_IS_UNDRAFT": "Publicao removida dos Rascunhos!",
	"POST_IS_DRAFT": "Puplicao adicionada a Rascunhos!",
	"SWIPE_LEFT": "Role para a esquerda para opes",
	"MANAGE": "Gerir",
	"IMAGE_REMOVED": "Imagem removida",
	"COPY": "Copiar",
	"NO_IMAGE": "No carregou nenhuma imagem, ainda",
	"PULL_DOWN_TO_REFRESH": "Carregue para refrescar",
	"EXTERNAL_APPS": "Apps Externas",
	"PLUGINS": "Mdulos de extenso",
	"SUGGEST": "Sugira",
	"COMING_SOON": "Brevemente",
	"CHAIN": "Corrente",
	"CHAIN_TEXT": "Aqui pode escolher blockchain ou a plataforma por defeito",
	"CURRENCY": "Moeda",
	"CURRENCY_TEXT": "Aqui pode alterar a sua unidade monetria padro. Ver o valor da recompensa do post/comentrio nessa moeda.",
	"ABOUT_11": "<br><b>Lista de funcionalidades</b><br>- Tenha acesso a artigos exclusivos sobre qualquer assunto que esteja interessado em ler.<br>- Envolva-se com os autores, comentando e discutindo os tpicos.<br>- Vote em posts para recompensar o autor, bem como para ganhar uma recompensa de curador.<br>- Publique os seus artigos e posts hospedando-os gratuitamente e ganhe recompensas por cativar e ganhar seguidores.<br>- Escreva artigos em movimento, salve mltiplos rascunhos do post para publicao posterior.<br>- Adicione artigos aos seus favoritos para ler mais tarde.<br>- Cambie ou recolha os seus ganhos.<br>- Envie os seus fundos para quaisquer autores ou usurios, amigos, seguidores, etc.<br>- Siga autores interessantes, bloggers<br>-. Procure os seguidores e autores que segue.<br>- Receba notificaes para se manter em contacto com os seus seguidores e discusses em que se encontre envolvido.<br>- Procure por marcadores/categorias interessantes de artigos, autores.<br>- Personalize o seu perfil.<br>- Muitas mais funcionalidades a caminho.<br><br><br>Segurana</b><br>1. A aplicao nunca acede ou retm fundos do usurio.<br>2. A aplicao oferece um modelo de segurana que privilegia o cliente, com chaves privadas hospedadas localmente e nunca enviadas para qualquer servidor, voc  responsvel por fazer uma cpia de segurana das suas senhas.<br>3. A aplicao oferece experincias e interfaces de usurio, simples e atraentes.<br>4. A aplicao oferece um nvel extra de segurana atravs do cdigo Pin<br><br>O eSteem apoia as plataformas Steem e Golos.<br>",
	"FOUNDER": "Fundador e desenvolvedor principal",
	"ADD_ACCOUNT": "Adicionar conta",
	"PLATFORM": "Plataforma",
	"ESCROW": "Compromisso",
	"ESCROW_AGENT": "Agente depositrio",
	"RATIFICATION_DEADLINE": "Prazo de ratificao",
	"ESCROW_EXPIRATION": "Vencimento do compromisso",
	"ESCROW_FEE": "Taxa de depsito",
	"ESCROW_TERMS": "Termos do compromisso",
	"NIGHT_MODE": "Modo nocturno",
	"DAY_MODE": "Modo diurno",
	"VIEW_CONTEXT": "Ver o contexto completo",
	"USER_NOTFOUND": "Utilizador no encontrado",
	"APPROVE": "Aprovar",
	"DISPUTE": "Disputa",
	"RELEASE": "Lanamento",
	"FROM": "De",
	"ID": "identificao",
	"SUBMIT": "Submeter",
	"RECEIVER": "Destinatrio",
	"LOCATION": "Localizao",
	"WEBSITE": "Website",
	"DISPLAY_NAME": "Nome a exibir"
}
},{}],125:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": " ",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ",
	"ABOUT_1": "       !",
	"ABOUT_2": "   {{platformname}}.  ",
	"ABOUT_3": "         .       , ,   ,       ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "1.            ;",
	"ABOUT_5": "2.       ,          ;",
	"ABOUT_6": "3.       ;",
	"ABOUT_7": "4.       -  .",
	"ABOUT_8": "   good-karma",
	"ABOUT_9": "/ :",
	"ABOUT_10": " :",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": " ",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ,   ",
	"POST_2": "  ,    ",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "   ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},   ,       . {{platformname}}     {{platformpower}},     {{platformname}}-.",
	"PROFILE_2": "{{platformpower}},   ,          .     ,                  .",
	"PROFILE_3": "   {{platformsunit}}  {{platformname}} .",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7-   {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "      .         .",
	"OWNER": "",
	"PROFILE_6": "            .          ,   .",
	"ACTIVE": "",
	"PROFILE_7": "           .",
	"MEMO": "",
	"PROFILE_8": "        .",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " ",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "PIN-",
	"PIN_TEXT": "PIN-       . <br/><br/><b>:</b>  ,     4   ,    PIN-     ,       .         .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,       ! <br/><b>:</b>       (   ,  ,  ).",
	"VOTE": "",
	"COMMENT_TEXT": "  ,  -     !<br/> <b>:</b>    ,  - <b></b>  .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,  -     !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,  -     /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,  -    !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "         ,        . <br/><br/><b>:</b>      ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": " ,       .",
	"LOGIN_2": "     , ,   .",
	"LOGIN_3": "          .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": " ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": " ",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "  ",
	"MASTER_PASS": "/ ",
	"USERNAME": " ",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": " ",
	"POST": "",
	"PREVIEW": " ",
	"DEFAULT": "  50% / 50%",
	"POWERUP": " 100%  {{platformpower}}",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "   ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN-",
	"INCORRECT": "",
	"OPENING_POST": " ",
	"SET_PIN": " PIN-",
	"ENTER_PIN": " PIN-",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "  ,   ?",
	"BROADCAST_ERROR": "  ,   !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": " ! , ,                    .",
	"LOGIN_FAIL_A": " ! , ,                    .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "  ",
	"SECS": "",
	"A_MIN": "",
	"MINS": "()",
	"AN_HOUR": "",
	"HOURS": "()",
	"A_DAY": "",
	"DAYS": "()",
	"A_MONTH": "",
	"MONTHS": "()",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": " ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": "  URL",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": "  ",
	"SET_URL": " ",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "   ",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "    ",
	"INFO": "",
	"QR_TEXT": " QR    ",
	"BALANCE_TEXT": "       !",
	"NONEXIST_USER": ",     ,  !",
	"TRANSFER_TEXT": "      ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "  ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": "  :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "  ,          .<br><br>      : <ul><li>  </li><li>   </li><li>     </li></ul>",
	"REQUEST_LIMIT_TEXT": "  .   /!",
	"POST_IS_UNBOOKMARK": "   !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": ",    ,      !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     .",
	"LOGIN_TO_X": "        , / . ,    .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "   !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": "     ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "      !",
	"PULL_DOWN_TO_REFRESH": " ,  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       ().",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .   /     .",
	"ABOUT_11": "<br><b> </b><br>-          ;<br>-   ,     ;<br>-   ,   ,     ;<br>-       ,      ;<br>-    ,       ,   ;<br>-     ,     ;<br>-     ;<br>-    , , ,   ..;<br>-      ;<br>-       ,    ;<br>-   -           ,   ;<br>-      ,    /;<br>-    ;<br>-    -        !<br><br><b></b><br>1.         ;<br>2.       ,              -       ;<br>3.      ,      ;<br>4.         -.<br><br>eSteem   Steem  Golos.<br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "",
	"ESCROW_AGENT": "",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": " ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "-",
	"DISPLAY_NAME": " "
}
},{}],126:[function(require,module,exports){
module.exports={
	"HOME": "Hem",
	"LOGIN": "Logga in",
	"LOGOUT": "Logga ut",
	"PROFILE": "Profil",
	"FOLLOW": "Flj",
	"BOOKMARKS": "Bokmrken",
	"TRANSFER": "verfring",
	"MARKET": "Marknad",
	"SETTINGS": "Instllningar",
	"ABOUT": "Om",
	"ABOUT_1": "dr vem som helst kan belnas fr sitt material!",
	"ABOUT_2": "r en social mediaplatform dr du betalas fr att blogga, kommentera och kurrera inlgg.",
	"ABOUT_3": "och r ett community-drivet projekt fr mobilen som baseras p ppen kllkod. Den ger ger dig tillgng s att du kan lsa innehll, kommentera, rsta, skapa inlgg och fra ver belningar, och diverse andra funktioner som grs mjliga av {{platformname}} block-kedja och {{sitename}}.",
	"ABOUT_4": "Appen har aldrig tillgng till anvndarens pengar.",
	"ABOUT_5": "Appen erbjuder en klientcentrerad skerhetsmodell, dvs. dina privata nycklar stannar lokalt och skickas inte till andra servrar.",
	"ABOUT_6": "Appen erbjuder ett enkelt och attraktivt anvndergrnssnitt, vilket ger en god anvndarupplevelse.",
	"ABOUT_7": "Appen krver aldrig att anvndaren matar in personlig information.",
	"ABOUT_8": "Rsta p good-karma som vittne",
	"ABOUT_9": "Kontakt/terkoppling",
	"ABOUT_10": "Mera information:",
	"REMOVE": "Ta bort",
	"MARKET_VIEW": "Marknadsvy",
	"PRICE": "Pris",
	"AMOUNT": "Mngd",
	"TOTAL": "Summa",
	"NOORDERS": "Inga aktiva ordrar fr",
	"DATE": "Datum",
	"BUY": "Kp",
	"SELL": "Slj",
	"OPEN": "ppen",
	"HISTORY": "Historik",
	"FOLLOW_BACK": "Flj tillbaka",
	"FOLLOWED": "Fljer",
	"UNFOLLOW": "Sluta flja",
	"FOLLOWING": "Fljer",
	"FOLLOWERS": "Fljare",
	"SEARCH_FOLLOWERS": "Sk bland fljare",
	"SEARCH_FOLLOWING": "Sk bland de du fljer",
	"BY": "av",
	"IN": "i",
	"MENU": "Meny",
	"BOOKMARK": "Bokmrk",
	"REBLOG": "terblogga",
	"UPVOTE": "Rsta upp",
	"DOWNVOTE": "Rsta ner",
	"UNVOTE_DOWNVOTED": "ngra rsta ner",
	"UNVOTE_UPVOTED": "ngra rsta upp",
	"REPLY": "Svara",
	"EDIT": "Redigera",
	"POST_1": "Svep t vnster ver kommentarer fr att se alternativ",
	"POST_2": "Dutta p kommentarer fr att se underkommentarer",
	"OPTIONS": "Alternativ",
	"RESTEEMED_BY": "tersteemades av",
	"NOTHING_HERE": "Tomt n s lnge...",
	"BALANCES": "Saldon",
	"PROFILE_1": "Steem, utbytsbara polletter som gr att verfra nr som helst. Steem kan omvandlas till SteemPower i en process som kallas att ka rsteffekt eller \"nga upp\".",
	"PROFILE_2": "SteemPower, inflytandepolletter som ger hgre rsteffekt fr att du sparar dem lngsiktigt och rstar p inlgg. Ju mer du har, desto mer kan du pverka andras belningar och belnas fr smart rstning.",
	"PROFILE_3": "Polletter vrda ungefr {{platformsunit}} av {{platformname}.",
	"ESTIMATED_VALUE": "Uppskattat vrde",
	"PROFILE_4": "Det uppskattade vrdet r baserat p ett 7 dagars genomsnittlig vrde av {{platformname}.",
	"TRANSACTION_HISTORY": "Transaktionshistorik",
	"POSTING": "Inlgg",
	"PROFILE_5": "Inlggsnyckeln anvnds fr att skriva inlgg och rsta. Den br vara olik allmnnyckeln och huvudnyckeln.",
	"OWNER": "gare",
	"PROFILE_6": "garnyckeln r huvudnyckeln fr kontot och behvs fr att kunna byta de andra nycklarna. Fr att ka skerheten br den \"privata nyckeln\" eller lsenordet till huvudnyckeln anvndas s lite som mjligt.",
	"ACTIVE": "Rrelse",
	"PROFILE_7": "Allmnnyckeln anvnds fr att gra verfringar och att lgga ordrar i den interna marknaden.",
	"MEMO": "Anteckning",
	"PROFILE_8": "Anteckningsnyckeln anvnds fr att skapa och lsa anteckningar.",
	"BLOG": "Blogg",
	"POSTS": "Inlgg",
	"REPLIES": "Svar",
	"WALLET": "Plnbok",
	"TAG": "mne",
	"USER": "Anvndare",
	"CLOSE": "Stng",
	"TO": "Till",
	"ASSET": "Tillgng",
	"SEND": "Skicka",
	"SECURITY": "Skerhet",
	"AVAILABLE": "Tillgnglig",
	"PUBLIC_MEMO": "Offentlig anteckning",
	"TO_DESC": "Anvndare t.ex. good-karma",
	"PIN_CODE": "Pinkod",
	"PIN_TEXT": "Pinkoden hjlper dig att skra appen och din data. Nr den aktiveras har du max 4 frsk att lsa upp appen. Om du har glmt den eller misslyckas kommer appen att ta bort inloggad anvndardata. Du mste d logga in p nytt fr att fortstta anvnda appen.",
	"NOTIFICATIONS": "Meddelanden",
	"VOTE_TEXT": "Du kommer f ett meddelande nr ngon rstar upp ditt inlgg. Meddelanden talar ven om den valda rstvikten. (oavsett upprstning, nedrstning, av/omrstning).",
	"VOTE": "Rsta",
	"COMMENT_TEXT": "Du kommer f ett meddelande nr ngon kommenterar p ditt inlgg eller kommentar. Meddelanden inkluderar ven nr ngon redigerar sin kommentar.",
	"COMMENT": "Kommentar",
	"FOLLOW_TEXT": "Du kommer f ett meddelande nr ngon fljer eller slutar flja dig.",
	"MENTIONS": "Omnmnande",
	"MENTIONS_TEXT": "Du kommer f ett meddelande nr ngon nmnar ditt namn i deras inlgg/kommentar!",
	"RESTEEM": "terblogga",
	"RESTEEM_TEXT": "Du kommer f ett meddelande nr ngon terbloggar ditt inlgg!",
	"CONFIGURATIONS": "Instllningar",
	"VOTING": "Rstning",
	"VOTING_TEXT": "Rstningsvikt eller procent pverkar rstningskraften p appen s att du kan reglera hur mycket du vill belna inlgg. Detta ndrar ocks p rstningsvikten/procenten fr nedrstningar och gller verallt p appen.",
	"SERVER": "Server",
	"SERVER_TEXT": "Rekommenderas",
	"SAVE_CHANGES": "Spara ndringar",
	"VOTERS_INFO": "Rstarens information",
	"WELCOME_BACK": "Vlkommen tillbaka!",
	"LOGIN_1": "Logga in med ditt anvndarnamn och lsenord fr att fortstta.",
	"LOGIN_2": "Inlggsnyckeln anvnds fr att gra inlgg, kommentera, rst, flja.",
	"LOGIN_3": "Allmnnyckeln anvnds fr att gra verfringar och att uppdatera profilbild.",
	"LOGIN_4": "Anvndaruppgifter lagras lokalt p enheten. Vid utloggning avlgsnas uppgifterna!",
	"DONT_HAVE": "Har du inget konto?",
	"SIGN_UP_NOW": "Registrera dig nu",
	"CANCEL": "Avbryt",
	"ADVANCED": "Avancerat lge",
	"ACTIVE_PRIKEY": "Privat allmnnyckel",
	"POSTING_PRIKEY": "Privat inlggsnyckel",
	"MASTER_PASS": "gare/huvudlsenord",
	"USERNAME": "Anvndarnamn",
	"CARD_VIEW": "Kortvy",
	"COMPACT_VIEW": "Kompakt vy",
	"SEARCH": "Sk",
	"SUBMIT_A_STORY": "Gr ett inlgg",
	"REPLYTO": "Svara",
	"POST": "Skicka",
	"PREVIEW": "Frhandsgranska",
	"DEFAULT": "Normal 50% / 50%",
	"POWERUP": "nga upp 100%",
	"DECLINE_PAYOUT": "Avsg dig belning",
	"SAVE_FOR_LATER": "SPARA TILL SENARE",
	"CLEAR": "TM",
	"POST_CONTENT": "Skriv inlgg",
	"COMMENT_CONTENT": "Kommentera material",
	"TITLE": "Titel",
	"TAGS": "mnen",
	"NOT_MATCH": "MATCHAR INTE",
	"CONFIRM_PIN": "Bekrfta pinkod",
	"INCORRECT": "FELAKTIG",
	"OPENING_POST": "ppnar inlgg",
	"SET_PIN": "Stll in pinkod",
	"ENTER_PIN": "Ange pinkod",
	"ARE_YOU_SURE": "r du sker?",
	"REBLOG_TEXT": "terbloggade inlgg kan inte ngras, vill du fortstta?",
	"BROADCAST_ERROR": "Sndningsfel, frsk igen!",
	"SUCCESS": "Utfrt",
	"REBLOGGED_POST": "terbloggade inlgg!",
	"LOGIN_FAIL": "Inloggning misslyckades! Var god skerstll att du loggar in med huvudlsenord eller din privata inlggsnyckel om du valt \"Avancerat lge\".",
	"LOGIN_FAIL_A": "Inloggning misslyckades! Var god skerstll att du loggar in med huvudlsenord eller din privata rrelsenyckel om du valt \"Avancerat lge\".",
	"WARNING": "Varning",
	"VOTE_FOR_WITNESS": "Rsta p vittne",
	"VOTED_FOR_WITNESS": "Rstade p vittnet",
	"AGO": "sedan",
	"FROM_NOW": "frn och med nu",
	"SECS": "sek",
	"A_MIN": "en minut",
	"MINS": "min",
	"AN_HOUR": "en timme",
	"HOURS": "timmar",
	"A_DAY": "en dag",
	"DAYS": "dagar",
	"A_MONTH": "en mnad",
	"MONTHS": "mnader",
	"A_YEAR": "ett r",
	"YEARS": "r",
	"MIN_READ": "min lsning",
	"DOWNVOTE_FLAG": "Rsta Ner",
	"CAPTURE_PICTURE": "Ta Foto",
	"SELECT_PICTURE": "Vlj Bild",
	"SET_CUSTOM_URL": "Stll in egen URL",
	"INSERT_PICTURE": "Infoga Bild",
	"ERROR": "Fel",
	"UPLOAD_ERROR": "Uppladdningsfel",
	"CAMERA_CANCELLED": "Kamera Avbruten",
	"SET_URL": "Stll in URL",
	"DIRECT_LINK_PICTURE": "Direkt webblnk fr bild",
	"COMMENT_SUBMITTED": "Kommentaren r skickad!",
	"DELETE_COMMENT": "Borttagning av kommentarer gr inte att ngra...",
	"DELETED_COMMENT": "Tog bort kommentaren",
	"UPLOADING_PICTURE": "Laddar upp bild",
	"UPLOAD_COMPLETED": "Uppladdning Slutfrd",
	"UPLOAD_FAILED": "Uppladdning Misslyckades",
	"PASSWORD_INCORRECT": "Lsenordet eller kontonamnet var felaktigt",
	"INFO": "Info",
	"QR_TEXT": "Placera QR-kod innanfr skanningsomrdet",
	"BALANCE_TEXT": "Se till att du har tillrckligt saldo fr transaktionen!",
	"NONEXIST_USER": "Anvndaren du frsker verfra till existerar inte!",
	"TRANSFER_TEXT": "r du sker att du vill fra ver?",
	"CONFIRMATION": "Bekrftelse",
	"TX_BROADCASTED": "verfring sndes",
	"FEED": "Flde",
	"TRENDING": "Trendande",
	"HOT": "Hett",
	"NEW": "Nytt",
	"PROMOTED": "Marknadsfrt",
	"VOTES": "Rster",
	"PAYOUT": "Utbetalning",
	"COMMENTS": "Kommentarer",
	"TRENDING_30": "Trendande fr 30 dagar",
	"SORT_POST_BY": "Sortera inlgg efter",
	"PAYOUT_CYCLE": "Utbetalningsperiod",
	"POTENTIAL_PAYOUT": "Potentiell Utbetalning",
	"PAST_PAYOUT": "Tidigare Utbetalning",
	"AUTHOR_PAYOUT": "Skribents Utbetalning",
	"CURATION_PAYOUT": "Kuratorers Utbetalning",
	"POST_SUBMITTED": "Inlgget r publicerat!",
	"POST_LATER": "Inlgg fr senare publicering!",
	"SAVED": "Sparat",
	"CLEARED": "Tmt",
	"FLAGGING_TEXT": "Att rsta ner ett inlgg kan ta bort belning och gra inlgget mindre synligt.<br><br> Nedrsten br anvndas fr fljande: <ul><li>Bedrger eller Plagiat</li><li>Hets eller Trolling</li><li>Medvetet felkategoriserat innehll eller Spam</li></ul>",
	"REQUEST_LIMIT_TEXT": "Slut p fldet ntt. Kolla in andra trender/mnestaggar!",
	"POST_IS_UNBOOKMARK": "Inlgget har tagits bort frn bokmrken!",
	"POST_IS_BOOKMARK": "Inlgget har lagts till i bokmrken!",
	"RESET": "terstll",
	"MODIFY_PICTURE": "Modifiera profilbild",
	"MODIFY_COVER_PICTURE": "Modifiera uppslagsbild",
	"ACTIVE_KEY_REQUIRED_TEXT": "Var god ange den privata rrelsenyckeln om du har valt Avancerat lge!",
	"RESET_PICTURE_TEXT": "Det hr terstller profilbild",
	"RESET_COVER_PICTURE_TEXT": "Det hr terstller uppslagsbild",
	"UPDATE_REQUIRES_RESTART": "Serveruppdatering krver omstart!",
	"SETTINGS_UPDATED": "Instllningar har uppdaterats!",
	"LANGUAGES": "Sprk",
	"LANGUAGES_TEXT": "Hr kan du vlja det sprk som appen anvnder.",
	"LOGIN_TO_X": "Den hr operationen krver att anvndaren r inloggad med lsenord, allmnnyckel/inlggsnyckel. Var god logga in och frsk igen.",
	"GALLERY": "Galleri",
	"TRANSLATIONS": "Bidragande versttare",
	"SHARE": "Dela",
	"MARKETPLACE": "Marknadsplats",
	"EXCHANGE": "Brs",
	"DRAFTS": "Utskick",
	"POST_IS_UNDRAFT": "Inlgg har tagits bort frn utskick!",
	"POST_IS_DRAFT": "Inlgg har lagts till i utskick!",
	"SWIPE_LEFT": "Dra t vnster fr att se alternativ",
	"MANAGE": "Hantera",
	"IMAGE_REMOVED": "Bilden r borttagen",
	"COPY": "Kopiera",
	"NO_IMAGE": "Du har inte laddat upp ngon bild nnu!",
	"PULL_DOWN_TO_REFRESH": "Dra ner fr att uppdatera",
	"EXTERNAL_APPS": "Externa appar",
	"PLUGINS": "Plugin",
	"SUGGEST": "Frslag",
	"COMING_SOON": "Kommer snart",
	"CHAIN": "Kedja",
	"CHAIN_TEXT": "Hr kan du ndra blockkedja eller frvald plattform.",
	"CURRENCY": "Valuta",
	"CURRENCY_TEXT": "Hr kan du ndra din standardvaluta. Det r den valuta som belningar fr inlgg/kommentarer kommer att visas i.",
	"ABOUT_11": "<br><b>Lista ver funktioner</b><br>- Tillgng till artiklar i mnen som intresserar dig.<br>- Interagera med skribenter genom att kommentera, diskutera mnen.<br>- Rsta p inlgg fr at belna skribenter och tjna kureringsbelningar.<br>- Publicera dina artiklar, blogginlgg och gr dem tillgnliga fr andra helt gratis, samt tjna belningar genom att engagera och f fljare.<br>- Skriv artiklar p stende ft, spara flera utkast av dina inlgg fr senare publicering.<br>- Bokmrk favortinlgg fr att lsa senare.<br>- Handla med eller ta ut dina belningar.<br>- Gr transaktioner till valfri anvndare, vn, fljare, etc.<br>- Flj intressanta skribenter, bloggare.<br>- Sk bland dina fljare och skribenter du fljer.<br>- F meddelande s att du kan hlla kontakten med dina fljare och ha koll p de diskussioner du deltar i.<br>- Sk efter intressanta mnen/artikelkategorier, skribenter.<br>- Gr din profil mer personlig.<br>- Mnga fler funktioner p vg<br><br><b>Skerhet</b><br>1. Appen har fr aldrig tillgng till eller kontroll ver dina pengar.<br>2. Appens skerhetsmodell r klientcentrerad, med privata nycklar sparade lokalt och aldrig skickade till ngra andra servrar, du r sjlv ansvarig fr att skerhetskopiera dina lsenord.<br>3. Appen erbjuder ett enkelt, attraktivt anvndargrnssnitt och anvndarupplevelse.<br>4. Appen erbjuder extra skerhet med pin-kod<br><br>eSteem stdjer Steem- och Golos- plattformarna.<br>",
	"FOUNDER": "Grundare och Lead Developer",
	"ADD_ACCOUNT": "Lgg till konto",
	"PLATFORM": "Plattform",
	"ESCROW_AGENT": "Escrow agent",
	"RATIFICATION_DEADLINE": "Ratificeringen tidsfristen",
	"ESCROW_EXPIRATION": "Escrow frfallodatum",
	"ESCROW_FEE": "Escrow avgift",
	"ESCROW_TERMS": "Escrow villkor"
}
},{}],127:[function(require,module,exports){
module.exports={
	"HOME": " ",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": " ",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": " ...",
	"ABOUT_1": "       !",
	"ABOUT_2": "  ,      ,   .",
	"ABOUT_3": "       .       , , , ,       ,   {{platformname}}   {{sitename}}.",
	"ABOUT_4": "          .",
	"ABOUT_5": "  -  .              .",
	"ABOUT_6": "3.   ,     .",
	"ABOUT_7": "        .",
	"ABOUT_8": "  good-karma   ",
	"ABOUT_9": "/ '",
	"ABOUT_10": " ",
	"REMOVE": "",
	"MARKET_VIEW": " ",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "   ",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "  ",
	"UNFOLLOW": " ",
	"FOLLOWING": " ",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": " ",
	"SEARCH_FOLLOWING": " ",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": " ",
	"DOWNVOTE": " ",
	"UNVOTE_DOWNVOTED": "  ",
	"UNVOTE_UPVOTED": "  ",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "    ,   ",
	"POST_2": "  ,    ",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": " ,  ...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}},  ,     - . {{platformname}}    {{platformpower}}  ,    \"\".",
	"PROFILE_2": "{{platformpower}},  ,            .     ,        ,      .",
	"PROFILE_3": "   {{platformsunit}} {{platformname}}.",
	"ESTIMATED_VALUE": " ",
	"PROFILE_4": "    7-   {{platformname}}.",
	"TRANSACTION_HISTORY": " ",
	"POSTING": "",
	"PROFILE_5": "-     .         .",
	"OWNER": "",
	"PROFILE_6": "   -         .            .",
	"ACTIVE": "",
	"PROFILE_7": "    ,         .",
	"MEMO": "'",
	"PROFILE_8": "'       '.",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": " '",
	"TO_DESC": ",  good-karma",
	"PIN_CODE": "PIN-",
	"PIN_TEXT": "PIN-       . <br/> <br/> <b>:</b>       4 ,  .    -     ,    ,    .        .",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "  ,      ! <br/> <b>:</b>         (   ,  ,  ).",
	"VOTE": "",
	"COMMENT_TEXT": "  ,       ! <br/> <b>:</b>     ,   <b></b>   .",
	"COMMENT": "",
	"FOLLOW_TEXT": "  ,          !",
	"MENTIONS": "",
	"MENTIONS_TEXT": "  ,       /!",
	"RESTEEM": "",
	"RESTEEM_TEXT": "  ,      !",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "         ,        . <br/> <br/> <b>:</b>     /   ,    ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": " ",
	"VOTERS_INFO": "  ,  ",
	"WELCOME_BACK": " !",
	"LOGIN_1": " ,        .",
	"LOGIN_2": "-     , , , .",
	"LOGIN_3": "        .",
	"LOGIN_4": "      .      !",
	"DONT_HAVE": "  ?",
	"SIGN_UP_NOW": " ",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "  ",
	"POSTING_PRIKEY": "-",
	"MASTER_PASS": "/ ",
	"USERNAME": "' ",
	"CARD_VIEW": "  ",
	"COMPACT_VIEW": " ",
	"SEARCH": "",
	"SUBMIT_A_STORY": " ",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": "  50% / 50%",
	"POWERUP": "   100%",
	"DECLINE_PAYOUT": "  ",
	"SAVE_FOR_LATER": "  ",
	"CLEAR": "",
	"POST_CONTENT": " ",
	"COMMENT_CONTENT": " ",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": " ",
	"CONFIRM_PIN": " PIN-",
	"INCORRECT": " ",
	"OPENING_POST": " ",
	"SET_PIN": " PIN-",
	"ENTER_PIN": " PIN-",
	"ARE_YOU_SURE": " ?",
	"REBLOG_TEXT": "  ,   ?",
	"BROADCAST_ERROR": " ,   !",
	"SUCCESS": "",
	"REBLOGGED_POST": " !",
	"LOGIN_FAIL": "  !  , ,     -    -       .",
	"LOGIN_FAIL_A": "  !  , ,     -            .",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "  ",
	"VOTED_FOR_WITNESS": "  ",
	"AGO": "",
	"FROM_NOW": "  ",
	"SECS": "",
	"A_MIN": "",
	"MINS": ".",
	"AN_HOUR": ".",
	"HOURS": ".",
	"A_DAY": "",
	"DAYS": "()",
	"A_MONTH": "",
	"MONTHS": "()",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": ". ",
	"DOWNVOTE_FLAG": "   ",
	"CAPTURE_PICTURE": " ",
	"SELECT_PICTURE": " ",
	"SET_CUSTOM_URL": " URL ",
	"INSERT_PICTURE": " ",
	"ERROR": "",
	"UPLOAD_ERROR": "  ",
	"CAMERA_CANCELLED": " ",
	"SET_URL": " URL",
	"DIRECT_LINK_PICTURE": "   ",
	"COMMENT_SUBMITTED": " !",
	"DELETE_COMMENT": "   ...",
	"DELETED_COMMENT": " ",
	"UPLOADING_PICTURE": " ",
	"UPLOAD_COMPLETED": " ",
	"UPLOAD_FAILED": "  ",
	"PASSWORD_INCORRECT": "   ' ",
	"INFO": "",
	"QR_TEXT": " QR-   ",
	"BALANCE_TEXT": ",       !",
	"NONEXIST_USER": ",     ,  !",
	"TRANSFER_TEXT": "    ?",
	"CONFIRMATION": "",
	"TX_BROADCASTED": " ",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "  30 ",
	"SORT_POST_BY": " :",
	"PAYOUT_CYCLE": " ",
	"POTENTIAL_PAYOUT": " ",
	"PAST_PAYOUT": " ",
	"AUTHOR_PAYOUT": " ",
	"CURATION_PAYOUT": " ",
	"POST_SUBMITTED": " !",
	"POST_LATER": "   !",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "           . <br><br>     : <ul><li>  </li> <li>   </li> <li>       </li></ul>",
	"REQUEST_LIMIT_TEXT": "  .   /!",
	"POST_IS_UNBOOKMARK": "   !",
	"POST_IS_BOOKMARK": "   !",
	"RESET": "",
	"MODIFY_PICTURE": "  ",
	"MODIFY_COVER_PICTURE": "  ",
	"ACTIVE_KEY_REQUIRED_TEXT": " ,    ,      !",
	"RESET_PICTURE_TEXT": "      ",
	"RESET_COVER_PICTURE_TEXT": "      ",
	"UPDATE_REQUIRES_RESTART": "   !",
	"SETTINGS_UPDATED": " !",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "     .",
	"LOGIN_TO_X": "        , / .  ,      .",
	"GALLERY": "",
	"TRANSLATIONS": " ",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "   !",
	"POST_IS_DRAFT": "   !",
	"SWIPE_LEFT": " ,   ",
	"MANAGE": "",
	"IMAGE_REMOVED": " ",
	"COPY": "",
	"NO_IMAGE": "     !",
	"PULL_DOWN_TO_REFRESH": " ,  ",
	"EXTERNAL_APPS": " ",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "       .",
	"CURRENCY": "",
	"CURRENCY_TEXT": "      .   /     .",
	"ABOUT_11": "<br><b></b> <br>-      -    . <br> -  ,    . <br>  ,   ,     . <br>  ,       ,      . <br>   ,            . <br>        . <br>      . <br>  -   , ,   <br>   , . <br> -     ,    . <br> ,    '       ,      <br>    / , . <br> -  . <br>     . <br><br><b></b> <br>1.         . <br>2.   - ,           - ,       . <br>3.   ,       . <br>4.         pin-. <br><br> eSteem   Steem  Golos. <br>",
	"FOUNDER": "   ",
	"ADD_ACCOUNT": " ",
	"PLATFORM": "",
	"ESCROW": "Escrow",
	"ESCROW_AGENT": " ",
	"RATIFICATION_DEADLINE": "  ",
	"ESCROW_EXPIRATION": "  ",
	"ESCROW_FEE": "  ",
	"ESCROW_TERMS": " ",
	"NIGHT_MODE": " ",
	"DAY_MODE": " ",
	"VIEW_CONTEXT": "  ",
	"USER_NOTFOUND": "  ",
	"APPROVE": "",
	"DISPUTE": "",
	"RELEASE": "",
	"FROM": "",
	"ID": "ID",
	"SUBMIT": "",
	"RECEIVER": "",
	"LOCATION": "",
	"WEBSITE": "-",
	"DISPLAY_NAME": " '"
}
},{}],128:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "",
	"ABOUT_2": "{{platformname}}",
	"ABOUT_3": "{{platformname}}{{sitename}}",
	"ABOUT_4": "1.",
	"ABOUT_5": "2. ",
	"ABOUT_6": "3.",
	"ABOUT_7": "4.",
	"ABOUT_8": " good-karma ",
	"ABOUT_9": "/",
	"ABOUT_10": "",
	"REMOVE": "",
	"MARKET_VIEW": "",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "",
	"SEARCH_FOLLOWING": "",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": "",
	"UNVOTE_UPVOTED": "",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "",
	"POST_2": "",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "...",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}}, . {{platformname}} {{platformpower}}",
	"PROFILE_2": "{{platformpower}}, ",
	"PROFILE_3": "{{platformsunit}} {{platformname}}",
	"ESTIMATED_VALUE": "",
	"PROFILE_4": "{{platformname}}7",
	"TRANSACTION_HISTORY": "",
	"POSTING": "",
	"PROFILE_5": "",
	"OWNER": "",
	"PROFILE_6": "",
	"ACTIVE": "",
	"PROFILE_7": "",
	"MEMO": "",
	"PROFILE_8": "",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": " (:good-karma)",
	"PIN_CODE": "Pin ",
	"PIN_TEXT": "PIN<br/><br/><b>:</b>4",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "<br/> <b>:</b>  (, , ). ",
	"VOTE": "",
	"COMMENT_TEXT": "<b>:</b> <b></b>. ",
	"COMMENT": "",
	"FOLLOW_TEXT": "",
	"MENTIONS": "",
	"MENTIONS_TEXT": "",
	"RESTEEM": "",
	"RESTEEM_TEXT": "",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "APP<br/><br/><b>:</b> /APP.",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "",
	"WELCOME_BACK": "",
	"LOGIN_1": "",
	"LOGIN_2": "",
	"LOGIN_3": "",
	"LOGIN_4": "",
	"DONT_HAVE": "",
	"SIGN_UP_NOW": "",
	"CANCEL": "",
	"ADVANCED": "",
	"ACTIVE_PRIKEY": "",
	"POSTING_PRIKEY": "",
	"MASTER_PASS": "",
	"USERNAME": "",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": "",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"POWERUP": "100% ",
	"DECLINE_PAYOUT": "",
	"SAVE_FOR_LATER": "",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": "",
	"CONFIRM_PIN": " PIN",
	"INCORRECT": "",
	"OPENING_POST": "",
	"SET_PIN": " PIN",
	"ENTER_PIN": " PIN",
	"ARE_YOU_SURE": "",
	"REBLOG_TEXT": "",
	"BROADCAST_ERROR": "",
	"SUCCESS": "",
	"REBLOGGED_POST": "",
	"LOGIN_FAIL": "",
	"LOGIN_FAIL_A": "",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "",
	"VOTED_FOR_WITNESS": "",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "",
	"DOWNVOTE_FLAG": "",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": "",
	"SET_CUSTOM_URL": "URL",
	"INSERT_PICTURE": "",
	"ERROR": "",
	"UPLOAD_ERROR": "",
	"CAMERA_CANCELLED": "",
	"SET_URL": "URL",
	"DIRECT_LINK_PICTURE": "",
	"COMMENT_SUBMITTED": "",
	"DELETE_COMMENT": "...",
	"DELETED_COMMENT": "",
	"UPLOADING_PICTURE": "",
	"UPLOAD_COMPLETED": "",
	"UPLOAD_FAILED": "",
	"PASSWORD_INCORRECT": "",
	"INFO": "",
	"QR_TEXT": "",
	"BALANCE_TEXT": "",
	"NONEXIST_USER": "",
	"TRANSFER_TEXT": "",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "30",
	"SORT_POST_BY": "",
	"PAYOUT_CYCLE": "",
	"POTENTIAL_PAYOUT": "",
	"PAST_PAYOUT": "",
	"AUTHOR_PAYOUT": "",
	"CURATION_PAYOUT": "",
	"POST_SUBMITTED": "",
	"POST_LATER": "",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "<br><br><ul><li></li><li></li><li>SPAM</li></ul>",
	"REQUEST_LIMIT_TEXT": "/",
	"POST_IS_UNBOOKMARK": "",
	"POST_IS_BOOKMARK": "",
	"RESET": "",
	"MODIFY_PICTURE": "",
	"MODIFY_COVER_PICTURE": "",
	"ACTIVE_KEY_REQUIRED_TEXT": "",
	"RESET_PICTURE_TEXT": "",
	"RESET_COVER_PICTURE_TEXT": "",
	"UPDATE_REQUIRES_RESTART": "",
	"SETTINGS_UPDATED": "",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "",
	"LOGIN_TO_X": "/",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "",
	"POST_IS_DRAFT": "",
	"SWIPE_LEFT": "",
	"MANAGE": "",
	"IMAGE_REMOVED": "",
	"COPY": "",
	"NO_IMAGE": "",
	"PULL_DOWN_TO_REFRESH": "",
	"EXTERNAL_APPS": "",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "",
	"CURRENCY": "",
	"CURRENCY_TEXT": "",
	"ABOUT_11": "<br><b></b> <br> <br>-<br><br><br>-<br><br><br>-   <br> <br>-<br> <br> <br>-<br><br><br><b></b> <br>1<br>2.<br>3. <br>4 pin  <br><br> Golos  <br>",
	"FOUNDER": "",
	"ADD_ACCOUNT": "",
	"PLATFORM": ""
}
},{}],129:[function(require,module,exports){
module.exports={
	"HOME": "",
	"LOGIN": "",
	"LOGOUT": "",
	"PROFILE": "",
	"FOLLOW": "",
	"BOOKMARKS": "",
	"TRANSFER": "",
	"MARKET": "",
	"SETTINGS": "",
	"ABOUT": "",
	"ABOUT_1": "",
	"ABOUT_2": "{{platformname}}App",
	"ABOUT_3": "{{platformname}}{{sitename}}",
	"ABOUT_4": "App",
	"ABOUT_5": "App",
	"ABOUT_6": "App",
	"ABOUT_7": "App",
	"ABOUT_8": "good-karmawitness",
	"ABOUT_9": "/",
	"ABOUT_10": "",
	"REMOVE": "",
	"MARKET_VIEW": "",
	"PRICE": "",
	"AMOUNT": "",
	"TOTAL": "",
	"NOORDERS": "",
	"DATE": "",
	"BUY": "",
	"SELL": "",
	"OPEN": "",
	"HISTORY": "",
	"FOLLOW_BACK": "",
	"FOLLOWED": "",
	"UNFOLLOW": "",
	"FOLLOWING": "",
	"FOLLOWERS": "",
	"SEARCH_FOLLOWERS": "",
	"SEARCH_FOLLOWING": "",
	"BY": "",
	"IN": "",
	"MENU": "",
	"BOOKMARK": "",
	"REBLOG": "",
	"UPVOTE": "",
	"DOWNVOTE": "",
	"UNVOTE_DOWNVOTED": "",
	"UNVOTE_UPVOTED": "",
	"REPLY": "",
	"EDIT": "",
	"POST_1": "",
	"POST_2": "",
	"OPTIONS": "",
	"RESTEEMED_BY": "",
	"NOTHING_HERE": "",
	"BALANCES": "",
	"PROFILE_1": "{{platformname}} {{platformname}}  {{platformpower}}powering up",
	"PROFILE_2": "{{platformpower}}  ",
	"PROFILE_3": "{{platformsunit}}{{platformname}}",
	"ESTIMATED_VALUE": "",
	"PROFILE_4": "{{platformname}}3-5",
	"TRANSACTION_HISTORY": "",
	"PROFILE_5": "PostingActiveOwner",
	"PROFILE_6": "OwnerOwner",
	"PROFILE_7": "Active",
	"PROFILE_8": "Memomemo",
	"BLOG": "",
	"POSTS": "",
	"REPLIES": "",
	"WALLET": "",
	"TAG": "",
	"USER": "",
	"CLOSE": "",
	"TO": "",
	"ASSET": "",
	"SEND": "",
	"SECURITY": "",
	"AVAILABLE": "",
	"PUBLIC_MEMO": "",
	"TO_DESC": " good-karma",
	"PIN_CODE": "",
	"PIN_TEXT": "App<br/><br/><b></b>4AppApp",
	"NOTIFICATIONS": "",
	"VOTE_TEXT": "<br/> <b></b> ",
	"VOTE": "",
	"COMMENT_TEXT": "<br/> <b></b> <b></b>",
	"COMMENT": "",
	"FOLLOW_TEXT": "",
	"MENTIONS": "",
	"MENTIONS_TEXT": "",
	"CONFIGURATIONS": "",
	"VOTING": "",
	"VOTING_TEXT": "<br/> <b></b> ",
	"SERVER": "",
	"SERVER_TEXT": "",
	"SAVE_CHANGES": "",
	"VOTERS_INFO": "",
	"WELCOME_BACK": "",
	"LOGIN_1": "",
	"LOGIN_2": "Posting key",
	"LOGIN_3": "Active key",
	"LOGIN_4": "",
	"DONT_HAVE": "",
	"SIGN_UP_NOW": "",
	"CANCEL": "",
	"ADVANCED": "",
	"MASTER_PASS": "Master/",
	"USERNAME": "",
	"CARD_VIEW": "",
	"COMPACT_VIEW": "",
	"SEARCH": "",
	"SUBMIT_A_STORY": "",
	"REPLYTO": "",
	"POST": "",
	"PREVIEW": "",
	"DEFAULT": " 50% / 50%",
	"DECLINE_PAYOUT": "Payout",
	"SAVE_FOR_LATER": "",
	"CLEAR": "",
	"POST_CONTENT": "",
	"COMMENT_CONTENT": "",
	"TITLE": "",
	"TAGS": "",
	"NOT_MATCH": "",
	"CONFIRM_PIN": "",
	"INCORRECT": "",
	"OPENING_POST": "",
	"SET_PIN": "",
	"ENTER_PIN": "",
	"ARE_YOU_SURE": "",
	"BROADCAST_ERROR": "",
	"SUCCESS": "",
	"REBLOGGED_POST": "",
	"LOGIN_FAIL": "masterPosting",
	"LOGIN_FAIL_A": "masterActive",
	"WARNING": "",
	"VOTE_FOR_WITNESS": "",
	"VOTED_FOR_WITNESS": "",
	"AGO": "",
	"FROM_NOW": "",
	"SECS": "",
	"A_MIN": "",
	"MINS": "",
	"AN_HOUR": "",
	"HOURS": "",
	"A_DAY": "",
	"DAYS": "",
	"A_MONTH": "",
	"MONTHS": "",
	"A_YEAR": "",
	"YEARS": "",
	"MIN_READ": "",
	"DOWNVOTE_FLAG": "",
	"CAPTURE_PICTURE": "",
	"SELECT_PICTURE": "",
	"SET_CUSTOM_URL": "",
	"INSERT_PICTURE": "",
	"ERROR": "",
	"UPLOAD_ERROR": "",
	"CAMERA_CANCELLED": "",
	"SET_URL": "URL",
	"DIRECT_LINK_PICTURE": "",
	"COMMENT_SUBMITTED": "",
	"DELETE_COMMENT": "",
	"DELETED_COMMENT": "",
	"UPLOADING_PICTURE": "",
	"UPLOAD_COMPLETED": "",
	"UPLOAD_FAILED": "",
	"PASSWORD_INCORRECT": "",
	"INFO": "",
	"QR_TEXT": "QR code",
	"BALANCE_TEXT": "",
	"NONEXIST_USER": "",
	"TRANSFER_TEXT": "",
	"CONFIRMATION": "",
	"TX_BROADCASTED": "",
	"FEED": "",
	"TRENDING": "",
	"HOT": "",
	"NEW": "",
	"PROMOTED": "",
	"VOTES": "",
	"PAYOUT": "",
	"COMMENTS": "",
	"TRENDING_30": "30",
	"SORT_POST_BY": "",
	"PAYOUT_CYCLE": "",
	"POTENTIAL_PAYOUT": "",
	"PAST_PAYOUT": "",
	"AUTHOR_PAYOUT": "",
	"CURATION_PAYOUT": "",
	"POST_SUBMITTED": "",
	"POST_LATER": "",
	"SAVED": "",
	"CLEARED": "",
	"FLAGGING_TEXT": "<br><br> <ul><li></li><li></li><li></li></ul>",
	"REQUEST_LIMIT_TEXT": "",
	"POST_IS_UNBOOKMARK": "",
	"POST_IS_BOOKMARK": "",
	"RESET": "",
	"MODIFY_PICTURE": "",
	"MODIFY_COVER_PICTURE": "",
	"ACTIVE_KEY_REQUIRED_TEXT": "Active",
	"RESET_PICTURE_TEXT": "",
	"RESET_COVER_PICTURE_TEXT": "",
	"UPDATE_REQUIRES_RESTART": "",
	"SETTINGS_UPDATED": "",
	"LANGUAGES": "",
	"LANGUAGES_TEXT": "APP",
	"LOGIN_TO_X": "ActivePosting",
	"GALLERY": "",
	"TRANSLATIONS": "",
	"SHARE": "",
	"MARKETPLACE": "",
	"EXCHANGE": "",
	"DRAFTS": "",
	"POST_IS_UNDRAFT": "",
	"POST_IS_DRAFT": "",
	"SWIPE_LEFT": "",
	"MANAGE": "",
	"IMAGE_REMOVED": "",
	"COPY": "",
	"NO_IMAGE": "",
	"PULL_DOWN_TO_REFRESH": "",
	"EXTERNAL_APPS": "App",
	"PLUGINS": "",
	"SUGGEST": "",
	"COMING_SOON": "",
	"CHAIN": "",
	"CHAIN_TEXT": "",
	"RELEASE": ""
}
},{}],130:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//angular.module('steem.services', [])
module.exports = function (app) {
	app.service('APIs', ['$http', '$rootScope', 'API_END_POINT', function ($http, $rootScope, API_END_POINT) {
		'use strict';
		return {
      getCurrencyRate: function(code_from, code_to){
        console.log(code_from,code_to);
        return $http.get("https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20yahoo.finance.xchange%20where%20pair%20in%20(%22"+code_from+code_to+"%22)&format=json&diagnostics=false&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys");
      },
      saveSubscription: function(deviceid, username, subscription) {
        return $http.post(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateSubscription: function(deviceid, username, subscription) {
        return $http.put(API_END_POINT+"/api/devices", {deviceid: deviceid, username: username, subscription: subscription, chain: $rootScope.$storage.chain});
      },
      updateToken: function(deviceid, newdev) {
        return $http.put(API_END_POINT+"/api/device/"+deviceid, {newdev: newdev, chain: $rootScope.$storage.chain});
      },
      deleteSubscription: function(deviceid) {
        return $http.delete(API_END_POINT+"/api/devices/"+deviceid);
      },
      getSubscriptions: function(deviceid) {
        return $http.get(API_END_POINT+"/api/devices/"+deviceid);
      },
			addBookmark: function(user, bookmark) {
        return $http.post(API_END_POINT+"/api/bookmark", {username: user, author: bookmark.author, permlink: bookmark.permlink, chain: $rootScope.$storage.chain});
      },
			getBookmarks: function(user) {
        return $http.get(API_END_POINT+"/api/bookmarks/"+user);
      },
			removeBookmark: function(id, user) {
        return $http.delete(API_END_POINT+"/api/bookmarks/"+user+"/"+id);
      },
			addDraft: function(user, draft) {
        return $http.post(API_END_POINT+"/api/draft", {username: user, title: draft.title, body: draft.body, tags: draft.tags, post_type: draft.post_type, chain: $rootScope.$storage.chain});
      },
			getDrafts: function(user) {
        return $http.get(API_END_POINT+"/api/drafts/"+user);
      },
			removeDraft: function(id, user) {
        return $http.delete(API_END_POINT+"/api/drafts/"+user+"/"+id);
      },
			removeImage: function(id, user) {
        return $http.delete(API_END_POINT+"/api/images/"+user+"/"+id);
      },
			fetchImages: function(user) {
        return $http.get(API_END_POINT+"/api/images/"+user);
      },
      searchEscrow: function(id) {
        return $http.get(API_END_POINT+"/api/escrow/"+$rootScope.$storage.chain+"/"+id);
      },
		};
	}])
  app.directive('backImg', function(){
    return function(scope, element, attrs){
        var url = attrs.backImg;
        element.css({
            'background-image': 'url(' + url +')',
            'background-size' : 'cover'
        });
    };
  });
  app.directive('select', function() {
    return {
      restrict: 'E',
      link: function(scope, element, attrs) {
        element.bind('focus', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("show bar (hide = false)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
          }
        });
        element.bind('blur', function(e) {
          if (window.cordova && window.cordova.plugins.Keyboard) {
            // $rootScope.log("hide bar (hide = true)");
            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
          }
        });
      }
    };
  });
  app.directive('navigation', function () {
    var controller = ['$scope', '$rootScope', function ($scope, $rootScope) {
      $scope.addactiveclass = function (menuItem) {
          $scope.activeMenu = menuItem.name;
          //$rootScope.log(menuItem);
          $rootScope.$storage.filter = menuItem.href;
          $rootScope.$broadcast('filter:change');
          $scope.center(menuItem.name);
          $scope.someCtrlFn({menulinks: menuItem});
      };

      $(window).resize(function(){
        $scope.center();
      });
      $scope.center = function(menuItem) {
        var nav = document.getElementById("nav1");
        var navWidth = document.getElementById("nav2").offsetWidth;
        var currentElement = document.querySelectorAll('[name="'+menuItem+'"]');
        currentElement = menuItem ? currentElement[0] : document.getElementsByClassName('active')[0];
        if(currentElement) {
          var margin = 0;
          var lenm = nav.children.length;
          for(var i =0; i<lenm; i++){

            if(currentElement == nav.children[i]){
              break;
            }else {
              margin += nav.children[i].offsetWidth;
            }
          }
          nav.style.marginLeft = (navWidth/2 - margin - currentElement.offsetWidth/2) + 'px';
        }
        else {
          nav.style.marginLeft = (navWidth/2 - $scope.activeMenu.length) + 'px';
        }
      };
      var _len = $scope.menulinks.length;
      for (var i = 0; i < _len; i++) {
        if ($rootScope.$storage.filter) {
          if ($scope.menulinks[i].href == $rootScope.$storage.filter) {
            $scope.activeMenu = $scope.menulinks[i].name;
          }
        } else {
          $scope.activeMenu = "Trending";
        }
      }

      //$scope.center();
      setTimeout(function() {
        $scope.center();
      }, 50);
    }];

    return {
      restrict: "E",
      replace: true,
      scope: {
        menulinks: '=',
        someCtrlFn: '&callbackFn'
      },
      controller: controller,
      template: "<ul id='nav1'>"+
              "<li ng-repeat='menulinks in menulinks' name='{{menulink.name}}' class='top {{menulink.role}}' ng-class='{active : activeMenu === menulink.name}'>"+
                "<a on-tap='addactiveclass(menulink)'>"+
                  "{{menulink.name}}"
                +"</a>"+
                "<div class='arrow'></div>"+
                "</li>"
            +"</ul>"
    }
  });
  function SimplePubSub() {
      var events = {};
      return {
          on: function(names, handler) {
              names.split(' ').forEach(function(name) {
                  if (!events[name]) {
                      events[name] = [];
                  }
                  events[name].push(handler);
              });
              return this;
          },
          trigger: function(name, args) {
              angular.forEach(events[name], function(handler) {
                  handler.call(null, args);
              });
              return this;
          }
      };
  };

  app.directive('onFinishRender', function ($timeout) {
      return {
          restrict: 'A',
          link: function (scope, element, attr) {
              if (scope.$last === true) {
                  $timeout(function () {
                      scope.$emit('ngRepeatFinished');
                  });
              }
          }
      }
  })
  app.directive('clickHandler', function($timeout){
      return{
          restrict: 'A',
          link: function($scope, $element,$attr){
              $timeout(function(){
                      $element.on('tap', function(){
                        //the function you want to perform on tap
        alert("Just been Clicked");
                      });
              });
          }
      };
  })
  app.directive('tabSlideBox', [ '$timeout', '$window', '$ionicSlideBoxDelegate', '$ionicScrollDelegate', '$rootScope',
    function($timeout, $window, $ionicSlideBoxDelegate, $ionicScrollDelegate, $rootScope) {
      'use strict';

      return {
        restrict : 'A, E, C',
        link : function(scope, element, attrs, ngModel) {

          var ta = element[0], $ta = element;
          $ta.addClass("tabbed-slidebox");
          if(attrs.tabsPosition === "bottom"){
            $ta.addClass("btm");
          }

          //Handle multiple slide/scroll boxes
          var handle = ta.querySelector('.slider').getAttribute('delegate-handle');

          var ionicSlideBoxDelegate = $ionicSlideBoxDelegate;
          if(handle){
            ionicSlideBoxDelegate = ionicSlideBoxDelegate.$getByHandle(handle);
          }

          var ionicScrollDelegate = $ionicScrollDelegate;
          if(handle){
            ionicScrollDelegate = ionicScrollDelegate.$getByHandle(handle);
          }

          function renderScrollableTabs(){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            angular.forEach(icons, function(value, key){
                 var a = angular.element(value);
                 a.on('click', function(){
                   ionicSlideBoxDelegate.slide(key);
                 });

              if(a.attr('icon-off')) {
                a.attr("class", a.attr('icon-off'));
              }
            });

            var initialIndex = attrs.tab;
            //Initializing the middle tab
            if(typeof attrs.tab === 'undefined' || (totalTabs <= initialIndex) || initialIndex < 0){
              initialIndex = Math.floor(icons.length/2);
            }

            //If initial element is 0, set position of the tab to 0th tab
            if(initialIndex == 0){
              setPosition(0);
            }
            //$rootScope.log('initialIndex '+initialIndex);
            if ($rootScope.$storage.filter) {
              if ($rootScope.$storage.user) {
                if ($rootScope.$storage.filter === 'feed') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 8;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 9;
                }
              } else {
                if ($rootScope.$storage.filter === 'trending') {
                  //$scope.events.trigger("slideChange", {"index" : 0});
                  initialIndex = 0;
                }
                if ($rootScope.$storage.filter === 'hot'){
                  //$scope.events.trigger("slideChange", {"index" : 1});
                  initialIndex = 1;
                }
                if ($rootScope.$storage.filter === 'created'){
                  //$scope.events.trigger("slideChange", {"index" : 2});
                  initialIndex = 2;
                }
                if ($rootScope.$storage.filter === 'active'){
                  //$scope.events.trigger("slideChange", {"index" : 3});
                  initialIndex = 3;
                }
                if ($rootScope.$storage.filter === 'promoted'){
                  //$scope.events.trigger("slideChange", {"index" : 4});
                  initialIndex = 4;
                }
                if ($rootScope.$storage.filter === 'trending30'){
                  //$scope.events.trigger("slideChange", {"index" : 5});
                  initialIndex = 5;
                }
                if ($rootScope.$storage.filter === 'votes'){
                  //$scope.events.trigger("slideChange", {"index" : 6});
                  initialIndex = 6;
                }
                if ($rootScope.$storage.filter === 'children'){
                  //$scope.events.trigger("slideChange", {"index" : 7});
                  initialIndex = 7;
                }
                if ($rootScope.$storage.filter === 'cashout'){
                  //$scope.events.trigger("slideChange", {"index" : 8});
                  initialIndex = 8;
                }
              }
            }
            $timeout(function() {
              ionicSlideBoxDelegate.slide(initialIndex);
            }, 10);
          }

          function setPosition(index){
            var iconsDiv = angular.element(ta.querySelector(".tsb-icons")), icons = iconsDiv.find("a"), wrap = iconsDiv[0].querySelector(".tsb-ic-wrp"), totalTabs = icons.length;
            var scrollDiv = wrap.querySelector(".scroll");

            var middle = iconsDiv[0].offsetWidth/2;
            var curEl = angular.element(icons[index]);
            var prvEl = angular.element(iconsDiv[0].querySelector(".active"));
            if(curEl && curEl.length){
              var curElWidth = curEl[0].offsetWidth, curElLeft = curEl[0].offsetLeft;

              if(prvEl.attr('icon-off')) {
                prvEl.attr("class", prvEl.attr('icon-off'));
              } else{
                prvEl.removeClass("active");
              }
              if(curEl.attr('icon-on')) {
                curEl.attr("class", curEl.attr('icon-on'));
              }
              curEl.addClass("active");

              var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5);
              //If tabs are not scrollable
              if(!scrollDiv){
                var leftStr = (middle  - (curElLeft) -  curElWidth/2 + 5) + "px";
                wrap.style.webkitTransform =  "translate3d("+leftStr+",0,0)" ;
              } else {
                //If scrollable tabs
                var wrapWidth = wrap.offsetWidth;
                var currentX = Math.abs(getX(scrollDiv.style.webkitTransform));
                var leftOffset = 100;
                var elementOffset = 54;
                //If tabs are reaching right end or left end
                if(((currentX + wrapWidth) < (curElLeft + curElWidth + elementOffset)) || (currentX > (curElLeft - leftOffset))){
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  //Use this scrollTo, so when scrolling tab manually will not flicker
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);

                } else {
                  if(leftStr > 0){
                    leftStr = 0;
                  }
                  setTimeout(function() {
                    ionicScrollDelegate.scrollTo(Math.abs(leftStr), 0, true);
                  }, 10);
                }
              }
            }
          };
          function getX(matrix) {

            matrix = matrix.replace("translate3d(","");
            matrix = matrix.replace("translate(","");
            return (parseInt(matrix));
          }
          var events = scope.events;
          events.on('slideChange', function(data){
            setPosition(data.index);
          });
          events.on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            renderScrollableTabs();
          });
          setTimeout(function() {
            renderScrollableTabs();
          }, 10);

        },
        controller : function($scope, $attrs, $element, $rootScope) {
          $scope.events = new SimplePubSub();
          $scope.slideHasChanged = function(index){
            $rootScope.log("SlideChanged "+index);
            $scope.currentSlide = index;
            $scope.events.trigger("slideChange", {"index" : index});
            $timeout(function(){
              if($scope.onSlideMove) {
                $scope.onSlideMove({"index" : eval(index)});
              }

              if ($rootScope.$storage.user) {
                if (index === 0) {
                  $rootScope.$storage.filter = 'feed';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 9) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              } else {
                if (index === 0) {
                  $rootScope.$storage.filter = 'trending';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 1) {
                  $rootScope.$storage.filter = 'hot';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 2) {
                  $rootScope.$storage.filter = 'created';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 3) {
                  $rootScope.$storage.filter = 'active';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 4) {
                  $rootScope.$storage.filter = 'promoted';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 5) {
                  $rootScope.$storage.filter = 'trending30';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 6) {
                  $rootScope.$storage.filter = 'votes';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 7) {
                  $rootScope.$storage.filter = 'children';
                  $rootScope.$broadcast('filter:change');
                }
                if (index === 8) {
                  $rootScope.$storage.filter = 'cashout';
                  $rootScope.$broadcast('filter:change');
                }
              }
              if (!$rootScope.$$phase){
                $rootScope.$apply();
              }
            }, 10);
          };

          $scope.$on('ngRepeatFinished', function(ngRepeatFinishedEvent) {
            $rootScope.log('ngRepeatFinished');
            $scope.events.trigger("ngRepeatFinished", {"event" : ngRepeatFinishedEvent});
          });
        }
      };

    }
  ]);

	app.filter('timeago', function($filter, $translate, $rootScope) {

      function TimeAgo(input, p_allowFuture) {
        var substitute = function (stringOrFunction, number, strings) {
                var string = angular.isFunction(stringOrFunction) ? stringOrFunction(number, dateDifference) : stringOrFunction;
                var value = (strings.numbers && strings.numbers[number]) || number;
                return string.replace(/%d/i, value);
            },
            nowTime = (new Date()).getTime(),
            date = (new Date(input)).getTime(),
            //refreshMillis= 6e4, //A minute
            allowFuture = p_allowFuture || false,
            strings= {
                prefixAgo: '',
                prefixFromNow: '',
                suffixAgo: $filter('translate')('AGO'),
                suffixFromNow: $filter('translate')('FROM_NOW'),
                seconds: $filter('translate')('SECS'),
                minute: $filter('translate')('A_MIN'),
                minutes: "%d "+$filter('translate')('MINS'),
                hour: $filter('translate')('AN_HOUR'),
                hours: "%d "+$filter('translate')('HOURS'),
                day: $filter('translate')('A_DAY'),
                days: "%d "+$filter('translate')('DAYS'),
                month: $filter('translate')('A_MONTH'),
                months: "%d "+$filter('translate')('MONTHS'),
                year: $filter('translate')('A_YEAR'),
                years: "%d "+$filter('translate')('YEARS')
            },
            dateDifference = nowTime - date,
            words,
            seconds = Math.abs(dateDifference) / 1000,
            minutes = seconds / 60,
            hours = minutes / 60,
            days = hours / 24,
            years = days / 365,
            separator = strings.wordSeparator === undefined ?  " " : strings.wordSeparator,


            prefix = strings.prefixAgo,
            suffix = strings.suffixAgo;

        if (allowFuture) {
            if (dateDifference < 0) {
                prefix = strings.prefixFromNow;
                suffix = strings.suffixFromNow;
            }
        }

        words = seconds < 45 && substitute(strings.seconds, Math.round(seconds), strings) ||
        seconds < 90 && substitute(strings.minute, 1, strings) ||
        minutes < 45 && substitute(strings.minutes, Math.round(minutes), strings) ||
        minutes < 90 && substitute(strings.hour, 1, strings) ||
        hours < 24 && substitute(strings.hours, Math.round(hours), strings) ||
        hours < 42 && substitute(strings.day, 1, strings) ||
        days < 30 && substitute(strings.days, Math.round(days), strings) ||
        days < 45 && substitute(strings.month, 1, strings) ||
        days < 365 && substitute(strings.months, Math.round(days / 30), strings) ||
        years < 1.5 && substitute(strings.year, 1, strings) ||
        substitute(strings.years, Math.round(years), strings);
        //$rootScope.log(prefix+words+suffix+separator);
        prefix.replace(/ /g, '')
        words.replace(/ /g, '')
        suffix.replace(/ /g, '')
        return (prefix+' '+words+' '+suffix+' '+separator);

      };

      TimeAgo.$stateful = true;
      return TimeAgo;
    });

    app.filter('parseUrl', function($sce) {
	    var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
	    var emails = /(\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,6})/gim;
  	 	var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
  		var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
  		var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

	    return function(textu, subpart) {
        var options = {
        	gfm: true,
			    tables: true,
          smartLists: true,
			    breaks: true,
			    pedantic: false,
			    sanitize: false,
			    smartLists: true,
			    smartypants: false
			  };
        if (textu) {
          var textu = marked(textu, options);
          if (subpart) {
            var s = $sce.trustAsHtml(textu).toString();
            var text = s.substring(s.indexOf("<p>"), s.indexOf("</p>"));
            return text;
          } else {
            return $sce.trustAsHtml(textu);
          }
        }
	    };
	});

    app.filter('metadata', function($sce) {
        var urls = /(\b(https?|ftp):\/\/[A-Z0-9+&@#\/%?=~_|!:,.;-]*[-A-Z0-9+&@#\/%=~_|])/gim;
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        var imgs = /(https?:\/\/.*\.(?:png|jpg|jpeg|gif))/gim;
        var youtube = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;
        var youtubeid = /(?:(?:youtube.com\/watch\?v=)|(?:youtu.be\/))([A-Za-z0-9\_\-]+)/i;

        return function(textu) {
            var out = {};
            var murls = textu.match(urls);
            var musers = textu.match(users);
            var mimgs = [];
            var mlinks = [];
            if (murls) {
              var _len = murls.length;
                for (var i = 0; i < _len; i++) {
                    var ind = murls[i].match(imgs);
                    if (ind) {
                        mimgs.push(murls[i]);
                    } else {
                        mlinks.push(murls[i]);
                    }
                }
                if (mlinks) {
                    angular.merge(out, {links: mlinks});
                }
                if (mimgs) {
                    angular.merge(out, {image: mimgs});
                }
            }
            if (musers) {
              var _len = musers.length;
                for (var i = 0; i < _len; i++) {
                    musers[i] = musers[i].trim().substring(1);
                }
                if (musers) {
                    angular.merge(out, {users: musers});
                }
            }
            return out;
        };
    });

    app.filter('metadataUsers', function($sce) {
        var users = /(^|\s)(@[a-z][-\.a-z\d]+[a-z\d])/gim;
        return function(textu) {
          if (textu) {
            var out = {};
            var musers = textu.match(users);

            $rootScope.log(angular.toJson(musers));

            return textu;
          }
        };
    });

    app.filter('ldots', function() {
        return function(text) {
          if (text) {
            return text+'...';
          }
        };
    });

    app.filter('regex', function() {
      return function(input, field, regex) {
          var patt = new RegExp(regex);      
          var out = [];
          for (var i = 0; i < input.length; i++){
            //console.log(patt.test(input[i][field]));
            if(!patt.test(input[i][field]))
              out.push(input[i]);
          }      
        return out;
      };
    });
    
    app.filter('detransliterate', function(){
      // copypaste from https://gist.github.com/tamr/5fb00a1c6214f5cab4f6
      // (it have been modified:  > iy and so on)
      // this have been done beecause we cannot use special symbols in url (`` and '')
      // and url seems to be the only source of thruth
      var d = /\s+/g,
      //rus = "                                           ".split(d),
      //eng = "sch  sh  ch  cz  yu  ju  ya  q  yie  iy  yo  jo  zh  w ye  y a b v g d e z i yi  k l m n o p r s t u f x h j".split(d);

      rus = "                                              ".split(d),
      eng = "shch sh ch cz ij yo ye yu ya kh zh a b v g d e z i k l m n o p r s t u f xx y x".split(d);
      return function (str, reverse) {
        if (!str) return str;
        if (!reverse && str.substring(0, 4) !== 'ru--') return str;
        if (!reverse) str = str.substring(4)

        // TODO rework this
        // (didnt placed this earlier because something is breaking and i am too lazy to figure it out ;( )
        if(!reverse) {
        //    str = str.replace(/j/g, '')
        //    str = str.replace(/w/g, '')
            str = str.replace(/yie/g, '')
        }
        else {
        //    str = str.replace(//g, 'j')
        //    str = str.replace(//g, 'w')
            str = str.replace(//g, 'yie')
        }

        var i,
            s = /[^[\]]+(?=])/g, orig = str.match(s),
            t = /<(.|\n)*?>/g, tags = str.match(t);

        if(reverse) {
            for(i = 0; i < rus.length; ++i) {
                str = str.split(rus[i]).join(eng[i]);
                str = str.split(rus[i].toUpperCase()).join(eng[i].toUpperCase());
            }
        }
        else {
            for(i = 0; i < rus.length; ++i) {
                str = str.split(eng[i]).join(rus[i]);
                str = str.split(eng[i].toUpperCase()).join(rus[i].toUpperCase());
            }
        }

        if(orig) {
            var restoreOrig = str.match(s);

            for (i = 0; i < restoreOrig.length; ++i)
                str = str.replace(restoreOrig[i], orig[i]);
        }

        if(tags) {
            var restoreTags = str.match(t);

            for (i = 0; i < restoreTags.length; ++i)
                str = str.replace(restoreTags[i], tags[i]);

            str = str.replace(/\[/g, '').replace(/\]/g, '');
        }

        return str;
      }
    })
     app.filter('getCurrencySymbol', function($filter) {
        return function(text) {
          if (text) {
            //console.log(text.split('-')[1]);
            //var x = text.split('-')[1];
            //var tt = $filter('uppercase')(x);
            var textu = window.getSymbol(text);
            return textu=="?"?text:textu;
          }
        };
    });

  function ansiWordBound(c) {
    return (
      (' ' === c) ||
      ('\n' === c) ||
      ('\r' === c) ||
      ('\t' === c)
    )
  }

  function readingTime(text, options) {
    var words = 0, start = 0, end = text.length - 1, wordBound, i

    options = options || {}

    // use default values if necessary
    options.wordsPerMinute = options.wordsPerMinute || 200

    // use provided function if available
    wordBound = options.wordBound || ansiWordBound

    // fetch bounds
    while (wordBound(text[start])) start++
    while (wordBound(text[end])) end--

    // calculate the number of words
    for (i = start; i <= end;) {
      for (; i <= end && !wordBound(text[i]); i++) ;
      words++
      for (; i <= end && wordBound(text[i]); i++) ;
    }

    // reading time stats
    var minutes = words / options.wordsPerMinute
    var time = minutes * 60 * 1000
    var displayed = Math.ceil(minutes.toFixed(2))

    return {
      text: displayed + ' min read',
      minutes: Math.ceil(minutes.toFixed(2)),
      time: time,
      words: words
    }
  }

  app.filter('readingtime', function($sce, $rootScope) {
      return function(text) {
        if (text) {
          return readingTime(text).minutes;
        }
      };
  })

	app.filter('sp', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests).toFixed(3);
	    	}
	    };
	})
	app.filter('sd', function($sce, $rootScope) {
	    return function(text, balance, sbd) {
	    	if (text) {
	    		return ((Number(text.split(" ")[0])/1e6*$rootScope.$storage.steem_per_mvests*$rootScope.$storage.base + Number(balance.split(" ")[0])*$rootScope.$storage.base + Number(sbd.split(" ")[0])).toFixed(3))*$rootScope.$storage.currencyRate;
	    	}
	    };
	})
	app.filter('sbd', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('st', function($sce, $rootScope) {
	    return function(text) {
	    	if (text) {
	    		return (Number(text.split(" ")[0]).toFixed(3));
	    	}
	    };
	})
	app.filter('reputation', function(){
		return function(value, bool) {
			reputation_level = 1;
			neg = false;

			if (value < 0)
				neg = true;

			if (value != 0) {
				reputation_level = Math.log10(Math.abs(value));
				reputation_level = Math.max(reputation_level - 9, 0);

				if (reputation_level < 0)
					reputation_level = 0;
				if (neg)
					reputation_level *= -1;

				reputation_level = (reputation_level*9) + 25;
			} else {
				return 0;
			}

			return bool?reputation_level:Math.floor(reputation_level);
		}
	})

  app.filter("sumPostTotal", function($rootScope){
    function SumPostTotal(value, rate) {
      //console.log(value, rate);
      if (value && value.pending_payout_value) {
        //value.total_payout_value.split(" ")[0])+parseFloat(value.total_pending_payout_value.split(" ")[0])
        //return (parseFloat(value.pending_payout_value.split(" ")[0])*rate);
        return ((parseFloat(value.total_payout_value.split(" ")[0]))+(parseFloat(value.pending_payout_value.split(" ")[0]))*rate).toFixed(2);
      }
    }
    //SumPostTotal.$stateful = true;

    return SumPostTotal;
  });

  app.filter("rate", function($rootScope){
    return function(value) {
      if (value) {
        return (parseFloat(value)*$rootScope.$storage.currencyRate);
      }
    }
  });  

  app.filter('hrefToJS', function ($sce, $sanitize) {
      return function (text) {
          var regex = /href="([\S]+)"/g;
          var newString = $sanitize(text).replace(regex, "href onClick=\"window.open('$1', '_system', 'location=yes');return false;\"");
          return $sce.trustAsHtml(newString);
      }
  });

  app.directive('autofocus', ['$timeout',
    function ($timeout) {
      return {
        restrict: 'A',
        link: function ($scope, $element) {
          $timeout(function () {
            $element[0].focus();
          });
        }
      };
    }]);

  app.directive('selectInput', ['$ionicPopup', '$rootScope', function($ionicPopup, $rootScope) {
    return {
      restric: 'E',
      scope: {
        currentInput: '=ngModel',
        selectOptions: '='
      },
      require: '?^ngModel',
      template: '<div class="item-input item-icon-right" style="width:100%;"><input ng-model="currentInput" type="text" ng-change="socketChange(currentInput)"><i class="icon ion-android-arrow-dropdown" ng-click="showOptions()"></i></div>',
      link: function(scope, element, attrs) {
        scope.options = {
          selected: ''
        }
        scope.socketChange = function(xx){
          console.log(xx);
          $rootScope.$storage["socket"+$rootScope.$storage.chain] = xx;
          localStorage.socketUrl = xx;
          scope.restart = true;
        }
        scope.showOptions = function() {
          $ionicPopup.show({
            template: '<ion-radio ng-repeat="item in selectOptions" class="item-text-wrap" ng-model="options.selected" ng-value="item">{{item}}</ion-radio>',
            title: 'Server',
            cssClass: 'my-custom-popup',
            scope: scope,
            buttons: [{
              text: 'Cancel'
            }, {
              text: '<b>Confirm</b>',
              type: 'button-positive',
              onTap: function(e) {
                scope.currentInput = scope.options.selected;
              }
            }]
          });
        }
      }
    }
  }])

	app.directive('qrcode', function($interpolate) {
		return {
		    restrict: 'E',
		    link: function($scope, $element, $attrs) {

		      var options = {
		        text: '',
		        width: 128,
		        height: 128,
		        colorDark: '#000000',
		        colorLight: '#ffffff',
		        correctLevel: 'H'
		      };

		      Object.keys(options).forEach(function(key) {
		        options[key] = $interpolate($attrs[key] || '')($scope) || options[key];
		      });

		      options.correctLevel = QRCode.CorrectLevel[options.correctLevel];

		      new QRCode($element[0], options);

		    }
		}
	});


    app.directive('ionComment', ionComment)
    app.directive('ionThread', ionThread);

    function ionComment() {
        return {
            restrict: 'E',
            scope: {
                comment: '='
            },
            template: '<ion-item ng-if="comment.author" class="ion-comment item">\
                        <div class="ion-comment--author"><img class="round-avatar" src="img/user_profile.png" ng-src="{{$root.$storage.paccounts[comment.author].user_image||$root.$storage.paccounts[comment.author].profile.profile_image}}" onerror="this.src=\'img/user_profile.png\'" onabort="this.src=\'img/user_profile.png\'" /><b><a href="#/app/profile/{{comment.author}}">{{comment.author}}</a></b>&nbsp;<div class="reputation">{{comment.author_reputation|reputation|number:0}}</div>&middot;{{comment.created|timeago}}</div>\
                        <div class="ion-comment--score"><span on-tap="openTooltip($event,comment)"><b>{{$root.$storage.currency|getCurrencySymbol}}</b> <span ng-if="comment.max_accepted_payout.split(\' \')[0] === \'0.000\'"><del>{{comment | sumPostTotal:$root.$storage.currencyRate | number}}</del></span><span ng-if="comment.max_accepted_payout.split(\' \')[0] !== \'0.000\'">{{comment | sumPostTotal:$root.$storage.currencyRate | number}}</span> </span> | <span on-tap="downvotePost(comment)"><span class="fa fa-flag" ng-class="{\'assertive\':comment.downvoted}"></span></span></div>\
                        <div class="ion-comment--text bodytext selectable" ng-bind-html="comment.body | parseUrl "></div>\
                        <div class="ion-comment--replies"><ion-spinner ng-if="comment.invoting"></ion-spinner><span on-tap="upvotePost(comment)" on-hold="openSliderr($event, comment)"><span class="fa fa-chevron-circle-up" ng-class="{\'positive\':comment.upvoted}"></span> {{"UPVOTE"|translate}}</span> | <span on-tap="$root.openInfo(comment)">{{comment.net_votes || 0}} {{"VOTES"|translate}}</span> | <span on-tap="toggleComment(comment)">{{comment.children || 0}} {{"REPLIES"|translate}}</span> | <span on-tap="replyToComment(comment)"><span class="fa fa-reply"></span> {{"REPLY"|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username && compateDate(comment)" on-tap="editComment(comment)"> | <span class="ion-ios-compose-outline"></span> {{\'EDIT\'|translate}}</span> <span ng-if="comment.author == $root.$storage.user.username && comment.abs_rshares == 0" on-tap="deleteComment(comment)"> | <span class="ion-ios-trash-outline"></span> {{\'REMOVE\'|translate}}</span></div>\
                    </ion-item>',
            controller: function($scope, $rootScope, $state, $ionicModal, $ionicPopover, $ionicPopup, $ionicActionSheet, $cordovaCamera, $filter, ImageUploadService) {
                  $ionicPopover.fromTemplateUrl('popoverTr.html', {
                      scope: $scope
                   }).then(function(popover) {
                      $scope.tooltip = popover;
                   });
                  
                  $ionicPopover.fromTemplateUrl('popoverSliderr.html', {
                      scope: $scope
                  }).then(function(popover) {
                      $scope.tooltipSliderr = popover;
                  });

                  $scope.openSliderr = function($event, d) {
                    $scope.votingPost = d;
                    $scope.rangeValue = $rootScope.$storage.voteWeight/100;
                    $scope.tooltipSliderr.show($event);
                  };
                  $scope.votePostS = function() {
                    $scope.tooltipSliderr.hide();
                    $scope.upvotePost($scope.votingPost);
                  }
                  $scope.drag = function(v) {
                    //console.log(v);
                    $rootScope.$storage.voteWeight = v*100;
                  };

                  $scope.closeSliderr = function() {
                    $scope.tooltipSliderr.hide();
                  };

                  $scope.openTooltip = function($event, d) {
                    var tppv = Number(d.pending_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var p = Number(d.promoted.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var tpv = Number(d.total_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var ar = Number(d.total_payout_value.split(' ')[0]-d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var crp = Number(d.curator_payout_value.split(' ')[0])*$rootScope.$storage.currencyRate;
                    var texth = "<div class='row'><div class='col'><b>"+$filter('translate')('POTENTIAL_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tppv, 3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAST_PAYOUT')+"</b></div><div class='col'>"+$filter('getCurrencySymbol')($rootScope.$storage.currency)+$filter('number')(tpv,3)+"</div></div><div class='row'><div class='col'><b>"+$filter('translate')('PAYOUT')+"</b></div><div class='col'>"+$filter('timeago')(d.cashout_time, true)+"</div></div>";
                    $scope.tooltipText = texth;
                    $scope.tooltip.show($event);
                  };

                  $scope.closeTooltip = function() {
                      $scope.tooltip.hide();
                  };

                  //Cleanup the popover when we're done with it!
                  $scope.$on('$destroy', function() {
                      $scope.tooltip.remove();
                  });


                  $scope.compateDate = function(comment) {
                    if (comment.last_payout == "1970-01-01T00:00:00") {
                        return true;
                    } else {
                      if (comment.mode == "first_payout"){
                        return true;
                      } else {
                        return false;
                      }
                    }
                  };
                  $scope.toggleComment = function(comment) {
                      $rootScope.log('toggleComment '+comment.showChildren);

                      if (comment.showChildren) {
                        comment.showChildren = false;
                      } else {
                        console.log(comment.author, comment.permlink);
                        comment.showChildren = true;
                        if (comment.depth % 5 == 0) {
                          console.log('depth5');
                          $rootScope.$broadcast('openComments', { data: comment });
                        } else {
                          window.Api.initPromise.then(function(response) {
                          window.Api.database_api().exec("get_content_replies", [comment.author, comment.permlink]).then(function(dd){
                            comment.comments = dd;

                            for (var i = 0, len = dd.length; i < len; i++) {
                              var v = dd[i];
                              if ($rootScope.$storage.postAccounts.indexOf(v.author) == -1) {
                                $rootScope.$storage.postAccounts.push(v.author);
                              }  
                            }
                            setTimeout(function() {
                              $scope.$broadcast('postAccounts');
                            }, 10);

                            if (!$scope.$$phase){
                              $scope.$apply();
                            }
                            comment.showChildren = true;
                            console.log(comment);
                          });
                          });  
                        }
                      }
                        //$rootScope.$broadcast('update:content');
                    //$rootScope.$broadcast('hide:loading');
                  };
                  $scope.$on('postAccounts', function(){
                    //$rootScope.$storage.paccounts = {};
                    //console.log($rootScope.$storage.paccounts)
                    window.Api.initPromise.then(function(response) {
                    window.Api.database_api().exec("get_accounts", [$rootScope.$storage.postAccounts]).then(function(res){
                      for (var i = 0, len = res.length; i < len; i++) {
                        var v = res[i];
                        if (typeof v.json_metadata === 'string' || v.json_metadata instanceof String) {
                          if (v.json_metadata) {
                            if (v.json_metadata.indexOf("created_at")>-1) {
                              v.json_metadata = angular.fromJson(angular.toJson(v.json_metadata));  
                            } else {
                              v.json_metadata = angular.fromJson(v.json_metadata);
                            }
                            var key = v.name;
                            $rootScope.$storage.paccounts[key] = v.json_metadata;
                          }
                        }
                      }
                      if (!$scope.$$phase){
                        $scope.$apply();
                      }
                    });
                    });
                  });
                  $scope.upvotePost = function(post) {
                    $rootScope.votePost(post, 'upvote', 'update:content');
                  };

                  $scope.downvotePost = function(post) {
                    var confirmPopup = $ionicPopup.confirm({
                      title: $filter('translate')('ARE_YOU_SURE'),
                      template: $filter('translate')('DOWNVOTE_FLAG')
                    });
                    confirmPopup.then(function(res) {
                      if(res) {
                        $rootScope.log('You are sure');
                        $rootScope.votePost(post, 'downvote', 'update:content');
                      } else {
                        $rootScope.log('You are not sure');
                      }
                    });
                  };

                  $scope.unvotePost = function(post) {
                    $rootScope.votePost(post, 'unvote', 'update:content');
                  };
                  $scope.data={};
                  $ionicModal.fromTemplateUrl('templates/reply.html', {
                    scope: $scope  }).then(function(modal) {
                    $scope.cmodal = modal;
                  });

                  $scope.openModal = function(item) {
                    $scope.cmodal.show();
                  };

                  $scope.closeModal = function() {
                    $scope.replying = false;
                    $scope.cmodal.hide();
                  };

                  $scope.isreplying = function(cho, xx) {
                    $scope.replying = xx;
                    $scope.post = cho;
                    if (xx) {
                        $scope.editc = false;
                        $scope.edit = false;
                        $scope.data.comment = '';
                        $scope.openModal();
                    } else {
                        $scope.editc = true;
                        $scope.edit = true;
                        $scope.data.comment = $scope.post.body;
                        $scope.patchbody = $scope.post.body;
                        $scope.openModal();
                    }
                  };

                  $scope.showImg = function() {
                   var hideSheet = $ionicActionSheet.show({
                     buttons: [
                       { text: $filter('translate')('CAPTURE_PICTURE') },
                       { text: $filter('translate')('SELECT_PICTURE') },
                       { text: $filter('translate')('SET_CUSTOM_URL') },
                     ],
                     titleText: $filter('translate')('INSERT_PICTURE'),
                     cancelText: $filter('translate')('CANCEL'),
                     cancel: function() {
                        // add cancel code..
                      },
                     buttonClicked: function(index) {
                        $scope.insertImageC(index);
                        return true;
                     }
                   });
                  };

                  $scope.insertImageC = function(type) {
                    var options = {};
                    if (type == 0 || type == 1) {
                      options = {
                        quality: 50,
                        destinationType: Camera.DestinationType.FILE_URI,
                        sourceType: (type===0)?Camera.PictureSourceType.CAMERA:Camera.PictureSourceType.PHOTOLIBRARY,
                        allowEdit: (type===0)?true:false,
                        encodingType: Camera.EncodingType.JPEG,
                        popoverOptions: CameraPopoverOptions,
                        saveToPhotoAlbum: false
                        //correctOrientation:true
                      };
                      $cordovaCamera.getPicture(options).then(function(imageData) {
                        setTimeout(function() {
                          ImageUploadService.uploadImage(imageData).then(function(result) {
                            //var url = result.secure_url || '';
                            var url = result.imageUrl || '';
                            var final = " ![image](" + url + ")";
                            $rootScope.log(final);
                            if ($scope.data.comment) {
                              $scope.data.comment += final;
                            } else {
                              $scope.data.comment = final;
                            }
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          },
                          function(err) {
                            $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('UPLOAD_ERROR'));
                            if (!ionic.Platform.isAndroid() || !ionic.Platform.isWindowsPhone()) {
                              $cordovaCamera.cleanup();
                            }
                          });
                        }, 10);
                      }, function(err) {
                        $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('CAMERA_CANCELLED'));
                      });
                    } else {
                      $ionicPopup.prompt({
                        title: $filter('translate')('SET_URL'),
                        template: $filter('translate')('DIRECT_LINK_PICTURE'),
                        inputType: 'text',
                        inputPlaceholder: 'http://example.com/image.jpg'
                      }).then(function(res) {
                        $rootScope.log('Your url is' + res);
                        if (res) {
                          var url = res.trim();
                          var final = " ![image](" + url + ")";
                          $rootScope.log(final);
                          if ($scope.data.comment) {
                            $scope.data.comment += final;
                          } else {
                            $scope.data.comment = final;
                          }
                        }
                      });
                    }
                  };

                  var dmp = new window.diff_match_patch();
                  function createPatch(text1, text2) {
                      if (!text1 && text1 === '') return undefined;
                      var patches = dmp.patch_make(text1, text2);
                      var patch = dmp.patch_toText(patches);
                      return patch;
                  }
                  $scope.reply = function (xx) {
                    window.Api.initPromise.then(function(response) {
                      if (!$scope.editc) {
                          $rootScope.$broadcast('show:loading');
                          if ($rootScope.$storage.user) {
                            $scope.mylogin = new window.ejs.Login();
                            $scope.mylogin.setRoles(["posting"]);
                            var loginSuccess = $scope.mylogin.checkKeys({
                                accountName: $rootScope.$storage.user.username,
                                password: $rootScope.$storage.user.password || null,
                                auths: {
                                    posting: $rootScope.$storage.user.posting.key_auths
                                },
                                privateKey: $rootScope.$storage.user.privatePostingKey || null
                              }
                            );
                            if (loginSuccess) {
                              var tr = new window.ejs.TransactionBuilder();
                              var t = new Date();
                              var timeformat = t.getFullYear().toString()+(t.getMonth()+1).toString()+t.getDate().toString()+"t"+t.getHours().toString()+t.getMinutes().toString()+t.getSeconds().toString()+t.getMilliseconds().toString()+"z";

                              var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                              tr.add_type_operation("comment", {
                                parent_author: $scope.post.author,
                                parent_permlink: $scope.post.permlink,
                                author: $rootScope.$storage.user.username,
                                permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,
                                title: "",
                                body: $scope.data.comment,
                                json_metadata: angular.toJson(json)
                              });
                              tr.add_type_operation("comment_options", {
                                allow_curation_rewards: true,
                                allow_votes: true,
                                author: $rootScope.$storage.user.username,
                                permlink: "re-"+$scope.post.author+"-"+$scope.post.permlink+"-"+timeformat,  
                                max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
                                percent_steem_dollars: 10000,
                                extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
                              });
                              //$rootScope.log(my_pubkeys);
                              localStorage.error = 0;
                              tr.process_transaction($scope.mylogin, null, true);

                              $scope.replying = false;
                              setTimeout(function() {
                                if (localStorage.error == 1) {
                                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                } else {
                                  $scope.closeModal();
                                  $scope.data.comment = "";
                                  $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                  $rootScope.$broadcast("update:content");
                                }
                                $rootScope.$broadcast('hide:loading');
                              }, 3000);
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                            }
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                          }
                      } else {

                          var patch = createPatch($scope.patchbody, $scope.data.comment)
                          // Putting body into buffer will expand Unicode characters into their true length
                          if (patch && patch.length < new Buffer($scope.data.comment, 'utf-8').length) {
                            $scope.data.comment2 = patch;
                            //$rootScope.log(patch);
                          }

                          $rootScope.$broadcast('show:loading');
                          if ($rootScope.$storage.user) {
                            $scope.mylogin = new window.ejs.Login();
                            $scope.mylogin.setRoles(["posting"]);
                            var loginSuccess = $scope.mylogin.checkKeys({
                                accountName: $rootScope.$storage.user.username,
                                password: $rootScope.$storage.user.password || null,
                                auths: {
                                    posting: $rootScope.$storage.user.posting.key_auths
                                },
                                privateKey: $rootScope.$storage.user.privatePostingKey || null
                              }
                            );
                            if (loginSuccess) {
                              var tr = new window.ejs.TransactionBuilder();

                              var json = {tags: angular.fromJson($scope.post.json_metadata).tags[0] || "", app: 'esteem/'+$rootScope.$storage.appversion, format: 'markdown+html' };
                              tr.add_type_operation("comment", {
                                parent_author: $scope.post.parent_author,
                                parent_permlink: $scope.post.parent_permlink,
                                author: $scope.post.author,
                                permlink: $scope.post.permlink,
                                title: "",
                                body: $scope.data.comment2 || $scope.data.comment,
                                json_metadata: $scope.post.json_metadata
                              });
                              tr.add_type_operation("comment_options", {
                                allow_curation_rewards: true,
                                allow_votes: true,
                                author: $scope.post.author,
                                permlink: $scope.post.permlink,  
                                max_accepted_payout: "1000000.000 "+$rootScope.$storage.platformdunit,
                                percent_steem_dollars: 10000,
                                extensions: { "beneficiaries": { "account":"esteemapp", "weight":100 } }
                              });
                              //$rootScope.log(my_pubkeys);
                              localStorage.error = 0;
                              tr.process_transaction($scope.mylogin, null, true);

                              $scope.closeModal();
                              $scope.replying = false;
                              setTimeout(function() {
                                if (localStorage.error == 1) {
                                  $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                } else {
                                  $scope.data.comment = "";
                                  $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('COMMENT_SUBMITTED'));
                                  $rootScope.$broadcast("update:content");
                                }
                                $rootScope.$broadcast('hide:loading');
                              }, 3000);
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showMessage($filter('translate')('ERROR'), $filter('translate')('LOGIN_FAIL'));
                            }
                          } else {
                            $rootScope.$broadcast('hide:loading');
                            $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                          }
                      }
                    $rootScope.$broadcast('hide:loading');
                  });
                }
                $scope.replyToComment = function(comment) {
                    $rootScope.log('reply to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, true);
                }
                $scope.editComment = function(comment) {
                    $rootScope.log('edit to comment')
                    //$rootScope.$storage.sitem = comment;
                    $scope.isreplying(comment, false);
                }
                $scope.deleteComment = function(comment) {
                    $rootScope.log('delete to comment '+ angular.toJson(comment));
                    var confirmPopup = $ionicPopup.confirm({
                        title: $filter('translate')('ARE_YOU_SURE'),
                        template: $filter('translate')('DELETE_COMMENT')
                    });
                    confirmPopup.then(function(res) {
                        if(res) {
                            $rootScope.log('You are sure');
                            $rootScope.$broadcast('show:loading');
                            if ($rootScope.$storage.user) {
                              $scope.mylogin = new window.ejs.Login();
                              $scope.mylogin.setRoles(["posting"]);
                              var loginSuccess = $scope.mylogin.checkKeys({
                                  accountName: $rootScope.$storage.user.username,
                                  password: $rootScope.$storage.user.password || null,
                                  auths: {
                                      posting: $rootScope.$storage.user.posting.key_auths
                                  },
                                  privateKey: $rootScope.$storage.user.privatePostingKey || null
                                }
                              );
                              if (loginSuccess) {
                                var tr = new window.ejs.TransactionBuilder();

                                tr.add_type_operation("delete_comment", {
                                  author: comment.author,
                                  permlink: comment.permlink
                                });
                                //$rootScope.log(my_pubkeys);
                                localStorage.error = 0;
                                tr.process_transaction($scope.mylogin, null, true);

                                setTimeout(function() {
                                  if (localStorage.error == 1) {
                                    $rootScope.showAlert($filter('translate')('ERROR'), $filter('translate')('BROADCAST_ERROR')+" "+localStorage.errormessage)
                                  } else {
                                    $rootScope.showMessage($filter('translate')('SUCCESS'), $filter('translate')('DELETED_COMMENT'));
                                    $rootScope.$broadcast("update:content");
                                  }
                                  $rootScope.$broadcast('hide:loading');
                                }, 3000);
                              } else {
                                $rootScope.$broadcast('hide:loading');
                              }
                            } else {
                              $rootScope.$broadcast('hide:loading');
                              $rootScope.showAlert($filter('translate')('WARNING'), $filter('translate')('LOGIN_TO_X'));
                            }
                        } else {
                          $rootScope.log('You are not sure');
                        }
                    });
                }
            }
        }
    }

    function ionThread() {
        return {
            restrict: 'E',
            scope: {
                comments: '='
            },
            //Replace ng-if="!comment.showChildren" with ng-if="comment.showChildren" to hide all child comments by default
            //Replace comment.data.replies.data.children according to the API you are using | orderBy:\'-net_votes\'
            template: '<script type="text/ng-template" id="node.html">\
                            <ion-comment comment="comment">\
                            </ion-comment>\
                            <div class="reddit-post--comment--container">\
                                 <ul ng-if="comment.showChildren" class="animate-if ion-comment--children">\
                                    <li ng-repeat="comment in comment.comments | orderBy:\'-pending_payout_value\' track by $index ">\
                                        <ng-include src="\'node.html\'"/>\
                                    </li>\
                                </ul>\
                            </div>\
                        </script>\
                        <ion-list ng-if="comments && comments.length > 0">\
                          <ul>\
                            <li ng-repeat="comment in comments | orderBy:\'-pending_payout_value\' track by $index">\
                                <ng-include src="\'node.html\'"/>\
                            </li>\
                          </ul>\
                        </ion-list>',
            controller: function($scope, $rootScope) {
                /*$scope.toggleComment = function(comment) {
                  //$rootScope.log('toggleComment');
                  if (comment.showChildren) {
                      comment.showChildren = false;
                  } else {
                      comment.showChildren = true;
                  }
                };*/
            }
        }
    }

    function ius($q, $ionicLoading, $cordovaFileTransfer, $ionicPlatform, $filter, $rootScope, API_END_POINT) {
        var service = {};
        service.uploadImage = uploadImage;
        return service;
        function uploadImage(imageURI) {
          var deferred = $q.defer();
          var fileSize;
          var percentage;
          /*if (ionic.Platform.isAndroid()) {
            if (imageURI.indexOf('file://')===-1) {
              imageURI="file://"+imageURI;
            }
          }*/
          // Find out how big the original file is
          window.resolveLocalFileSystemURL(imageURI, function(fileEntry) {
            fileEntry.file(function(fileObj) {
              fileSize = fileObj.size;
              // Display a loading indicator reporting the start of the upload
              $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + 0 + '%'});
              // Trigger the upload
              uploadFile();
            });
          });
          function uploadFile() {
            // Add the Cloudinary "upload preset" name to the headers
            // "https://api.cloudinary.com/v1_1/esteem/image/upload"
            var uploadOptions = {
              params : { 'username': $rootScope.$storage.user.username}
            };
            $ionicPlatform.ready(function() {
                $cordovaFileTransfer.upload(API_END_POINT+"/api/upload", imageURI, uploadOptions).then(function(result) {
                    // Let the user know the upload is completed
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_COMPLETED'), duration: 1000});
                    // Result has a "response" property that is escaped
                    // FYI: The result will also have URLs for any new images generated with
                    // eager transformations
                    var response = JSON.parse(decodeURIComponent(result.response));
                    deferred.resolve(response);
                  }, function(err) {
                    // Uh oh!
                    $ionicLoading.show({template : $filter('translate')('UPLOAD_FAILED'), duration: 2000});
                    deferred.reject(err);
                  }, function (progress) {
                    // The upload plugin gives you information about how much data has been transferred
                    // on some interval.  Use this with the original file size to show a progress indicator.
                    percentage = Math.floor((progress.loaded / fileSize) * 100);
                    $ionicLoading.show({template : $filter('translate')('UPLOADING_PICTURE') + percentage + '%'});
                  });
            });
          }
          return deferred.promise;
        }
    }

    app.factory('ImageUploadService', ius);

    app.constant('defaultSettings', {
        alphabetcolors: ["#5A8770", "#B2B7BB", "#6FA9AB", "#F5AF29", "#0088B9", "#F18636", "#D93A37", "#A6B12E", "#5C9BBC", "#F5888D", "#9A89B5", "#407887", "#9A89B5", "#5A8770", "#D33F33", "#A2B01F", "#F0B126", "#0087BF", "#F18636", "#0087BF", "#B2B7BB", "#72ACAE", "#9C8AB4", "#5A8770", "#EEB424", "#407887"],
        textColor: '#ffffff',
        defaultBorder: 'border:5px solid white',
        triangleup: 'width: 0;height: 0;border-left: 50px solid transparent;border-right: 50px solid transparent;border-bottom: 100px solid;',
        fontsize: 30, // unit in pixels
        height: 50, // unit in pixels
        width: 50, // unit in pixels
        fontWeight: 400, //
        charCount: 1,
        fontFamily: 'HelveticaNeue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial,Lucida Grande, sans-serif',
        base: 'data:image/svg+xml;base64,',
        radius: 'border-radius:50%;',
        custombgcolor: '',
        dynamic: 'false',
        rotatedeg: '0'
    });

    /**
     * directive to create the avatar
     * @param {type} param1
     * @param {type} param2
     */
    app.directive('ngLetterAvatar', ['defaultSettings', function (defaultSettings) {
        return {
            restrict: 'AE',
            replace: true,
            scope: {
                alphabetcolors: '=alphabetcolors',
                data: '@'
            },
            link: function (scope, element, attrs) {

                /**
                 * Populate the attribute values to params object
                 * @type type
                 */
                var params = {
                    charCount: attrs.charcount || defaultSettings.charCount,
                    data: attrs.data,
                    textColor: defaultSettings.textColor,
                    height: attrs.height || defaultSettings.height,
                    width: attrs.width || defaultSettings.width,
                    fontsize: attrs.fontsize || defaultSettings.fontsize,
                    fontWeight: attrs.fontweight || defaultSettings.fontWeight,
                    fontFamily: attrs.fontfamily || defaultSettings.fontFamily,
                    avatarBorderStyle: attrs.avatarcustomborder,
                    avatardefaultBorder: attrs.avatarborder,
                    defaultBorder: defaultSettings.defaultBorder,
                    shape: attrs.shape,
                    alphabetcolors: scope.alphabetcolors || defaultSettings.alphabetcolors,
                    avatarCustomBGColor: attrs.avatarcustombgcolor || defaultSettings.custombgcolor,
                    dynamic: attrs.dynamic || defaultSettings.dynamic,
                    rotatedeg: attrs.rotatedeg || defaultSettings.rotatedeg
                };

                /**
                 * to generate the avatar dynamically on data change, enable the below function to watch the event
                 */
                if (params.dynamic === 'true') {
                    scope.$watch('data', function () {
                        _generateLetterAvatar();
                    });
                } else {
                    _generateLetterAvatar();
                }

                function _generateLetterAvatar() {
                    var c = '';
                    if (params.charCount == 2) {
                        var _data = getFirstAndLastName(scope.data.toUpperCase());
                        if (_data) {
                            c = _data;
                        } else {
                            c = scope.data.substr(0, params.charCount).toUpperCase();
                        }
                    } else {
                        c = scope.data.substr(0, params.charCount).toUpperCase();
                    }
                    var cobj = getCharacterObject(c, params.textColor, params.fontFamily, params.fontWeight, params.fontsize);
                    var colorIndex = '';
                    var color = '';

                    /**
                     * Populate the colors according to attributes
                     */
                    if (c.charCodeAt(0) < 65) {
                        color = getRandomColors();
                    } else {
                        colorIndex = Math.floor((c.charCodeAt(0) - 65) % params.alphabetcolors.length);
                        color = params.alphabetcolors[colorIndex];
                    }

                    if (params.avatarCustomBGColor) {
                        color = params.avatarCustomBGColor;
                    }

                    var svg = getImgTag(params.width, params.height, color);
                    svg.append(cobj);
                    var lvcomponent = angular.element('<div>').append(svg.clone()).html();
                    var svgHtml = window.btoa(unescape(encodeURIComponent(lvcomponent)));
                    var component;
                    var base = defaultSettings.base;
                    var _style = '';
                    if (params.avatarBorderStyle) {
                        _style = params.avatarBorderStyle;
                    } else if (params.avatardefaultBorder) {
                        _style = params.defaultBorder;
                    }

                    if (params.rotatedeg != '0') {
                        _style = '-ms-transform: rotate(' + params.rotatedeg + 'deg); -webkit-transform: rotate(' + params.rotatedeg + 'deg); transform: rotate(' + params.rotatedeg + 'deg)';
                    }

                    if (params.shape) {
                        if (params.shape === 'round') {
                            var round_style = defaultSettings.radius + _style;
                            if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                                var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                                component = "<img src=" + scope.data + " style='" + img_size + round_style + "'  />";
                            } else {
                                component = "<img src=" + base + svgHtml + " style='" + round_style + "' title='" + scope.data + "' />";
                            }
                        }
                    } else {
                        if (scope.data.indexOf('http') > -1 || scope.data.indexOf('data:image') > -1) {
                            var img_size = 'width:' + params.width + 'px;height:' + params.height + 'px;';
                            component = "<img src=" + scope.data + " style='" + img_size + _style + "'  />";
                        } else {
                            component = "<img src=" + base + svgHtml + " style='" + _style + "' title='" + scope.data + "' />";
                        }
                    }

                    if (params.dynamic === 'true') {
                        element.empty();
                        element.append(component);
                    } else {
                        element.replaceWith(component);
                    }
                }
            }
        };
    }]);
    /**
     * Get the random colors
     * @returns {String}
     */
    function getRandomColors() {
        var letters = '0123456789ABCDEF'.split('');
        var _color = '#';
        for (var i = 0; i < 6; i++) {
            _color += letters[Math.floor(Math.random() * 16)];
        }
        return _color;
    }
    /**
     * get the first name and last name first letters and combined and form the letter avatar
     * @param {type} data
     * @returns {unresolved}
     */
    function getFirstAndLastName(data) {
        var names = data.split(" ");
        if (names && names.length >= 2) {
            var firstName = names[0];
            var lastName = names[1];
            if (firstName && lastName) {
                var text = firstName.substr(0, 1) + lastName.substr(0, 1);
                return text;
            } else {
                return data.substr(0, 2);
            }
        }
    }

    /**
     * Populate the svg tag which will used for the avatar generation
     * @param {type} width
     * @param {type} height
     * @param {type} color
     * @returns {unresolved}
     */
    function getImgTag(width, height, color) {

        var svgTag = angular.element('<svg></svg>')
                .attr({
                    'xmlns': 'http://www.w3.org/2000/svg',
                    'pointer-events': 'none',
                    'width': width,
                    'height': height
                })
                .css({
                    'background-color': color,
                    'width': width + 'px',
                    'height': height + 'px'
                });

        return svgTag;
    }

    /**
     *  Generate the Letter tag by using the svg text element
     * @param {type} character
     * @param {type} textColor
     * @param {type} fontFamily
     * @param {type} fontWeight
     * @param {type} fontsize
     * @returns {unresolved}
     */
    function getCharacterObject(character, textColor, fontFamily, fontWeight, fontsize) {
        var textTag = angular.element('<text text-anchor="middle"></text>')
                .attr({
                    'y': '50%',
                    'x': '50%',
                    'dy': '0.35em',
                    //'stroke': '#000000',
                    'pointer-events': 'auto',
                    'fill': textColor,
                    'font-family': fontFamily
                })
                .html(character)
                .css({
                    'font-weight': fontWeight,
                    'font-size': fontsize + 'px',
                });

        return textTag;
    }

}



}).call(this,require("pBGvAp"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/posts/services.js","/posts")
},{"buffer":11,"pBGvAp":74}]},{},[100])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iYXNlLXgvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvYmlnaS9saWIvYmlnaS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iaWdpL2xpYi9jb252ZXJ0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2JpZ2kvcGFja2FnZS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ieXRlYnVmZmVyL2Rpc3QvYnl0ZWJ1ZmZlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaC9icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL2hlbHBlcnMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyZWF0ZS1obWFjL2Jyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY2lwaGVyLWNvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1iYXNlNjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2VuYy1oZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXAvY3VycmVuY3ktc3ltYm9sLW1hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwL21hcC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvY3VydmUuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9jdXJ2ZXMuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWIvbmFtZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9wb2ludC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpbkNvbmZpZy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpblZhbGlkYXRpb24uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9OdW1iZXJVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL09iamVjdElkLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvVHJhbnNhY3Rpb25IZWxwZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9CcmFpbktleS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9LZXlVdGlscy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9Qcml2YXRlS2V5LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL1B1YmxpY0tleS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9hZGRyZXNzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2Flcy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lY2RzYS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lY3NpZ25hdHVyZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lbmZvcmNlX3R5cGVzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL2hhc2guanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvc2lnbmF0dXJlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvRmFzdFBhcnNlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24uanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL2Vycm9yX3dpdGhfY2F1c2UuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL251bWJlclV0aWxzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9vcGVyYXRpb25zLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvdHlwZXMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9sb25nL2Rpc3QvbG9uZy5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zZWN1cmUtcmFuZG9tL2xpYi9zZWN1cmUtcmFuZG9tLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9oYXNoLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGExLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMzg0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGE1MTIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9BcGlJbnN0YW5jZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL1N0ZWVtQXBpLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvV2ViU29ja2V0UnBjLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvaW5kZXguanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9yZWNvbm5lY3Rpbmctd2Vic29ja2V0LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3Bhc3N0aHJvdWdoLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3JlYWRhYmxlLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS93cml0YWJsZS5qcyIsIi9Vc2Vycy9tL3AvZXN0ZWVtL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL2Zha2VfY2MzODhhMzMuanMiLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvY29uZmlnLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2NvbnRyb2xsZXJzLmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2luZGV4LmpzIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvYXItU0EuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2JnLUJHLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9jcy1DWi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZGUtREUuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2RvbGFuLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9lbC1HUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZW4uanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2VzLUVTLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9mYS1JUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvZmlsLVBILmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9mci1GUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvaGUtSUwuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2hyLUhSLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9odS1IVS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvaWQtSUQuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L2l0LUlULmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9tcy1NWS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvbmwtTkwuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3BsLVBMLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9wdC1CUi5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvcHQtUFQuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3J1LVJVLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS9zdi1TRS5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL2xvY2FsZXMvcmVhZHkvdWstVUEuanNvbiIsIi9Vc2Vycy9tL3AvZXN0ZWVtL3NyYy9wb3N0cy9sb2NhbGVzL3JlYWR5L3poLUNOLmpzb24iLCIvVXNlcnMvbS9wL2VzdGVlbS9zcmMvcG9zdHMvbG9jYWxlcy9yZWFkeS96aC1UVy5qc29uIiwiL1VzZXJzL20vcC9lc3RlZW0vc3JjL3Bvc3RzL3NlcnZpY2VzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNucEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2plQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNua0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcndDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Fzc2VydFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIGJhc2UteCBlbmNvZGluZ1xuLy8gRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iczU4XG4vLyBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcbi8vIENvcHlyaWdodCAoYykgMjAxMSBHb29nbGUgSW5jXG4vLyBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBTdGVmYW4gVGhvbWFzXG4vLyBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgQml0UGF5IEluY1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIHZhciBBTFBIQUJFVF9NQVAgPSB7fVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG5cbiAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICBBTFBIQUJFVF9NQVBbQUxQSEFCRVQuY2hhckF0KGkpXSA9IGlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuXG4gICAgdmFyIGRpZ2l0cyA9IFswXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgY2FycnkgPSBzb3VyY2VbaV07IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDhcbiAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBCQVNFXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgfCAwXG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBCQVNFKVxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpIHwgMFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yICh2YXIgayA9IDA7IHNvdXJjZVtrXSA9PT0gMCAmJiBrIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgZGlnaXRzLnB1c2goMClcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgIGZvciAodmFyIGlpID0gMCwgamogPSBkaWdpdHMubGVuZ3RoIC0gMTsgaWkgPD0gamo7ICsraWksIC0tamopIHtcbiAgICAgIHZhciB0bXAgPSBBTFBIQUJFVFtkaWdpdHNbaWldXVxuICAgICAgZGlnaXRzW2lpXSA9IEFMUEhBQkVUW2RpZ2l0c1tqal1dXG4gICAgICBkaWdpdHNbampdID0gdG1wXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZ2l0cy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdXG5cbiAgICB2YXIgYnl0ZXMgPSBbMF1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gQUxQSEFCRVRfTUFQW3N0cmluZ1tpXV1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IHZhbHVlOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiBCQVNFXG4gICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmXG4gICAgICAgIGNhcnJ5ID4+PSA4XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpXG4gICAgICAgIGNhcnJ5ID4+PSA4XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IgKHZhciBrID0gMDsgc3RyaW5nW2tdID09PSBMRUFERVIgJiYgayA8IHN0cmluZy5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgIGJ5dGVzLnB1c2goMClcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXMucmV2ZXJzZSgpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmFzZS14L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jhc2UteFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcbmZ1bmN0aW9uIEJpZ0ludGVnZXIoYSwgYiwgYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmlnSW50ZWdlcikpXG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGEsIGIsIGMpXG5cbiAgaWYgKGEgIT0gbnVsbCkge1xuICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBhKSB0aGlzLmZyb21OdW1iZXIoYSwgYiwgYylcbiAgICBlbHNlIGlmIChiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgdGhpcy5mcm9tU3RyaW5nKGEsIDI1NilcbiAgICBlbHNlIHRoaXMuZnJvbVN0cmluZyhhLCBiKVxuICB9XG59XG5cbnZhciBwcm90byA9IEJpZ0ludGVnZXIucHJvdG90eXBlXG5cbi8vIGR1Y2stdHlwZWQgaXNCaWdJbnRlZ2VyXG5wcm90by5fX2JpZ2kgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5CaWdJbnRlZ2VyLmlzQmlnSW50ZWdlciA9IGZ1bmN0aW9uIChvYmosIGNoZWNrX3Zlcikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2JpZ2kgJiYgKCFjaGVja192ZXIgfHwgb2JqLl9fYmlnaSA9PT0gcHJvdG8uX19iaWdpKVxufVxuXG4vLyBCaXRzIHBlciBkaWdpdFxudmFyIGRiaXRzXG5cbi8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2Fycmllcyxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbi8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbi8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG5cbi8vIGFtMTogdXNlIGEgc2luZ2xlIG11bHQgYW5kIGRpdmlkZSB0byBnZXQgdGhlIGhpZ2ggYml0cyxcbi8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4vLyBtYXggaW50ZXJuYWwgdmFsdWUgPSAyKmR2YWx1ZV4yLTIqZHZhbHVlICg8IDJeNTMpXG5mdW5jdGlvbiBhbTEoaSwgeCwgdywgaiwgYywgbikge1xuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgdiA9IHggKiB0aGlzW2krK10gKyB3W2pdICsgY1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyAweDQwMDAwMDApXG4gICAgd1tqKytdID0gdiAmIDB4M2ZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG4vLyBhbTIgYXZvaWRzIGEgYmlnIG11bHQtYW5kLWV4dHJhY3QgY29tcGxldGVseS5cbi8vIE1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSA8PSAzMCBiZWNhdXNlIHdlIGRvIGJpdHdpc2Ugb3BzXG4vLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG5mdW5jdGlvbiBhbTIoaSwgeCwgdywgaiwgYywgbikge1xuICB2YXIgeGwgPSB4ICYgMHg3ZmZmLFxuICAgIHhoID0geCA+PiAxNVxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDdmZmZcbiAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNVxuICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsXG4gICAgbCA9IHhsICogbCArICgobSAmIDB4N2ZmZikgPDwgMTUpICsgd1tqXSArIChjICYgMHgzZmZmZmZmZilcbiAgICBjID0gKGwgPj4+IDMwKSArIChtID4+PiAxNSkgKyB4aCAqIGggKyAoYyA+Pj4gMzApXG4gICAgd1tqKytdID0gbCAmIDB4M2ZmZmZmZmZcbiAgfVxuICByZXR1cm4gY1xufVxuLy8gQWx0ZXJuYXRlbHksIHNldCBtYXggZGlnaXQgYml0cyB0byAyOCBzaW5jZSBzb21lXG4vLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG5mdW5jdGlvbiBhbTMoaSwgeCwgdywgaiwgYywgbikge1xuICB2YXIgeGwgPSB4ICYgMHgzZmZmLFxuICAgIHhoID0geCA+PiAxNFxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDNmZmZcbiAgICB2YXIgaCA9IHRoaXNbaSsrXSA+PiAxNFxuICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsXG4gICAgbCA9IHhsICogbCArICgobSAmIDB4M2ZmZikgPDwgMTQpICsgd1tqXSArIGNcbiAgICBjID0gKGwgPj4gMjgpICsgKG0gPj4gMTQpICsgeGggKiBoXG4gICAgd1tqKytdID0gbCAmIDB4ZmZmZmZmZlxuICB9XG4gIHJldHVybiBjXG59XG5cbi8vIHd0Zj9cbkJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xXG5kYml0cyA9IDI2XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHNcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxIDw8IGRiaXRzKSAtIDEpXG52YXIgRFYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EViA9ICgxIDw8IGRiaXRzKVxuXG52YXIgQklfRlAgPSA1MlxuQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLCBCSV9GUClcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAgLSBkYml0c1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyICogZGJpdHMgLSBCSV9GUFxuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIlxudmFyIEJJX1JDID0gbmV3IEFycmF5KClcbnZhciByciwgdnZcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDA7IHZ2IDw9IDk7ICsrdnYpIEJJX1JDW3JyKytdID0gdnZcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKVxuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2XG5yciA9IFwiQVwiLmNoYXJDb2RlQXQoMClcbmZvciAodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2dlxuXG5mdW5jdGlvbiBpbnQyY2hhcihuKSB7XG4gIHJldHVybiBCSV9STS5jaGFyQXQobilcbn1cblxuZnVuY3Rpb24gaW50QXQocywgaSkge1xuICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV1cbiAgcmV0dXJuIChjID09IG51bGwpID8gLTEgOiBjXG59XG5cbi8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG5mdW5jdGlvbiBibnBDb3B5VG8ocikge1xuICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHJbaV0gPSB0aGlzW2ldXG4gIHIudCA9IHRoaXMudFxuICByLnMgPSB0aGlzLnNcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG5mdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgdGhpcy50ID0gMVxuICB0aGlzLnMgPSAoeCA8IDApID8gLTEgOiAwXG4gIGlmICh4ID4gMCkgdGhpc1swXSA9IHhcbiAgZWxzZSBpZiAoeCA8IC0xKSB0aGlzWzBdID0geCArIERWXG4gIGVsc2UgdGhpcy50ID0gMFxufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgci5mcm9tSW50KGkpXG4gIHJldHVybiByXG59XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocywgYikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIga1xuICBpZiAoYiA9PSAxNikgayA9IDRcbiAgZWxzZSBpZiAoYiA9PSA4KSBrID0gM1xuICBlbHNlIGlmIChiID09IDI1NikgayA9IDg7IC8vIGJ5dGUgYXJyYXlcbiAgZWxzZSBpZiAoYiA9PSAyKSBrID0gMVxuICBlbHNlIGlmIChiID09IDMyKSBrID0gNVxuICBlbHNlIGlmIChiID09IDQpIGsgPSAyXG4gIGVsc2Uge1xuICAgIHNlbGYuZnJvbVJhZGl4KHMsIGIpXG4gICAgcmV0dXJuXG4gIH1cbiAgc2VsZi50ID0gMFxuICBzZWxmLnMgPSAwXG4gIHZhciBpID0gcy5sZW5ndGgsXG4gICAgbWkgPSBmYWxzZSxcbiAgICBzaCA9IDBcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoayA9PSA4KSA/IHNbaV0gJiAweGZmIDogaW50QXQocywgaSlcbiAgICBpZiAoeCA8IDApIHtcbiAgICAgIGlmIChzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBtaSA9IGZhbHNlXG4gICAgaWYgKHNoID09IDApXG4gICAgICBzZWxmW3NlbGYudCsrXSA9IHhcbiAgICBlbHNlIGlmIChzaCArIGsgPiBzZWxmLkRCKSB7XG4gICAgICBzZWxmW3NlbGYudCAtIDFdIHw9ICh4ICYgKCgxIDw8IChzZWxmLkRCIC0gc2gpKSAtIDEpKSA8PCBzaFxuICAgICAgc2VsZltzZWxmLnQrK10gPSAoeCA+PiAoc2VsZi5EQiAtIHNoKSlcbiAgICB9IGVsc2VcbiAgICAgIHNlbGZbc2VsZi50IC0gMV0gfD0geCA8PCBzaFxuICAgIHNoICs9IGtcbiAgICBpZiAoc2ggPj0gc2VsZi5EQikgc2ggLT0gc2VsZi5EQlxuICB9XG4gIGlmIChrID09IDggJiYgKHNbMF0gJiAweDgwKSAhPSAwKSB7XG4gICAgc2VsZi5zID0gLTFcbiAgICBpZiAoc2ggPiAwKSBzZWxmW3NlbGYudCAtIDFdIHw9ICgoMSA8PCAoc2VsZi5EQiAtIHNoKSkgLSAxKSA8PCBzaFxuICB9XG4gIHNlbGYuY2xhbXAoKVxuICBpZiAobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhzZWxmLCBzZWxmKVxufVxuXG4vLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbmZ1bmN0aW9uIGJucENsYW1wKCkge1xuICB2YXIgYyA9IHRoaXMucyAmIHRoaXMuRE1cbiAgd2hpbGUgKHRoaXMudCA+IDAgJiYgdGhpc1t0aGlzLnQgLSAxXSA9PSBjKS0tdGhpcy50XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gZ2l2ZW4gcmFkaXhcbmZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYucyA8IDApIHJldHVybiBcIi1cIiArIHNlbGYubmVnYXRlKClcbiAgICAudG9TdHJpbmcoYilcbiAgdmFyIGtcbiAgaWYgKGIgPT0gMTYpIGsgPSA0XG4gIGVsc2UgaWYgKGIgPT0gOCkgayA9IDNcbiAgZWxzZSBpZiAoYiA9PSAyKSBrID0gMVxuICBlbHNlIGlmIChiID09IDMyKSBrID0gNVxuICBlbHNlIGlmIChiID09IDQpIGsgPSAyXG4gIGVsc2UgcmV0dXJuIHNlbGYudG9SYWRpeChiKVxuICB2YXIga20gPSAoMSA8PCBrKSAtIDEsXG4gICAgZCwgbSA9IGZhbHNlLFxuICAgIHIgPSBcIlwiLFxuICAgIGkgPSBzZWxmLnRcbiAgdmFyIHAgPSBzZWxmLkRCIC0gKGkgKiBzZWxmLkRCKSAlIGtcbiAgaWYgKGktLSA+IDApIHtcbiAgICBpZiAocCA8IHNlbGYuREIgJiYgKGQgPSBzZWxmW2ldID4+IHApID4gMCkge1xuICAgICAgbSA9IHRydWVcbiAgICAgIHIgPSBpbnQyY2hhcihkKVxuICAgIH1cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICBpZiAocCA8IGspIHtcbiAgICAgICAgZCA9IChzZWxmW2ldICYgKCgxIDw8IHApIC0gMSkpIDw8IChrIC0gcClcbiAgICAgICAgZCB8PSBzZWxmWy0taV0gPj4gKHAgKz0gc2VsZi5EQiAtIGspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkID0gKHNlbGZbaV0gPj4gKHAgLT0gaykpICYga21cbiAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgIHAgKz0gc2VsZi5EQlxuICAgICAgICAgIC0taVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZCA+IDApIG0gPSB0cnVlXG4gICAgICBpZiAobSkgciArPSBpbnQyY2hhcihkKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbSA/IHIgOiBcIjBcIlxufVxuXG4vLyAocHVibGljKSAtdGhpc1xuZnVuY3Rpb24gYm5OZWdhdGUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHtcbiAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IHRoaXMubmVnYXRlKCkgOiB0aGlzXG59XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zIC0gYS5zXG4gIGlmIChyICE9IDApIHJldHVybiByXG4gIHZhciBpID0gdGhpcy50XG4gIHIgPSBpIC0gYS50XG4gIGlmIChyICE9IDApIHJldHVybiAodGhpcy5zIDwgMCkgPyAtciA6IHJcbiAgd2hpbGUgKC0taSA+PSAwKVxuICAgIGlmICgociA9IHRoaXNbaV0gLSBhW2ldKSAhPSAwKSByZXR1cm4gclxuICByZXR1cm4gMFxufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsXG4gICAgdFxuICBpZiAoKHQgPSB4ID4+PiAxNikgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAxNlxuICB9XG4gIGlmICgodCA9IHggPj4gOCkgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSA4XG4gIH1cbiAgaWYgKCh0ID0geCA+PiA0KSAhPSAwKSB7XG4gICAgeCA9IHRcbiAgICByICs9IDRcbiAgfVxuICBpZiAoKHQgPSB4ID4+IDIpICE9IDApIHtcbiAgICB4ID0gdFxuICAgIHIgKz0gMlxuICB9XG4gIGlmICgodCA9IHggPj4gMSkgIT0gMCkge1xuICAgIHggPSB0XG4gICAgciArPSAxXG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHRoZSBudW1iZXIgb2YgYml0cyBpbiBcInRoaXNcIlxuZnVuY3Rpb24gYm5CaXRMZW5ndGgoKSB7XG4gIGlmICh0aGlzLnQgPD0gMCkgcmV0dXJuIDBcbiAgcmV0dXJuIHRoaXMuREIgKiAodGhpcy50IC0gMSkgKyBuYml0cyh0aGlzW3RoaXMudCAtIDFdIF4gKHRoaXMucyAmIHRoaXMuRE0pKVxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBpbiBcInRoaXNcIlxuZnVuY3Rpb24gYm5CeXRlTGVuZ3RoKCkge1xuICByZXR1cm4gdGhpcy5iaXRMZW5ndGgoKSA+PiAzXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcbmZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLCByKSB7XG4gIHZhciBpXG4gIGZvciAoaSA9IHRoaXMudCAtIDE7IGkgPj0gMDsgLS1pKSByW2kgKyBuXSA9IHRoaXNbaV1cbiAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSByW2ldID0gMFxuICByLnQgPSB0aGlzLnQgKyBuXG4gIHIucyA9IHRoaXMuc1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuKkRCXG5mdW5jdGlvbiBibnBEUlNoaWZ0VG8obiwgcikge1xuICBmb3IgKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByW2kgLSBuXSA9IHRoaXNbaV1cbiAgci50ID0gTWF0aC5tYXgodGhpcy50IC0gbiwgMClcbiAgci5zID0gdGhpcy5zXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJucExTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBicyA9IG4gJSBzZWxmLkRCXG4gIHZhciBjYnMgPSBzZWxmLkRCIC0gYnNcbiAgdmFyIGJtID0gKDEgPDwgY2JzKSAtIDFcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gc2VsZi5EQiksXG4gICAgYyA9IChzZWxmLnMgPDwgYnMpICYgc2VsZi5ETSxcbiAgICBpXG4gIGZvciAoaSA9IHNlbGYudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgcltpICsgZHMgKyAxXSA9IChzZWxmW2ldID4+IGNicykgfCBjXG4gICAgYyA9IChzZWxmW2ldICYgYm0pIDw8IGJzXG4gIH1cbiAgZm9yIChpID0gZHMgLSAxOyBpID49IDA7IC0taSkgcltpXSA9IDBcbiAgcltkc10gPSBjXG4gIHIudCA9IHNlbGYudCArIGRzICsgMVxuICByLnMgPSBzZWxmLnNcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJucFJTaGlmdFRvKG4sIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHIucyA9IHNlbGYuc1xuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4gLyBzZWxmLkRCKVxuICBpZiAoZHMgPj0gc2VsZi50KSB7XG4gICAgci50ID0gMFxuICAgIHJldHVyblxuICB9XG4gIHZhciBicyA9IG4gJSBzZWxmLkRCXG4gIHZhciBjYnMgPSBzZWxmLkRCIC0gYnNcbiAgdmFyIGJtID0gKDEgPDwgYnMpIC0gMVxuICByWzBdID0gc2VsZltkc10gPj4gYnNcbiAgZm9yICh2YXIgaSA9IGRzICsgMTsgaSA8IHNlbGYudDsgKytpKSB7XG4gICAgcltpIC0gZHMgLSAxXSB8PSAoc2VsZltpXSAmIGJtKSA8PCBjYnNcbiAgICByW2kgLSBkc10gPSBzZWxmW2ldID4+IGJzXG4gIH1cbiAgaWYgKGJzID4gMCkgcltzZWxmLnQgLSBkcyAtIDFdIHw9IChzZWxmLnMgJiBibSkgPDwgY2JzXG4gIHIudCA9IHNlbGYudCAtIGRzXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbmZ1bmN0aW9uIGJucFN1YlRvKGEsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpID0gMCxcbiAgICBjID0gMCxcbiAgICBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGMgKz0gc2VsZltpXSAtIGFbaV1cbiAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgIGMgPj49IHNlbGYuREJcbiAgfVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgYyAtPSBhLnNcbiAgICB3aGlsZSAoaSA8IHNlbGYudCkge1xuICAgICAgYyArPSBzZWxmW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IHNlbGYuc1xuICB9IGVsc2Uge1xuICAgIGMgKz0gc2VsZi5zXG4gICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgIGMgLT0gYVtpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyAtPSBhLnNcbiAgfVxuICByLnMgPSAoYyA8IDApID8gLTEgOiAwXG4gIGlmIChjIDwgLTEpIHJbaSsrXSA9IHNlbGYuRFYgKyBjXG4gIGVsc2UgaWYgKGMgPiAwKSByW2krK10gPSBjXG4gIHIudCA9IGlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICogYSwgciAhPSB0aGlzLGEgKEhBQyAxNC4xMilcbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VG8oYSwgcikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksXG4gICAgeSA9IGEuYWJzKClcbiAgdmFyIGkgPSB4LnRcbiAgci50ID0gaSArIHkudFxuICB3aGlsZSAoLS1pID49IDApIHJbaV0gPSAwXG4gIGZvciAoaSA9IDA7IGkgPCB5LnQ7ICsraSkgcltpICsgeC50XSA9IHguYW0oMCwgeVtpXSwgciwgaSwgMCwgeC50KVxuICByLnMgPSAwXG4gIHIuY2xhbXAoKVxuICBpZiAodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIsIHIpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICB2YXIgeCA9IHRoaXMuYWJzKClcbiAgdmFyIGkgPSByLnQgPSAyICogeC50XG4gIHdoaWxlICgtLWkgPj0gMCkgcltpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IHgudCAtIDE7ICsraSkge1xuICAgIHZhciBjID0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSlcbiAgICBpZiAoKHJbaSArIHgudF0gKz0geC5hbShpICsgMSwgMiAqIHhbaV0sIHIsIDIgKiBpICsgMSwgYywgeC50IC0gaSAtIDEpKSA+PSB4LkRWKSB7XG4gICAgICByW2kgKyB4LnRdIC09IHguRFZcbiAgICAgIHJbaSArIHgudCArIDFdID0gMVxuICAgIH1cbiAgfVxuICBpZiAoci50ID4gMCkgcltyLnQgLSAxXSArPSB4LmFtKGksIHhbaV0sIHIsIDIgKiBpLCAwLCAxKVxuICByLnMgPSAwXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSwgcSwgcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHBtID0gbS5hYnMoKVxuICBpZiAocG0udCA8PSAwKSByZXR1cm5cbiAgdmFyIHB0ID0gc2VsZi5hYnMoKVxuICBpZiAocHQudCA8IHBtLnQpIHtcbiAgICBpZiAocSAhPSBudWxsKSBxLmZyb21JbnQoMClcbiAgICBpZiAociAhPSBudWxsKSBzZWxmLmNvcHlUbyhyKVxuICAgIHJldHVyblxuICB9XG4gIGlmIChyID09IG51bGwpIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHZhciB5ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB0cyA9IHNlbGYucyxcbiAgICBtcyA9IG0uc1xuICB2YXIgbnNoID0gc2VsZi5EQiAtIG5iaXRzKHBtW3BtLnQgLSAxXSk7IC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmIChuc2ggPiAwKSB7XG4gICAgcG0ubFNoaWZ0VG8obnNoLCB5KVxuICAgIHB0LmxTaGlmdFRvKG5zaCwgcilcbiAgfSBlbHNlIHtcbiAgICBwbS5jb3B5VG8oeSlcbiAgICBwdC5jb3B5VG8ocilcbiAgfVxuICB2YXIgeXMgPSB5LnRcbiAgdmFyIHkwID0geVt5cyAtIDFdXG4gIGlmICh5MCA9PSAwKSByZXR1cm5cbiAgdmFyIHl0ID0geTAgKiAoMSA8PCBzZWxmLkYxKSArICgoeXMgPiAxKSA/IHlbeXMgLSAyXSA+PiBzZWxmLkYyIDogMClcbiAgdmFyIGQxID0gc2VsZi5GViAvIHl0LFxuICAgIGQyID0gKDEgPDwgc2VsZi5GMSkgLyB5dCxcbiAgICBlID0gMSA8PCBzZWxmLkYyXG4gIHZhciBpID0gci50LFxuICAgIGogPSBpIC0geXMsXG4gICAgdCA9IChxID09IG51bGwpID8gbmV3IEJpZ0ludGVnZXIoKSA6IHFcbiAgeS5kbFNoaWZ0VG8oaiwgdClcbiAgaWYgKHIuY29tcGFyZVRvKHQpID49IDApIHtcbiAgICByW3IudCsrXSA9IDFcbiAgICByLnN1YlRvKHQsIHIpXG4gIH1cbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLCB0KVxuICB0LnN1YlRvKHksIHkpOyAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICB3aGlsZSAoeS50IDwgeXMpIHlbeS50KytdID0gMFxuICB3aGlsZSAoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyWy0taV0gPT0geTApID8gc2VsZi5ETSA6IE1hdGguZmxvb3IocltpXSAqIGQxICsgKHJbaSAtIDFdICsgZSkgKiBkMilcbiAgICBpZiAoKHJbaV0gKz0geS5hbSgwLCBxZCwgciwgaiwgMCwgeXMpKSA8IHFkKSB7IC8vIFRyeSBpdCBvdXRcbiAgICAgIHkuZGxTaGlmdFRvKGosIHQpXG4gICAgICByLnN1YlRvKHQsIHIpXG4gICAgICB3aGlsZSAocltpXSA8IC0tcWQpIHIuc3ViVG8odCwgcilcbiAgICB9XG4gIH1cbiAgaWYgKHEgIT0gbnVsbCkge1xuICAgIHIuZHJTaGlmdFRvKHlzLCBxKVxuICAgIGlmICh0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEsIHEpXG4gIH1cbiAgci50ID0geXNcbiAgci5jbGFtcCgpXG4gIGlmIChuc2ggPiAwKSByLnJTaGlmdFRvKG5zaCwgcik7IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICBpZiAodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcilcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5hYnMoKVxuICAgIC5kaXZSZW1UbyhhLCBudWxsLCByKVxuICBpZiAodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLCByKVxuICByZXR1cm4gclxufVxuXG4vLyBNb2R1bGFyIHJlZHVjdGlvbiB1c2luZyBcImNsYXNzaWNcIiBhbGdvcml0aG1cbmZ1bmN0aW9uIENsYXNzaWMobSkge1xuICB0aGlzLm0gPSBtXG59XG5cbmZ1bmN0aW9uIGNDb252ZXJ0KHgpIHtcbiAgaWYgKHgucyA8IDAgfHwgeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSByZXR1cm4geC5tb2QodGhpcy5tKVxuICBlbHNlIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIGNSZXZlcnQoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBjUmVkdWNlKHgpIHtcbiAgeC5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHgpXG59XG5cbmZ1bmN0aW9uIGNNdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5mdW5jdGlvbiBjU3FyVG8oeCwgcikge1xuICB4LnNxdWFyZVRvKHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydFxuQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydFxuQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZVxuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG9cbkNsYXNzaWMucHJvdG90eXBlLnNxclRvID0gY1NxclRvXG5cbi8vIChwcm90ZWN0ZWQpIHJldHVybiBcIi0xL3RoaXMgJSAyXkRCXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXG4vLyBqdXN0aWZpY2F0aW9uOlxuLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbi8vICAgICAgICAgeHkgPSAgMStrbVxuLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4vLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXG4vLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4vLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbi8vIEpTIG11bHRpcGx5IFwib3ZlcmZsb3dzXCIgZGlmZmVyZW50bHkgZnJvbSBDL0MrKywgc28gY2FyZSBpcyBuZWVkZWQgaGVyZS5cbmZ1bmN0aW9uIGJucEludkRpZ2l0KCkge1xuICBpZiAodGhpcy50IDwgMSkgcmV0dXJuIDBcbiAgdmFyIHggPSB0aGlzWzBdXG4gIGlmICgoeCAmIDEpID09IDApIHJldHVybiAwXG4gIHZhciB5ID0geCAmIDM7IC8vIHkgPT0gMS94IG1vZCAyXjJcbiAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZikgKiB5KSkgJiAweGY7IC8vIHkgPT0gMS94IG1vZCAyXjRcbiAgeSA9ICh5ICogKDIgLSAoeCAmIDB4ZmYpICogeSkpICYgMHhmZjsgLy8geSA9PSAxL3ggbW9kIDJeOFxuICB5ID0gKHkgKiAoMiAtICgoKHggJiAweGZmZmYpICogeSkgJiAweGZmZmYpKSkgJiAweGZmZmY7IC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseVxuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5ICogKDIgLSB4ICogeSAlIHRoaXMuRFYpKSAlIHRoaXMuRFY7IC8vIHkgPT0gMS94IG1vZCAyXmRiaXRzXG4gIC8vIHdlIHJlYWxseSB3YW50IHRoZSBuZWdhdGl2ZSBpbnZlcnNlLCBhbmQgLURWIDwgeSA8IERWXG4gIHJldHVybiAoeSA+IDApID8gdGhpcy5EViAtIHkgOiAteVxufVxuXG4vLyBNb250Z29tZXJ5IHJlZHVjdGlvblxuZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XG4gIHRoaXMubSA9IG1cbiAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKVxuICB0aGlzLm1wbCA9IHRoaXMubXAgJiAweDdmZmZcbiAgdGhpcy5tcGggPSB0aGlzLm1wID4+IDE1XG4gIHRoaXMudW0gPSAoMSA8PCAobS5EQiAtIDE1KSkgLSAxXG4gIHRoaXMubXQyID0gMiAqIG0udFxufVxuXG4vLyB4UiBtb2QgbVxuZnVuY3Rpb24gbW9udENvbnZlcnQoeCkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgeC5hYnMoKVxuICAgIC5kbFNoaWZ0VG8odGhpcy5tLnQsIHIpXG4gIHIuZGl2UmVtVG8odGhpcy5tLCBudWxsLCByKVxuICBpZiAoeC5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgdGhpcy5tLnN1YlRvKHIsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIHgvUiBtb2QgbVxuZnVuY3Rpb24gbW9udFJldmVydCh4KSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB4LmNvcHlUbyhyKVxuICB0aGlzLnJlZHVjZShyKVxuICByZXR1cm4gclxufVxuXG4vLyB4ID0geC9SIG1vZCBtIChIQUMgMTQuMzIpXG5mdW5jdGlvbiBtb250UmVkdWNlKHgpIHtcbiAgd2hpbGUgKHgudCA8PSB0aGlzLm10MikgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgeFt4LnQrK10gPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4W2ldKm1wIG1vZCBEVlxuICAgIHZhciBqID0geFtpXSAmIDB4N2ZmZlxuICAgIHZhciB1MCA9IChqICogdGhpcy5tcGwgKyAoKChqICogdGhpcy5tcGggKyAoeFtpXSA+PiAxNSkgKiB0aGlzLm1wbCkgJiB0aGlzLnVtKSA8PCAxNSkpICYgeC5ETVxuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpICsgdGhpcy5tLnRcbiAgICB4W2pdICs9IHRoaXMubS5hbSgwLCB1MCwgeCwgaSwgMCwgdGhpcy5tLnQpXG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUgKHhbal0gPj0geC5EVikge1xuICAgICAgeFtqXSAtPSB4LkRWXG4gICAgICB4Wysral0rK1xuICAgIH1cbiAgfVxuICB4LmNsYW1wKClcbiAgeC5kclNoaWZ0VG8odGhpcy5tLnQsIHgpXG4gIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLCB4KVxufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgsIHksIHIpIHtcbiAgeC5tdWx0aXBseVRvKHksIHIpXG4gIHRoaXMucmVkdWNlKHIpXG59XG5cbk1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydFxuTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydFxuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZVxuTW9udGdvbWVyeS5wcm90b3R5cGUubXVsVG8gPSBtb250TXVsVG9cbk1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvXG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkge1xuICByZXR1cm4gKCh0aGlzLnQgPiAwKSA/ICh0aGlzWzBdICYgMSkgOiB0aGlzLnMpID09IDBcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUsIHopIHtcbiAgaWYgKGUgPiAweGZmZmZmZmZmIHx8IGUgPCAxKSByZXR1cm4gQmlnSW50ZWdlci5PTkVcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpLFxuICAgIHIyID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICBnID0gei5jb252ZXJ0KHRoaXMpLFxuICAgIGkgPSBuYml0cyhlKSAtIDFcbiAgZy5jb3B5VG8ocilcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLCByMilcbiAgICBpZiAoKGUgJiAoMSA8PCBpKSkgPiAwKSB6Lm11bFRvKHIyLCBnLCByKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHQgPSByXG4gICAgICByID0gcjJcbiAgICAgIHIyID0gdFxuICAgIH1cbiAgfVxuICByZXR1cm4gei5yZXZlcnQocilcbn1cblxuLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSwgbSkge1xuICB2YXIgelxuICBpZiAoZSA8IDI1NiB8fCBtLmlzRXZlbigpKSB6ID0gbmV3IENsYXNzaWMobSlcbiAgZWxzZSB6ID0gbmV3IE1vbnRnb21lcnkobSlcbiAgcmV0dXJuIHRoaXMuZXhwKGUsIHopXG59XG5cbi8vIHByb3RlY3RlZFxucHJvdG8uY29weVRvID0gYm5wQ29weVRvXG5wcm90by5mcm9tSW50ID0gYm5wRnJvbUludFxucHJvdG8uZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmdcbnByb3RvLmNsYW1wID0gYm5wQ2xhbXBcbnByb3RvLmRsU2hpZnRUbyA9IGJucERMU2hpZnRUb1xucHJvdG8uZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvXG5wcm90by5sU2hpZnRUbyA9IGJucExTaGlmdFRvXG5wcm90by5yU2hpZnRUbyA9IGJucFJTaGlmdFRvXG5wcm90by5zdWJUbyA9IGJucFN1YlRvXG5wcm90by5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUb1xucHJvdG8uc3F1YXJlVG8gPSBibnBTcXVhcmVUb1xucHJvdG8uZGl2UmVtVG8gPSBibnBEaXZSZW1Ub1xucHJvdG8uaW52RGlnaXQgPSBibnBJbnZEaWdpdFxucHJvdG8uaXNFdmVuID0gYm5wSXNFdmVuXG5wcm90by5leHAgPSBibnBFeHBcblxuLy8gcHVibGljXG5wcm90by50b1N0cmluZyA9IGJuVG9TdHJpbmdcbnByb3RvLm5lZ2F0ZSA9IGJuTmVnYXRlXG5wcm90by5hYnMgPSBibkFic1xucHJvdG8uY29tcGFyZVRvID0gYm5Db21wYXJlVG9cbnByb3RvLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoXG5wcm90by5ieXRlTGVuZ3RoID0gYm5CeXRlTGVuZ3RoXG5wcm90by5tb2QgPSBibk1vZFxucHJvdG8ubW9kUG93SW50ID0gYm5Nb2RQb3dJbnRcblxuLy8gKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmNvcHlUbyhyKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuZnVuY3Rpb24gYm5JbnRWYWx1ZSgpIHtcbiAgaWYgKHRoaXMucyA8IDApIHtcbiAgICBpZiAodGhpcy50ID09IDEpIHJldHVybiB0aGlzWzBdIC0gdGhpcy5EVlxuICAgIGVsc2UgaWYgKHRoaXMudCA9PSAwKSByZXR1cm4gLTFcbiAgfSBlbHNlIGlmICh0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF1cbiAgZWxzZSBpZiAodGhpcy50ID09IDApIHJldHVybiAwXG4gIC8vIGFzc3VtZXMgMTYgPCBEQiA8IDMyXG4gIHJldHVybiAoKHRoaXNbMV0gJiAoKDEgPDwgKDMyIC0gdGhpcy5EQikpIC0gMSkpIDw8IHRoaXMuREIpIHwgdGhpc1swXVxufVxuXG4vLyAocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7XG4gIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMjQpID4+IDI0XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7XG4gIHJldHVybiAodGhpcy50ID09IDApID8gdGhpcy5zIDogKHRoaXNbMF0gPDwgMTYpID4+IDE2XG59XG5cbi8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yICogdGhpcy5EQiAvIE1hdGgubG9nKHIpKVxufVxuXG4vLyAocHVibGljKSAwIGlmIHRoaXMgPT0gMCwgMSBpZiB0aGlzID4gMFxuZnVuY3Rpb24gYm5TaWdOdW0oKSB7XG4gIGlmICh0aGlzLnMgPCAwKSByZXR1cm4gLTFcbiAgZWxzZSBpZiAodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHJldHVybiAwXG4gIGVsc2UgcmV0dXJuIDFcbn1cblxuLy8gKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuICBpZiAoYiA9PSBudWxsKSBiID0gMTBcbiAgaWYgKHRoaXMuc2lnbnVtKCkgPT0gMCB8fCBiIDwgMiB8fCBiID4gMzYpIHJldHVybiBcIjBcIlxuICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKVxuICB2YXIgYSA9IE1hdGgucG93KGIsIGNzKVxuICB2YXIgZCA9IG5idihhKSxcbiAgICB5ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB6ID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICByID0gXCJcIlxuICB0aGlzLmRpdlJlbVRvKGQsIHksIHopXG4gIHdoaWxlICh5LnNpZ251bSgpID4gMCkge1xuICAgIHIgPSAoYSArIHouaW50VmFsdWUoKSlcbiAgICAgIC50b1N0cmluZyhiKVxuICAgICAgLnN1YnN0cigxKSArIHJcbiAgICB5LmRpdlJlbVRvKGQsIHksIHopXG4gIH1cbiAgcmV0dXJuIHouaW50VmFsdWUoKVxuICAgIC50b1N0cmluZyhiKSArIHJcbn1cblxuLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wRnJvbVJhZGl4KHMsIGIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuZnJvbUludCgwKVxuICBpZiAoYiA9PSBudWxsKSBiID0gMTBcbiAgdmFyIGNzID0gc2VsZi5jaHVua1NpemUoYilcbiAgdmFyIGQgPSBNYXRoLnBvdyhiLCBjcyksXG4gICAgbWkgPSBmYWxzZSxcbiAgICBqID0gMCxcbiAgICB3ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgeCA9IGludEF0KHMsIGkpXG4gICAgaWYgKHggPCAwKSB7XG4gICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgc2VsZi5zaWdudW0oKSA9PSAwKSBtaSA9IHRydWVcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHcgPSBiICogdyArIHhcbiAgICBpZiAoKytqID49IGNzKSB7XG4gICAgICBzZWxmLmRNdWx0aXBseShkKVxuICAgICAgc2VsZi5kQWRkT2Zmc2V0KHcsIDApXG4gICAgICBqID0gMFxuICAgICAgdyA9IDBcbiAgICB9XG4gIH1cbiAgaWYgKGogPiAwKSB7XG4gICAgc2VsZi5kTXVsdGlwbHkoTWF0aC5wb3coYiwgaikpXG4gICAgc2VsZi5kQWRkT2Zmc2V0KHcsIDApXG4gIH1cbiAgaWYgKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8oc2VsZiwgc2VsZilcbn1cblxuLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsIGIsIGMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gICAgaWYgKGEgPCAyKSBzZWxmLmZyb21JbnQoMSlcbiAgICBlbHNlIHtcbiAgICAgIHNlbGYuZnJvbU51bWJlcihhLCBjKVxuICAgICAgaWYgKCFzZWxmLnRlc3RCaXQoYSAtIDEpKSAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgIHNlbGYuYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhIC0gMSksIG9wX29yLCBzZWxmKVxuICAgICAgaWYgKHNlbGYuaXNFdmVuKCkpIHNlbGYuZEFkZE9mZnNldCgxLCAwKTsgLy8gZm9yY2Ugb2RkXG4gICAgICB3aGlsZSAoIXNlbGYuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgIHNlbGYuZEFkZE9mZnNldCgyLCAwKVxuICAgICAgICBpZiAoc2VsZi5iaXRMZW5ndGgoKSA+IGEpIHNlbGYuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgc2VsZilcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiAgICB2YXIgeCA9IG5ldyBBcnJheSgpLFxuICAgICAgdCA9IGEgJiA3XG4gICAgeC5sZW5ndGggPSAoYSA+PiAzKSArIDFcbiAgICBiLm5leHRCeXRlcyh4KVxuICAgIGlmICh0ID4gMCkgeFswXSAmPSAoKDEgPDwgdCkgLSAxKVxuICAgIGVsc2UgeFswXSA9IDBcbiAgICBzZWxmLmZyb21TdHJpbmcoeCwgMjU2KVxuICB9XG59XG5cbi8vIChwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcbmZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgaSA9IHNlbGYudCxcbiAgICByID0gbmV3IEFycmF5KClcbiAgclswXSA9IHNlbGYuc1xuICB2YXIgcCA9IHNlbGYuREIgLSAoaSAqIHNlbGYuREIpICUgOCxcbiAgICBkLCBrID0gMFxuICBpZiAoaS0tID4gMCkge1xuICAgIGlmIChwIDwgc2VsZi5EQiAmJiAoZCA9IHNlbGZbaV0gPj4gcCkgIT0gKHNlbGYucyAmIHNlbGYuRE0pID4+IHApXG4gICAgICByW2srK10gPSBkIHwgKHNlbGYucyA8PCAoc2VsZi5EQiAtIHApKVxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIGlmIChwIDwgOCkge1xuICAgICAgICBkID0gKHNlbGZbaV0gJiAoKDEgPDwgcCkgLSAxKSkgPDwgKDggLSBwKVxuICAgICAgICBkIHw9IHNlbGZbLS1pXSA+PiAocCArPSBzZWxmLkRCIC0gOClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSAoc2VsZltpXSA+PiAocCAtPSA4KSkgJiAweGZmXG4gICAgICAgIGlmIChwIDw9IDApIHtcbiAgICAgICAgICBwICs9IHNlbGYuREJcbiAgICAgICAgICAtLWlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChkICYgMHg4MCkgIT0gMCkgZCB8PSAtMjU2XG4gICAgICBpZiAoayA9PT0gMCAmJiAoc2VsZi5zICYgMHg4MCkgIT0gKGQgJiAweDgwKSkrK2tcbiAgICAgIGlmIChrID4gMCB8fCBkICE9IHNlbGYucykgcltrKytdID0gZFxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBibkVxdWFscyhhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPT0gMClcbn1cblxuZnVuY3Rpb24gYm5NaW4oYSkge1xuICByZXR1cm4gKHRoaXMuY29tcGFyZVRvKGEpIDwgMCkgPyB0aGlzIDogYVxufVxuXG5mdW5jdGlvbiBibk1heChhKSB7XG4gIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPiAwKSA/IHRoaXMgOiBhXG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIG9wIGEgKGJpdHdpc2UpXG5mdW5jdGlvbiBibnBCaXR3aXNlVG8oYSwgb3AsIHIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBpLCBmLCBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHJbaV0gPSBvcChzZWxmW2ldLCBhW2ldKVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgZiA9IGEucyAmIHNlbGYuRE1cbiAgICBmb3IgKGkgPSBtOyBpIDwgc2VsZi50OyArK2kpIHJbaV0gPSBvcChzZWxmW2ldLCBmKVxuICAgIHIudCA9IHNlbGYudFxuICB9IGVsc2Uge1xuICAgIGYgPSBzZWxmLnMgJiBzZWxmLkRNXG4gICAgZm9yIChpID0gbTsgaSA8IGEudDsgKytpKSByW2ldID0gb3AoZiwgYVtpXSlcbiAgICByLnQgPSBhLnRcbiAgfVxuICByLnMgPSBvcChzZWxmLnMsIGEucylcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCwgeSkge1xuICByZXR1cm4geCAmIHlcbn1cblxuZnVuY3Rpb24gYm5BbmQoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5iaXR3aXNlVG8oYSwgb3BfYW5kLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzIHwgYVxuZnVuY3Rpb24gb3Bfb3IoeCwgeSkge1xuICByZXR1cm4geCB8IHlcbn1cblxuZnVuY3Rpb24gYm5PcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9vciwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBeIGFcbmZ1bmN0aW9uIG9wX3hvcih4LCB5KSB7XG4gIHJldHVybiB4IF4geVxufVxuXG5mdW5jdGlvbiBiblhvcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF94b3IsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgsIHkpIHtcbiAgcmV0dXJuIHggJiB+eVxufVxuXG5mdW5jdGlvbiBibkFuZE5vdChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmRub3QsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIH50aGlzXG5mdW5jdGlvbiBibk5vdCgpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHJbaV0gPSB0aGlzLkRNICYgfnRoaXNbaV1cbiAgci50ID0gdGhpcy50XG4gIHIucyA9IH50aGlzLnNcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBpZiAobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4sIHIpXG4gIGVsc2UgdGhpcy5sU2hpZnRUbyhuLCByKVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJuU2hpZnRSaWdodChuKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICBpZiAobiA8IDApIHRoaXMubFNoaWZ0VG8oLW4sIHIpXG4gIGVsc2UgdGhpcy5yU2hpZnRUbyhuLCByKVxuICByZXR1cm4gclxufVxuXG4vLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5mdW5jdGlvbiBsYml0KHgpIHtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC0xXG4gIHZhciByID0gMFxuICBpZiAoKHggJiAweGZmZmYpID09IDApIHtcbiAgICB4ID4+PSAxNlxuICAgIHIgKz0gMTZcbiAgfVxuICBpZiAoKHggJiAweGZmKSA9PSAwKSB7XG4gICAgeCA+Pj0gOFxuICAgIHIgKz0gOFxuICB9XG4gIGlmICgoeCAmIDB4ZikgPT0gMCkge1xuICAgIHggPj49IDRcbiAgICByICs9IDRcbiAgfVxuICBpZiAoKHggJiAzKSA9PSAwKSB7XG4gICAgeCA+Pj0gMlxuICAgIHIgKz0gMlxuICB9XG4gIGlmICgoeCAmIDEpID09IDApKytyXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpXG4gICAgaWYgKHRoaXNbaV0gIT0gMCkgcmV0dXJuIGkgKiB0aGlzLkRCICsgbGJpdCh0aGlzW2ldKVxuICBpZiAodGhpcy5zIDwgMCkgcmV0dXJuIHRoaXMudCAqIHRoaXMuREJcbiAgcmV0dXJuIC0xXG59XG5cbi8vIHJldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcbmZ1bmN0aW9uIGNiaXQoeCkge1xuICB2YXIgciA9IDBcbiAgd2hpbGUgKHggIT0gMCkge1xuICAgIHggJj0geCAtIDFcbiAgICArK3JcbiAgfVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSByZXR1cm4gbnVtYmVyIG9mIHNldCBiaXRzXG5mdW5jdGlvbiBibkJpdENvdW50KCkge1xuICB2YXIgciA9IDAsXG4gICAgeCA9IHRoaXMucyAmIHRoaXMuRE1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgciArPSBjYml0KHRoaXNbaV0gXiB4KVxuICByZXR1cm4gclxufVxuXG4vLyAocHVibGljKSB0cnVlIGlmZiBudGggYml0IGlzIHNldFxuZnVuY3Rpb24gYm5UZXN0Qml0KG4pIHtcbiAgdmFyIGogPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKVxuICBpZiAoaiA+PSB0aGlzLnQpIHJldHVybiAodGhpcy5zICE9IDApXG4gIHJldHVybiAoKHRoaXNbal0gJiAoMSA8PCAobiAlIHRoaXMuREIpKSkgIT0gMClcbn1cblxuLy8gKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbmZ1bmN0aW9uIGJucENoYW5nZUJpdChuLCBvcCkge1xuICB2YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKVxuICB0aGlzLmJpdHdpc2VUbyhyLCBvcCwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuZnVuY3Rpb24gYm5TZXRCaXQobikge1xuICByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobiwgb3Bfb3IpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXG5mdW5jdGlvbiBibkNsZWFyQml0KG4pIHtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX2FuZG5vdClcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHtcbiAgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sIG9wX3hvcilcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG5mdW5jdGlvbiBibnBBZGRUbyhhLCByKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBpID0gMCxcbiAgICBjID0gMCxcbiAgICBtID0gTWF0aC5taW4oYS50LCBzZWxmLnQpXG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGMgKz0gc2VsZltpXSArIGFbaV1cbiAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgIGMgPj49IHNlbGYuREJcbiAgfVxuICBpZiAoYS50IDwgc2VsZi50KSB7XG4gICAgYyArPSBhLnNcbiAgICB3aGlsZSAoaSA8IHNlbGYudCkge1xuICAgICAgYyArPSBzZWxmW2ldXG4gICAgICByW2krK10gPSBjICYgc2VsZi5ETVxuICAgICAgYyA+Pj0gc2VsZi5EQlxuICAgIH1cbiAgICBjICs9IHNlbGYuc1xuICB9IGVsc2Uge1xuICAgIGMgKz0gc2VsZi5zXG4gICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgIGMgKz0gYVtpXVxuICAgICAgcltpKytdID0gYyAmIHNlbGYuRE1cbiAgICAgIGMgPj49IHNlbGYuREJcbiAgICB9XG4gICAgYyArPSBhLnNcbiAgfVxuICByLnMgPSAoYyA8IDApID8gLTEgOiAwXG4gIGlmIChjID4gMCkgcltpKytdID0gY1xuICBlbHNlIGlmIChjIDwgLTEpIHJbaSsrXSA9IHNlbGYuRFYgKyBjXG4gIHIudCA9IGlcbiAgci5jbGFtcCgpXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgKyBhXG5mdW5jdGlvbiBibkFkZChhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmFkZFRvKGEsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHtcbiAgdmFyIHIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMuc3ViVG8oYSwgcilcbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgdGhpcyAqIGFcbmZ1bmN0aW9uIGJuTXVsdGlwbHkoYSkge1xuICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5tdWx0aXBseVRvKGEsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXNeMlxuZnVuY3Rpb24gYm5TcXVhcmUoKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLnNxdWFyZVRvKHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgLyBhXG5mdW5jdGlvbiBibkRpdmlkZShhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIHIsIG51bGwpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIHRoaXMgJSBhXG5mdW5jdGlvbiBiblJlbWFpbmRlcihhKSB7XG4gIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICB0aGlzLmRpdlJlbVRvKGEsIG51bGwsIHIpXG4gIHJldHVybiByXG59XG5cbi8vIChwdWJsaWMpIFt0aGlzL2EsdGhpcyVhXVxuZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSkge1xuICB2YXIgcSA9IG5ldyBCaWdJbnRlZ2VyKCksXG4gICAgciA9IG5ldyBCaWdJbnRlZ2VyKClcbiAgdGhpcy5kaXZSZW1UbyhhLCBxLCByKVxuICByZXR1cm4gbmV3IEFycmF5KHEsIHIpXG59XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXMgKj0gbiwgdGhpcyA+PSAwLCAxIDwgbiA8IERWXG5mdW5jdGlvbiBibnBETXVsdGlwbHkobikge1xuICB0aGlzW3RoaXMudF0gPSB0aGlzLmFtKDAsIG4gLSAxLCB0aGlzLCAwLCAwLCB0aGlzLnQpXG4gICsrdGhpcy50XG4gIHRoaXMuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG5mdW5jdGlvbiBibnBEQWRkT2Zmc2V0KG4sIHcpIHtcbiAgaWYgKG4gPT0gMCkgcmV0dXJuXG4gIHdoaWxlICh0aGlzLnQgPD0gdykgdGhpc1t0aGlzLnQrK10gPSAwXG4gIHRoaXNbd10gKz0gblxuICB3aGlsZSAodGhpc1t3XSA+PSB0aGlzLkRWKSB7XG4gICAgdGhpc1t3XSAtPSB0aGlzLkRWXG4gICAgaWYgKCsrdyA+PSB0aGlzLnQpIHRoaXNbdGhpcy50KytdID0gMFxuICAgICsrdGhpc1t3XVxuICB9XG59XG5cbi8vIEEgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5cbmZ1bmN0aW9uIG5Ob3AoeCkge1xuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBuTXVsVG8oeCwgeSwgcikge1xuICB4Lm11bHRpcGx5VG8oeSwgcilcbn1cblxuZnVuY3Rpb24gblNxclRvKHgsIHIpIHtcbiAgeC5zcXVhcmVUbyhyKVxufVxuXG5OdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gbk5vcFxuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcFxuTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG9cbk51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvXG5cbi8vIChwdWJsaWMpIHRoaXNeZVxuZnVuY3Rpb24gYm5Qb3coZSkge1xuICByZXR1cm4gdGhpcy5leHAoZSwgbmV3IE51bGxFeHAoKSlcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsIG4sIHIpIHtcbiAgdmFyIGkgPSBNYXRoLm1pbih0aGlzLnQgKyBhLnQsIG4pXG4gIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgci50ID0gaVxuICB3aGlsZSAoaSA+IDApIHJbLS1pXSA9IDBcbiAgdmFyIGpcbiAgZm9yIChqID0gci50IC0gdGhpcy50OyBpIDwgajsgKytpKSByW2kgKyB0aGlzLnRdID0gdGhpcy5hbSgwLCBhW2ldLCByLCBpLCAwLCB0aGlzLnQpXG4gIGZvciAoaiA9IE1hdGgubWluKGEudCwgbik7IGkgPCBqOyArK2kpIHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgbiAtIGkpXG4gIHIuY2xhbXAoKVxufVxuXG4vLyAocHJvdGVjdGVkKSByID0gXCJ0aGlzICogYVwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcbi8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbmZ1bmN0aW9uIGJucE11bHRpcGx5VXBwZXJUbyhhLCBuLCByKSB7XG4gIC0tblxuICB2YXIgaSA9IHIudCA9IHRoaXMudCArIGEudCAtIG5cbiAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICB3aGlsZSAoLS1pID49IDApIHJbaV0gPSAwXG4gIGZvciAoaSA9IE1hdGgubWF4KG4gLSB0aGlzLnQsIDApOyBpIDwgYS50OyArK2kpXG4gICAgclt0aGlzLnQgKyBpIC0gbl0gPSB0aGlzLmFtKG4gLSBpLCBhW2ldLCByLCAwLCAwLCB0aGlzLnQgKyBpIC0gbilcbiAgci5jbGFtcCgpXG4gIHIuZHJTaGlmdFRvKDEsIHIpXG59XG5cbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cbmZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAvLyBzZXR1cCBCYXJyZXR0XG4gIHRoaXMucjIgPSBuZXcgQmlnSW50ZWdlcigpXG4gIHRoaXMucTMgPSBuZXcgQmlnSW50ZWdlcigpXG4gIEJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyICogbS50LCB0aGlzLnIyKVxuICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSlcbiAgdGhpcy5tID0gbVxufVxuXG5mdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KSB7XG4gIGlmICh4LnMgPCAwIHx8IHgudCA+IDIgKiB0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSlcbiAgZWxzZSBpZiAoeC5jb21wYXJlVG8odGhpcy5tKSA8IDApIHJldHVybiB4XG4gIGVsc2Uge1xuICAgIHZhciByID0gbmV3IEJpZ0ludGVnZXIoKVxuICAgIHguY29weVRvKHIpXG4gICAgdGhpcy5yZWR1Y2UocilcbiAgICByZXR1cm4gclxuICB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkge1xuICByZXR1cm4geFxufVxuXG4vLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB4LmRyU2hpZnRUbyhzZWxmLm0udCAtIDEsIHNlbGYucjIpXG4gIGlmICh4LnQgPiBzZWxmLm0udCArIDEpIHtcbiAgICB4LnQgPSBzZWxmLm0udCArIDFcbiAgICB4LmNsYW1wKClcbiAgfVxuICBzZWxmLm11Lm11bHRpcGx5VXBwZXJUbyhzZWxmLnIyLCBzZWxmLm0udCArIDEsIHNlbGYucTMpXG4gIHNlbGYubS5tdWx0aXBseUxvd2VyVG8oc2VsZi5xMywgc2VsZi5tLnQgKyAxLCBzZWxmLnIyKVxuICB3aGlsZSAoeC5jb21wYXJlVG8oc2VsZi5yMikgPCAwKSB4LmRBZGRPZmZzZXQoMSwgc2VsZi5tLnQgKyAxKVxuICB4LnN1YlRvKHNlbGYucjIsIHgpXG4gIHdoaWxlICh4LmNvbXBhcmVUbyhzZWxmLm0pID49IDApIHguc3ViVG8oc2VsZi5tLCB4KVxufVxuXG4vLyByID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LCByKSB7XG4gIHguc3F1YXJlVG8ocilcbiAgdGhpcy5yZWR1Y2Uocilcbn1cblxuLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LCB5LCByKSB7XG4gIHgubXVsdGlwbHlUbyh5LCByKVxuICB0aGlzLnJlZHVjZShyKVxufVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnRcbkJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGJhcnJldHRSZXZlcnRcbkJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2VcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvXG5CYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUb1xuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtIChIQUMgMTQuODUpXG5mdW5jdGlvbiBibk1vZFBvdyhlLCBtKSB7XG4gIHZhciBpID0gZS5iaXRMZW5ndGgoKSxcbiAgICBrLCByID0gbmJ2KDEpLFxuICAgIHpcbiAgaWYgKGkgPD0gMCkgcmV0dXJuIHJcbiAgZWxzZSBpZiAoaSA8IDE4KSBrID0gMVxuICBlbHNlIGlmIChpIDwgNDgpIGsgPSAzXG4gIGVsc2UgaWYgKGkgPCAxNDQpIGsgPSA0XG4gIGVsc2UgaWYgKGkgPCA3NjgpIGsgPSA1XG4gIGVsc2UgayA9IDZcbiAgaWYgKGkgPCA4KVxuICAgIHogPSBuZXcgQ2xhc3NpYyhtKVxuICBlbHNlIGlmIChtLmlzRXZlbigpKVxuICAgIHogPSBuZXcgQmFycmV0dChtKVxuICBlbHNlXG4gICAgeiA9IG5ldyBNb250Z29tZXJ5KG0pXG5cbiAgLy8gcHJlY29tcHV0YXRpb25cbiAgdmFyIGcgPSBuZXcgQXJyYXkoKSxcbiAgICBuID0gMyxcbiAgICBrMSA9IGsgLSAxLFxuICAgIGttID0gKDEgPDwgaykgLSAxXG4gIGdbMV0gPSB6LmNvbnZlcnQodGhpcylcbiAgaWYgKGsgPiAxKSB7XG4gICAgdmFyIGcyID0gbmV3IEJpZ0ludGVnZXIoKVxuICAgIHouc3FyVG8oZ1sxXSwgZzIpXG4gICAgd2hpbGUgKG4gPD0ga20pIHtcbiAgICAgIGdbbl0gPSBuZXcgQmlnSW50ZWdlcigpXG4gICAgICB6Lm11bFRvKGcyLCBnW24gLSAyXSwgZ1tuXSlcbiAgICAgIG4gKz0gMlxuICAgIH1cbiAgfVxuXG4gIHZhciBqID0gZS50IC0gMSxcbiAgICB3LCBpczEgPSB0cnVlLFxuICAgIHIyID0gbmV3IEJpZ0ludGVnZXIoKSxcbiAgICB0XG4gIGkgPSBuYml0cyhlW2pdKSAtIDFcbiAgd2hpbGUgKGogPj0gMCkge1xuICAgIGlmIChpID49IGsxKSB3ID0gKGVbal0gPj4gKGkgLSBrMSkpICYga21cbiAgICBlbHNlIHtcbiAgICAgIHcgPSAoZVtqXSAmICgoMSA8PCAoaSArIDEpKSAtIDEpKSA8PCAoazEgLSBpKVxuICAgICAgaWYgKGogPiAwKSB3IHw9IGVbaiAtIDFdID4+ICh0aGlzLkRCICsgaSAtIGsxKVxuICAgIH1cblxuICAgIG4gPSBrXG4gICAgd2hpbGUgKCh3ICYgMSkgPT0gMCkge1xuICAgICAgdyA+Pj0gMVxuICAgICAgLS1uXG4gICAgfVxuICAgIGlmICgoaSAtPSBuKSA8IDApIHtcbiAgICAgIGkgKz0gdGhpcy5EQlxuICAgICAgLS1qXG4gICAgfVxuICAgIGlmIChpczEpIHsgLy8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgICAgZ1t3XS5jb3B5VG8ocilcbiAgICAgIGlzMSA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICB6LnNxclRvKHIsIHIyKVxuICAgICAgICB6LnNxclRvKHIyLCByKVxuICAgICAgICBuIC09IDJcbiAgICAgIH1cbiAgICAgIGlmIChuID4gMCkgei5zcXJUbyhyLCByMilcbiAgICAgIGVsc2Uge1xuICAgICAgICB0ID0gclxuICAgICAgICByID0gcjJcbiAgICAgICAgcjIgPSB0XG4gICAgICB9XG4gICAgICB6Lm11bFRvKHIyLCBnW3ddLCByKVxuICAgIH1cblxuICAgIHdoaWxlIChqID49IDAgJiYgKGVbal0gJiAoMSA8PCBpKSkgPT0gMCkge1xuICAgICAgei5zcXJUbyhyLCByMilcbiAgICAgIHQgPSByXG4gICAgICByID0gcjJcbiAgICAgIHIyID0gdFxuICAgICAgaWYgKC0taSA8IDApIHtcbiAgICAgICAgaSA9IHRoaXMuREIgLSAxXG4gICAgICAgIC0talxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gei5yZXZlcnQocilcbn1cblxuLy8gKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbmZ1bmN0aW9uIGJuR0NEKGEpIHtcbiAgdmFyIHggPSAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcy5jbG9uZSgpXG4gIHZhciB5ID0gKGEucyA8IDApID8gYS5uZWdhdGUoKSA6IGEuY2xvbmUoKVxuICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XG4gICAgdmFyIHQgPSB4XG4gICAgeCA9IHlcbiAgICB5ID0gdFxuICB9XG4gIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKSxcbiAgICBnID0geS5nZXRMb3dlc3RTZXRCaXQoKVxuICBpZiAoZyA8IDApIHJldHVybiB4XG4gIGlmIChpIDwgZykgZyA9IGlcbiAgaWYgKGcgPiAwKSB7XG4gICAgeC5yU2hpZnRUbyhnLCB4KVxuICAgIHkuclNoaWZ0VG8oZywgeSlcbiAgfVxuICB3aGlsZSAoeC5zaWdudW0oKSA+IDApIHtcbiAgICBpZiAoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHguclNoaWZ0VG8oaSwgeClcbiAgICBpZiAoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHkuclNoaWZ0VG8oaSwgeSlcbiAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgeC5zdWJUbyh5LCB4KVxuICAgICAgeC5yU2hpZnRUbygxLCB4KVxuICAgIH0gZWxzZSB7XG4gICAgICB5LnN1YlRvKHgsIHkpXG4gICAgICB5LnJTaGlmdFRvKDEsIHkpXG4gICAgfVxuICB9XG4gIGlmIChnID4gMCkgeS5sU2hpZnRUbyhnLCB5KVxuICByZXR1cm4geVxufVxuXG4vLyAocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbmZ1bmN0aW9uIGJucE1vZEludChuKSB7XG4gIGlmIChuIDw9IDApIHJldHVybiAwXG4gIHZhciBkID0gdGhpcy5EViAlIG4sXG4gICAgciA9ICh0aGlzLnMgPCAwKSA/IG4gLSAxIDogMFxuICBpZiAodGhpcy50ID4gMClcbiAgICBpZiAoZCA9PSAwKSByID0gdGhpc1swXSAlIG5cbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHIgPSAoZCAqIHIgKyB0aGlzW2ldKSAlIG5cbiAgcmV0dXJuIHJcbn1cblxuLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pIHtcbiAgdmFyIGFjID0gbS5pc0V2ZW4oKVxuICBpZiAodGhpcy5zaWdudW0oKSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcbiAgaWYgKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk9cbiAgdmFyIHUgPSBtLmNsb25lKCksXG4gICAgdiA9IHRoaXMuY2xvbmUoKVxuICB2YXIgYSA9IG5idigxKSxcbiAgICBiID0gbmJ2KDApLFxuICAgIGMgPSBuYnYoMCksXG4gICAgZCA9IG5idigxKVxuICB3aGlsZSAodS5zaWdudW0oKSAhPSAwKSB7XG4gICAgd2hpbGUgKHUuaXNFdmVuKCkpIHtcbiAgICAgIHUuclNoaWZ0VG8oMSwgdSlcbiAgICAgIGlmIChhYykge1xuICAgICAgICBpZiAoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICBhLmFkZFRvKHRoaXMsIGEpXG4gICAgICAgICAgYi5zdWJUbyhtLCBiKVxuICAgICAgICB9XG4gICAgICAgIGEuclNoaWZ0VG8oMSwgYSlcbiAgICAgIH0gZWxzZSBpZiAoIWIuaXNFdmVuKCkpIGIuc3ViVG8obSwgYilcbiAgICAgIGIuclNoaWZ0VG8oMSwgYilcbiAgICB9XG4gICAgd2hpbGUgKHYuaXNFdmVuKCkpIHtcbiAgICAgIHYuclNoaWZ0VG8oMSwgdilcbiAgICAgIGlmIChhYykge1xuICAgICAgICBpZiAoIWMuaXNFdmVuKCkgfHwgIWQuaXNFdmVuKCkpIHtcbiAgICAgICAgICBjLmFkZFRvKHRoaXMsIGMpXG4gICAgICAgICAgZC5zdWJUbyhtLCBkKVxuICAgICAgICB9XG4gICAgICAgIGMuclNoaWZ0VG8oMSwgYylcbiAgICAgIH0gZWxzZSBpZiAoIWQuaXNFdmVuKCkpIGQuc3ViVG8obSwgZClcbiAgICAgIGQuclNoaWZ0VG8oMSwgZClcbiAgICB9XG4gICAgaWYgKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgIHUuc3ViVG8odiwgdSlcbiAgICAgIGlmIChhYykgYS5zdWJUbyhjLCBhKVxuICAgICAgYi5zdWJUbyhkLCBiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2LnN1YlRvKHUsIHYpXG4gICAgICBpZiAoYWMpIGMuc3ViVG8oYSwgYylcbiAgICAgIGQuc3ViVG8oYiwgZClcbiAgICB9XG4gIH1cbiAgaWYgKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPXG4gIHdoaWxlIChkLmNvbXBhcmVUbyhtKSA+PSAwKSBkLnN1YlRvKG0sIGQpXG4gIHdoaWxlIChkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLCBkKVxuICByZXR1cm4gZFxufVxuXG52YXIgbG93cHJpbWVzID0gW1xuICAyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzcsIDQxLCA0MywgNDcsIDUzLCA1OSwgNjEsIDY3LCA3MSxcbiAgNzMsIDc5LCA4MywgODksIDk3LCAxMDEsIDEwMywgMTA3LCAxMDksIDExMywgMTI3LCAxMzEsIDEzNywgMTM5LCAxNDksIDE1MSxcbiAgMTU3LCAxNjMsIDE2NywgMTczLCAxNzksIDE4MSwgMTkxLCAxOTMsIDE5NywgMTk5LCAyMTEsIDIyMywgMjI3LCAyMjksIDIzMyxcbiAgMjM5LCAyNDEsIDI1MSwgMjU3LCAyNjMsIDI2OSwgMjcxLCAyNzcsIDI4MSwgMjgzLCAyOTMsIDMwNywgMzExLCAzMTMsIDMxNyxcbiAgMzMxLCAzMzcsIDM0NywgMzQ5LCAzNTMsIDM1OSwgMzY3LCAzNzMsIDM3OSwgMzgzLCAzODksIDM5NywgNDAxLCA0MDksIDQxOSxcbiAgNDIxLCA0MzEsIDQzMywgNDM5LCA0NDMsIDQ0OSwgNDU3LCA0NjEsIDQ2MywgNDY3LCA0NzksIDQ4NywgNDkxLCA0OTksIDUwMyxcbiAgNTA5LCA1MjEsIDUyMywgNTQxLCA1NDcsIDU1NywgNTYzLCA1NjksIDU3MSwgNTc3LCA1ODcsIDU5MywgNTk5LCA2MDEsIDYwNyxcbiAgNjEzLCA2MTcsIDYxOSwgNjMxLCA2NDEsIDY0MywgNjQ3LCA2NTMsIDY1OSwgNjYxLCA2NzMsIDY3NywgNjgzLCA2OTEsIDcwMSxcbiAgNzA5LCA3MTksIDcyNywgNzMzLCA3MzksIDc0MywgNzUxLCA3NTcsIDc2MSwgNzY5LCA3NzMsIDc4NywgNzk3LCA4MDksIDgxMSxcbiAgODIxLCA4MjMsIDgyNywgODI5LCA4MzksIDg1MywgODU3LCA4NTksIDg2MywgODc3LCA4ODEsIDg4MywgODg3LCA5MDcsIDkxMSxcbiAgOTE5LCA5MjksIDkzNywgOTQxLCA5NDcsIDk1MywgOTY3LCA5NzEsIDk3NywgOTgzLCA5OTEsIDk5N1xuXVxuXG52YXIgbHBsaW0gPSAoMSA8PCAyNikgLyBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdXG5cbi8vIChwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuZnVuY3Rpb24gYm5Jc1Byb2JhYmxlUHJpbWUodCkge1xuICB2YXIgaSwgeCA9IHRoaXMuYWJzKClcbiAgaWYgKHgudCA9PSAxICYmIHhbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICAgICBpZiAoeFswXSA9PSBsb3dwcmltZXNbaV0pIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKHguaXNFdmVuKCkpIHJldHVybiBmYWxzZVxuICBpID0gMVxuICB3aGlsZSAoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXSxcbiAgICAgIGogPSBpICsgMVxuICAgIHdoaWxlIChqIDwgbG93cHJpbWVzLmxlbmd0aCAmJiBtIDwgbHBsaW0pIG0gKj0gbG93cHJpbWVzW2orK11cbiAgICBtID0geC5tb2RJbnQobSlcbiAgICB3aGlsZSAoaSA8IGopIGlmIChtICUgbG93cHJpbWVzW2krK10gPT0gMCkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHgubWlsbGVyUmFiaW4odClcbn1cblxuLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZiBwcm9iYWJseSBwcmltZSAoSEFDIDQuMjQsIE1pbGxlci1SYWJpbilcbmZ1bmN0aW9uIGJucE1pbGxlclJhYmluKHQpIHtcbiAgdmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSlcbiAgdmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKVxuICBpZiAoayA8PSAwKSByZXR1cm4gZmFsc2VcbiAgdmFyIHIgPSBuMS5zaGlmdFJpZ2h0KGspXG4gIHQgPSAodCArIDEpID4+IDFcbiAgaWYgKHQgPiBsb3dwcmltZXMubGVuZ3RoKSB0ID0gbG93cHJpbWVzLmxlbmd0aFxuICB2YXIgYSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpXG4gIHZhciBqLCBiYXNlcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgaiA9IGxvd3ByaW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsb3dwcmltZXMubGVuZ3RoKV1cbiAgICAgIGlmIChiYXNlcy5pbmRleE9mKGopID09IC0xKSBicmVha1xuICAgIH1cbiAgICBiYXNlcy5wdXNoKGopXG4gICAgYS5mcm9tSW50KGopXG4gICAgdmFyIHkgPSBhLm1vZFBvdyhyLCB0aGlzKVxuICAgIGlmICh5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgdmFyIGogPSAxXG4gICAgICB3aGlsZSAoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICB5ID0geS5tb2RQb3dJbnQoMiwgdGhpcylcbiAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIHByb3RlY3RlZFxucHJvdG8uY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplXG5wcm90by50b1JhZGl4ID0gYm5wVG9SYWRpeFxucHJvdG8uZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4XG5wcm90by5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlclxucHJvdG8uYml0d2lzZVRvID0gYm5wQml0d2lzZVRvXG5wcm90by5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXRcbnByb3RvLmFkZFRvID0gYm5wQWRkVG9cbnByb3RvLmRNdWx0aXBseSA9IGJucERNdWx0aXBseVxucHJvdG8uZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXRcbnByb3RvLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUb1xucHJvdG8ubXVsdGlwbHlVcHBlclRvID0gYm5wTXVsdGlwbHlVcHBlclRvXG5wcm90by5tb2RJbnQgPSBibnBNb2RJbnRcbnByb3RvLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW5cblxuLy8gcHVibGljXG5wcm90by5jbG9uZSA9IGJuQ2xvbmVcbnByb3RvLmludFZhbHVlID0gYm5JbnRWYWx1ZVxucHJvdG8uYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWVcbnByb3RvLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWVcbnByb3RvLnNpZ251bSA9IGJuU2lnTnVtXG5wcm90by50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXlcbnByb3RvLmVxdWFscyA9IGJuRXF1YWxzXG5wcm90by5taW4gPSBibk1pblxucHJvdG8ubWF4ID0gYm5NYXhcbnByb3RvLmFuZCA9IGJuQW5kXG5wcm90by5vciA9IGJuT3JcbnByb3RvLnhvciA9IGJuWG9yXG5wcm90by5hbmROb3QgPSBibkFuZE5vdFxucHJvdG8ubm90ID0gYm5Ob3RcbnByb3RvLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0XG5wcm90by5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0XG5wcm90by5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdFxucHJvdG8uYml0Q291bnQgPSBibkJpdENvdW50XG5wcm90by50ZXN0Qml0ID0gYm5UZXN0Qml0XG5wcm90by5zZXRCaXQgPSBiblNldEJpdFxucHJvdG8uY2xlYXJCaXQgPSBibkNsZWFyQml0XG5wcm90by5mbGlwQml0ID0gYm5GbGlwQml0XG5wcm90by5hZGQgPSBibkFkZFxucHJvdG8uc3VidHJhY3QgPSBiblN1YnRyYWN0XG5wcm90by5tdWx0aXBseSA9IGJuTXVsdGlwbHlcbnByb3RvLmRpdmlkZSA9IGJuRGl2aWRlXG5wcm90by5yZW1haW5kZXIgPSBiblJlbWFpbmRlclxucHJvdG8uZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXJcbnByb3RvLm1vZFBvdyA9IGJuTW9kUG93XG5wcm90by5tb2RJbnZlcnNlID0gYm5Nb2RJbnZlcnNlXG5wcm90by5wb3cgPSBiblBvd1xucHJvdG8uZ2NkID0gYm5HQ0RcbnByb3RvLmlzUHJvYmFibGVQcmltZSA9IGJuSXNQcm9iYWJsZVByaW1lXG5cbi8vIEpTQk4tc3BlY2lmaWMgZXh0ZW5zaW9uXG5wcm90by5zcXVhcmUgPSBiblNxdWFyZVxuXG4vLyBjb25zdGFudHNcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKVxuQmlnSW50ZWdlci5PTkUgPSBuYnYoMSlcbkJpZ0ludGVnZXIudmFsdWVPZiA9IG5idlxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ0ludGVnZXJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWIvYmlnaS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaWdpL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIEZJWE1FOiBLaW5kIG9mIGEgd2VpcmQgd2F5IHRvIHRocm93IGV4Y2VwdGlvbnMsIGNvbnNpZGVyIHJlbW92aW5nXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnLi9iaWdpJylcblxuLyoqXG4gKiBUdXJucyBhIGJ5dGUgYXJyYXkgaW50byBhIGJpZyBpbnRlZ2VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBpbnRlcnByZXQgYSBieXRlIGFycmF5IGFzIGEgYmlnIGludGVnZXIgaW4gYmlnXG4gKiBlbmRpYW4gbm90YXRpb24uXG4gKi9cbkJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkID0gZnVuY3Rpb24oYnl0ZUFycmF5KSB7XG4gIC8vIEJpZ0ludGVnZXIgZXhwZWN0cyBhIERFUiBpbnRlZ2VyIGNvbmZvcm1hbnQgYnl0ZSBhcnJheVxuICBpZiAoYnl0ZUFycmF5WzBdICYgMHg4MCkge1xuICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMF0uY29uY2F0KGJ5dGVBcnJheSkpXG4gIH1cblxuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYnl0ZUFycmF5KVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWcgaW50ZWdlci5cbiAqXG4gKiBUaGlzIHJldHVybnMgdGhlIGFic29sdXRlIG9mIHRoZSBjb250YWluZWQgdmFsdWUgaW4gYmlnIGVuZGlhblxuICogZm9ybS4gQSB2YWx1ZSBvZiB6ZXJvIHJlc3VsdHMgaW4gYW4gZW1wdHkgYXJyYXkuXG4gKi9cbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5VW5zaWduZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IHRoaXMudG9CeXRlQXJyYXkoKVxuICByZXR1cm4gYnl0ZUFycmF5WzBdID09PSAwID8gYnl0ZUFycmF5LnNsaWNlKDEpIDogYnl0ZUFycmF5XG59XG5cbkJpZ0ludGVnZXIuZnJvbURFUkludGVnZXIgPSBmdW5jdGlvbihieXRlQXJyYXkpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJ5dGVBcnJheSlcbn1cblxuLypcbiAqIENvbnZlcnRzIEJpZ0ludGVnZXIgdG8gYSBERVIgaW50ZWdlciByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBUaGUgZm9ybWF0IGZvciB0aGlzIHZhbHVlIHVzZXMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGFzIGEgc2lnblxuICogYml0LiAgSWYgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIGFscmVhZHkgc2V0IGFuZCB0aGUgaW50ZWdlciBpc1xuICogcG9zaXRpdmUsIGEgMHgwMCBpcyBwcmVwZW5kZWQuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAwID0+ICAgICAweDAwXG4gKiAgICAgIDEgPT4gICAgIDB4MDFcbiAqICAgICAtMSA9PiAgICAgMHhmZlxuICogICAgMTI3ID0+ICAgICAweDdmXG4gKiAgIC0xMjcgPT4gICAgIDB4ODFcbiAqICAgIDEyOCA9PiAgIDB4MDA4MFxuICogICAtMTI4ID0+ICAgICAweDgwXG4gKiAgICAyNTUgPT4gICAweDAwZmZcbiAqICAgLTI1NSA9PiAgIDB4ZmYwMVxuICogIDE2MzAwID0+ICAgMHgzZmFjXG4gKiAtMTYzMDAgPT4gICAweGMwNTRcbiAqICA2MjMwMCA9PiAweDAwZjM1Y1xuICogLTYyMzAwID0+IDB4ZmYwY2E0XG4qL1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9ERVJJbnRlZ2VyID0gQmlnSW50ZWdlci5wcm90b3R5cGUudG9CeXRlQXJyYXlcblxuQmlnSW50ZWdlci5mcm9tQnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIEJpZ0ludGVnZXIgZXhwZWN0cyBhIERFUiBpbnRlZ2VyIGNvbmZvcm1hbnQgYnl0ZSBhcnJheVxuICBpZiAoYnVmZmVyWzBdICYgMHg4MCkge1xuICAgIHZhciBieXRlQXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChidWZmZXIpXG5cbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoWzBdLmNvbmNhdChieXRlQXJyYXkpKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJ1ZmZlcilcbn1cblxuQmlnSW50ZWdlci5mcm9tSGV4ID0gZnVuY3Rpb24oaGV4KSB7XG4gIGlmIChoZXggPT09ICcnKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPXG5cbiAgYXNzZXJ0LmVxdWFsKGhleCwgaGV4Lm1hdGNoKC9eW0EtRmEtZjAtOV0rLyksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICBhc3NlcnQuZXF1YWwoaGV4Lmxlbmd0aCAlIDIsIDAsICdJbmNvbXBsZXRlIGhleCcpXG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihoZXgsIDE2KVxufVxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IHRoaXMudG9CeXRlQXJyYXlVbnNpZ25lZCgpXG4gIHZhciB6ZXJvcyA9IFtdXG5cbiAgdmFyIHBhZGRpbmcgPSBzaXplIC0gYnl0ZUFycmF5Lmxlbmd0aFxuICB3aGlsZSAoemVyb3MubGVuZ3RoIDwgcGFkZGluZykgemVyb3MucHVzaCgwKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHplcm9zLmNvbmNhdChieXRlQXJyYXkpKVxufVxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMudG9CdWZmZXIoc2l6ZSkudG9TdHJpbmcoJ2hleCcpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2NvbnZlcnQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlnaS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJy4vYmlnaScpXG5cbi8vYWRkb25zXG5yZXF1aXJlKCcuL2NvbnZlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJpZ0ludGVnZXJcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2JpZ2kvbGliXCIpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICB7XG4gICAgICAgIFwicmF3XCI6IFwiYmlnaUBeMS40LjJcIixcbiAgICAgICAgXCJzY29wZVwiOiBudWxsLFxuICAgICAgICBcImVzY2FwZWROYW1lXCI6IFwiYmlnaVwiLFxuICAgICAgICBcIm5hbWVcIjogXCJiaWdpXCIsXG4gICAgICAgIFwicmF3U3BlY1wiOiBcIl4xLjQuMlwiLFxuICAgICAgICBcInNwZWNcIjogXCI+PTEuNC4yIDwyLjAuMFwiLFxuICAgICAgICBcInR5cGVcIjogXCJyYW5nZVwiXG4gICAgICB9LFxuICAgICAgXCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1hdXRoXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJiaWdpQD49MS40LjIgPDIuMC4wXCIsXG4gIFwiX2lkXCI6IFwiYmlnaUAxLjQuMlwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2luc3RhbGxhYmxlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL2JpZ2lcIixcbiAgXCJfbm9kZVZlcnNpb25cIjogXCI2LjEuMFwiLFxuICBcIl9ucG1PcGVyYXRpb25hbEludGVybmFsXCI6IHtcbiAgICBcImhvc3RcIjogXCJwYWNrYWdlcy0xMi13ZXN0LmludGVybmFsLm5wbWpzLmNvbVwiLFxuICAgIFwidG1wXCI6IFwidG1wL2JpZ2ktMS40LjIudGd6XzE0Njk1ODQxOTI0MTNfMC42ODAxMjM4NjExODA2MTg0XCJcbiAgfSxcbiAgXCJfbnBtVXNlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwianByaWNoYXJkc29uXCIsXG4gICAgXCJlbWFpbFwiOiBcImpwcmljaGFyZHNvbkBnbWFpbC5jb21cIlxuICB9LFxuICBcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjZcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwicmF3XCI6IFwiYmlnaUBeMS40LjJcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJlc2NhcGVkTmFtZVwiOiBcImJpZ2lcIixcbiAgICBcIm5hbWVcIjogXCJiaWdpXCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiXjEuNC4yXCIsXG4gICAgXCJzcGVjXCI6IFwiPj0xLjQuMiA8Mi4wLjBcIixcbiAgICBcInR5cGVcIjogXCJyYW5nZVwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL2VjdXJ2ZVwiLFxuICAgIFwiL3N0ZWVtYXV0aFwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvYmlnaS8tL2JpZ2ktMS40LjIudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjljNjY1YTk1Zjg4YjhiMDhmYzA1Y2ZkNzMxZjU2MTg1OWQ3MjU4MjVcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwiYmlnaUBeMS40LjJcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvbS9wL2VzdGVlbS9ub2RlX21vZHVsZXMvc3RlZW1hdXRoXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge30sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJCaWcgaW50ZWdlcnMuXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNvdmVyYWxsc1wiOiBcIl4yLjExLjJcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuMy41XCIsXG4gICAgXCJqc2hpbnRcIjogXCJeMi41LjFcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJtb2NoaWZ5XCI6IFwiXjIuMS4wXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcIjljNjY1YTk1Zjg4YjhiMDhmYzA1Y2ZkNzMxZjU2MTg1OWQ3MjU4MjVcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9iaWdpLy0vYmlnaS0xLjQuMi50Z3pcIlxuICB9LFxuICBcImdpdEhlYWRcIjogXCJjMjUzMDgwODFjODk2ZmY4NDcwMjMwMzcyMmJmNWVjZDhiM2Y3OGUzXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JpZ2kjcmVhZG1lXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY3J5cHRvZ3JhcGh5XCIsXG4gICAgXCJtYXRoXCIsXG4gICAgXCJiaXRjb2luXCIsXG4gICAgXCJhcmJpdHJhcnlcIixcbiAgICBcInByZWNpc2lvblwiLFxuICAgIFwiYXJpdGhtZXRpY1wiLFxuICAgIFwiYmlnXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJpbnRcIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiYmlnaW50ZWdlclwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJiaWdudW1iZXJcIixcbiAgICBcImRlY2ltYWxcIixcbiAgICBcImZsb2F0XCJcbiAgXSxcbiAgXCJtYWluXCI6IFwiLi9saWIvaW5kZXguanNcIixcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibWlkbmlnaHRsaWdodG5pbmdcIixcbiAgICAgIFwiZW1haWxcIjogXCJib3lkYkBtaWRuaWdodGRlc2lnbi53c1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJzaWRhemhhbmdcIixcbiAgICAgIFwiZW1haWxcIjogXCJzaWRhemhhbmc4OUBnbWFpbC5jb21cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwibmFkYXZcIixcbiAgICAgIFwiZW1haWxcIjogXCJucG1Ac2hlc2VrLmluZm9cIlxuICAgIH0sXG4gICAge1xuICAgICAgXCJuYW1lXCI6IFwianByaWNoYXJkc29uXCIsXG4gICAgICBcImVtYWlsXCI6IFwianByaWNoYXJkc29uQGdtYWlsLmNvbVwiXG4gICAgfVxuICBdLFxuICBcIm5hbWVcIjogXCJiaWdpXCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG4gIFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmlnaS5naXRcIixcbiAgICBcInR5cGVcIjogXCJnaXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiYnJvd3Nlci10ZXN0XCI6IFwibW9jaGlmeSAtLXdkIC1SIHNwZWNcIixcbiAgICBcImNvdmVyYWdlXCI6IFwiaXN0YW5idWwgY292ZXIgLi9ub2RlX21vZHVsZXMvLmJpbi9fbW9jaGEgLS0gLS1yZXBvcnRlciBsaXN0IHRlc3QvKi5qc1wiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwibnBtIHJ1bi1zY3JpcHQgY292ZXJhZ2UgJiYgbm9kZSAuL25vZGVfbW9kdWxlcy8uYmluL2NvdmVyYWxscyA8IGNvdmVyYWdlL2xjb3YuaW5mb1wiLFxuICAgIFwianNoaW50XCI6IFwianNoaW50IC0tY29uZmlnIGpzaGludC5qc29uIGxpYi8qLmpzIDsgdHJ1ZVwiLFxuICAgIFwidGVzdFwiOiBcIl9tb2NoYSAtLSB0ZXN0LyouanNcIixcbiAgICBcInVuaXRcIjogXCJtb2NoYVwiXG4gIH0sXG4gIFwidGVzdGxpbmdcIjoge1xuICAgIFwiZmlsZXNcIjogXCJ0ZXN0LyouanNcIixcbiAgICBcImhhcm5lc3NcIjogXCJtb2NoYVwiLFxuICAgIFwiYnJvd3NlcnNcIjogW1xuICAgICAgXCJpZS85Li5sYXRlc3RcIixcbiAgICAgIFwiZmlyZWZveC9sYXRlc3RcIixcbiAgICAgIFwiY2hyb21lL2xhdGVzdFwiLFxuICAgICAgXCJzYWZhcmkvNi4wLi5sYXRlc3RcIixcbiAgICAgIFwiaXBob25lLzYuMC4ubGF0ZXN0XCIsXG4gICAgICBcImFuZHJvaWQtYnJvd3Nlci80LjIuLmxhdGVzdFwiXG4gICAgXVxuICB9LFxuICBcInZlcnNpb25cIjogXCIxLjQuMlwiXG59XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmVcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgICAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIG9mZnNldCwgaSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gKGkgLSBvZmZzZXQpO1xuICAgIG9mZnNldCA9IGk7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoaSA9PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gY2hhclN0cjtcblxuICAgIC8vIG90aGVyd2lzZSBjdXQgb2ZmIHRoZSBjaGFyYWN0ZXJzIGVuZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoaSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgYnJlYWs7XG4gIH1cblxuICB2YXIgbGVuSW5jb21wbGV0ZSA9IHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gbGVuSW5jb21wbGV0ZSwgZW5kKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGxlbkluY29tcGxldGU7XG4gICAgZW5kIC09IGxlbkluY29tcGxldGU7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICB0aGlzLmNoYXJCdWZmZXIud3JpdGUoY2hhclN0ci5jaGFyQXQoY2hhclN0ci5sZW5ndGggLSAxKSwgdGhpcy5lbmNvZGluZyk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAyIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAzIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xudmFyIGJhc2U1OCA9IGJhc2V4KEFMUEhBQkVUKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBiYXNlNTguZW5jb2RlLFxuICBkZWNvZGU6IGJhc2U1OC5kZWNvZGVcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iczU4XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2J1ZmZlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXHJcbiBDb3B5cmlnaHQgMjAxMy0yMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIGJ5dGVidWZmZXIuanMgKGMpIDIwMTUgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogQmFja2luZyBidWZmZXI6IEFycmF5QnVmZmVyLCBBY2Nlc3NvcjogVWludDhBcnJheVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vYnl0ZWJ1ZmZlci5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbXCJhbWRcIl0pXHJcbiAgICAgICAgZGVmaW5lKFtcImxvbmdcIl0sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIExvbmc7IHRyeSB7IExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoTG9uZyk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgIC8qIEdsb2JhbCAqLyBlbHNlXHJcbiAgICAgICAgKGdsb2JhbFtcImRjb2RlSU9cIl0gPSBnbG9iYWxbXCJkY29kZUlPXCJdIHx8IHt9KVtcIkJ5dGVCdWZmZXJcIl0gPSBmYWN0b3J5KGdsb2JhbFtcImRjb2RlSU9cIl1bXCJMb25nXCJdKTtcclxuXHJcbn0pKHRoaXMsIGZ1bmN0aW9uKExvbmcpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBCeXRlQnVmZmVyLlxyXG4gICAgICogQGNsYXNzIFRoZSBzd2lzcyBhcm15IGtuaWZlIGZvciBiaW5hcnkgZGF0YSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICogQGV4cG9ydHMgQnl0ZUJ1ZmZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNhcGFjaXR5IEluaXRpYWwgY2FwYWNpdHkuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFl9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICB2YXIgQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYXBhY2l0eSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTjtcclxuICAgICAgICBpZiAodHlwZW9mIG5vQXNzZXJ0ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlQ7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBjYXBhY2l0eSA9IGNhcGFjaXR5IHwgMDtcclxuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSAhIWxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSAhIW5vQXNzZXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFja2luZyBBcnJheUJ1ZmZlci5cclxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5QnVmZmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGNhcGFjaXR5ID09PSAwID8gRU1QVFlfQlVGRkVSIDogbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVWludDhBcnJheSB1dGlsaXplZCB0byBtYW5pcHVsYXRlIHRoZSBiYWNraW5nIGJ1ZmZlci4gQmVjb21lcyBgbnVsbGAgaWYgdGhlIGJhY2tpbmcgYnVmZmVyIGhhcyBhIGNhcGFjaXR5IG9mIGAwYC5cclxuICAgICAgICAgKiBAdHlwZSB7P1VpbnQ4QXJyYXl9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNhcGFjaXR5ID09PSAwID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzb2x1dGUgcmVhZC93cml0ZSBvZmZzZXQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2ZsaXBcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjY2xlYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcmtlZCBvZmZzZXQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI21hcmtcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnNvbHV0ZSBsaW1pdCBvZiB0aGUgY29udGFpbmVkIGRhdGEuIFNldCB0byB0aGUgYmFja2luZyBidWZmZXIncyBjYXBhY2l0eSB1cG9uIGFsbG9jYXRpb24uXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2ZsaXBcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjY2xlYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbWl0ID0gY2FwYWNpdHk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgYmlnIGVuZGlhbi5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub0Fzc2VydCA9IG5vQXNzZXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5dGVCdWZmZXIgdmVyc2lvbi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5WRVJTSU9OID0gXCI1LjAuMVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGl0dGxlIGVuZGlhbiBjb25zdGFudCB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgaXRzIGJvb2xlYW4gdmFsdWUuIEV2YWx1YXRlcyB0byBgdHJ1ZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmlnIGVuZGlhbiBjb25zdGFudCB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgaXRzIGJvb2xlYW4gdmFsdWUuIEV2YWx1YXRlcyB0byBgZmFsc2VgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5CSUdfRU5ESUFOID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGluaXRpYWwgY2FwYWNpdHkgb2YgYDE2YC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSA9IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBlbmRpYW5lc3Mgb2YgYGZhbHNlYCBmb3IgYmlnIGVuZGlhbi5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOID0gQnl0ZUJ1ZmZlci5CSUdfRU5ESUFOO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBubyBhc3NlcnRpb25zIGZsYWcgb2YgYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYExvbmdgIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NC1iaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLiBNYXkgYmUgYG51bGxgIGlmIExvbmcuanMgaGFzIG5vdCBiZWVuIGxvYWRlZFxyXG4gICAgICogIGFuZCBpbnQ2NCBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICAgKiBAdHlwZSB7P0xvbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbG9uZy5qc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkxvbmcgPSBMb25nIHx8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgQnl0ZUJ1ZmZlci5wcm90b3R5cGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgQnl0ZUJ1ZmZlclByb3RvdHlwZSA9IEJ5dGVCdWZmZXIucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ5dGVCdWZmZXIgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuX19pc0J5dGVCdWZmZXJfXztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnl0ZUJ1ZmZlclByb3RvdHlwZSwgXCJfX2lzQnl0ZUJ1ZmZlcl9fXCIsIHtcclxuICAgICAgICB2YWx1ZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBoZWxwZXJzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUFycmF5QnVmZmVyfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBFTVBUWV9CVUZGRVIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpbmcuZnJvbUNoYXJDb2RlIHJlZmVyZW5jZSBmb3IgY29tcGlsZS10aW1lIHJlbmFtaW5nLlxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKC4uLm51bWJlcik6c3RyaW5nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHNvdXJjZSBmdW5jdGlvbiBmb3IgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcgdG8gcmVhZCBmcm9tXHJcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gU291cmNlIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZSBhcmVcclxuICAgICAqICBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGFyZ3VtZW50IGlzIGludmFsaWRcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdTb3VyY2Uocykge1xyXG4gICAgICAgIHZhciBpPTA7IHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGkgPCBzLmxlbmd0aCA/IHMuY2hhckNvZGVBdChpKyspIDogbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGRlc3RpbmF0aW9uIGZ1bmN0aW9uIGZvciBhIHN0cmluZy5cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbihudW1iZXI9KTp1bmRlZmluZWR8c3RyaW5nfSBEZXN0aW5hdGlvbiBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggdGhlIG5leHQgY2hhciBjb2RlLlxyXG4gICAgICogIFJldHVybnMgdGhlIGZpbmFsIHN0cmluZyB3aGVuIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cy5cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdEZXN0aW5hdGlvbigpIHtcclxuICAgICAgICB2YXIgY3MgPSBbXSwgcHMgPSBbXTsgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcy5qb2luKCcnKStzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcyk7XHJcbiAgICAgICAgICAgIGlmIChjcy5sZW5ndGggKyBhcmd1bWVudHMubGVuZ3RoID4gMTAyNClcclxuICAgICAgICAgICAgICAgIHBzLnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY3MpKSxcclxuICAgICAgICAgICAgICAgICAgICBjcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYWNjZXNzb3IgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYEJ1ZmZlcmAgdW5kZXIgbm9kZS5qcywgYFVpbnQ4QXJyYXlgIHJlc3BlY3RpdmVseSBgRGF0YVZpZXdgIGluIHRoZSBicm93c2VyIChjbGFzc2VzKVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmFjY2Vzc29yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgQnl0ZUJ1ZmZlciBiYWNrZWQgYnkgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY2FwYWNpdHkgSW5pdGlhbCBjYXBhY2l0eS4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWX0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIEJ5dGVCdWZmZXJzIGludG8gb25lLlxyXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmc+fSBidWZmZXJzIEJ1ZmZlcnMgdG8gY29uY2F0ZW5hdGVcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xib29sZWFuKT19IGVuY29kaW5nIFN0cmluZyBlbmNvZGluZyBpZiBgYnVmZmVyc2AgY29udGFpbnMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsXHJcbiAgICAgKiAgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlciBmb3IgdGhlIHJlc3VsdGluZyBCeXRlQnVmZmVyLiBEZWZhdWx0c1xyXG4gICAgICogIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcyBmb3IgdGhlIHJlc3VsdGluZyBCeXRlQnVmZmVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDb25jYXRlbmF0ZWQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uKGJ1ZmZlcnMsIGVuY29kaW5nLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGs9YnVmZmVycy5sZW5ndGgsIGxlbmd0aDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCFCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcihidWZmZXJzW2ldKSlcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcnNbaV0gPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyc1tpXSwgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBidWZmZXJzW2ldLmxpbWl0IC0gYnVmZmVyc1tpXS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSBjYXBhY2l0eSArPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXBhY2l0eSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSxcclxuICAgICAgICAgICAgYmk7XHJcbiAgICAgICAgaT0wOyB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIGJpID0gYnVmZmVyc1tpKytdO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBiaS5saW1pdCAtIGJpLm9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgYmIudmlldy5zZXQoYmkudmlldy5zdWJhcnJheShiaS5vZmZzZXQsIGJpLmxpbWl0KSwgYmIub2Zmc2V0KTtcclxuICAgICAgICAgICAgYmIub2Zmc2V0ICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBiYi5vZmZzZXQ7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7Kn0gYmIgQnl0ZUJ1ZmZlciB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGl0IGlzIGEgQnl0ZUJ1ZmZlciwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIgPSBmdW5jdGlvbihiYikge1xyXG4gICAgICAgIHJldHVybiAoYmIgJiYgYmJbXCJfX2lzQnl0ZUJ1ZmZlcl9fXCJdKSA9PT0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGJhY2tpbmcgYnVmZmVyIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGBCdWZmZXJgIHVuZGVyIG5vZGUuanMsIGBBcnJheUJ1ZmZlcmAgaW4gdGhlIGJyb3dzZXIgKGNsYXNzZXMpXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIudHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheUJ1ZmZlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBzIGEgYnVmZmVyIG9yIGEgc3RyaW5nLiBTZXRzIHRoZSBhbGxvY2F0ZWQgQnl0ZUJ1ZmZlcidzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gdG8gYDBgIGFuZCBpdHNcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlIGxlbmd0aCBvZiB0aGUgd3JhcHBlZCBkYXRhLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfCFBcnJheS48bnVtYmVyPn0gYnVmZmVyIEFueXRoaW5nIHRoYXQgY2FuIGJlIHdyYXBwZWRcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xib29sZWFuKT19IGVuY29kaW5nIFN0cmluZyBlbmNvZGluZyBpZiBgYnVmZmVyYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG9cclxuICAgICAqICBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQSBCeXRlQnVmZmVyIHdyYXBwaW5nIGBidWZmZXJgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIud3JhcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9IGxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGV4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUhleChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21VVEY4KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21EZWJ1ZyhidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2VuY29kaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZmVyID09PSBudWxsIHx8IHR5cGVvZiBidWZmZXIgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgICAgICB2YXIgYmI7XHJcbiAgICAgICAgaWYgKEJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgYmIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLmNsb25lLmNhbGwoYnVmZmVyKTtcclxuICAgICAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiBiYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsgLy8gRXh0cmFjdCBBcnJheUJ1ZmZlciBmcm9tIFVpbnQ4QXJyYXlcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7IC8vIEF2b2lkIHJlZmVyZW5jZXMgdG8gbW9yZSB0aGFuIG9uZSBFTVBUWV9CVUZGRVJcclxuICAgICAgICAgICAgICAgIGJiLmJ1ZmZlciA9IGJ1ZmZlci5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBidWZmZXIuYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJiLnZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsgLy8gUmV1c2UgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYmIuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gYnVmZmVyLmJ5dGVMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChidWZmZXIpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHsgLy8gQ3JlYXRlIGZyb20gb2N0ZXRzXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoYnVmZmVyLmxlbmd0aCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlci5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIGJiLnZpZXdbaV0gPSBidWZmZXJbaV07XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyXCIpOyAvLyBPdGhlcndpc2UgZmFpbFxyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIGFycmF5IGFzIGEgYml0c2V0LlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxib29sZWFuPn0gdmFsdWUgQXJyYXkgb2YgYm9vbGVhbnMgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCaXRTZXQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxyXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBCaXRTZXQ6IE5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICBiaXRzID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgYnl0ZXMgPSAoYml0cyA+PiAzKSxcclxuICAgICAgICAgIGJpdCA9IDAsXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgb2Zmc2V0ICs9IHRoaXMud3JpdGVWYXJpbnQzMihiaXRzLG9mZnNldCk7XHJcblxyXG4gICAgICB3aGlsZShieXRlcy0tKSB7XHJcbiAgICAgICAgayA9ICghIXZhbHVlW2JpdCsrXSAmIDEpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDEpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDIpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDMpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDQpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDUpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDYpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDcpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGssb2Zmc2V0KyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihiaXQgPCBiaXRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSAwOyBrID0gMDtcclxuICAgICAgICB3aGlsZShiaXQgPCBiaXRzKSBrID0gayB8ICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAobSsrKSk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ5dGUoayxvZmZzZXQrKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgQml0U2V0IGFzIGFuIGFycmF5IG9mIGJvb2xlYW5zLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYGxlbmd0aGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheTxib29sZWFuPlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCaXRTZXQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXHJcbiAgICAgIHZhciByZXQgPSB0aGlzLnJlYWRWYXJpbnQzMihvZmZzZXQpLFxyXG4gICAgICAgICAgYml0cyA9IHJldC52YWx1ZSxcclxuICAgICAgICAgIGJ5dGVzID0gKGJpdHMgPj4gMyksXHJcbiAgICAgICAgICBiaXQgPSAwLFxyXG4gICAgICAgICAgdmFsdWUgPSBbXSxcclxuICAgICAgICAgIGs7XHJcblxyXG4gICAgICBvZmZzZXQgKz0gcmV0Lmxlbmd0aDtcclxuXHJcbiAgICAgIHdoaWxlKGJ5dGVzLS0pIHtcclxuICAgICAgICBrID0gdGhpcy5yZWFkQnl0ZShvZmZzZXQrKyk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDEpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDAyKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwNCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDgpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDEwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgyMCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4NDApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDgwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoYml0IDwgYml0cykge1xyXG4gICAgICAgIHZhciBtID0gMDtcclxuICAgICAgICBrID0gdGhpcy5yZWFkQnl0ZShvZmZzZXQrKyk7XHJcbiAgICAgICAgd2hpbGUoYml0IDwgYml0cykgdmFsdWVbYml0KytdID0gISEoKGsgPj4gKG0rKykpICYgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgbGVuZ3RoYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRCeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgbGVuZ3RoID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrbGVuZ3RoK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2xpY2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgcGF5bG9hZCBvZiBieXRlcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNhcHBlbmR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmd9IHNvdXJjZSBEYXRhIHRvIHdyaXRlLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXRzXHJcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZW5jb2RpbmcgRW5jb2RpbmcgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQnl0ZXMgPSBCeXRlQnVmZmVyUHJvdG90eXBlLmFwcGVuZDtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDhcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHZhciBjYXBhY2l0eTAgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUJ5dGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50ODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52aWV3W29mZnNldF07XHJcbiAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODApID09PSAweDgwKSB2YWx1ZSA9IC0oMHhGRiAtIHZhbHVlICsgMSk7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50OH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJ5dGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB2YXIgY2FwYWNpdHkxID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMTtcbiAgICAgICAgdGhpcy52aWV3W29mZnNldF0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50OH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAxYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50OCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50ODtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52aWV3W29mZnNldF07XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50OH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQ4ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDg7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQxNlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDE2ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB2YXIgY2FwYWNpdHkyID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTIgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTIgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMjtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXRdICAgPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVNob3J0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDIgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisyK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF07XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDg7XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodmFsdWUgJiAweDgwMDApID09PSAweDgwMDApIHZhbHVlID0gLSgweEZGRkYgLSB2YWx1ZSArIDEpOyAvLyBDYXN0IHRvIHNpZ25lZFxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDE2fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFNob3J0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdmFyIGNhcGFjaXR5MyA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkzICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkzIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDI7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSAgID0gKHZhbHVlICYgMHhGRjAwKSA+Pj4gODtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICB2YWx1ZSAmIDB4MDBGRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDE2fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDJgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIG9yIGB2YWx1ZWAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50MTYgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDIgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisyK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF07XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDg7XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMTZiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDE2fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQxNiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQxNjtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDMyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB2YXIgY2FwYWNpdHk0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTQgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTQgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50MzJ9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSB8PSAwOyAvLyBDYXN0IHRvIHNpZ25lZFxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZEludDMyfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB2YXIgY2FwYWNpdHk1ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTUgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTUgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICB2YWx1ZSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50MzJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVSW50MzIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50MzIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50MzI7XHJcblxyXG4gICAgLy8gdHlwZXMvaW50cy9pbnQ2NFxyXG5cclxuICAgIGlmIChMb25nKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhciBjYXBhY2l0eTYgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NilcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk2ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk2IDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICAgICAgdmFyIGxvID0gdmFsdWUubG93LFxyXG4gICAgICAgICAgICAgICAgaGkgPSB2YWx1ZS5oaWdoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDY0fS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlTG9uZyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrOCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsbyA9IDAsXHJcbiAgICAgICAgICAgICAgICBoaSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50NjR9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkTG9uZyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB2YXIgY2FwYWNpdHk3ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NyA6IG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgICAgIHZhciBsbyA9IHZhbHVlLmxvdyxcclxuICAgICAgICAgICAgICAgIGhpID0gdmFsdWUuaGlnaDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ2NH0uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQ2NCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbG8gPSAwLFxyXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgTG9uZyhsbywgaGksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50NjR9LlxyXG4gICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDY0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDY0O1xyXG5cclxuICAgIH0gLy8gTG9uZ1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy9mbG9hdHMvZmxvYXQzMlxyXG5cclxuICAgIC8qXHJcbiAgICAgaWVlZTc1NCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvaWVlZTc1NFxyXG5cclxuICAgICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuXHJcbiAgICAgQ29weXJpZ2h0IChjKSBGZXJvc3MgQWJvdWtoYWRpamVoXHJcblxyXG4gICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICAgICBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAgICAgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gICAgIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICAgICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICAgICBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gICAgIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAgICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAgICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAgICAgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAgICAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gICAgIFRIRSBTT0ZUV0FSRS5cclxuICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiBJRUVFNzU0IGZsb2F0IGZyb20gYSBieXRlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHshQXJyYXl9IGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xFXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbUxlblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlc1xyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpZWVlNzU0X3JlYWQoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xyXG4gICAgICAgIHZhciBlLCBtLFxyXG4gICAgICAgICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxyXG4gICAgICAgICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxyXG4gICAgICAgICAgICBlQmlhcyA9IGVNYXggPj4gMSxcclxuICAgICAgICAgICAgbkJpdHMgPSAtNyxcclxuICAgICAgICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxyXG4gICAgICAgICAgICBkID0gaXNMRSA/IC0xIDogMSxcclxuICAgICAgICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcclxuXHJcbiAgICAgICAgaSArPSBkO1xyXG5cclxuICAgICAgICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcclxuICAgICAgICBzID4+PSAoLW5CaXRzKTtcclxuICAgICAgICBuQml0cyArPSBlTGVuO1xyXG4gICAgICAgIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XHJcblxyXG4gICAgICAgIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xyXG4gICAgICAgIGUgPj49ICgtbkJpdHMpO1xyXG4gICAgICAgIG5CaXRzICs9IG1MZW47XHJcbiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cclxuXHJcbiAgICAgICAgaWYgKGUgPT09IDApIHtcclxuICAgICAgICAgICAgZSA9IDEgLSBlQmlhcztcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XHJcbiAgICAgICAgICAgIGUgPSBlIC0gZUJpYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIElFRUU3NTQgZmxvYXQgdG8gYSBieXRlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHshQXJyYXl9IGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTEVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaWVlZTc1NF93cml0ZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xyXG4gICAgICAgIHZhciBlLCBtLCBjLFxyXG4gICAgICAgICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxyXG4gICAgICAgICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxyXG4gICAgICAgICAgICBlQmlhcyA9IGVNYXggPj4gMSxcclxuICAgICAgICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxyXG4gICAgICAgICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXHJcbiAgICAgICAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxyXG4gICAgICAgICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xyXG4gICAgICAgICAgICBlID0gZU1heDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgIGUtLTtcclxuICAgICAgICAgICAgICAgIGMgKj0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHJ0IC8gYztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcclxuICAgICAgICAgICAgICAgIGUrKztcclxuICAgICAgICAgICAgICAgIGMgLz0gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtID0gMDtcclxuICAgICAgICAgICAgICAgIGUgPSBlTWF4O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XHJcbiAgICAgICAgICAgICAgICBlID0gZSArIGVCaWFzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XHJcblxyXG4gICAgICAgIGUgPSAoZSA8PCBtTGVuKSB8IG07XHJcbiAgICAgICAgZUxlbiArPSBtTGVuO1xyXG4gICAgICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cclxuXHJcbiAgICAgICAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgZmxvYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUZsb2F0MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYSBudW1iZXIpXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk4KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5OCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5OCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZWVlNzU0X3dyaXRlKHRoaXMudmlldywgdmFsdWUsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDIzLCA0KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlRmxvYXQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQzMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgZmxvYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0MzIgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrNCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBpZWVlNzU0X3JlYWQodGhpcy52aWV3LCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCAyMywgNCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkRmxvYXQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDMyO1xyXG5cclxuICAgIC8vIHR5cGVzL2Zsb2F0cy9mbG9hdDY0XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSA2NGJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhIG51bWJlcilcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgdmFyIGNhcGFjaXR5OSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTkpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk5ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk5IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgIGllZWU3NTRfd3JpdGUodGhpcy52aWV3LCB2YWx1ZSwgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgNTIsIDgpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgNjRiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVGbG9hdDY0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVEb3VibGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQ2NDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgNjRiaXQgZmxvYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyA4ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrOCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBpZWVlNzU0X3JlYWQodGhpcy52aWV3LCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCA1MiwgOCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSA2NGJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkRmxvYXQ2NH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRG91YmxlID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQ2NDtcclxuXHJcblxyXG4gICAgLy8gdHlwZXMvdmFyaW50cy92YXJpbnQzMlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UMzJfQllURVMgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGVuY29kZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkLiBDYXBwZWQgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDMyX0JZVEVTfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gMDtcclxuICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEgPDwgNyApIHJldHVybiAxO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAxNCkgcmV0dXJuIDI7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDIxKSByZXR1cm4gMztcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMjgpIHJldHVybiA0O1xyXG4gICAgICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogWmlnemFnIGVuY29kZXMgYSBzaWduZWQgMzJiaXQgaW50ZWdlciBzbyB0aGF0IGl0IGNhbiBiZSBlZmZlY3RpdmVseSB1c2VkIHdpdGggdmFyaW50IGVuY29kaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gU2lnbmVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGUzMiA9IGZ1bmN0aW9uKG4pIHtcclxuICAgICAgICByZXR1cm4gKCgobiB8PSAwKSA8PCAxKSBeIChuID4+IDMxKSkgPj4+IDA7IC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgemlnemFnIGVuY29kZWQgc2lnbmVkIDMyYml0IGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBVbnNpZ25lZCB6aWd6YWcgZW5jb2RlZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTMyID0gZnVuY3Rpb24obikge1xyXG4gICAgICAgIHJldHVybiAoKG4gPj4+IDEpIF4gLShuICYgMSkpIHwgMDsgLy8gLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpemUgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKHZhbHVlKSxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTAgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEwICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBzaXplO1xuICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgd2hpbGUgKHZhbHVlID49IDB4ODApIHtcclxuICAgICAgICAgICAgYiA9ICh2YWx1ZSAmIDB4N2YpIHwgMHg4MDtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gNztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHppZy16YWcgZW5jb2RlZCAoc2lnbmVkKSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDMyWmlnWmFnID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVmFyaW50MzIoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGUzMih2YWx1ZSksIG9mZnNldCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCF7dmFsdWU6IG51bWJlciwgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZFxyXG4gICAgICogIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50LiBIYXMgYSBwcm9wZXJ0eSBgdHJ1bmNhdGVkID0gdHJ1ZWAgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIGF2YWlsYWJsZVxyXG4gICAgICogIHRvIGZ1bGx5IGRlY29kZSB0aGUgdmFyaW50LlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjID0gMCxcclxuICAgICAgICAgICAgdmFsdWUgPSAwID4+PiAwLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0ICYmIG9mZnNldCA+IHRoaXMubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcIlRydW5jYXRlZFwiKTtcclxuICAgICAgICAgICAgICAgIGVyclsndHJ1bmNhdGVkJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICBpZiAoYyA8IDUpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSB8PSAoYiAmIDB4N2YpIDw8ICg3KmMpO1xyXG4gICAgICAgICAgICArK2M7XHJcbiAgICAgICAgfSB3aGlsZSAoKGIgJiAweDgwKSAhPT0gMCk7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiB2YWx1ZSxcclxuICAgICAgICAgICAgXCJsZW5ndGhcIjogY1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgKHNpZ25lZCkgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcnwhe3ZhbHVlOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWRcclxuICAgICAqICBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIG5vdCBhIHZhbGlkIHZhcmludFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRWYXJpbnQzMlppZ1phZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgdmFsW1widmFsdWVcIl0gPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTMyKHZhbFtcInZhbHVlXCJdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHZhbCA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIodmFsKTtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0eXBlcy92YXJpbnRzL3ZhcmludDY0XHJcblxyXG4gICAgaWYgKExvbmcpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLk1BWF9WQVJJTlQ2NF9CWVRFUyA9IDEwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIGVuY29kZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyByZXF1aXJlZC4gQ2FwcGVkIHRvIHtAbGluayBCeXRlQnVmZmVyLk1BWF9WQVJJTlQ2NF9CWVRFU31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgICAgICB2YXIgcGFydDAgPSB2YWx1ZS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDEgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMjgpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCg1NikudG9JbnQoKSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHBhcnQyID09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJ0MSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQwIDwgMSA8PCAxNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQwIDwgMSA8PCA3ID8gMSA6IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDAgPCAxIDw8IDIxID8gMyA6IDQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0MSA8IDEgPDwgMTQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MSA8IDEgPDwgNyA/IDUgOiA2O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxIDwgMSA8PCAyMSA/IDcgOiA4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MiA8IDEgPDwgNyA/IDkgOiAxMDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBaaWd6YWcgZW5jb2RlcyBhIHNpZ25lZCA2NGJpdCBpbnRlZ2VyIHNvIHRoYXQgaXQgY2FuIGJlIGVmZmVjdGl2ZWx5IHVzZWQgd2l0aCB2YXJpbnQgZW5jb2RpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFNpZ25lZCBsb25nXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCB6aWd6YWcgZW5jb2RlZCBsb25nXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlNjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zaGlmdExlZnQoMSkueG9yKHZhbHVlLnNoaWZ0UmlnaHQoNjMpKS50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIHppZ3phZyBlbmNvZGVkIHNpZ25lZCA2NGJpdCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfSB2YWx1ZSBVbnNpZ25lZCB6aWd6YWcgZW5jb2RlZCBsb25nIG9yIEphdmFTY3JpcHQgbnVtYmVyXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDEpLnhvcih2YWx1ZS5hbmQoTG9uZy5PTkUpLnRvU2lnbmVkKCkubmVnYXRlKCkpLnRvU2lnbmVkKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8TG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50NjQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIExvbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIgb3IgTG9uZylcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIHZhciBzaXplID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSksXHJcbiAgICAgICAgICAgICAgICBwYXJ0MCA9IHZhbHVlLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpID4+PiAwO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgICAgIHZhciBjYXBhY2l0eTExID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTExKVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTExICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMSA6IG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgLT0gc2l6ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxMDogdGhpcy52aWV3W29mZnNldCs5XSA9IChwYXJ0MiA+Pj4gIDcpICYgMHgwMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgOSA6IHRoaXMudmlld1tvZmZzZXQrOF0gPSBzaXplICE9PSA5ID8gKHBhcnQyICAgICAgICkgfCAweDgwIDogKHBhcnQyICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA4IDogdGhpcy52aWV3W29mZnNldCs3XSA9IHNpemUgIT09IDggPyAocGFydDEgPj4+IDIxKSB8IDB4ODAgOiAocGFydDEgPj4+IDIxKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDcgOiB0aGlzLnZpZXdbb2Zmc2V0KzZdID0gc2l6ZSAhPT0gNyA/IChwYXJ0MSA+Pj4gMTQpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMTQpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNiA6IHRoaXMudmlld1tvZmZzZXQrNV0gPSBzaXplICE9PSA2ID8gKHBhcnQxID4+PiAgNykgfCAweDgwIDogKHBhcnQxID4+PiAgNykgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1IDogdGhpcy52aWV3W29mZnNldCs0XSA9IHNpemUgIT09IDUgPyAocGFydDEgICAgICAgKSB8IDB4ODAgOiAocGFydDEgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQgOiB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gc2l6ZSAhPT0gNCA/IChwYXJ0MCA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gMjEpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMyA6IHRoaXMudmlld1tvZmZzZXQrMl0gPSBzaXplICE9PSAzID8gKHBhcnQwID4+PiAxNCkgfCAweDgwIDogKHBhcnQwID4+PiAxNCkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyIDogdGhpcy52aWV3W29mZnNldCsxXSA9IHNpemUgIT09IDIgPyAocGFydDAgPj4+ICA3KSB8IDB4ODAgOiAocGFydDAgPj4+ICA3KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgOiB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gc2l6ZSAhPT0gMSA/IChwYXJ0MCAgICAgICApIHwgMHg4MCA6IChwYXJ0MCAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNpemU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgemlnLXphZyBlbmNvZGVkIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfExvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZhcmludDY0WmlnWmFnID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZVZhcmludDY0KEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlNjQodmFsdWUpLCBvZmZzZXQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlYWRzIGEgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuIFJlcXVpcmVzIExvbmcuanMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfCF7dmFsdWU6IExvbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWQgYW5kXHJcbiAgICAgICAgICogIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgcGFydDAgPSAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDEgPSAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSAwLFxyXG4gICAgICAgICAgICAgICAgYiAgPSAwO1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgID0gKGIgJiAweDdGKSAgICAgIDsgaWYgKCBiICYgMHg4MCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgfD0gKGIgJiAweDdGKSA8PCAgNzsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgfD0gKGIgJiAweDdGKSA8PCAxNDsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDAgfD0gKGIgJiAweDdGKSA8PCAyMTsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDEgID0gKGIgJiAweDdGKSAgICAgIDsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDEgfD0gKGIgJiAweDdGKSA8PCAgNzsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDEgfD0gKGIgJiAweDdGKSA8PCAxNDsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDEgfD0gKGIgJiAweDdGKSA8PCAyMTsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDIgID0gKGIgJiAweDdGKSAgICAgIDsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W29mZnNldCsrXTsgcGFydDIgfD0gKGIgJiAweDdGKSA8PCAgNzsgaWYgKChiICYgMHg4MCkgfHwgKHRoaXMubm9Bc3NlcnQgJiYgdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJ1ZmZlciBvdmVycnVuXCIpOyB9fX19fX19fX19XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IExvbmcuZnJvbUJpdHMocGFydDAgfCAocGFydDEgPDwgMjgpLCAocGFydDEgPj4+IDQpIHwgKHBhcnQyKSA8PCAyNCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0LXN0YXJ0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuIFJlcXVpcmVzIExvbmcuanMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfCF7dmFsdWU6IExvbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHZhbHVlIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHZhbHVlIHJlYWQgYW5kXHJcbiAgICAgICAgICogIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDY0WmlnWmFnID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnJlYWRWYXJpbnQ2NChvZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAodmFsICYmIHZhbFsndmFsdWUnXSBpbnN0YW5jZW9mIExvbmcpXHJcbiAgICAgICAgICAgICAgICB2YWxbXCJ2YWx1ZVwiXSA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsW1widmFsdWVcIl0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB2YWwgPSBCeXRlQnVmZmVyLnppZ1phZ0RlY29kZTY0KHZhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9IC8vIExvbmdcclxuXHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy9jc3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBOVUxMLXRlcm1pbmF0ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy4gRm9yIHRoaXMgdG8gd29yayB0aGUgc3BlY2lmaWVkIHN0cmluZyBtdXN0IG5vdCBjb250YWluIGFueSBOVUxMXHJcbiAgICAgKiAgY2hhcmFjdGVycyBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgY29udGFpbmVkIGluIGBzdHJgICsgMSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVDU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgIGsgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBmb3IgKGk9MDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIuY2hhckNvZGVBdChpKSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIE5VTEwtY2hhcmFjdGVyc1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgLy8gVVRGOCBzdHJpbmdzIGRvIG5vdCBjb250YWluIHplcm8gYnl0ZXMgaW4gYmV0d2VlbiBleGNlcHQgZm9yIHRoZSB6ZXJvIGNoYXJhY3Rlciwgc286XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSBrKzE7XG4gICAgICAgIHZhciBjYXBhY2l0eTEyID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTIgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gaysxO1xuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IDA7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGs7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBOVUxMLXRlcm1pbmF0ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy4gRm9yIHRoaXMgdG8gd29yayB0aGUgc3RyaW5nIHJlYWQgbXVzdCBub3QgY29udGFpbiBhbnkgTlVMTCBjaGFyYWN0ZXJzXHJcbiAgICAgKiAgaXRzZWxmLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZENTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIHRlbXA7XHJcbiAgICAgICAgLy8gVVRGOCBzdHJpbmdzIGRvIG5vdCBjb250YWluIHplcm8gYnl0ZXMgaW4gYmV0d2VlbiBleGNlcHQgZm9yIHRoZSB6ZXJvIGNoYXJhY3RlciBpdHNlbGYsIHNvOlxyXG4gICAgICAgIHZhciBzZCwgYiA9IC0xO1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSB0aGlzLmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPCBcIit0aGlzLmxpbWl0KTtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107XHJcbiAgICAgICAgICAgIHJldHVybiBiID09PSAwID8gbnVsbCA6IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCksIHRydWUpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IHNkKCksXHJcbiAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy9pc3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsZW5ndGggYXMgdWludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3dyaXRlVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUlTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgaztcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdGhpcy5ub0Fzc2VydClbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQraztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTMgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMylcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEzICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMyA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0K2s7XG4gICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChrID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChrID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChrID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBrICAgICAgICAgJiAweEZGO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChrID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChrID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChrID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBrICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBzdGFydCArIDQgKyBrKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIisob2Zmc2V0KzQraykpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGxlbmd0aCBhcyB1aW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3JlYWRWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJU3RyaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHZhciBsZW4gPSB0aGlzLnJlYWRVaW50MzIob2Zmc2V0KTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5yZWFkVVRGOFN0cmluZyhsZW4sIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUywgb2Zmc2V0ICs9IDQpO1xyXG4gICAgICAgIG9mZnNldCArPSBzdHJbJ2xlbmd0aCddO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHN0clsnc3RyaW5nJ107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdzdHJpbmcnOiBzdHJbJ3N0cmluZyddLFxyXG4gICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL3V0ZjhzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ldHJpY3MgcmVwcmVzZW50aW5nIG51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnMuIEV2YWx1YXRlcyB0byBgY2AuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUyA9ICdjJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ldHJpY3MgcmVwcmVzZW50aW5nIG51bWJlciBvZiBieXRlcy4gRXZhbHVhdGVzIHRvIGBiYC5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTID0gJ2InO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVVRGOFN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVsxXTtcclxuICAgICAgICBvZmZzZXQgKz0gaztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNClcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE0ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBrO1xuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVVRGOFN0cmluZ30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVTdHJpbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVVRGOFN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnMgb2YgYSBzdHJpbmcuIEphdmFTY3JpcHQgaXRzZWxmIHVzZXMgVVRGLTE2LCBzbyB0aGF0IGEgc3RyaW5nJ3NcclxuICAgICAqICBgbGVuZ3RoYCBwcm9wZXJ0eSBkb2VzIG5vdCByZWZsZWN0IGl0cyBhY3R1YWwgVVRGOCBzaXplIGlmIGl0IGNvbnRhaW5zIGNvZGUgcG9pbnRzIGxhcmdlciB0aGFuIDB4RkZGRi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggY2hhcmFjdGVyc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhDaGFycyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHJldHVybiB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpKVswXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyBvZiBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggYnl0ZXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgb2YgYSBzdHJpbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY2FsY3VsYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgVVRGOCBieXRlc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVN0cmluZyA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbWV0cmljcyBNZXRyaWNzIHNwZWNpZnlpbmcgd2hhdCBgbGVuZ3RoYCBpcyBtZWFudCB0byBjb3VudC4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoLCBtZXRyaWNzLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG1ldHJpY3MgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG1ldHJpY3M7XHJcbiAgICAgICAgICAgIG1ldHJpY3MgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAodHlwZW9mIG1ldHJpY3MgPT09ICd1bmRlZmluZWQnKSBtZXRyaWNzID0gQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrbGVuZ3RoK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBsZW5ndGggfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICBzZDtcclxuICAgICAgICBpZiAobWV0cmljcyA9PT0gQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTKSB7IC8vIFRoZSBzYW1lIGZvciBub2RlIGFuZCB0aGUgYnJvd3NlclxyXG4gICAgICAgICAgICBzZCA9IHN0cmluZ0Rlc3RpbmF0aW9uKCk7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpIDwgbGVuZ3RoICYmIG9mZnNldCA8IHRoaXMubGltaXQgPyB0aGlzLnZpZXdbb2Zmc2V0KytdIDogbnVsbDtcclxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICAgICAgKytpOyB1dGZ4LlVURjh0b1VURjE2KGNwLCBzZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gbGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitpK1wiID09IFwiK2xlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIjogc2QoKSxcclxuICAgICAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0cmljcyA9PT0gQnl0ZUJ1ZmZlci5NRVRSSUNTX0JZVEVTKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIGxlbmd0aCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIitsZW5ndGgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgayA9IG9mZnNldCArIGxlbmd0aDtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgPCBrID8gdGhpcy52aWV3W29mZnNldCsrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaylcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiID09IFwiK2spO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICdzdHJpbmcnOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBtZXRyaWNzOiBcIittZXRyaWNzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVVEY4U3RyaW5nfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgY2hhcmFjdGVycyBvciBieXRlcyB0byByZWFkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG1ldHJpY3MgTWV0cmljcyBzcGVjaWZ5aW5nIHdoYXQgYG5gIGlzIG1lYW50IHRvIGNvdW50LiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlN9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFN0cmluZyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVURjhTdHJpbmc7XHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy92c3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsZW5ndGggYXMgdmFyaW50MzIgcHJlZml4ZWQgVVRGOCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSBgdGhpc2AgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjd3JpdGVWYXJpbnQzMlxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVlN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgICAgICBrLCBsO1xyXG4gICAgICAgIGsgPSB1dGZ4LmNhbGN1bGF0ZVVURjE2YXNVVEY4KHN0cmluZ1NvdXJjZShzdHIpLCB0aGlzLm5vQXNzZXJ0KVsxXTtcclxuICAgICAgICBsID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihrKTtcclxuICAgICAgICBvZmZzZXQgKz0gbCtrO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNSA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE1KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTUgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE1IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGwraztcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMud3JpdGVWYXJpbnQzMihrLCBvZmZzZXQpO1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBzdGFydCtrK2wpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiID09IFwiKyhvZmZzZXQraytsKSk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgbGVuZ3RoIGFzIHZhcmludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZWFkVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVlN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5yZWFkVVRGOFN0cmluZyhsZW5bJ3ZhbHVlJ10sIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUywgb2Zmc2V0ICs9IGxlblsnbGVuZ3RoJ10pO1xyXG4gICAgICAgIG9mZnNldCArPSBzdHJbJ2xlbmd0aCddO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHN0clsnc3RyaW5nJ107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICdzdHJpbmcnOiBzdHJbJ3N0cmluZyddLFxyXG4gICAgICAgICAgICAgICAgJ2xlbmd0aCc6IG9mZnNldCAtIHN0YXJ0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHNvbWUgZGF0YSB0byB0aGlzIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlaGluZCB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGUgYXBwZW5kZWRcclxuICAgICAqICBkYXRhJ3MgbGVuZ3RoLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfSBzb3VyY2UgRGF0YSB0byBhcHBlbmQuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcclxuICAgICAqICB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIGFwcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQGV4YW1wbGUgQSByZWxhdGl2ZSBgPDAxIDAyPjAzLmFwcGVuZCg8MDQgMDU+KWAgd2lsbCByZXN1bHQgaW4gYDwwMSAwMiAwNCAwNT4sIDA0IDA1fGBcclxuICAgICAqIEBleGFtcGxlIEFuIGFic29sdXRlIGA8MDEgMDI+MDMuYXBwZW5kKDA0IDA1PiwgMSlgIHdpbGwgcmVzdWx0IGluIGA8MDEgMDQ+MDUsIDA0IDA1fGBcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihzb3VyY2UsIGVuY29kaW5nLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHNvdXJjZSA9IEJ5dGVCdWZmZXIud3JhcChzb3VyY2UsIGVuY29kaW5nKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gc291cmNlLmxpbWl0IC0gc291cmNlLm9mZnNldDtcclxuICAgICAgICBpZiAobGVuZ3RoIDw9IDApIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIGFwcGVuZFxyXG4gICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHZhciBjYXBhY2l0eTE2ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTYpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTYgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnZpZXcuc2V0KHNvdXJjZS52aWV3LnN1YmFycmF5KHNvdXJjZS5vZmZzZXQsIHNvdXJjZS5saW1pdCksIG9mZnNldCk7XHJcbiAgICAgICAgc291cmNlLm9mZnNldCArPSBsZW5ndGg7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBhdCBhbmQgYWZ0ZXIgdGhlXHJcbiAgICAgICAgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGUgbGVuZ3RoIG9mIHRoaXMgQnl0ZUJ1ZmZlcidzIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBhcHBlbmQgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNhcHBlbmRcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0LmFwcGVuZCh0aGlzLCBvZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYXNzZXJ0aW9ucyBvZiBhcmd1bWVudCB0eXBlcyBhbmQgb2Zmc2V0cy4gQXNzZXJ0aW9ucyBhcmUgZW5hYmxlZCBieSBkZWZhdWx0IGJ1dCB5b3UgY2FuIG9wdCB0b1xyXG4gICAgICogIGRpc2FibGUgdGhlbSBpZiB5b3VyIGNvZGUgYWxyZWFkeSBtYWtlcyBzdXJlIHRoYXQgZXZlcnl0aGluZyBpcyB2YWxpZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXNzZXJ0IGB0cnVlYCB0byBlbmFibGUgYXNzZXJ0aW9ucywgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmFzc2VydCA9IGZ1bmN0aW9uKGFzc2VydCkge1xyXG4gICAgICAgIHRoaXMubm9Bc3NlcnQgPSAhYXNzZXJ0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNhcGFjaXR5IG9mIHRoaXMgQnl0ZUJ1ZmZlcidzIGJhY2tpbmcgYnVmZmVyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ2FwYWNpdHkgb2YgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY2FwYWNpdHkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGlzIEJ5dGVCdWZmZXIncyBvZmZzZXRzIGJ5IHNldHRpbmcge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSB0byBgMGAgYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSB0byB0aGVcclxuICAgICAqICBiYWNraW5nIGJ1ZmZlcidzIGNhcGFjaXR5LiBEaXNjYXJkcyB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5tYXJrZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmVkIGluc3RhbmNlIG9mIHRoaXMgQnl0ZUJ1ZmZlciwgcHJlc2V0IHdpdGggdGhpcyBCeXRlQnVmZmVyJ3MgdmFsdWVzIGZvciB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvcHkgV2hldGhlciB0byBjb3B5IHRoZSBiYWNraW5nIGJ1ZmZlciBvciB0byByZXR1cm4gYW5vdGhlciB2aWV3IG9uIHRoZSBzYW1lLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENsb25lZCBpbnN0YW5jZVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oY29weSkge1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKDAsIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICBpZiAoY29weSkge1xyXG4gICAgICAgICAgICBiYi5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgIGJiLnZpZXcgPSBuZXcgVWludDhBcnJheShiYi5idWZmZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJiLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgICAgICBiYi52aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYi5vZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBiYi5tYXJrZWRPZmZzZXQgPSB0aGlzLm1hcmtlZE9mZnNldDtcclxuICAgICAgICBiYi5saW1pdCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhY3RzIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSBiYWNrZWQgYnkgYSB7QGxpbmsgQnl0ZUJ1ZmZlciNidWZmZXJ9IG9mIGl0cyBjb250ZW50cycgbGVuZ3RoLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzXHJcbiAgICAgKiAgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uIFdpbGwgc2V0IGBvZmZzZXQgPSAwYCBhbmQgYGxpbWl0ID0gY2FwYWNpdHlgIGFuZFxyXG4gICAgICogIGFkYXB0IHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0gdG8gdGhlIHNhbWUgcmVsYXRpdmUgcG9zaXRpb24gaWYgc2V0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gc3RhcnQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSAwICYmIGVuZCA9PT0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEFscmVhZHkgY29tcGFjdGVkXHJcbiAgICAgICAgdmFyIGxlbiA9IGVuZCAtIGJlZ2luO1xyXG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBFTVBUWV9CVUZGRVI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCAtPSBiZWdpbjtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmxpbWl0ID0gMDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuKTtcclxuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgdmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KGJlZ2luLCBlbmQpKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCAtPSBiZWdpbjtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IGxlbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IENvcHlcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPT09IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKDAsIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICB2YXIgY2FwYWNpdHkgPSBlbmQgLSBiZWdpbixcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihjYXBhY2l0eSwgdGhpcy5saXR0bGVFbmRpYW4sIHRoaXMubm9Bc3NlcnQpO1xyXG4gICAgICAgIGJiLm9mZnNldCA9IDA7XHJcbiAgICAgICAgYmIubGltaXQgPSBjYXBhY2l0eTtcclxuICAgICAgICBpZiAoYmIubWFya2VkT2Zmc2V0ID49IDApIGJiLm1hcmtlZE9mZnNldCAtPSBiZWdpbjtcclxuICAgICAgICB0aGlzLmNvcHlUbyhiYiwgMCwgYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhbm90aGVyIEJ5dGVCdWZmZXIuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB0YXJnZXRPZmZzZXQgT2Zmc2V0IHRvIGNvcHkgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB0aGUgdGFyZ2V0J3Mge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fVxyXG4gICAgICogIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgY29waWVkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHNvdXJjZU9mZnNldCBPZmZzZXQgdG8gc3RhcnQgY29weWluZyBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGVcclxuICAgICAqICBudW1iZXIgb2YgYnl0ZXMgY29waWVkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHNvdXJjZUxpbWl0IE9mZnNldCB0byBlbmQgY29weWluZyBmcm9tLCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvcHlUbyA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0T2Zmc2V0LCBzb3VyY2VPZmZzZXQsIHNvdXJjZUxpbWl0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlLFxyXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZTtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKCFCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih0YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQ6IE5vdCBhIEJ5dGVCdWZmZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldE9mZnNldCA9ICh0YXJnZXRSZWxhdGl2ZSA9IHR5cGVvZiB0YXJnZXRPZmZzZXQgPT09ICd1bmRlZmluZWQnKSA/IHRhcmdldC5vZmZzZXQgOiB0YXJnZXRPZmZzZXQgfCAwO1xyXG4gICAgICAgIHNvdXJjZU9mZnNldCA9IChyZWxhdGl2ZSA9IHR5cGVvZiBzb3VyY2VPZmZzZXQgPT09ICd1bmRlZmluZWQnKSA/IHRoaXMub2Zmc2V0IDogc291cmNlT2Zmc2V0IHwgMDtcclxuICAgICAgICBzb3VyY2VMaW1pdCA9IHR5cGVvZiBzb3VyY2VMaW1pdCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmxpbWl0IDogc291cmNlTGltaXQgfCAwO1xyXG5cclxuICAgICAgICBpZiAodGFyZ2V0T2Zmc2V0IDwgMCB8fCB0YXJnZXRPZmZzZXQgPiB0YXJnZXQuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHRhcmdldCByYW5nZTogMCA8PSBcIit0YXJnZXRPZmZzZXQrXCIgPD0gXCIrdGFyZ2V0LmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBpZiAoc291cmNlT2Zmc2V0IDwgMCB8fCBzb3VyY2VMaW1pdCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHNvdXJjZSByYW5nZTogMCA8PSBcIitzb3VyY2VPZmZzZXQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcblxyXG4gICAgICAgIHZhciBsZW4gPSBzb3VyY2VMaW1pdCAtIHNvdXJjZU9mZnNldDtcclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0OyAvLyBOb3RoaW5nIHRvIGNvcHlcclxuXHJcbiAgICAgICAgdGFyZ2V0LmVuc3VyZUNhcGFjaXR5KHRhcmdldE9mZnNldCArIGxlbik7XHJcblxyXG4gICAgICAgIHRhcmdldC52aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkoc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCksIHRhcmdldE9mZnNldCk7XHJcblxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgIGlmICh0YXJnZXRSZWxhdGl2ZSkgdGFyZ2V0Lm9mZnNldCArPSBsZW47XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHN1cmUgdGhhdCB0aGlzIEJ5dGVCdWZmZXIgaXMgYmFja2VkIGJ5IGEge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfSBvZiBhdCBsZWFzdCB0aGUgc3BlY2lmaWVkIGNhcGFjaXR5LiBJZiB0aGVcclxuICAgICAqICBjdXJyZW50IGNhcGFjaXR5IGlzIGV4Y2VlZGVkLCBpdCB3aWxsIGJlIGRvdWJsZWQuIElmIGRvdWJsZSB0aGUgY3VycmVudCBjYXBhY2l0eSBpcyBsZXNzIHRoYW4gdGhlIHJlcXVpcmVkIGNhcGFjaXR5LFxyXG4gICAgICogIHRoZSByZXF1aXJlZCBjYXBhY2l0eSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eSBSZXF1aXJlZCBjYXBhY2l0eVxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHkgPSBmdW5jdGlvbihjYXBhY2l0eSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICBpZiAoY3VycmVudCA8IGNhcGFjaXR5KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNpemUoKGN1cnJlbnQgKj0gMikgPiBjYXBhY2l0eSA/IGN1cnJlbnQgOiBjYXBhY2l0eSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcndyaXRlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgQnl0ZSB2YWx1ZSB0byBmaWxsIHdpdGguIElmIGdpdmVuIGFzIGEgc3RyaW5nLCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIHVzZWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldC4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC4gZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQGV4YW1wbGUgYHNvbWVCeXRlQnVmZmVyLmNsZWFyKCkuZmlsbCgwKWAgZmlsbHMgdGhlIGVudGlyZSBiYWNraW5nIGJ1ZmZlciB3aXRoIHplcm9lc1xyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbih2YWx1ZSwgYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgYmVnaW4gPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVnaW4gPj0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBmaWxsXHJcbiAgICAgICAgd2hpbGUgKGJlZ2luIDwgZW5kKSB0aGlzLnZpZXdbYmVnaW4rK10gPSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ID0gYmVnaW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgdGhpcyBCeXRlQnVmZmVyIHJlYWR5IGZvciBhIG5ldyBzZXF1ZW5jZSBvZiB3cml0ZSBvciByZWxhdGl2ZSByZWFkIG9wZXJhdGlvbnMuIFNldHMgYGxpbWl0ID0gb2Zmc2V0YCBhbmRcclxuICAgICAqICBgb2Zmc2V0ID0gMGAuIE1ha2Ugc3VyZSBhbHdheXMgdG8gZmxpcCBhIEJ5dGVCdWZmZXIgd2hlbiBhbGwgcmVsYXRpdmUgcmVhZCBvciB3cml0ZSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmxpbWl0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTWFya3MgYW4gb2Zmc2V0IG9uIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSB1c2VkIGxhdGVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIG1hcmsuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVzZXRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgb2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9mZnNldCA6IG9mZnNldDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYnl0ZSBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGl0dGxlRW5kaWFuIGB0cnVlYCBmb3IgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLCBgZmFsc2VgIGZvciBiaWcgZW5kaWFuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpdHRsZUVuZGlhbiAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsaXR0bGVFbmRpYW46IE5vdCBhIGJvb2xlYW5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gISFsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoZXMgKHRvKSBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gRGVmYXVsdHMgdG8gYHRydWVgLCBvdGhlcndpc2UgdXNlcyBiaWcgZW5kaWFuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5MRSA9IGZ1bmN0aW9uKGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHlwZW9mIGxpdHRsZUVuZGlhbiAhPT0gJ3VuZGVmaW5lZCcgPyAhIWxpdHRsZUVuZGlhbiA6IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoZXMgKHRvKSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBiaWdFbmRpYW4gRGVmYXVsdHMgdG8gYHRydWVgLCBvdGhlcndpc2UgdXNlcyBsaXR0bGUgZW5kaWFuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5CRSA9IGZ1bmN0aW9uKGJpZ0VuZGlhbikge1xyXG4gICAgICAgIHRoaXMubGl0dGxlRW5kaWFuID0gdHlwZW9mIGJpZ0VuZGlhbiAhPT0gJ3VuZGVmaW5lZCcgPyAhYmlnRW5kaWFuIDogZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kcyBzb21lIGRhdGEgdG8gdGhpcyBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWZvcmUgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlXHJcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqICB3aWxsIGJlIHJlc2l6ZWQgYW5kIGl0cyBjb250ZW50cyBtb3ZlZCBhY2NvcmRpbmdseS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8c3RyaW5nfCFBcnJheUJ1ZmZlcn0gc291cmNlIERhdGEgdG8gcHJlcGVuZC4gSWYgYHNvdXJjZWAgaXMgYSBCeXRlQnVmZmVyLCBpdHMgb2Zmc2V0IHdpbGwgYmVcclxuICAgICAqICBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZW5jb2RpbmcgRW5jb2RpbmcgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBwcmVwZW5kIGF0LiBXaWxsIHVzZSBhbmQgZGVjcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcHJlcGVuZGVkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4pYCByZXN1bHRzIGluIGA8MDQgMDUgMDEgMDIgMDM+LCAwNCAwNXxgXHJcbiAgICAgKiBAZXhhbXBsZSBBbiBhYnNvbHV0ZSBgMDA8MDEgMDIgMDM+LnByZXBlbmQoPDA0IDA1PiwgMilgIHJlc3VsdHMgaW4gYDA0PDA1IDAyIDAzPiwgMDQgMDV8YFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihzb3VyY2UsIGVuY29kaW5nLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgQnl0ZUJ1ZmZlcikpXHJcbiAgICAgICAgICAgIHNvdXJjZSA9IEJ5dGVCdWZmZXIud3JhcChzb3VyY2UsIGVuY29kaW5nKTtcclxuICAgICAgICB2YXIgbGVuID0gc291cmNlLmxpbWl0IC0gc291cmNlLm9mZnNldDtcclxuICAgICAgICBpZiAobGVuIDw9IDApIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIHByZXBlbmRcclxuICAgICAgICB2YXIgZGlmZiA9IGxlbiAtIG9mZnNldDtcclxuICAgICAgICBpZiAoZGlmZiA+IDApIHsgLy8gTm90IGVub3VnaCBzcGFjZSBiZWZvcmUgb2Zmc2V0LCBzbyByZXNpemUgKyBtb3ZlXHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCArIGRpZmYpO1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShvZmZzZXQsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpLCBsZW4pO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gZGlmZjtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWFya2VkT2Zmc2V0ID49IDApIHRoaXMubWFya2VkT2Zmc2V0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIHRoaXMubGltaXQgKz0gZGlmZjtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGRpZmY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGFycmF5VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3LnNldChzb3VyY2Uudmlldy5zdWJhcnJheShzb3VyY2Uub2Zmc2V0LCBzb3VyY2UubGltaXQpLCBvZmZzZXQgLSBsZW4pO1xyXG5cclxuICAgICAgICBzb3VyY2Uub2Zmc2V0ID0gc291cmNlLmxpbWl0O1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSlcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByZXBlbmRzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhbm90aGVyIEJ5dGVCdWZmZXIuIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGNvbnRlbnRzIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCB1cCB0byB0aGVcclxuICAgICAqICBwcmVwZW5kZWQgZGF0YSdzIGxlbmd0aC4gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdmFpbGFibGUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgYG9mZnNldGAsIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogIHdpbGwgYmUgcmVzaXplZCBhbmQgaXRzIGNvbnRlbnRzIG1vdmVkIGFjY29yZGluZ2x5LlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcHJlcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGRlY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHByZXBlbmRlZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcHJlcGVuZFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnByZXBlbmRUbyA9IGZ1bmN0aW9uKHRhcmdldCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0LnByZXBlbmQodGhpcywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByaW50cyBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nKT19IG91dCBPdXRwdXQgZnVuY3Rpb24gdG8gY2FsbCwgZGVmYXVsdHMgdG8gY29uc29sZS5sb2dcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmludERlYnVnID0gZnVuY3Rpb24ob3V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvdXQgIT09ICdmdW5jdGlvbicpIG91dCA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XHJcbiAgICAgICAgb3V0KFxyXG4gICAgICAgICAgICB0aGlzLnRvU3RyaW5nKCkrXCJcXG5cIitcclxuICAgICAgICAgICAgXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIrXHJcbiAgICAgICAgICAgIHRoaXMudG9EZWJ1ZygvKiBjb2x1bW5zICovIHRydWUpXHJcbiAgICAgICAgKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIHJlYWRhYmxlIGJ5dGVzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0sIHNvIHRoaXMgcmV0dXJucyBgbGltaXQgLSBvZmZzZXRgLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmVtYWluaW5nIHJlYWRhYmxlIGJ5dGVzLiBNYXkgYmUgbmVnYXRpdmUgaWYgYG9mZnNldCA+IGxpbWl0YC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZW1haW5pbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdCAtIHRoaXMub2Zmc2V0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoaXMgQnl0ZUJ1ZmZlcidzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uIElmIGFuIG9mZnNldCBoYXMgYmVlbiBtYXJrZWQgdGhyb3VnaCB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrfVxyXG4gICAgICogIGJlZm9yZSwgYG9mZnNldGAgd2lsbCBiZSBzZXQgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fSwgd2hpY2ggd2lsbCB0aGVuIGJlIGRpc2NhcmRlZC4gSWYgbm8gb2Zmc2V0IGhhcyBiZWVuXHJcbiAgICAgKiAgbWFya2VkLCBzZXRzIGBvZmZzZXQgPSAwYC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI21hcmtcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5tYXJrZWRPZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhpcyBCeXRlQnVmZmVyIHRvIGJlIGJhY2tlZCBieSBhIGJ1ZmZlciBvZiBhdCBsZWFzdCB0aGUgZ2l2ZW4gY2FwYWNpdHkuIFdpbGwgZG8gbm90aGluZyBpZiBhbHJlYWR5IHRoYXRcclxuICAgICAqICBsYXJnZSBvciBsYXJnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHkgQ2FwYWNpdHkgcmVxdWlyZWRcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgY2FwYWNpdHlgIGlzIG5vdCBhIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYGNhcGFjaXR5IDwgMGBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbihjYXBhY2l0eSkge1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhcGFjaXR5ICE9PSAnbnVtYmVyJyB8fCBjYXBhY2l0eSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBjYXBhY2l0eTogXCIrY2FwYWNpdHkrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIGNhcGFjaXR5IHw9IDA7XG4gICAgICAgICAgICBpZiAoY2FwYWNpdHkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IDAgPD0gXCIrY2FwYWNpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA8IGNhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY2FwYWNpdHkpO1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHZpZXcuc2V0KHRoaXMudmlldyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldmVyc2VzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gc3RhcnQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBOb3RoaW5nIHRvIHJldmVyc2VcclxuICAgICAgICBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKHRoaXMudmlldy5zdWJhcnJheShiZWdpbiwgZW5kKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTa2lwcyB0aGUgbmV4dCBgbGVuZ3RoYCBieXRlcy4gVGhpcyB3aWxsIGp1c3QgYWR2YW5jZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcC4gTWF5IGFsc28gYmUgbmVnYXRpdmUgdG8gbW92ZSB0aGUgb2Zmc2V0IGJhY2suXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24obGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBsZW5ndGggJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiBcIitsZW5ndGgrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIGxlbmd0aCB8PSAwO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgbGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgbGVuZ3RoOiAwIDw9IFwiK3RoaXMub2Zmc2V0K1wiICsgXCIrbGVuZ3RoK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTbGljZXMgdGhpcyBCeXRlQnVmZmVyIGJ5IGNyZWF0aW5nIGEgY2xvbmVkIGluc3RhbmNlIHdpdGggYG9mZnNldCA9IGJlZ2luYCBhbmQgYGxpbWl0ID0gZW5kYC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDbG9uZSBvZiB0aGlzIEJ5dGVCdWZmZXIgd2l0aCBzbGljaW5nIGFwcGxpZWQsIGJhY2tlZCBieSB0aGUgc2FtZSB7QGxpbmsgQnl0ZUJ1ZmZlciNidWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYiA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICBiYi5vZmZzZXQgPSBiZWdpbjtcclxuICAgICAgICBiYi5saW1pdCA9IGVuZDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYmFja2luZyBidWZmZXIgdGhhdCBjb250YWlucyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VDb3B5IElmIGB0cnVlYCByZXR1cm5zIGEgY29weSwgb3RoZXJ3aXNlIHJldHVybnMgYSB2aWV3IHJlZmVyZW5jaW5nIHRoZSBzYW1lIG1lbW9yeSBpZlxyXG4gICAgICogIHBvc3NpYmxlLiBEZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5QnVmZmVyfSBDb250ZW50cyBhcyBhbiBBcnJheUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oZm9yY2VDb3B5KSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0LFxyXG4gICAgICAgICAgICBsaW1pdCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fCBsaW1pdCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsaW1pdDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBsaW1pdCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBsaW1pdCB8fCBsaW1pdCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrb2Zmc2V0K1wiIDw9IFwiK2xpbWl0K1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogSXQncyBub3QgcG9zc2libGUgdG8gaGF2ZSBhbm90aGVyIEFycmF5QnVmZmVyIHJlZmVyZW5jZSB0aGUgc2FtZSBtZW1vcnkgYXMgdGhlIGJhY2tpbmcgYnVmZmVyLiBUaGlzIGlzXHJcbiAgICAgICAgLy8gcG9zc2libGUgd2l0aCBVaW50OEFycmF5I3N1YmFycmF5IG9ubHksIGJ1dCB3ZSBoYXZlIHRvIHJldHVybiBhbiBBcnJheUJ1ZmZlciBieSBjb250cmFjdC4gU286XHJcbiAgICAgICAgaWYgKCFmb3JjZUNvcHkgJiYgb2Zmc2V0ID09PSAwICYmIGxpbWl0ID09PSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gbGltaXQpXHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsaW1pdCAtIG9mZnNldCk7XHJcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpLnN1YmFycmF5KG9mZnNldCwgbGltaXQpLCAwKTtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSByYXcgYnVmZmVyIGNvbXBhY3RlZCB0byBjb250YWluIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjdG9CdWZmZXJ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZUNvcHkgSWYgYHRydWVgIHJldHVybnMgYSBjb3B5LCBvdGhlcndpc2UgcmV0dXJucyBhIHZpZXcgcmVmZXJlbmNpbmcgdGhlIHNhbWUgbWVtb3J5LlxyXG4gICAgICogIERlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHshQXJyYXlCdWZmZXJ9IENvbnRlbnRzIGFzIGFuIEFycmF5QnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CdWZmZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmNvZGluZyBPdXRwdXQgZW5jb2RpbmcuIFJldHVybnMgYW4gaW5mb3JtYXRpdmUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlmIG9taXR0ZWQgYnV0IGFsc28gYWxsb3dzXHJcbiAgICAgKiAgZGlyZWN0IGNvbnZlcnNpb24gdG8gXCJ1dGY4XCIsIFwiaGV4XCIsIFwiYmFzZTY0XCIgYW5kIFwiYmluYXJ5XCIgZW5jb2RpbmcuIFwiZGVidWdcIiByZXR1cm5zIGEgaGV4IHJlcHJlc2VudGF0aW9uIHdpdGhcclxuICAgICAqICBoaWdobGlnaHRlZCBvZmZzZXRzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fVxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGVuY29kaW5nYCBpcyBpbnZhbGlkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJCeXRlQnVmZmVyQUIob2Zmc2V0PVwiK3RoaXMub2Zmc2V0K1wiLG1hcmtlZE9mZnNldD1cIit0aGlzLm1hcmtlZE9mZnNldCtcIixsaW1pdD1cIit0aGlzLmxpbWl0K1wiLGNhcGFjaXR5PVwiK3RoaXMuY2FwYWNpdHkoKStcIilcIjtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSBcInV0ZjhcIixcclxuICAgICAgICAgICAgYmVnaW4gPSBlbmNvZGluZyxcclxuICAgICAgICAgICAgZW5kID0gYmVnaW47XHJcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xyXG4gICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VVEY4KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0Jhc2U2NChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImhleFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQmluYXJ5KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGVidWcoKTtcclxuICAgICAgICAgICAgY2FzZSBcImNvbHVtbnNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQ29sdW1ucygpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZzogXCIrZW5jb2RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gbHhpdi1lbWJlZGRhYmxlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBseGl2LWVtYmVkZGFibGUgKGMpIDIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICAgICAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbHhpdiBmb3IgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICB2YXIgbHhpdiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBseGl2IG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqIEBleHBvcnRzIGx4aXZcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgbHhpdiA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFyYWN0ZXIgY29kZXMgZm9yIG91dHB1dC5cclxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBhb3V0ID0gW1xyXG4gICAgICAgICAgICA2NSwgNjYsIDY3LCA2OCwgNjksIDcwLCA3MSwgNzIsIDczLCA3NCwgNzUsIDc2LCA3NywgNzgsIDc5LCA4MCxcclxuICAgICAgICAgICAgODEsIDgyLCA4MywgODQsIDg1LCA4NiwgODcsIDg4LCA4OSwgOTAsIDk3LCA5OCwgOTksIDEwMCwgMTAxLCAxMDIsXHJcbiAgICAgICAgICAgIDEwMywgMTA0LCAxMDUsIDEwNiwgMTA3LCAxMDgsIDEwOSwgMTEwLCAxMTEsIDExMiwgMTEzLCAxMTQsIDExNSwgMTE2LCAxMTcsIDExOCxcclxuICAgICAgICAgICAgMTE5LCAxMjAsIDEyMSwgMTIyLCA0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDMsIDQ3XHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhcmFjdGVyIGNvZGVzIGZvciBpbnB1dC5cclxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxudW1iZXI+fVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBhaW4gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGs9YW91dC5sZW5ndGg7IGk8azsgKytpKVxyXG4gICAgICAgICAgICBhaW5bYW91dFtpXV0gPSBpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIGJ5dGVzIHRvIGJhc2U2NCBjaGFyIGNvZGVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBCeXRlcyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgYnl0ZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmXHJcbiAgICAgICAgICogIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENoYXJhY3RlcnMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBlbmNvZGVkIGNoYXJcclxuICAgICAgICAgKiAgY29kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBseGl2LmVuY29kZSA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBiLCB0O1xyXG4gICAgICAgICAgICB3aGlsZSAoKGIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRzdChhb3V0WyhiPj4yKSYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICB0ID0gKGImMHgzKTw8NDtcclxuICAgICAgICAgICAgICAgIGlmICgoYiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgfD0gKGI+PjQpJjB4ZjtcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFsodHwoKGI+PjQpJjB4ZikpJjB4M2ZdKTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gKGImMHhmKTw8MjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGIgPSBzcmMoKSkgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdChhb3V0Wyh0fCgoYj4+NikmMHgzKSkmMHgzZl0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFtiJjB4M2ZdKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W3QmMHgzZl0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoNjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbdCYweDNmXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KDYxKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoNjEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBiYXNlNjQgY2hhciBjb2RlcyB0byBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIGNoYXJhY3RlciBjb2RlIGlzIGludmFsaWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBseGl2LmRlY29kZSA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjLCB0MSwgdDI7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZhaWwoYykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBjb2RlOiBcIitjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MSA9PT0gJ3VuZGVmaW5lZCcpIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQyID09PSAndW5kZWZpbmVkJykgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKHQxPDwyKT4+PjB8KHQyJjB4MzApPj40KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoKCh0MiYweGYpPDw0KT4+PjB8KHQxJjB4M2MpPj4yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDIgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSA2MSkgYnJlYWs7IGVsc2UgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoKHQxJjB4Myk8PDYpPj4+MHx0Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHN0cmluZyBpcyB2YWxpZCBiYXNlNjQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gdGVzdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdmFsaWQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi50ZXN0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBseGl2O1xyXG4gICAgfSgpO1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9iYXNlNjRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYGJlZ2luYCBvciBgZW5kYCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CYXNlNjQgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGJlZ2luID0gYmVnaW4gfCAwOyBlbmQgPSBlbmQgfCAwO1xyXG4gICAgICAgIGlmIChiZWdpbiA8IDAgfHwgZW5kID4gdGhpcy5jYXBhY2l0eSB8fCBiZWdpbiA+IGVuZClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImJlZ2luLCBlbmRcIik7XHJcbiAgICAgICAgdmFyIHNkOyBseGl2LmVuY29kZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlZ2luIDwgZW5kID8gdGhpcy52aWV3W2JlZ2luKytdIDogbnVsbDtcclxuICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSk7XHJcbiAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21CYXNlNjQgPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKHN0ci5sZW5ndGgvNCozLCBsaXR0bGVFbmRpYW4pLFxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICBseGl2LmRlY29kZShzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gaTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBhIGJpbmFyeSBzdHJpbmcgdG8gYmFzZTY0IGxpa2UgYHdpbmRvdy5idG9hYCBkb2VzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBCaW5hcnkgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5idG9hXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYnRvYSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoc3RyKS50b0Jhc2U2NCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYmluYXJ5IGxpa2UgYHdpbmRvdy5hdG9iYCBkb2VzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGI2NCBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSBzdHJpbmdcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5hdG9iXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYXRvYiA9IGZ1bmN0aW9uKGI2NCkge1xyXG4gICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CYXNlNjQoYjY0KS50b0JpbmFyeSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvYmluYXJ5XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZywgdGhhdCBpcyB1c2luZyBvbmx5IGNoYXJhY3RlcnMgMHgwMC0weEZGIGFzIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCaW5hcnkgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXQgPiBsaW1pdGBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0JpbmFyeSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgYmVnaW4gfD0gMDsgZW5kIHw9IDA7XHJcbiAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBlbmQgPiB0aGlzLmNhcGFjaXR5KCkgfHwgYmVnaW4gPiBlbmQpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB2YXIgY2hhcnMgPSBbXSxcclxuICAgICAgICAgICAgcGFydHMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHtcclxuICAgICAgICAgICAgY2hhcnMucHVzaCh0aGlzLnZpZXdbYmVnaW4rK10pO1xyXG4gICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID49IDEwMjQpXHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaGFycykpLFxyXG4gICAgICAgICAgICAgICAgY2hhcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpICsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNoYXJzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgYmluYXJ5IGVuY29kZWQgc3RyaW5nLCB0aGF0IGlzIHVzaW5nIG9ubHkgY2hhcmFjdGVycyAweDAwLTB4RkYgYXMgYnl0ZXMsIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeSA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJzdHJcIik7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgY2hhckNvZGUsXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoaywgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+IDB4ZmYpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiaWxsZWdhbCBjaGFyIGNvZGU6IFwiK2NoYXJDb2RlKTtcclxuICAgICAgICAgICAgYmIudmlld1tpKytdID0gY2hhckNvZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLmxpbWl0ID0gaztcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9kZWJ1Z1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcgd2l0aCBtYXJrZWQgb2Zmc2V0cy4gT2Zmc2V0IHN5bWJvbHMgYXJlOlxyXG4gICAgICogKiBgPGAgOiBvZmZzZXQsXHJcbiAgICAgKiAqIGAnYCA6IG1hcmtlZE9mZnNldCxcclxuICAgICAqICogYD5gIDogbGltaXQsXHJcbiAgICAgKiAqIGB8YCA6IG9mZnNldCBhbmQgbGltaXQsXHJcbiAgICAgKiAqIGBbYCA6IG9mZnNldCBhbmQgbWFya2VkT2Zmc2V0LFxyXG4gICAgICogKiBgXWAgOiBtYXJrZWRPZmZzZXQgYW5kIGxpbWl0LFxyXG4gICAgICogKiBgIWAgOiBvZmZzZXQsIG1hcmtlZE9mZnNldCBhbmQgbGltaXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbHVtbnMgSWYgYHRydWVgIHJldHVybnMgdHdvIGNvbHVtbnMgaGV4ICsgYXNjaWksIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IUFycmF5LjxzdHJpbmc+fSBEZWJ1ZyBzdHJpbmcgb3IgYXJyYXkgb2YgbGluZXMgaWYgYGFzQXJyYXkgPSB0cnVlYFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQGV4YW1wbGUgYD4wMCcwMSAwMjwwM2AgY29udGFpbnMgZm91ciBieXRlcyB3aXRoIGBsaW1pdD0wLCBtYXJrZWRPZmZzZXQ9MSwgb2Zmc2V0PTNgXHJcbiAgICAgKiBAZXhhbXBsZSBgMDBbMDEgMDIgMDM+YCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYG9mZnNldD1tYXJrZWRPZmZzZXQ9MSwgbGltaXQ9NGBcclxuICAgICAqIEBleGFtcGxlIGAwMHwwMSAwMiAwM2AgY29udGFpbnMgZm91ciBieXRlcyB3aXRoIGBvZmZzZXQ9bGltaXQ9MSwgbWFya2VkT2Zmc2V0PS0xYFxyXG4gICAgICogQGV4YW1wbGUgYHxgIGNvbnRhaW5zIHplcm8gYnl0ZXMgd2l0aCBgb2Zmc2V0PWxpbWl0PTAsIG1hcmtlZE9mZnNldD0tMWBcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0RlYnVnID0gZnVuY3Rpb24oY29sdW1ucykge1xyXG4gICAgICAgIHZhciBpID0gLTEsXHJcbiAgICAgICAgICAgIGsgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoLFxyXG4gICAgICAgICAgICBiLFxyXG4gICAgICAgICAgICBoZXggPSBcIlwiLFxyXG4gICAgICAgICAgICBhc2MgPSBcIlwiLFxyXG4gICAgICAgICAgICBvdXQgPSBcIlwiO1xyXG4gICAgICAgIHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gdGhpcy52aWV3W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGIgPCAweDEwKSBoZXggKz0gXCIwXCIrYi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaGV4ICs9IGIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucylcclxuICAgICAgICAgICAgICAgICAgICBhc2MgKz0gYiA+IDMyICYmIGIgPCAxMjcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpIDogJy4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgaWYgKGNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpID4gMCAmJiBpICUgMTYgPT09IDAgJiYgaSAhPT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMyoxNiszKSBoZXggKz0gXCIgXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IGhleCthc2MrXCJcXG5cIjtcclxuICAgICAgICAgICAgICAgICAgICBoZXggPSBhc2MgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpID09PSB0aGlzLm9mZnNldCAmJiBpID09PSB0aGlzLmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IGkgPT09IHRoaXMubWFya2VkT2Zmc2V0ID8gXCIhXCIgOiBcInxcIjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gdGhpcy5vZmZzZXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIltcIiA6IFwiPFwiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSB0aGlzLmxpbWl0KVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IGkgPT09IHRoaXMubWFya2VkT2Zmc2V0ID8gXCJdXCIgOiBcIj5cIjtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaGV4ICs9IGkgPT09IHRoaXMubWFya2VkT2Zmc2V0ID8gXCInXCIgOiAoY29sdW1ucyB8fCAoaSAhPT0gMCAmJiBpICE9PSBrKSA/IFwiIFwiIDogXCJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2x1bW5zICYmIGhleCAhPT0gXCIgXCIpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGhleC5sZW5ndGggPCAzKjE2KzMpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIG91dCArPSBoZXggKyBhc2MgKyBcIlxcblwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sdW1ucyA/IG91dCA6IGhleDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHdpdGggbWFya2VkIG9mZnNldHMgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBEZWJ1ZyBzdHJpbmcgdG8gZGVjb2RlIChub3QgYmUgZ2VuZXJhdGVkIHdpdGggYGNvbHVtbnMgPSB0cnVlYClcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3RvRGVidWdcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tRGVidWcgPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICB2YXIgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoKChrKzEpLzMpfDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgIHZhciBpID0gMCwgaiA9IDAsIGNoLCBiLFxyXG4gICAgICAgICAgICBycyA9IGZhbHNlLCAvLyBSZXF1aXJlIHN5bWJvbCBuZXh0XHJcbiAgICAgICAgICAgIGhvID0gZmFsc2UsIGhtID0gZmFsc2UsIGhsID0gZmFsc2UsIC8vIEFscmVhZHkgaGFzIG9mZnNldCAoaG8pLCBtYXJrZWRPZmZzZXQgKGhtKSwgbGltaXQgKGhsKT9cclxuICAgICAgICAgICAgZmFpbCA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgc3dpdGNoIChjaCA9IHN0ci5jaGFyQXQoaSsrKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnISc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8gfHwgaG0gfHwgaGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSBobSA9IGhsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYmIubWFya2VkT2Zmc2V0ID0gYmIubGltaXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd8JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYmIubGltaXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdbJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaG8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICddJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobCB8fCBobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobCA9IGhtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcIidcIjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJyAnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBwYXJzZUludChjaCtzdHIuY2hhckF0KGkrKyksIDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihiKSB8fCBiIDwgMCB8fCBiID4gMjU1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIGRlYnVnIGVuY29kZWQgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi52aWV3W2orK10gPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmFpbClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBJbnZhbGlkIHN5bWJvbCBhdCBcIitpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAoIWhvIHx8ICFobClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBNaXNzaW5nIG9mZnNldCBvciBsaW1pdFwiKTtcclxuICAgICAgICAgICAgaWYgKGo8YmIuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmcgKGlzIGl0IGhleD8pIFwiK2orXCIgPCBcIitrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvaGV4XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBiZWdpbiA9IHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9mZnNldCA6IGJlZ2luO1xyXG4gICAgICAgIGVuZCA9IHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5saW1pdCA6IGVuZDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKSxcclxuICAgICAgICAgICAgYjtcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHtcclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tiZWdpbisrXTtcclxuICAgICAgICAgICAgaWYgKGIgPCAweDEwKVxyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goXCIwXCIsIGIudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgZWxzZSBvdXQucHVzaChiLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQuam9pbignJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21IZXggPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoICUgMiAhPT0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBMZW5ndGggbm90IGEgbXVsdGlwbGUgb2YgMlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYiA9IG5ldyBCeXRlQnVmZmVyKChrIC8gMikgfCAwLCBsaXR0bGVFbmRpYW4pLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIGZvciAodmFyIGk9MCwgaj0wOyBpPGs7IGkrPTIpIHtcclxuICAgICAgICAgICAgYiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSsyKSwgMTYpO1xyXG4gICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShiKSB8fCBiIDwgMCB8fCBiID4gMjU1KVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBDb250YWlucyBub24taGV4IGNoYXJhY3RlcnNcIik7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaisrXSA9IGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJiLmxpbWl0ID0gajtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHV0ZngtZW1iZWRkYWJsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogdXRmeC1lbWJlZGRhYmxlIChjKSAyMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAgICAgKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3V0ZnggZm9yIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgdmFyIHV0ZnggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdXRmeCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgdXRmeCA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIHZhbGlkIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAY29uc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4Lk1BWF9DT0RFUE9JTlQgPSAweDEwRkZGRjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjggYnl0ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpIHwgbnVtYmVyfSBzcmMgQ29kZSBwb2ludHMgc291cmNlLCBlaXRoZXIgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludFxyXG4gICAgICAgICAqICByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQgb3IgYSBzaW5nbGUgbnVtZXJpYyBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5lbmNvZGVVVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGNwID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgY3AgPSBzcmMsXHJcbiAgICAgICAgICAgICAgICBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgICAgIHdoaWxlIChjcCAhPT0gbnVsbCB8fCAoY3AgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjcCA8IDB4ODApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwJjB4N0YpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3AgPCAweDgwMClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+NikmMHgxRil8MHhDMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNwIDwgMHgxMDAwMClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTIpJjB4MEYpfDB4RTApLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xOCkmMHgwNyl8MHhGMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjEyKSYweDNGKXwweDgwKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+NikmMHgzRil8MHg4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCYweDNGKXwweDgwKTtcclxuICAgICAgICAgICAgICAgIGNwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgVVRGOCBieXRlcyB0byBVVEY4IGNvZGUgcG9pbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBCeXRlcyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgYnl0ZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlXHJcbiAgICAgICAgICogIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENvZGUgcG9pbnRzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggZGVjb2RlZCBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGEgc3RhcnRpbmcgYnl0ZSBpcyBpbnZhbGlkIGluIFVURjhcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxhc3Qgc2VxdWVuY2UgaXMgdHJ1bmNhdGVkLiBIYXMgYW4gYXJyYXkgcHJvcGVydHkgYGJ5dGVzYCBob2xkaW5nIHRoZVxyXG4gICAgICAgICAqICByZW1haW5pbmcgYnl0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGIsIGMsIGQsIGZhaWwgPSBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgICAgICBiID0gYi5zbGljZSgwLCBiLmluZGV4T2YobnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKGIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBlcnIubmFtZSA9IFwiVHJ1bmNhdGVkRXJyb3JcIjtcclxuICAgICAgICAgICAgICAgIGVyclsnYnl0ZXMnXSA9IGI7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICgoYSA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChhJjB4ODApID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChhJjB4RTApID09PSAweEMwKVxyXG4gICAgICAgICAgICAgICAgICAgICgoYiA9IHNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYl0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGEmMHgxRik8PDYpIHwgKGImMHgzRikpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhGMCkgPT09IDB4RTApXHJcbiAgICAgICAgICAgICAgICAgICAgKChiPXNyYygpKSA9PT0gbnVsbCB8fCAoYz1zcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGIsIGNdKSxcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChhJjB4MEYpPDwxMikgfCAoKGImMHgzRik8PDYpIHwgKGMmMHgzRikpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhGOCkgPT09IDB4RjApXHJcbiAgICAgICAgICAgICAgICAgICAgKChiPXNyYygpKSA9PT0gbnVsbCB8fCAoYz1zcmMoKSkgPT09IG51bGwgfHwgKGQ9c3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiLCBjICxkXSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoYSYweDA3KTw8MTgpIHwgKChiJjB4M0YpPDwxMikgfCAoKGMmMHgzRik8PDYpIHwgKGQmMHgzRikpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzdGFydGluZyBieXRlOiBcIithKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIFVURjE2IGNoYXJhY3RlcnMgdG8gVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDb2RlIHBvaW50cyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGNvbnZlcnRlZCBjb2RlXHJcbiAgICAgICAgICogIHBvaW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguVVRGMTZ0b1VURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYzEsIGMyID0gbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYzEgPSBjMiAhPT0gbnVsbCA/IGMyIDogc3JjKCkpID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMxID49IDB4RDgwMCAmJiBjMSA8PSAweERGRkYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGMyID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjMiA+PSAweERDMDAgJiYgYzIgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3QoKGMxLTB4RDgwMCkqMHg0MDArYzItMHhEQzAwKzB4MTAwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzIgPSBudWxsOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRzdChjMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMyICE9PSBudWxsKSBkc3QoYzIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIFVURjggY29kZSBwb2ludHMgdG8gVVRGMTYgY2hhcmFjdGVycy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCkgfCBudW1iZXJ9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UsIGVpdGhlciBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENoYXJhY3RlcnMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY2hhciBjb2RlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGEgY29kZSBwb2ludCBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LlVURjh0b1VURjE2ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGNwID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgY3AgPSBzcmMsIHNyYyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfTtcclxuICAgICAgICAgICAgd2hpbGUgKGNwICE9PSBudWxsIHx8IChjcCA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNwIDw9IDB4RkZGRilcclxuICAgICAgICAgICAgICAgICAgICBkc3QoY3ApO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNwIC09IDB4MTAwMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcD4+MTApKzB4RDgwMCksXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KChjcCUweDQwMCkrMHhEQzAwKTtcclxuICAgICAgICAgICAgICAgIGNwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGFuZCBlbmNvZGVzIFVURjE2IGNoYXJhY3RlcnMgdG8gVVRGOCBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseSBgbnVsbGBcclxuICAgICAgICAgKiAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB1dGZ4LlVURjE2dG9VVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgIHV0ZnguZW5jb2RlVVRGOChjcCwgZHN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhbmQgY29udmVydHMgVVRGOCBieXRlcyB0byBVVEYxNiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBCeXRlcyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgYnl0ZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlXHJcbiAgICAgICAgICogIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENoYXJhY3RlcnMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY2hhciBjb2RlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGEgc3RhcnRpbmcgYnl0ZSBpcyBpbnZhbGlkIGluIFVURjhcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxhc3Qgc2VxdWVuY2UgaXMgdHJ1bmNhdGVkLiBIYXMgYW4gYXJyYXkgcHJvcGVydHkgYGJ5dGVzYCBob2xkaW5nIHRoZSByZW1haW5pbmcgYnl0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICB1dGZ4LlVURjh0b1VURjE2KGNwLCBkc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhbiBVVEY4IGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNwIFVURjggY29kZSBwb2ludFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVDb2RlUG9pbnQgPSBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCl9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludCByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQuXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVVVEY4ID0gZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICAgIHZhciBjcCwgbD0wO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGNwID0gc3JjKCkpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbCArPSAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICAgICAgcmV0dXJuIGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggY29kZSBwb2ludHMgcmVzcGVjdGl2ZWx5IFVURjggYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgVVRGMTYgY2hhciBjb2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCl9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gVGhlIG51bWJlciBvZiBVVEY4IGNvZGUgcG9pbnRzIGF0IGluZGV4IDAgYW5kIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZCBhdCBpbmRleCAxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjggPSBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICAgICAgdmFyIG49MCwgbD0wO1xyXG4gICAgICAgICAgICB1dGZ4LlVURjE2dG9VVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgICsrbjsgbCArPSAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbbixsXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdXRmeDtcclxuICAgIH0oKTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvdXRmOFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSB0byBhbiBVVEY4IGVuY29kZWRcclxuICAgICAqICBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXQgPiBsaW1pdGBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b1VURjggPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZDsgdHJ5IHtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiZWdpbiA8IGVuZCA/IHRoaXMudmlld1tiZWdpbisrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChiZWdpbiAhPT0gZW5kKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitiZWdpbitcIiAhPSBcIitlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tVVRGOCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIodXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdHJ1ZSlbMV0sIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmIubGltaXQgPSBpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEJ5dGVCdWZmZXI7XHJcbn0pO1xyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2J5dGVidWZmZXIvZGlzdC9ieXRlYnVmZmVyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2J5dGVidWZmZXIvZGlzdFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbmluaGVyaXRzKENpcGhlckJhc2UsIFRyYW5zZm9ybSlcbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuICB0aGlzLl9lbmNvZGluZyA9IG51bGxcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBpbnB1dEVuYywgb3V0cHV0RW5jKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBpbnB1dEVuYylcbiAgfVxuICB2YXIgb3V0RGF0YSA9IHRoaXMuX3VwZGF0ZShkYXRhKVxuICBpZiAodGhpcy5oYXNoTW9kZSkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cbiAgcmV0dXJuIG91dERhdGFcbn1cblxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuc2V0QXV0b1BhZGRpbmcgPSBmdW5jdGlvbiAoKSB7fVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fZmluYWwoKSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVyciA9IGVcbiAgfSBmaW5hbGx5IHtcbiAgICBkb25lKGVycilcbiAgfVxufVxuQ2lwaGVyQmFzZS5wcm90b3R5cGUuX2ZpbmFsT3JEaWdlc3QgPSBmdW5jdGlvbiAob3V0cHV0RW5jKSB7XG4gIHZhciBvdXREYXRhID0gdGhpcy5fZmluYWwoKSB8fCBuZXcgQnVmZmVyKCcnKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuICBpZiAodGhpcy5fZW5jb2RpbmcgIT09IGVuYykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FuXFwndCBzd2l0Y2ggZW5jb2RpbmdzJylcbiAgfVxuICB2YXIgb3V0ID0gdGhpcy5fZGVjb2Rlci53cml0ZSh2YWx1ZSlcbiAgaWYgKGZpbikge1xuICAgIG91dCArPSB0aGlzLl9kZWNvZGVyLmVuZCgpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZS9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jaXBoZXItYmFzZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBtZDUgPSByZXF1aXJlKCcuL21kNScpXG52YXIgcm1kMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2NpcGhlci1iYXNlJylcblxuZnVuY3Rpb24gSGFzaE5vQ29uc3RydWN0b3IoaGFzaCkge1xuICBCYXNlLmNhbGwodGhpcywgJ2RpZ2VzdCcpXG5cbiAgdGhpcy5faGFzaCA9IGhhc2hcbiAgdGhpcy5idWZmZXJzID0gW11cbn1cblxuaW5oZXJpdHMoSGFzaE5vQ29uc3RydWN0b3IsIEJhc2UpXG5cbkhhc2hOb0NvbnN0cnVjdG9yLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goZGF0YSlcbn1cblxuSGFzaE5vQ29uc3RydWN0b3IucHJvdG90eXBlLl9maW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQodGhpcy5idWZmZXJzKVxuICB2YXIgciA9IHRoaXMuX2hhc2goYnVmKVxuICB0aGlzLmJ1ZmZlcnMgPSBudWxsXG5cbiAgcmV0dXJuIHJcbn1cblxuZnVuY3Rpb24gSGFzaChoYXNoKSB7XG4gIEJhc2UuY2FsbCh0aGlzLCAnZGlnZXN0JylcblxuICB0aGlzLl9oYXNoID0gaGFzaFxufVxuXG5pbmhlcml0cyhIYXNoLCBCYXNlKVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSlcbn1cblxuSGFzaC5wcm90b3R5cGUuX2ZpbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzaC5kaWdlc3QoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKGFsZykge1xuICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKVxuICBpZiAoJ21kNScgPT09IGFsZykgcmV0dXJuIG5ldyBIYXNoTm9Db25zdHJ1Y3RvcihtZDUpXG4gIGlmICgncm1kMTYwJyA9PT0gYWxnIHx8ICdyaXBlbWQxNjAnID09PSBhbGcpIHJldHVybiBuZXcgSGFzaE5vQ29uc3RydWN0b3Iocm1kMTYwKVxuXG4gIHJldHVybiBuZXcgSGFzaChzaGEoYWxnKSlcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvaGVscGVycy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0Jztcbi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjEgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG5cbn1cblxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcbntcbiAgcmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksYik7XG59XG5mdW5jdGlvbiBtZDVfZmYoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2lpKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZDUoYnVmKSB7XG4gIHJldHVybiBoZWxwZXJzLmhhc2goYnVmLCBjb3JlX21kNSwgMTYpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1oYXNoL21kNS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaGFzaFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gvYnJvd3NlcicpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtXG5cbnZhciBaRVJPUyA9IG5ldyBCdWZmZXIoMTI4KVxuWkVST1MuZmlsbCgwKVxuXG5mdW5jdGlvbiBIbWFjKGFsZywga2V5KSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IG5ldyBCdWZmZXIoa2V5KVxuICB9XG5cbiAgdmFyIGJsb2Nrc2l6ZSA9IChhbGcgPT09ICdzaGE1MTInIHx8IGFsZyA9PT0gJ3NoYTM4NCcpID8gMTI4IDogNjRcblxuICB0aGlzLl9hbGcgPSBhbGdcbiAgdGhpcy5fa2V5ID0ga2V5XG5cbiAgaWYgKGtleS5sZW5ndGggPiBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGtleSkuZGlnZXN0KClcblxuICB9IGVsc2UgaWYgKGtleS5sZW5ndGggPCBibG9ja3NpemUpIHtcbiAgICBrZXkgPSBCdWZmZXIuY29uY2F0KFtrZXksIFpFUk9TXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzaXplOyBpKyspIHtcbiAgICBpcGFkW2ldID0ga2V5W2ldIF4gMHgzNlxuICAgIG9wYWRbaV0gPSBrZXlbaV0gXiAweDVDXG4gIH1cblxuICB0aGlzLl9oYXNoID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShpcGFkKVxufVxuXG5pbmhlcml0cyhIbWFjLCBUcmFuc2Zvcm0pXG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkhtYWMucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZGF0YSwgXywgbmV4dCkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxuXG4gIG5leHQoKVxufVxuXG5IbWFjLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcblxuICBuZXh0KClcbn1cblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaCA9IHRoaXMuX2hhc2guZGlnZXN0KClcblxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVIbWFjKGFsZywga2V5KSB7XG4gIHJldHVybiBuZXcgSG1hYyhhbGcsIGtleSlcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3JlYXRlLWhtYWMvYnJvd3Nlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcmVhdGUtaG1hY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIExvb2t1cCB0YWJsZXNcblx0ICAgIHZhciBTQk9YID0gW107XG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuXHQgICAgICAgIHZhciBkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2FsayBHRigyXjgpXG5cdCAgICAgICAgdmFyIHggPSAwO1xuXHQgICAgICAgIHZhciB4aSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG5cdCAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2Mztcblx0ICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcblx0ICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG5cdCAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXHQgICAgICAgICAgICBpZiAoIXgpIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuXHQgICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXHQgICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cblx0ICAgICAgICAgICAgLy8gQ2hvb3NlIG1peGluZyBibG9ja1xuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWxpemVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gRm9ybWF0XG5cdCAgICAgICAgICAgIGlmIChzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgdmFyIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcblx0ICAgICAgICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcblx0ICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuXHQgICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuXHQgICAgICAgICAgICBpZiAoIXNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuXHQgICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcblx0ICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jaXBoZXItY29yZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbCBvZiBPYmplY3QuY3JlYXRlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9O1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1fdyA9IG1fdztcblx0ICAgICAgICAgICAgICAgIHZhciBtX3ogPSAweDNhZGU2OGIxO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1feiA9ICgweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICgobV96IDw8IDB4MTApICsgbV93KSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gLjUgPyAxIDogLTEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcmNhY2hlOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuXHQgICAgICAgICAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKChfcigpICogMHgxMDAwMDAwMDApIHwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvY29yZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlNjQgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tYXA6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSdcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWJhc2U2NC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuSGV4O1xuXG59KSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvZW5jLWhleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jcnlwdG8tanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGExXCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcblx0ICAgICAqL1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXG5cdCAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhlIGRlcml2YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29tcHV0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjZmcgPSB0aGlzLmNmZztcblxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0gY2ZnLmtleVNpemU7XG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb25zXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgKi9cblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcblx0ICAgICAgICByZXR1cm4gRXZwS0RGLmNyZWF0ZShjZmcpLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9ldnBrZGYuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8qKlxuXHQgICAgICogSE1BQyBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBITUFDID0gQ19hbGdvLkhNQUMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjSGFzaGVyID0gQ3J5cHRvSlMuYWxnby5ITUFDLmNyZWF0ZShDcnlwdG9KUy5hbGdvLlNIQTI1Niwga2V5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdCBoYXNoZXJcblx0ICAgICAgICAgICAgaGFzaGVyID0gdGhpcy5faGFzaGVyID0gbmV3IGhhc2hlci5pbml0KCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuXHQgICAgICAgICAgICBpZiAoa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAga2V5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xuXHQgICAgICAgICAgICB2YXIgb0tleSA9IHRoaXMuX29LZXkgPSBrZXkuY2xvbmUoKTtcblx0ICAgICAgICAgICAgdmFyIGlLZXkgPSB0aGlzLl9pS2V5ID0ga2V5LmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgb0tleVdvcmRzW2ldIF49IDB4NWM1YzVjNWM7XG5cdCAgICAgICAgICAgICAgICBpS2V5V29yZHNbaV0gXj0gMHgzNjM2MzYzNjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvS2V5LnNpZ0J5dGVzID0gaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICBoYXNoZXIudXBkYXRlKHRoaXMuX2lLZXkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtITUFDfSBUaGlzIEhNQUMgaW5zdGFuY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBITUFDIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcblx0ICAgICAgICAgICAgdmFyIGlubmVySGFzaCA9IGhhc2hlci5maW5hbGl6ZShtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhtYWM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2htYWMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGExLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2NyeXB0by1qc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBjdXJyZW5jeVN5bWJvbE1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbnZhciBzeW1ib2xDdXJyZW5jeU1hcCA9IHt9O1xuT2JqZWN0LmtleXMoY3VycmVuY3lTeW1ib2xNYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBzeW1ib2xDdXJyZW5jeU1hcFtjdXJyZW5jeVN5bWJvbE1hcFtrZXldXSA9IGtleVxufSlcblxuZnVuY3Rpb24gZ2V0U3ltYm9sRnJvbUN1cnJlbmN5KGN1cnJlbmN5Q29kZSkge1xuICBpZiAodHlwZW9mIGN1cnJlbmN5Q29kZSAhPT0gJ3N0cmluZycpIHJldHVybiB1bmRlZmluZWRcbiAgdmFyIGNvZGUgPSBjdXJyZW5jeUNvZGUudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFjdXJyZW5jeVN5bWJvbE1hcC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gY3VycmVuY3lTeW1ib2xNYXBbY29kZV07XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbmN5RnJvbVN5bWJvbChzeW1ib2wpIHtcbiAgaWYgKCFzeW1ib2xDdXJyZW5jeU1hcC5oYXNPd25Qcm9wZXJ0eShzeW1ib2wpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiBzeW1ib2xDdXJyZW5jeU1hcFtzeW1ib2xdXG59XG5cbmZ1bmN0aW9uIGdldFN5bWJvbChjdXJyZW5jeUNvZGUpIHtcbiAgaWYgKHR5cGVvZiBjdXJyZW5jeUNvZGUgIT09ICdzdHJpbmcnKSByZXR1cm4gJz8nXG4gIHZhciBzeW1ib2wgPSBnZXRTeW1ib2xGcm9tQ3VycmVuY3koY3VycmVuY3lDb2RlLnRvVXBwZXJDYXNlKCkpXG4gIHJldHVybiBzeW1ib2wgIT09IHVuZGVmaW5lZCA/IHN5bWJvbCA6ICc/J1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbFxubW9kdWxlLmV4cG9ydHMuZ2V0U3ltYm9sRnJvbUN1cnJlbmN5ID0gZ2V0U3ltYm9sRnJvbUN1cnJlbmN5XG5tb2R1bGUuZXhwb3J0cy5nZXRDdXJyZW5jeUZyb21TeW1ib2wgPSBnZXRDdXJyZW5jeUZyb21TeW1ib2xcbm1vZHVsZS5leHBvcnRzLnN5bWJvbEN1cnJlbmN5TWFwID0gc3ltYm9sQ3VycmVuY3lNYXBcbm1vZHVsZS5leHBvcnRzLmN1cnJlbmN5U3ltYm9sTWFwID0gY3VycmVuY3lTeW1ib2xNYXBcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3VycmVuY3ktc3ltYm9sLW1hcC9jdXJyZW5jeS1zeW1ib2wtbWFwLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2N1cnJlbmN5LXN5bWJvbC1tYXBcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9XG57IFwiQUxMXCI6IFwiTFwiXG4sIFwiQUZOXCI6IFwi2ItcIlxuLCBcIkFSU1wiOiBcIiRcIlxuLCBcIkFXR1wiOiBcIsaSXCJcbiwgXCJBVURcIjogXCIkXCJcbiwgXCJBWk5cIjogXCLigrxcIlxuLCBcIkJTRFwiOiBcIiRcIlxuLCBcIkJCRFwiOiBcIiRcIlxuLCBcIkJZUlwiOiBcInAuXCJcbiwgXCJCWkRcIjogXCJCWiRcIlxuLCBcIkJNRFwiOiBcIiRcIlxuLCBcIkJPQlwiOiBcIkJzLlwiXG4sIFwiQkFNXCI6IFwiS01cIlxuLCBcIkJXUFwiOiBcIlBcIlxuLCBcIkJHTlwiOiBcItC70LJcIlxuLCBcIkJSTFwiOiBcIlIkXCJcbiwgXCJCTkRcIjogXCIkXCJcbiwgXCJCVENcIjogXCLJg1wiXG4sIFwiS0hSXCI6IFwi4Z+bXCJcbiwgXCJDQURcIjogXCIkXCJcbiwgXCJLWURcIjogXCIkXCJcbiwgXCJDTFBcIjogXCIkXCJcbiwgXCJDTllcIjogXCLCpVwiXG4sIFwiQ09QXCI6IFwiJFwiXG4sIFwiQ1JDXCI6IFwi4oKhXCJcbiwgXCJIUktcIjogXCJrblwiXG4sIFwiQ1VQXCI6IFwi4oKxXCJcbiwgXCJDWktcIjogXCJLxI1cIlxuLCBcIkRLS1wiOiBcImtyXCJcbiwgXCJET1BcIjogXCJSRCRcIlxuLCBcIlhDRFwiOiBcIiRcIlxuLCBcIkVHUFwiOiBcIsKjXCJcbiwgXCJTVkNcIjogXCIkXCJcbiwgXCJFRUtcIjogXCJrclwiXG4sIFwiRVVSXCI6IFwi4oKsXCJcbiwgXCJGS1BcIjogXCLCo1wiXG4sIFwiRkpEXCI6IFwiJFwiXG4sIFwiR0hDXCI6IFwi4oK1XCJcbiwgXCJHSVBcIjogXCLCo1wiXG4sIFwiR1RRXCI6IFwiUVwiXG4sIFwiR0dQXCI6IFwiwqNcIlxuLCBcIkdZRFwiOiBcIiRcIlxuLCBcIkhOTFwiOiBcIkxcIlxuLCBcIkhLRFwiOiBcIiRcIlxuLCBcIkhVRlwiOiBcIkZ0XCJcbiwgXCJJU0tcIjogXCJrclwiXG4sIFwiSU5SXCI6IFwi4oK5XCJcbiwgXCJJRFJcIjogXCJScFwiXG4sIFwiSVJSXCI6IFwi77e8XCJcbiwgXCJJTVBcIjogXCLCo1wiXG4sIFwiSUxTXCI6IFwi4oKqXCJcbiwgXCJKTURcIjogXCJKJFwiXG4sIFwiSlBZXCI6IFwiwqVcIlxuLCBcIkpFUFwiOiBcIsKjXCJcbiwgXCJLRVNcIjogXCJLU2hcIlxuLCBcIktaVFwiOiBcItC70LJcIlxuLCBcIktQV1wiOiBcIuKCqVwiXG4sIFwiS1JXXCI6IFwi4oKpXCJcbiwgXCJLR1NcIjogXCLQu9CyXCJcbiwgXCJMQUtcIjogXCLigq1cIlxuLCBcIkxWTFwiOiBcIkxzXCJcbiwgXCJMQlBcIjogXCLCo1wiXG4sIFwiTFJEXCI6IFwiJFwiXG4sIFwiTFRMXCI6IFwiTHRcIlxuLCBcIk1LRFwiOiBcItC00LXQvVwiXG4sIFwiTVlSXCI6IFwiUk1cIlxuLCBcIk1VUlwiOiBcIuKCqFwiXG4sIFwiTVhOXCI6IFwiJFwiXG4sIFwiTU5UXCI6IFwi4oKuXCJcbiwgXCJNWk5cIjogXCJNVFwiXG4sIFwiTkFEXCI6IFwiJFwiXG4sIFwiTlBSXCI6IFwi4oKoXCJcbiwgXCJBTkdcIjogXCLGklwiXG4sIFwiTlpEXCI6IFwiJFwiXG4sIFwiTklPXCI6IFwiQyRcIlxuLCBcIk5HTlwiOiBcIuKCplwiXG4sIFwiTk9LXCI6IFwia3JcIlxuLCBcIk9NUlwiOiBcIu+3vFwiXG4sIFwiUEtSXCI6IFwi4oKoXCJcbiwgXCJQQUJcIjogXCJCLy5cIlxuLCBcIlBZR1wiOiBcIkdzXCJcbiwgXCJQRU5cIjogXCJTLy5cIlxuLCBcIlBIUFwiOiBcIuKCsVwiXG4sIFwiUExOXCI6IFwiesWCXCJcbiwgXCJRQVJcIjogXCLvt7xcIlxuLCBcIlJPTlwiOiBcImxlaVwiXG4sIFwiUlVCXCI6IFwi4oK9XCJcbiwgXCJSTUJcIjogXCLvv6VcIlxuLCBcIlNIUFwiOiBcIsKjXCJcbiwgXCJTQVJcIjogXCLvt7xcIlxuLCBcIlJTRFwiOiBcItCU0LjQvS5cIlxuLCBcIlNDUlwiOiBcIuKCqFwiXG4sIFwiU0dEXCI6IFwiJFwiXG4sIFwiU0JEXCI6IFwiJFwiXG4sIFwiU09TXCI6IFwiU1wiXG4sIFwiWkFSXCI6IFwiUlwiXG4sIFwiTEtSXCI6IFwi4oKoXCJcbiwgXCJTRUtcIjogXCJrclwiXG4sIFwiQ0hGXCI6IFwiQ0hGXCJcbiwgXCJTUkRcIjogXCIkXCJcbiwgXCJTWVBcIjogXCLCo1wiXG4sIFwiVFpTXCI6IFwiVFNoXCJcbiwgXCJUV0RcIjogXCJOVCRcIlxuLCBcIlRIQlwiOiBcIuC4v1wiXG4sIFwiVFREXCI6IFwiVFQkXCJcbiwgXCJUUllcIjogXCLigrpcIlxuLCBcIlRSTFwiOiBcIuKCpFwiXG4sIFwiVFZEXCI6IFwiJFwiXG4sIFwiVUdYXCI6IFwiVVNoXCJcbiwgXCJVQUhcIjogXCLigrRcIlxuLCBcIkdCUFwiOiBcIsKjXCJcbiwgXCJVU0RcIjogXCIkXCJcbiwgXCJVWVVcIjogXCIkVVwiXG4sIFwiVVpTXCI6IFwi0LvQslwiXG4sIFwiVkVGXCI6IFwiQnNcIlxuLCBcIlZORFwiOiBcIuKCq1wiXG4sIFwiWUVSXCI6IFwi77e8XCJcbiwgXCJaV0RcIjogXCJaJFwiXG4sIFwiR0VMXCI6IFwi4oK+XCJcbiwgXCJLWlRcIjogXCLigrhcIlxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwL21hcC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9jdXJyZW5jeS1zeW1ib2wtbWFwXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnXHJcblxyXG4vKipcclxuICogRGlmZiBNYXRjaCBhbmQgUGF0Y2hcclxuICpcclxuICogQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy5cclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGV4dHMgdG8gY3JlYXRlIGEgcGF0Y2guXHJcbiAqIEFwcGxpZXMgdGhlIHBhdGNoIG9udG8gYW5vdGhlciB0ZXh0LCBhbGxvd2luZyBmb3IgZXJyb3JzLlxyXG4gKiBAYXV0aG9yIGZyYXNlckBnb29nbGUuY29tIChOZWlsIEZyYXNlcilcclxuICovXHJcblxyXG4vKipcclxuICogQ2xhc3MgY29udGFpbmluZyB0aGUgZGlmZiwgbWF0Y2ggYW5kIHBhdGNoIG1ldGhvZHMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gZGlmZl9tYXRjaF9wYXRjaCgpIHtcclxuXHJcbiAgLy8gRGVmYXVsdHMuXHJcbiAgLy8gUmVkZWZpbmUgdGhlc2UgaW4geW91ciBwcm9ncmFtIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0cy5cclxuXHJcbiAgLy8gTnVtYmVyIG9mIHNlY29uZHMgdG8gbWFwIGEgZGlmZiBiZWZvcmUgZ2l2aW5nIHVwICgwIGZvciBpbmZpbml0eSkuXHJcbiAgdGhpcy5EaWZmX1RpbWVvdXQgPSAxLjA7XHJcbiAgLy8gQ29zdCBvZiBhbiBlbXB0eSBlZGl0IG9wZXJhdGlvbiBpbiB0ZXJtcyBvZiBlZGl0IGNoYXJhY3RlcnMuXHJcbiAgdGhpcy5EaWZmX0VkaXRDb3N0ID0gNDtcclxuICAvLyBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cclxuICB0aGlzLk1hdGNoX1RocmVzaG9sZCA9IDAuNTtcclxuICAvLyBIb3cgZmFyIHRvIHNlYXJjaCBmb3IgYSBtYXRjaCAoMCA9IGV4YWN0IGxvY2F0aW9uLCAxMDAwKyA9IGJyb2FkIG1hdGNoKS5cclxuICAvLyBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcclxuICAvLyAxLjAgdG8gdGhlIHNjb3JlICgwLjAgaXMgYSBwZXJmZWN0IG1hdGNoKS5cclxuICB0aGlzLk1hdGNoX0Rpc3RhbmNlID0gMTAwMDtcclxuICAvLyBXaGVuIGRlbGV0aW5nIGEgbGFyZ2UgYmxvY2sgb2YgdGV4dCAob3ZlciB+NjQgY2hhcmFjdGVycyksIGhvdyBjbG9zZSBkb1xyXG4gIC8vIHRoZSBjb250ZW50cyBoYXZlIHRvIGJlIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBjb250ZW50cy4gKDAuMCA9IHBlcmZlY3Rpb24sXHJcbiAgLy8gMS4wID0gdmVyeSBsb29zZSkuICBOb3RlIHRoYXQgTWF0Y2hfVGhyZXNob2xkIGNvbnRyb2xzIGhvdyBjbG9zZWx5IHRoZVxyXG4gIC8vIGVuZCBwb2ludHMgb2YgYSBkZWxldGUgbmVlZCB0byBtYXRjaC5cclxuICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCA9IDAuNTtcclxuICAvLyBDaHVuayBzaXplIGZvciBjb250ZXh0IGxlbmd0aC5cclxuICB0aGlzLlBhdGNoX01hcmdpbiA9IDQ7XHJcblxyXG4gIC8vIFRoZSBudW1iZXIgb2YgYml0cyBpbiBhbiBpbnQuXHJcbiAgdGhpcy5NYXRjaF9NYXhCaXRzID0gMzI7XHJcbn1cclxuXHJcblxyXG4vLyAgRElGRiBGVU5DVElPTlNcclxuXHJcblxyXG4vKipcclxuICogVGhlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIGRpZmYgaXMgYW4gYXJyYXkgb2YgdHVwbGVzOlxyXG4gKiBbW0RJRkZfREVMRVRFLCAnSGVsbG8nXSwgW0RJRkZfSU5TRVJULCAnR29vZGJ5ZSddLCBbRElGRl9FUVVBTCwgJyB3b3JsZC4nXV1cclxuICogd2hpY2ggbWVhbnM6IGRlbGV0ZSAnSGVsbG8nLCBhZGQgJ0dvb2RieWUnIGFuZCBrZWVwICcgd29ybGQuJ1xyXG4gKi9cclxudmFyIERJRkZfREVMRVRFID0gLTE7XHJcbnZhciBESUZGX0lOU0VSVCA9IDE7XHJcbnZhciBESUZGX0VRVUFMID0gMDtcclxuXHJcbi8qKiBAdHlwZWRlZiB7ezA6IG51bWJlciwgMTogc3RyaW5nfX0gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5EaWZmO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIFNpbXBsaWZpZXMgdGhlIHByb2JsZW0gYnkgc3RyaXBwaW5nXHJcbiAqIGFueSBjb21tb24gcHJlZml4IG9yIHN1ZmZpeCBvZmYgdGhlIHRleHRzIGJlZm9yZSBkaWZmaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NoZWNrbGluZXMgT3B0aW9uYWwgc3BlZWR1cCBmbGFnLiBJZiBwcmVzZW50IGFuZCBmYWxzZSxcclxuICogICAgIHRoZW4gZG9uJ3QgcnVuIGEgbGluZS1sZXZlbCBkaWZmIGZpcnN0IHRvIGlkZW50aWZ5IHRoZSBjaGFuZ2VkIGFyZWFzLlxyXG4gKiAgICAgRGVmYXVsdHMgdG8gdHJ1ZSwgd2hpY2ggZG9lcyBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmYuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRfZGVhZGxpbmUgT3B0aW9uYWwgdGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZVxyXG4gKiAgICAgYnkuICBVc2VkIGludGVybmFsbHkgZm9yIHJlY3Vyc2l2ZSBjYWxscy4gIFVzZXJzIHNob3VsZCBzZXQgRGlmZlRpbWVvdXRcclxuICogICAgIGluc3RlYWQuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9tYWluID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBvcHRfY2hlY2tsaW5lcyxcclxuICAgIG9wdF9kZWFkbGluZSkge1xyXG4gIC8vIFNldCBhIGRlYWRsaW5lIGJ5IHdoaWNoIHRpbWUgdGhlIGRpZmYgbXVzdCBiZSBjb21wbGV0ZS5cclxuICBpZiAodHlwZW9mIG9wdF9kZWFkbGluZSA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHRoaXMuRGlmZl9UaW1lb3V0IDw9IDApIHtcclxuICAgICAgb3B0X2RlYWRsaW5lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdF9kZWFkbGluZSA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpICsgdGhpcy5EaWZmX1RpbWVvdXQgKiAxMDAwO1xyXG4gICAgfVxyXG4gIH1cclxuICB2YXIgZGVhZGxpbmUgPSBvcHRfZGVhZGxpbmU7XHJcblxyXG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cclxuICBpZiAodGV4dDEgPT0gbnVsbCB8fCB0ZXh0MiA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChkaWZmX21haW4pJyk7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBmb3IgZXF1YWxpdHkgKHNwZWVkdXApLlxyXG4gIGlmICh0ZXh0MSA9PSB0ZXh0Mikge1xyXG4gICAgaWYgKHRleHQxKSB7XHJcbiAgICAgIHJldHVybiBbW0RJRkZfRVFVQUwsIHRleHQxXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIG9wdF9jaGVja2xpbmVzID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBvcHRfY2hlY2tsaW5lcyA9IHRydWU7XHJcbiAgfVxyXG4gIHZhciBjaGVja2xpbmVzID0gb3B0X2NoZWNrbGluZXM7XHJcblxyXG4gIC8vIFRyaW0gb2ZmIGNvbW1vbiBwcmVmaXggKHNwZWVkdXApLlxyXG4gIHZhciBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mik7XHJcbiAgdmFyIGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xyXG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuXHJcbiAgLy8gVHJpbSBvZmYgY29tbW9uIHN1ZmZpeCAoc3BlZWR1cCkuXHJcbiAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xyXG4gIHZhciBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcclxuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xyXG4gIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQyLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XHJcblxyXG4gIC8vIENvbXB1dGUgdGhlIGRpZmYgb24gdGhlIG1pZGRsZSBibG9jay5cclxuICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfY29tcHV0ZV8odGV4dDEsIHRleHQyLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XHJcblxyXG4gIC8vIFJlc3RvcmUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxyXG4gIGlmIChjb21tb25wcmVmaXgpIHtcclxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pO1xyXG4gIH1cclxuICBpZiAoY29tbW9uc3VmZml4KSB7XHJcbiAgICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBjb21tb25zdWZmaXhdKTtcclxuICB9XHJcbiAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XHJcbiAgcmV0dXJuIGRpZmZzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHR3byB0ZXh0cy4gIEFzc3VtZXMgdGhhdCB0aGUgdGV4dHMgZG8gbm90XHJcbiAqIGhhdmUgYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2xpbmVzIFNwZWVkdXAgZmxhZy4gIElmIGZhbHNlLCB0aGVuIGRvbid0IHJ1biBhXHJcbiAqICAgICBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXHJcbiAqICAgICBJZiB0cnVlLCB0aGVuIHJ1biBhIGZhc3Rlciwgc2xpZ2h0bHkgbGVzcyBvcHRpbWFsIGRpZmYuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlIGJ5LlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tcHV0ZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsXHJcbiAgICBkZWFkbGluZSkge1xyXG4gIHZhciBkaWZmcztcclxuXHJcbiAgaWYgKCF0ZXh0MSkge1xyXG4gICAgLy8gSnVzdCBhZGQgc29tZSB0ZXh0IChzcGVlZHVwKS5cclxuICAgIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF0ZXh0Mikge1xyXG4gICAgLy8gSnVzdCBkZWxldGUgc29tZSB0ZXh0IChzcGVlZHVwKS5cclxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcclxuICB2YXIgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcclxuICB2YXIgaSA9IGxvbmd0ZXh0LmluZGV4T2Yoc2hvcnR0ZXh0KTtcclxuICBpZiAoaSAhPSAtMSkge1xyXG4gICAgLy8gU2hvcnRlciB0ZXh0IGlzIGluc2lkZSB0aGUgbG9uZ2VyIHRleHQgKHNwZWVkdXApLlxyXG4gICAgZGlmZnMgPSBbW0RJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSldLFxyXG4gICAgICAgICAgICAgW0RJRkZfRVFVQUwsIHNob3J0dGV4dF0sXHJcbiAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXTtcclxuICAgIC8vIFN3YXAgaW5zZXJ0aW9ucyBmb3IgZGVsZXRpb25zIGlmIGRpZmYgaXMgcmV2ZXJzZWQuXHJcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XHJcbiAgICAgIGRpZmZzWzBdWzBdID0gZGlmZnNbMl1bMF0gPSBESUZGX0RFTEVURTtcclxuICAgIH1cclxuICAgIHJldHVybiBkaWZmcztcclxuICB9XHJcblxyXG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09IDEpIHtcclxuICAgIC8vIFNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nLlxyXG4gICAgLy8gQWZ0ZXIgdGhlIHByZXZpb3VzIHNwZWVkdXAsIHRoZSBjaGFyYWN0ZXIgY2FuJ3QgYmUgYW4gZXF1YWxpdHkuXHJcbiAgICByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIHByb2JsZW0gY2FuIGJlIHNwbGl0IGluIHR3by5cclxuICB2YXIgaG0gPSB0aGlzLmRpZmZfaGFsZk1hdGNoXyh0ZXh0MSwgdGV4dDIpO1xyXG4gIGlmIChobSkge1xyXG4gICAgLy8gQSBoYWxmLW1hdGNoIHdhcyBmb3VuZCwgc29ydCBvdXQgdGhlIHJldHVybiBkYXRhLlxyXG4gICAgdmFyIHRleHQxX2EgPSBobVswXTtcclxuICAgIHZhciB0ZXh0MV9iID0gaG1bMV07XHJcbiAgICB2YXIgdGV4dDJfYSA9IGhtWzJdO1xyXG4gICAgdmFyIHRleHQyX2IgPSBobVszXTtcclxuICAgIHZhciBtaWRfY29tbW9uID0gaG1bNF07XHJcbiAgICAvLyBTZW5kIGJvdGggcGFpcnMgb2ZmIGZvciBzZXBhcmF0ZSBwcm9jZXNzaW5nLlxyXG4gICAgdmFyIGRpZmZzX2EgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MV9hLCB0ZXh0Ml9hLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XHJcbiAgICB2YXIgZGlmZnNfYiA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2IsIHRleHQyX2IsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcclxuICAgIC8vIE1lcmdlIHRoZSByZXN1bHRzLlxyXG4gICAgcmV0dXJuIGRpZmZzX2EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkX2NvbW1vbl1dLCBkaWZmc19iKTtcclxuICB9XHJcblxyXG4gIGlmIChjaGVja2xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDApIHtcclxuICAgIHJldHVybiB0aGlzLmRpZmZfbGluZU1vZGVfKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuZGlmZl9iaXNlY3RfKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEbyBhIHF1aWNrIGxpbmUtbGV2ZWwgZGlmZiBvbiBib3RoIHN0cmluZ3MsIHRoZW4gcmVkaWZmIHRoZSBwYXJ0cyBmb3JcclxuICogZ3JlYXRlciBhY2N1cmFjeS5cclxuICogVGhpcyBzcGVlZHVwIGNhbiBwcm9kdWNlIG5vbi1taW5pbWFsIGRpZmZzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lTW9kZV8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIGRlYWRsaW5lKSB7XHJcbiAgLy8gU2NhbiB0aGUgdGV4dCBvbiBhIGxpbmUtYnktbGluZSBiYXNpcyBmaXJzdC5cclxuICB2YXIgYSA9IHRoaXMuZGlmZl9saW5lc1RvQ2hhcnNfKHRleHQxLCB0ZXh0Mik7XHJcbiAgdGV4dDEgPSBhLmNoYXJzMTtcclxuICB0ZXh0MiA9IGEuY2hhcnMyO1xyXG4gIHZhciBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcclxuXHJcbiAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIHRleHQyLCBmYWxzZSwgZGVhZGxpbmUpO1xyXG5cclxuICAvLyBDb252ZXJ0IHRoZSBkaWZmIGJhY2sgdG8gb3JpZ2luYWwgdGV4dC5cclxuICB0aGlzLmRpZmZfY2hhcnNUb0xpbmVzXyhkaWZmcywgbGluZWFycmF5KTtcclxuICAvLyBFbGltaW5hdGUgZnJlYWsgbWF0Y2hlcyAoZS5nLiBibGFuayBsaW5lcylcclxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcclxuXHJcbiAgLy8gUmVkaWZmIGFueSByZXBsYWNlbWVudCBibG9ja3MsIHRoaXMgdGltZSBjaGFyYWN0ZXItYnktY2hhcmFjdGVyLlxyXG4gIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXHJcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTtcclxuICB2YXIgcG9pbnRlciA9IDA7XHJcbiAgdmFyIGNvdW50X2RlbGV0ZSA9IDA7XHJcbiAgdmFyIGNvdW50X2luc2VydCA9IDA7XHJcbiAgdmFyIHRleHRfZGVsZXRlID0gJyc7XHJcbiAgdmFyIHRleHRfaW5zZXJ0ID0gJyc7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBjb3VudF9pbnNlcnQrKztcclxuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBjb3VudF9kZWxldGUrKztcclxuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXHJcbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XHJcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0KTtcclxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xyXG4gICAgICAgICAgdmFyIGEgPSB0aGlzLmRpZmZfbWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIGZhbHNlLCBkZWFkbGluZSk7XHJcbiAgICAgICAgICBmb3IgKHZhciBqID0gYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgYVtqXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIGEubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xyXG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcclxuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuXHJcbiAgcmV0dXJuIGRpZmZzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSAnbWlkZGxlIHNuYWtlJyBvZiBhIGRpZmYsIHNwbGl0IHRoZSBwcm9ibGVtIGluIHR3b1xyXG4gKiBhbmQgcmV0dXJuIHRoZSByZWN1cnNpdmVseSBjb25zdHJ1Y3RlZCBkaWZmLlxyXG4gKiBTZWUgTXllcnMgMTk4NiBwYXBlcjogQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIEl0cyBWYXJpYXRpb25zLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgYXQgd2hpY2ggdG8gYmFpbCBpZiBub3QgeWV0IGNvbXBsZXRlLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfYmlzZWN0XyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcclxuICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXHJcbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcclxuICB2YXIgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xyXG4gIHZhciBtYXhfZCA9IE1hdGguY2VpbCgodGV4dDFfbGVuZ3RoICsgdGV4dDJfbGVuZ3RoKSAvIDIpO1xyXG4gIHZhciB2X29mZnNldCA9IG1heF9kO1xyXG4gIHZhciB2X2xlbmd0aCA9IDIgKiBtYXhfZDtcclxuICB2YXIgdjEgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xyXG4gIHZhciB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XHJcbiAgLy8gU2V0dGluZyBhbGwgZWxlbWVudHMgdG8gLTEgaXMgZmFzdGVyIGluIENocm9tZSAmIEZpcmVmb3ggdGhhbiBtaXhpbmdcclxuICAvLyBpbnRlZ2VycyBhbmQgdW5kZWZpbmVkLlxyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xyXG4gICAgdjFbeF0gPSAtMTtcclxuICAgIHYyW3hdID0gLTE7XHJcbiAgfVxyXG4gIHYxW3Zfb2Zmc2V0ICsgMV0gPSAwO1xyXG4gIHYyW3Zfb2Zmc2V0ICsgMV0gPSAwO1xyXG4gIHZhciBkZWx0YSA9IHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aDtcclxuICAvLyBJZiB0aGUgdG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgaXMgb2RkLCB0aGVuIHRoZSBmcm9udCBwYXRoIHdpbGwgY29sbGlkZVxyXG4gIC8vIHdpdGggdGhlIHJldmVyc2UgcGF0aC5cclxuICB2YXIgZnJvbnQgPSAoZGVsdGEgJSAyICE9IDApO1xyXG4gIC8vIE9mZnNldHMgZm9yIHN0YXJ0IGFuZCBlbmQgb2YgayBsb29wLlxyXG4gIC8vIFByZXZlbnRzIG1hcHBpbmcgb2Ygc3BhY2UgYmV5b25kIHRoZSBncmlkLlxyXG4gIHZhciBrMXN0YXJ0ID0gMDtcclxuICB2YXIgazFlbmQgPSAwO1xyXG4gIHZhciBrMnN0YXJ0ID0gMDtcclxuICB2YXIgazJlbmQgPSAwO1xyXG4gIGZvciAodmFyIGQgPSAwOyBkIDwgbWF4X2Q7IGQrKykge1xyXG4gICAgLy8gQmFpbCBvdXQgaWYgZGVhZGxpbmUgaXMgcmVhY2hlZC5cclxuICAgIGlmICgobmV3IERhdGUoKSkuZ2V0VGltZSgpID4gZGVhZGxpbmUpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2FsayB0aGUgZnJvbnQgcGF0aCBvbmUgc3RlcC5cclxuICAgIGZvciAodmFyIGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcclxuICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgazE7XHJcbiAgICAgIHZhciB4MTtcclxuICAgICAgaWYgKGsxID09IC1kIHx8IChrMSAhPSBkICYmIHYxW2sxX29mZnNldCAtIDFdIDwgdjFbazFfb2Zmc2V0ICsgMV0pKSB7XHJcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgeTEgPSB4MSAtIGsxO1xyXG4gICAgICB3aGlsZSAoeDEgPCB0ZXh0MV9sZW5ndGggJiYgeTEgPCB0ZXh0Ml9sZW5ndGggJiZcclxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh4MSkgPT0gdGV4dDIuY2hhckF0KHkxKSkge1xyXG4gICAgICAgIHgxKys7XHJcbiAgICAgICAgeTErKztcclxuICAgICAgfVxyXG4gICAgICB2MVtrMV9vZmZzZXRdID0geDE7XHJcbiAgICAgIGlmICh4MSA+IHRleHQxX2xlbmd0aCkge1xyXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIHJpZ2h0IG9mIHRoZSBncmFwaC5cclxuICAgICAgICBrMWVuZCArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKHkxID4gdGV4dDJfbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgYm90dG9tIG9mIHRoZSBncmFwaC5cclxuICAgICAgICBrMXN0YXJ0ICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoZnJvbnQpIHtcclxuICAgICAgICB2YXIgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xyXG4gICAgICAgIGlmIChrMl9vZmZzZXQgPj0gMCAmJiBrMl9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MltrMl9vZmZzZXRdICE9IC0xKSB7XHJcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgICAgICAgIHZhciB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XHJcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBXYWxrIHRoZSByZXZlcnNlIHBhdGggb25lIHN0ZXAuXHJcbiAgICBmb3IgKHZhciBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XHJcbiAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xyXG4gICAgICB2YXIgeDI7XHJcbiAgICAgIGlmIChrMiA9PSAtZCB8fCAoazIgIT0gZCAmJiB2MltrMl9vZmZzZXQgLSAxXSA8IHYyW2syX29mZnNldCArIDFdKSkge1xyXG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0ICsgMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgLSAxXSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHkyID0geDIgLSBrMjtcclxuICAgICAgd2hpbGUgKHgyIDwgdGV4dDFfbGVuZ3RoICYmIHkyIDwgdGV4dDJfbGVuZ3RoICYmXHJcbiAgICAgICAgICAgICB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geDIgLSAxKSA9PVxyXG4gICAgICAgICAgICAgdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkyIC0gMSkpIHtcclxuICAgICAgICB4MisrO1xyXG4gICAgICAgIHkyKys7XHJcbiAgICAgIH1cclxuICAgICAgdjJbazJfb2Zmc2V0XSA9IHgyO1xyXG4gICAgICBpZiAoeDIgPiB0ZXh0MV9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBsZWZ0IG9mIHRoZSBncmFwaC5cclxuICAgICAgICBrMmVuZCArPSAyO1xyXG4gICAgICB9IGVsc2UgaWYgKHkyID4gdGV4dDJfbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgdG9wIG9mIHRoZSBncmFwaC5cclxuICAgICAgICBrMnN0YXJ0ICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWZyb250KSB7XHJcbiAgICAgICAgdmFyIGsxX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMjtcclxuICAgICAgICBpZiAoazFfb2Zmc2V0ID49IDAgJiYgazFfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjFbazFfb2Zmc2V0XSAhPSAtMSkge1xyXG4gICAgICAgICAgdmFyIHgxID0gdjFbazFfb2Zmc2V0XTtcclxuICAgICAgICAgIHZhciB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XHJcbiAgICAgICAgICAvLyBNaXJyb3IgeDIgb250byB0b3AtbGVmdCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XHJcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcclxuICAgICAgICAgICAgLy8gT3ZlcmxhcCBkZXRlY3RlZC5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlmZl9iaXNlY3RTcGxpdF8odGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8gRGlmZiB0b29rIHRvbyBsb25nIGFuZCBoaXQgdGhlIGRlYWRsaW5lIG9yXHJcbiAgLy8gbnVtYmVyIG9mIGRpZmZzIGVxdWFscyBudW1iZXIgb2YgY2hhcmFjdGVycywgbm8gY29tbW9uYWxpdHkgYXQgYWxsLlxyXG4gIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIGxvY2F0aW9uIG9mIHRoZSAnbWlkZGxlIHNuYWtlJywgc3BsaXQgdGhlIGRpZmYgaW4gdHdvIHBhcnRzXHJcbiAqIGFuZCByZWN1cnNlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgT2xkIHN0cmluZyB0byBiZSBkaWZmZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBOZXcgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHggSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDEuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IEluZGV4IG9mIHNwbGl0IHBvaW50IGluIHRleHQyLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSBhdCB3aGljaCB0byBiYWlsIGlmIG5vdCB5ZXQgY29tcGxldGUuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9iaXNlY3RTcGxpdF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIHgsIHksXHJcbiAgICBkZWFkbGluZSkge1xyXG4gIHZhciB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCk7XHJcbiAgdmFyIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcclxuICB2YXIgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpO1xyXG4gIHZhciB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSk7XHJcblxyXG4gIC8vIENvbXB1dGUgYm90aCBkaWZmcyBzZXJpYWxseS5cclxuICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWEsIHRleHQyYSwgZmFsc2UsIGRlYWRsaW5lKTtcclxuICB2YXIgZGlmZnNiID0gdGhpcy5kaWZmX21haW4odGV4dDFiLCB0ZXh0MmIsIGZhbHNlLCBkZWFkbGluZSk7XHJcblxyXG4gIHJldHVybiBkaWZmcy5jb25jYXQoZGlmZnNiKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogU3BsaXQgdHdvIHRleHRzIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcclxuICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge3tjaGFyczE6IHN0cmluZywgY2hhcnMyOiBzdHJpbmcsIGxpbmVBcnJheTogIUFycmF5LjxzdHJpbmc+fX1cclxuICogICAgIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlbmNvZGVkIHRleHQxLCB0aGUgZW5jb2RlZCB0ZXh0MiBhbmRcclxuICogICAgIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncy5cclxuICogICAgIFRoZSB6ZXJvdGggZWxlbWVudCBvZiB0aGUgYXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MgaXMgaW50ZW50aW9uYWxseSBibGFuay5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGluZXNUb0NoYXJzXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIHZhciBsaW5lQXJyYXkgPSBbXTsgIC8vIGUuZy4gbGluZUFycmF5WzRdID09ICdIZWxsb1xcbidcclxuICB2YXIgbGluZUhhc2ggPSB7fTsgICAvLyBlLmcuIGxpbmVIYXNoWydIZWxsb1xcbiddID09IDRcclxuXHJcbiAgLy8gJ1xceDAwJyBpcyBhIHZhbGlkIGNoYXJhY3RlciwgYnV0IHZhcmlvdXMgZGVidWdnZXJzIGRvbid0IGxpa2UgaXQuXHJcbiAgLy8gU28gd2UnbGwgaW5zZXJ0IGEganVuayBlbnRyeSB0byBhdm9pZCBnZW5lcmF0aW5nIGEgbnVsbCBjaGFyYWN0ZXIuXHJcbiAgbGluZUFycmF5WzBdID0gJyc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwbGl0IGEgdGV4dCBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MuICBSZWR1Y2UgdGhlIHRleHRzIHRvIGEgc3RyaW5nIG9mXHJcbiAgICogaGFzaGVzIHdoZXJlIGVhY2ggVW5pY29kZSBjaGFyYWN0ZXIgcmVwcmVzZW50cyBvbmUgbGluZS5cclxuICAgKiBNb2RpZmllcyBsaW5lYXJyYXkgYW5kIGxpbmVoYXNoIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFN0cmluZyB0byBlbmNvZGUuXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIHN0cmluZy5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpZmZfbGluZXNUb0NoYXJzTXVuZ2VfKHRleHQpIHtcclxuICAgIHZhciBjaGFycyA9ICcnO1xyXG4gICAgLy8gV2FsayB0aGUgdGV4dCwgcHVsbGluZyBvdXQgYSBzdWJzdHJpbmcgZm9yIGVhY2ggbGluZS5cclxuICAgIC8vIHRleHQuc3BsaXQoJ1xcbicpIHdvdWxkIHdvdWxkIHRlbXBvcmFyaWx5IGRvdWJsZSBvdXIgbWVtb3J5IGZvb3RwcmludC5cclxuICAgIC8vIE1vZGlmeWluZyB0ZXh0IHdvdWxkIGNyZWF0ZSBtYW55IGxhcmdlIHN0cmluZ3MgdG8gZ2FyYmFnZSBjb2xsZWN0LlxyXG4gICAgdmFyIGxpbmVTdGFydCA9IDA7XHJcbiAgICB2YXIgbGluZUVuZCA9IC0xO1xyXG4gICAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXJpYWJsZSBpcyBmYXN0ZXIgdGhhbiBsb29raW5nIGl0IHVwLlxyXG4gICAgdmFyIGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XHJcbiAgICB3aGlsZSAobGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMSkge1xyXG4gICAgICBsaW5lRW5kID0gdGV4dC5pbmRleE9mKCdcXG4nLCBsaW5lU3RhcnQpO1xyXG4gICAgICBpZiAobGluZUVuZCA9PSAtMSkge1xyXG4gICAgICAgIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDE7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcclxuICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XHJcblxyXG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eShsaW5lKSA6XHJcbiAgICAgICAgICAobGluZUhhc2hbbGluZV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVBcnJheUxlbmd0aCk7XHJcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XHJcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGFycztcclxuICB9XHJcblxyXG4gIHZhciBjaGFyczEgPSBkaWZmX2xpbmVzVG9DaGFyc011bmdlXyh0ZXh0MSk7XHJcbiAgdmFyIGNoYXJzMiA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2VfKHRleHQyKTtcclxuICByZXR1cm4ge2NoYXJzMTogY2hhcnMxLCBjaGFyczI6IGNoYXJzMiwgbGluZUFycmF5OiBsaW5lQXJyYXl9O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWh5ZHJhdGUgdGhlIHRleHQgaW4gYSBkaWZmIGZyb20gYSBzdHJpbmcgb2YgbGluZSBoYXNoZXMgdG8gcmVhbCBsaW5lcyBvZlxyXG4gKiB0ZXh0LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gbGluZUFycmF5IEFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jaGFyc1RvTGluZXNfID0gZnVuY3Rpb24oZGlmZnMsIGxpbmVBcnJheSkge1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBjaGFycyA9IGRpZmZzW3hdWzFdO1xyXG4gICAgdmFyIHRleHQgPSBbXTtcclxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2hhcnMubGVuZ3RoOyB5KyspIHtcclxuICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcclxuICAgIH1cclxuICAgIGRpZmZzW3hdWzFdID0gdGV4dC5qb2luKCcnKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHByZWZpeCBvZiB0d28gc3RyaW5ncy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgc3RhcnQgb2YgZWFjaFxyXG4gKiAgICAgc3RyaW5nLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25QcmVmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXHJcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KDApICE9IHRleHQyLmNoYXJBdCgwKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIC8vIEJpbmFyeSBzZWFyY2guXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cclxuICB2YXIgcG9pbnRlcm1pbiA9IDA7XHJcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XHJcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xyXG4gIHZhciBwb2ludGVyc3RhcnQgPSAwO1xyXG4gIHdoaWxlIChwb2ludGVybWluIDwgcG9pbnRlcm1pZCkge1xyXG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09XHJcbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkpIHtcclxuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XHJcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcclxuICAgIH1cclxuICAgIHBvaW50ZXJtaWQgPSBNYXRoLmZsb29yKChwb2ludGVybWF4IC0gcG9pbnRlcm1pbikgLyAyICsgcG9pbnRlcm1pbik7XHJcbiAgfVxyXG4gIHJldHVybiBwb2ludGVybWlkO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGNvbW1vbiBzdWZmaXggb2YgdHdvIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiBlYWNoIHN0cmluZy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uU3VmZml4ID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgLy8gUXVpY2sgY2hlY2sgZm9yIGNvbW1vbiBudWxsIGNhc2VzLlxyXG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8XHJcbiAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0gMSkpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICAvLyBCaW5hcnkgc2VhcmNoLlxyXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMDcvMTAvMDkvXHJcbiAgdmFyIHBvaW50ZXJtaW4gPSAwO1xyXG4gIHZhciBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xyXG4gIHZhciBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcclxuICB2YXIgcG9pbnRlcmVuZCA9IDA7XHJcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XHJcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09XHJcbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XHJcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xyXG4gICAgICBwb2ludGVyZW5kID0gcG9pbnRlcm1pbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiB0aGUgc3VmZml4IG9mIG9uZSBzdHJpbmcgaXMgdGhlIHByZWZpeCBvZiBhbm90aGVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0XHJcbiAqICAgICBzdHJpbmcgYW5kIHRoZSBzdGFydCBvZiB0aGUgc2Vjb25kIHN0cmluZy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY29tbW9uT3ZlcmxhcF8gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICAvLyBDYWNoZSB0aGUgdGV4dCBsZW5ndGhzIHRvIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMuXHJcbiAgdmFyIHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcclxuICB2YXIgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xyXG4gIC8vIEVsaW1pbmF0ZSB0aGUgbnVsbCBjYXNlLlxyXG4gIGlmICh0ZXh0MV9sZW5ndGggPT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT0gMCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIC8vIFRydW5jYXRlIHRoZSBsb25nZXIgc3RyaW5nLlxyXG4gIGlmICh0ZXh0MV9sZW5ndGggPiB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxX2xlbmd0aCAtIHRleHQyX2xlbmd0aCk7XHJcbiAgfSBlbHNlIGlmICh0ZXh0MV9sZW5ndGggPCB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxX2xlbmd0aCk7XHJcbiAgfVxyXG4gIHZhciB0ZXh0X2xlbmd0aCA9IE1hdGgubWluKHRleHQxX2xlbmd0aCwgdGV4dDJfbGVuZ3RoKTtcclxuICAvLyBRdWljayBjaGVjayBmb3IgdGhlIHdvcnN0IGNhc2UuXHJcbiAgaWYgKHRleHQxID09IHRleHQyKSB7XHJcbiAgICByZXR1cm4gdGV4dF9sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBieSBsb29raW5nIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgbWF0Y2hcclxuICAvLyBhbmQgaW5jcmVhc2UgbGVuZ3RoIHVudGlsIG5vIG1hdGNoIGlzIGZvdW5kLlxyXG4gIC8vIFBlcmZvcm1hbmNlIGFuYWx5c2lzOiBodHRwOi8vbmVpbC5mcmFzZXIubmFtZS9uZXdzLzIwMTAvMTEvMDQvXHJcbiAgdmFyIGJlc3QgPSAwO1xyXG4gIHZhciBsZW5ndGggPSAxO1xyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICB2YXIgcGF0dGVybiA9IHRleHQxLnN1YnN0cmluZyh0ZXh0X2xlbmd0aCAtIGxlbmd0aCk7XHJcbiAgICB2YXIgZm91bmQgPSB0ZXh0Mi5pbmRleE9mKHBhdHRlcm4pO1xyXG4gICAgaWYgKGZvdW5kID09IC0xKSB7XHJcbiAgICAgIHJldHVybiBiZXN0O1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoICs9IGZvdW5kO1xyXG4gICAgaWYgKGZvdW5kID09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKSA9PVxyXG4gICAgICAgIHRleHQyLnN1YnN0cmluZygwLCBsZW5ndGgpKSB7XHJcbiAgICAgIGJlc3QgPSBsZW5ndGg7XHJcbiAgICAgIGxlbmd0aCsrO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogRG8gdGhlIHR3byB0ZXh0cyBzaGFyZSBhIHN1YnN0cmluZyB3aGljaCBpcyBhdCBsZWFzdCBoYWxmIHRoZSBsZW5ndGggb2YgdGhlXHJcbiAqIGxvbmdlciB0ZXh0P1xyXG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPn0gRml2ZSBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZSBwcmVmaXggb2ZcclxuICogICAgIHRleHQxLCB0aGUgc3VmZml4IG9mIHRleHQxLCB0aGUgcHJlZml4IG9mIHRleHQyLCB0aGUgc3VmZml4IG9mXHJcbiAqICAgICB0ZXh0MiBhbmQgdGhlIGNvbW1vbiBtaWRkbGUuICBPciBudWxsIGlmIHRoZXJlIHdhcyBubyBtYXRjaC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfaGFsZk1hdGNoXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIGlmICh0aGlzLkRpZmZfVGltZW91dCA8PSAwKSB7XHJcbiAgICAvLyBEb24ndCByaXNrIHJldHVybmluZyBhIG5vbi1vcHRpbWFsIGRpZmYgaWYgd2UgaGF2ZSB1bmxpbWl0ZWQgdGltZS5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xyXG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xyXG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gbnVsbDsgIC8vIFBvaW50bGVzcy5cclxuICB9XHJcbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXHJcblxyXG4gIC8qKlxyXG4gICAqIERvZXMgYSBzdWJzdHJpbmcgb2Ygc2hvcnR0ZXh0IGV4aXN0IHdpdGhpbiBsb25ndGV4dCBzdWNoIHRoYXQgdGhlIHN1YnN0cmluZ1xyXG4gICAqIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiBsb25ndGV4dD9cclxuICAgKiBDbG9zdXJlLCBidXQgZG9lcyBub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvbmd0ZXh0IExvbmdlciBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNob3J0dGV4dCBTaG9ydGVyIHN0cmluZy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBTdGFydCBpbmRleCBvZiBxdWFydGVyIGxlbmd0aCBzdWJzdHJpbmcgd2l0aGluIGxvbmd0ZXh0LlxyXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxyXG4gICAqICAgICBsb25ndGV4dCwgdGhlIHN1ZmZpeCBvZiBsb25ndGV4dCwgdGhlIHByZWZpeCBvZiBzaG9ydHRleHQsIHRoZSBzdWZmaXhcclxuICAgKiAgICAgb2Ygc2hvcnR0ZXh0IGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LCBpKSB7XHJcbiAgICAvLyBTdGFydCB3aXRoIGEgMS80IGxlbmd0aCBzdWJzdHJpbmcgYXQgcG9zaXRpb24gaSBhcyBhIHNlZWQuXHJcbiAgICB2YXIgc2VlZCA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dC5sZW5ndGggLyA0KSk7XHJcbiAgICB2YXIgaiA9IC0xO1xyXG4gICAgdmFyIGJlc3RfY29tbW9uID0gJyc7XHJcbiAgICB2YXIgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XHJcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9IC0xKSB7XHJcbiAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25QcmVmaXgobG9uZ3RleHQuc3Vic3RyaW5nKGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaikpO1xyXG4gICAgICB2YXIgc3VmZml4TGVuZ3RoID0gZG1wLmRpZmZfY29tbW9uU3VmZml4KGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGopKTtcclxuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xyXG4gICAgICAgIGJlc3RfY29tbW9uID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqIC0gc3VmZml4TGVuZ3RoLCBqKSArXHJcbiAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XHJcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkgLSBzdWZmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcclxuICAgICAgICBiZXN0X3Nob3J0dGV4dF9hID0gc2hvcnR0ZXh0LnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcclxuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0LnN1YnN0cmluZyhqICsgcHJlZml4TGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ3RleHQubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBbYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsXHJcbiAgICAgICAgICAgICAgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc2Vjb25kIHF1YXJ0ZXIgaXMgdGhlIHNlZWQgZm9yIGEgaGFsZi1tYXRjaC5cclxuICB2YXIgaG0xID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XHJcbiAgLy8gQ2hlY2sgYWdhaW4gYmFzZWQgb24gdGhlIHRoaXJkIHF1YXJ0ZXIuXHJcbiAgdmFyIGhtMiA9IGRpZmZfaGFsZk1hdGNoSV8obG9uZ3RleHQsIHNob3J0dGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwobG9uZ3RleHQubGVuZ3RoIC8gMikpO1xyXG4gIHZhciBobTtcclxuICBpZiAoIWhtMSAmJiAhaG0yKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGVsc2UgaWYgKCFobTIpIHtcclxuICAgIGhtID0gaG0xO1xyXG4gIH0gZWxzZSBpZiAoIWhtMSkge1xyXG4gICAgaG0gPSBobTI7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEJvdGggbWF0Y2hlZC4gIFNlbGVjdCB0aGUgbG9uZ2VzdC5cclxuICAgIGhtID0gaG0xWzRdLmxlbmd0aCA+IGhtMls0XS5sZW5ndGggPyBobTEgOiBobTI7XHJcbiAgfVxyXG5cclxuICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXHJcbiAgdmFyIHRleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2I7XHJcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xyXG4gICAgdGV4dDFfYSA9IGhtWzBdO1xyXG4gICAgdGV4dDFfYiA9IGhtWzFdO1xyXG4gICAgdGV4dDJfYSA9IGhtWzJdO1xyXG4gICAgdGV4dDJfYiA9IGhtWzNdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0ZXh0Ml9hID0gaG1bMF07XHJcbiAgICB0ZXh0Ml9iID0gaG1bMV07XHJcbiAgICB0ZXh0MV9hID0gaG1bMl07XHJcbiAgICB0ZXh0MV9iID0gaG1bM107XHJcbiAgfVxyXG4gIHZhciBtaWRfY29tbW9uID0gaG1bNF07XHJcbiAgcmV0dXJuIFt0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iLCBtaWRfY29tbW9uXTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgc2VtYW50aWNhbGx5IHRyaXZpYWwgZXF1YWxpdGllcy5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfY2xlYW51cFNlbWFudGljID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xyXG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxyXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cclxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgLy8gQWx3YXlzIGVxdWFsIHRvIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdXVsxXVxyXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIHByaW9yIHRvIHRoZSBlcXVhbGl0eS5cclxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMxID0gMDtcclxuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xyXG4gIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgY2hhbmdlZCBhZnRlciB0aGUgZXF1YWxpdHkuXHJcbiAgdmFyIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XHJcbiAgdmFyIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIEVxdWFsaXR5IGZvdW5kLlxyXG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xyXG4gICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSBsZW5ndGhfaW5zZXJ0aW9uczI7XHJcbiAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gbGVuZ3RoX2RlbGV0aW9uczI7XHJcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XHJcbiAgICAgIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcclxuICAgICAgbGFzdGVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICB9IGVsc2UgeyAgLy8gQW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uLlxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcclxuICAgICAgfVxyXG4gICAgICAvLyBFbGltaW5hdGUgYW4gZXF1YWxpdHkgdGhhdCBpcyBzbWFsbGVyIG9yIGVxdWFsIHRvIHRoZSBlZGl0cyBvbiBib3RoXHJcbiAgICAgIC8vIHNpZGVzIG9mIGl0LlxyXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9XHJcbiAgICAgICAgICBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSkgJiZcclxuICAgICAgICAgIChsYXN0ZXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aF9kZWxldGlvbnMyKSkpIHtcclxuICAgICAgICAvLyBEdXBsaWNhdGUgcmVjb3JkLlxyXG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgW0RJRkZfREVMRVRFLCBsYXN0ZXF1YWxpdHldKTtcclxuICAgICAgICAvLyBDaGFuZ2Ugc2Vjb25kIGNvcHkgdG8gaW5zZXJ0LlxyXG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcclxuICAgICAgICAvLyBUaHJvdyBhd2F5IHRoZSBlcXVhbGl0eSB3ZSBqdXN0IGRlbGV0ZWQuXHJcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xyXG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5IChpdCBuZWVkcyB0byBiZSByZWV2YWx1YXRlZCkuXHJcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xyXG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XHJcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gMDsgIC8vIFJlc2V0IHRoZSBjb3VudGVycy5cclxuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XHJcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcclxuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XHJcbiAgICAgICAgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuXHJcbiAgLy8gTm9ybWFsaXplIHRoZSBkaWZmLlxyXG4gIGlmIChjaGFuZ2VzKSB7XHJcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICB9XHJcbiAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcclxuXHJcbiAgLy8gRmluZCBhbnkgb3ZlcmxhcHMgYmV0d2VlbiBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMuXHJcbiAgLy8gZS5nOiA8ZGVsPmFiY3h4eDwvZGVsPjxpbnM+eHh4ZGVmPC9pbnM+XHJcbiAgLy8gICAtPiA8ZGVsPmFiYzwvZGVsPnh4eDxpbnM+ZGVmPC9pbnM+XHJcbiAgLy8gZS5nOiA8ZGVsPnh4eGFiYzwvZGVsPjxpbnM+ZGVmeHh4PC9pbnM+XHJcbiAgLy8gICAtPiA8aW5zPmRlZjwvaW5zPnh4eDxkZWw+YWJjPC9kZWw+XHJcbiAgLy8gT25seSBleHRyYWN0IGFuIG92ZXJsYXAgaWYgaXQgaXMgYXMgYmlnIGFzIHRoZSBlZGl0IGFoZWFkIG9yIGJlaGluZCBpdC5cclxuICBwb2ludGVyID0gMTtcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0RFTEVURSAmJlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgIHZhciBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXTtcclxuICAgICAgdmFyIGluc2VydGlvbiA9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICB2YXIgb3ZlcmxhcF9sZW5ndGgxID0gdGhpcy5kaWZmX2NvbW1vbk92ZXJsYXBfKGRlbGV0aW9uLCBpbnNlcnRpb24pO1xyXG4gICAgICB2YXIgb3ZlcmxhcF9sZW5ndGgyID0gdGhpcy5kaWZmX2NvbW1vbk92ZXJsYXBfKGluc2VydGlvbiwgZGVsZXRpb24pO1xyXG4gICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IG92ZXJsYXBfbGVuZ3RoMikge1xyXG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fFxyXG4gICAgICAgICAgICBvdmVybGFwX2xlbmd0aDEgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcclxuICAgICAgICAgIC8vIE92ZXJsYXAgZm91bmQuICBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsXHJcbiAgICAgICAgICAgICAgW0RJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgxKV0pO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID1cclxuICAgICAgICAgICAgICBkZWxldGlvbi5zdWJzdHJpbmcoMCwgZGVsZXRpb24ubGVuZ3RoIC0gb3ZlcmxhcF9sZW5ndGgxKTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgxKTtcclxuICAgICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMiA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8XHJcbiAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xyXG4gICAgICAgICAgLy8gUmV2ZXJzZSBvdmVybGFwIGZvdW5kLlxyXG4gICAgICAgICAgLy8gSW5zZXJ0IGFuIGVxdWFsaXR5IGFuZCBzd2FwIGFuZCB0cmltIHRoZSBzdXJyb3VuZGluZyBlZGl0cy5cclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLFxyXG4gICAgICAgICAgICAgIFtESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgyKV0pO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQ7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxyXG4gICAgICAgICAgICAgIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMik7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9XHJcbiAgICAgICAgICAgICAgZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMik7XHJcbiAgICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHBvaW50ZXIrKztcclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvb2sgZm9yIHNpbmdsZSBlZGl0cyBzdXJyb3VuZGVkIG9uIGJvdGggc2lkZXMgYnkgZXF1YWxpdGllc1xyXG4gKiB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBhbGlnbiB0aGUgZWRpdCB0byBhIHdvcmQgYm91bmRhcnkuXHJcbiAqIGUuZzogVGhlIGM8aW5zPmF0IGM8L2lucz5hbWUuIC0+IFRoZSA8aW5zPmNhdCA8L2lucz5jYW1lLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWNMb3NzbGVzcyA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgLyoqXHJcbiAgICogR2l2ZW4gdHdvIHN0cmluZ3MsIGNvbXB1dGUgYSBzY29yZSByZXByZXNlbnRpbmcgd2hldGhlciB0aGUgaW50ZXJuYWxcclxuICAgKiBib3VuZGFyeSBmYWxscyBvbiBsb2dpY2FsIGJvdW5kYXJpZXMuXHJcbiAgICogU2NvcmVzIHJhbmdlIGZyb20gNiAoYmVzdCkgdG8gMCAod29yc3QpLlxyXG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb25lIEZpcnN0IHN0cmluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHdvIFNlY29uZCBzdHJpbmcuXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgc2NvcmUuXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhvbmUsIHR3bykge1xyXG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xyXG4gICAgICAvLyBFZGdlcyBhcmUgdGhlIGJlc3QuXHJcbiAgICAgIHJldHVybiA2O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVhY2ggcG9ydCBvZiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50bHkgZHVlIHRvXHJcbiAgICAvLyBzdWJ0bGUgZGlmZmVyZW5jZXMgaW4gZWFjaCBsYW5ndWFnZSdzIGRlZmluaXRpb24gb2YgdGhpbmdzIGxpa2VcclxuICAgIC8vICd3aGl0ZXNwYWNlJy4gIFNpbmNlIHRoaXMgZnVuY3Rpb24ncyBwdXJwb3NlIGlzIGxhcmdlbHkgY29zbWV0aWMsXHJcbiAgICAvLyB0aGUgY2hvaWNlIGhhcyBiZWVuIG1hZGUgdG8gdXNlIGVhY2ggbGFuZ3VhZ2UncyBuYXRpdmUgZmVhdHVyZXNcclxuICAgIC8vIHJhdGhlciB0aGFuIGZvcmNlIHRvdGFsIGNvbmZvcm1pdHkuXHJcbiAgICB2YXIgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKTtcclxuICAgIHZhciBjaGFyMiA9IHR3by5jaGFyQXQoMCk7XHJcbiAgICB2YXIgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfKTtcclxuICAgIHZhciBub25BbHBoYU51bWVyaWMyID0gY2hhcjIubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ub25BbHBoYU51bWVyaWNSZWdleF8pO1xyXG4gICAgdmFyIHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJlxyXG4gICAgICAgIGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gud2hpdGVzcGFjZVJlZ2V4Xyk7XHJcbiAgICB2YXIgd2hpdGVzcGFjZTIgPSBub25BbHBoYU51bWVyaWMyICYmXHJcbiAgICAgICAgY2hhcjIubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC53aGl0ZXNwYWNlUmVnZXhfKTtcclxuICAgIHZhciBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiZcclxuICAgICAgICBjaGFyMS5tYXRjaChkaWZmX21hdGNoX3BhdGNoLmxpbmVicmVha1JlZ2V4Xyk7XHJcbiAgICB2YXIgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmXHJcbiAgICAgICAgY2hhcjIubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5saW5lYnJlYWtSZWdleF8pO1xyXG4gICAgdmFyIGJsYW5rTGluZTEgPSBsaW5lQnJlYWsxICYmXHJcbiAgICAgICAgb25lLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lRW5kUmVnZXhfKTtcclxuICAgIHZhciBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJlxyXG4gICAgICAgIHR3by5tYXRjaChkaWZmX21hdGNoX3BhdGNoLmJsYW5rbGluZVN0YXJ0UmVnZXhfKTtcclxuXHJcbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XHJcbiAgICAgIC8vIEZpdmUgcG9pbnRzIGZvciBibGFuayBsaW5lcy5cclxuICAgICAgcmV0dXJuIDU7XHJcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xyXG4gICAgICAvLyBGb3VyIHBvaW50cyBmb3IgbGluZSBicmVha3MuXHJcbiAgICAgIHJldHVybiA0O1xyXG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xyXG4gICAgICAvLyBUaHJlZSBwb2ludHMgZm9yIGVuZCBvZiBzZW50ZW5jZXMuXHJcbiAgICAgIHJldHVybiAzO1xyXG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xyXG4gICAgICAvLyBUd28gcG9pbnRzIGZvciB3aGl0ZXNwYWNlLlxyXG4gICAgICByZXR1cm4gMjtcclxuICAgIH0gZWxzZSBpZiAobm9uQWxwaGFOdW1lcmljMSB8fCBub25BbHBoYU51bWVyaWMyKSB7XHJcbiAgICAgIC8vIE9uZSBwb2ludCBmb3Igbm9uLWFscGhhbnVtZXJpYy5cclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHZhciBwb2ludGVyID0gMTtcclxuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcclxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxyXG4gICAgICB2YXIgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xyXG4gICAgICB2YXIgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICB2YXIgZXF1YWxpdHkyID0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xyXG5cclxuICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBlZGl0IGFzIGZhciBsZWZ0IGFzIHBvc3NpYmxlLlxyXG4gICAgICB2YXIgY29tbW9uT2Zmc2V0ID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeChlcXVhbGl0eTEsIGVkaXQpO1xyXG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcclxuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xyXG4gICAgICAgIGVkaXQgPSBjb21tb25TdHJpbmcgKyBlZGl0LnN1YnN0cmluZygwLCBlZGl0Lmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XHJcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZWNvbmQsIHN0ZXAgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciByaWdodCwgbG9va2luZyBmb3IgdGhlIGJlc3QgZml0LlxyXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcclxuICAgICAgdmFyIGJlc3RFZGl0ID0gZWRpdDtcclxuICAgICAgdmFyIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XHJcbiAgICAgIHZhciBiZXN0U2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcclxuICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVkaXQsIGVxdWFsaXR5Mik7XHJcbiAgICAgIHdoaWxlIChlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKSkge1xyXG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcclxuICAgICAgICBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApO1xyXG4gICAgICAgIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgdmFyIHNjb3JlID0gZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZXF1YWxpdHkxLCBlZGl0KSArXHJcbiAgICAgICAgICAgIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVkaXQsIGVxdWFsaXR5Mik7XHJcbiAgICAgICAgLy8gVGhlID49IGVuY291cmFnZXMgdHJhaWxpbmcgcmF0aGVyIHRoYW4gbGVhZGluZyB3aGl0ZXNwYWNlIG9uIGVkaXRzLlxyXG4gICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpIHtcclxuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xyXG4gICAgICAgICAgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcclxuICAgICAgICAgIGJlc3RFZGl0ID0gZWRpdDtcclxuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzFdICE9IGJlc3RFcXVhbGl0eTEpIHtcclxuICAgICAgICAvLyBXZSBoYXZlIGFuIGltcHJvdmVtZW50LCBzYXZlIGl0IGJhY2sgdG8gdGhlIGRpZmYuXHJcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XHJcbiAgICAgICAgICBwb2ludGVyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XHJcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGJlc3RFcXVhbGl0eTI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XHJcbiAgICAgICAgICBwb2ludGVyLS07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gRGVmaW5lIHNvbWUgcmVnZXggcGF0dGVybnMgZm9yIG1hdGNoaW5nIGJvdW5kYXJpZXMuXHJcbmRpZmZfbWF0Y2hfcGF0Y2gubm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XHJcbmRpZmZfbWF0Y2hfcGF0Y2gud2hpdGVzcGFjZVJlZ2V4XyA9IC9cXHMvO1xyXG5kaWZmX21hdGNoX3BhdGNoLmxpbmVicmVha1JlZ2V4XyA9IC9bXFxyXFxuXS87XHJcbmRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcclxuZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVTdGFydFJlZ2V4XyA9IC9eXFxyP1xcblxccj9cXG4vO1xyXG5cclxuLyoqXHJcbiAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIGVkaXRzIGJ5IGVsaW1pbmF0aW5nIG9wZXJhdGlvbmFsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcclxuICB2YXIgZXF1YWxpdGllcyA9IFtdOyAgLy8gU3RhY2sgb2YgaW5kaWNlcyB3aGVyZSBlcXVhbGl0aWVzIGFyZSBmb3VuZC5cclxuICB2YXIgZXF1YWxpdGllc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXHJcbiAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xyXG4gIHZhciBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gIC8vIEFsd2F5cyBlcXVhbCB0byBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXV1bMV1cclxuICB2YXIgcG9pbnRlciA9IDA7ICAvLyBJbmRleCBvZiBjdXJyZW50IHBvc2l0aW9uLlxyXG4gIC8vIElzIHRoZXJlIGFuIGluc2VydGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwcmVfaW5zID0gZmFsc2U7XHJcbiAgLy8gSXMgdGhlcmUgYSBkZWxldGlvbiBvcGVyYXRpb24gYmVmb3JlIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwcmVfZGVsID0gZmFsc2U7XHJcbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cclxuICB2YXIgcG9zdF9pbnMgPSBmYWxzZTtcclxuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBhZnRlciB0aGUgbGFzdCBlcXVhbGl0eS5cclxuICB2YXIgcG9zdF9kZWwgPSBmYWxzZTtcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfRVFVQUwpIHsgIC8vIEVxdWFsaXR5IGZvdW5kLlxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0ICYmXHJcbiAgICAgICAgICAocG9zdF9pbnMgfHwgcG9zdF9kZWwpKSB7XHJcbiAgICAgICAgLy8gQ2FuZGlkYXRlIGZvdW5kLlxyXG4gICAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XHJcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xyXG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcclxuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBOb3QgYSBjYW5kaWRhdGUsIGFuZCBjYW4gbmV2ZXIgYmVjb21lIG9uZS5cclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcclxuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7ICAvLyBBbiBpbnNlcnRpb24gb3IgZGVsZXRpb24uXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0RFTEVURSkge1xyXG4gICAgICAgIHBvc3RfZGVsID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwb3N0X2lucyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgLypcclxuICAgICAgICogRml2ZSB0eXBlcyB0byBiZSBzcGxpdDpcclxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WFk8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cclxuICAgICAgICogPGlucz5BPC9pbnM+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGlucz5DPC9pbnM+XHJcbiAgICAgICAqIDxpbnM+QTwvZGVsPlg8aW5zPkM8L2lucz48ZGVsPkQ8L2RlbD5cclxuICAgICAgICogPGlucz5BPC9pbnM+PGRlbD5CPC9kZWw+WDxkZWw+QzwvZGVsPlxyXG4gICAgICAgKi9cclxuICAgICAgaWYgKGxhc3RlcXVhbGl0eSAmJiAoKHByZV9pbnMgJiYgcHJlX2RlbCAmJiBwb3N0X2lucyAmJiBwb3N0X2RlbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKChsYXN0ZXF1YWxpdHkubGVuZ3RoIDwgdGhpcy5EaWZmX0VkaXRDb3N0IC8gMikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmVfaW5zICsgcHJlX2RlbCArIHBvc3RfaW5zICsgcG9zdF9kZWwpID09IDMpKSkge1xyXG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmQuXHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xyXG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXHJcbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xyXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZDtcclxuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcclxuICAgICAgICAgIC8vIE5vIGNoYW5nZXMgbWFkZSB3aGljaCBjb3VsZCBhZmZlY3QgcHJldmlvdXMgZW50cnksIGtlZXAgZ29pbmcuXHJcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gdHJ1ZTtcclxuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07ICAvLyBUaHJvdyBhd2F5IHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cclxuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/XHJcbiAgICAgICAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcclxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcblxyXG4gIGlmIChjaGFuZ2VzKSB7XHJcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlb3JkZXIgYW5kIG1lcmdlIGxpa2UgZWRpdCBzZWN0aW9ucy4gIE1lcmdlIGVxdWFsaXRpZXMuXHJcbiAqIEFueSBlZGl0IHNlY3Rpb24gY2FuIG1vdmUgYXMgbG9uZyBhcyBpdCBkb2Vzbid0IGNyb3NzIGFuIGVxdWFsaXR5LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwTWVyZ2UgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsICcnXSk7ICAvLyBBZGQgYSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxyXG4gIHZhciBwb2ludGVyID0gMDtcclxuICB2YXIgY291bnRfZGVsZXRlID0gMDtcclxuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcclxuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcclxuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcclxuICB2YXIgY29tbW9ubGVuZ3RoO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XHJcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xyXG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIC8vIFVwb24gcmVhY2hpbmcgYW4gZXF1YWxpdHksIGNoZWNrIGZvciBwcmlvciByZWR1bmRhbmNpZXMuXHJcbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCA+IDEpIHtcclxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgYW55IGNvbW1vbiBwcmVmaXhpZXMuXHJcbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcclxuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIGlmICgocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVswXSA9PVxyXG4gICAgICAgICAgICAgICAgICBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz1cclxuICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIFtESUZGX0VRVUFMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHN1ZmZpeGllcy5cclxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblN1ZmZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xyXG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC1cclxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRfaW5zZXJ0Lmxlbmd0aCAtXHJcbiAgICAgICAgICAgICAgICAgIGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dF9kZWxldGUubGVuZ3RoIC1cclxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gRGVsZXRlIHRoZSBvZmZlbmRpbmcgcmVjb3JkcyBhbmQgYWRkIHRoZSBtZXJnZWQgb25lcy5cclxuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgPT09IDApIHtcclxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9pbnNlcnQsXHJcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnRfaW5zZXJ0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlLFxyXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcclxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfREVMRVRFLCB0ZXh0X2RlbGV0ZV0sXHJcbiAgICAgICAgICAgICAgICBbRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0XSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCArXHJcbiAgICAgICAgICAgICAgICAgICAgKGNvdW50X2RlbGV0ZSA/IDEgOiAwKSArIChjb3VudF9pbnNlcnQgPyAxIDogMCkgKyAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgLy8gTWVyZ2UgdGhpcyBlcXVhbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnRfaW5zZXJ0ID0gMDtcclxuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xyXG4gICAgICAgIHRleHRfZGVsZXRlID0gJyc7XHJcbiAgICAgICAgdGV4dF9pbnNlcnQgPSAnJztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSAnJykge1xyXG4gICAgZGlmZnMucG9wKCk7ICAvLyBSZW1vdmUgdGhlIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXHJcbiAgfVxyXG5cclxuICAvLyBTZWNvbmQgcGFzczogbG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXHJcbiAgLy8gd2hpY2ggY2FuIGJlIHNoaWZ0ZWQgc2lkZXdheXMgdG8gZWxpbWluYXRlIGFuIGVxdWFsaXR5LlxyXG4gIC8vIGUuZzogQTxpbnM+QkE8L2lucz5DIC0+IDxpbnM+QUI8L2lucz5BQ1xyXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XHJcbiAgcG9pbnRlciA9IDE7XHJcbiAgLy8gSW50ZW50aW9uYWxseSBpZ25vcmUgdGhlIGZpcnN0IGFuZCBsYXN0IGVsZW1lbnQgKGRvbid0IG5lZWQgY2hlY2tpbmcpLlxyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xyXG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMICYmXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID09IERJRkZfRVFVQUwpIHtcclxuICAgICAgLy8gVGhpcyBpcyBhIHNpbmdsZSBlZGl0IHN1cnJvdW5kZWQgYnkgZXF1YWxpdGllcy5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT0gZGlmZnNbcG9pbnRlciAtIDFdWzFdKSB7XHJcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgcHJldmlvdXMgZXF1YWxpdHkuXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gK1xyXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpO1xyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcclxuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xyXG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PVxyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XHJcbiAgICAgICAgLy8gU2hpZnQgdGhlIGVkaXQgb3ZlciB0aGUgbmV4dCBlcXVhbGl0eS5cclxuICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdO1xyXG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID1cclxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICtcclxuICAgICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xyXG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XHJcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcbiAgLy8gSWYgc2hpZnRzIHdlcmUgbWFkZSwgdGhlIGRpZmYgbmVlZHMgcmVvcmRlcmluZyBhbmQgYW5vdGhlciBzaGlmdCBzd2VlcC5cclxuICBpZiAoY2hhbmdlcykge1xyXG4gICAgdGhpcy5kaWZmX2NsZWFudXBNZXJnZShkaWZmcyk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBsb2MgaXMgYSBsb2NhdGlvbiBpbiB0ZXh0MSwgY29tcHV0ZSBhbmQgcmV0dXJuIHRoZSBlcXVpdmFsZW50IGxvY2F0aW9uIGluXHJcbiAqIHRleHQyLlxyXG4gKiBlLmcuICdUaGUgY2F0JyB2cyAnVGhlIGJpZyBjYXQnLCAxLT4xLCA1LT44XHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb2MgTG9jYXRpb24gd2l0aGluIHRleHQxLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IExvY2F0aW9uIHdpdGhpbiB0ZXh0Mi5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfeEluZGV4ID0gZnVuY3Rpb24oZGlmZnMsIGxvYykge1xyXG4gIHZhciBjaGFyczEgPSAwO1xyXG4gIHZhciBjaGFyczIgPSAwO1xyXG4gIHZhciBsYXN0X2NoYXJzMSA9IDA7XHJcbiAgdmFyIGxhc3RfY2hhcnMyID0gMDtcclxuICB2YXIgeDtcclxuICBmb3IgKHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHsgIC8vIEVxdWFsaXR5IG9yIGRlbGV0aW9uLlxyXG4gICAgICBjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkgeyAgLy8gRXF1YWxpdHkgb3IgaW5zZXJ0aW9uLlxyXG4gICAgICBjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKGNoYXJzMSA+IGxvYykgeyAgLy8gT3ZlcnNob3QgdGhlIGxvY2F0aW9uLlxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xyXG4gICAgbGFzdF9jaGFyczIgPSBjaGFyczI7XHJcbiAgfVxyXG4gIC8vIFdhcyB0aGUgbG9jYXRpb24gd2FzIGRlbGV0ZWQ/XHJcbiAgaWYgKGRpZmZzLmxlbmd0aCAhPSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSkge1xyXG4gICAgcmV0dXJuIGxhc3RfY2hhcnMyO1xyXG4gIH1cclxuICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXIgbGVuZ3RoLlxyXG4gIHJldHVybiBsYXN0X2NoYXJzMiArIChsb2MgLSBsYXN0X2NoYXJzMSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBkaWZmIGFycmF5IGludG8gYSBwcmV0dHkgSFRNTCByZXBvcnQuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gSFRNTCByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfcHJldHR5SHRtbCA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIGh0bWwgPSBbXTtcclxuICB2YXIgcGF0dGVybl9hbXAgPSAvJi9nO1xyXG4gIHZhciBwYXR0ZXJuX2x0ID0gLzwvZztcclxuICB2YXIgcGF0dGVybl9ndCA9IC8+L2c7XHJcbiAgdmFyIHBhdHRlcm5fcGFyYSA9IC9cXG4vZztcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTsgICAgLy8gT3BlcmF0aW9uIChpbnNlcnQsIGRlbGV0ZSwgZXF1YWwpXHJcbiAgICB2YXIgZGF0YSA9IGRpZmZzW3hdWzFdOyAgLy8gVGV4dCBvZiBjaGFuZ2UuXHJcbiAgICB2YXIgdGV4dCA9IGRhdGEucmVwbGFjZShwYXR0ZXJuX2FtcCwgJyZhbXA7JykucmVwbGFjZShwYXR0ZXJuX2x0LCAnJmx0OycpXHJcbiAgICAgICAgLnJlcGxhY2UocGF0dGVybl9ndCwgJyZndDsnKS5yZXBsYWNlKHBhdHRlcm5fcGFyYSwgJyZwYXJhOzxicj4nKTtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBodG1sW3hdID0gJzxpbnMgc3R5bGU9XCJiYWNrZ3JvdW5kOiNlNmZmZTY7XCI+JyArIHRleHQgKyAnPC9pbnM+JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBodG1sW3hdID0gJzxkZWwgc3R5bGU9XCJiYWNrZ3JvdW5kOiNmZmU2ZTY7XCI+JyArIHRleHQgKyAnPC9kZWw+JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIGh0bWxbeF0gPSAnPHNwYW4+JyArIHRleHQgKyAnPC9zcGFuPic7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBodG1sLmpvaW4oJycpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNvdXJjZSB0ZXh0IChhbGwgZXF1YWxpdGllcyBhbmQgZGVsZXRpb25zKS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBTb3VyY2UgdGV4dC5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfdGV4dDEgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciB0ZXh0ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICB0ZXh0W3hdID0gZGlmZnNbeF1bMV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0LmpvaW4oJycpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIGRlc3RpbmF0aW9uIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBpbnNlcnRpb25zKS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBEZXN0aW5hdGlvbiB0ZXh0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MiA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIExldmVuc2h0ZWluIGRpc3RhbmNlOyB0aGUgbnVtYmVyIG9mIGluc2VydGVkLCBkZWxldGVkIG9yXHJcbiAqIHN1YnN0aXR1dGVkIGNoYXJhY3RlcnMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGNoYW5nZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xldmVuc2h0ZWluID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgbGV2ZW5zaHRlaW4gPSAwO1xyXG4gIHZhciBpbnNlcnRpb25zID0gMDtcclxuICB2YXIgZGVsZXRpb25zID0gMDtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgb3AgPSBkaWZmc1t4XVswXTtcclxuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07XHJcbiAgICBzd2l0Y2ggKG9wKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICAvLyBBIGRlbGV0aW9uIGFuZCBhbiBpbnNlcnRpb24gaXMgb25lIHN1YnN0aXR1dGlvbi5cclxuICAgICAgICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xyXG4gICAgICAgIGluc2VydGlvbnMgPSAwO1xyXG4gICAgICAgIGRlbGV0aW9ucyA9IDA7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XHJcbiAgcmV0dXJuIGxldmVuc2h0ZWluO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDcnVzaCB0aGUgZGlmZiBpbnRvIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGUgb3BlcmF0aW9uc1xyXG4gKiByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0Mi5cclxuICogRS5nLiA9M1xcdC0yXFx0K2luZyAgLT4gS2VlcCAzIGNoYXJzLCBkZWxldGUgMiBjaGFycywgaW5zZXJ0ICdpbmcnLlxyXG4gKiBPcGVyYXRpb25zIGFyZSB0YWItc2VwYXJhdGVkLiAgSW5zZXJ0ZWQgdGV4dCBpcyBlc2NhcGVkIHVzaW5nICV4eCBub3RhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBEZWx0YSB0ZXh0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90b0RlbHRhID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgdGV4dCA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHN3aXRjaCAoZGlmZnNbeF1bMF0pIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICB0ZXh0W3hdID0gJysnICsgZW5jb2RlVVJJKGRpZmZzW3hdWzFdKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICB0ZXh0W3hdID0gJy0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgdGV4dFt4XSA9ICc9JyArIGRpZmZzW3hdWzFdLmxlbmd0aDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignXFx0JykucmVwbGFjZSgvJTIwL2csICcgJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBvcmlnaW5hbCB0ZXh0MSwgYW5kIGFuIGVuY29kZWQgc3RyaW5nIHdoaWNoIGRlc2NyaWJlcyB0aGVcclxuICogb3BlcmF0aW9ucyByZXF1aXJlZCB0byB0cmFuc2Zvcm0gdGV4dDEgaW50byB0ZXh0MiwgY29tcHV0ZSB0aGUgZnVsbCBkaWZmLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgU291cmNlIHN0cmluZyBmb3IgdGhlIGRpZmYuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWx0YSBEZWx0YSB0ZXh0LlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHRocm93cyB7IUVycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9mcm9tRGVsdGEgPSBmdW5jdGlvbih0ZXh0MSwgZGVsdGEpIHtcclxuICB2YXIgZGlmZnMgPSBbXTtcclxuICB2YXIgZGlmZnNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEN1cnNvciBpbiB0ZXh0MVxyXG4gIHZhciB0b2tlbnMgPSBkZWx0YS5zcGxpdCgvXFx0L2cpO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdG9rZW5zLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAvLyBFYWNoIHRva2VuIGJlZ2lucyB3aXRoIGEgb25lIGNoYXJhY3RlciBwYXJhbWV0ZXIgd2hpY2ggc3BlY2lmaWVzIHRoZVxyXG4gICAgLy8gb3BlcmF0aW9uIG9mIHRoaXMgdG9rZW4gKGRlbGV0ZSwgaW5zZXJ0LCBlcXVhbGl0eSkuXHJcbiAgICB2YXIgcGFyYW0gPSB0b2tlbnNbeF0uc3Vic3RyaW5nKDEpO1xyXG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XHJcbiAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0lOU0VSVCwgZGVjb2RlVVJJKHBhcmFtKV07XHJcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgZXNjYXBlIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxyXG4gICAgICBjYXNlICc9JzpcclxuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KHBhcmFtLCAxMCk7XHJcbiAgICAgICAgaWYgKGlzTmFOKG4pIHx8IG4gPCAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAnICsgcGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4dCA9IHRleHQxLnN1YnN0cmluZyhwb2ludGVyLCBwb2ludGVyICs9IG4pO1xyXG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09ICc9Jykge1xyXG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9FUVVBTCwgdGV4dF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfREVMRVRFLCB0ZXh0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgLy8gQmxhbmsgdG9rZW5zIGFyZSBvayAoZnJvbSBhIHRyYWlsaW5nIFxcdCkuXHJcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBpcyBhbiBlcnJvci5cclxuICAgICAgICBpZiAodG9rZW5zW3hdKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vuc1t4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAocG9pbnRlciAhPSB0ZXh0MS5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignRGVsdGEgbGVuZ3RoICgnICsgcG9pbnRlciArXHJcbiAgICAgICAgJykgZG9lcyBub3QgZXF1YWwgc291cmNlIHRleHQgbGVuZ3RoICgnICsgdGV4dDEubGVuZ3RoICsgJykuJyk7XHJcbiAgfVxyXG4gIHJldHVybiBkaWZmcztcclxufTtcclxuXHJcblxyXG4vLyAgTUFUQ0ggRlVOQ1RJT05TXHJcblxyXG5cclxuLyoqXHJcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gc2VhcmNoIGZvci5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cclxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfbWFpbiA9IGZ1bmN0aW9uKHRleHQsIHBhdHRlcm4sIGxvYykge1xyXG4gIC8vIENoZWNrIGZvciBudWxsIGlucHV0cy5cclxuICBpZiAodGV4dCA9PSBudWxsIHx8IHBhdHRlcm4gPT0gbnVsbCB8fCBsb2MgPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGlucHV0LiAobWF0Y2hfbWFpbiknKTtcclxuICB9XHJcblxyXG4gIGxvYyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvYywgdGV4dC5sZW5ndGgpKTtcclxuICBpZiAodGV4dCA9PSBwYXR0ZXJuKSB7XHJcbiAgICAvLyBTaG9ydGN1dCAocG90ZW50aWFsbHkgbm90IGd1YXJhbnRlZWQgYnkgdGhlIGFsZ29yaXRobSlcclxuICAgIHJldHVybiAwO1xyXG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XHJcbiAgICAvLyBOb3RoaW5nIHRvIG1hdGNoLlxyXG4gICAgcmV0dXJuIC0xO1xyXG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT0gcGF0dGVybikge1xyXG4gICAgLy8gUGVyZmVjdCBtYXRjaCBhdCB0aGUgcGVyZmVjdCBzcG90ISAgKEluY2x1ZGVzIGNhc2Ugb2YgbnVsbCBwYXR0ZXJuKVxyXG4gICAgcmV0dXJuIGxvYztcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gRG8gYSBmdXp6eSBjb21wYXJlLlxyXG4gICAgcmV0dXJuIHRoaXMubWF0Y2hfYml0YXBfKHRleHQsIHBhdHRlcm4sIGxvYyk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NhdGUgdGhlIGJlc3QgaW5zdGFuY2Ugb2YgJ3BhdHRlcm4nIGluICd0ZXh0JyBuZWFyICdsb2MnIHVzaW5nIHRoZVxyXG4gKiBCaXRhcCBhbGdvcml0aG0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIHNlYXJjaC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gc2VhcmNoIGZvci5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBUaGUgbG9jYXRpb24gdG8gc2VhcmNoIGFyb3VuZC5cclxuICogQHJldHVybiB7bnVtYmVyfSBCZXN0IG1hdGNoIGluZGV4IG9yIC0xLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYml0YXBfID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XHJcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdHRlcm4gdG9vIGxvbmcgZm9yIHRoaXMgYnJvd3Nlci4nKTtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0LlxyXG4gIHZhciBzID0gdGhpcy5tYXRjaF9hbHBoYWJldF8ocGF0dGVybik7XHJcblxyXG4gIHZhciBkbXAgPSB0aGlzOyAgLy8gJ3RoaXMnIGJlY29tZXMgJ3dpbmRvdycgaW4gYSBjbG9zdXJlLlxyXG5cclxuICAvKipcclxuICAgKiBDb21wdXRlIGFuZCByZXR1cm4gdGhlIHNjb3JlIGZvciBhIG1hdGNoIHdpdGggZSBlcnJvcnMgYW5kIHggbG9jYXRpb24uXHJcbiAgICogQWNjZXNzZXMgbG9jIGFuZCBwYXR0ZXJuIHRocm91Z2ggYmVpbmcgYSBjbG9zdXJlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlIE51bWJlciBvZiBlcnJvcnMgaW4gbWF0Y2guXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTG9jYXRpb24gb2YgbWF0Y2guXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBPdmVyYWxsIHNjb3JlIGZvciBtYXRjaCAoMC4wID0gZ29vZCwgMS4wID0gYmFkKS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1hdGNoX2JpdGFwU2NvcmVfKGUsIHgpIHtcclxuICAgIHZhciBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aDtcclxuICAgIHZhciBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcclxuICAgIGlmICghZG1wLk1hdGNoX0Rpc3RhbmNlKSB7XHJcbiAgICAgIC8vIERvZGdlIGRpdmlkZSBieSB6ZXJvIGVycm9yLlxyXG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWNjdXJhY3kgKyAocHJveGltaXR5IC8gZG1wLk1hdGNoX0Rpc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXHJcbiAgdmFyIHNjb3JlX3RocmVzaG9sZCA9IHRoaXMuTWF0Y2hfVGhyZXNob2xkO1xyXG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcclxuICB2YXIgYmVzdF9sb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcclxuICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcclxuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmVfKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcclxuICAgIC8vIFdoYXQgYWJvdXQgaW4gdGhlIG90aGVyIGRpcmVjdGlvbj8gKHNwZWVkdXApXHJcbiAgICBiZXN0X2xvYyA9IHRleHQubGFzdEluZGV4T2YocGF0dGVybiwgbG9jICsgcGF0dGVybi5sZW5ndGgpO1xyXG4gICAgaWYgKGJlc3RfbG9jICE9IC0xKSB7XHJcbiAgICAgIHNjb3JlX3RocmVzaG9sZCA9XHJcbiAgICAgICAgICBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlXygwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJbml0aWFsaXNlIHRoZSBiaXQgYXJyYXlzLlxyXG4gIHZhciBtYXRjaG1hc2sgPSAxIDw8IChwYXR0ZXJuLmxlbmd0aCAtIDEpO1xyXG4gIGJlc3RfbG9jID0gLTE7XHJcblxyXG4gIHZhciBiaW5fbWluLCBiaW5fbWlkO1xyXG4gIHZhciBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcclxuICB2YXIgbGFzdF9yZDtcclxuICBmb3IgKHZhciBkID0gMDsgZCA8IHBhdHRlcm4ubGVuZ3RoOyBkKyspIHtcclxuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxyXG4gICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tICdsb2MnIHdlIGNhbiBzdHJheSBhdCB0aGlzXHJcbiAgICAvLyBlcnJvciBsZXZlbC5cclxuICAgIGJpbl9taW4gPSAwO1xyXG4gICAgYmluX21pZCA9IGJpbl9tYXg7XHJcbiAgICB3aGlsZSAoYmluX21pbiA8IGJpbl9taWQpIHtcclxuICAgICAgaWYgKG1hdGNoX2JpdGFwU2NvcmVfKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZCkge1xyXG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xyXG4gICAgICB9XHJcbiAgICAgIGJpbl9taWQgPSBNYXRoLmZsb29yKChiaW5fbWF4IC0gYmluX21pbikgLyAyICsgYmluX21pbik7XHJcbiAgICB9XHJcbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cclxuICAgIGJpbl9tYXggPSBiaW5fbWlkO1xyXG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xyXG4gICAgdmFyIGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbl9taWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoO1xyXG5cclxuICAgIHZhciByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xyXG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XHJcbiAgICBmb3IgKHZhciBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcclxuICAgICAgLy8gVGhlIGFscGhhYmV0IChzKSBpcyBhIHNwYXJzZSBoYXNoLCBzbyB0aGUgZm9sbG93aW5nIGxpbmUgZ2VuZXJhdGVzXHJcbiAgICAgIC8vIHdhcm5pbmdzLlxyXG4gICAgICB2YXIgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xyXG4gICAgICBpZiAoZCA9PT0gMCkgeyAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2guXHJcbiAgICAgICAgcmRbal0gPSAoKHJkW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xyXG4gICAgICB9IGVsc2UgeyAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoLlxyXG4gICAgICAgIHJkW2pdID0gKCgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2gpIHxcclxuICAgICAgICAgICAgICAgICgoKGxhc3RfcmRbaiArIDFdIHwgbGFzdF9yZFtqXSkgPDwgMSkgfCAxKSB8XHJcbiAgICAgICAgICAgICAgICBsYXN0X3JkW2ogKyAxXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcclxuICAgICAgICB2YXIgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlXyhkLCBqIC0gMSk7XHJcbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxyXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXHJcbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlX3RocmVzaG9sZCkge1xyXG4gICAgICAgICAgLy8gVG9sZCB5b3Ugc28uXHJcbiAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPSBzY29yZTtcclxuICAgICAgICAgIGJlc3RfbG9jID0gaiAtIDE7XHJcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGxvYywgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gbG9jLlxyXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0X2xvYyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBsb2MsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxyXG4gICAgaWYgKG1hdGNoX2JpdGFwU2NvcmVfKGQgKyAxLCBsb2MpID4gc2NvcmVfdGhyZXNob2xkKSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgbGFzdF9yZCA9IHJkO1xyXG4gIH1cclxuICByZXR1cm4gYmVzdF9sb2M7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpc2UgdGhlIGFscGhhYmV0IGZvciB0aGUgQml0YXAgYWxnb3JpdGhtLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgdGV4dCB0byBlbmNvZGUuXHJcbiAqIEByZXR1cm4geyFPYmplY3R9IEhhc2ggb2YgY2hhcmFjdGVyIGxvY2F0aW9ucy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLm1hdGNoX2FscGhhYmV0XyA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcclxuICB2YXIgcyA9IHt9O1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcclxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gaSAtIDEpO1xyXG4gIH1cclxuICByZXR1cm4gcztcclxufTtcclxuXHJcblxyXG4vLyAgUEFUQ0ggRlVOQ1RJT05TXHJcblxyXG5cclxuLyoqXHJcbiAqIEluY3JlYXNlIHRoZSBjb250ZXh0IHVudGlsIGl0IGlzIHVuaXF1ZSxcclxuICogYnV0IGRvbid0IGxldCB0aGUgcGF0dGVybiBleHBhbmQgYmV5b25kIE1hdGNoX01heEJpdHMuXHJcbiAqIEBwYXJhbSB7IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqfSBwYXRjaCBUaGUgcGF0Y2ggdG8gZ3Jvdy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU291cmNlIHRleHQuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRDb250ZXh0XyA9IGZ1bmN0aW9uKHBhdGNoLCB0ZXh0KSB7XHJcbiAgaWYgKHRleHQubGVuZ3RoID09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdmFyIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpO1xyXG4gIHZhciBwYWRkaW5nID0gMDtcclxuXHJcbiAgLy8gTG9vayBmb3IgdGhlIGZpcnN0IGFuZCBsYXN0IG1hdGNoZXMgb2YgcGF0dGVybiBpbiB0ZXh0LiAgSWYgdHdvIGRpZmZlcmVudFxyXG4gIC8vIG1hdGNoZXMgYXJlIGZvdW5kLCBpbmNyZWFzZSB0aGUgcGF0dGVybiBsZW5ndGguXHJcbiAgd2hpbGUgKHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4pICYmXHJcbiAgICAgICAgIHBhdHRlcm4ubGVuZ3RoIDwgdGhpcy5NYXRjaF9NYXhCaXRzIC0gdGhpcy5QYXRjaF9NYXJnaW4gLVxyXG4gICAgICAgICB0aGlzLlBhdGNoX01hcmdpbikge1xyXG4gICAgcGFkZGluZyArPSB0aGlzLlBhdGNoX01hcmdpbjtcclxuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcclxuICB9XHJcbiAgLy8gQWRkIG9uZSBjaHVuayBmb3IgZ29vZCBsdWNrLlxyXG4gIHBhZGRpbmcgKz0gdGhpcy5QYXRjaF9NYXJnaW47XHJcblxyXG4gIC8vIEFkZCB0aGUgcHJlZml4LlxyXG4gIHZhciBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIpO1xyXG4gIGlmIChwcmVmaXgpIHtcclxuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIHByZWZpeF0pO1xyXG4gIH1cclxuICAvLyBBZGQgdGhlIHN1ZmZpeC5cclxuICB2YXIgc3VmZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xyXG4gIGlmIChzdWZmaXgpIHtcclxuICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHN1ZmZpeF0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUm9sbCBiYWNrIHRoZSBzdGFydCBwb2ludHMuXHJcbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XHJcbiAgcGF0Y2guc3RhcnQyIC09IHByZWZpeC5sZW5ndGg7XHJcbiAgLy8gRXh0ZW5kIHRoZSBsZW5ndGhzLlxyXG4gIHBhdGNoLmxlbmd0aDEgKz0gcHJlZml4Lmxlbmd0aCArIHN1ZmZpeC5sZW5ndGg7XHJcbiAgcGF0Y2gubGVuZ3RoMiArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSBhIGxpc3Qgb2YgcGF0Y2hlcyB0byB0dXJuIHRleHQxIGludG8gdGV4dDIuXHJcbiAqIFVzZSBkaWZmcyBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGNvbXB1dGUgaXQgb3Vyc2VsdmVzLlxyXG4gKiBUaGVyZSBhcmUgZm91ciB3YXlzIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgZGVwZW5kaW5nIG9uIHdoYXQgZGF0YSBpc1xyXG4gKiBhdmFpbGFibGUgdG8gdGhlIGNhbGxlcjpcclxuICogTWV0aG9kIDE6XHJcbiAqIGEgPSB0ZXh0MSwgYiA9IHRleHQyXHJcbiAqIE1ldGhvZCAyOlxyXG4gKiBhID0gZGlmZnNcclxuICogTWV0aG9kIDMgKG9wdGltYWwpOlxyXG4gKiBhID0gdGV4dDEsIGIgPSBkaWZmc1xyXG4gKiBNZXRob2QgNCAoZGVwcmVjYXRlZCwgdXNlIG1ldGhvZCAzKTpcclxuICogYSA9IHRleHQxLCBiID0gdGV4dDIsIGMgPSBkaWZmc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBhIHRleHQxIChtZXRob2RzIDEsMyw0KSBvclxyXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAyKS5cclxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gb3B0X2IgdGV4dDIgKG1ldGhvZHMgMSw0KSBvclxyXG4gKiBBcnJheSBvZiBkaWZmIHR1cGxlcyBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCAzKSBvciB1bmRlZmluZWQgKG1ldGhvZCAyKS5cclxuICogQHBhcmFtIHtzdHJpbmd8IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gb3B0X2MgQXJyYXkgb2YgZGlmZiB0dXBsZXNcclxuICogZm9yIHRleHQxIHRvIHRleHQyIChtZXRob2QgNCkgb3IgdW5kZWZpbmVkIChtZXRob2RzIDEsMiwzKS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfbWFrZSA9IGZ1bmN0aW9uKGEsIG9wdF9iLCBvcHRfYykge1xyXG4gIHZhciB0ZXh0MSwgZGlmZnM7XHJcbiAgaWYgKHR5cGVvZiBhID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRfYiA9PSAnc3RyaW5nJyAmJlxyXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIE1ldGhvZCAxOiB0ZXh0MSwgdGV4dDJcclxuICAgIC8vIENvbXB1dGUgZGlmZnMgZnJvbSB0ZXh0MSBhbmQgdGV4dDIuXHJcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcclxuICAgIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhvcHRfYiksIHRydWUpO1xyXG4gICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpYyhkaWZmcyk7XHJcbiAgICAgIHRoaXMuZGlmZl9jbGVhbnVwRWZmaWNpZW5jeShkaWZmcyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChhICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRfYiA9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICB0eXBlb2Ygb3B0X2MgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIC8vIE1ldGhvZCAyOiBkaWZmc1xyXG4gICAgLy8gQ29tcHV0ZSB0ZXh0MSBmcm9tIGRpZmZzLlxyXG4gICAgZGlmZnMgPSAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovKGEpO1xyXG4gICAgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEoZGlmZnMpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgb3B0X2IgJiYgdHlwZW9mIG9wdF9iID09ICdvYmplY3QnICYmXHJcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gTWV0aG9kIDM6IHRleHQxLCBkaWZmc1xyXG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8oYSk7XHJcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2IpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXHJcbiAgICAgIG9wdF9jICYmIHR5cGVvZiBvcHRfYyA9PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gTWV0aG9kIDQ6IHRleHQxLCB0ZXh0MiwgZGlmZnNcclxuICAgIC8vIHRleHQyIGlzIG5vdCB1c2VkLlxyXG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi8oYSk7XHJcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8ob3B0X2MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS4nKTtcclxuICB9XHJcblxyXG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBbXTsgIC8vIEdldCByaWQgb2YgdGhlIG51bGwgY2FzZS5cclxuICB9XHJcbiAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICB2YXIgcGF0Y2hEaWZmTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cclxuICB2YXIgY2hhcl9jb3VudDEgPSAwOyAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW50byB0aGUgdGV4dDEgc3RyaW5nLlxyXG4gIHZhciBjaGFyX2NvdW50MiA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MiBzdHJpbmcuXHJcbiAgLy8gU3RhcnQgd2l0aCB0ZXh0MSAocHJlcGF0Y2hfdGV4dCkgYW5kIGFwcGx5IHRoZSBkaWZmcyB1bnRpbCB3ZSBhcnJpdmUgYXRcclxuICAvLyB0ZXh0MiAocG9zdHBhdGNoX3RleHQpLiAgV2UgcmVjcmVhdGUgdGhlIHBhdGNoZXMgb25lIGJ5IG9uZSB0byBkZXRlcm1pbmVcclxuICAvLyBjb250ZXh0IGluZm8uXHJcbiAgdmFyIHByZXBhdGNoX3RleHQgPSB0ZXh0MTtcclxuICB2YXIgcG9zdHBhdGNoX3RleHQgPSB0ZXh0MTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB2YXIgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XHJcbiAgICB2YXIgZGlmZl90ZXh0ID0gZGlmZnNbeF1bMV07XHJcblxyXG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgIC8vIEEgbmV3IHBhdGNoIHN0YXJ0cyBoZXJlLlxyXG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcclxuICAgICAgcGF0Y2guc3RhcnQyID0gY2hhcl9jb3VudDI7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoIChkaWZmX3R5cGUpIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcclxuICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICsgZGlmZl90ZXh0ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50Mik7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xyXG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZfdGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgaWYgKGRpZmZfdGV4dC5sZW5ndGggPD0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luICYmXHJcbiAgICAgICAgICAgIHBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmcy5sZW5ndGggIT0geCArIDEpIHtcclxuICAgICAgICAgIC8vIFNtYWxsIGVxdWFsaXR5IGluc2lkZSBhIHBhdGNoLlxyXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XHJcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3RleHQubGVuZ3RoID49IDIgKiB0aGlzLlBhdGNoX01hcmdpbikge1xyXG4gICAgICAgICAgLy8gVGltZSBmb3IgYSBuZXcgcGF0Y2guXHJcbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dF8ocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xyXG4gICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gICAgICAgICAgICBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAvLyBVbmxpa2UgVW5pZGlmZiwgb3VyIHBhdGNoIGxpc3RzIGhhdmUgYSByb2xsaW5nIGNvbnRleHQuXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL1VuaWRpZmZcclxuICAgICAgICAgICAgLy8gVXBkYXRlIHByZXBhdGNoIHRleHQgJiBwb3MgdG8gcmVmbGVjdCB0aGUgYXBwbGljYXRpb24gb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIGp1c3QgY29tcGxldGVkIHBhdGNoLlxyXG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XHJcbiAgICAgICAgICAgIGNoYXJfY291bnQxID0gY2hhcl9jb3VudDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBjaGFyYWN0ZXIgY291bnQuXHJcbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9ERUxFVEUpIHtcclxuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgIH1cclxuICB9XHJcbiAgLy8gUGljayB1cCB0aGUgbGVmdG92ZXIgcGF0Y2ggaWYgbm90IGVtcHR5LlxyXG4gIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcclxuICAgIHRoaXMucGF0Y2hfYWRkQ29udGV4dF8ocGF0Y2gsIHByZXBhdGNoX3RleHQpO1xyXG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBwYXRjaGVzO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBwYXRjaGVzLCByZXR1cm4gYW5vdGhlciBhcnJheSB0aGF0IGlzIGlkZW50aWNhbC5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZGVlcENvcHkgPSBmdW5jdGlvbihwYXRjaGVzKSB7XHJcbiAgLy8gTWFraW5nIGRlZXAgY29waWVzIGlzIGhhcmQgaW4gSmF2YVNjcmlwdC5cclxuICB2YXIgcGF0Y2hlc0NvcHkgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBwYXRjaCA9IHBhdGNoZXNbeF07XHJcbiAgICB2YXIgcGF0Y2hDb3B5ID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcclxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2guZGlmZnMubGVuZ3RoOyB5KyspIHtcclxuICAgICAgcGF0Y2hDb3B5LmRpZmZzW3ldID0gcGF0Y2guZGlmZnNbeV0uc2xpY2UoKTtcclxuICAgIH1cclxuICAgIHBhdGNoQ29weS5zdGFydDEgPSBwYXRjaC5zdGFydDE7XHJcbiAgICBwYXRjaENvcHkuc3RhcnQyID0gcGF0Y2guc3RhcnQyO1xyXG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xyXG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDIgPSBwYXRjaC5sZW5ndGgyO1xyXG4gICAgcGF0Y2hlc0NvcHlbeF0gPSBwYXRjaENvcHk7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRjaGVzQ29weTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogTWVyZ2UgYSBzZXQgb2YgcGF0Y2hlcyBvbnRvIHRoZSB0ZXh0LiAgUmV0dXJuIGEgcGF0Y2hlZCB0ZXh0LCBhcyB3ZWxsXHJcbiAqIGFzIGEgbGlzdCBvZiB0cnVlL2ZhbHNlIHZhbHVlcyBpbmRpY2F0aW5nIHdoaWNoIHBhdGNoZXMgd2VyZSBhcHBsaWVkLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBPbGQgdGV4dC5cclxuICogQHJldHVybiB7IUFycmF5LjxzdHJpbmd8IUFycmF5Ljxib29sZWFuPj59IFR3byBlbGVtZW50IEFycmF5LCBjb250YWluaW5nIHRoZVxyXG4gKiAgICAgIG5ldyB0ZXh0IGFuZCBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FwcGx5ID0gZnVuY3Rpb24ocGF0Y2hlcywgdGV4dCkge1xyXG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICByZXR1cm4gW3RleHQsIFtdXTtcclxuICB9XHJcblxyXG4gIC8vIERlZXAgY29weSB0aGUgcGF0Y2hlcyBzbyB0aGF0IG5vIGNoYW5nZXMgYXJlIG1hZGUgdG8gb3JpZ2luYWxzLlxyXG4gIHBhdGNoZXMgPSB0aGlzLnBhdGNoX2RlZXBDb3B5KHBhdGNoZXMpO1xyXG5cclxuICB2YXIgbnVsbFBhZGRpbmcgPSB0aGlzLnBhdGNoX2FkZFBhZGRpbmcocGF0Y2hlcyk7XHJcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nO1xyXG5cclxuICB0aGlzLnBhdGNoX3NwbGl0TWF4KHBhdGNoZXMpO1xyXG4gIC8vIGRlbHRhIGtlZXBzIHRyYWNrIG9mIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZXhwZWN0ZWQgYW5kIGFjdHVhbCBsb2NhdGlvblxyXG4gIC8vIG9mIHRoZSBwcmV2aW91cyBwYXRjaC4gIElmIHRoZXJlIGFyZSBwYXRjaGVzIGV4cGVjdGVkIGF0IHBvc2l0aW9ucyAxMCBhbmRcclxuICAvLyAyMCwgYnV0IHRoZSBmaXJzdCBwYXRjaCB3YXMgZm91bmQgYXQgMTIsIGRlbHRhIGlzIDIgYW5kIHRoZSBzZWNvbmQgcGF0Y2hcclxuICAvLyBoYXMgYW4gZWZmZWN0aXZlIGV4cGVjdGVkIHBvc2l0aW9uIG9mIDIyLlxyXG4gIHZhciBkZWx0YSA9IDA7XHJcbiAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBleHBlY3RlZF9sb2MgPSBwYXRjaGVzW3hdLnN0YXJ0MiArIGRlbHRhO1xyXG4gICAgdmFyIHRleHQxID0gdGhpcy5kaWZmX3RleHQxKHBhdGNoZXNbeF0uZGlmZnMpO1xyXG4gICAgdmFyIHN0YXJ0X2xvYztcclxuICAgIHZhciBlbmRfbG9jID0gLTE7XHJcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzKSB7XHJcbiAgICAgIC8vIHBhdGNoX3NwbGl0TWF4IHdpbGwgb25seSBwcm92aWRlIGFuIG92ZXJzaXplZCBwYXR0ZXJuIGluIHRoZSBjYXNlIG9mXHJcbiAgICAgIC8vIGEgbW9uc3RlciBkZWxldGUuXHJcbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcoMCwgdGhpcy5NYXRjaF9NYXhCaXRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkX2xvYyk7XHJcbiAgICAgIGlmIChzdGFydF9sb2MgIT0gLTEpIHtcclxuICAgICAgICBlbmRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsXHJcbiAgICAgICAgICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpLFxyXG4gICAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSB0aGlzLk1hdGNoX01heEJpdHMpO1xyXG4gICAgICAgIGlmIChlbmRfbG9jID09IC0xIHx8IHN0YXJ0X2xvYyA+PSBlbmRfbG9jKSB7XHJcbiAgICAgICAgICAvLyBDYW4ndCBmaW5kIHZhbGlkIHRyYWlsaW5nIGNvbnRleHQuICBEcm9wIHRoaXMgcGF0Y2guXHJcbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0X2xvYyA9IHRoaXMubWF0Y2hfbWFpbih0ZXh0LCB0ZXh0MSwgZXhwZWN0ZWRfbG9jKTtcclxuICAgIH1cclxuICAgIGlmIChzdGFydF9sb2MgPT0gLTEpIHtcclxuICAgICAgLy8gTm8gbWF0Y2ggZm91bmQuICA6KFxyXG4gICAgICByZXN1bHRzW3hdID0gZmFsc2U7XHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBkZWx0YSBmb3IgdGhpcyBmYWlsZWQgcGF0Y2ggZnJvbSBzdWJzZXF1ZW50IHBhdGNoZXMuXHJcbiAgICAgIGRlbHRhIC09IHBhdGNoZXNbeF0ubGVuZ3RoMiAtIHBhdGNoZXNbeF0ubGVuZ3RoMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEZvdW5kIGEgbWF0Y2guICA6KVxyXG4gICAgICByZXN1bHRzW3hdID0gdHJ1ZTtcclxuICAgICAgZGVsdGEgPSBzdGFydF9sb2MgLSBleHBlY3RlZF9sb2M7XHJcbiAgICAgIHZhciB0ZXh0MjtcclxuICAgICAgaWYgKGVuZF9sb2MgPT0gLTEpIHtcclxuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgZW5kX2xvYyArIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRleHQxID09IHRleHQyKSB7XHJcbiAgICAgICAgLy8gUGVyZmVjdCBtYXRjaCwganVzdCBzaG92ZSB0aGUgcmVwbGFjZW1lbnQgdGV4dCBpbi5cclxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jKSArXHJcbiAgICAgICAgICAgICAgIHRoaXMuZGlmZl90ZXh0MihwYXRjaGVzW3hdLmRpZmZzKSArXHJcbiAgICAgICAgICAgICAgIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSW1wZXJmZWN0IG1hdGNoLiAgUnVuIGEgZGlmZiB0byBnZXQgYSBmcmFtZXdvcmsgb2YgZXF1aXZhbGVudFxyXG4gICAgICAgIC8vIGluZGljZXMuXHJcbiAgICAgICAgdmFyIGRpZmZzID0gdGhpcy5kaWZmX21haW4odGV4dDEsIHRleHQyLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHRoaXMuTWF0Y2hfTWF4Qml0cyAmJlxyXG4gICAgICAgICAgICB0aGlzLmRpZmZfbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID5cclxuICAgICAgICAgICAgdGhpcy5QYXRjaF9EZWxldGVUaHJlc2hvbGQpIHtcclxuICAgICAgICAgIC8vIFRoZSBlbmQgcG9pbnRzIG1hdGNoLCBidXQgdGhlIGNvbnRlbnQgaXMgdW5hY2NlcHRhYmx5IGJhZC5cclxuICAgICAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcclxuICAgICAgICAgIHZhciBpbmRleDEgPSAwO1xyXG4gICAgICAgICAgdmFyIGluZGV4MjtcclxuICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgcGF0Y2hlc1t4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgbW9kID0gcGF0Y2hlc1t4XS5kaWZmc1t5XTtcclxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuZGlmZl94SW5kZXgoZGlmZnMsIGluZGV4MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1vZFswXSA9PT0gRElGRl9JTlNFUlQpIHsgIC8vIEluc2VydGlvblxyXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICtcclxuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RbMF0gPT09IERJRkZfREVMRVRFKSB7ICAvLyBEZWxldGlvblxyXG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICtcclxuICAgICAgICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGhpcy5kaWZmX3hJbmRleChkaWZmcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4MSArIG1vZFsxXS5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0RFTEVURSkge1xyXG4gICAgICAgICAgICAgIGluZGV4MSArPSBtb2RbMV0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIFN0cmlwIHRoZSBwYWRkaW5nIG9mZi5cclxuICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCk7XHJcbiAgcmV0dXJuIFt0ZXh0LCByZXN1bHRzXTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQWRkIHNvbWUgcGFkZGluZyBvbiB0ZXh0IHN0YXJ0IGFuZCBlbmQgc28gdGhhdCBlZGdlcyBjYW4gbWF0Y2ggc29tZXRoaW5nLlxyXG4gKiBJbnRlbmRlZCB0byBiZSBjYWxsZWQgb25seSBmcm9tIHdpdGhpbiBwYXRjaF9hcHBseS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcGFkZGluZyBzdHJpbmcgYWRkZWQgdG8gZWFjaCBzaWRlLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYWRkUGFkZGluZyA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcclxuICB2YXIgcGFkZGluZ0xlbmd0aCA9IHRoaXMuUGF0Y2hfTWFyZ2luO1xyXG4gIHZhciBudWxsUGFkZGluZyA9ICcnO1xyXG4gIGZvciAodmFyIHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykge1xyXG4gICAgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcclxuICB9XHJcblxyXG4gIC8vIEJ1bXAgYWxsIHRoZSBwYXRjaGVzIGZvcndhcmQuXHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBzb21lIHBhZGRpbmcgb24gc3RhcnQgb2YgZmlyc3QgZGlmZi5cclxuICB2YXIgcGF0Y2ggPSBwYXRjaGVzWzBdO1xyXG4gIHZhciBkaWZmcyA9IHBhdGNoLmRpZmZzO1xyXG4gIGlmIChkaWZmcy5sZW5ndGggPT0gMCB8fCBkaWZmc1swXVswXSAhPSBESUZGX0VRVUFMKSB7XHJcbiAgICAvLyBBZGQgbnVsbFBhZGRpbmcgZXF1YWxpdHkuXHJcbiAgICBkaWZmcy51bnNoaWZ0KFtESUZGX0VRVUFMLCBudWxsUGFkZGluZ10pO1xyXG4gICAgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cclxuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoOyAgLy8gU2hvdWxkIGJlIDAuXHJcbiAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XHJcbiAgICAvLyBHcm93IGZpcnN0IGVxdWFsaXR5LlxyXG4gICAgdmFyIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcclxuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcclxuICAgIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XHJcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBlbmQgb2YgbGFzdCBkaWZmLlxyXG4gIHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdO1xyXG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XHJcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzBdICE9IERJRkZfRVFVQUwpIHtcclxuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cclxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XHJcbiAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XHJcbiAgICAvLyBHcm93IGxhc3QgZXF1YWxpdHkuXHJcbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xyXG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XHJcbiAgICBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBMb29rIHRocm91Z2ggdGhlIHBhdGNoZXMgYW5kIGJyZWFrIHVwIGFueSB3aGljaCBhcmUgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW1cclxuICogbGltaXQgb2YgdGhlIG1hdGNoIGFsZ29yaXRobS5cclxuICogSW50ZW5kZWQgdG8gYmUgY2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gcGF0Y2hfYXBwbHkuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9zcGxpdE1heCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcclxuICB2YXIgcGF0Y2hfc2l6ZSA9IHRoaXMuTWF0Y2hfTWF4Qml0cztcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPD0gcGF0Y2hfc2l6ZSkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XHJcbiAgICAvLyBSZW1vdmUgdGhlIGJpZyBvbGQgcGF0Y2guXHJcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xyXG4gICAgdmFyIHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MTtcclxuICAgIHZhciBzdGFydDIgPSBiaWdwYXRjaC5zdGFydDI7XHJcbiAgICB2YXIgcHJlY29udGV4dCA9ICcnO1xyXG4gICAgd2hpbGUgKGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAvLyBDcmVhdGUgb25lIG9mIHNldmVyYWwgc21hbGxlciBwYXRjaGVzLlxyXG4gICAgICB2YXIgcGF0Y2ggPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcclxuICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xyXG4gICAgICBpZiAocHJlY29udGV4dCAhPT0gJycpIHtcclxuICAgICAgICBwYXRjaC5sZW5ndGgxID0gcGF0Y2gubGVuZ3RoMiA9IHByZWNvbnRleHQubGVuZ3RoO1xyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHByZWNvbnRleHRdKTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmXHJcbiAgICAgICAgICAgICBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hfc2l6ZSAtIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XHJcbiAgICAgICAgdmFyIGRpZmZfdHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xyXG4gICAgICAgIHZhciBkaWZmX3RleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXTtcclxuICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICAgICAgLy8gSW5zZXJ0aW9ucyBhcmUgaGFybWxlc3MuXHJcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XHJcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90eXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgcGF0Y2guZGlmZnNbMF1bMF0gPT0gRElGRl9FUVVBTCAmJlxyXG4gICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiBwYXRjaF9zaXplKSB7XHJcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGFyZ2UgZGVsZXRpb24uICBMZXQgaXQgcGFzcyBpbiBvbmUgY2h1bmsuXHJcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtkaWZmX3R5cGUsIGRpZmZfdGV4dF0pO1xyXG4gICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRGVsZXRpb24gb3IgZXF1YWxpdHkuICBPbmx5IHRha2UgYXMgbXVjaCBhcyB3ZSBjYW4gc3RvbWFjaC5cclxuICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCxcclxuICAgICAgICAgICAgICBwYXRjaF9zaXplIC0gcGF0Y2gubGVuZ3RoMSAtIHRoaXMuUGF0Y2hfTWFyZ2luKTtcclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XHJcbiAgICAgICAgICBpZiAoZGlmZl90ZXh0ID09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XHJcbiAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9XHJcbiAgICAgICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZl90ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIENvbXB1dGUgdGhlIGhlYWQgY29udGV4dCBmb3IgdGhlIG5leHQgcGF0Y2guXHJcbiAgICAgIHByZWNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDIocGF0Y2guZGlmZnMpO1xyXG4gICAgICBwcmVjb250ZXh0ID1cclxuICAgICAgICAgIHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xyXG4gICAgICAvLyBBcHBlbmQgdGhlIGVuZCBjb250ZXh0IGZvciB0aGlzIHBhdGNoLlxyXG4gICAgICB2YXIgcG9zdGNvbnRleHQgPSB0aGlzLmRpZmZfdGV4dDEoYmlncGF0Y2guZGlmZnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIHRoaXMuUGF0Y2hfTWFyZ2luKTtcclxuICAgICAgaWYgKHBvc3Rjb250ZXh0ICE9PSAnJykge1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Y29udGV4dF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoIWVtcHR5KSB7XHJcbiAgICAgICAgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRha2UgYSBsaXN0IG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIHRleHR1YWwgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGV4dCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfdG9UZXh0ID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIHZhciB0ZXh0ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICB0ZXh0W3hdID0gcGF0Y2hlc1t4XTtcclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiBwYXRjaGVzIGFuZCByZXR1cm4gYSBsaXN0IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0bGluZSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHRocm93cyB7IUVycm9yfSBJZiBpbnZhbGlkIGlucHV0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfZnJvbVRleHQgPSBmdW5jdGlvbih0ZXh0bGluZSkge1xyXG4gIHZhciBwYXRjaGVzID0gW107XHJcbiAgaWYgKCF0ZXh0bGluZSkge1xyXG4gICAgcmV0dXJuIHBhdGNoZXM7XHJcbiAgfVxyXG4gIHZhciB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoJ1xcbicpO1xyXG4gIHZhciB0ZXh0UG9pbnRlciA9IDA7XHJcbiAgdmFyIHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcclxuICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgdmFyIG0gPSB0ZXh0W3RleHRQb2ludGVyXS5tYXRjaChwYXRjaEhlYWRlcik7XHJcbiAgICBpZiAoIW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhdGNoIHN0cmluZzogJyArIHRleHRbdGV4dFBvaW50ZXJdKTtcclxuICAgIH1cclxuICAgIHZhciBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcclxuICAgIHBhdGNoLnN0YXJ0MSA9IHBhcnNlSW50KG1bMV0sIDEwKTtcclxuICAgIGlmIChtWzJdID09PSAnJykge1xyXG4gICAgICBwYXRjaC5zdGFydDEtLTtcclxuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDE7XHJcbiAgICB9IGVsc2UgaWYgKG1bMl0gPT0gJzAnKSB7XHJcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGF0Y2guc3RhcnQxLS07XHJcbiAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXJzZUludChtWzJdLCAxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGF0Y2guc3RhcnQyID0gcGFyc2VJbnQobVszXSwgMTApO1xyXG4gICAgaWYgKG1bNF0gPT09ICcnKSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcclxuICAgIH0gZWxzZSBpZiAobVs0XSA9PSAnMCcpIHtcclxuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXRjaC5zdGFydDItLTtcclxuICAgICAgcGF0Y2gubGVuZ3RoMiA9IHBhcnNlSW50KG1bNF0sIDEwKTtcclxuICAgIH1cclxuICAgIHRleHRQb2ludGVyKys7XHJcblxyXG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgdmFyIHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcclxuICAgICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgICAvLyBNYWxmb3JtZWQgVVJJIHNlcXVlbmNlLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICcgKyBsaW5lKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc2lnbiA9PSAnLScpIHtcclxuICAgICAgICAvLyBEZWxldGlvbi5cclxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT0gJysnKSB7XHJcbiAgICAgICAgLy8gSW5zZXJ0aW9uLlxyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnICcpIHtcclxuICAgICAgICAvLyBNaW5vciBlcXVhbGl0eS5cclxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBsaW5lXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnQCcpIHtcclxuICAgICAgICAvLyBTdGFydCBvZiBuZXh0IHBhdGNoLlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09ICcnKSB7XHJcbiAgICAgICAgLy8gQmxhbmsgbGluZT8gIFdoYXRldmVyLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFdURj9cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggbW9kZSBcIicgKyBzaWduICsgJ1wiIGluOiAnICsgbGluZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGV4dFBvaW50ZXIrKztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHBhdGNoZXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENsYXNzIHJlcHJlc2VudGluZyBvbmUgcGF0Y2ggb3BlcmF0aW9uLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqID0gZnVuY3Rpb24oKSB7XHJcbiAgLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqL1xyXG4gIHRoaXMuZGlmZnMgPSBbXTtcclxuICAvKiogQHR5cGUgez9udW1iZXJ9ICovXHJcbiAgdGhpcy5zdGFydDEgPSBudWxsO1xyXG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cclxuICB0aGlzLnN0YXJ0MiA9IG51bGw7XHJcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgdGhpcy5sZW5ndGgxID0gMDtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICB0aGlzLmxlbmd0aDIgPSAwO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBFbW11bGF0ZSBHTlUgZGlmZidzIGZvcm1hdC5cclxuICogSGVhZGVyOiBAQCAtMzgyLDggKzQ4MSw5IEBAXHJcbiAqIEluZGljaWVzIGFyZSBwcmludGVkIGFzIDEtYmFzZWQsIG5vdCAwLWJhc2VkLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBHTlUgZGlmZiBzdHJpbmcuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iai5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgY29vcmRzMSwgY29vcmRzMjtcclxuICBpZiAodGhpcy5sZW5ndGgxID09PSAwKSB7XHJcbiAgICBjb29yZHMxID0gdGhpcy5zdGFydDEgKyAnLDAnO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgxID09IDEpIHtcclxuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvb3JkczEgPSAodGhpcy5zdGFydDEgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMTtcclxuICB9XHJcbiAgaWYgKHRoaXMubGVuZ3RoMiA9PT0gMCkge1xyXG4gICAgY29vcmRzMiA9IHRoaXMuc3RhcnQyICsgJywwJztcclxuICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PSAxKSB7XHJcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb29yZHMyID0gKHRoaXMuc3RhcnQyICsgMSkgKyAnLCcgKyB0aGlzLmxlbmd0aDI7XHJcbiAgfVxyXG4gIHZhciB0ZXh0ID0gWydAQCAtJyArIGNvb3JkczEgKyAnICsnICsgY29vcmRzMiArICcgQEBcXG4nXTtcclxuICB2YXIgb3A7XHJcbiAgLy8gRXNjYXBlIHRoZSBib2R5IG9mIHRoZSBwYXRjaCB3aXRoICV4eCBub3RhdGlvbi5cclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIG9wID0gJysnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIG9wID0gJy0nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgb3AgPSAnICc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB0ZXh0W3ggKyAxXSA9IG9wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pICsgJ1xcbic7XHJcbiAgfVxyXG4gIHJldHVybiB0ZXh0LmpvaW4oJycpLnJlcGxhY2UoLyUyMC9nLCAnICcpO1xyXG59O1xyXG5cclxuXHJcbi8vIFRoZSBmb2xsb3dpbmcgZXhwb3J0IGNvZGUgd2FzIGFkZGVkIGJ5IEBGb3JiZXNMaW5kZXNheVxyXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZfbWF0Y2hfcGF0Y2g7XHJcbm1vZHVsZS5leHBvcnRzWydkaWZmX21hdGNoX3BhdGNoJ10gPSBkaWZmX21hdGNoX3BhdGNoO1xyXG5tb2R1bGUuZXhwb3J0c1snRElGRl9ERUxFVEUnXSA9IERJRkZfREVMRVRFO1xyXG5tb2R1bGUuZXhwb3J0c1snRElGRl9JTlNFUlQnXSA9IERJRkZfSU5TRVJUO1xyXG5tb2R1bGUuZXhwb3J0c1snRElGRl9FUVVBTCddID0gRElGRl9FUVVBTDtcclxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2RpZmYtbWF0Y2gtcGF0Y2hcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpXG5cbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKVxuXG5mdW5jdGlvbiBDdXJ2ZSAocCwgYSwgYiwgR3gsIEd5LCBuLCBoKSB7XG4gIHRoaXMucCA9IHBcbiAgdGhpcy5hID0gYVxuICB0aGlzLmIgPSBiXG4gIHRoaXMuRyA9IFBvaW50LmZyb21BZmZpbmUodGhpcywgR3gsIEd5KVxuICB0aGlzLm4gPSBuXG4gIHRoaXMuaCA9IGhcblxuICB0aGlzLmluZmluaXR5ID0gbmV3IFBvaW50KHRoaXMsIG51bGwsIG51bGwsIEJpZ0ludGVnZXIuWkVSTylcblxuICAvLyByZXN1bHQgY2FjaGluZ1xuICB0aGlzLnBPdmVyRm91ciA9IHAuYWRkKEJpZ0ludGVnZXIuT05FKS5zaGlmdFJpZ2h0KDIpXG59XG5cbkN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gKGlzT2RkLCB4KSB7XG4gIHZhciBhbHBoYSA9IHgucG93KDMpLmFkZCh0aGlzLmEubXVsdGlwbHkoeCkpLmFkZCh0aGlzLmIpLm1vZCh0aGlzLnApXG4gIHZhciBiZXRhID0gYWxwaGEubW9kUG93KHRoaXMucE92ZXJGb3VyLCB0aGlzLnApIC8vIFhYWDogbm90IGNvbXBhdGlibGUgd2l0aCBhbGwgY3VydmVzXG5cbiAgdmFyIHkgPSBiZXRhXG4gIGlmIChiZXRhLmlzRXZlbigpIF4gIWlzT2RkKSB7XG4gICAgeSA9IHRoaXMucC5zdWJ0cmFjdCh5KSAvLyAteSAlIHBcbiAgfVxuXG4gIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHRoaXMsIHgsIHkpXG59XG5cbkN1cnZlLnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gKFEpIHtcbiAgaWYgKFEgPT09IHRoaXMuaW5maW5pdHkpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIFEuei5zaWdudW0oKSA9PT0gMCAmJiBRLnkuc2lnbnVtKCkgIT09IDBcbn1cblxuQ3VydmUucHJvdG90eXBlLmlzT25DdXJ2ZSA9IGZ1bmN0aW9uIChRKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoUSkpIHJldHVybiB0cnVlXG5cbiAgdmFyIHggPSBRLmFmZmluZVhcbiAgdmFyIHkgPSBRLmFmZmluZVlcbiAgdmFyIGEgPSB0aGlzLmFcbiAgdmFyIGIgPSB0aGlzLmJcbiAgdmFyIHAgPSB0aGlzLnBcblxuICAvLyBDaGVjayB0aGF0IHhRIGFuZCB5USBhcmUgaW50ZWdlcnMgaW4gdGhlIGludGVydmFsIFswLCBwIC0gMV1cbiAgaWYgKHguc2lnbnVtKCkgPCAwIHx8IHguY29tcGFyZVRvKHApID49IDApIHJldHVybiBmYWxzZVxuICBpZiAoeS5zaWdudW0oKSA8IDAgfHwgeS5jb21wYXJlVG8ocCkgPj0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgLy8gYW5kIGNoZWNrIHRoYXQgeV4yID0geF4zICsgYXggKyBiIChtb2QgcClcbiAgdmFyIGxocyA9IHkuc3F1YXJlKCkubW9kKHApXG4gIHZhciByaHMgPSB4LnBvdygzKS5hZGQoYS5tdWx0aXBseSh4KSkuYWRkKGIpLm1vZChwKVxuICByZXR1cm4gbGhzLmVxdWFscyhyaHMpXG59XG5cbi8qKlxuICogVmFsaWRhdGUgYW4gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKlxuICogU2VlIFNFQyAxLCBzZWN0aW9uIDMuMi4yLjE6IEVsbGlwdGljIEN1cnZlIFB1YmxpYyBLZXkgVmFsaWRhdGlvbiBQcmltaXRpdmVcbiAqL1xuQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKFEpIHtcbiAgLy8gQ2hlY2sgUSAhPSBPXG4gIGFzc2VydCghdGhpcy5pc0luZmluaXR5KFEpLCAnUG9pbnQgaXMgYXQgaW5maW5pdHknKVxuICBhc3NlcnQodGhpcy5pc09uQ3VydmUoUSksICdQb2ludCBpcyBub3Qgb24gdGhlIGN1cnZlJylcblxuICAvLyBDaGVjayBuUSA9IE8gKHdoZXJlIFEgaXMgYSBzY2FsYXIgbXVsdGlwbGUgb2YgRylcbiAgdmFyIG5RID0gUS5tdWx0aXBseSh0aGlzLm4pXG4gIGFzc2VydCh0aGlzLmlzSW5maW5pdHkoblEpLCAnUG9pbnQgaXMgbm90IGEgc2NhbGFyIG11bHRpcGxlIG9mIEcnKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VydmVcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9jdXJ2ZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliXCIpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInNlY3AxMjhyMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmRmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIixcbiAgICBcImFcIjogXCJmZmZmZmZmZGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1wiLFxuICAgIFwiYlwiOiBcImU4NzU3OWMxMTA3OWY0M2RkODI0OTkzYzJjZWU1ZWQzXCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmUwMDAwMDAwMDc1YTMwZDFiOTAzOGExMTVcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCIxNjFmZjc1MjhiODk5YjJkMGMyODYwN2NhNTJjNWI4NlwiLFxuICAgIFwiR3lcIjogXCJjZjVhYzgzOTViYWZlYjEzYzAyZGEyOTJkZGVkN2E4M1wiXG4gIH0sXG4gIFwic2VjcDE2MGsxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZhYzczXCIsXG4gICAgXCJhXCI6IFwiMDBcIixcbiAgICBcImJcIjogXCIwN1wiLFxuICAgIFwiblwiOiBcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFiOGZhMTZkZmFiOWFjYTE2YjZiM1wiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjNiNGMzODJjZTM3YWExOTJhNDAxOWU3NjMwMzZmNGY1ZGQ0ZDdlYmJcIixcbiAgICBcIkd5XCI6IFwiOTM4Y2Y5MzUzMThmZGNlZDZiYzI4Mjg2NTMxNzMzYzNmMDNjNGZlZVwiXG4gIH0sXG4gIFwic2VjcDE2MHIxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmZmZmZmZmXCIsXG4gICAgXCJhXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY3ZmZmZmZmY1wiLFxuICAgIFwiYlwiOiBcIjFjOTdiZWZjNTRiZDdhOGI2NWFjZjg5ZjgxZDRkNGFkYzU2NWZhNDVcIixcbiAgICBcIm5cIjogXCIwMTAwMDAwMDAwMDAwMDAwMDAwMDAxZjRjOGY5MjdhZWQzY2E3NTIyNTdcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCI0YTk2YjU2ODhlZjU3MzI4NDY2NDY5ODk2OGMzOGJiOTEzY2JmYzgyXCIsXG4gICAgXCJHeVwiOiBcIjIzYTYyODU1MzE2ODk0N2Q1OWRjYzkxMjA0MjM1MTM3N2FjNWZiMzJcIlxuICB9LFxuICBcInNlY3AxOTJrMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZlZTM3XCIsXG4gICAgXCJhXCI6IFwiMDBcIixcbiAgICBcImJcIjogXCIwM1wiLFxuICAgIFwiblwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZTI2ZjJmYzE3MGY2OTQ2NmE3NGRlZmQ4ZFwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcImRiNGZmMTBlYzA1N2U5YWUyNmIwN2QwMjgwYjdmNDM0MWRhNWQxYjFlYWUwNmM3ZFwiLFxuICAgIFwiR3lcIjogXCI5YjJmMmY2ZDljNTYyOGE3ODQ0MTYzZDAxNWJlODYzNDQwODJhYTg4ZDk1ZTJmOWRcIlxuICB9LFxuICBcInNlY3AxOTJyMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZmZmZmZmZmZmZmXCIsXG4gICAgXCJhXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZmZmZmZmZmZmZjXCIsXG4gICAgXCJiXCI6IFwiNjQyMTA1MTllNTljODBlNzBmYTdlOWFiNzIyNDMwNDlmZWI4ZGVlY2MxNDZiOWIxXCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmOTlkZWY4MzYxNDZiYzliMWI0ZDIyODMxXCIsXG4gICAgXCJoXCI6IFwiMDFcIixcbiAgICBcIkd4XCI6IFwiMTg4ZGE4MGViMDMwOTBmNjdjYmYyMGViNDNhMTg4MDBmNGZmMGFmZDgyZmYxMDEyXCIsXG4gICAgXCJHeVwiOiBcIjA3MTkyYjk1ZmZjOGRhNzg2MzEwMTFlZDZiMjRjZGQ1NzNmOTc3YTExZTc5NDgxMVwiXG4gIH0sXG4gIFwic2VjcDI1NmsxXCI6IHtcbiAgICBcInBcIjogXCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmXCIsXG4gICAgXCJhXCI6IFwiMDBcIixcbiAgICBcImJcIjogXCIwN1wiLFxuICAgIFwiblwiOiBcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIixcbiAgICBcImhcIjogXCIwMVwiLFxuICAgIFwiR3hcIjogXCI3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4XCIsXG4gICAgXCJHeVwiOiBcIjQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjhcIlxuICB9LFxuICBcInNlY3AyNTZyMVwiOiB7XG4gICAgXCJwXCI6IFwiZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiLFxuICAgIFwiYVwiOiBcImZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNcIixcbiAgICBcImJcIjogXCI1YWM2MzVkOGFhM2E5M2U3YjNlYmJkNTU3Njk4ODZiYzY1MWQwNmIwY2M1M2IwZjYzYmNlM2MzZTI3ZDI2MDRiXCIsXG4gICAgXCJuXCI6IFwiZmZmZmZmZmYwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZiY2U2ZmFhZGE3MTc5ZTg0ZjNiOWNhYzJmYzYzMjU1MVwiLFxuICAgIFwiaFwiOiBcIjAxXCIsXG4gICAgXCJHeFwiOiBcIjZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTZcIixcbiAgICBcIkd5XCI6IFwiNGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNVwiXG4gIH1cbn1cbiIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBQb2ludCA9IHJlcXVpcmUoJy4vcG9pbnQnKVxudmFyIEN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpXG5cbnZhciBnZXRDdXJ2ZUJ5TmFtZSA9IHJlcXVpcmUoJy4vbmFtZXMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ3VydmU6IEN1cnZlLFxuICBQb2ludDogUG9pbnQsXG4gIGdldEN1cnZlQnlOYW1lOiBnZXRDdXJ2ZUJ5TmFtZVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VjdXJ2ZS9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgY3VydmVzID0gcmVxdWlyZSgnLi9jdXJ2ZXMuanNvbicpXG52YXIgQ3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJylcblxuZnVuY3Rpb24gZ2V0Q3VydmVCeU5hbWUgKG5hbWUpIHtcbiAgdmFyIGN1cnZlID0gY3VydmVzW25hbWVdXG4gIGlmICghY3VydmUpIHJldHVybiBudWxsXG5cbiAgdmFyIHAgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5wLCAxNilcbiAgdmFyIGEgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5hLCAxNilcbiAgdmFyIGIgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5iLCAxNilcbiAgdmFyIG4gPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5uLCAxNilcbiAgdmFyIGggPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5oLCAxNilcbiAgdmFyIEd4ID0gbmV3IEJpZ0ludGVnZXIoY3VydmUuR3gsIDE2KVxuICB2YXIgR3kgPSBuZXcgQmlnSW50ZWdlcihjdXJ2ZS5HeSwgMTYpXG5cbiAgcmV0dXJuIG5ldyBDdXJ2ZShwLCBhLCBiLCBHeCwgR3ksIG4sIGgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VydmVCeU5hbWVcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9uYW1lcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKVxuXG52YXIgVEhSRUUgPSBCaWdJbnRlZ2VyLnZhbHVlT2YoMylcblxuZnVuY3Rpb24gUG9pbnQgKGN1cnZlLCB4LCB5LCB6KSB7XG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCh6LCB1bmRlZmluZWQsICdNaXNzaW5nIFogY29vcmRpbmF0ZScpXG5cbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlXG4gIHRoaXMueCA9IHhcbiAgdGhpcy55ID0geVxuICB0aGlzLnogPSB6XG4gIHRoaXMuX3pJbnYgPSBudWxsXG5cbiAgdGhpcy5jb21wcmVzc2VkID0gdHJ1ZVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCAnekludicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3pJbnYgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3pJbnYgPSB0aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3pJbnZcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvaW50LnByb3RvdHlwZSwgJ2FmZmluZVgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLngubXVsdGlwbHkodGhpcy56SW52KS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9pbnQucHJvdG90eXBlLCAnYWZmaW5lWScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueS5tdWx0aXBseSh0aGlzLnpJbnYpLm1vZCh0aGlzLmN1cnZlLnApXG4gIH1cbn0pXG5cblBvaW50LmZyb21BZmZpbmUgPSBmdW5jdGlvbiAoY3VydmUsIHgsIHkpIHtcbiAgcmV0dXJuIG5ldyBQb2ludChjdXJ2ZSwgeCwgeSwgQmlnSW50ZWdlci5PTkUpXG59XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSByZXR1cm4gdHJ1ZVxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gdGhpcy5jdXJ2ZS5pc0luZmluaXR5KG90aGVyKVxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KG90aGVyKSkgcmV0dXJuIHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKVxuXG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB2YXIgdSA9IG90aGVyLnkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgaWYgKHUuc2lnbnVtKCkgIT09IDApIHJldHVybiBmYWxzZVxuXG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2YXIgdiA9IG90aGVyLngubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLngubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIHYuc2lnbnVtKCkgPT09IDBcbn1cblxuUG9pbnQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHkgPSB0aGlzLmN1cnZlLnAuc3VidHJhY3QodGhpcy55KVxuXG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5jdXJ2ZSwgdGhpcy54LCB5LCB0aGlzLnopXG59XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYikge1xuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KHRoaXMpKSByZXR1cm4gYlxuICBpZiAodGhpcy5jdXJ2ZS5pc0luZmluaXR5KGIpKSByZXR1cm4gdGhpc1xuXG4gIHZhciB4MSA9IHRoaXMueFxuICB2YXIgeTEgPSB0aGlzLnlcbiAgdmFyIHgyID0gYi54XG4gIHZhciB5MiA9IGIueVxuXG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB2YXIgdSA9IHkyLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QoeTEubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8gdiA9IFgyICogWjEgLSBYMSAqIFoyXG4gIHZhciB2ID0geDIubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh4MS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5wKVxuXG4gIGlmICh2LnNpZ251bSgpID09PSAwKSB7XG4gICAgaWYgKHUuc2lnbnVtKCkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnR3aWNlKCkgLy8gdGhpcyA9PSBiLCBzbyBkb3VibGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5pbmZpbml0eSAvLyB0aGlzID0gLWIsIHNvIGluZmluaXR5XG4gIH1cblxuICB2YXIgdjIgPSB2LnNxdWFyZSgpXG4gIHZhciB2MyA9IHYyLm11bHRpcGx5KHYpXG4gIHZhciB4MXYyID0geDEubXVsdGlwbHkodjIpXG4gIHZhciB6dTIgPSB1LnNxdWFyZSgpLm11bHRpcGx5KHRoaXMueilcblxuICAvLyB4MyA9IHYgKiAoejIgKiAoejEgKiB1XjIgLSAyICogeDEgKiB2XjIpIC0gdl4zKVxuICB2YXIgeDMgPSB6dTIuc3VidHJhY3QoeDF2Mi5zaGlmdExlZnQoMSkpLm11bHRpcGx5KGIueikuc3VidHJhY3QodjMpLm11bHRpcGx5KHYpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHkzID0gejIgKiAoMyAqIHgxICogdSAqIHZeMiAtIHkxICogdl4zIC0gejEgKiB1XjMpICsgdSAqIHZeM1xuICB2YXIgeTMgPSB4MXYyLm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh1KS5zdWJ0cmFjdCh5MS5tdWx0aXBseSh2MykpLnN1YnRyYWN0KHp1Mi5tdWx0aXBseSh1KSkubXVsdGlwbHkoYi56KS5hZGQodS5tdWx0aXBseSh2MykpLm1vZCh0aGlzLmN1cnZlLnApXG4gIC8vIHozID0gdl4zICogejEgKiB6MlxuICB2YXIgejMgPSB2My5tdWx0aXBseSh0aGlzLnopLm11bHRpcGx5KGIueikubW9kKHRoaXMuY3VydmUucClcblxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMuY3VydmUsIHgzLCB5MywgejMpXG59XG5cblBvaW50LnByb3RvdHlwZS50d2ljZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIHRoaXNcbiAgaWYgKHRoaXMueS5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIHRoaXMuY3VydmUuaW5maW5pdHlcblxuICB2YXIgeDEgPSB0aGlzLnhcbiAgdmFyIHkxID0gdGhpcy55XG5cbiAgdmFyIHkxejEgPSB5MS5tdWx0aXBseSh0aGlzLnopXG4gIHZhciB5MXNxejEgPSB5MXoxLm11bHRpcGx5KHkxKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICB2YXIgYSA9IHRoaXMuY3VydmUuYVxuXG4gIC8vIHcgPSAzICogeDFeMiArIGEgKiB6MV4yXG4gIHZhciB3ID0geDEuc3F1YXJlKCkubXVsdGlwbHkoVEhSRUUpXG5cbiAgaWYgKGEuc2lnbnVtKCkgIT09IDApIHtcbiAgICB3ID0gdy5hZGQodGhpcy56LnNxdWFyZSgpLm11bHRpcGx5KGEpKVxuICB9XG5cbiAgdyA9IHcubW9kKHRoaXMuY3VydmUucClcbiAgLy8geDMgPSAyICogeTEgKiB6MSAqICh3XjIgLSA4ICogeDEgKiB5MV4yICogejEpXG4gIHZhciB4MyA9IHcuc3F1YXJlKCkuc3VidHJhY3QoeDEuc2hpZnRMZWZ0KDMpLm11bHRpcGx5KHkxc3F6MSkpLnNoaWZ0TGVmdCgxKS5tdWx0aXBseSh5MXoxKS5tb2QodGhpcy5jdXJ2ZS5wKVxuICAvLyB5MyA9IDQgKiB5MV4yICogejEgKiAoMyAqIHcgKiB4MSAtIDIgKiB5MV4yICogejEpIC0gd14zXG4gIHZhciB5MyA9IHcubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHgxKS5zdWJ0cmFjdCh5MXNxejEuc2hpZnRMZWZ0KDEpKS5zaGlmdExlZnQoMikubXVsdGlwbHkoeTFzcXoxKS5zdWJ0cmFjdCh3LnBvdygzKSkubW9kKHRoaXMuY3VydmUucClcbiAgLy8gejMgPSA4ICogKHkxICogejEpXjNcbiAgdmFyIHozID0geTF6MS5wb3coMykuc2hpZnRMZWZ0KDMpLm1vZCh0aGlzLmN1cnZlLnApXG5cbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmN1cnZlLCB4MywgeTMsIHozKVxufVxuXG4vLyBTaW1wbGUgTkFGIChOb24tQWRqYWNlbnQgRm9ybSkgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG4vLyBUT0RPOiBtb2R1bGFyaXplIHRoZSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG1cblBvaW50LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChrKSB7XG4gIGlmICh0aGlzLmN1cnZlLmlzSW5maW5pdHkodGhpcykpIHJldHVybiB0aGlzXG4gIGlmIChrLnNpZ251bSgpID09PSAwKSByZXR1cm4gdGhpcy5jdXJ2ZS5pbmZpbml0eVxuXG4gIHZhciBlID0ga1xuICB2YXIgaCA9IGUubXVsdGlwbHkoVEhSRUUpXG5cbiAgdmFyIG5lZyA9IHRoaXMubmVnYXRlKClcbiAgdmFyIFIgPSB0aGlzXG5cbiAgZm9yICh2YXIgaSA9IGguYml0TGVuZ3RoKCkgLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgdmFyIGhCaXQgPSBoLnRlc3RCaXQoaSlcbiAgICB2YXIgZUJpdCA9IGUudGVzdEJpdChpKVxuXG4gICAgUiA9IFIudHdpY2UoKVxuXG4gICAgaWYgKGhCaXQgIT09IGVCaXQpIHtcbiAgICAgIFIgPSBSLmFkZChoQml0ID8gdGhpcyA6IG5lZylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUlxufVxuXG4vLyBDb21wdXRlIHRoaXMqaiArIHgqayAoc2ltdWx0YW5lb3VzIG11bHRpcGxpY2F0aW9uKVxuUG9pbnQucHJvdG90eXBlLm11bHRpcGx5VHdvID0gZnVuY3Rpb24gKGosIHgsIGspIHtcbiAgdmFyIGkgPSBNYXRoLm1heChqLmJpdExlbmd0aCgpLCBrLmJpdExlbmd0aCgpKSAtIDFcbiAgdmFyIFIgPSB0aGlzLmN1cnZlLmluZmluaXR5XG4gIHZhciBib3RoID0gdGhpcy5hZGQoeClcblxuICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgdmFyIGpCaXQgPSBqLnRlc3RCaXQoaSlcbiAgICB2YXIga0JpdCA9IGsudGVzdEJpdChpKVxuXG4gICAgUiA9IFIudHdpY2UoKVxuXG4gICAgaWYgKGpCaXQpIHtcbiAgICAgIGlmIChrQml0KSB7XG4gICAgICAgIFIgPSBSLmFkZChib3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUiA9IFIuYWRkKHRoaXMpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrQml0KSB7XG4gICAgICBSID0gUi5hZGQoeClcbiAgICB9XG4gICAgLS1pXG4gIH1cblxuICByZXR1cm4gUlxufVxuXG5Qb2ludC5wcm90b3R5cGUuZ2V0RW5jb2RlZCA9IGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XG4gIGlmIChjb21wcmVzc2VkID09IG51bGwpIGNvbXByZXNzZWQgPSB0aGlzLmNvbXByZXNzZWRcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuIG5ldyBCdWZmZXIoJzAwJywgJ2hleCcpIC8vIEluZmluaXR5IHBvaW50IGVuY29kZWQgaXMgc2ltcGx5ICcwMCdcblxuICB2YXIgeCA9IHRoaXMuYWZmaW5lWFxuICB2YXIgeSA9IHRoaXMuYWZmaW5lWVxuXG4gIHZhciBidWZmZXJcblxuICAvLyBEZXRlcm1pbmUgc2l6ZSBvZiBxIGluIGJ5dGVzXG4gIHZhciBieXRlTGVuZ3RoID0gTWF0aC5mbG9vcigodGhpcy5jdXJ2ZS5wLmJpdExlbmd0aCgpICsgNykgLyA4KVxuXG4gIC8vIDB4MDIvMHgwMyB8IFhcbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKDEgKyBieXRlTGVuZ3RoKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHkuaXNFdmVuKCkgPyAweDAyIDogMHgwMywgMClcblxuICAvLyAweDA0IHwgWCB8IFlcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKDEgKyBieXRlTGVuZ3RoICsgYnl0ZUxlbmd0aClcbiAgICBidWZmZXIud3JpdGVVSW50OCgweDA0LCAwKVxuXG4gICAgeS50b0J1ZmZlcihieXRlTGVuZ3RoKS5jb3B5KGJ1ZmZlciwgMSArIGJ5dGVMZW5ndGgpXG4gIH1cblxuICB4LnRvQnVmZmVyKGJ5dGVMZW5ndGgpLmNvcHkoYnVmZmVyLCAxKVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuUG9pbnQuZGVjb2RlRnJvbSA9IGZ1bmN0aW9uIChjdXJ2ZSwgYnVmZmVyKSB7XG4gIHZhciB0eXBlID0gYnVmZmVyLnJlYWRVSW50OCgwKVxuICB2YXIgY29tcHJlc3NlZCA9ICh0eXBlICE9PSA0KVxuXG4gIHZhciBieXRlTGVuZ3RoID0gTWF0aC5mbG9vcigoY3VydmUucC5iaXRMZW5ndGgoKSArIDcpIC8gOClcbiAgdmFyIHggPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDEsIDEgKyBieXRlTGVuZ3RoKSlcblxuICB2YXIgUVxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIGFzc2VydC5lcXVhbChidWZmZXIubGVuZ3RoLCBieXRlTGVuZ3RoICsgMSwgJ0ludmFsaWQgc2VxdWVuY2UgbGVuZ3RoJylcbiAgICBhc3NlcnQodHlwZSA9PT0gMHgwMiB8fCB0eXBlID09PSAweDAzLCAnSW52YWxpZCBzZXF1ZW5jZSB0YWcnKVxuXG4gICAgdmFyIGlzT2RkID0gKHR5cGUgPT09IDB4MDMpXG4gICAgUSA9IGN1cnZlLnBvaW50RnJvbVgoaXNPZGQsIHgpXG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsIDEgKyBieXRlTGVuZ3RoICsgYnl0ZUxlbmd0aCwgJ0ludmFsaWQgc2VxdWVuY2UgbGVuZ3RoJylcblxuICAgIHZhciB5ID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZmZlci5zbGljZSgxICsgYnl0ZUxlbmd0aCkpXG4gICAgUSA9IFBvaW50LmZyb21BZmZpbmUoY3VydmUsIHgsIHkpXG4gIH1cblxuICBRLmNvbXByZXNzZWQgPSBjb21wcmVzc2VkXG4gIHJldHVybiBRXG59XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY3VydmUuaXNJbmZpbml0eSh0aGlzKSkgcmV0dXJuICcoSU5GSU5JVFkpJ1xuXG4gIHJldHVybiAnKCcgKyB0aGlzLmFmZmluZVgudG9TdHJpbmcoKSArICcsJyArIHRoaXMuYWZmaW5lWS50b1N0cmluZygpICsgJyknXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnRcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZWN1cnZlL2xpYi9wb2ludC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lY3VydmUvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKFwiLi9zcmMvVHJhbnNhY3Rpb25CdWlsZGVyXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBUcmFuc2FjdGlvbkJ1aWxkZXI6IFRyYW5zYWN0aW9uQnVpbGRlcixcbiAgICBDaGFpbkNvbmZpZzogcmVxdWlyZShcIi4vc3JjL0NoYWluQ29uZmlnXCIpLFxuICAgIENoYWluVHlwZXM6IHJlcXVpcmUoXCIuL3NyYy9DaGFpblR5cGVzXCIpLFxuICAgIE9iamVjdElkOiByZXF1aXJlKFwiLi9zcmMvT2JqZWN0SWRcIiksXG4gICAgTnVtYmVyVXRpbHM6IHJlcXVpcmUoXCIuL3NyYy9OdW1iZXJVdGlsc1wiKSxcbiAgICBUcmFuc2FjdGlvbkhlbHBlcjogcmVxdWlyZShcIi4vc3JjL1RyYW5zYWN0aW9uSGVscGVyXCIpLFxuICAgIENoYWluVmFsaWRhdGlvbjogcmVxdWlyZShcIi4vc3JjL0NoYWluVmFsaWRhdGlvblwiKSxcbiAgICBMb2dpbjogcmVxdWlyZShcIi4vc3JjL0FjY291bnRMb2dpblwiKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW5cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFByaXZhdGVLZXkgPSByZXF1aXJlKFwiLi4vLi4vZWNjL3NyYy9Qcml2YXRlS2V5XCIpO1xudmFyIGtleSA9IHJlcXVpcmUoXCIuLi8uLi9lY2Mvc3JjL0tleVV0aWxzXCIpO1xuXG52YXIgS2V5Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gS2V5Q2FjaGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlDYWNoZSk7XG5cbiAgICAgICAgdGhpcy5fa2V5Q2FjaGVQcml2ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9rZXlDYWNoZVB1YiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbXlLZXlzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhLZXlDYWNoZSwgW3tcbiAgICAgICAga2V5OiBcInNldFByaXZLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByaXZLZXkoa2V5LCBwcml2S2V5KSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlDYWNoZVByaXYuc2V0KGtleSwgcHJpdktleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJoYXNQcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNQcml2S2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNhY2hlUHJpdi5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFByaXZLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByaXZLZXkoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5Q2FjaGVQcml2LmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0UHViS2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQdWJLZXkoa2V5LCBwdWJLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleUNhY2hlUHViLnNldChrZXksIHB1YktleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJoYXNQdWJLZXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1B1YktleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9rZXlDYWNoZVB1Yi5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFB1YktleVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHViS2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNhY2hlUHViLmdldChrZXkpOztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldE15S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNeUtleShrZXksIHByaXZLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuX215S2V5cy5zZXQoa2V5LCBwcml2S2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldE15S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNeUtleShrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9teUtleXMuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gS2V5Q2FjaGU7XG59KCk7XG5cbnZhciBBY2NvdW50TG9naW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3VudExvZ2luKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWNjb3VudExvZ2luKTtcblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMua2V5Q2FjaGUgPSBuZXcgS2V5Q2FjaGUoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWNjb3VudExvZ2luLCBbe1xuICAgICAgICBrZXk6IFwicmVzZXRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHsgbG9nZ2VkSW46IGZhbHNlLCByb2xlczogW1wiYWN0aXZlXCIsIFwib3duZXJcIiwgXCJwb3N0aW5nXCIsIFwibWVtb1wiXSB9O1xuXG4gICAgICAgICAgICB0aGlzLnN1YnMgPSB7fTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkZFN1YnNjcmlwdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3Vic2NyaXB0aW9uKGNiKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNbY2JdID0gY2I7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXRSb2xlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Um9sZXMocm9sZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucm9sZXMgPSByb2xlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFJvbGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb2xlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvbGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2VuZXJhdGVLZXlzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUtleXMoYWNjb3VudE5hbWUsIHBhc3N3b3JkLCByb2xlcywgcHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIWFjY291bnROYW1lIHx8ICFwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY291bnQgbmFtZSBvciBwYXNzd29yZCByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCAxMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3N3b3JkIG11c3QgaGF2ZSBhdCBsZWFzdCAxMiBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJpdktleXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwdWJLZXlzID0ge307XG5cbiAgICAgICAgICAgIChyb2xlcyB8fCB0aGlzLnN0YXRlLnJvbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZWQgPSBhY2NvdW50TmFtZSArIHJvbGUgKyBwYXNzd29yZDtcbiAgICAgICAgICAgICAgICB2YXIgcGtleSA9IF90aGlzLmtleUNhY2hlLmhhc1ByaXZLZXkocm9sZSkgPyBfdGhpcy5rZXlDYWNoZS5nZXRQcml2S2V5KHJvbGUpIDogUHJpdmF0ZUtleS5mcm9tU2VlZChrZXkubm9ybWFsaXplX2JyYWluS2V5KHNlZWQpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5rZXlDYWNoZS5zZXRQcml2S2V5KHJvbGUsIHBrZXkpO1xuXG4gICAgICAgICAgICAgICAgcHJpdktleXNbcm9sZV0gPSBwa2V5O1xuICAgICAgICAgICAgICAgIHB1YktleXNbcm9sZV0gPSBfdGhpcy5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSkgPyBfdGhpcy5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSkgOiBwa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcocHJlZml4KTtcblxuICAgICAgICAgICAgICAgIF90aGlzLmtleUNhY2hlLnNldFB1YktleShyb2xlLCBwdWJLZXlzW3JvbGVdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBwcml2S2V5czogcHJpdktleXMsIHB1YktleXM6IHB1YktleXMgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZyb21Qcml2S2V5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUHJpdktleShhY2NvdW50TmFtZSwgcHJpdmF0ZUtleSwgcm9sZXMsIHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByaXZLZXlzID0ge307XG4gICAgICAgICAgICB2YXIgcHViS2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAocm9sZXMgfHwgdGhpcy5zdGF0ZS5yb2xlcykuZm9yRWFjaChmdW5jdGlvbiAocm9sZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBrZXkgPSBfdGhpczIua2V5Q2FjaGUuaGFzUHJpdktleShyb2xlKSA/IF90aGlzMi5rZXlDYWNoZS5nZXRQcml2S2V5KHJvbGUpIDogUHJpdmF0ZUtleS5mcm9tV2lmKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5rZXlDYWNoZS5zZXRQcml2S2V5KHJvbGUsIHBrZXkpO1xuXG4gICAgICAgICAgICAgICAgcHJpdktleXNbcm9sZV0gPSBwa2V5O1xuICAgICAgICAgICAgICAgIHB1YktleXNbcm9sZV0gPSBfdGhpczIua2V5Q2FjaGUuZ2V0UHViS2V5KHJvbGUpID8gX3RoaXMyLmtleUNhY2hlLmdldFB1YktleShyb2xlKSA6IHBrZXkudG9QdWJsaWNLZXkoKS50b1N0cmluZyhwcmVmaXgpO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMyLmtleUNhY2hlLnNldFB1YktleShyb2xlLCBwdWJLZXlzW3JvbGVdKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBwcml2S2V5czogcHJpdktleXMsIHB1YktleXM6IHB1YktleXMgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldFB1YktleXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFB1YktleXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm9sZXMubWFwKGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5rZXlDYWNoZS5nZXRQdWJLZXkocm9sZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNoZWNrS2V5c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tLZXlzKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYWNjb3VudE5hbWUgPSBfcmVmLmFjY291bnROYW1lLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkID0gX3JlZi5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICBhdXRocyA9IF9yZWYuYXV0aHMsXG4gICAgICAgICAgICAgICAgX3JlZiRwcml2YXRlS2V5ID0gX3JlZi5wcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBfcmVmJHByaXZhdGVLZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBfcmVmJHByaXZhdGVLZXk7XG5cbiAgICAgICAgICAgIGlmICghYWNjb3VudE5hbWUgfHwgIXBhc3N3b3JkICYmICFwcml2YXRlS2V5IHx8ICFhdXRocykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrS2V5czogTWlzc2luZyBpbnB1dHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFzS2V5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHJvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAocGFzc3dvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IF90aGlzNC5nZW5lcmF0ZUtleXMoYWNjb3VudE5hbWUsIHBhc3N3b3JkLCBbcm9sZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gX3RoaXM0LmZyb21Qcml2S2V5KGFjY291bnROYW1lLCBwcml2YXRlS2V5LCBbcm9sZV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXlzICYmIE9iamVjdC5rZXlzKGtleXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2tleXMgPSBrZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpdktleXMgPSBfa2V5cy5wcml2S2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YktleXMgPSBfa2V5cy5wdWJLZXlzO1xuXG4gICAgICAgICAgICAgICAgICAgIGF1dGhzW3JvbGVdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVswXSA9PT0gcHViS2V5c1tyb2xlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0LmtleUNhY2hlLnNldE15S2V5KHJvbGUsIHsgcHJpdjogcHJpdktleXNbcm9sZV0sIHB1YjogcHViS2V5c1tyb2xlXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgcm9sZSBpbiBhdXRocykge1xuICAgICAgICAgICAgICAgIF9sb29wKHJvbGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGhhc0tleSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IGFjY291bnROYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxvZ2dlZEluID0gaGFzS2V5O1xuXG4gICAgICAgICAgICByZXR1cm4gaGFzS2V5O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc2lnbmVyUHVia2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICB2YXIgcmVxdWlyZWRQdWJrZXlzID0gYXJndW1lbnRzWzJdO1xuXG5cbiAgICAgICAgICAgIHZhciBteUtleXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoYXNLZXkgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5yb2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15S2V5ID0gX3RoaXM1LmtleUNhY2hlLmdldE15S2V5KHJvbGUpO1xuICAgICAgICAgICAgICAgIGlmIChteUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmVyUHVia2V5c1tteUtleS5wdWJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhc0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lclB1YmtleXNbbXlLZXkucHViXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZFB1YmtleXMgJiYgcmVxdWlyZWRQdWJrZXlzLmluZGV4T2YobXlLZXkucHViKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF9zaWduZXIobXlLZXkucHJpdiwgbXlLZXkucHViKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmVxdWlyZWRQdWJrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRfc2lnbmVyKG15S2V5LnByaXYsIG15S2V5LnB1Yik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFoYXNLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGRvIG5vdCBoYXZlIGFueSBwcml2YXRlIGtleXMgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBkbyBub3QgaGF2ZSBhbnkgcHJpdmF0ZSBrZXlzIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBY2NvdW50TG9naW47XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWNjb3VudExvZ2luO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9BY2NvdW50TG9naW4uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG4vL3ZhciBfdGhpcztcblxudmFyIGVjY19jb25maWcgPSB7XG4gICAgYWRkcmVzc19wcmVmaXg6IFwiU1RNXCJcbn07XG5cbnZhciBfdGhpcyA9IHtcbiAgICBjb3JlX2Fzc2V0OiBcIlNURUVNXCIsXG4gICAgdmVzdF9hc3NldDogXCJWRVNUU1wiLFxuICAgIGRvbGxhcl9hc3NldDogXCJTQkRcIixcbiAgICBhZGRyZXNzX3ByZWZpeDogXCJTVE1cIixcbiAgICBleHBpcmVfaW5fc2VjczogMTUsXG4gICAgZXhwaXJlX2luX3NlY3NfcHJvcG9zYWw6IDI0ICogNjAgKiA2MCxcbiAgICBjaGFpbl9pZDogXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgbmV0d29ya3M6IHtcbiAgICAgICAgU3RlZW06IHtcbiAgICAgICAgICAgIGNvcmVfYXNzZXQ6IFwiU1RFRU1cIixcbiAgICAgICAgICAgIHZlc3RfYXNzZXQ6IFwiVkVTVFNcIixcbiAgICAgICAgICAgIGRvbGxhcl9hc3NldDogXCJTQkRcIixcbiAgICAgICAgICAgIGFkZHJlc3NfcHJlZml4OiBcIlNUTVwiLFxuICAgICAgICAgICAgY2hhaW5faWQ6IFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgICAgIH0sXG4gICAgICAgIEdvbG9zOiB7XG4gICAgICAgICAgICBjb3JlX2Fzc2V0OiBcIkdPTE9TXCIsXG4gICAgICAgICAgICB2ZXN0X2Fzc2V0OiBcIkdFU1RTXCIsXG4gICAgICAgICAgICBkb2xsYXJfYXNzZXQ6IFwiR0JHXCIsXG4gICAgICAgICAgICBhZGRyZXNzX3ByZWZpeDogXCJHTFNcIixcbiAgICAgICAgICAgIGNoYWluX2lkOiBcIjc4MmEzMDM5YjQ3OGM4MzllNGNiMGM5NDFmZjRlYWViN2RmNDBiZGQ2OGJkNDQxYWZkNDQ0YjlkYTc2M2RlMTJcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogU2V0IGEgZmV3IHByb3BlcnRpZXMgZm9yIGtub3duIGNoYWluIElEcy4gKi9cbiAgICBzZXRDaGFpbklkOiBmdW5jdGlvbiBzZXRDaGFpbklkKGNoYWluX2lkKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgbmV0d29yaywgbmV0d29ya19uYW1lLCByZWY7XG4gICAgICAgIHJlZiA9IE9iamVjdC5rZXlzKF90aGlzLm5ldHdvcmtzKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgbmV0d29ya19uYW1lID0gcmVmW2ldO1xuICAgICAgICAgICAgbmV0d29yayA9IF90aGlzLm5ldHdvcmtzW25ldHdvcmtfbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmNoYWluX2lkID09PSBjaGFpbl9pZCkge1xuXG4gICAgICAgICAgICAgICAgX3RoaXMubmV0d29ya19uYW1lID0gbmV0d29ya19uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmsuYWRkcmVzc19wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkcmVzc19wcmVmaXggPSBuZXR3b3JrLmFkZHJlc3NfcHJlZml4O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb2xsYXJfYXNzZXQgPSBuZXR3b3JrLmRvbGxhcl9hc3NldDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmVzdF9hc3NldCA9IG5ldHdvcmsudmVzdF9hc3NldDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29yZV9hc3NldCA9IG5ldHdvcmsuY29yZV9hc3NldDtcblxuICAgICAgICAgICAgICAgICAgICBlY2NfY29uZmlnLmFkZHJlc3NfcHJlZml4ID0gbmV0d29yay5hZGRyZXNzX3ByZWZpeDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhaW5faWQgPSBjaGFpbl9pZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIklORk8gICAgQ29uZmlndXJlZCBmb3JcIiwgbmV0d29ya19uYW1lLCBcIjpcIiwgbmV0d29yay5jb3JlX2Fzc2V0LCBcIlxcblwiKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtfbmFtZTogbmV0d29ya19uYW1lLFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMubmV0d29ya19uYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gY2hhaW4gaWQgKHRoaXMgbWF5IGJlIGEgdGVzdG5ldClcIiwgY2hhaW5faWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgX3RoaXMuY29yZV9hc3NldCA9IFwiU1RFRU1cIjtcbiAgICAgICAgX3RoaXMuYWRkcmVzc19wcmVmaXggPSBcIlNUTVwiO1xuICAgICAgICBlY2NfY29uZmlnLmFkZHJlc3NfcHJlZml4ID0gXCJTVE1cIjtcbiAgICAgICAgX3RoaXMuZXhwaXJlX2luX3NlY3MgPSAxNTtcbiAgICAgICAgX3RoaXMuZXhwaXJlX2luX3NlY3NfcHJvcG9zYWwgPSAyNCAqIDYwICogNjA7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJDaGFpbiBjb25maWcgcmVzZXRcIik7XG4gICAgfSxcblxuICAgIHNldFByZWZpeDogZnVuY3Rpb24gc2V0UHJlZml4KCkge1xuICAgICAgICB2YXIgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIlNUTVwiO1xuXG4gICAgICAgIF90aGlzLmFkZHJlc3NfcHJlZml4ID0gcHJlZml4O1xuICAgICAgICBlY2NfY29uZmlnLmFkZHJlc3NfcHJlZml4ID0gcHJlZml4O1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IF90aGlzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9DaGFpbkNvbmZpZy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDaGFpblR5cGVzID0ge307XG5cbkNoYWluVHlwZXMub3BlcmF0aW9ucyA9IHtcbiAgICB2b3RlOiAwLFxuICAgIGNvbW1lbnQ6IDEsXG4gICAgdHJhbnNmZXI6IDIsXG4gICAgdHJhbnNmZXJfdG9fdmVzdGluZzogMyxcbiAgICB3aXRoZHJhd192ZXN0aW5nOiA0LFxuICAgIGxpbWl0X29yZGVyX2NyZWF0ZTogNSxcbiAgICBsaW1pdF9vcmRlcl9jYW5jZWw6IDYsXG4gICAgZmVlZF9wdWJsaXNoOiA3LFxuICAgIGNvbnZlcnQ6IDgsXG4gICAgYWNjb3VudF9jcmVhdGU6IDksXG4gICAgYWNjb3VudF91cGRhdGU6IDEwLFxuICAgIHdpdG5lc3NfdXBkYXRlOiAxMSxcbiAgICBhY2NvdW50X3dpdG5lc3Nfdm90ZTogMTIsXG4gICAgYWNjb3VudF93aXRuZXNzX3Byb3h5OiAxMyxcbiAgICBwb3c6IDE0LFxuICAgIGN1c3RvbTogMTUsXG4gICAgcmVwb3J0X292ZXJfcHJvZHVjdGlvbjogMTYsXG4gICAgZGVsZXRlX2NvbW1lbnQ6IDE3LFxuICAgIGN1c3RvbV9qc29uOiAxOCxcbiAgICBjb21tZW50X29wdGlvbnM6IDE5LFxuICAgIHNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlOiAyMCxcbiAgICBsaW1pdF9vcmRlcl9jcmVhdGUyOiAyMSxcbiAgICBjaGFsbGVuZ2VfYXV0aG9yaXR5OiAyMixcbiAgICBwcm92ZV9hdXRob3JpdHk6IDIzLFxuICAgIHJlcXVlc3RfYWNjb3VudF9yZWNvdmVyeTogMjQsXG4gICAgcmVjb3Zlcl9hY2NvdW50OiAyNSxcbiAgICBjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudDogMjYsXG4gICAgZXNjcm93X3RyYW5zZmVyOiAyNyxcbiAgICBlc2Nyb3dfZGlzcHV0ZTogMjgsXG4gICAgZXNjcm93X3JlbGVhc2U6IDI5LFxuICAgIHBvdzI6IDMwLFxuICAgIGVzY3Jvd19hcHByb3ZlOiAzMSxcbiAgICB0cmFuc2Zlcl90b19zYXZpbmdzOiAzMixcbiAgICB0cmFuc2Zlcl9mcm9tX3NhdmluZ3M6IDMzLFxuICAgIGNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3M6IDM0LFxuICAgIGN1c3RvbV9iaW5hcnk6IDM1LFxuICAgIGRlY2xpbmVfdm90aW5nX3JpZ2h0czogMzYsXG4gICAgcmVzZXRfYWNjb3VudDogMzcsXG4gICAgc2V0X3Jlc2V0X2FjY291bnQ6IDM4LFxuICAgIGNsYWltX3Jld2FyZF9iYWxhbmNlOiAzOSxcbiAgICBkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlczogNDAsXG4gICAgYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uOiA0MSxcbiAgICBmaWxsX2NvbnZlcnRfcmVxdWVzdDogNDIsXG4gICAgYXV0aG9yX3Jld2FyZDogNDMsXG4gICAgY3VyYXRpb25fcmV3YXJkOiA0NCxcbiAgICBjb21tZW50X3Jld2FyZDogNDUsXG4gICAgbGlxdWlkaXR5X3Jld2FyZDogNDYsXG4gICAgaW50ZXJlc3Q6IDQ3LFxuICAgIGZpbGxfdmVzdGluZ193aXRoZHJhdzogNDgsXG4gICAgZmlsbF9vcmRlcjogNDksXG4gICAgc2h1dGRvd25fd2l0bmVzczogNTAsXG4gICAgZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3M6IDUxLFxuICAgIGhhcmRmb3JrOiA1MixcbiAgICBjb21tZW50X3BheW91dF91cGRhdGU6IDUzLFxuICAgIHJldHVybl92ZXN0aW5nX2RlbGVnYXRpb246IDU0LFxuICAgIGNvbW1lbnRfYmVuZWZhY3Rvcl9yZXdhcmQ6IDU1XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYWluVHlwZXM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL0NoYWluVHlwZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gICAgQWNjb3VudCBuYW1lcyBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSBuYW1lcyBzZXBhcmF0ZWQgYnkgYSBkb3QuXG4gICAgRWFjaCBuYW1lIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBsZXR0ZXIgYW5kIG1heSBjb250YWluXG4gICAgbnVtYmVycywgb3Igd2VsbCBwbGFjZWQgZGFzaGVzLlxuICAgIEBzZWUgaXNfdmFsaWRfbmFtZSBncmFwaGVuZS9saWJyYXJpZXMvY2hhaW4vcHJvdG9jb2wvYWNjb3VudC5jcHBcbiovXG52YXIgaWRfcmVnZXggPSAvXFxiXFxkK1xcLlxcZCtcXC4oXFxkKylcXGIvO1xuXG52YXIgY2hhaW5WYWxpZGF0aW9uID0ge1xuICAgIGlzX2FjY291bnRfbmFtZTogZnVuY3Rpb24gaXNfYWNjb3VudF9uYW1lKHZhbHVlKSB7XG4gICAgICAgIHZhciBhbGxvd190b29fc2hvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBpLCBsYWJlbCwgbGVuLCBsZW5ndGgsIHJlZjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAoIWFsbG93X3Rvb19zaG9ydCAmJiBsZW5ndGggPCAzIHx8IGxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWYgPSB2YWx1ZS5zcGxpdCgnLicpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICBsYWJlbCA9IHJlZltpXTtcblxuICAgICAgICAgICAgaWYgKCEoL15bYS16XVthLXowLTktXSokLy50ZXN0KGxhYmVsKSAmJiAhLy0tLy50ZXN0KGxhYmVsKSAmJiAvW2EtejAtOV0kLy50ZXN0KGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGlzX29iamVjdF9pZDogZnVuY3Rpb24gaXNfb2JqZWN0X2lkKG9ial9pZCkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIG9ial9pZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBtYXRjaCA9IGlkX3JlZ2V4LmV4ZWMob2JqX2lkKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoICE9PSBudWxsICYmIG9ial9pZC5zcGxpdChcIi5cIikubGVuZ3RoID09PSAzO1xuICAgIH0sXG5cbiAgICBpc19lbXB0eTogZnVuY3Rpb24gaXNfZW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH0sXG5cbiAgICBpc19hY2NvdW50X25hbWVfZXJyb3I6IGZ1bmN0aW9uIGlzX2FjY291bnRfbmFtZV9lcnJvcih2YWx1ZSwgYWxsb3dfdG9vX3Nob3J0KSB7XG4gICAgICAgIHZhciBpLCBsYWJlbCwgbGVuLCBsZW5ndGgsIHJlZiwgc3VmZml4O1xuICAgICAgICBpZiAoYWxsb3dfdG9vX3Nob3J0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFsbG93X3Rvb19zaG9ydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCA9IFwiQWNjb3VudCBuYW1lIHNob3VsZCBcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJub3QgYmUgZW1wdHkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBpZiAoIWFsbG93X3Rvb19zaG9ydCAmJiBsZW5ndGggPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJiZSBsb25nZXIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJiZSBzaG9ydGVyLlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXFwuLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgc3VmZml4ID0gXCJFYWNoIGFjY291bnQgc2VnbWVudCBzaG91bGQgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVmID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IHJlZltpXTtcbiAgICAgICAgICAgIGlmICghL15bfmEtel0vLnRlc3QobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwic3RhcnQgd2l0aCBhIGxldHRlci5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghL15bfmEtejAtOS1dKiQvLnRlc3QobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiaGF2ZSBvbmx5IGxldHRlcnMsIGRpZ2l0cywgb3IgZGFzaGVzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC8tLS8udGVzdChsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJoYXZlIG9ubHkgb25lIGRhc2ggaW4gYSByb3cuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIS9bYS16MC05XSQvLnRlc3QobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiZW5kIHdpdGggYSBsZXR0ZXIgb3IgZGlnaXQuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShsYWJlbC5sZW5ndGggPj0gMykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJiZSBsb25nZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaXNfY2hlYXBfbmFtZTogZnVuY3Rpb24gaXNfY2hlYXBfbmFtZShhY2NvdW50X25hbWUpIHtcbiAgICAgICAgcmV0dXJuICgvWzAtOS1dLy50ZXN0KGFjY291bnRfbmFtZSkgfHwgIS9bYWVpb3V5XS8udGVzdChhY2NvdW50X25hbWUpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGlzX2VtcHR5X3VzZXJfaW5wdXQ6IGZ1bmN0aW9uIGlzX2VtcHR5X3VzZXJfaW5wdXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHZhbHVlICsgXCJcIikudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlcXVpcmVkOiBmdW5jdGlvbiByZXF1aXJlZCh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5pc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhbHVlIHJlcXVpcmVkIGZvciBcIiArIGZpZWxkX25hbWUgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKiogQHNlZSBpc192YWxpZF9zeW1ib2wgZ3JhcGhlbmUvbGlicmFyaWVzL2NoYWluL3Byb3RvY29sL2Fzc2V0X29wcy5jcHAgKi9cbiAgICBpc192YWxpZF9zeW1ib2xfZXJyb3I6IGZ1bmN0aW9uIGlzX3ZhbGlkX3N5bWJvbF9lcnJvcih2YWx1ZSkge1xuICAgICAgICB2YXIgc3VmZml4ID0gXCJBc3NldCBuYW1lIHNob3VsZCBcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VmZml4ICsgXCJub3QgYmUgZW1wdHkuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnNwbGl0KCcuJykubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiaGF2ZSBvbmx5IG9uZSBkb3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImJlIGxvbmdlci5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImJlIHNob3J0ZXIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXltBLVpdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwic3RhcnQgd2l0aCBhIGxldHRlclwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL1tBLVpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWZmaXggKyBcImVuZCB3aXRoIGEgbGV0dGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eW0EtWjAtOVxcLl0kLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeCArIFwiY29udGFpbiBvbmx5IGxldHRlcnMgbnVtYmVycyBhbmQgcGVyaGFwcyBhIGRvdC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYWluVmFsaWRhdGlvbjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvQ2hhaW5WYWxpZGF0aW9uLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKipcbiAgICBDb252ZXJ0IDEyLjM0IHdpdGggYSBwcmVjaXNpb24gb2YgMyBpbnRvIDEyMzQwXG4gICAgXG4gICAgQGFyZyB7bnVtYmVyfHN0cmluZ30gbnVtYmVyIC0gVXNlIHN0cmluZ3MgZm9yIGxhcmdlIG51bWJlcnMuICBUaGlzIG1heSBjb250YWluIG9uZSBkZWNpbWFsIGJ1dCBubyBzaWduXG4gICAgQGFyZyB7bnVtYmVyfSBwcmVjaXNpb24gLSBudW1iZXIgb2YgaW1wbGllZCBkZWNpbWFsIHBsYWNlcyAodXN1YWxseSBjYXVzZXMgcmlnaHQgemVybyBwYWRkaW5nKVxuICAgIEByZXR1cm4ge3N0cmluZ30gLVxuKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHRvSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIHRvSW1wbGllZERlY2ltYWwobnVtYmVyLCBwcmVjaXNpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyID09PSBcInN0cmluZ1wiLCBcIm51bWJlciBzaG91bGQgYmUgYW4gYWN0dWFsIG51bWJlciBvciBzdHJpbmc6IFwiICsgKHR5cGVvZiBudW1iZXIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihudW1iZXIpKSk7XG4gICAgICAgIG51bWJlciA9IG51bWJlci50cmltKCk7XG4gICAgICAgIGFzc2VydCgvXlswLTldKlxcLj9bMC05XSokLy50ZXN0KG51bWJlciksIFwiSW52YWxpZCBkZWNpbWFsIG51bWJlciBcIiArIG51bWJlcik7XG5cbiAgICAgICAgdmFyIF9udW1iZXIkc3BsaXQgPSBudW1iZXIuc3BsaXQoXCIuXCIpLFxuICAgICAgICAgICAgX251bWJlciRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfbnVtYmVyJHNwbGl0LCAyKSxcbiAgICAgICAgICAgIF9udW1iZXIkc3BsaXQyJCA9IF9udW1iZXIkc3BsaXQyWzBdLFxuICAgICAgICAgICAgd2hvbGUgPSBfbnVtYmVyJHNwbGl0MiQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBfbnVtYmVyJHNwbGl0MiQsXG4gICAgICAgICAgICBfbnVtYmVyJHNwbGl0MiQyID0gX251bWJlciRzcGxpdDJbMV0sXG4gICAgICAgICAgICBkZWNpbWFsID0gX251bWJlciRzcGxpdDIkMiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJDI7XG5cbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwcmVjaXNpb24gLSBkZWNpbWFsLmxlbmd0aDtcbiAgICAgICAgYXNzZXJ0KHBhZGRpbmcgPj0gMCwgXCJUb28gbWFueSBkZWNpbWFsIGRpZ2l0cyBpbiBcIiArIG51bWJlciArIFwiIHRvIGNyZWF0ZSBhbiBpbXBsaWVkIGRlY2ltYWwgb2YgXCIgKyBwcmVjaXNpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGluZzsgaSsrKSB7XG4gICAgICAgICAgICBkZWNpbWFsICs9IFwiMFwiO1xuICAgICAgICB9d2hpbGUgKHdob2xlLmNoYXJBdCgwKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9cmV0dXJuIHdob2xlICsgZGVjaW1hbDtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyYy9OdW1iZXJVdGlscy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdieXRlYnVmZmVyJyksXG4gICAgTG9uZyA9IF9yZXF1aXJlLkxvbmc7XG5cbnZhciB2ID0gcmVxdWlyZSgnLi4vLi4vc2VyaWFsaXplci9zcmMvU2VyaWFsaXplclZhbGlkYXRpb24nKTtcblxudmFyIERCX01BWF9JTlNUQU5DRV9JRCA9IExvbmcuZnJvbU51bWJlcihNYXRoLnBvdygyLCA0OCkgLSAxKTtcblxudmFyIE9iamVjdElkID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdElkKHNwYWNlLCB0eXBlLCBpbnN0YW5jZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0SWQpO1xuXG4gICAgICAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB2YXIgaW5zdGFuY2Vfc3RyaW5nID0gdGhpcy5pbnN0YW5jZS50b1N0cmluZygpO1xuICAgICAgICB2YXIgX09iamVjdElkID0gdGhpcy5zcGFjZSArICcuJyArIHRoaXMudHlwZSArICcuJyArIGluc3RhbmNlX3N0cmluZztcbiAgICAgICAgaWYgKCF2LmlzX2RpZ2l0cyhpbnN0YW5jZV9zdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgKCdJbnZhbGlkIG9iamVjdCBpZCAnICsgX09iamVjdElkKSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE9iamVjdElkLCBbe1xuICAgICAgICBrZXk6ICd0b0xvbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb25nKCkge1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnNwYWNlKS5zaGlmdExlZnQoNTYpLm9yKExvbmcuZnJvbU51bWJlcih0aGlzLnR5cGUpLnNoaWZ0TGVmdCg0OCkub3IodGhpcy5pbnN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcHBlbmRCeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgcmV0dXJuIGIud3JpdGVVaW50NjQodGhpcy50b0xvbmcoKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2UgKyAnLicgKyB0aGlzLnR5cGUgKyAnLicgKyB0aGlzLmluc3RhbmNlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3BhY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS50eXBlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHYucmVxdWlyZV9tYXRjaCgvXihbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKSQvLCB2LnJlcXVpcmVkKHZhbHVlLCBcIk9iamVjdElkXCIpLCBcIk9iamVjdElkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChwYXJzZUludChwYXJhbXNbMV0pLCBwYXJzZUludChwYXJhbXNbMl0pLCBMb25nLmZyb21TdHJpbmcocGFyYW1zWzNdKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21Mb25nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Mb25nKGxvbmcpIHtcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IGxvbmcuc2hpZnRSaWdodCg1NikudG9JbnQoKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbG9uZy5zaGlmdFJpZ2h0KDQ4KS50b0ludCgpICYgMHgwMGZmO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbG9uZy5hbmQoREJfTUFYX0lOU1RBTkNFX0lEKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoc3BhY2UsIHR5cGUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbUJ5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdElkLmZyb21Mb25nKGIucmVhZFVpbnQ2NCgpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPYmplY3RJZDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmMvT2JqZWN0SWQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2NoYWluL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpLFxuICAgIFNpZ25hdHVyZSA9IF9yZXF1aXJlLlNpZ25hdHVyZSxcbiAgICBQdWJsaWNLZXkgPSBfcmVxdWlyZS5QdWJsaWNLZXksXG4gICAgaGFzaCA9IF9yZXF1aXJlLmhhc2g7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vLi4vc2VyaWFsaXplclwiKSxcbiAgICBvcHMgPSBfcmVxdWlyZTIub3BzO1xuXG52YXIgQ2hhaW5Db25maWcgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL0NoYWluQ29uZmlnXCIpO1xuXG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZSgnc3RlZW0tcnBjJyksXG4gICAgQ2xpZW50ID0gX3JlcXVpcmUzLkNsaWVudDtcblxudmFyIEFwaSA9IENsaWVudC5nZXQoKTtcblxudmFyIF9yZXF1aXJlNCA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKSxcbiAgICBMb25nID0gX3JlcXVpcmU0Lkxvbmc7XG5cbnZhciBDaGFpblR5cGVzID0gcmVxdWlyZSgnLi9DaGFpblR5cGVzJyk7XG5cbnZhciBoZWFkX2Jsb2NrX3RpbWVfc3RyaW5nO1xuXG52YXIgVHJhbnNhY3Rpb25CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uQnVpbGRlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uQnVpbGRlcik7XG5cbiAgICAgICAgdGhpcy5yZWZfYmxvY2tfbnVtID0gMDtcbiAgICAgICAgdGhpcy5yZWZfYmxvY2tfcHJlZml4ID0gMDtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLnNpZ25lcl9wcml2YXRlX2tleXMgPSBbXTtcblxuICAgICAgICAvLyBzZW1pLXByaXZhdGUgbWV0aG9kIGJpbmRpbmdzXG4gICAgICAgIHRoaXMuX2Jyb2FkY2FzdCA9IF9icm9hZGNhc3QuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgQGFyZyB7c3RyaW5nfSBuYW1lIC0gbGlrZSBcInRyYW5zZmVyXCJcbiAgICAgICAgQGFyZyB7b2JqZWN0fSBvcGVyYXRpb24gLSBKU09OIG1hdGNoY2hpbmcgdGhlIG9wZXJhdGlvbidzIGZvcm1hdFxuICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbkJ1aWxkZXIsIFt7XG4gICAgICAgIGtleTogXCJhZGRfdHlwZV9vcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZF90eXBlX29wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX29wZXJhdGlvbih0aGlzLmdldF90eXBlX29wZXJhdGlvbihuYW1lLCBvcGVyYXRpb24pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBkb2VzIGl0IGFsbDogc2V0IGZlZXMsIGZpbmFsaXplLCBzaWduLCBhbmQgYnJvYWRjYXN0IChpZiB3YW50ZWQpLlxuICAgICAgICAgICAgIEBhcmcge0NvbmZpZGVudGlhbFdhbGxldH0gY3dhbGxldCAtIG11c3QgYmUgdW5sb2NrZWQsIHVzZWQgdG8gZ2F0aGVyIHNpZ25pbmcga2V5c1xuICAgICAgICAgICAgIEBhcmcge2FycmF5PHN0cmluZz59IFtzaWduZXJfcHVia2V5cyA9IG51bGxdIC0gT3B0aW9uYWwgW1wiR1BIQWJjOURlZjAuLi5cIiwgLi4uXS4gIFRoZXNlIGFyZSBhZGRpdGlvbmFsIHNpZ25pbmcga2V5cy4gIFNvbWUgYmFsYW5jZSBjbGFpbXMgcmVxdWlyZSBwcm9wcml0YXJ5IGFkZHJlc3MgZm9ybWF0cywgdGhlIHdpdG5lc3Mgbm9kZSBjYW4ndCB0ZWxsIHVzIHdoaWNoIG9uZXMgYXJlIG5lZWRlZCBzbyB0aGV5IG11c3QgYmUgcGFzc2VkIGluLiAgSWYgdGhlIHdpdG5lc3Mgbm9kZSBjYW4gZmlndXJlIG91dCBhIHNpZ25pbmcga2V5IChtb3N0bHkgYWxsIG90aGVyIHRyYW5zYWN0aW9ucyksIGl0IHNob3VsZCBub3QgYmUgcGFzc2VkIGluIGhlcmUuXG4gICAgICAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2Jyb2FkY2FzdCA9IGZhbHNlXVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc190cmFuc2FjdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc190cmFuc2FjdGlvbihhY2NvdW50TG9naW4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzaWduZXJfcHVia2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBicm9hZGNhc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG5cbiAgICAgICAgICAgIC8vIGxldCB3YWxsZXRfb2JqZWN0ID0gY3dhbGxldC53YWxsZXQud2FsbGV0X29iamVjdFxuICAgICAgICAgICAgLy8gaWYoQXBpLmNoYWluX2lkICE9PSB3YWxsZXRfb2JqZWN0LmdldChcImNoYWluX2lkXCIpKVxuICAgICAgICAgICAgLy8gICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIk1pc21hdGNoZWQgY2hhaW5faWQ7IGV4cGVjdGluZyBcIiArXG4gICAgICAgICAgICAvLyAgICAgICAgIHdhbGxldF9vYmplY3QuZ2V0KFwiY2hhaW5faWRcIikgKyBcIiwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAvLyAgICAgICAgIEFwaS5jaGFpbl9pZClcblxuICAgICAgICAgICAgdmFyIHNpZ25lcl9wdWJrZXlzX2FkZGVkID0ge307XG4gICAgICAgICAgICAvLyBpZihzaWduZXJfcHVia2V5cykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAvLyBCYWxhbmNlIGNsYWltcyBhcmUgYnkgYWRkcmVzcywgb25seSB0aGUgcHJpdmF0ZVxuICAgICAgICAgICAgLy8gICAgIC8vIGtleSBob2xkZXIgY2FuIGtub3cgYWJvdXQgdGhlc2UgYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gICAgIC8vIHBvdGVudGlhbCBrZXlzLlxuICAgICAgICAgICAgLy8gICAgIHZhciBwdWJrZXlzID0gYWNjb3VudExvZ2luLmdldFB1YktleXMoKVxuICAgICAgICAgICAgLy8gICAgIGlmKCAhIHB1YmtleXMubGVuZ3RoKVxuICAgICAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNpZ25pbmcga2V5XCIpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgIGZvcihsZXQgcHVia2V5X3N0cmluZyBvZiBwdWJrZXlzKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHZhciBwcml2YXRlX2tleSA9IGN3YWxsZXQuZ2V0UHJpdmF0ZUtleShwdWJrZXlfc3RyaW5nKVxuICAgICAgICAgICAgLy8gICAgICAgICB0aGlzLmFkZF9zaWduZXIocHJpdmF0ZV9rZXksIHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAvLyAgICAgICAgIHNpZ25lcl9wdWJrZXlzX2FkZGVkW3B1YmtleV9zdHJpbmddID0gdHJ1ZVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMuZ2V0X3BvdGVudGlhbF9zaWduYXR1cmVzKCkudGhlbiggKHB1YmtleXMpPT4ge1xuICAgICAgICAgICAgdmFyIG15X3B1YmtleXMgPSBhY2NvdW50TG9naW4uZ2V0UHViS2V5cygpO1xuXG4gICAgICAgICAgICAvL3svL1Rlc3Rpbmcgb25seSwgZG9uJ3Qgc2VuZCBBbGwgcHVibGljIGtleXMhXG4gICAgICAgICAgICAvLyAgICB2YXIgcHVia2V5c19hbGwgPSBQcml2YXRlS2V5U3RvcmUuZ2V0UHVia2V5cygpIC8vIEFsbCBwdWJsaWMga2V5c1xuICAgICAgICAgICAgLy8gICAgdGhpcy5nZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyhwdWJrZXlzX2FsbCkudGhlbiggcmVxdWlyZWRfcHVia2V5X3N0cmluZ3MgPT5cbiAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZygnZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgYWxsXFx0JyxyZXF1aXJlZF9wdWJrZXlfc3RyaW5ncy5zb3J0KCksIHB1YmtleXNfYWxsKSlcbiAgICAgICAgICAgIC8vICAgIHRoaXMuZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMobXlfcHVia2V5cykudGhlbiggcmVxdWlyZWRfcHVia2V5X3N0cmluZ3MgPT5cbiAgICAgICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZygnZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMgbm9ybWFsXFx0JyxyZXF1aXJlZF9wdWJrZXlfc3RyaW5ncy5zb3J0KCksIHB1YmtleXMpKVxuICAgICAgICAgICAgLy99XG5cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMobXlfcHVia2V5cykudGhlbihmdW5jdGlvbiAocmVxdWlyZWRfcHVia2V5cykge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicmVxdWlyZWRfcHVia2V5c1wiLCByZXF1aXJlZF9wdWJrZXlzKTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gbXlfcHVia2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdWJrZXlfc3RyaW5nID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwicHVia2V5X3N0cmluZ1wiLCBwdWJrZXlfc3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25lcl9wdWJrZXlzX2FkZGVkW3B1YmtleV9zdHJpbmddKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudExvZ2luLnNpZ25UcmFuc2FjdGlvbihfdGhpcywgc2lnbmVyX3B1YmtleXNfYWRkZWQsIHJlcXVpcmVkX3B1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHByaXZhdGVfa2V5ID0gY3dhbGxldC5nZXRQcml2YXRlS2V5KHB1YmtleV9zdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiggISBwcml2YXRlX2tleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBnZXRfcmVxdWlyZWRfc2lnbmF0dXJlcyB3aWxsIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAvLyByZXR1cm5lZCBrZXlzIGZyb20gbXlfcHVia2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc2lnbmluZyBrZXkgZm9yIFwiICsgcHVia2V5X3N0cmluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkX3NpZ25lcihwcml2YXRlX2tleSwgcHVia2V5X3N0cmluZylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2lnbmVyX3B1YmtleXNfYWRkZWRcIiwgc2lnbmVyX3B1YmtleXNfYWRkZWQpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYnJvYWRjYXN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFR5cGljYWxseSB0aGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGp1c3QgcHJpb3IgdG8gc2lnbmluZy4gIE9uY2UgZmluYWxpemVkIHRoaXMgdHJhbnNhY3Rpb24gY2FuIG5vdCBiZSBjaGFuZ2VkLiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVHJ5IHRvIGZpbmFsaXplXCIsIFwiZXhwaXJhdGlvbjpcIiwgdGhpcy5leHBpcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKEFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXNcIiwgW10pLnRoZW4oZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZF9ibG9ja190aW1lX3N0cmluZyA9IHIudGltZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5leHBpcmF0aW9uID09PSAwKSBfdGhpczIuZXhwaXJhdGlvbiA9IGJhc2VfZXhwaXJhdGlvbl9zZWMoKSArIENoYWluQ29uZmlnLmV4cGlyZV9pbl9zZWNzO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5ldyBleHBpcmF0aW9uOlwiLCB0aGlzLmV4cGlyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIucmVmX2Jsb2NrX251bSA9IHIuaGVhZF9ibG9ja19udW1iZXIgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5yZWZfYmxvY2tfcHJlZml4ID0gbmV3IEJ1ZmZlcihyLmhlYWRfYmxvY2tfaWQsICdoZXgnKS5yZWFkVUludDMyTEUoNCk7XG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coXCJyZWZfYmxvY2tcIixAcmVmX2Jsb2NrX251bSxAcmVmX2Jsb2NrX3ByZWZpeCxyKVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IF90aGlzMi5vcGVyYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgb3A7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFsxXVtcImZpbmFsaXplXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BbMV0uZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpczIudHJfYnVmZmVyID0gb3BzLnRyYW5zYWN0aW9uLnRvQnVmZmVyKF90aGlzMik7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzIGVycjpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9IGhleCB0cmFuc2FjdGlvbiBJRCAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiaWRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlkKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyX2J1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzaC5zaGEyNTYodGhpcy50cl9idWZmZXIpLnRvU3RyaW5nKCdoZXgnKS5zdWJzdHJpbmcoMCwgNDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBUeXBpY2FsbHkgb25lIHdpbGwgdXNlIHtAbGluayB0aGlzLmFkZF90eXBlX29wZXJhdGlvbn0gaW5zdGVhZC5cbiAgICAgICAgICAgIEBhcmcge2FycmF5fSBvcGVyYXRpb24gLSBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25dXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhZGRfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRfb3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnQob3BlcmF0aW9uLCBcIm9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcGVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0aW5nIGFycmF5IFtvcGVyYXRpb25faWQsIG9wZXJhdGlvbl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0X3R5cGVfb3BlcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfdHlwZV9vcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChuYW1lLCBcIm5hbWVcIik7XG4gICAgICAgICAgICBhc3NlcnQob3BlcmF0aW9uLCBcIm9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBfdHlwZSA9IG9wc1tuYW1lXTtcbiAgICAgICAgICAgIGFzc2VydChfdHlwZSwgXCJVbmtub3duIG9wZXJhdGlvbiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbl9pZCA9IENoYWluVHlwZXMub3BlcmF0aW9uc1tfdHlwZS5vcGVyYXRpb25fbmFtZV07XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIG9wZXJhdGlvbjogXCIgKyBfdHlwZS5vcGVyYXRpb25fbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZXJhdGlvbi5mZWUpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZmVlID0geyBhbW91bnQ6IDAsIGFzc2V0X2lkOiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3Byb3Bvc2FsX2NyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lIHx8IChvcGVyYXRpb24uZXhwaXJhdGlvbl90aW1lID0gYmFzZV9leHBpcmF0aW9uX3NlYygpICsgQ2hhaW5Db25maWcuZXhwaXJlX2luX3NlY3NfcHJvcG9zYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbl9pbnN0YW5jZSA9IF90eXBlLmZyb21PYmplY3Qob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBbb3BlcmF0aW9uX2lkLCBvcGVyYXRpb25faW5zdGFuY2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIG9wdGlvbmFsOiB0aGVyZSBpcyBhIGRlYWZ1bHQgZXhwaXJhdGlvbiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2V0X2V4cGlyZV9zZWNvbmRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfZXhwaXJlX3NlY29uZHMoc2VjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGlyYXRpb24gPSBiYXNlX2V4cGlyYXRpb25fc2VjKCkgKyBzZWM7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBXcmFwcyB0aGlzIHRyYW5zYWN0aW9uIGluIGEgcHJvcG9zYWxfY3JlYXRlIHRyYW5zYWN0aW9uICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9wb3NlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wb3NlKHByb3Bvc2FsX2NyZWF0ZV9vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZCBvcGVyYXRpb24gZmlyc3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzc2VydChwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucywgXCJwcm9wb3NhbF9jcmVhdGVfb3B0aW9uc1wiKTtcbiAgICAgICAgICAgIGFzc2VydChwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucy5mZWVfcGF5aW5nX2FjY291bnQsIFwicHJvcG9zYWxfY3JlYXRlX29wdGlvbnMuZmVlX3BheWluZ19hY2NvdW50XCIpO1xuXG4gICAgICAgICAgICB2YXIgcHJvcG9zZWRfb3BzID0gdGhpcy5vcGVyYXRpb25zLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcDogb3AgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG4gICAgICAgICAgICBwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucy5wcm9wb3NlZF9vcHMgPSBwcm9wb3NlZF9vcHM7XG4gICAgICAgICAgICB0aGlzLmFkZF90eXBlX29wZXJhdGlvbihcInByb3Bvc2FsX2NyZWF0ZVwiLCBwcm9wb3NhbF9jcmVhdGVfb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImhhc19wcm9wb3NlZF9vcGVyYXRpb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc19wcm9wb3NlZF9vcGVyYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcGVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwicHJvcG9zZWRfb3BzXCIgaW4gdGhpcy5vcGVyYXRpb25zW2ldWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Byb3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcG9zZWQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRfcG90ZW50aWFsX3NpZ25hdHVyZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9wb3RlbnRpYWxfc2lnbmF0dXJlcygpIHtcbiAgICAgICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIEFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3BvdGVudGlhbF9zaWduYXR1cmVzXCIsIFt0cl9vYmplY3RdKS50aGVuKGZ1bmN0aW9uIChwdWJrZXlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcHVia2V5czogcHVia2V5cyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRfcmVxdWlyZWRfc2lnbmF0dXJlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMoYXZhaWxhYmxlX2tleXMpIHtcblxuICAgICAgICAgICAgaWYgKCFhdmFpbGFibGVfa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnLi4uIHRyX29iamVjdCcsdHJfb2JqZWN0KTtcbiAgICAgICAgICAgIC8vREVCVUcgY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLHRyX29iamVjdClcbiAgICAgICAgICAgIHJldHVybiBBcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9yZXF1aXJlZF9zaWduYXR1cmVzXCIsIFt0cl9vYmplY3QsIGF2YWlsYWJsZV9rZXlzXSkudGhlbihmdW5jdGlvbiAocmVxdWlyZWRfcHVibGljX2tleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIGdldF9yZXF1aXJlZF9zaWduYXR1cmVzJyxyZXF1aXJlZF9wdWJsaWNfa2V5cylcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcuLi4gZ2V0X3JlcXVpcmVkX3NpZ25hdHVyZXMnLHJlcXVpcmVkX3B1YmxpY19rZXlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRfcHVibGljX2tleXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFkZF9zaWduZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZF9zaWduZXIocHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBwdWJsaWNfa2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpO1xuXG5cbiAgICAgICAgICAgIGFzc2VydChwcml2YXRlX2tleS5kLCBcInJlcXVpcmVkIFByaXZhdGVLZXkgb2JqZWN0XCIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IHNpZ25lZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHVibGljX2tleS5RKSB7XG4gICAgICAgICAgICAgICAgcHVibGljX2tleSA9IFB1YmxpY0tleS5mcm9tUHVibGljS2V5U3RyaW5nKHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgICAgICB2YXIgc3BIZXggPSBwcml2YXRlX2tleS50b0hleCgpO1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3AgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwWzBdLnRvSGV4KCkgPT09IHNwSGV4KSByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2lnbmVyX3ByaXZhdGVfa2V5cy5wdXNoKFtwcml2YXRlX2tleSwgcHVibGljX2tleV0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwic2lnblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbl9pZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogQ2hhaW5Db25maWcuY2hhaW5faWQ7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYWluX2lkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy50cl9idWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZmluYWxpemVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBzaWduZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgZW5kID8gaSA8IGVuZCA6IGkgPiBlbmQ7IDAgPCBlbmQgPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NpZ25lcl9wcml2YXRlX2tleXMkID0gX3NsaWNlZFRvQXJyYXkodGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzW2ldLCAyKSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZV9rZXkgPSBfc2lnbmVyX3ByaXZhdGVfa2V5cyRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY19rZXkgPSBfc2lnbmVyX3ByaXZhdGVfa2V5cyRbMV07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2lnID0gU2lnbmF0dXJlLnNpZ25CdWZmZXIoQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihjaGFpbl9pZCwgJ2hleCcpLCB0aGlzLnRyX2J1ZmZlcl0pLCBwcml2YXRlX2tleSwgcHVibGljX2tleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWduYXR1cmVzLnB1c2goc2lnLnRvQnVmZmVyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaWduZXJfcHJpdmF0ZV9rZXlzID0gW107XG4gICAgICAgICAgICB0aGlzLnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwidG9PYmplY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wcy5zaWduZWRfdHJhbnNhY3Rpb24udG9PYmplY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJicm9hZGNhc3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fYnJvYWRjYXN0KHdhc19icm9hZGNhc3RfY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uQnVpbGRlcjtcbn0oKTtcblxudmFyIGJhc2VfZXhwaXJhdGlvbl9zZWMgPSBmdW5jdGlvbiBiYXNlX2V4cGlyYXRpb25fc2VjKCkge1xuICAgIHZhciBoZWFkX2Jsb2NrX3NlYyA9IE1hdGguY2VpbChnZXRIZWFkQmxvY2tEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgdmFyIG5vd19zZWMgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIC8vIFRoZSBoZWFkIGJsb2NrIHRpbWUgc2hvdWxkIGJlIHVwZGF0ZWQgZXZlcnkgMyBzZWNvbmRzLiAgSWYgaXQgaXNuJ3RcbiAgICAvLyB0aGVuIGhlbHAgdGhlIHRyYW5zYWN0aW9uIHRvIGV4cGlyZSAodXNlIGhlYWRfYmxvY2tfc2VjKVxuICAgIGlmIChub3dfc2VjIC0gaGVhZF9ibG9ja19zZWMgPiAzMCkge1xuICAgICAgICByZXR1cm4gaGVhZF9ibG9ja19zZWM7XG4gICAgfVxuICAgIC8vIElmIHRoZSB1c2VyJ3MgY2xvY2sgaXMgdmVyeSBmYXIgYmVoaW5kLCB1c2UgdGhlIGhlYWQgYmxvY2sgdGltZS5cbiAgICByZXR1cm4gTWF0aC5tYXgobm93X3NlYywgaGVhZF9ibG9ja19zZWMpO1xufTtcblxuZnVuY3Rpb24gX2Jyb2FkY2FzdCh3YXNfYnJvYWRjYXN0X2NhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBpZiAoIV90aGlzNC5zaWduZWQpIHtcbiAgICAgICAgICAgIF90aGlzNC5zaWduKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQudHJfYnVmZmVyKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm90IGZpbmFsaXplZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczQuc2lnbmF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJub3Qgc2lnbmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV90aGlzNC5vcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vIG9wZXJhdGlvbnNcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoXCJuZXR3b3JrX2Jyb2FkY2FzdF9hcGlcIiBpbiBBcGkpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQXBpIGRvZXMgbm90IGluY2x1ZGUgbmV0d29ya19icm9hZGNhc3RfYXBpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJfb2JqZWN0ID0gb3BzLnNpZ25lZF90cmFuc2FjdGlvbi50b09iamVjdChfdGhpczQpO1xuXG4gICAgICAgIHJldHVybiBBcGkubmV0d29ya19icm9hZGNhc3RfYXBpKCkuZXhlYyhcImJyb2FkY2FzdF90cmFuc2FjdGlvbl93aXRoX2NhbGxiYWNrXCIsIFt7IHJlamVjdDogcmVqZWN0LCByZXNvbHZlOiByZXNvbHZlIH0sIHRyX29iamVjdF0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBicm9hZGNhc3Qgc3VjY2Vzcywgd2FpdGluZyBmb3IgY2FsbGJhY2snKVxuICAgICAgICAgICAgaWYgKHdhc19icm9hZGNhc3RfY2FsbGJhY2spIHdhc19icm9hZGNhc3RfY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyBtYXkgYmUgcmVkdW5kYW50IGZvciBuZXR3b3JrIGVycm9ycywgb3RoZXIgZXJyb3JzIGNvdWxkIG9jY3VyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobWVzc2FnZSArIFwiXFxuXCIgKyAnZ3JhcGhlbmUtY3J5cHRvICcgKyAnIGRpZ2VzdCAnICsgaGFzaC5zaGEyNTYoX3RoaXM0LnRyX2J1ZmZlcikudG9TdHJpbmcoJ2hleCcpICsgJyB0cmFuc2FjdGlvbiAnICsgX3RoaXM0LnRyX2J1ZmZlci50b1N0cmluZygnaGV4JykgKyAnICcgKyBKU09OLnN0cmluZ2lmeSh0cl9vYmplY3QpKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkQmxvY2tEYXRlKCkge1xuICAgIHJldHVybiB0aW1lU3RyaW5nVG9EYXRlKGhlYWRfYmxvY2tfdGltZV9zdHJpbmcpO1xufVxuXG5mdW5jdGlvbiB0aW1lU3RyaW5nVG9EYXRlKHRpbWVfc3RyaW5nKSB7XG4gICAgaWYgKCF0aW1lX3N0cmluZykgcmV0dXJuIG5ldyBEYXRlKFwiMTk3MC0wMS0wMVQwMDowMDowMC4wMDBaXCIpO1xuICAgIGlmICghL1okLy50ZXN0KHRpbWVfc3RyaW5nKSkgLy9kb2VzIG5vdCBlbmQgaW4gWlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvbm9tZXgvZ3JhcGhlbmUvaXNzdWVzLzM2OFxuICAgICAgICB0aW1lX3N0cmluZyA9IHRpbWVfc3RyaW5nICsgXCJaXCI7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVfc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbkJ1aWxkZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL1RyYW5zYWN0aW9uQnVpbGRlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVyO1xubW9kdWxlLmV4cG9ydHMgPSBoZWxwZXIgPSB7fTtcblxudmFyIHNlY3VyZVJhbmRvbSA9IHJlcXVpcmUoJ3NlY3VyZS1yYW5kb20nKTtcblxuLy9Qcm9taXNlID0gcmVxdWlyZSAnLi4vY29tbW9uL1Byb21pc2UnXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKSxcbiAgICBMb25nID0gX3JlcXVpcmUuTG9uZztcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi8uLi9lY2NcIiksXG4gICAgU2lnbmF0dXJlID0gX3JlcXVpcmUyLlNpZ25hdHVyZTtcblxudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi8uLi9zZXJpYWxpemVyXCIpLFxuICAgIG9wcyA9IF9yZXF1aXJlMy5vcHM7XG5cbmhlbHBlci51bmlxdWVfbm9uY2VfZW50cm9weSA9IG51bGw7XG5oZWxwZXIudW5pcXVlX25vbmNlX3VpbnQ2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cm9weSA9IGhlbHBlci51bmlxdWVfbm9uY2VfZW50cm9weSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAoaGVscGVyLnVuaXF1ZV9ub25jZV9lbnRyb3B5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcuLi4gc2VjdXJlUmFuZG9tLnJhbmRvbVVpbnQ4QXJyYXkoMSlbMF0nLHNlY3VyZVJhbmRvbS5yYW5kb21VaW50OEFycmF5KDEpWzBdKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlY3VyZVJhbmRvbS5yYW5kb21VaW50OEFycmF5KDEpWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiArK2hlbHBlci51bmlxdWVfbm9uY2VfZW50cm9weSAlIDI1NjtcbiAgICAgICAgfVxuICAgIH0oKTtcbiAgICB2YXIgbG9uZyA9IExvbmcuZnJvbU51bWJlcihEYXRlLm5vdygpKTtcbiAgICAvL2NvbnNvbGUubG9nKCd1bmlxdWVfbm9uY2VfdWludDY0IGRhdGVcXHQnLEJ5dGVCdWZmZXIuYWxsb2NhdGUoOCkud3JpdGVVaW50NjQobG9uZykudG9IZXgoMCkpXG4gICAgLy9jb25zb2xlLmxvZygndW5pcXVlX25vbmNlX3VpbnQ2NCBlbnRyb3B5XFx0JyxCeXRlQnVmZmVyLmFsbG9jYXRlKDgpLndyaXRlVWludDY0KExvbmcuZnJvbU51bWJlcihlbnRyb3B5KSkudG9IZXgoMCkpXG4gICAgbG9uZyA9IGxvbmcuc2hpZnRMZWZ0KDgpLm9yKExvbmcuZnJvbU51bWJlcihlbnRyb3B5KSk7XG4gICAgLy9jb25zb2xlLmxvZygndW5pcXVlX25vbmNlX3VpbnQ2NCBzaGlmdDhcXHQnLEJ5dGVCdWZmZXIuYWxsb2NhdGUoOCkud3JpdGVVaW50NjQobG9uZykudG9IZXgoMCkpXG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn07XG5cbi8qIFRvZG8sIHNldCBmZWVzICovXG5oZWxwZXIudG9fanNvbiA9IGZ1bmN0aW9uICh0cikge1xuICAgIHZhciBicm9hZGNhc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0ciwgYnJvYWRjYXN0KSB7XG4gICAgICAgIHZhciB0cl9vYmplY3QgPSBvcHMuc2lnbmVkX3RyYW5zYWN0aW9uLnRvT2JqZWN0KHRyKTtcbiAgICAgICAgaWYgKGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgdmFyIG5ldCA9IEFwaXMuaW5zdGFuY2UoKS5uZXR3b3JrX2FwaSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy4uLiB0cl9vYmplY3QnLCBKU09OLnN0cmluZ2lmeSh0cl9vYmplY3QpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXQuZXhlYyhcImJyb2FkY2FzdF90cmFuc2FjdGlvblwiLCBbdHJfb2JqZWN0XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJfb2JqZWN0O1xuICAgICAgICB9XG4gICAgfSh0ciwgYnJvYWRjYXN0KTtcbn07XG5cbmhlbHBlci5zaWduZWRfdHJfanNvbiA9IGZ1bmN0aW9uICh0ciwgcHJpdmF0ZV9rZXlzKSB7XG4gICAgdmFyIHRyX2J1ZmZlciA9IG9wcy50cmFuc2FjdGlvbi50b0J1ZmZlcih0cik7XG4gICAgdHIgPSBvcHMudHJhbnNhY3Rpb24udG9PYmplY3QodHIpO1xuICAgIHRyLnNpZ25hdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBwcml2YXRlX2tleXMubGVuZ3RoID8gaSA8IHByaXZhdGVfa2V5cy5sZW5ndGggOiBpID4gcHJpdmF0ZV9rZXlzLmxlbmd0aDsgMCA8IHByaXZhdGVfa2V5cy5sZW5ndGggPyBpKysgOiBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlX2tleSA9IHByaXZhdGVfa2V5c1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFNpZ25hdHVyZS5zaWduQnVmZmVyKHRyX2J1ZmZlciwgcHJpdmF0ZV9rZXkpLnRvSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSgpO1xuICAgIHJldHVybiB0cjtcbn07XG5cbmhlbHBlci5leHBpcmVfaW5fbWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIG1pbiAqIDYwO1xufTtcblxuaGVscGVyLnNlY29uZHNfZnJvbV9ub3cgPSBmdW5jdGlvbiAodGltZW91dF9zZWMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyB0aW1lb3V0X3NlYztcbn07XG5cbi8qKlxuICAgIFByaW50IHRvIHRoZSBjb25zb2xlIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbnkgb2JqZWN0IGluXG4gICAgQGdyYXBoZW5lL3NlcmlhbGl6ZXIgeyB0eXBlcyB9XG4qL1xuaGVscGVyLnRlbXBsYXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZSkge1xuICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IHRydWUgfTtcblxuICAgIHZhciBzbyA9IHR5cGVbc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lXTtcbiAgICBpZiAoIXNvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlICcgKyBzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gc28udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1Zyk7XG59O1xuXG5oZWxwZXIubmV3X29wZXJhdGlvbiA9IGZ1bmN0aW9uIChzZXJpYWxpemVyX29wZXJhdGlvbl90eXBlX25hbWUpIHtcbiAgICB2YXIgc28gPSB0eXBlW3NlcmlhbGl6ZXJfb3BlcmF0aW9uX3R5cGVfbmFtZV07XG4gICAgaWYgKCFzbykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZSAnICsgc2VyaWFsaXplcl9vcGVyYXRpb25fdHlwZV9uYW1lKTtcbiAgICB9XG4gICAgdmFyIG9iamVjdCA9IHNvLnRvT2JqZWN0KHVuZGVmaW5lZCwgeyB1c2VfZGVmYXVsdDogdHJ1ZSwgYW5ub3RhdGU6IHRydWUgfSk7XG4gICAgcmV0dXJuIHNvLmZyb21PYmplY3Qob2JqZWN0KTtcbn07XG5cbmhlbHBlci5pbnN0YW5jZSA9IGZ1bmN0aW9uIChPYmplY3RJZCkge1xuICAgIHJldHVybiBPYmplY3RJZC5zdWJzdHJpbmcoXCIwLjAuXCIubGVuZ3RoKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvY2hhaW4vc3JjL1RyYW5zYWN0aW9uSGVscGVyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9jaGFpbi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWRkcmVzczogcmVxdWlyZShcIi4vc3JjL2FkZHJlc3NcIiksXG4gICAgQWVzOiByZXF1aXJlKFwiLi9zcmMvYWVzXCIpLFxuICAgIFByaXZhdGVLZXk6IHJlcXVpcmUoXCIuL3NyYy9Qcml2YXRlS2V5XCIpLFxuICAgIFB1YmxpY0tleTogcmVxdWlyZShcIi4vc3JjL1B1YmxpY0tleVwiKSxcbiAgICBTaWduYXR1cmU6IHJlcXVpcmUoXCIuL3NyYy9zaWduYXR1cmVcIiksXG4gICAgYnJhaW5LZXk6IHJlcXVpcmUoXCIuL3NyYy9CcmFpbktleVwiKSxcbiAgICBoYXNoOiByZXF1aXJlKFwiLi9zcmMvaGFzaFwiKSxcbiAgICBrZXk6IHJlcXVpcmUoXCIuL3NyYy9LZXlVdGlsc1wiKVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2MvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemUoYnJhaW5LZXkpIHtcbiAgICBpZiAodHlwZW9mIGJyYWluS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGJyYWluS2V5XCIpO1xuICAgIH1cbiAgICBicmFpbktleSA9IGJyYWluS2V5LnRyaW0oKTtcbiAgICByZXR1cm4gYnJhaW5LZXkuc3BsaXQoL1tcXHRcXG5cXHZcXGZcXHIgXSsvKS5qb2luKCcgJyk7XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvQnJhaW5LZXkuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIGtleTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9Qcml2YXRlS2V5Jyk7XG52YXIgUHVibGljS2V5ID0gcmVxdWlyZSgnLi9QdWJsaWNLZXknKTtcbnZhciBBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgQWVzID0gcmVxdWlyZSgnLi9hZXMnKTtcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbi8vIHZhciBkaWN0aW9uYXJ5ID0gcmVxdWlyZSgnLi9kaWN0aW9uYXJ5X2VuJyk7XG52YXIgc2VjdXJlUmFuZG9tID0gcmVxdWlyZSgnc2VjdXJlLXJhbmRvbScpO1xudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcblxuLy8gaGFzaCBmb3IgLjI1IHNlY29uZFxudmFyIEhBU0hfUE9XRVJfTUlMTFMgPSAyNTA7XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5ID0ge1xuXG4gICAgLyoqIFVzZXMgMSBzZWNvbmQgb2YgaGFzaGluZyBwb3dlciB0byBjcmVhdGUgYSBrZXkvcGFzc3dvcmQgY2hlY2tzdW0uICBBblxuICAgIGltcGxlbWVudGF0aW9uIGNhbiByZS1jYWxsIHRoaXMgbWV0aG9kIHdpdGggdGhlIHNhbWUgcGFzc3dvcmQgdG8gcmUtbWF0Y2hcbiAgICB0aGUgc3RyZW5ndGggb2YgdGhlIENQVSAoZWl0aGVyIGFmdGVyIG1vdmluZyBmcm9tIGEgZGVza3RvcCB0byBhIG1vYmlsZSxcbiAgICBtb2JpbGUgdG8gZGVza3RvcCwgb3IgTiB5ZWFycyBmcm9tIG5vdyB3aGVuIENQVXMgYXJlIHByZXN1bWFibHkgc3Ryb25nZXIpLlxuICAgICBBIHNhbHQgaXMgdXNlZCBmb3IgYWxsIHRoZSBub3JtYWwgcmVhc29ucy4uLlxuICAgICBAcmV0dXJuIG9iamVjdCB7XG4gICAgICAgIGFlc19wcml2YXRlOiBBZXMsXG4gICAgICAgIGNoZWNrc3VtOiBcIntoYXNoX2l0ZXJhdGlvbl9jb3VudH0se3NhbHR9LHtjaGVja3N1bX1cIlxuICAgIH1cbiAgICAqL1xuICAgIGFlc19jaGVja3N1bTogZnVuY3Rpb24gYWVzX2NoZWNrc3VtKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBwYXNzd29yZCA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBcInBhc3N3b3JkIHN0cmluZyByZXF1aXJlZFwiKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbHQgPSBzZWN1cmVSYW5kb20ucmFuZG9tQnVmZmVyKDQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICB2YXIgc2VjcmV0ID0gc2FsdCArIHBhc3N3b3JkO1xuICAgICAgICAvLyBoYXNoIGZvciAuMSBzZWNvbmRcbiAgICAgICAgdmFyIHN0YXJ0X3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0X3QgPCBIQVNIX1BPV0VSX01JTExTKSB7XG4gICAgICAgICAgICBzZWNyZXQgPSBoYXNoLnNoYTI1NihzZWNyZXQpO1xuICAgICAgICAgICAgaXRlcmF0aW9ucyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoc2VjcmV0KTtcbiAgICAgICAgdmFyIGNoZWNrc3VtX3N0cmluZyA9IFtpdGVyYXRpb25zLCBzYWx0LnRvU3RyaW5nKCdoZXgnKSwgY2hlY2tzdW0uc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpXS5qb2luKCcsJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgYWVzX3ByaXZhdGU6IEFlcy5mcm9tU2VlZChzZWNyZXQpLFxuICAgICAgICAgICAgY2hlY2tzdW06IGNoZWNrc3VtX3N0cmluZ1xuICAgICAgICB9O1xuICAgIH0sXG5cblxuICAgIC8qKiBQcm92aWRlIGEgbWF0Y2hpbmcgcGFzc3dvcmQgYW5kIGtleV9jaGVja3N1bS4gIEEgXCJ3cm9uZyBwYXNzd29yZFwiXG4gICAgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBwYXNzd29yZCBkb2VzIG5vdCBtYXRjaC4gIElmIHRoaXMgbWV0aG9kIHRha2VzXG4gICAgbXVjaCBtb3JlIG9yIGxlc3MgdGhhbiAxIHNlY29uZCB0byByZXR1cm4sIG9uZSBzaG91bGQgY29uc2lkZXIgdXBkYXRpbmdcbiAgICBhbGwgZW5jeXJwdGVkIGZpZWxkcyB1c2luZyBhIG5ldyBrZXkua2V5X2NoZWNrc3VtLlxuICAgICovXG4gICAgYWVzX3ByaXZhdGU6IGZ1bmN0aW9uIGFlc19wcml2YXRlKHBhc3N3b3JkLCBrZXlfY2hlY2tzdW0pIHtcbiAgICAgICAgdmFyIF9rZXlfY2hlY2tzdW0kc3BsaXQgPSBrZXlfY2hlY2tzdW0uc3BsaXQoJywnKSxcbiAgICAgICAgICAgIF9rZXlfY2hlY2tzdW0kc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX2tleV9jaGVja3N1bSRzcGxpdCwgMyksXG4gICAgICAgICAgICBpdGVyYXRpb25zID0gX2tleV9jaGVja3N1bSRzcGxpdDJbMF0sXG4gICAgICAgICAgICBzYWx0ID0gX2tleV9jaGVja3N1bSRzcGxpdDJbMV0sXG4gICAgICAgICAgICBjaGVja3N1bSA9IF9rZXlfY2hlY2tzdW0kc3BsaXQyWzJdO1xuXG4gICAgICAgIHZhciBzZWNyZXQgPSBzYWx0ICsgcGFzc3dvcmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAwIDwgaXRlcmF0aW9ucyA/IGkgPCBpdGVyYXRpb25zIDogaSA+IGl0ZXJhdGlvbnM7IDAgPCBpdGVyYXRpb25zID8gaSsrIDogaSsrKSB7XG4gICAgICAgICAgICBzZWNyZXQgPSBoYXNoLnNoYTI1NihzZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihzZWNyZXQpO1xuICAgICAgICBpZiAoIShuZXdfY2hlY2tzdW0uc2xpY2UoMCwgNCkudG9TdHJpbmcoJ2hleCcpID09PSBjaGVja3N1bSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndyb25nIHBhc3N3b3JkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZXMuZnJvbVNlZWQoc2VjcmV0KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgICAgQSB3ZWVrIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGNhbiBydW4gb3V0IG9mIGVudHJvcHkuICBUaGlzIHNob3VsZCBlbnN1cmUgZXZlbiB0aGUgd29yc3QgcmFuZG9tIG51bWJlciBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHJlYXNvbmFibHkgc2FmZS5cbiAgICAgICAgIEBwYXJhbTEgc3RyaW5nIGVudHJvcHkgb2YgYXQgbGVhc3QgMzIgYnl0ZXNcbiAgICAqL1xuICAgIHJhbmRvbTMyQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gcmFuZG9tMzJCeXRlQnVmZmVyKCkge1xuICAgICAgICB2YXIgZW50cm9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5icm93c2VyRW50cm9weSgpO1xuXG5cbiAgICAgICAgaWYgKCEodHlwZW9mIGVudHJvcHkgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIHJlcXVpcmVkIGZvciBlbnRyb3B5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJvcHkubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGluZyBhdCBsZWFzdCAzMiBieXRlcyBvZiBlbnRyb3B5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0X3QgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRfdCA8IEhBU0hfUE9XRVJfTUlMTFMpIHtcbiAgICAgICAgICAgIGVudHJvcHkgPSBoYXNoLnNoYTI1NihlbnRyb3B5KTtcbiAgICAgICAgfXZhciBoYXNoX2FycmF5ID0gW107XG4gICAgICAgIGhhc2hfYXJyYXkucHVzaChlbnRyb3B5KTtcblxuICAgICAgICAvLyBIYXNoaW5nIGZvciAxIHNlY29uZCBtYXkgaGVscHMgdGhlIGNvbXB1dGVyIGlzIG5vdCBsb3cgb24gZW50cm9weSAodGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBiYWNrLXRvLWJhY2spLlxuICAgICAgICBoYXNoX2FycmF5LnB1c2goc2VjdXJlUmFuZG9tLnJhbmRvbUJ1ZmZlcigzMikpO1xuXG4gICAgICAgIHJldHVybiBoYXNoLnNoYTI1NihCdWZmZXIuY29uY2F0KGhhc2hfYXJyYXkpKTtcbiAgICB9LFxuXG5cbiAgICBzdWdnZXN0X2JyYWluX2tleTogZnVuY3Rpb24gc3VnZ2VzdF9icmFpbl9rZXkoKSB7XG4gICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBcIixcIjtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuYnJvd3NlckVudHJvcHkoKTtcblxuXG4gICAgICAgIHZhciByYW5kb21CdWZmZXIgPSB0aGlzLnJhbmRvbTMyQnl0ZUJ1ZmZlcihlbnRyb3B5KTtcblxuICAgICAgICB2YXIgd29yZF9jb3VudCA9IDE2O1xuICAgICAgICB2YXIgZGljdGlvbmFyeV9saW5lcyA9IGRpY3Rpb25hcnkuc3BsaXQoJywnKTtcblxuICAgICAgICBpZiAoIShkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCA9PT0gNDk3NDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyAnICsgNDk3NDQgKyAnIGJ1dCBnb3QgJyArIGRpY3Rpb25hcnlfbGluZXMubGVuZ3RoICsgJyBkaWN0aW9uYXJ5IHdvcmRzJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnJhaW5rZXkgPSBbXTtcbiAgICAgICAgdmFyIGVuZCA9IHdvcmRfY291bnQgKiAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpICs9IDIpIHtcblxuICAgICAgICAgICAgLy8gcmFuZG9tQnVmZmVyIGhhcyAyNTYgYml0cyAvIDE2IGJpdHMgcGVyIHdvcmQgPT0gMTYgd29yZHNcbiAgICAgICAgICAgIHZhciBudW0gPSAocmFuZG9tQnVmZmVyW2ldIDw8IDgpICsgcmFuZG9tQnVmZmVyW2kgKyAxXTtcblxuICAgICAgICAgICAgLy8gY29udmVydCBpbnRvIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSAoaW5jbHVzaXZlKVxuICAgICAgICAgICAgdmFyIHJuZE11bHRpcGxpZXIgPSBudW0gLyBNYXRoLnBvdygyLCAxNik7XG4gICAgICAgICAgICB2YXIgd29yZEluZGV4ID0gTWF0aC5yb3VuZChkaWN0aW9uYXJ5X2xpbmVzLmxlbmd0aCAqIHJuZE11bHRpcGxpZXIpO1xuXG4gICAgICAgICAgICBicmFpbmtleS5wdXNoKGRpY3Rpb25hcnlfbGluZXNbd29yZEluZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplX2JyYWluS2V5KGJyYWlua2V5LmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIGdldF9yYW5kb21fa2V5OiBmdW5jdGlvbiBnZXRfcmFuZG9tX2tleShlbnRyb3B5KSB7XG4gICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIodGhpcy5yYW5kb20zMkJ5dGVCdWZmZXIoZW50cm9weSkpO1xuICAgIH0sXG4gICAgZ2V0X2JyYWluUHJpdmF0ZUtleTogZnVuY3Rpb24gZ2V0X2JyYWluUHJpdmF0ZUtleShicmFpbktleSkge1xuICAgICAgICB2YXIgc2VxdWVuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgICAgaWYgKHNlcXVlbmNlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXF1ZW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmFpbktleSA9IGtleS5ub3JtYWxpemVfYnJhaW5LZXkoYnJhaW5LZXkpO1xuICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKGhhc2guc2hhMjU2KGhhc2guc2hhNTEyKGJyYWluS2V5ICsgXCIgXCIgKyBzZXF1ZW5jZSkpKTtcbiAgICB9LFxuXG5cbiAgICAvLyBUdXJuIGludmlzaWJsZSBzcGFjZSBsaWtlIGNoYXJhY3RlcnMgaW50byBhIHNpbmdsZSBzcGFjZVxuICAgIG5vcm1hbGl6ZV9icmFpbktleTogZnVuY3Rpb24gbm9ybWFsaXplX2JyYWluS2V5KGJyYWluS2V5KSB7XG4gICAgICAgIGlmICghKHR5cGVvZiBicmFpbktleSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVxdWlyZWQgZm9yIGJyYWluS2V5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJhaW5LZXkgPSBicmFpbktleS50cmltKCk7XG4gICAgICAgIHJldHVybiBicmFpbktleS5zcGxpdCgvW1xcdFxcblxcdlxcZlxcciBdKy8pLmpvaW4oJyAnKTtcbiAgICB9LFxuICAgIGJyb3dzZXJFbnRyb3B5OiBmdW5jdGlvbiBicm93c2VyRW50cm9weSgpIHtcblxuICAgICAgICB2YXIgZW50cm9weVN0ciA9IFwiXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbnRyb3B5U3RyID0gbmV3IERhdGUoKS50b1N0cmluZygpICsgXCIgXCIgKyB3aW5kb3cuc2NyZWVuLmhlaWdodCArIFwiIFwiICsgd2luZG93LnNjcmVlbi53aWR0aCArIFwiIFwiICsgd2luZG93LnNjcmVlbi5jb2xvckRlcHRoICsgXCIgXCIgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgKyBcIiBcIiArIHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCArIFwiIFwiICsgd2luZG93LnNjcmVlbi5waXhlbERlcHRoICsgbmF2aWdhdG9yLmxhbmd1YWdlICsgXCIgXCIgKyB3aW5kb3cubG9jYXRpb24gKyBcIiBcIiArIHdpbmRvdy5oaXN0b3J5Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1pbWVUeXBlOyBpIDwgbmF2aWdhdG9yLm1pbWVUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gbmF2aWdhdG9yLm1pbWVUeXBlc1tpXTtcbiAgICAgICAgICAgICAgICBlbnRyb3B5U3RyICs9IG1pbWVUeXBlLmRlc2NyaXB0aW9uICsgXCIgXCIgKyBtaW1lVHlwZS50eXBlICsgXCIgXCIgKyBtaW1lVHlwZS5zdWZmaXhlcyArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJJTkZPXFx0YnJvd3NlckVudHJvcHkgZ2F0aGVyZWRcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvL25vZGVqczpSZWZlcmVuY2VFcnJvcjogd2luZG93IGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICBlbnRyb3B5U3RyID0gaGFzaC5zaGEyNTYobmV3IERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiID0gbmV3IEJ1ZmZlcihlbnRyb3B5U3RyKTtcbiAgICAgICAgZW50cm9weVN0ciArPSBiLnRvU3RyaW5nKCdiaW5hcnknKSArIFwiIFwiICsgbmV3IERhdGUoKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZW50cm9weVN0cjtcbiAgICB9LFxuXG5cbiAgICAvLyBAcmV0dXJuIGFycmF5IG9mIDUgbGVnYWN5IGFkZHJlc3NlcyBmb3IgYSBwdWJrZXkgc3RyaW5nIHBhcmFtZXRlci5cbiAgICBhZGRyZXNzZXM6IGZ1bmN0aW9uIGFkZHJlc3NlcyhwdWJrZXkpIHtcbiAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICB2YXIgcHVibGljX2tleSA9IFB1YmxpY0tleS5mcm9tUHVibGljS2V5U3RyaW5nKHB1YmtleSwgYWRkcmVzc19wcmVmaXgpO1xuICAgICAgICAvLyBTIEwgTyBXXG4gICAgICAgIHZhciBhZGRyZXNzX3N0cmluZyA9IFtBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgZmFsc2UsIDApLnRvU3RyaW5nKGFkZHJlc3NfcHJlZml4KSwgLy8gYnRjX3VuY29tcHJlc3NlZFxuICAgICAgICBBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgdHJ1ZSwgMCkudG9TdHJpbmcoYWRkcmVzc19wcmVmaXgpLCAvLyBidGNfY29tcHJlc3NlZFxuICAgICAgICBBZGRyZXNzLmZyb21QdWJsaWMocHVibGljX2tleSwgZmFsc2UsIDU2KS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIHB0c191bmNvbXByZXNzZWRcbiAgICAgICAgQWRkcmVzcy5mcm9tUHVibGljKHB1YmxpY19rZXksIHRydWUsIDU2KS50b1N0cmluZyhhZGRyZXNzX3ByZWZpeCksIC8vIHB0c19jb21wcmVzc2VkXG4gICAgICAgIHB1YmxpY19rZXkudG9BZGRyZXNzU3RyaW5nKGFkZHJlc3NfcHJlZml4KSAvLyBidHNfc2hvcnQsIG1vc3QgcmVjZW50IGZvcm1hdFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYWRkcmVzc19zdHJpbmc7XG4gICAgfVxufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL0tleVV0aWxzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgZWN1cnZlID0gcmVxdWlyZSgnZWN1cnZlJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2VjdXJ2ZScpLFxuICAgIFBvaW50ID0gX3JlcXVpcmUuUG9pbnQsXG4gICAgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnYnM1OCcpLFxuICAgIGVuY29kZSA9IF9yZXF1aXJlMi5lbmNvZGUsXG4gICAgZGVjb2RlID0gX3JlcXVpcmUyLmRlY29kZTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKCcuL1B1YmxpY0tleScpO1xudmFyIGRlZXBFcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuXG52YXIgRyA9IHNlY3AyNTZrMS5HLFxuICAgIG4gPSBzZWNwMjU2azEubjtcblxudmFyIFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgICAgQHByaXZhdGUgc2VlIHN0YXRpYyBmdW5jdGlvbnNcbiAgICAgICAgQHBhcmFtIHtCaWdJbnRlZ2VyfVxuICAgICovXG4gICAgZnVuY3Rpb24gUHJpdmF0ZUtleShkKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcml2YXRlS2V5KTtcblxuICAgICAgICB0aGlzLmQgPSBkO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQcml2YXRlS2V5LCBbe1xuICAgICAgICBrZXk6ICd0b1dpZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1dpZigpIHtcbiAgICAgICAgICAgIHZhciBwcml2YXRlX2tleSA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrc3VtIGluY2x1ZGVzIHRoZSB2ZXJzaW9uXG4gICAgICAgICAgICBwcml2YXRlX2tleSA9IEJ1ZmZlci5jb25jYXQoW25ldyBCdWZmZXIoWzB4ODBdKSwgcHJpdmF0ZV9rZXldKTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IGhhc2guc2hhMjU2KHByaXZhdGVfa2V5KTtcbiAgICAgICAgICAgIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoY2hlY2tzdW0pO1xuICAgICAgICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBwcml2YXRlX3dpZiA9IEJ1ZmZlci5jb25jYXQoW3ByaXZhdGVfa2V5LCBjaGVja3N1bV0pO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZShwcml2YXRlX3dpZik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEByZXR1cm4ge1BvaW50fVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1B1YmxpY0tleVBvaW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHVibGljS2V5UG9pbnQoKSB7XG4gICAgICAgICAgICB2YXIgUTtcbiAgICAgICAgICAgIHJldHVybiBRID0gc2VjcDI1NmsxLkcubXVsdGlwbHkodGhpcy5kKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdWJsaWNLZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9QdWJsaWNLZXkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGljX2tleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1YmxpY19rZXkgPSBQdWJsaWNLZXkuZnJvbVBvaW50KHRoaXMudG9QdWJsaWNLZXlQb2ludCgpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kLnRvQnVmZmVyKDMyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBFQ0lFUyAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRfc2hhcmVkX3NlY3JldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgbGVnYWN5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgICAgICAgICAgcHVibGljX2tleSA9IHRvUHVibGljKHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgdmFyIEtCID0gcHVibGljX2tleS50b1VuY29tcHJlc3NlZCgpLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgS0JQID0gUG9pbnQuZnJvbUFmZmluZShzZWNwMjU2azEsIEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihLQi5zbGljZSgxLCAzMykpLCAvLyB4XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoS0Iuc2xpY2UoMzMsIDY1KSkgLy8geVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIFAgPSBLQlAubXVsdGlwbHkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKHIpKTtcbiAgICAgICAgICAgIHZhciBTID0gUC5hZmZpbmVYLnRvQnVmZmVyKHsgc2l6ZTogMzIgfSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdGhlIGlucHV0IHRvIHNoYTUxMiBtdXN0IGJlIGV4YWN0bHkgMzItYnl0ZXMsIHRvIG1hdGNoIHRoZSBjKysgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgIG9mIGdldF9zaGFyZWRfc2VjcmV0LiAgUmlnaHQgbm93IFMgd2lsbCBiZSBzaG9ydGVyIGlmIHRoZSBtb3N0IHNpZ25pZmljYW50XG4gICAgICAgICAgICBieXRlKHMpIGlzIHplcm8uICBQYWQgaXQgYmFjayB0byB0aGUgZnVsbCAzMi1ieXRlc1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghbGVnYWN5ICYmIFMubGVuZ3RoIDwgMzIpIHtcbiAgICAgICAgICAgICAgICBwYWQgPSBuZXcgQnVmZmVyKDMyIC0gUy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgICAgICAgICAgUyA9IEJ1ZmZlci5jb25jYXQoW3BhZCwgU10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTSEE1MTIgdXNlZCBpbiBFQ0lFU1xuICAgICAgICAgICAgcmV0dXJuIGhhc2guc2hhNTEyKFMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLyoqIEVDSUVTIChkb2VzIG5vdCBhbHdheXMgbWF0Y2ggdGhlIFBvaW50LmZyb21BZmZpbmUgdmVyc2lvbiBhYm92ZSkgKi9cbiAgICAgICAgLy8gZ2V0X3NoYXJlZF9zZWNyZXQocHVibGljX2tleSl7XG4gICAgICAgIC8vICAgICBwdWJsaWNfa2V5ID0gdG9QdWJsaWMocHVibGljX2tleSlcbiAgICAgICAgLy8gICAgIHZhciBQID0gcHVibGljX2tleS5RLm11bHRpcGx5KCB0aGlzLmQgKTtcbiAgICAgICAgLy8gICAgIHZhciBTID0gUC5hZmZpbmVYLnRvQnVmZmVyKHtzaXplOiAzMn0pO1xuICAgICAgICAvLyAgICAgLy8gRUNJRVMsIGFkZHMgYW4gZXh0cmEgc2hhNTEyXG4gICAgICAgIC8vICAgICByZXR1cm4gaGFzaC5zaGE1MTIoUyk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvKiogQHRocm93cyB7RXJyb3J9IC0gb3ZlcmZsb3cgb2YgdGhlIGtleSBjb3VsZCBub3QgYmUgZGVyaXZlZCAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGlsZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMudG9QdWJsaWNLZXkoKS50b0J1ZmZlcigpLCBvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGhhc2guc2hhMjU2KG9mZnNldCk7XG4gICAgICAgICAgICB2YXIgYyA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihvZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAoYy5jb21wYXJlVG8obikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IHdlbnQgb3V0IG9mIGJvdW5kcywgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICB2YXIgZGVyaXZlZCA9IHRoaXMuZC5hZGQoYyk7IC8vLm1vZChuKVxuXG4gICAgICAgICAgICBpZiAoZGVyaXZlZC5zaWdudW0oKSA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgb2Zmc2V0IGRlcml2ZWQgdG8gYW4gaW52YWxpZCBrZXksIHRyeSBhZ2FpblwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlS2V5KGRlcml2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPGhlbHBlcl9mdW5jdGlvbnM+ICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J5dGVCdWZmZXIoKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPC9oZWxwZXJfZnVuY3Rpb25zPiAqL1xuXG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgcGFyYW10ZXIgdG8gYmUgYSBCdWZmZXIgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgzMiAhPT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOOiBFeHBlY3RpbmcgMzIgYnl0ZXMsIGluc3RlYWQgZ290ICcgKyBidWYubGVuZ3RoICsgJywgc3RhY2sgdHJhY2U6JywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBidWZmZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1ZikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBhcmcge3N0cmluZ30gc2VlZCAtIGFueSBsZW5ndGggc3RyaW5nLiAgVGhpcyBpcyBwcml2YXRlLCB0aGUgc2FtZSBzZWVkIHByb2R1Y2VzIHRoZSBzYW1lIHByaXZhdGUga2V5IGV2ZXJ5IHRpbWUuICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tU2VlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZV9wcml2YXRlX2tleVxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHNlZWQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKGhhc2guc2hhMjU2KHNlZWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9IFdhbGxldCBJbXBvcnQgRm9ybWF0IChzdGlsbCBhIHNlY3JldCwgTm90IGVuY3J5cHRlZCkgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVdpZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tV2lmKF9wcml2YXRlX3dpZikge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVfd2lmID0gbmV3IEJ1ZmZlcihkZWNvZGUoX3ByaXZhdGVfd2lmKSk7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHByaXZhdGVfd2lmLnJlYWRVSW50OCgwKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgweDgwLCB2ZXJzaW9uLCAnRXhwZWN0ZWQgdmVyc2lvbiAnICsgMHg4MCArICcsIGluc3RlYWQgZ290ICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgICAgIC8vIGNoZWNrc3VtIGluY2x1ZGVzIHRoZSB2ZXJzaW9uXG4gICAgICAgICAgICB2YXIgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX3dpZi5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwcml2YXRlX3dpZi5zbGljZSgtNCk7XG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYocHJpdmF0ZV9rZXkpO1xuICAgICAgICAgICAgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYobmV3X2NoZWNrc3VtKTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBpc0VxdWFsID0gZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleS5zbGljZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBQcml2YXRlS2V5LmZyb21CdWZmZXIocHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJpdmF0ZUtleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFByaXZhdGVLZXk7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpdmF0ZUtleTtcblxudmFyIHRvUHVibGljID0gZnVuY3Rpb24gdG9QdWJsaWMoZGF0YSkge1xuICAgIHJldHVybiBkYXRhID09IG51bGwgPyBkYXRhIDogZGF0YS5RID8gZGF0YSA6IFB1YmxpY0tleS5mcm9tU3RyaW5nT3JUaHJvdyhkYXRhKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9Qcml2YXRlS2V5LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZWN1cnZlJyksXG4gICAgUG9pbnQgPSBfcmVxdWlyZS5Qb2ludCxcbiAgICBnZXRDdXJ2ZUJ5TmFtZSA9IF9yZXF1aXJlLmdldEN1cnZlQnlOYW1lO1xuXG52YXIgc2VjcDI1NmsxID0gZ2V0Q3VydmVCeU5hbWUoJ3NlY3AyNTZrMScpO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgnYnM1OCcpLFxuICAgIGVuY29kZSA9IF9yZXF1aXJlMi5lbmNvZGUsXG4gICAgZGVjb2RlID0gX3JlcXVpcmUyLmRlY29kZTtcblxudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBDaGFpbkNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi9jaGFpbi9zcmMvQ2hhaW5Db25maWdcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbnZhciBHID0gc2VjcDI1NmsxLkcsXG4gICAgbiA9IHNlY3AyNTZrMS5uO1xuXG52YXIgUHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqIEBwYXJhbSB7UG9pbnR9IHB1YmxpYyBrZXkgKi9cbiAgICBmdW5jdGlvbiBQdWJsaWNLZXkoUSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHVibGljS2V5KTtcblxuICAgICAgICB0aGlzLlEgPSBRO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQdWJsaWNLZXksIFt7XG4gICAgICAgIGtleTogJ3RvQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnVmZmVyKCkge1xuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuUSA/IHRoaXMuUS5jb21wcmVzc2VkIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuUSA9PT0gbnVsbCkgcmV0dXJuIG5ldyBCdWZmZXIoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlEuZ2V0RW5jb2RlZChjb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9VbmNvbXByZXNzZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9VbmNvbXByZXNzZWQoKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gdGhpcy5RLmdldEVuY29kZWQoZmFsc2UpO1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gUG9pbnQuZGVjb2RlRnJvbShzZWNwMjU2azEsIGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChwb2ludCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogYnRzOjpibG9ja2NoYWluOjphZGRyZXNzICh1bmlxdWUgYnV0IG5vdCBhIGZ1bGwgcHVibGljIGtleSkgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CbG9ja2NoYWluQWRkcmVzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0Jsb2NrY2hhaW5BZGRyZXNzKCkge1xuICAgICAgICAgICAgdmFyIHB1Yl9idWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICAgICAgICB2YXIgcHViX3NoYSA9IGhhc2guc2hhNTEyKHB1Yl9idWYpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEFsaWFzIGZvciB7QGxpbmsgdG9QdWJsaWNLZXlTdHJpbmd9ICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9QdWJsaWNLZXlTdHJpbmcoYWRkcmVzc19wcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBGdWxsIHB1YmxpYyBrZXlcbiAgICAgICAgICAgIHtyZXR1cm59IHN0cmluZ1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b1B1YmxpY0tleVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1B1YmxpY0tleVN0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzX3ByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogQ2hhaW5Db25maWcuYWRkcmVzc19wcmVmaXg7XG5cbiAgICAgICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAocHViX2J1Zik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IEJ1ZmZlci5jb25jYXQoW3B1Yl9idWYsIGNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzc19wcmVmaXggKyBlbmNvZGUoYWRkeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gcHVibGljX2tleSAtIGxpa2UgR1BIWHl6Li4uXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IGFkZHJlc3NfcHJlZml4IC0gbGlrZSBHUEhcbiAgICAgICAgICAgIEByZXR1cm4gUHVibGljS2V5IG9yIGBudWxsYCAoaWYgdGhlIHB1YmxpY19rZXkgc3RyaW5nIGlzIGludmFsaWQpXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQWRkcmVzc1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FkZHJlc3NTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgICAgICB2YXIgcHViX2J1ZiA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBwdWJfc2hhID0gaGFzaC5zaGE1MTIocHViX2J1Zik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKHB1Yl9zaGEpO1xuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAoYWRkeSk7XG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzX3ByZWZpeCArIGVuY29kZShhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9QdHNBZGR5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvUHRzQWRkeSgpIHtcbiAgICAgICAgICAgIHZhciBwdWJfYnVmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgICAgICAgICAgdmFyIHB1Yl9zaGEgPSBoYXNoLnNoYTI1NihwdWJfYnVmKTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gaGFzaC5yaXBlbWQxNjAocHViX3NoYSk7XG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbbmV3IEJ1ZmZlcihbMHgzOF0pLCBhZGR5XSk7IC8vdmVyc2lvbiA1NihkZWNpbWFsKVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihhZGR5KTtcbiAgICAgICAgICAgIGNoZWNrc3VtID0gaGFzaC5zaGEyNTYoY2hlY2tzdW0pO1xuXG4gICAgICAgICAgICBhZGR5ID0gQnVmZmVyLmNvbmNhdChbYWRkeSwgY2hlY2tzdW0uc2xpY2UoMCwgNCldKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGUoYWRkeSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoaWxkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoaWxkKG9mZnNldCkge1xuXG4gICAgICAgICAgICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKG9mZnNldCksIFwiQnVmZmVyIHJlcXVpcmVkOiBvZmZzZXRcIik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Zmc2V0Lmxlbmd0aCwgMzIsIFwib2Zmc2V0IGxlbmd0aFwiKTtcblxuICAgICAgICAgICAgb2Zmc2V0ID0gQnVmZmVyLmNvbmNhdChbdGhpcy50b0J1ZmZlcigpLCBvZmZzZXRdKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGhhc2guc2hhMjU2KG9mZnNldCk7XG5cbiAgICAgICAgICAgIHZhciBjID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKG9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChjLmNvbXBhcmVUbyhuKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgd2VudCBvdXQgb2YgYm91bmRzLCB0cnkgYWdhaW5cIik7XG5cbiAgICAgICAgICAgIHZhciBjRyA9IEcubXVsdGlwbHkoYyk7XG4gICAgICAgICAgICB2YXIgUXByaW1lID0gdGhpcy5RLmFkZChjRyk7XG5cbiAgICAgICAgICAgIGlmIChzZWNwMjU2azEuaXNJbmZpbml0eShRcHJpbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGlsZCBvZmZzZXQgZGVyaXZlZCB0byBhbiBpbnZhbGlkIGtleSwgdHJ5IGFnYWluXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21Qb2ludChRcHJpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPEhFWD4gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBiID0gbmV3IEJ5dGVCdWZmZXIoQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZLCBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4pO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRCeXRlQnVmZmVyKGIpO1xuICAgICAgICAgICAgcmV0dXJuIGIuY29weSgwLCBiLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAnZnJvbUJpbmFyeScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQmluYXJ5KGJpbikge1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKG5ldyBCdWZmZXIoYmluLCAnYmluYXJ5JykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHJldHVybiBuZXcgUHVibGljS2V5KG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoUG9pbnQuZGVjb2RlRnJvbShzZWNwMjU2azEsIGJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVBvaW50KHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwb2ludCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21QdWJsaWNLZXlTdHJpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVB1YmxpY0tleVN0cmluZyhwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVN0cmluZ09yVGhyb3cocHVibGljX2tleSwgYWRkcmVzc19wcmVmaXgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IHB1YmxpY19rZXkgLSBsaWtlIEdQSFh5ei4uLlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBhZGRyZXNzX3ByZWZpeCAtIGxpa2UgR1BIXG4gICAgICAgICAgICBAdGhyb3dzIHtFcnJvcn0gaWYgcHVibGljIGtleSBpcyBpbnZhbGlkXG4gICAgICAgICAgICBAcmV0dXJuIFB1YmxpY0tleVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tU3RyaW5nT3JUaHJvdycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nT3JUaHJvdyhwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc19wcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4O1xuXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gcHVibGljX2tleS5zbGljZSgwLCBhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkZHJlc3NfcHJlZml4LCBwcmVmaXgsICdFeHBlY3Rpbmcga2V5IHRvIGJlZ2luIHdpdGggJyArIGFkZHJlc3NfcHJlZml4ICsgJywgaW5zdGVhZCBnb3QgJyArIHByZWZpeCk7XG4gICAgICAgICAgICBwdWJsaWNfa2V5ID0gcHVibGljX2tleS5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwdWJsaWNfa2V5ID0gbmV3IEJ1ZmZlcihkZWNvZGUocHVibGljX2tleSksICdiaW5hcnknKTtcbiAgICAgICAgICAgIHZhciBjaGVja3N1bSA9IHB1YmxpY19rZXkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgcHVibGljX2tleSA9IHB1YmxpY19rZXkuc2xpY2UoMCwgLTQpO1xuICAgICAgICAgICAgdmFyIG5ld19jaGVja3N1bSA9IGhhc2gucmlwZW1kMTYwKHB1YmxpY19rZXkpO1xuICAgICAgICAgICAgbmV3X2NoZWNrc3VtID0gbmV3X2NoZWNrc3VtLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgdmFyIGlzRXF1YWwgPSBkZWVwRXF1YWwoY2hlY2tzdW0sIG5ld19jaGVja3N1bSk7IC8vLCAnSW52YWxpZCBjaGVja3N1bSdcbiAgICAgICAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNoZWNrc3VtIGRpZCBub3QgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHVibGljS2V5LmZyb21CdWZmZXIocHVibGljX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgJ2hleCcpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVB1YmxpY0tleVN0cmluZ0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUHVibGljS2V5U3RyaW5nSGV4KGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tUHVibGljS2V5U3RyaW5nKG5ldyBCdWZmZXIoaGV4LCAnaGV4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogPC9IRVg+ICovXG5cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUHVibGljS2V5O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFB1YmxpY0tleTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL1B1YmxpY0tleS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2JzNTgnKSxcbiAgICBlbmNvZGUgPSBfcmVxdWlyZS5lbmNvZGUsXG4gICAgZGVjb2RlID0gX3JlcXVpcmUuZGVjb2RlO1xuXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZShcImRlZXAtZXF1YWxcIik7XG5cbi8qKiBBZGRyZXNzZXMgYXJlIHNob3J0ZW5lZCBub24tcmV2ZXJzYWJsZSBoYXNoZXMgb2YgYSBwdWJsaWMga2V5LiAgVGhlIGZ1bGwgUHVibGljS2V5IGlzIHByZWZlcnJlZC5cbiAgICBAZGVwcmVjYXRlZFxuKi9cblxudmFyIEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRkcmVzcyhhZGR5KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZGRyZXNzKTtcblxuICAgICAgICB0aGlzLmFkZHkgPSBhZGR5O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBZGRyZXNzLCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZHk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIGNoZWNrc3VtID0gaGFzaC5yaXBlbWQxNjAodGhpcy5hZGR5KTtcbiAgICAgICAgICAgIHZhciBhZGR5ID0gQnVmZmVyLmNvbmNhdChbdGhpcy5hZGR5LCBjaGVja3N1bS5zbGljZSgwLCA0KV0pO1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3NfcHJlZml4ICsgZW5jb2RlKGFkZHkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhNTEyKGJ1ZmZlcik7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IGhhc2gucmlwZW1kMTYwKF9oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzcyhhZGR5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZnJvbVN0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NfcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeDtcblxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHN0cmluZy5zbGljZSgwLCBhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkZHJlc3NfcHJlZml4LCBwcmVmaXgsICdFeHBlY3Rpbmcga2V5IHRvIGJlZ2luIHdpdGggJyArIGFkZHJlc3NfcHJlZml4ICsgJywgaW5zdGVhZCBnb3QgJyArIHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgYWRkeSA9IHN0cmluZy5zbGljZShhZGRyZXNzX3ByZWZpeC5sZW5ndGgpO1xuICAgICAgICAgICAgYWRkeSA9IG5ldyBCdWZmZXIoZGVjb2RlKGFkZHkpLCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBhZGR5LnNsaWNlKC00KTtcbiAgICAgICAgICAgIGFkZHkgPSBhZGR5LnNsaWNlKDAsIC00KTtcbiAgICAgICAgICAgIHZhciBuZXdfY2hlY2tzdW0gPSBoYXNoLnJpcGVtZDE2MChhZGR5KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBpc0VxdWFsID0gZGVlcEVxdWFsKGNoZWNrc3VtLCBuZXdfY2hlY2tzdW0pOyAvLywgJ0ludmFsaWQgY2hlY2tzdW0nXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDaGVja3N1bSBkaWQgbm90IG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFkZHkpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tUHVibGljJyxcblxuXG4gICAgICAgIC8qKiBAcmV0dXJuIEFkZHJlc3MgLSBDb21wcmVzc2VkIFBUUyBmb3JtYXQgKGJ5IGRlZmF1bHQpICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUHVibGljKHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDU2O1xuXG4gICAgICAgICAgICB2YXIgc2hhMiA9IGhhc2guc2hhMjU2KHB1YmxpY19rZXkudG9CdWZmZXIoY29tcHJlc3NlZCkpO1xuICAgICAgICAgICAgdmFyIHJlcCA9IGhhc2gucmlwZW1kMTYwKHNoYTIpO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25CdWZmZXIgPSBuZXcgQnVmZmVyKDEpO1xuICAgICAgICAgICAgdmVyc2lvbkJ1ZmZlci53cml0ZVVJbnQ4KDB4RkYgJiB2ZXJzaW9uLCAwKTtcbiAgICAgICAgICAgIHZhciBhZGRyID0gQnVmZmVyLmNvbmNhdChbdmVyc2lvbkJ1ZmZlciwgcmVwXSk7XG4gICAgICAgICAgICB2YXIgY2hlY2sgPSBoYXNoLnNoYTI1NihhZGRyKTtcbiAgICAgICAgICAgIGNoZWNrID0gaGFzaC5zaGEyNTYoY2hlY2spO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2FkZHIsIGNoZWNrLnNsaWNlKDAsIDQpXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3MoaGFzaC5yaXBlbWQxNjAoYnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWRkcmVzcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGRyZXNzO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvYWRkcmVzcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xudmFyIEFFUyA9IHJlcXVpcmUoXCJjcnlwdG8tanMvYWVzXCIpO1xudmFyIGVuY0hleCA9IHJlcXVpcmUoXCJjcnlwdG8tanMvZW5jLWhleFwiKTtcbnZhciBlbmNCYXNlNjQgPSByZXF1aXJlKFwiY3J5cHRvLWpzL2VuYy1iYXNlNjRcIik7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcImJ5dGVidWZmZXJcIiksXG4gICAgTG9uZyA9IF9yZXF1aXJlLkxvbmc7XG5cbnZhciBoYXNoID0gcmVxdWlyZSgnLi9oYXNoJyk7XG5cbi8qKiBQcm92aWRlcyBzeW1ldHJpYyBlbmNyeXB0IGFuZCBkZWNyeXB0IHZpYSBBRVMuICovXG5cbnZhciBBZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKiogQHByaXZhdGUgKi9cbiAgICBmdW5jdGlvbiBBZXMoaXYsIGtleSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWVzKTtcblxuICAgICAgICB0aGlzLml2ID0gaXYsIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIC8qKiBUaGlzIGlzIGFuIGV4Y2VsbGVudCB3YXkgdG8gZW5zdXJlIHRoYXQgYWxsIHJlZmVyZW5jZXMgdG8gQWVzIGNhbiBub3Qgb3BlcmF0ZSBhbnltb3JlIChleGFtcGxlOiBhIHdhbGxldCBiZWNvbWVzIGxvY2tlZCkuICBBbiBhcHBsaWNhdGlvbiBzaG91bGQgZW5zdXJlIHRoZXJlIGlzIG9ubHkgb25lIEFlcyBvYmplY3QgaW5zdGFuY2UgZm9yIGEgZ2l2ZW4gc2VjcmV0IGBzZWVkYC4gKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEFlcywgW3tcbiAgICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml2ID0gdGhpcy5rZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQGFyZyB7c3RyaW5nfSBzZWVkIC0gc2VjcmV0IHNlZWQgbWF5IGJlIHVzZWQgdG8gZW5jcnlwdCBvciBkZWNyeXB0LiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2RlY3J5cHRfd29yZF9hcnJheVwiLFxuXG5cbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVjcnlwdF93b3JkX2FycmF5KGNpcGhlcikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvI0N1c3RvbV9LZXlfYW5kX0lWXG4gICAgICAgICAgICAvLyBzZWUgd2FsbGV0X3JlY29yZHMuY3BwIG1hc3Rlcl9rZXk6OmRlY3J5cHRfa2V5XG4gICAgICAgICAgICByZXR1cm4gQUVTLmRlY3J5cHQoeyBjaXBoZXJ0ZXh0OiBjaXBoZXIsIHNhbHQ6IG51bGwgfSwgdGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9lbmNyeXB0X3dvcmRfYXJyYXlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmNyeXB0X3dvcmRfYXJyYXkocGxhaW50ZXh0KSB7XG4gICAgICAgICAgICAvL2h0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL2lzc3Vlcy9kZXRhaWw/aWQ9ODVcbiAgICAgICAgICAgIHZhciBjaXBoZXIgPSBBRVMuZW5jcnlwdChwbGFpbnRleHQsIHRoaXMua2V5LCB7IGl2OiB0aGlzLml2IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVuY0Jhc2U2NC5wYXJzZShjaXBoZXIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBjaXBoZXJ0ZXh0XG4gICAgICAgICAgICBAcmV0dXJuIHtCdWZmZXJ9IGJpbmFyeVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGVjcnlwdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gbmV3IEJ1ZmZlcihjaXBoZXJ0ZXh0LCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaXBoZXJ0ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydChjaXBoZXJ0ZXh0LCBcIk1pc3NpbmcgY2lwaGVyIHRleHRcIik7XG4gICAgICAgICAgICAvLyBoZXggaXMgdGhlIG9ubHkgY29tbW9uIGZvcm1hdFxuICAgICAgICAgICAgdmFyIGhleCA9IHRoaXMuZGVjcnlwdEhleChjaXBoZXJ0ZXh0LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IHBsYWludGV4dFxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBiaW5hcnlcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuY3J5cHRcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBsYWludGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBsYWludGV4dCA9IG5ldyBCdWZmZXIocGxhaW50ZXh0LCAnYmluYXJ5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwbGFpbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9hc3NlcnQgcGxhaW50ZXh0LCBcIk1pc3NpbmcgcGxhaW4gdGV4dFwiXG4gICAgICAgICAgICAvLyBoZXggaXMgdGhlIG9ubHkgY29tbW9uIGZvcm1hdFxuICAgICAgICAgICAgdmFyIGhleCA9IHRoaXMuZW5jcnlwdEhleChwbGFpbnRleHQudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGhleCwgJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHVzZSBhIGNoZWNrc3VtLCB0aGUgcmV0dXJuZWQgZGF0YSBtdXN0IGJlIHZhbGlkYXRlZCBzb21lIG90aGVyIHdheS5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ3xCdWZmZXJ9IHBsYWludGV4dFxuICAgICAgICAgICAgQHJldHVybiB7c3RyaW5nfSBoZXhcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuY3J5cHRUb0hleFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5jcnlwdFRvSGV4KHBsYWludGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbGFpbnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwbGFpbnRleHQgPSBuZXcgQnVmZmVyKHBsYWludGV4dCwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGxhaW50ZXh0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vYXNzZXJ0IHBsYWludGV4dCwgXCJNaXNzaW5nIHBsYWluIHRleHRcIlxuICAgICAgICAgICAgLy8gaGV4IGlzIHRoZSBvbmx5IGNvbW1vbiBmb3JtYXRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRIZXgocGxhaW50ZXh0LnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBjaXBoZXIgLSBoZXhcbiAgICAgICAgICAgIEByZXR1cm4ge3N0cmluZ30gYmluYXJ5IChjb3VsZCBlYXNpbHkgYmUgcmVhZGFibGUgdGV4dClcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRIZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlY3J5cHRIZXgoY2lwaGVyKSB7XG4gICAgICAgICAgICBhc3NlcnQoY2lwaGVyLCBcIk1pc3NpbmcgY2lwaGVyIHRleHRcIik7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaW50byB3b3JkIGFycmF5cyAodXNlZCBieSBDcnlwdG8pXG4gICAgICAgICAgICB2YXIgY2lwaGVyX2FycmF5ID0gZW5jSGV4LnBhcnNlKGNpcGhlcik7XG4gICAgICAgICAgICB2YXIgcGxhaW53b3JkcyA9IHRoaXMuX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXJfYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY0hleC5zdHJpbmdpZnkocGxhaW53b3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBjaXBoZXIgLSBoZXhcbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZCBhcyBzcGVjaWZpZWQgYnkgdGhlIHBhcmFtZXRlclxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGVjcnlwdEhleFRvQnVmZmVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNyeXB0SGV4VG9CdWZmZXIoY2lwaGVyKSB7XG4gICAgICAgICAgICBhc3NlcnQoY2lwaGVyLCBcIk1pc3NpbmcgY2lwaGVyIHRleHRcIik7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaW50byB3b3JkIGFycmF5cyAodXNlZCBieSBDcnlwdG8pXG4gICAgICAgICAgICB2YXIgY2lwaGVyX2FycmF5ID0gZW5jSGV4LnBhcnNlKGNpcGhlcik7XG4gICAgICAgICAgICB2YXIgcGxhaW53b3JkcyA9IHRoaXMuX2RlY3J5cHRfd29yZF9hcnJheShjaXBoZXJfYXJyYXkpO1xuICAgICAgICAgICAgdmFyIHBsYWluaGV4ID0gZW5jSGV4LnN0cmluZ2lmeShwbGFpbndvcmRzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHBsYWluaGV4LCAnaGV4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogVGhpcyBtZXRob2QgZG9lcyBub3QgdXNlIGEgY2hlY2tzdW0sIHRoZSByZXR1cm5lZCBkYXRhIG11c3QgYmUgdmFsaWRhdGVkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgQGFyZyB7c3RyaW5nfSBjaXBoZXIgLSBoZXhcbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gW2VuY29kaW5nID0gJ2JpbmFyeSddIC0gYSB2YWxpZCBCdWZmZXIgZW5jb2RpbmdcbiAgICAgICAgICAgIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBhcyBzcGVjaWZpZWQgYnkgdGhlIHBhcmFtZXRlclxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGVjcnlwdEhleFRvVGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdEhleFRvVGV4dChjaXBoZXIpIHtcbiAgICAgICAgICAgIHZhciBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2JpbmFyeSc7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRIZXhUb0J1ZmZlcihjaXBoZXIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1c2UgYSBjaGVja3N1bSwgdGhlIHJldHVybmVkIGRhdGEgbXVzdCBiZSB2YWxpZGF0ZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICBAYXJnIHtzdHJpbmd9IHBsYWluaGV4IC0gaGV4IGZvcm1hdFxuICAgICAgICAgICAgQHJldHVybiB7U3RyaW5nfSBoZXhcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImVuY3J5cHRIZXhcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuY3J5cHRIZXgocGxhaW5oZXgpIHtcbiAgICAgICAgICAgIHZhciBwbGFpbl9hcnJheSA9IGVuY0hleC5wYXJzZShwbGFpbmhleCk7XG4gICAgICAgICAgICB2YXIgY2lwaGVyX2FycmF5ID0gdGhpcy5fZW5jcnlwdF93b3JkX2FycmF5KHBsYWluX2FycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNIZXguc3RyaW5naWZ5KGNpcGhlcl9hcnJheSk7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiBcImZyb21TZWVkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgICAgICBpZiAoc2VlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VlZCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhNTEyKHNlZWQpO1xuICAgICAgICAgICAgX2hhc2ggPSBfaGFzaC50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgICAvLyBERUJVRyBjb25zb2xlLmxvZygnLi4uIGZyb21TZWVkIF9oYXNoJyxfaGFzaClcbiAgICAgICAgICAgIHJldHVybiBBZXMuZnJvbVNoYTUxMihfaGFzaCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmcm9tU2hhNTEyXCIsXG5cblxuICAgICAgICAvKiogQGFyZyB7c3RyaW5nfSBoYXNoIC0gQSAxMjggYnl0ZSBoZXggc3RyaW5nLCB0eXBpY2FsbHkgb25lIHdvdWxkIGNhbGwge0BsaW5rIGZyb21TZWVkfSBpbnN0ZWFkLiAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNoYTUxMihoYXNoKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoaGFzaC5sZW5ndGgsIDEyOCwgXCJBIFNoYTUxMiBpbiBIRVggc2hvdWxkIGJlIDEyOCBjaGFyYWN0ZXJzIGxvbmcsIGluc3RlYWQgZ290IFwiICsgaGFzaC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGl2ID0gZW5jSGV4LnBhcnNlKGhhc2guc3Vic3RyaW5nKDY0LCA5NikpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGVuY0hleC5wYXJzZShoYXNoLnN1YnN0cmluZygwLCA2NCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZXMoaXYsIGtleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmcm9tQnVmZmVyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1Zikge1xuICAgICAgICAgICAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihidWYpLCBcIkV4cGVjdGluZyBCdWZmZXJcIik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoYnVmLmxlbmd0aCwgNjQsIFwiQSBTaGE1MTIgQnVmZmVyIHNob3VsZCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcsIGluc3RlYWQgZ290IFwiICsgYnVmLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gQWVzLmZyb21TaGE1MTIoYnVmLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICAgIEB0aHJvd3Mge0Vycm9yfSAtIFwiSW52YWxpZCBLZXksIC4uLlwiXG4gICAgICAgICAgICBAYXJnIHtQcml2YXRlS2V5fSBwcml2YXRlX2tleSAtIHJlcXVpcmVkIGFuZCB1c2VkIGZvciBkZWNyeXB0aW9uXG4gICAgICAgICAgICBAYXJnIHtQdWJsaWNLZXl9IHB1YmxpY19rZXkgLSByZXF1aXJlZCBhbmQgdXNlZCB0byBjYWxjdWFsdGUgdGhlIHNoYXJlZCBzZWNyZXRcbiAgICAgICAgICAgIEBhcmcge3N0cmluZ30gW25vbmNlID0gXCJcIl0gb3B0aW9uYWwgYnV0IHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYW5kIGJlIHVuaXF1ZSB3aGVuIHJlLXVzaW5nIHRoZSBzYW1lIHByaXZhdGUvcHVibGljIGtleXMgbW9yZSB0aGFuIG9uY2UuICBUaGlzIG5vbmNlIGlzIG5vdCBhIHNlY3JldC5cbiAgICAgICAgICAgIEBhcmcge3N0cmluZ3xCdWZmZXJ9IG1lc3NhZ2UgLSBFbmNyeXB0ZWQgbWVzc2FnZSBjb250YWluaW5nIGEgY2hlY2tzdW1cbiAgICAgICAgICAgIEByZXR1cm4ge0J1ZmZlcn1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlY3J5cHRfd2l0aF9jaGVja3N1bVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVjcnlwdF93aXRoX2NoZWNrc3VtKHByaXZhdGVfa2V5LCBwdWJsaWNfa2V5LCBub25jZSwgbWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGxlZ2FjeSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cblxuICAgICAgICAgICAgLy8gV2FybmluZzogRG8gbm90IHB1dCBgbm9uY2UgPSBcIlwiYCBpbiB0aGUgYXJndW1lbnRzLCBpbiBlczYgdGhpcyB3aWxsIG5vdCBjb252ZXJ0IFwibnVsbFwiIGludG8gYW4gZW10cHkgc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9uY2UgPT0gbnVsbCkgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBub25jZSA9IFwiXCI7XG5cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ2hleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgUyA9IHByaXZhdGVfa2V5LmdldF9zaGFyZWRfc2VjcmV0KHB1YmxpY19rZXksIGxlZ2FjeSk7XG4gICAgICAgICAgICAvLyBEIEUgQiBVIEdcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdkZWNyeXB0X3dpdGhfY2hlY2tzdW0nLCB7XG4gICAgICAgICAgICAvLyAgICAgcHJpdl90b19wdWI6IHByaXZhdGVfa2V5LnRvUHVibGljS2V5KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIC8vICAgICBwdWI6IHB1YmxpY19rZXkudG9QdWJsaWNLZXlTdHJpbmcoKSxcbiAgICAgICAgICAgIC8vICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAvLyAgICAgbWVzc2FnZTogbWVzc2FnZS5sZW5ndGgsXG4gICAgICAgICAgICAvLyAgICAgUzogUy50b1N0cmluZygnaGV4JylcbiAgICAgICAgICAgIC8vIH0pXG5cbiAgICAgICAgICAgIHZhciBhZXMgPSBBZXMuZnJvbVNlZWQoQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBBIG51bGwgb3IgZW1wdHkgc3RyaW5nIG5vbmNlIHdpbGwgbm90IGVmZmVjdCB0aGUgaGFzaFxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcblxuICAgICAgICAgICAgdmFyIHBsYW5lYnVmZmVyID0gYWVzLmRlY3J5cHQobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIShwbGFuZWJ1ZmZlci5sZW5ndGggPj0gNCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleSwgY291bGQgbm90IGRlY3J5cHQgbWVzc2FnZSgxKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gREVCVUcgY29uc29sZS5sb2coJy4uLiBwbGFuZWJ1ZmZlcicscGxhbmVidWZmZXIpXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBwbGFuZWJ1ZmZlci5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBwbGFuZWJ1ZmZlci5zbGljZSg0KTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBjaGVja3N1bScsY2hlY2tzdW0udG9TdHJpbmcoJ2hleCcpKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy4uLiBwbGFpbnRleHQnLHBsYWludGV4dC50b1N0cmluZygpKVxuXG4gICAgICAgICAgICB2YXIgbmV3X2NoZWNrc3VtID0gaGFzaC5zaGEyNTYocGxhaW50ZXh0KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIG5ld19jaGVja3N1bSA9IG5ld19jaGVja3N1bS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICAgICAgICAgIGlmICghKGNoZWNrc3VtLnRvU3RyaW5nKCdoZXgnKSA9PT0gbmV3X2NoZWNrc3VtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5LCBjb3VsZCBub3QgZGVjcnlwdCBtZXNzYWdlKDIpXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZW5jcnlwdF93aXRoX2NoZWNrc3VtXCIsXG5cblxuICAgICAgICAvKiogSWRlbnRpY2FsIHRvIHtAbGluayBkZWNyeXB0X3dpdGhfY2hlY2tzdW19IGJ1dCB1c2VkIHRvIGVuY3J5cHQuICBTaG91bGQgbm90IHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgQHJldHVybiB7QnVmZmVyfSBtZXNzYWdlIC0gRW5jcnlwdGVkIG1lc3NhZ2Ugd2hpY2ggaW5jbHVkZXMgYSBjaGVja3N1bVxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5jcnlwdF93aXRoX2NoZWNrc3VtKHByaXZhdGVfa2V5LCBwdWJsaWNfa2V5LCBub25jZSwgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICAvLyBXYXJuaW5nOiBEbyBub3QgcHV0IGBub25jZSA9IFwiXCJgIGluIHRoZSBhcmd1bWVudHMsIGluIGVzNiB0aGlzIHdpbGwgbm90IGNvbnZlcnQgXCJudWxsXCIgaW50byBhbiBlbXRweSBzdHJpbmdcblxuICAgICAgICAgICAgaWYgKG5vbmNlID09IG51bGwpIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgbm9uY2UgPSBcIlwiO1xuXG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgQnVmZmVyKG1lc3NhZ2UsICdiaW5hcnknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIFMgPSBwcml2YXRlX2tleS5nZXRfc2hhcmVkX3NlY3JldChwdWJsaWNfa2V5KTtcblxuICAgICAgICAgICAgLy8gRCBFIEIgVSBHXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZW5jcnlwdF93aXRoX2NoZWNrc3VtJywge1xuICAgICAgICAgICAgLy8gICAgIHByaXZfdG9fcHViOiBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIC8vICAgICBwdWI6IHB1YmxpY19rZXkudG9QdWJsaWNLZXlTdHJpbmcoKVxuICAgICAgICAgICAgLy8gICAgIG5vbmNlOiBub25jZVxuICAgICAgICAgICAgLy8gICAgIG1lc3NhZ2U6IG1lc3NhZ2UubGVuZ3RoXG4gICAgICAgICAgICAvLyAgICAgUzogUy50b1N0cmluZygnaGV4JylcbiAgICAgICAgICAgIC8vIH0pXG5cbiAgICAgICAgICAgIHZhciBhZXMgPSBBZXMuZnJvbVNlZWQoQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBBIG51bGwgb3IgZW1wdHkgc3RyaW5nIG5vbmNlIHdpbGwgbm90IGVmZmVjdCB0aGUgaGFzaFxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihcIlwiICsgbm9uY2UpLCBuZXcgQnVmZmVyKFMudG9TdHJpbmcoJ2hleCcpKV0pKTtcbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gUycsUy50b1N0cmluZygnaGV4JykpXG4gICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBoYXNoLnNoYTI1NihtZXNzYWdlKS5zbGljZSgwLCA0KTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbY2hlY2tzdW0sIG1lc3NhZ2VdKTtcbiAgICAgICAgICAgIC8vIERFQlVHIGNvbnNvbGUubG9nKCcuLi4gcGF5bG9hZCcscGF5bG9hZC50b1N0cmluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFlcy5lbmNyeXB0KHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFlcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZXM7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9hZXMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTsgLy8gZnJvbSBnaXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliIGZyb20gZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvZWNkc2FcbnZhciBjcnlwdG8gPSByZXF1aXJlKCcuL2hhc2gnKTtcbnZhciBlbmZvcmNlVHlwZSA9IHJlcXVpcmUoJy4vZW5mb3JjZV90eXBlcycpO1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcbnZhciBFQ1NpZ25hdHVyZSA9IHJlcXVpcmUoJy4vZWNzaWduYXR1cmUnKTtcblxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5Nzkjc2VjdGlvbi0zLjJcbmZ1bmN0aW9uIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGNoZWNrU2lnLCBub25jZSkge1xuXG4gIGVuZm9yY2VUeXBlKCdCdWZmZXInLCBoYXNoKTtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgZCk7XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgaGFzaCA9IGNyeXB0by5zaGEyNTYoQnVmZmVyLmNvbmNhdChbaGFzaCwgbmV3IEJ1ZmZlcihub25jZSldKSk7XG4gIH1cblxuICAvLyBzYW5pdHkgY2hlY2tcbiAgYXNzZXJ0LmVxdWFsKGhhc2gubGVuZ3RoLCAzMiwgJ0hhc2ggbXVzdCBiZSAyNTYgYml0Jyk7XG5cbiAgdmFyIHggPSBkLnRvQnVmZmVyKDMyKTtcbiAgdmFyIGsgPSBuZXcgQnVmZmVyKDMyKTtcbiAgdmFyIHYgPSBuZXcgQnVmZmVyKDMyKTtcblxuICAvLyBTdGVwIEJcbiAgdi5maWxsKDEpO1xuXG4gIC8vIFN0ZXAgQ1xuICBrLmZpbGwoMCk7XG5cbiAgLy8gU3RlcCBEXG4gIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFswXSksIHgsIGhhc2hdKSwgayk7XG5cbiAgLy8gU3RlcCBFXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICAvLyBTdGVwIEZcbiAgayA9IGNyeXB0by5IbWFjU0hBMjU2KEJ1ZmZlci5jb25jYXQoW3YsIG5ldyBCdWZmZXIoWzFdKSwgeCwgaGFzaF0pLCBrKTtcblxuICAvLyBTdGVwIEdcbiAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gIC8vIFN0ZXAgSDEvSDJhLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gIC8vIFN0ZXAgSDJiXG4gIHYgPSBjcnlwdG8uSG1hY1NIQTI1Nih2LCBrKTtcblxuICB2YXIgVCA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcih2KTtcblxuICAvLyBTdGVwIEgzLCByZXBlYXQgdW50aWwgVCBpcyB3aXRoaW4gdGhlIGludGVydmFsIFsxLCBuIC0gMV1cbiAgd2hpbGUgKFQuc2lnbnVtKCkgPD0gMCB8fCBULmNvbXBhcmVUbyhjdXJ2ZS5uKSA+PSAwIHx8ICFjaGVja1NpZyhUKSkge1xuICAgIGsgPSBjcnlwdG8uSG1hY1NIQTI1NihCdWZmZXIuY29uY2F0KFt2LCBuZXcgQnVmZmVyKFswXSldKSwgayk7XG4gICAgdiA9IGNyeXB0by5IbWFjU0hBMjU2KHYsIGspO1xuXG4gICAgLy8gU3RlcCBIMS9IMmEsIGFnYWluLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gICAgLy8gU3RlcCBIMmIgYWdhaW5cbiAgICB2ID0gY3J5cHRvLkhtYWNTSEEyNTYodiwgayk7XG5cbiAgICBUID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKHYpO1xuICB9XG5cbiAgcmV0dXJuIFQ7XG59XG5cbmZ1bmN0aW9uIHNpZ24oY3VydmUsIGhhc2gsIGQsIG5vbmNlKSB7XG5cbiAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoaGFzaCk7XG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByLCBzO1xuICB2YXIgayA9IGRldGVybWluaXN0aWNHZW5lcmF0ZUsoY3VydmUsIGhhc2gsIGQsIGZ1bmN0aW9uIChrKSB7XG4gICAgLy8gZmluZCBjYW5vbmljYWxseSB2YWxpZCBzaWduYXR1cmVcbiAgICB2YXIgUSA9IEcubXVsdGlwbHkoayk7XG5cbiAgICBpZiAoY3VydmUuaXNJbmZpbml0eShRKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgciA9IFEuYWZmaW5lWC5tb2Qobik7XG4gICAgaWYgKHIuc2lnbnVtKCkgPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHMgPSBrLm1vZEludmVyc2UobikubXVsdGlwbHkoZS5hZGQoZC5tdWx0aXBseShyKSkpLm1vZChuKTtcbiAgICBpZiAocy5zaWdudW0oKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIG5vbmNlKTtcblxuICB2YXIgTl9PVkVSX1RXTyA9IG4uc2hpZnRSaWdodCgxKTtcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNvbXBhcmVUbyhOX09WRVJfVFdPKSA+IDApIHtcbiAgICBzID0gbi5zdWJ0cmFjdChzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgRUNTaWduYXR1cmUociwgcyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVJhdyhjdXJ2ZSwgZSwgc2lnbmF0dXJlLCBRKSB7XG4gIHZhciBuID0gY3VydmUubjtcbiAgdmFyIEcgPSBjdXJ2ZS5HO1xuXG4gIHZhciByID0gc2lnbmF0dXJlLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlLnM7XG5cbiAgLy8gMS40LjEgRW5mb3JjZSByIGFuZCBzIGFyZSBib3RoIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMSwgbiDiiJIgMV1cbiAgaWYgKHIuc2lnbnVtKCkgPD0gMCB8fCByLmNvbXBhcmVUbyhuKSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzLnNpZ251bSgpIDw9IDAgfHwgcy5jb21wYXJlVG8obikgPj0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGMgPSBzXi0xIG1vZCBuXG4gIHZhciBjID0gcy5tb2RJbnZlcnNlKG4pO1xuXG4gIC8vIDEuNC40IENvbXB1dGUgdTEgPSBlc17iiJIxIG1vZCBuXG4gIC8vICAgICAgICAgICAgICAgdTIgPSByc17iiJIxIG1vZCBuXG4gIHZhciB1MSA9IGUubXVsdGlwbHkoYykubW9kKG4pO1xuICB2YXIgdTIgPSByLm11bHRpcGx5KGMpLm1vZChuKTtcblxuICAvLyAxLjQuNSBDb21wdXRlIFIgPSAoeFIsIHlSKSA9IHUxRyArIHUyUVxuICB2YXIgUiA9IEcubXVsdGlwbHlUd28odTEsIFEsIHUyKTtcblxuICAvLyAxLjQuNSAoY29udC4pIEVuZm9yY2UgUiBpcyBub3QgYXQgaW5maW5pdHlcbiAgaWYgKGN1cnZlLmlzSW5maW5pdHkoUikpIHJldHVybiBmYWxzZTtcblxuICAvLyAxLjQuNiBDb252ZXJ0IHRoZSBmaWVsZCBlbGVtZW50IFIueCB0byBhbiBpbnRlZ2VyXG4gIHZhciB4UiA9IFIuYWZmaW5lWDtcblxuICAvLyAxLjQuNyBTZXQgdiA9IHhSIG1vZCBuXG4gIHZhciB2ID0geFIubW9kKG4pO1xuXG4gIC8vIDEuNC44IElmIHYgPSByLCBvdXRwdXQgXCJ2YWxpZFwiLCBhbmQgaWYgdiAhPSByLCBvdXRwdXQgXCJpbnZhbGlkXCJcbiAgcmV0dXJuIHYuZXF1YWxzKHIpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZnkoY3VydmUsIGhhc2gsIHNpZ25hdHVyZSwgUSkge1xuICAvLyAxLjQuMiBIID0gSGFzaChNKSwgYWxyZWFkeSBkb25lIGJ5IHRoZSB1c2VyXG4gIC8vIDEuNC4zIGUgPSBIXG4gIHZhciBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGhhc2gpO1xuICByZXR1cm4gdmVyaWZ5UmF3KGN1cnZlLCBlLCBzaWduYXR1cmUsIFEpO1xufVxuXG4vKipcbiAgKiBSZWNvdmVyIGEgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICAqXG4gICogU2VlIFNFQyAxOiBFbGxpcHRpYyBDdXJ2ZSBDcnlwdG9ncmFwaHksIHNlY3Rpb24gNC4xLjYsIFwiUHVibGljXG4gICogS2V5IFJlY292ZXJ5IE9wZXJhdGlvblwiLlxuICAqXG4gICogaHR0cDovL3d3dy5zZWNnLm9yZy9kb3dubG9hZC9haWQtNzgwL3NlYzEtdjIucGRmXG4gICovXG5mdW5jdGlvbiByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpIHtcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKGkgJiAzLCBpLCAnUmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG5cbiAgdmFyIG4gPSBjdXJ2ZS5uO1xuICB2YXIgRyA9IGN1cnZlLkc7XG5cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcblxuICBhc3NlcnQoci5zaWdudW0oKSA+IDAgJiYgci5jb21wYXJlVG8obikgPCAwLCAnSW52YWxpZCByIHZhbHVlJyk7XG4gIGFzc2VydChzLnNpZ251bSgpID4gMCAmJiBzLmNvbXBhcmVUbyhuKSA8IDAsICdJbnZhbGlkIHMgdmFsdWUnKTtcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGkgJiAxO1xuXG4gIC8vIFRoZSBtb3JlIHNpZ25pZmljYW50IGJpdCBzcGVjaWZpZXMgd2hldGhlciB3ZSBzaG91bGQgdXNlIHRoZVxuICAvLyBmaXJzdCBvciBzZWNvbmQgY2FuZGlkYXRlIGtleS5cbiAgdmFyIGlzU2Vjb25kS2V5ID0gaSA+PiAxO1xuXG4gIC8vIDEuMSBMZXQgeCA9IHIgKyBqblxuICB2YXIgeCA9IGlzU2Vjb25kS2V5ID8gci5hZGQobikgOiByO1xuICB2YXIgUiA9IGN1cnZlLnBvaW50RnJvbVgoaXNZT2RkLCB4KTtcblxuICAvLyAxLjQgQ2hlY2sgdGhhdCBuUiBpcyBhdCBpbmZpbml0eVxuICB2YXIgblIgPSBSLm11bHRpcGx5KG4pO1xuICBhc3NlcnQoY3VydmUuaXNJbmZpbml0eShuUiksICduUiBpcyBub3QgYSB2YWxpZCBjdXJ2ZSBwb2ludCcpO1xuXG4gIC8vIENvbXB1dGUgLWUgZnJvbSBlXG4gIHZhciBlTmVnID0gZS5uZWdhdGUoKS5tb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICB2YXIgckludiA9IHIubW9kSW52ZXJzZShuKTtcblxuICB2YXIgUSA9IFIubXVsdGlwbHlUd28ocywgRywgZU5lZykubXVsdGlwbHkockludik7XG4gIGN1cnZlLnZhbGlkYXRlKFEpO1xuXG4gIHJldHVybiBRO1xufVxuXG4vKipcbiAgKiBDYWxjdWxhdGUgcHVia2V5IGV4dHJhY3Rpb24gcGFyYW1ldGVyLlxuICAqXG4gICogV2hlbiBleHRyYWN0aW5nIGEgcHVia2V5IGZyb20gYSBzaWduYXR1cmUsIHdlIGhhdmUgdG9cbiAgKiBkaXN0aW5ndWlzaCBmb3VyIGRpZmZlcmVudCBjYXNlcy4gUmF0aGVyIHRoYW4gcHV0dGluZyB0aGlzXG4gICogYnVyZGVuIG9uIHRoZSB2ZXJpZmllciwgQml0Y29pbiBpbmNsdWRlcyBhIDItYml0IHZhbHVlIHdpdGggdGhlXG4gICogc2lnbmF0dXJlLlxuICAqXG4gICogVGhpcyBmdW5jdGlvbiBzaW1wbHkgdHJpZXMgYWxsIGZvdXIgY2FzZXMgYW5kIHJldHVybnMgdGhlIHZhbHVlXG4gICogdGhhdCByZXN1bHRlZCBpbiBhIHN1Y2Nlc3NmdWwgcHVia2V5IHJlY292ZXJ5LlxuICAqL1xuZnVuY3Rpb24gY2FsY1B1YktleVJlY292ZXJ5UGFyYW0oY3VydmUsIGUsIHNpZ25hdHVyZSwgUSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWUgPSByZWNvdmVyUHViS2V5KGN1cnZlLCBlLCBzaWduYXR1cmUsIGkpO1xuXG4gICAgLy8gMS42LjIgVmVyaWZ5IFFcbiAgICBpZiAoUXByaW1lLmVxdWFscyhRKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNhbGNQdWJLZXlSZWNvdmVyeVBhcmFtOiBjYWxjUHViS2V5UmVjb3ZlcnlQYXJhbSxcbiAgZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSzogZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyxcbiAgcmVjb3ZlclB1YktleTogcmVjb3ZlclB1YktleSxcbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHZlcmlmeVJhdzogdmVyaWZ5UmF3XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvZWNkc2EuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTsgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWJcbnZhciBlbmZvcmNlVHlwZSA9IHJlcXVpcmUoJy4vZW5mb3JjZV90eXBlcycpO1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxuZnVuY3Rpb24gRUNTaWduYXR1cmUociwgcykge1xuICBlbmZvcmNlVHlwZShCaWdJbnRlZ2VyLCByKTtcbiAgZW5mb3JjZVR5cGUoQmlnSW50ZWdlciwgcyk7XG5cbiAgdGhpcy5yID0gcjtcbiAgdGhpcy5zID0gcztcbn1cblxuLy8gSW1wb3J0IG9wZXJhdGlvbnNcbkVDU2lnbmF0dXJlLnBhcnNlQ29tcGFjdCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIHZhciBpID0gYnVmZmVyLnJlYWRVSW50OCgwKSAtIDI3O1xuXG4gIC8vIEF0IG1vc3QgMyBiaXRzXG4gIGFzc2VydC5lcXVhbChpLCBpICYgNywgJ0ludmFsaWQgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICB2YXIgY29tcHJlc3NlZCA9ICEhKGkgJiA0KTtcblxuICAvLyBSZWNvdmVyeSBwYXJhbSBvbmx5XG4gIGkgPSBpICYgMztcblxuICB2YXIgciA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihidWZmZXIuc2xpY2UoMSwgMzMpKTtcbiAgdmFyIHMgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmZmVyLnNsaWNlKDMzKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wcmVzc2VkOiBjb21wcmVzc2VkLFxuICAgIGk6IGksXG4gICAgc2lnbmF0dXJlOiBuZXcgRUNTaWduYXR1cmUociwgcylcbiAgfTtcbn07XG5cbkVDU2lnbmF0dXJlLmZyb21ERVIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KDApLCAweDMwLCAnTm90IGEgREVSIHNlcXVlbmNlJyk7XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KDEpLCBidWZmZXIubGVuZ3RoIC0gMiwgJ0ludmFsaWQgc2VxdWVuY2UgbGVuZ3RoJyk7XG4gIGFzc2VydC5lcXVhbChidWZmZXIucmVhZFVJbnQ4KDIpLCAweDAyLCAnRXhwZWN0ZWQgYSBERVIgaW50ZWdlcicpO1xuXG4gIHZhciByTGVuID0gYnVmZmVyLnJlYWRVSW50OCgzKTtcbiAgYXNzZXJ0KHJMZW4gPiAwLCAnUiBsZW5ndGggaXMgemVybycpO1xuXG4gIHZhciBvZmZzZXQgPSA0ICsgckxlbjtcbiAgYXNzZXJ0LmVxdWFsKGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KSwgMHgwMiwgJ0V4cGVjdGVkIGEgREVSIGludGVnZXIgKDIpJyk7XG5cbiAgdmFyIHNMZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCArIDEpO1xuICBhc3NlcnQoc0xlbiA+IDAsICdTIGxlbmd0aCBpcyB6ZXJvJyk7XG5cbiAgdmFyIHJCID0gYnVmZmVyLnNsaWNlKDQsIG9mZnNldCk7XG4gIHZhciBzQiA9IGJ1ZmZlci5zbGljZShvZmZzZXQgKyAyKTtcbiAgb2Zmc2V0ICs9IDIgKyBzTGVuO1xuXG4gIGlmIChyTGVuID4gMSAmJiByQi5yZWFkVUludDgoMCkgPT09IDB4MDApIHtcbiAgICBhc3NlcnQockIucmVhZFVJbnQ4KDEpICYgMHg4MCwgJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIH1cblxuICBpZiAoc0xlbiA+IDEgJiYgc0IucmVhZFVJbnQ4KDApID09PSAweDAwKSB7XG4gICAgYXNzZXJ0KHNCLnJlYWRVSW50OCgxKSAmIDB4ODAsICdTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICB9XG5cbiAgYXNzZXJ0LmVxdWFsKG9mZnNldCwgYnVmZmVyLmxlbmd0aCwgJ0ludmFsaWQgREVSIGVuY29kaW5nJyk7XG4gIHZhciByID0gQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlcihyQik7XG4gIHZhciBzID0gQmlnSW50ZWdlci5mcm9tREVSSW50ZWdlcihzQik7XG5cbiAgYXNzZXJ0KHIuc2lnbnVtKCkgPj0gMCwgJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgYXNzZXJ0KHMuc2lnbnVtKCkgPj0gMCwgJ1MgdmFsdWUgaXMgbmVnYXRpdmUnKTtcblxuICByZXR1cm4gbmV3IEVDU2lnbmF0dXJlKHIsIHMpO1xufTtcblxuLy8gRklYTUU6IDB4MDAsIDB4MDQsIDB4ODAgYXJlIFNJR0hBU0hfKiBib3VuZGFyeSBjb25zdGFudHMsIGltcG9ydGluZyBUcmFuc2FjdGlvbiBjYXVzZXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5XG5FQ1NpZ25hdHVyZS5wYXJzZVNjcmlwdFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdmFyIGhhc2hUeXBlID0gYnVmZmVyLnJlYWRVSW50OChidWZmZXIubGVuZ3RoIC0gMSk7XG4gIHZhciBoYXNoVHlwZU1vZCA9IGhhc2hUeXBlICYgfjB4ODA7XG5cbiAgYXNzZXJ0KGhhc2hUeXBlTW9kID4gMHgwMCAmJiBoYXNoVHlwZU1vZCA8IDB4MDQsICdJbnZhbGlkIGhhc2hUeXBlJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEVDU2lnbmF0dXJlLmZyb21ERVIoYnVmZmVyLnNsaWNlKDAsIC0xKSksXG4gICAgaGFzaFR5cGU6IGhhc2hUeXBlXG4gIH07XG59O1xuXG4vLyBFeHBvcnQgb3BlcmF0aW9uc1xuRUNTaWduYXR1cmUucHJvdG90eXBlLnRvQ29tcGFjdCA9IGZ1bmN0aW9uIChpLCBjb21wcmVzc2VkKSB7XG4gIGlmIChjb21wcmVzc2VkKSBpICs9IDQ7XG4gIGkgKz0gMjc7XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoNjUpO1xuICBidWZmZXIud3JpdGVVSW50OChpLCAwKTtcblxuICB0aGlzLnIudG9CdWZmZXIoMzIpLmNvcHkoYnVmZmVyLCAxKTtcbiAgdGhpcy5zLnRvQnVmZmVyKDMyKS5jb3B5KGJ1ZmZlciwgMzMpO1xuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5FQ1NpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByQmEgPSB0aGlzLnIudG9ERVJJbnRlZ2VyKCk7XG4gIHZhciBzQmEgPSB0aGlzLnMudG9ERVJJbnRlZ2VyKCk7XG5cbiAgdmFyIHNlcXVlbmNlID0gW107XG5cbiAgLy8gSU5URUdFUlxuICBzZXF1ZW5jZS5wdXNoKDB4MDIsIHJCYS5sZW5ndGgpO1xuICBzZXF1ZW5jZSA9IHNlcXVlbmNlLmNvbmNhdChyQmEpO1xuXG4gIC8vIElOVEVHRVJcbiAgc2VxdWVuY2UucHVzaCgweDAyLCBzQmEubGVuZ3RoKTtcbiAgc2VxdWVuY2UgPSBzZXF1ZW5jZS5jb25jYXQoc0JhKTtcblxuICAvLyBTRVFVRU5DRVxuICBzZXF1ZW5jZS51bnNoaWZ0KDB4MzAsIHNlcXVlbmNlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2VxdWVuY2UpO1xufTtcblxuRUNTaWduYXR1cmUucHJvdG90eXBlLnRvU2NyaXB0U2lnbmF0dXJlID0gZnVuY3Rpb24gKGhhc2hUeXBlKSB7XG4gIHZhciBoYXNoVHlwZUJ1ZmZlciA9IG5ldyBCdWZmZXIoMSk7XG4gIGhhc2hUeXBlQnVmZmVyLndyaXRlVUludDgoaGFzaFR5cGUsIDApO1xuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFt0aGlzLnRvREVSKCksIGhhc2hUeXBlQnVmZmVyXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVDU2lnbmF0dXJlO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvZWNzaWduYXR1cmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5mb3JjZSh0eXBlLCB2YWx1ZSkge1xuICAvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWJcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnQnVmZmVyJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdOdW1iZXInOlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGdldE5hbWUodmFsdWUuY29uc3RydWN0b3IpID09PSBnZXROYW1lKHR5cGUpKSByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCAnICsgKGdldE5hbWUodHlwZSkgfHwgdHlwZSkgKyAnLCBnb3QgJyArIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIGdldE5hbWUoZm4pIHtcbiAgLy8gV2h5IG5vdCBmbi5uYW1lOiBodHRwczovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNi8jZnVuY3Rpb25fbmFtZV9wcm9wZXJ0eVxuICB2YXIgbWF0Y2ggPSBmbi50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoLio/KVxcKC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyYy9lbmZvcmNlX3R5cGVzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xudmFyIGNyZWF0ZUhtYWMgPSByZXF1aXJlKFwiY3JlYXRlLWhtYWNcIik7XG5cbi8qKiBAYXJnIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgQGFyZyB7c3RyaW5nfSBbZGlnZXN0ID0gbnVsbF0gLSAnaGV4JywgJ2JpbmFyeScgb3IgJ2Jhc2U2NCdcbiAgICBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSAtIEJ1ZmZlciB3aGVuIGRpZ2VzdCBpcyBudWxsLCBvciBzdHJpbmdcbiovXG5mdW5jdGlvbiBzaGExKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuLyoqIEBhcmcge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICBAYXJnIHtzdHJpbmd9IFtkaWdlc3QgPSBudWxsXSAtICdoZXgnLCAnYmluYXJ5JyBvciAnYmFzZTY0J1xuICAgIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IC0gQnVmZmVyIHdoZW4gZGlnZXN0IGlzIG51bGwsIG9yIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHNoYTI1NihkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuLyoqIEBhcmcge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAgICBAYXJnIHtzdHJpbmd9IFtkaWdlc3QgPSBudWxsXSAtICdoZXgnLCAnYmluYXJ5JyBvciAnYmFzZTY0J1xuICAgIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IC0gQnVmZmVyIHdoZW4gZGlnZXN0IGlzIG51bGwsIG9yIHN0cmluZ1xuKi9cbmZ1bmN0aW9uIHNoYTUxMihkYXRhLCBlbmNvZGluZykge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoZGF0YSkuZGlnZXN0KGVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gSG1hY1NIQTI1NihidWZmZXIsIHNlY3JldCkge1xuICAgIHJldHVybiBjcmVhdGVIbWFjKCdzaGEyNTYnLCBzZWNyZXQpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpO1xufVxuXG5mdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoZGF0YSkuZGlnZXN0KCk7XG59XG5cbi8vIGZ1bmN0aW9uIGhhc2gxNjAoYnVmZmVyKSB7XG4vLyAgIHJldHVybiByaXBlbWQxNjAoc2hhMjU2KGJ1ZmZlcikpXG4vLyB9XG4vL1xuLy8gZnVuY3Rpb24gaGFzaDI1NihidWZmZXIpIHtcbi8vICAgcmV0dXJuIHNoYTI1NihzaGEyNTYoYnVmZmVyKSlcbi8vIH1cblxuLy9cbi8vIGZ1bmN0aW9uIEhtYWNTSEE1MTIoYnVmZmVyLCBzZWNyZXQpIHtcbi8vICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCBzZWNyZXQpLnVwZGF0ZShidWZmZXIpLmRpZ2VzdCgpXG4vLyB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNoYTE6IHNoYTEsXG4gICAgc2hhMjU2OiBzaGEyNTYsXG4gICAgc2hhNTEyOiBzaGE1MTIsXG4gICAgSG1hY1NIQTI1NjogSG1hY1NIQTI1NixcbiAgICByaXBlbWQxNjA6IHJpcGVtZDE2MFxuICAgIC8vIGhhc2gxNjA6IGhhc2gxNjAsXG4gICAgLy8gaGFzaDI1NjogaGFzaDI1NixcbiAgICAvLyBIbWFjU0hBNTEyOiBIbWFjU0hBNTEyXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L2VjYy9zcmMvaGFzaC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGVjZHNhID0gcmVxdWlyZSgnLi9lY2RzYScpO1xudmFyIGhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZWN1cnZlJyksXG4gICAgZ2V0Q3VydmVCeU5hbWUgPSBfcmVxdWlyZS5nZXRDdXJ2ZUJ5TmFtZTtcblxudmFyIHNlY3AyNTZrMSA9IGdldEN1cnZlQnlOYW1lKCdzZWNwMjU2azEnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnYmlnaScpO1xudmFyIFB1YmxpY0tleSA9IHJlcXVpcmUoJy4vUHVibGljS2V5Jyk7XG5cbnZhciBTaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbmF0dXJlKHIxLCBzMSwgaTEpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ25hdHVyZSk7XG5cbiAgICAgICAgdGhpcy5yID0gcjE7XG4gICAgICAgIHRoaXMucyA9IHMxO1xuICAgICAgICB0aGlzLmkgPSBpMTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMuciAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMucyAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHRoaXMuaSAhPSBudWxsLCB0cnVlLCAnTWlzc2luZyBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2lnbmF0dXJlLCBbe1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICBidWYgPSBuZXcgQnVmZmVyKDY1KTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHRoaXMuaSwgMCk7XG4gICAgICAgICAgICB0aGlzLnIudG9CdWZmZXIoMzIpLmNvcHkoYnVmLCAxKTtcbiAgICAgICAgICAgIHRoaXMucy50b0J1ZmZlcigzMikuY29weShidWYsIDMzKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY292ZXJQdWJsaWNLZXlGcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXlGcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlclB1YmxpY0tleShoYXNoLnNoYTI1NihidWZmZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjb3ZlclB1YmxpY0tleScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICAgIEByZXR1cm4ge1B1YmxpY0tleX1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoc2hhMjU2X2J1ZmZlcikge1xuICAgICAgICAgICAgdmFyIFEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpID0gdm9pZCAwO1xuICAgICAgICAgICAgZSA9IEJpZ0ludGVnZXIuZnJvbUJ1ZmZlcihzaGEyNTZfYnVmZmVyKTtcbiAgICAgICAgICAgIGkgPSB0aGlzLmk7XG4gICAgICAgICAgICBpIC09IDI3O1xuICAgICAgICAgICAgaSA9IGkgJiAzO1xuICAgICAgICAgICAgUSA9IGVjZHNhLnJlY292ZXJQdWJLZXkoc2VjcDI1NmsxLCBlLCB0aGlzLCBpKTtcbiAgICAgICAgICAgIHJldHVybiBQdWJsaWNLZXkuZnJvbVBvaW50KFEpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2ZXJpZnlCdWZmZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gdW4taGFzaGVkXG4gICAgICAgICAgICBAcGFyYW0gey4vUHVibGljS2V5fVxuICAgICAgICAgICAgQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUJ1ZmZlcihidWYsIHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhMjU2KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlIYXNoKF9oYXNoLCBwdWJsaWNfa2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndmVyaWZ5SGFzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlIYXNoKGhhc2gsIHB1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChoYXNoLmxlbmd0aCwgMzIsIFwiQSBTSEEgMjU2IHNob3VsZCBiZSAzMiBieXRlcyBsb25nLCBpbnN0ZWFkIGdvdCBcIiArIGhhc2gubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBlY2RzYS52ZXJpZnkoc2VjcDI1NmsxLCBoYXNoLCB7XG4gICAgICAgICAgICAgICAgcjogdGhpcy5yLFxuICAgICAgICAgICAgICAgIHM6IHRoaXMuc1xuICAgICAgICAgICAgfSwgcHVibGljX2tleS5RKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9CeXRlQnVmZmVyJyxcblxuXG4gICAgICAgIC8qIDxIRVg+ICovXG5cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQnl0ZUJ1ZmZlcigpIHtcbiAgICAgICAgICAgIHZhciBiO1xuICAgICAgICAgICAgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0hleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKCkudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZlcmlmeUhleCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlIZXgoaGV4LCBwdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICB2YXIgYnVmO1xuICAgICAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihoZXgsICdoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeUJ1ZmZlcihidWYsIHB1YmxpY19rZXkpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2Zyb21CdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWYpIHtcbiAgICAgICAgICAgIHZhciBpLCByLCBzO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGJ1Zi5sZW5ndGgsIDY1LCAnSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gICAgICAgICAgICBpID0gYnVmLnJlYWRVSW50OCgwKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChpIC0gMjcsIGkgLSAyNyAmIDcsICdJbnZhbGlkIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHIgPSBCaWdJbnRlZ2VyLmZyb21CdWZmZXIoYnVmLnNsaWNlKDEsIDMzKSk7XG4gICAgICAgICAgICBzID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zi5zbGljZSgzMykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcywgaSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ25CdWZmZXInLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gICAgICAgICAgICBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduQnVmZmVyKGJ1ZiwgcHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgICAgIHZhciBfaGFzaCA9IGhhc2guc2hhMjU2KGJ1Zik7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXJTaGEyNTYoX2hhc2gsIHByaXZhdGVfa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBTaWduIGEgYnVmZmVyIG9mIGV4YWN0YWxseSAzMiBieXRlcyBpbiBzaXplIChzaGEyNTYodGV4dCkpXG4gICAgICAgICAgICBAcGFyYW0ge0J1ZmZlcn0gYnVmIC0gMzIgYnl0ZXMgYmluYXJ5XG4gICAgICAgICAgICBAcGFyYW0ge1ByaXZhdGVLZXl9IHByaXZhdGVfa2V5XG4gICAgICAgICAgICBAcmV0dXJuIHtTaWduYXR1cmV9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ25CdWZmZXJTaGEyNTYnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbkJ1ZmZlclNoYTI1NihidWZfc2hhMjU2LCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgaWYgKGJ1Zl9zaGEyNTYubGVuZ3RoICE9PSAzMiB8fCAhQnVmZmVyLmlzQnVmZmVyKGJ1Zl9zaGEyNTYpKSB0aHJvdyBuZXcgRXJyb3IoXCJidWZfc2hhMjU2OiAzMiBieXRlIGJ1ZmZlciByZXF1cmVkXCIpO1xuICAgICAgICAgICAgdmFyIGRlciwgZSwgZWNzaWduYXR1cmUsIGksIGxlblIsIGxlblMsIG5vbmNlO1xuICAgICAgICAgICAgaSA9IG51bGw7XG4gICAgICAgICAgICBub25jZSA9IDA7XG4gICAgICAgICAgICBlID0gQmlnSW50ZWdlci5mcm9tQnVmZmVyKGJ1Zl9zaGEyNTYpO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBlY3NpZ25hdHVyZSA9IGVjZHNhLnNpZ24oc2VjcDI1NmsxLCBidWZfc2hhMjU2LCBwcml2YXRlX2tleS5kLCBub25jZSsrKTtcbiAgICAgICAgICAgICAgICBkZXIgPSBlY3NpZ25hdHVyZS50b0RFUigpO1xuICAgICAgICAgICAgICAgIGxlblIgPSBkZXJbM107XG4gICAgICAgICAgICAgICAgbGVuUyA9IGRlcls1ICsgbGVuUl07XG4gICAgICAgICAgICAgICAgaWYgKGxlblIgPT09IDMyICYmIGxlblMgPT09IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBlY2RzYS5jYWxjUHViS2V5UmVjb3ZlcnlQYXJhbShzZWNwMjU2azEsIGUsIGVjc2lnbmF0dXJlLCBwcml2YXRlX2tleS50b1B1YmxpY0tleSgpLlEpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDQ7IC8vIGNvbXByZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyNzsgLy8gY29tcGFjdCAgLy8gIDI0IG9yIDI3IDooIGZvcmNpbmcgb2RkLXkgMm5kIGtleSBjYW5kaWRhdGUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9uY2UgJSAxMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldBUk46IFwiICsgbm9uY2UgKyBcIiBhdHRlbXB0cyB0byBmaW5kIGNhbm9uaWNhbCBzaWduYXR1cmVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoZWNzaWduYXR1cmUuciwgZWNzaWduYXR1cmUucywgaSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NpZ24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihzdHJpbmcsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXIobmV3IEJ1ZmZlcihzdHJpbmcpLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUJ1ZmZlcihuZXcgQnVmZmVyKGhleCwgXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzaWduSGV4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25IZXgoaGV4LCBwcml2YXRlX2tleSkge1xuICAgICAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoaGV4LCAnaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLnNpZ25CdWZmZXIoYnVmLCBwcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2lnbmF0dXJlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9lY2Mvc3JjL3NpZ25hdHVyZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvZWNjL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24ocmVxdWlyZShcIi4vY2hhaW5cIiksIHJlcXVpcmUoXCIuL2VjY1wiKSwgcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3QvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIC8vIFByaW1hcnkgY2xhc3MgZm9yIGNyZWF0aW5nIG9wZXJhdGlvbnNcbiAgICBTZXJpYWxpemVyOiByZXF1aXJlKCcuL3NyYy9zZXJpYWxpemVyJyksXG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBvcGVyYXRpb25zXG4gICAgZnA6IHJlcXVpcmUoJy4vc3JjL0Zhc3RQYXJzZXInKSxcblxuICAgIC8vIExvdyBsZXZlbCB0eXBlc1xuICAgIHR5cGVzOiByZXF1aXJlKCcuL3NyYy90eXBlcycpLFxuXG4gICAgLy8gSGlnaGVyIGxldmVsIG9wZXJhdGlvbnMgKG1hZGUgb3V0IG9mIGdlbmVyaWMgdHlwZXMpXG4gICAgb3BzOiByZXF1aXJlKCcuL3NyYy9vcGVyYXRpb25zJyksXG5cbiAgICAvLyBVdGlsaXR5IHRoYXQgZ2VuZXJhdGVzIEpTT04gZXhhbXBsZXNcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zcmMvdGVtcGxhdGUnKSxcblxuICAgIC8vIFNlcmlhbGl6ZXIgdmFsaWRhdGlvblxuICAgIFNlcmlhbGl6ZXJWYWxpZGF0aW9uOiByZXF1aXJlKCcuL3NyYy9TZXJpYWxpemVyVmFsaWRhdGlvbicpXG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQdWJsaWNLZXkgPSByZXF1aXJlKFwiLi4vLi4vZWNjL3NyYy9QdWJsaWNLZXlcIik7XG5cbnZhciBGYXN0UGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZhc3RQYXJzZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGYXN0UGFyc2VyKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRmFzdFBhcnNlciwgbnVsbCwgW3tcbiAgICAgICAga2V5OiAnZml4ZWRfZGF0YScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaXhlZF9kYXRhKGIsIGxlbiwgYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2xpY2UoMCwgbGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICAgICAgICAgICAgYi5hcHBlbmQoZGF0YSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChsZW4tLSA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGIud3JpdGVVaW50OCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgICAgICAgICBiLnNraXAobGVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwdWJsaWNfa2V5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1YmxpY19rZXkoYiwgX3B1YmxpY19rZXkpIHtcbiAgICAgICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHVibGljX2tleSkge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBfcHVibGljX2tleS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGIuYXBwZW5kKGJ1ZmZlci50b1N0cmluZygnYmluYXJ5JyksICdiaW5hcnknKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEZhc3RQYXJzZXIuZml4ZWRfZGF0YShiLCAzMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFB1YmxpY0tleS5mcm9tQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JpcGVtZDE2MCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByaXBlbWQxNjAoYiwgX3JpcGVtZCkge1xuICAgICAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9yaXBlbWQpIHtcbiAgICAgICAgICAgICAgICBGYXN0UGFyc2VyLmZpeGVkX2RhdGEoYiwgMjAsIF9yaXBlbWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZhc3RQYXJzZXIuZml4ZWRfZGF0YShiLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RpbWVfcG9pbnRfc2VjJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVfcG9pbnRfc2VjKGIsIGVwb2NoKSB7XG4gICAgICAgICAgICBpZiAoZXBvY2gpIHtcbiAgICAgICAgICAgICAgICBlcG9jaCA9IE1hdGguY2VpbChlcG9jaCAvIDEwMDApO1xuICAgICAgICAgICAgICAgIGIud3JpdGVJbnQzMihlcG9jaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcG9jaCA9IGIucmVhZEludDMyKCk7IC8vIGZjOjp0aW1lX3BvaW50X3NlY1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShlcG9jaCAqIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEZhc3RQYXJzZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFzdFBhcnNlcjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9GYXN0UGFyc2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX215O1xudmFyIGlzX2VtcHR5O1xudmFyIGlzX2RpZ2l0cztcbnZhciB0b19udW1iZXI7XG52YXIgcmVxdWlyZV9tYXRjaDtcbnZhciByZXF1aXJlX29iamVjdF9pZDtcbnZhciByZXF1aXJlX29iamVjdF90eXBlO1xudmFyIGdldF9pbnN0YW5jZTtcbnZhciByZXF1aXJlX3JlbGF0aXZlX3R5cGU7XG52YXIgZ2V0X3JlbGF0aXZlX2luc3RhbmNlO1xudmFyIHJlcXVpcmVfcHJvdG9jb2xfdHlwZTtcbnZhciBnZXRfcHJvdG9jb2xfaW5zdGFuY2U7XG52YXIgZ2V0X3Byb3RvY29sX3R5cGU7XG52YXIgcmVxdWlyZV9pbXBsZW1lbnRhdGlvbl90eXBlO1xudmFyIGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZTtcbnZhciBMb25nID0gcmVxdWlyZSgnYnl0ZWJ1ZmZlcicpLkxvbmc7XG4vLyB2YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2JpZ2knKTtcblxudmFyIGNoYWluX3R5cGVzID0gcmVxdWlyZSgnLi4vLi4vY2hhaW4vc3JjL0NoYWluVHlwZXMnKTtcblxudmFyIE1BWF9TQUZFX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTUlOX1NBRkVfSU5UID0gLTkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICAgIE1vc3QgdmFsaWRhdGlvbnMgYXJlIHNraXBwZWQgYW5kIHRoZSB2YWx1ZSByZXR1cm5lZCB1bmNoYW5nZWQgd2hlbiBhbiBlbXB0eSBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCBpcyBlbmNvdW50ZXJlZCAoZXhjZXB0IFwicmVxdWlyZWRcIikuIFxuICAgIFZhbGlkYXRpb25zIHN1cHBvcnQgYSBzdHJpbmcgZm9ybWF0IGZvciBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycy5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IF9teSA9IHtcblxuICAgIGlzX2VtcHR5OiBpc19lbXB0eSA9IGZ1bmN0aW9uIGlzX2VtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSByZXF1aXJlZCAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZXF1aXJlX2xvbmc6IGZ1bmN0aW9uIHJlcXVpcmVfbG9uZyh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb25nIHZhbHVlIHJlcXVpcmVkICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyByZXF1aXJlZDogJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBudW1iZXI6IGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgcmVxdWlyZWQ6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgd2hvbGVfbnVtYmVyOiBmdW5jdGlvbiB3aG9sZV9udW1iZXIodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXFwuLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aG9sZSBudW1iZXIgcmVxdWlyZWQgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdW5zaWduZWQ6IGZ1bmN0aW9uIHVuc2lnbmVkKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoLy0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2lnbmVkIHJlcXVpcmVkICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICBpc19kaWdpdHM6IGlzX2RpZ2l0cyA9IGZ1bmN0aW9uIGlzX2RpZ2l0cyh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWVyaWNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgvXlswLTldKyQvLnRlc3QodmFsdWUpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHRvX251bWJlcjogdG9fbnVtYmVyID0gZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBfbXkubm9fb3ZlcmZsb3c1Myh2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHZhciBpbnRfdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBpbnRfdmFsdWU7XG4gICAgfSxcblxuICAgIHRvX2xvbmc6IGZ1bmN0aW9uIHRvX2xvbmcodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9teS5ub19vdmVyZmxvdzY0KHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBcIlwiICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgfSxcbiAgICB0b19zdHJpbmc6IGZ1bmN0aW9uIHRvX3N0cmluZyh2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIF9teS5ub19vdmVyZmxvdzUzKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgJ3Vuc3VwcG9ydGVkIHR5cGUgJyArIGZpZWxkX25hbWUgKyAnOiAoJyArICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkgKyAnKSAnICsgdmFsdWU7XG4gICAgfSxcbiAgICByZXF1aXJlX3Rlc3Q6IGZ1bmN0aW9uIHJlcXVpcmVfdGVzdChyZWdleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5tYXRjaGVkICcgKyByZWdleCArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIHJlcXVpcmVfbWF0Y2g6IHJlcXVpcmVfbWF0Y2ggPSBmdW5jdGlvbiByZXF1aXJlX21hdGNoKHJlZ2V4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5tYXRjaGVkICcgKyByZWdleCArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0sXG5cbiAgICAvLyByZXF1aXJlX29iamVjdF9pZDogcmVxdWlyZV9vYmplY3RfaWQ9ZnVuY3Rpb24odmFsdWUsIGZpZWxkX25hbWUpe1xuICAgIC8vICAgICByZXR1cm4gcmVxdWlyZV9tYXRjaChcbiAgICAvLyAgICAgICAgIC9eKFswLTldKylcXC4oWzAtOV0rKVxcLihbMC05XSspJC8sXG4gICAgLy8gICAgICAgICB2YWx1ZSxcbiAgICAvLyAgICAgICAgIGZpZWxkX25hbWVcbiAgICAvLyAgICAgKTtcbiAgICAvLyB9LFxuXG4gICAgLy8gRG9lcyBub3Qgc3VwcG9ydCBvdmVyIDUzIGJpdHNcbiAgICByZXF1aXJlX3JhbmdlOiBmdW5jdGlvbiByZXF1aXJlX3JhbmdlKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgZmllbGRfbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJcIjtcblxuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWJlciA9IHRvX251bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXQgb2YgcmFuZ2UgJyArIHZhbHVlICsgJyAnICsgZmllbGRfbmFtZSArICcgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuXG4gICAgcmVxdWlyZV9vYmplY3RfdHlwZTogcmVxdWlyZV9vYmplY3RfdHlwZSA9IGZ1bmN0aW9uIHJlcXVpcmVfb2JqZWN0X3R5cGUoKSB7XG4gICAgICAgIHZhciByZXNlcnZlZF9zcGFjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIlwiO1xuXG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2JqZWN0X3R5cGUgPSBjaGFpbl90eXBlcy5vYmplY3RfdHlwZVt0eXBlXTtcbiAgICAgICAgaWYgKCFvYmplY3RfdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9iamVjdCB0eXBlOiAnICsgdHlwZSArICcsICcgKyBmaWVsZF9uYW1lICsgJywgJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKHJlc2VydmVkX3NwYWNlcyArICcuJyArIG9iamVjdF90eXBlICsgJy5bMC05XSskJyk7XG4gICAgICAgIGlmICghcmUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nICcgKyB0eXBlICsgJyBpbiBmb3JtYXQgJyArIChyZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZSArICcuWzAtOV0rICcpICsgKCdpbnN0ZWFkIG9mICcgKyB2YWx1ZSArICcgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0X2luc3RhbmNlOiBnZXRfaW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRfaW5zdGFuY2UocmVzZXJ2ZV9zcGFjZXMsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXF1aXJlX29iamVjdF90eXBlKHJlc2VydmVfc3BhY2VzLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gICAgfSxcblxuICAgIHJlcXVpcmVfcmVsYXRpdmVfdHlwZTogcmVxdWlyZV9yZWxhdGl2ZV90eXBlID0gZnVuY3Rpb24gcmVxdWlyZV9yZWxhdGl2ZV90eXBlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIHJlcXVpcmVfb2JqZWN0X3R5cGUoMCwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldF9yZWxhdGl2ZV9pbnN0YW5jZTogZ2V0X3JlbGF0aXZlX2luc3RhbmNlID0gZnVuY3Rpb24gZ2V0X3JlbGF0aXZlX2luc3RhbmNlKHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXF1aXJlX29iamVjdF90eXBlKDAsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRvX251bWJlcih2YWx1ZS5zcGxpdCgnLicpWzJdKTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZV9wcm90b2NvbF90eXBlOiByZXF1aXJlX3Byb3RvY29sX3R5cGUgPSBmdW5jdGlvbiByZXF1aXJlX3Byb3RvY29sX3R5cGUodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgcmVxdWlyZV9vYmplY3RfdHlwZSgxLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0X3Byb3RvY29sX2luc3RhbmNlOiBnZXRfcHJvdG9jb2xfaW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfaW5zdGFuY2UodHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpIHtcbiAgICAgICAgaWYgKGlzX2VtcHR5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVpcmVfb2JqZWN0X3R5cGUoMSwgdHlwZSwgdmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICByZXR1cm4gdG9fbnVtYmVyKHZhbHVlLnNwbGl0KCcuJylbMl0pO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfdHlwZTogZ2V0X3Byb3RvY29sX3R5cGUgPSBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZSh2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZV9vYmplY3RfaWQodmFsdWUsIGZpZWxkX25hbWUpO1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRvX251bWJlcih2YWx1ZXNbMV0pO1xuICAgIH0sXG5cbiAgICBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lOiBmdW5jdGlvbiBnZXRfcHJvdG9jb2xfdHlwZV9uYW1lKHZhbHVlLCBmaWVsZF9uYW1lKSB7XG4gICAgICAgIGlmIChpc19lbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZV9pZCA9IGdldF9wcm90b2NvbF90eXBlKHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNoYWluX3R5cGVzLm9iamVjdF90eXBlKVt0eXBlX2lkXTtcbiAgICB9LFxuXG5cbiAgICByZXF1aXJlX2ltcGxlbWVudGF0aW9uX3R5cGU6IHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZSA9IGZ1bmN0aW9uIHJlcXVpcmVfaW1wbGVtZW50YXRpb25fdHlwZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICByZXF1aXJlX29iamVjdF90eXBlKDIsIHR5cGUsIHZhbHVlLCBmaWVsZF9uYW1lKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRfaW1wbGVtZW50YXRpb25faW5zdGFuY2U6IGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZSA9IGZ1bmN0aW9uIGdldF9pbXBsZW1lbnRhdGlvbl9pbnN0YW5jZSh0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSkge1xuICAgICAgICBpZiAoaXNfZW1wdHkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZV9vYmplY3RfdHlwZSgyLCB0eXBlLCB2YWx1ZSwgZmllbGRfbmFtZSk7XG4gICAgICAgIHJldHVybiB0b19udW1iZXIodmFsdWUuc3BsaXQoJy4nKVsyXSk7XG4gICAgfSxcblxuICAgIC8vIHNpZ25lZCAvIHVuc2lnbmVkIGRlY2ltYWxcbiAgICBub19vdmVyZmxvdzUzOiBmdW5jdGlvbiBub19vdmVyZmxvdzUzKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaWVsZF9uYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIlwiO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGludCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gdHlwZW9mIHZhbHVlLnRvSW50KCkgaXMgJ251bWJlcidcbiAgICAgICAgICAgIF9teS5ub19vdmVyZmxvdzUzKHZhbHVlLnRvSW50KCksIGZpZWxkX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93ICd1bnN1cHBvcnRlZCB0eXBlICcgKyBmaWVsZF9uYW1lICsgJzogKCcgKyAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpICsgJykgJyArIHZhbHVlO1xuICAgIH0sXG5cblxuICAgIC8vIHNpZ25lZCAvIHVuc2lnbmVkIHdob2xlIG51bWJlcnMgb25seVxuICAgIG5vX292ZXJmbG93NjQ6IGZ1bmN0aW9uIG5vX292ZXJmbG93NjQodmFsdWUpIHtcbiAgICAgICAgdmFyIGZpZWxkX25hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vTG9uZy5qcy9pc3N1ZXMvMjBcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmlnSW50ZWdlciNpc0JpZ0ludGVnZXIgaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iaWdpL2lzc3Vlcy8yMFxuICAgICAgICBpZiAodmFsdWUudCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX215Lm5vX292ZXJmbG93NjQodmFsdWUudG9TdHJpbmcoKSwgZmllbGRfbmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgbGVhZGluZyB6ZXJvcywgd2lsbCBjYXVzZSBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14wKy8sICcnKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgd2hpbGUgKC8wJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXFwuJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgZG90XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvbmdfc3RyaW5nID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGxvbmdfc3RyaW5nICE9PSB2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJmbG93ICcgKyBmaWVsZF9uYW1lICsgJyAnICsgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVCB8fCB2YWx1ZSA8IE1JTl9TQUZFX0lOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3ZlcmZsb3cgJyArIGZpZWxkX25hbWUgKyAnICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyAndW5zdXBwb3J0ZWQgdHlwZSAnICsgZmllbGRfbmFtZSArICc6ICgnICsgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSArICcpICcgKyB2YWx1ZTtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL1NlcmlhbGl6ZXJWYWxpZGF0aW9uLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogRXhjZXB0aW9uIG5lc3RpbmcuICAqL1xudmFyIEVycm9yV2l0aENhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVycm9yV2l0aENhdXNlKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcnJvcldpdGhDYXVzZSk7XG5cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYXVzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXVzZSAhPT0gbnVsbCA/IGNhdXNlLm1lc3NhZ2UgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiY2F1c2VcXHRcIiArIGNhdXNlLm1lc3NhZ2UgKyBcIlxcdFwiICsgdGhpcy5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gXCJcIjsgLy8obmV3IEVycm9yKS5zdGFja1xuICAgICAgICBpZiAodHlwZW9mIGNhdXNlICE9PSBcInVuZGVmaW5lZFwiICYmIGNhdXNlICE9PSBudWxsID8gY2F1c2Uuc3RhY2sgOiB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrID0gXCJjYXVzZWQgYnlcXG5cXHRcIiArIGNhdXNlLnN0YWNrICsgXCJcXHRcIiArIHN0YWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMubWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRXJyb3JXaXRoQ2F1c2UsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJ0aHJvd1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93KG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2F1c2UgIT09IFwidW5kZWZpbmVkXCIgJiYgY2F1c2UgIT09IG51bGwgPyBjYXVzZS5tZXNzYWdlIDogdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiXFx0IGNhdXNlOiBcIiArIGNhdXNlLm1lc3NhZ2UgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2F1c2UgIT09IFwidW5kZWZpbmVkXCIgJiYgY2F1c2UgIT09IG51bGwgPyBjYXVzZS5zdGFjayA6IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1zZyArPSBcIlxcbiBzdGFjazogXCIgKyBjYXVzZS5zdGFjayArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRXJyb3JXaXRoQ2F1c2U7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXJyb3JXaXRoQ2F1c2U7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmMvZXJyb3Jfd2l0aF9jYXVzZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vKipcbiAgICBDb252ZXJ0IDEyLjM0IHdpdGggYSBwcmVjaXNpb24gb2YgMyBpbnRvIDEyMzQwXG5cbiAgICBAYXJnIHtudW1iZXJ8c3RyaW5nfSBudW1iZXIgLSBVc2Ugc3RyaW5ncyBmb3IgbGFyZ2UgbnVtYmVycy4gIFRoaXMgbWF5IGNvbnRhaW4gb25lIGRlY2ltYWwgYnV0IG5vIHNpZ25cbiAgICBAYXJnIHtudW1iZXJ9IHByZWNpc2lvbiAtIG51bWJlciBvZiBpbXBsaWVkIGRlY2ltYWwgcGxhY2VzICh1c3VhbGx5IGNhdXNlcyByaWdodCB6ZXJvIHBhZGRpbmcpXG4gICAgQHJldHVybiB7c3RyaW5nfSAtXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdG9JbXBsaWVkRGVjaW1hbDogZnVuY3Rpb24gdG9JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBhc3NlcnQobnVtYmVyIDw9IDkwMDcxOTkyNTQ3NDA5OTEsIFwib3ZlcmZsb3dcIik7XG4gICAgICAgICAgICBudW1iZXIgPSBcIlwiICsgbnVtYmVyO1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlci50b1N0cmluZykgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIgPT09IFwic3RyaW5nXCIsIFwibnVtYmVyIHNob3VsZCBiZSBhbiBhY3R1YWwgbnVtYmVyIG9yIHN0cmluZzogXCIgKyAodHlwZW9mIG51bWJlciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG51bWJlcikpKTtcbiAgICAgICAgbnVtYmVyID0gbnVtYmVyLnRyaW0oKTtcbiAgICAgICAgYXNzZXJ0KC9eWzAtOV0qXFwuP1swLTldKiQvLnRlc3QobnVtYmVyKSwgXCJJbnZhbGlkIGRlY2ltYWwgbnVtYmVyIFwiICsgbnVtYmVyKTtcblxuICAgICAgICB2YXIgX251bWJlciRzcGxpdCA9IG51bWJlci5zcGxpdChcIi5cIiksXG4gICAgICAgICAgICBfbnVtYmVyJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9udW1iZXIkc3BsaXQsIDIpLFxuICAgICAgICAgICAgX251bWJlciRzcGxpdDIkID0gX251bWJlciRzcGxpdDJbMF0sXG4gICAgICAgICAgICB3aG9sZSA9IF9udW1iZXIkc3BsaXQyJCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IF9udW1iZXIkc3BsaXQyJCxcbiAgICAgICAgICAgIF9udW1iZXIkc3BsaXQyJDIgPSBfbnVtYmVyJHNwbGl0MlsxXSxcbiAgICAgICAgICAgIGRlY2ltYWwgPSBfbnVtYmVyJHNwbGl0MiQyID09PSB1bmRlZmluZWQgPyBcIlwiIDogX251bWJlciRzcGxpdDIkMjtcblxuICAgICAgICB2YXIgcGFkZGluZyA9IHByZWNpc2lvbiAtIGRlY2ltYWwubGVuZ3RoO1xuICAgICAgICBhc3NlcnQocGFkZGluZyA+PSAwLCBcIlRvbyBtYW55IGRlY2ltYWwgZGlnaXRzIGluIFwiICsgbnVtYmVyICsgXCIgdG8gY3JlYXRlIGFuIGltcGxpZWQgZGVjaW1hbCBvZiBcIiArIHByZWNpc2lvbik7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgIGRlY2ltYWwgKz0gXCIwXCI7XG4gICAgICAgIH13aGlsZSAod2hvbGUuY2hhckF0KDApID09PSBcIjBcIikge1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1yZXR1cm4gd2hvbGUgKyBkZWNpbWFsO1xuICAgIH0sXG5cbiAgICBmcm9tSW1wbGllZERlY2ltYWw6IGZ1bmN0aW9uIGZyb21JbXBsaWVkRGVjaW1hbChudW1iZXIsIHByZWNpc2lvbikge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYXNzZXJ0KG51bWJlciA8PSA5MDA3MTk5MjU0NzQwOTkxLCBcIm92ZXJmbG93XCIpO1xuICAgICAgICAgICAgbnVtYmVyID0gXCJcIiArIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXIudG9TdHJpbmcpIG51bWJlciA9IG51bWJlci50b1N0cmluZygpO1xuXG4gICAgICAgIHdoaWxlIChudW1iZXIubGVuZ3RoIDwgcHJlY2lzaW9uICsgMSkge1xuICAgICAgICAgICAgLy8gMC4xMjNcbiAgICAgICAgICAgIG51bWJlciA9IFwiMFwiICsgbnVtYmVyO1xuICAgICAgICB9IC8vIDQ0MDAwID0+IDQ0LjAwMFxuICAgICAgICB2YXIgZGVjX3N0cmluZyA9IG51bWJlci5zdWJzdHJpbmcobnVtYmVyLmxlbmd0aCAtIHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiBudW1iZXIuc3Vic3RyaW5nKDAsIG51bWJlci5sZW5ndGggLSBwcmVjaXNpb24pICsgKGRlY19zdHJpbmcgPyBcIi5cIiArIGRlY19zdHJpbmcgOiBcIlwiKTtcbiAgICB9XG59O1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL251bWJlclV0aWxzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBTZXJpYWxpemVySW1wbCA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIik7XG5cbnZhciBpbnQxNiA9IHR5cGVzLmludDE2LFxuICAgIHVpbnQxNiA9IHR5cGVzLnVpbnQxNixcbiAgICB1aW50MzIgPSB0eXBlcy51aW50MzIsXG4gICAgaW50NjQgPSB0eXBlcy5pbnQ2NCxcbiAgICB1aW50NjQgPSB0eXBlcy51aW50NjQsXG4gICAgc3RyaW5nID0gdHlwZXMuc3RyaW5nLFxuICAgIGJ5dGVzID0gdHlwZXMuYnl0ZXMsXG4gICAgYm9vbCA9IHR5cGVzLmJvb2wsXG4gICAgYXJyYXkgPSB0eXBlcy5hcnJheSxcbiAgICBmaXhlZF9hcnJheSA9IHR5cGVzLmZpeGVkX2FycmF5LFxuICAgIG9iamVjdF9pZF90eXBlID0gdHlwZXMub2JqZWN0X2lkX3R5cGUsXG4gICAgdm90ZV9pZCA9IHR5cGVzLnZvdGVfaWQsXG4gICAgc3RyaW5nX2JpbmFyeSA9IHR5cGVzLnN0cmluZ19iaW5hcnksXG4gICAgZnV0dXJlX2V4dGVuc2lvbnMgPSB0eXBlcy5mdXR1cmVfZXh0ZW5zaW9ucyxcbiAgICBoYXJkZm9ya192ZXJzaW9uX3ZvdGUgPSB0eXBlcy5oYXJkZm9ya192ZXJzaW9uX3ZvdGUsXG4gICAgdmVyc2lvbiA9IHR5cGVzLnZlcnNpb24sXG4gICAgc3RhdGljX3ZhcmlhbnQgPSB0eXBlcy5zdGF0aWNfdmFyaWFudCxcbiAgICBtYXAgPSB0eXBlcy5tYXAsXG4gICAgc2V0ID0gdHlwZXMuc2V0LFxuICAgIHB1YmxpY19rZXkgPSB0eXBlcy5wdWJsaWNfa2V5LFxuICAgIGFkZHJlc3MgPSB0eXBlcy5hZGRyZXNzLFxuICAgIHRpbWVfcG9pbnRfc2VjID0gdHlwZXMudGltZV9wb2ludF9zZWMsXG4gICAgb3B0aW9uYWwgPSB0eXBlcy5vcHRpb25hbCxcbiAgICBhc3NldCA9IHR5cGVzLmFzc2V0O1xuXG5mdXR1cmVfZXh0ZW5zaW9ucyA9IHR5cGVzLnZvaWQ7XG5oYXJkZm9ya192ZXJzaW9uX3ZvdGUgPSB0eXBlcy52b2lkO1xudmVyc2lvbiA9IHR5cGVzLnZvaWQ7XG5cbi8vIFBsYWNlLWhvbGRlciwgdGhlaXIgYXJlIGRlcGVuZGVuY2llcyBvbiBcIm9wZXJhdGlvblwiIC4uIFRoZSBmaW5hbCBsaXN0IG9mXG4vLyBvcGVyYXRpb25zIGlzIG5vdCBhdmlhbGJsZSB1bnRpbCB0aGUgdmVyeSBlbmQgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLlxuLy8gU2VlOiBvcGVyYXRpb24uc3Rfb3BlcmF0aW9ucyA9IC4uLlxudmFyIG9wZXJhdGlvbiA9IHN0YXRpY192YXJpYW50KCk7XG5tb2R1bGUuZXhwb3J0c1tcIm9wZXJhdGlvblwiXSA9IG9wZXJhdGlvbjtcblxuLy8gRm9yIG1vZHVsZS5leHBvcnRzXG52YXIgU2VyaWFsaXplciA9IGZ1bmN0aW9uIFNlcmlhbGl6ZXIob3BlcmF0aW9uX25hbWUsIHNlcmlsaXphdGlvbl90eXBlc19vYmplY3QpIHtcbiAgICB2YXIgcyA9IG5ldyBTZXJpYWxpemVySW1wbChvcGVyYXRpb25fbmFtZSwgc2VyaWxpemF0aW9uX3R5cGVzX29iamVjdCk7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzW29wZXJhdGlvbl9uYW1lXSA9IHM7XG59O1xuXG4vLyBDdXN0b20tdHlwZXMgZm9sbG93IEdlbmVyYXRlZCBjb2RlOlxuXG4vLyAjIyAgR2VuZXJhdGVkIGNvZGUgZm9sbG93c1xuLy8gIyBucG0gaSAtZyBkZWNhZmZlaW5hdGVcbi8vICMgcHJvZ3JhbXMvanNfb3BlcmF0aW9uX3NlcmlhbGl6ZXIgPiBvcHMuY29mZmVlICYmIGRlY2FmZmVpbmF0ZSBvcHMuY29mZmVlXG4vLyAjIG9wZW4gb3BzLnR4dCwgY29weSB0byBDaGFpbi9DaGFpblR5cGVzIGFuZCBvcGVyYXRpb25zLmpzXG4vLyAjIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBiZW5lZmljaWFyaWVzID0gbmV3IFNlcmlhbGl6ZXIoXCJiZW5lZmljaWFyaWVzXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgd2VpZ2h0OiB1aW50MTZcbn0pO1xuXG52YXIgY29tbWVudF9wYXlvdXRfYmVuZWZpY2lhcmllcyA9IG5ldyBTZXJpYWxpemVyKDAsIHtcbiAgICBiZW5lZmljaWFyaWVzOiBzZXQoYmVuZWZpY2lhcmllcylcbn0pO1xuXG52YXIgc2lnbmVkX3RyYW5zYWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfdHJhbnNhY3Rpb25cIiwge1xuICAgIHJlZl9ibG9ja19udW06IHVpbnQxNixcbiAgICByZWZfYmxvY2tfcHJlZml4OiB1aW50MzIsXG4gICAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWMsXG4gICAgb3BlcmF0aW9uczogYXJyYXkob3BlcmF0aW9uKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpLFxuICAgIHNpZ25hdHVyZXM6IGFycmF5KGJ5dGVzKDY1KSlcbn0pO1xuXG52YXIgc2lnbmVkX2Jsb2NrID0gbmV3IFNlcmlhbGl6ZXIoXCJzaWduZWRfYmxvY2tcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2Z1dHVyZV9leHRlbnNpb25zLCB2ZXJzaW9uLCBoYXJkZm9ya192ZXJzaW9uX3ZvdGVdKSksXG4gICAgd2l0bmVzc19zaWduYXR1cmU6IGJ5dGVzKDY1KSxcbiAgICB0cmFuc2FjdGlvbnM6IGFycmF5KHNpZ25lZF90cmFuc2FjdGlvbilcbn0pO1xuXG52YXIgYmxvY2tfaGVhZGVyID0gbmV3IFNlcmlhbGl6ZXIoXCJibG9ja19oZWFkZXJcIiwge1xuICAgIHByZXZpb3VzOiBieXRlcygyMCksXG4gICAgdGltZXN0YW1wOiB0aW1lX3BvaW50X3NlYyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgdHJhbnNhY3Rpb25fbWVya2xlX3Jvb3Q6IGJ5dGVzKDIwKSxcbiAgICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2Z1dHVyZV9leHRlbnNpb25zLCB2ZXJzaW9uLCBoYXJkZm9ya192ZXJzaW9uX3ZvdGVdKSlcbn0pO1xuXG52YXIgc2lnbmVkX2Jsb2NrX2hlYWRlciA9IG5ldyBTZXJpYWxpemVyKFwic2lnbmVkX2Jsb2NrX2hlYWRlclwiLCB7XG4gICAgcHJldmlvdXM6IGJ5dGVzKDIwKSxcbiAgICB0aW1lc3RhbXA6IHRpbWVfcG9pbnRfc2VjLFxuICAgIHdpdG5lc3M6IHN0cmluZyxcbiAgICB0cmFuc2FjdGlvbl9tZXJrbGVfcm9vdDogYnl0ZXMoMjApLFxuICAgIGV4dGVuc2lvbnM6IHNldChzdGF0aWNfdmFyaWFudChbZnV0dXJlX2V4dGVuc2lvbnMsIHZlcnNpb24sIGhhcmRmb3JrX3ZlcnNpb25fdm90ZV0pKSxcbiAgICB3aXRuZXNzX3NpZ25hdHVyZTogYnl0ZXMoNjUpXG59KTtcblxudmFyIHZvdGUgPSBuZXcgU2VyaWFsaXplcihcInZvdGVcIiwge1xuICAgIHZvdGVyOiBzdHJpbmcsXG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICB3ZWlnaHQ6IGludDE2XG59KTtcblxudmFyIGNvbW1lbnQgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRcIiwge1xuICAgIHBhcmVudF9hdXRob3I6IHN0cmluZyxcbiAgICBwYXJlbnRfcGVybWxpbms6IHN0cmluZyxcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHRpdGxlOiBzdHJpbmcsXG4gICAgYm9keTogc3RyaW5nLFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG5cbnZhciB0cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNmZXJcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgbWVtbzogc3RyaW5nXG59KTtcblxudmFyIHRyYW5zZmVyX3RvX3Zlc3RpbmcgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX3RvX3Zlc3RpbmdcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGFtb3VudDogYXNzZXRcbn0pO1xuXG52YXIgd2l0aGRyYXdfdmVzdGluZyA9IG5ldyBTZXJpYWxpemVyKFwid2l0aGRyYXdfdmVzdGluZ1wiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHZlc3Rpbmdfc2hhcmVzOiBhc3NldFxufSk7XG5cbnZhciBsaW1pdF9vcmRlcl9jcmVhdGUgPSBuZXcgU2VyaWFsaXplcihcImxpbWl0X29yZGVyX2NyZWF0ZVwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBvcmRlcmlkOiB1aW50MzIsXG4gICAgYW1vdW50X3RvX3NlbGw6IGFzc2V0LFxuICAgIG1pbl90b19yZWNlaXZlOiBhc3NldCxcbiAgICBmaWxsX29yX2tpbGw6IGJvb2wsXG4gICAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWNcbn0pO1xuXG52YXIgbGltaXRfb3JkZXJfY2FuY2VsID0gbmV3IFNlcmlhbGl6ZXIoXCJsaW1pdF9vcmRlcl9jYW5jZWxcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgb3JkZXJpZDogdWludDMyXG59KTtcblxudmFyIHByaWNlID0gbmV3IFNlcmlhbGl6ZXIoXCJwcmljZVwiLCB7XG4gICAgYmFzZTogYXNzZXQsXG4gICAgcXVvdGU6IGFzc2V0XG59KTtcblxudmFyIGZlZWRfcHVibGlzaCA9IG5ldyBTZXJpYWxpemVyKFwiZmVlZF9wdWJsaXNoXCIsIHtcbiAgICBwdWJsaXNoZXI6IHN0cmluZyxcbiAgICBleGNoYW5nZV9yYXRlOiBwcmljZVxufSk7XG5cbnZhciBjb252ZXJ0ID0gbmV3IFNlcmlhbGl6ZXIoXCJjb252ZXJ0XCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIHJlcXVlc3RpZDogdWludDMyLFxuICAgIGFtb3VudDogYXNzZXRcbn0pO1xuXG52YXIgYXV0aG9yaXR5ID0gbmV3IFNlcmlhbGl6ZXIoXCJhdXRob3JpdHlcIiwge1xuICAgIHdlaWdodF90aHJlc2hvbGQ6IHVpbnQzMixcbiAgICBhY2NvdW50X2F1dGhzOiBtYXAoc3RyaW5nLCB1aW50MTYpLFxuICAgIGtleV9hdXRoczogbWFwKHB1YmxpY19rZXksIHVpbnQxNilcbn0pO1xuXG52YXIgYWNjb3VudF9jcmVhdGUgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfY3JlYXRlXCIsIHtcbiAgICBmZWU6IGFzc2V0LFxuICAgIGNyZWF0b3I6IHN0cmluZyxcbiAgICBuZXdfYWNjb3VudF9uYW1lOiBzdHJpbmcsXG4gICAgb3duZXI6IGF1dGhvcml0eSxcbiAgICBhY3RpdmU6IGF1dGhvcml0eSxcbiAgICBwb3N0aW5nOiBhdXRob3JpdHksXG4gICAgbWVtb19rZXk6IHB1YmxpY19rZXksXG4gICAganNvbl9tZXRhZGF0YTogc3RyaW5nXG59KTtcblxudmFyIGFjY291bnRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJhY2NvdW50X3VwZGF0ZVwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIG93bmVyOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICAgIGFjdGl2ZTogb3B0aW9uYWwoYXV0aG9yaXR5KSxcbiAgICBwb3N0aW5nOiBvcHRpb25hbChhdXRob3JpdHkpLFxuICAgIG1lbW9fa2V5OiBwdWJsaWNfa2V5LFxuICAgIGpzb25fbWV0YWRhdGE6IHN0cmluZ1xufSk7XG5cbnZhciBjaGFpbl9wcm9wZXJ0aWVzID0gbmV3IFNlcmlhbGl6ZXIoXCJjaGFpbl9wcm9wZXJ0aWVzXCIsIHtcbiAgICBhY2NvdW50X2NyZWF0aW9uX2ZlZTogYXNzZXQsXG4gICAgbWF4aW11bV9ibG9ja19zaXplOiB1aW50MzIsXG4gICAgc2JkX2ludGVyZXN0X3JhdGU6IHVpbnQxNlxufSk7XG5cbnZhciB3aXRuZXNzX3VwZGF0ZSA9IG5ldyBTZXJpYWxpemVyKFwid2l0bmVzc191cGRhdGVcIiwge1xuICAgIG93bmVyOiBzdHJpbmcsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgYmxvY2tfc2lnbmluZ19rZXk6IHB1YmxpY19rZXksXG4gICAgcHJvcHM6IGNoYWluX3Byb3BlcnRpZXMsXG4gICAgZmVlOiBhc3NldFxufSk7XG5cbnZhciBhY2NvdW50X3dpdG5lc3Nfdm90ZSA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF93aXRuZXNzX3ZvdGVcIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICB3aXRuZXNzOiBzdHJpbmcsXG4gICAgYXBwcm92ZTogYm9vbFxufSk7XG5cbnZhciBhY2NvdW50X3dpdG5lc3NfcHJveHkgPSBuZXcgU2VyaWFsaXplcihcImFjY291bnRfd2l0bmVzc19wcm94eVwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHByb3h5OiBzdHJpbmdcbn0pO1xuXG52YXIgcG93ID0gbmV3IFNlcmlhbGl6ZXIoXCJwb3dcIiwge1xuICAgIHdvcmtlcjogcHVibGljX2tleSxcbiAgICBpbnB1dDogYnl0ZXMoMzIpLFxuICAgIHNpZ25hdHVyZTogYnl0ZXMoNjUpLFxuICAgIHdvcms6IGJ5dGVzKDMyKVxufSk7XG5cbnZhciBjdXN0b20gPSBuZXcgU2VyaWFsaXplcihcImN1c3RvbVwiLCB7XG4gICAgcmVxdWlyZWRfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIGlkOiB1aW50MTYsXG4gICAgZGF0YTogYnl0ZXMoKVxufSk7XG5cbnZhciByZXBvcnRfb3Zlcl9wcm9kdWN0aW9uID0gbmV3IFNlcmlhbGl6ZXIoXCJyZXBvcnRfb3Zlcl9wcm9kdWN0aW9uXCIsIHtcbiAgICByZXBvcnRlcjogc3RyaW5nLFxuICAgIGZpcnN0X2Jsb2NrOiBzaWduZWRfYmxvY2tfaGVhZGVyLFxuICAgIHNlY29uZF9ibG9jazogc2lnbmVkX2Jsb2NrX2hlYWRlclxufSk7XG5cbnZhciBkZWxldGVfY29tbWVudCA9IG5ldyBTZXJpYWxpemVyKFwiZGVsZXRlX2NvbW1lbnRcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmdcbn0pO1xuXG52YXIgY3VzdG9tX2pzb24gPSBuZXcgU2VyaWFsaXplcihcImN1c3RvbV9qc29uXCIsIHtcbiAgICByZXF1aXJlZF9hdXRoczogc2V0KHN0cmluZyksXG4gICAgcmVxdWlyZWRfcG9zdGluZ19hdXRoczogc2V0KHN0cmluZyksXG4gICAgaWQ6IHN0cmluZyxcbiAgICBqc29uOiBzdHJpbmdcbn0pO1xuXG52YXIgY29tbWVudF9vcHRpb25zID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X29wdGlvbnNcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmcsXG4gICAgbWF4X2FjY2VwdGVkX3BheW91dDogYXNzZXQsXG4gICAgcGVyY2VudF9zdGVlbV9kb2xsYXJzOiB1aW50MTYsXG4gICAgYWxsb3dfdm90ZXM6IGJvb2wsXG4gICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogYm9vbCxcbiAgICBleHRlbnNpb25zOiBzZXQoc3RhdGljX3ZhcmlhbnQoW2NvbW1lbnRfcGF5b3V0X2JlbmVmaWNpYXJpZXNdKSlcbn0pO1xuXG52YXIgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGUgPSBuZXcgU2VyaWFsaXplcihcInNldF93aXRoZHJhd192ZXN0aW5nX3JvdXRlXCIsIHtcbiAgICBmcm9tX2FjY291bnQ6IHN0cmluZyxcbiAgICB0b19hY2NvdW50OiBzdHJpbmcsXG4gICAgcGVyY2VudDogdWludDE2LFxuICAgIGF1dG9fdmVzdDogYm9vbFxufSk7XG5cbnZhciBsaW1pdF9vcmRlcl9jcmVhdGUyID0gbmV3IFNlcmlhbGl6ZXIoXCJsaW1pdF9vcmRlcl9jcmVhdGUyXCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIG9yZGVyaWQ6IHVpbnQzMixcbiAgICBhbW91bnRfdG9fc2VsbDogYXNzZXQsXG4gICAgZXhjaGFuZ2VfcmF0ZTogcHJpY2UsXG4gICAgZmlsbF9vcl9raWxsOiBib29sLFxuICAgIGV4cGlyYXRpb246IHRpbWVfcG9pbnRfc2VjXG59KTtcblxudmFyIGNoYWxsZW5nZV9hdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcImNoYWxsZW5nZV9hdXRob3JpdHlcIiwge1xuICAgIGNoYWxsZW5nZXI6IHN0cmluZyxcbiAgICBjaGFsbGVuZ2VkOiBzdHJpbmcsXG4gICAgcmVxdWlyZV9vd25lcjogYm9vbFxufSk7XG5cbnZhciBwcm92ZV9hdXRob3JpdHkgPSBuZXcgU2VyaWFsaXplcihcInByb3ZlX2F1dGhvcml0eVwiLCB7XG4gICAgY2hhbGxlbmdlZDogc3RyaW5nLFxuICAgIHJlcXVpcmVfb3duZXI6IGJvb2xcbn0pO1xuXG52YXIgcmVxdWVzdF9hY2NvdW50X3JlY292ZXJ5ID0gbmV3IFNlcmlhbGl6ZXIoXCJyZXF1ZXN0X2FjY291bnRfcmVjb3ZlcnlcIiwge1xuICAgIHJlY292ZXJ5X2FjY291bnQ6IHN0cmluZyxcbiAgICBhY2NvdW50X3RvX3JlY292ZXI6IHN0cmluZyxcbiAgICBuZXdfb3duZXJfYXV0aG9yaXR5OiBhdXRob3JpdHksXG4gICAgZXh0ZW5zaW9uczogc2V0KGZ1dHVyZV9leHRlbnNpb25zKVxufSk7XG5cbnZhciByZWNvdmVyX2FjY291bnQgPSBuZXcgU2VyaWFsaXplcihcInJlY292ZXJfYWNjb3VudFwiLCB7XG4gICAgYWNjb3VudF90b19yZWNvdmVyOiBzdHJpbmcsXG4gICAgbmV3X293bmVyX2F1dGhvcml0eTogYXV0aG9yaXR5LFxuICAgIHJlY2VudF9vd25lcl9hdXRob3JpdHk6IGF1dGhvcml0eSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxudmFyIGNoYW5nZV9yZWNvdmVyeV9hY2NvdW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJjaGFuZ2VfcmVjb3ZlcnlfYWNjb3VudFwiLCB7XG4gICAgYWNjb3VudF90b19yZWNvdmVyOiBzdHJpbmcsXG4gICAgbmV3X3JlY292ZXJ5X2FjY291bnQ6IHN0cmluZyxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxudmFyIGVzY3Jvd190cmFuc2ZlciA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X3RyYW5zZmVyXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBzYmRfYW1vdW50OiBhc3NldCxcbiAgICBzdGVlbV9hbW91bnQ6IGFzc2V0LFxuICAgIGVzY3Jvd19pZDogdWludDMyLFxuICAgIGFnZW50OiBzdHJpbmcsXG4gICAgZmVlOiBhc3NldCxcbiAgICBqc29uX21ldGE6IHN0cmluZyxcbiAgICByYXRpZmljYXRpb25fZGVhZGxpbmU6IHRpbWVfcG9pbnRfc2VjLFxuICAgIGVzY3Jvd19leHBpcmF0aW9uOiB0aW1lX3BvaW50X3NlY1xufSk7XG5cbnZhciBlc2Nyb3dfZGlzcHV0ZSA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X2Rpc3B1dGVcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGFnZW50OiBzdHJpbmcsXG4gICAgd2hvOiBzdHJpbmcsXG4gICAgZXNjcm93X2lkOiB1aW50MzJcbn0pO1xuXG52YXIgZXNjcm93X3JlbGVhc2UgPSBuZXcgU2VyaWFsaXplcihcImVzY3Jvd19yZWxlYXNlXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhZ2VudDogc3RyaW5nLFxuICAgIHdobzogc3RyaW5nLFxuICAgIHJlY2VpdmVyOiBzdHJpbmcsXG4gICAgZXNjcm93X2lkOiB1aW50MzIsXG4gICAgc2JkX2Ftb3VudDogYXNzZXQsXG4gICAgc3RlZW1fYW1vdW50OiBhc3NldFxufSk7XG5cbnZhciBwb3cyX2lucHV0ID0gbmV3IFNlcmlhbGl6ZXIoXCJwb3cyX2lucHV0XCIsIHtcbiAgICB3b3JrZXJfYWNjb3VudDogc3RyaW5nLFxuICAgIHByZXZfYmxvY2s6IGJ5dGVzKDIwKSxcbiAgICBub25jZTogdWludDY0XG59KTtcblxudmFyIHBvdzIgPSBuZXcgU2VyaWFsaXplcihcInBvdzJcIiwge1xuICAgIGlucHV0OiBwb3cyX2lucHV0LFxuICAgIHBvd19zdW1tYXJ5OiB1aW50MzJcbn0pO1xuXG52YXIgZXF1aWhhc2hfcHJvb2YgPSBuZXcgU2VyaWFsaXplcihcImVxdWloYXNoX3Byb29mXCIsIHtcbiAgICBuOiB1aW50MzIsXG4gICAgazogdWludDMyLFxuICAgIHNlZWQ6IGJ5dGVzKDMyKSxcbiAgICBpbnB1dHM6IGFycmF5KHVpbnQzMilcbn0pO1xuXG52YXIgZXF1aWhhc2hfcG93ID0gbmV3IFNlcmlhbGl6ZXIoXCJlcXVpaGFzaF9wb3dcIiwge1xuICAgIGlucHV0OiBwb3cyX2lucHV0LFxuICAgIHByb29mOiBlcXVpaGFzaF9wcm9vZixcbiAgICBwcmV2X2Jsb2NrOiBieXRlcygyMCksXG4gICAgcG93X3N1bW1hcnk6IHVpbnQzMlxufSk7XG5cbnZhciBlc2Nyb3dfYXBwcm92ZSA9IG5ldyBTZXJpYWxpemVyKFwiZXNjcm93X2FwcHJvdmVcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGFnZW50OiBzdHJpbmcsXG4gICAgd2hvOiBzdHJpbmcsXG4gICAgZXNjcm93X2lkOiB1aW50MzIsXG4gICAgYXBwcm92ZTogYm9vbFxufSk7XG5cbnZhciB0cmFuc2Zlcl90b19zYXZpbmdzID0gbmV3IFNlcmlhbGl6ZXIoXCJ0cmFuc2Zlcl90b19zYXZpbmdzXCIsIHtcbiAgICBmcm9tOiBzdHJpbmcsXG4gICAgdG86IHN0cmluZyxcbiAgICBhbW91bnQ6IGFzc2V0LFxuICAgIG1lbW86IHN0cmluZ1xufSk7XG5cbnZhciB0cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcInRyYW5zZmVyX2Zyb21fc2F2aW5nc1wiLCB7XG4gICAgZnJvbTogc3RyaW5nLFxuICAgIHJlcXVlc3RfaWQ6IHVpbnQzMixcbiAgICB0bzogc3RyaW5nLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgbWVtbzogc3RyaW5nXG59KTtcblxudmFyIGNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3MgPSBuZXcgU2VyaWFsaXplcihcImNhbmNlbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3NcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICByZXF1ZXN0X2lkOiB1aW50MzJcbn0pO1xuXG52YXIgY3VzdG9tX2JpbmFyeSA9IG5ldyBTZXJpYWxpemVyKFwiY3VzdG9tX2JpbmFyeVwiLCB7XG4gICAgcmVxdWlyZWRfb3duZXJfYXV0aHM6IHNldChzdHJpbmcpLFxuICAgIHJlcXVpcmVkX2FjdGl2ZV9hdXRoczogc2V0KHN0cmluZyksXG4gICAgcmVxdWlyZWRfcG9zdGluZ19hdXRoczogc2V0KHN0cmluZyksXG4gICAgcmVxdWlyZWRfYXV0aHM6IGFycmF5KGF1dGhvcml0eSksXG4gICAgaWQ6IHN0cmluZyxcbiAgICBkYXRhOiBieXRlcygpXG59KTtcblxudmFyIGRlY2xpbmVfdm90aW5nX3JpZ2h0cyA9IG5ldyBTZXJpYWxpemVyKFwiZGVjbGluZV92b3RpbmdfcmlnaHRzXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgZGVjbGluZTogYm9vbFxufSk7XG5cbnZhciByZXNldF9hY2NvdW50ID0gbmV3IFNlcmlhbGl6ZXIoXCJyZXNldF9hY2NvdW50XCIsIHtcbiAgICByZXNldF9hY2NvdW50OiBzdHJpbmcsXG4gICAgYWNjb3VudF90b19yZXNldDogc3RyaW5nLFxuICAgIG5ld19vd25lcl9hdXRob3JpdHk6IGF1dGhvcml0eVxufSk7XG5cbnZhciBzZXRfcmVzZXRfYWNjb3VudCA9IG5ldyBTZXJpYWxpemVyKFwic2V0X3Jlc2V0X2FjY291bnRcIiwge1xuICAgIGFjY291bnQ6IHN0cmluZyxcbiAgICBjdXJyZW50X3Jlc2V0X2FjY291bnQ6IHN0cmluZyxcbiAgICByZXNldF9hY2NvdW50OiBzdHJpbmdcbn0pO1xuXG52YXIgY2xhaW1fcmV3YXJkX2JhbGFuY2UgPSBuZXcgU2VyaWFsaXplcihcImNsYWltX3Jld2FyZF9iYWxhbmNlXCIsIHtcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgcmV3YXJkX3N0ZWVtOiBhc3NldCxcbiAgICByZXdhcmRfc2JkOiBhc3NldCxcbiAgICByZXdhcmRfdmVzdHM6IGFzc2V0XG59KTtcblxudmFyIGRlbGVnYXRlX3Zlc3Rpbmdfc2hhcmVzID0gbmV3IFNlcmlhbGl6ZXIoXCJkZWxlZ2F0ZV92ZXN0aW5nX3NoYXJlc1wiLCB7XG4gICAgZGVsZWdhdG9yOiBzdHJpbmcsXG4gICAgZGVsZWdhdGVlOiBzdHJpbmcsXG4gICAgdmVzdGluZ19zaGFyZXM6IGFzc2V0XG59KTtcblxudmFyIGFjY291bnRfY3JlYXRlX3dpdGhfZGVsZWdhdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwiYWNjb3VudF9jcmVhdGVfd2l0aF9kZWxlZ2F0aW9uXCIsIHtcbiAgICBmZWU6IGFzc2V0LFxuICAgIGRlbGVnYXRpb246IGFzc2V0LFxuICAgIGNyZWF0b3I6IHN0cmluZyxcbiAgICBuZXdfYWNjb3VudF9uYW1lOiBzdHJpbmcsXG4gICAgb3duZXI6IGF1dGhvcml0eSxcbiAgICBhY3RpdmU6IGF1dGhvcml0eSxcbiAgICBwb3N0aW5nOiBhdXRob3JpdHksXG4gICAgbWVtb19rZXk6IHB1YmxpY19rZXksXG4gICAganNvbl9tZXRhZGF0YTogc3RyaW5nLFxuICAgIGV4dGVuc2lvbnM6IHNldChmdXR1cmVfZXh0ZW5zaW9ucylcbn0pO1xuXG52YXIgZmlsbF9jb252ZXJ0X3JlcXVlc3QgPSBuZXcgU2VyaWFsaXplcihcImZpbGxfY29udmVydF9yZXF1ZXN0XCIsIHtcbiAgICBvd25lcjogc3RyaW5nLFxuICAgIHJlcXVlc3RpZDogdWludDMyLFxuICAgIGFtb3VudF9pbjogYXNzZXQsXG4gICAgYW1vdW50X291dDogYXNzZXRcbn0pO1xuXG52YXIgYXV0aG9yX3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwiYXV0aG9yX3Jld2FyZFwiLCB7XG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICBzYmRfcGF5b3V0OiBhc3NldCxcbiAgICBzdGVlbV9wYXlvdXQ6IGFzc2V0LFxuICAgIHZlc3RpbmdfcGF5b3V0OiBhc3NldFxufSk7XG5cbnZhciBjdXJhdGlvbl9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImN1cmF0aW9uX3Jld2FyZFwiLCB7XG4gICAgY3VyYXRvcjogc3RyaW5nLFxuICAgIHJld2FyZDogYXNzZXQsXG4gICAgY29tbWVudF9hdXRob3I6IHN0cmluZyxcbiAgICBjb21tZW50X3Blcm1saW5rOiBzdHJpbmdcbn0pO1xuXG52YXIgY29tbWVudF9yZXdhcmQgPSBuZXcgU2VyaWFsaXplcihcImNvbW1lbnRfcmV3YXJkXCIsIHtcbiAgICBhdXRob3I6IHN0cmluZyxcbiAgICBwZXJtbGluazogc3RyaW5nLFxuICAgIHBheW91dDogYXNzZXRcbn0pO1xuXG52YXIgbGlxdWlkaXR5X3Jld2FyZCA9IG5ldyBTZXJpYWxpemVyKFwibGlxdWlkaXR5X3Jld2FyZFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBwYXlvdXQ6IGFzc2V0XG59KTtcblxudmFyIGludGVyZXN0ID0gbmV3IFNlcmlhbGl6ZXIoXCJpbnRlcmVzdFwiLCB7XG4gICAgb3duZXI6IHN0cmluZyxcbiAgICBpbnRlcmVzdDogYXNzZXRcbn0pO1xuXG52YXIgZmlsbF92ZXN0aW5nX3dpdGhkcmF3ID0gbmV3IFNlcmlhbGl6ZXIoXCJmaWxsX3Zlc3Rpbmdfd2l0aGRyYXdcIiwge1xuICAgIGZyb21fYWNjb3VudDogc3RyaW5nLFxuICAgIHRvX2FjY291bnQ6IHN0cmluZyxcbiAgICB3aXRoZHJhd246IGFzc2V0LFxuICAgIGRlcG9zaXRlZDogYXNzZXRcbn0pO1xuXG52YXIgZmlsbF9vcmRlciA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF9vcmRlclwiLCB7XG4gICAgY3VycmVudF9vd25lcjogc3RyaW5nLFxuICAgIGN1cnJlbnRfb3JkZXJpZDogdWludDMyLFxuICAgIGN1cnJlbnRfcGF5czogYXNzZXQsXG4gICAgb3Blbl9vd25lcjogc3RyaW5nLFxuICAgIG9wZW5fb3JkZXJpZDogdWludDMyLFxuICAgIG9wZW5fcGF5czogYXNzZXRcbn0pO1xuXG52YXIgc2h1dGRvd25fd2l0bmVzcyA9IG5ldyBTZXJpYWxpemVyKFwic2h1dGRvd25fd2l0bmVzc1wiLCB7IG93bmVyOiBzdHJpbmcgfSk7XG5cbnZhciBmaWxsX3RyYW5zZmVyX2Zyb21fc2F2aW5ncyA9IG5ldyBTZXJpYWxpemVyKFwiZmlsbF90cmFuc2Zlcl9mcm9tX3NhdmluZ3NcIiwge1xuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGFtb3VudDogYXNzZXQsXG4gICAgcmVxdWVzdF9pZDogdWludDMyLFxuICAgIG1lbW86IHN0cmluZ1xufSk7XG5cbnZhciBoYXJkZm9yayA9IG5ldyBTZXJpYWxpemVyKFwiaGFyZGZvcmtcIiwgeyBoYXJkZm9ya19pZDogdWludDMyIH0pO1xuXG52YXIgY29tbWVudF9wYXlvdXRfdXBkYXRlID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X3BheW91dF91cGRhdGVcIiwge1xuICAgIGF1dGhvcjogc3RyaW5nLFxuICAgIHBlcm1saW5rOiBzdHJpbmdcbn0pO1xuXG52YXIgcmV0dXJuX3Zlc3RpbmdfZGVsZWdhdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwicmV0dXJuX3Zlc3RpbmdfZGVsZWdhdGlvblwiLCB7XG4gICAgYWNjb3VudDogc3RyaW5nLFxuICAgIHZlc3Rpbmdfc2hhcmVzOiBhc3NldFxufSk7XG5cbnZhciBjb21tZW50X2JlbmVmYWN0b3JfcmV3YXJkID0gbmV3IFNlcmlhbGl6ZXIoXCJjb21tZW50X2JlbmVmYWN0b3JfcmV3YXJkXCIsIHtcbiAgICBiZW5lZmFjdG9yOiBzdHJpbmcsXG4gICAgYXV0aG9yOiBzdHJpbmcsXG4gICAgcGVybWxpbms6IHN0cmluZyxcbiAgICByZXdhcmQ6IGFzc2V0XG59KTtcblxub3BlcmF0aW9uLnN0X29wZXJhdGlvbnMgPSBbdm90ZSwgY29tbWVudCwgdHJhbnNmZXIsIHRyYW5zZmVyX3RvX3Zlc3RpbmcsIHdpdGhkcmF3X3Zlc3RpbmcsIGxpbWl0X29yZGVyX2NyZWF0ZSwgbGltaXRfb3JkZXJfY2FuY2VsLCBmZWVkX3B1Ymxpc2gsIGNvbnZlcnQsIGFjY291bnRfY3JlYXRlLCBhY2NvdW50X3VwZGF0ZSwgd2l0bmVzc191cGRhdGUsIGFjY291bnRfd2l0bmVzc192b3RlLCBhY2NvdW50X3dpdG5lc3NfcHJveHksIHBvdywgY3VzdG9tLCByZXBvcnRfb3Zlcl9wcm9kdWN0aW9uLCBkZWxldGVfY29tbWVudCwgY3VzdG9tX2pzb24sIGNvbW1lbnRfb3B0aW9ucywgc2V0X3dpdGhkcmF3X3Zlc3Rpbmdfcm91dGUsIGxpbWl0X29yZGVyX2NyZWF0ZTIsIGNoYWxsZW5nZV9hdXRob3JpdHksIHByb3ZlX2F1dGhvcml0eSwgcmVxdWVzdF9hY2NvdW50X3JlY292ZXJ5LCByZWNvdmVyX2FjY291bnQsIGNoYW5nZV9yZWNvdmVyeV9hY2NvdW50LCBlc2Nyb3dfdHJhbnNmZXIsIGVzY3Jvd19kaXNwdXRlLCBlc2Nyb3dfcmVsZWFzZSwgcG93MiwgZXNjcm93X2FwcHJvdmUsIHRyYW5zZmVyX3RvX3NhdmluZ3MsIHRyYW5zZmVyX2Zyb21fc2F2aW5ncywgY2FuY2VsX3RyYW5zZmVyX2Zyb21fc2F2aW5ncywgY3VzdG9tX2JpbmFyeSwgZGVjbGluZV92b3RpbmdfcmlnaHRzLCByZXNldF9hY2NvdW50LCBzZXRfcmVzZXRfYWNjb3VudCwgY2xhaW1fcmV3YXJkX2JhbGFuY2UsIGRlbGVnYXRlX3Zlc3Rpbmdfc2hhcmVzLCBhY2NvdW50X2NyZWF0ZV93aXRoX2RlbGVnYXRpb24sIGZpbGxfY29udmVydF9yZXF1ZXN0LCBhdXRob3JfcmV3YXJkLCBjdXJhdGlvbl9yZXdhcmQsIGNvbW1lbnRfcmV3YXJkLCBsaXF1aWRpdHlfcmV3YXJkLCBpbnRlcmVzdCwgZmlsbF92ZXN0aW5nX3dpdGhkcmF3LCBmaWxsX29yZGVyLCBzaHV0ZG93bl93aXRuZXNzLCBmaWxsX3RyYW5zZmVyX2Zyb21fc2F2aW5ncywgaGFyZGZvcmssIGNvbW1lbnRfcGF5b3V0X3VwZGF0ZSwgcmV0dXJuX3Zlc3RpbmdfZGVsZWdhdGlvbiwgY29tbWVudF9iZW5lZmFjdG9yX3Jld2FyZF07XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBTZXJpYWxpemVyKFwidHJhbnNhY3Rpb25cIiwge1xuICAgIHJlZl9ibG9ja19udW06IHVpbnQxNixcbiAgICByZWZfYmxvY2tfcHJlZml4OiB1aW50MzIsXG4gICAgZXhwaXJhdGlvbjogdGltZV9wb2ludF9zZWMsXG4gICAgb3BlcmF0aW9uczogYXJyYXkob3BlcmF0aW9uKSxcbiAgICBleHRlbnNpb25zOiBzZXQoZnV0dXJlX2V4dGVuc2lvbnMpXG59KTtcblxuLy8jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIyAgR2VuZXJhdGVkIGNvZGUgZW5kICBTIFQgTyBQXG4vLyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBDdXN0b20gVHlwZXMgKGRvIG5vdCBvdmVyLXdyaXRlKVxuXG52YXIgZW5jcnlwdGVkX21lbW8gPSBuZXcgU2VyaWFsaXplcihcImVuY3J5cHRlZF9tZW1vXCIsIHsgZnJvbTogcHVibGljX2tleSxcbiAgICB0bzogcHVibGljX2tleSxcbiAgICBub25jZTogdWludDY0LFxuICAgIGNoZWNrOiB1aW50MzIsXG4gICAgZW5jcnlwdGVkOiBzdHJpbmdfYmluYXJ5IH0pO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjL29wZXJhdGlvbnMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9kaXN0L3NlcmlhbGl6ZXIvc3JjXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnl0ZUJ1ZmZlciA9IHJlcXVpcmUoJ2J5dGVidWZmZXInKTtcbnZhciBFQyA9IHJlcXVpcmUoJy4vZXJyb3Jfd2l0aF9jYXVzZScpO1xuXG52YXIgSEVYX0RVTVAgPSBwcm9jZXNzLmVudi5ucG1fY29uZmlnX19ncmFwaGVuZV9zZXJpYWxpemVyX2hleF9kdW1wO1xuXG52YXIgU2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJpYWxpemVyKG9wZXJhdGlvbl9uYW1lLCB0eXBlcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VyaWFsaXplcik7XG5cbiAgICAgICAgdGhpcy5vcGVyYXRpb25fbmFtZSA9IG9wZXJhdGlvbl9uYW1lO1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGlmICh0aGlzLnR5cGVzKSB0aGlzLmtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnR5cGVzKTtcblxuICAgICAgICBTZXJpYWxpemVyLnByaW50RGVidWcgPSB0cnVlO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTZXJpYWxpemVyLCBbe1xuICAgICAgICBrZXk6ICdmcm9tQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLmtleXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGVzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlLm9wZXJhdGlvbl9uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IodHlwZS5vcGVyYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8xID0gYi5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMiA9IGIub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLm9mZnNldCA9IG8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2IucmVzZXQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBiLmNvcHkobzEsIG8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyAnXFx0JywgX2IudG9IZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2ZpZWxkXSA9IHR5cGUuZnJvbUJ5dGVCdWZmZXIoYik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTZXJpYWxpemVyLnByaW50RGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nICcgKyB0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQgKyAnIGluIGRhdGE6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5wcmludERlYnVnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXBwZW5kQnl0ZUJ1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhYmxlID0gdGhpcy5rZXlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIHR5cGUuYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbZmllbGRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEVDLnRocm93KHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCArIFwiID0gXCIgKyBKU09OLnN0cmluZ2lmeShvYmplY3RbZmllbGRdKSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2lyY3VsYXIgcmVmXG4gICAgICAgICAgICAgICAgICAgIEVDLnRocm93KHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCArIFwiID0gXCIgKyBvYmplY3RbZmllbGRdLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21PYmplY3Qoc2VyaWFsaXplZF9vYmplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzZXJpYWxpemVkX29iamVjdFtmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIC8vREVCVUcgdmFsdWUgPSB2YWx1ZS5yZXNvbHZlIGlmIHZhbHVlLnJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgLy9ERUJVRyBjb25zb2xlLmxvZygnLi4uIHZhbHVlJyxmaWVsZCx2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHR5cGUuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtmaWVsZF0gPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBFQy50aHJvdyh0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2RlYnVnLnVzZV9kZWZhdWx0ID0gZmFsc2VdIC0gbW9yZSB0ZW1wbGF0ZSBmcmllbmRseVxuICAgICAgICAgICAgQGFyZyB7Ym9vbGVhbn0gW2RlYnVnLmFubm90YXRlID0gZmFsc2VdIC0gYWRkIHVzZXItZnJpZW5kbHkgaW5mb3JtYXRpb25cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9PYmplY3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZF9vYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IHVzZV9kZWZhdWx0OiBmYWxzZSwgYW5ub3RhdGU6IGZhbHNlIH07XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlcykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMua2V5cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gdHlwZS50b09iamVjdCh0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGwgPyBzZXJpYWxpemVkX29iamVjdFtmaWVsZF0gOiB1bmRlZmluZWQsIGRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkXSA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBCeXRlQnVmZmVyKEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNfdmFsdWUgPSB0eXBlb2Ygc2VyaWFsaXplZF9vYmplY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VyaWFsaXplZF9vYmplY3QgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VyaWFsaXplZF9vYmplY3RbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgdHlwZS5hcHBlbmRCeXRlQnVmZmVyKGIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcih0aGlzLm9wZXJhdGlvbl9uYW1lICsgJy4nICsgZmllbGQsIGIudG9IZXgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIEVDLnRocm93KHRoaXMub3BlcmF0aW9uX25hbWUgKyAnLicgKyBmaWVsZCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIFNvcnQgYnkgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBvcGVyYXRpb24gKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcGFyZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcblxuICAgICAgICAgICAgdmFyIGZpcnN0X2tleSA9IHRoaXMua2V5c1swXTtcbiAgICAgICAgICAgIHZhciBmaXJzdF90eXBlID0gdGhpcy50eXBlc1tmaXJzdF9rZXldO1xuXG4gICAgICAgICAgICB2YXIgdmFsQSA9IGFbZmlyc3Rfa2V5XTtcbiAgICAgICAgICAgIHZhciB2YWxCID0gYltmaXJzdF9rZXldO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RfdHlwZS5jb21wYXJlKSByZXR1cm4gZmlyc3RfdHlwZS5jb21wYXJlKHZhbEEsIHZhbEIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbEEgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHZhbEIgPT09IFwibnVtYmVyXCIpIHJldHVybiB2YWxBIC0gdmFsQjtcblxuICAgICAgICAgICAgdmFyIGVuY29kaW5nID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWxBKSAmJiBCdWZmZXIuaXNCdWZmZXIodmFsQikpIHtcbiAgICAgICAgICAgICAgICAvLyBBIGJpbmFyeSBzdHJpbmcgY29tcGFyZSBkb2VzIG5vdCB3b3JrLiAgSWYgbG9jYWxlQ29tcGFyZSBpcyB3ZWxsIHN1cHBvcnRlZCB0aGF0IGNvdWxkIHJlcGxhY2UgSEVYLiAgUGVyZm9ybWFuYW5jZSBpcyB2ZXJ5IGdvb2Qgc28gY29tcGFyaW5nIEhFWCB3b3Jrcy5cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFwiaGV4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdHJBID0gdmFsQS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICB2YXIgc3RyQiA9IHZhbEIudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ckEgPiBzdHJCID8gMSA6IHN0ckEgPCBzdHJCID8gLTEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gPGhlbHBlcl9mdW5jdGlvbnM+XG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zyb21IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIHZhciBiID0gQnl0ZUJ1ZmZlci5mcm9tSGV4KGhleCwgQnl0ZUJ1ZmZlci5MSVRUTEVfRU5ESUFOKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmcm9tQnVmZmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShidWZmZXIudG9TdHJpbmcoXCJiaW5hcnlcIiksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9IZXgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXgob2JqZWN0KSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhpcy50b0J1ZmZlcihvYmplY3QpLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMudG9CeXRlQnVmZmVyKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gYi50b0hleCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J5dGVCdWZmZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9CeXRlQnVmZmVyKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgQnl0ZUJ1ZmZlcihCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFksIEJ5dGVCdWZmZXIuTElUVExFX0VORElBTik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBiLmNvcHkoMCwgYi5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0J1ZmZlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHRoaXMudG9CeXRlQnVmZmVyKG9iamVjdCkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNlcmlhbGl6ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWFsaXplcjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy9zZXJpYWxpemVyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblwidXNlIHN0cmljdFwiO1xuXG4vKiogQ29uc29sZSBwcmludCBhbnkgdHJhbnNhY3Rpb24gb2JqZWN0IHdpdGggemVybyBkZWZhdWx0IHZhbHVlcy4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGVtcGxhdGUob3ApIHtcblxuICAgIHZhciBvYmplY3QgPSBvcC50b09iamVjdCh2b2lkIDAsIHsgdXNlX2RlZmF1bHQ6IHRydWUsIGFubm90YXRlOiB0cnVlIH0pO1xuXG4gICAgLy8gdmlzdWFsICh3aXRoIGRlc2NyaXB0aW9ucylcbiAgICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KG9iamVjdCwgbnVsbCwgNCkpO1xuXG4gICAgLy8gdXNhYmxlIGluIGEgY29weS1wYXN0ZVxuXG4gICAgb2JqZWN0ID0gb3AudG9PYmplY3Qodm9pZCAwLCB7IHVzZV9kZWZhdWx0OiB0cnVlLCBhbm5vdGF0ZTogZmFsc2UgfSk7XG5cbiAgICAvLyBjb3B5LXBhc3RlIG9uZS1saW5lZXJcbiAgICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90ZW1wbGF0ZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4vLyBMb3ctbGV2ZWwgdHlwZXMgdGhhdCBtYWtlIHVwIG9wZXJhdGlvbnNcblxudmFyIHYgPSByZXF1aXJlKCcuL1NlcmlhbGl6ZXJWYWxpZGF0aW9uJyk7XG52YXIgZnAgPSByZXF1aXJlKCcuL0Zhc3RQYXJzZXInKTtcblxudmFyIENoYWluVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL0NoYWluVHlwZXNcIik7XG52YXIgT2JqZWN0SWQgPSByZXF1aXJlKFwiLi4vLi4vY2hhaW4vc3JjL09iamVjdElkXCIpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vLi4vZWNjXCIpLFxuICAgIFB1YmxpY0tleSA9IF9yZXF1aXJlLlB1YmxpY0tleSxcbiAgICBBZGRyZXNzID0gX3JlcXVpcmUuQWRkcmVzcztcblxudmFyIENoYWluQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2NoYWluL3NyYy9DaGFpbkNvbmZpZ1wiKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL251bWJlclV0aWxzXCIpLFxuICAgIGZyb21JbXBsaWVkRGVjaW1hbCA9IF9yZXF1aXJlMi5mcm9tSW1wbGllZERlY2ltYWw7XG5cbnZhciBUeXBlcyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlcztcblxudmFyIEhFWF9EVU1QID0gcHJvY2Vzcy5lbnYubnBtX2NvbmZpZ19fZ3JhcGhlbmVfc2VyaWFsaXplcl9oZXhfZHVtcDtcblxuLyoqXG4qIEFzc2V0IHN5bWJvbHMgY29udGFpbiB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uXG4qXG4qICA0IGJpdCBQUkVDSVNJT05cbiogIDQgYml0IFJFU0VSVkVEXG4qICBDSEFSWzZdIHVwIHRvIDYgdXBwZXIgY2FzZSBhbHBoYSBudW1lcmljIGFzY2lpIGNoYXJhY3RlcnMsXG4qICBjaGFyID0gXFwwICBudWxsIHRlcm1pbmF0ZWRcbipcbiogIEl0IGlzIHRyZWF0ZWQgYXMgYSB1aW50NjRfdCBmb3IgYWxsIGludGVybmFsIG9wZXJhdGlvbnMsIGJ1dFxuKiAgaXMgZWFzaWx5IGNvbnZlcnRlZCB0byBzb21ldGhpbmcgdGhhdCBjYW4gYmUgZGlzcGxheWVkLlxuKi9cblR5cGVzLmFzc2V0ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHZhciBhbW91bnQgPSBiLnJlYWRJbnQ2NCgpO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gYi5yZWFkVWludDgoKTtcbiAgICAgICAgdmFyIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyA3KTtcbiAgICAgICAgdmFyIHN5bWJvbCA9IG5ldyBCdWZmZXIoYl9jb3B5LnRvQmluYXJ5KCksIFwiYmluYXJ5XCIpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFx4MDAvZywgXCJcIik7XG4gICAgICAgIGIuc2tpcCg3KTtcbiAgICAgICAgLy8gXCIxLjAwMCBTVEVFTVwiIGFsd2F5cyB3cml0dGVuIHdpdGggZnVsbCBwcmVjaXNpb25cbiAgICAgICAgdmFyIGFtb3VudF9zdHJpbmcgPSBmcm9tSW1wbGllZERlY2ltYWwoYW1vdW50LCBwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gYW1vdW50X3N0cmluZyArIFwiIFwiICsgc3ltYm9sO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRyaW0oKTtcbiAgICAgICAgaWYgKCEvXlswLTldK1xcLj9bMC05XSogW0EtWmEtejAtOV0rJC8udGVzdChvYmplY3QpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RpbmcgYW1vdW50IGxpa2UgJzk5LjAwMCBTWU1CT0wnLCBpbnN0ZWFkIGdvdCAnXCIgKyBvYmplY3QgKyBcIidcIik7XG5cbiAgICAgICAgdmFyIF9vYmplY3Qkc3BsaXQgPSBvYmplY3Quc3BsaXQoXCIgXCIpLFxuICAgICAgICAgICAgX29iamVjdCRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfb2JqZWN0JHNwbGl0LCAyKSxcbiAgICAgICAgICAgIGFtb3VudCA9IF9vYmplY3Qkc3BsaXQyWzBdLFxuICAgICAgICAgICAgc3ltYm9sID0gX29iamVjdCRzcGxpdDJbMV07XG5cbiAgICAgICAgaWYgKHN5bWJvbC5sZW5ndGggPiA2KSB0aHJvdyBuZXcgRXJyb3IoXCJTeW1ib2xzIGFyZSBub3QgbG9uZ2VyIHRoYW4gNiBjaGFyYWN0ZXJzIFwiICsgc3ltYm9sICsgXCItXCIgKyBzeW1ib2wubGVuZ3RoKTtcblxuICAgICAgICBiLndyaXRlSW50NjQodi50b19sb25nKGFtb3VudC5yZXBsYWNlKFwiLlwiLCBcIlwiKSkpO1xuICAgICAgICB2YXIgZG90ID0gYW1vdW50LmluZGV4T2YoXCIuXCIpOyAvLyAwLjAwMFxuICAgICAgICB2YXIgcHJlY2lzaW9uID0gZG90ID09PSAtMSA/IDAgOiBhbW91bnQubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgYi53cml0ZVVpbnQ4KHByZWNpc2lvbik7XG4gICAgICAgIGIuYXBwZW5kKHN5bWJvbC50b1VwcGVyQ2FzZSgpLCAnYmluYXJ5Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNyAtIHN5bWJvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYi53cml0ZVVpbnQ4KDApO1xuICAgICAgICB9cmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjAuMDAwIFNURUVNXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG59O1xuXG5UeXBlcy51aW50OCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDgoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGLCBvYmplY3QsICd1aW50OCAnICsgb2JqZWN0KTtcbiAgICAgICAgYi53cml0ZVVpbnQ4KG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGLCBvYmplY3QsICd1aW50OCAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGLCBvYmplY3QsICd1aW50OCAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxuVHlwZXMudWludDE2ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50MTYoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkYsIG9iamVjdCwgJ3VpbnQxNiAnICsgb2JqZWN0KTtcbiAgICAgICAgYi53cml0ZVVpbnQxNihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGLCBvYmplY3QsICd1aW50MTYgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQzMiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDMyKCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICBiLndyaXRlVWludDMyKG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweEZGRkZGRkZGLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhGRkZGRkZGRiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqZWN0KTtcbiAgICB9XG59O1xuXG52YXIgTUlOX1NJR05FRF8zMiA9IC0xICogTWF0aC5wb3coMiwgMzEpO1xudmFyIE1BWF9TSUdORURfMzIgPSBNYXRoLnBvdygyLCAzMSkgLSAxO1xuXG5UeXBlcy52YXJpbnQzMiA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVmFyaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZV9yYW5nZShNSU5fU0lHTkVEXzMyLCBNQVhfU0lHTkVEXzMyLCBvYmplY3QsICd1aW50MzIgJyArIG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoTUlOX1NJR05FRF8zMiwgTUFYX1NJR05FRF8zMiwgb2JqZWN0LCAndWludDMyICcgKyBvYmplY3QpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKE1JTl9TSUdORURfMzIsIE1BWF9TSUdORURfMzIsIG9iamVjdCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iamVjdCk7XG4gICAgfVxufTtcblxuVHlwZXMuaW50MTYgPSB7XG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVhZEludDE2KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBiLndyaXRlSW50MTYob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChvYmplY3QpO1xuICAgIH1cbn07XG5cblR5cGVzLmludDY0ID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRJbnQ2NCgpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBiLndyaXRlSW50NjQodi50b19sb25nKG9iamVjdCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcob2JqZWN0KS50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnVpbnQ2NCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDY0KCk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBiLndyaXRlVWludDY0KHYudG9fbG9uZyh2LnVuc2lnbmVkKG9iamVjdCkpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHYudG9fbG9uZyh2LnVuc2lnbmVkKG9iamVjdCkpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2LnRvX2xvbmcob2JqZWN0KS50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnN0cmluZyA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiLnJlYWRWU3RyaW5nKCksICd1dGY4Jyk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGIud3JpdGVWU3RyaW5nKG9iamVjdC50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihvYmplY3QsICd1dGY4Jyk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxufTtcblxuVHlwZXMuc3RyaW5nX2JpbmFyeSA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICB2YXIgYl9jb3B5O1xuICAgICAgICB2YXIgbGVuID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgYl9jb3B5ID0gYi5jb3B5KGIub2Zmc2V0LCBiLm9mZnNldCArIGxlbiksIGIuc2tpcChsZW4pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgYi53cml0ZVZhcmludDMyKG9iamVjdC5sZW5ndGgpO1xuICAgICAgICBiLmFwcGVuZChvYmplY3QudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmluYXJ5Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9XG59O1xuXG5UeXBlcy5ieXRlcyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYl9jb3B5O1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgICAgIGJfY29weSA9IGIuY29weShiLm9mZnNldCwgYi5vZmZzZXQgKyBsZW4pLCBiLnNraXAobGVuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiX2NvcHkgPSBiLmNvcHkoYi5vZmZzZXQsIGIub2Zmc2V0ICsgc2l6ZSksIGIuc2tpcChzaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihiX2NvcHkudG9CaW5hcnkoKSwgJ2JpbmFyeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIG9iamVjdCA9IG5ldyBCdWZmZXIob2JqZWN0LCBcImhleFwiKTtcblxuICAgICAgICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIuYXBwZW5kKG9iamVjdC50b1N0cmluZygnYmluYXJ5JyksICdiaW5hcnknKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkgcmV0dXJuIG9iamVjdDtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIob2JqZWN0LCAnaGV4Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB6ZXJvcyA9IGZ1bmN0aW9uIHplcm9zKG51bSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KG51bSkuam9pbihcIjAwXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9zKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMuYm9vbCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICByZXR1cm4gYi5yZWFkVWludDgoKSA9PT0gMTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIC8vIHN1cHBvcnRzIGJvb2xlYW4gb3IgaW50ZWdlclxuICAgICAgICBiLndyaXRlVWludDgoSlNPTi5wYXJzZShvYmplY3QpID8gMSA6IDApO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShvYmplY3QpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKG9iamVjdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxufTtcblxuVHlwZXMudm9pZCA9IHtcbiAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIodm9pZCkgdW5kZWZpbmVkIHR5cGVcIik7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIih2b2lkKSB1bmRlZmluZWQgdHlwZVwiKTtcbiAgICB9XG59O1xuXG5UeXBlcy5hcnJheSA9IGZ1bmN0aW9uIChzdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gZnJvbUJ5dGVCdWZmZXIoYikge1xuICAgICAgICAgICAgdmFyIHNpemUgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ2YXJpbnQzMiBzaXplID0gXCIgKyBzaXplLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IHNpemUgPyBpIDwgc2l6ZSA6IGkgPiBzaXplOyAwIDwgc2l6ZSA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihyZXN1bHQsIHN0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBvYmplY3QgPSBzb3J0T3BlcmF0aW9uKG9iamVjdCwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGIud3JpdGVWYXJpbnQzMihvYmplY3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG8sIGRlYnVnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnRpbWVfcG9pbnRfc2VjID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlYWRVaW50MzIoKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm51bWJlclwiKSBvYmplY3QgPSBUeXBlcy50aW1lX3BvaW50X3NlYy5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgYi53cml0ZVVpbnQzMihvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwibnVtYmVyXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gTWF0aC5mbG9vcihvYmplY3QuZ2V0VGltZSgpIC8gMTAwMCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0ZSB0eXBlOiBcIiArIG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIgJiYgIS9aJC8udGVzdChvYmplY3QpKSBvYmplY3QgPSBvYmplY3QgKyBcIlpcIjtcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZShvYmplY3QpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyBEYXRlKDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIpIHJldHVybiBvYmplY3Q7XG5cbiAgICAgICAgaWYgKG9iamVjdC5nZXRUaW1lKSByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcblxuICAgICAgICB2YXIgaW50ID0gcGFyc2VJbnQob2JqZWN0KTtcbiAgICAgICAgdi5yZXF1aXJlX3JhbmdlKDAsIDB4RkZGRkZGRkYsIGludCwgJ3VpbnQzMiAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGludCAqIDEwMDApLnRvSVNPU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICB9XG59O1xuXG5UeXBlcy5zZXQgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgPSB0eXBlb2YgbyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobyksIFsnc3RyaW5nJywgJ251bWJlciddLmluZGV4T2YocmVmKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBfbWFwW29dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSAoc2V0KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkdXBfbWFwW29dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydE9wZXJhdGlvbihhcnJheSwgc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gYi5yZWFkVmFyaW50MzIoKTtcbiAgICAgICAgICAgIGlmIChIRVhfRFVNUCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyaW50MzIgc2l6ZSA9IFwiICsgc2l6ZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgMCA8IHNpemUgPyBpIDwgc2l6ZSA6IGkgPiBzaXplOyAwIDwgc2l6ZSA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kQnl0ZUJ1ZmZlcjogZnVuY3Rpb24gYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIHN0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3QobykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzdF9vcGVyYXRpb24udG9PYmplY3Qob2JqZWN0LCBkZWJ1ZyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG8sIGRlYnVnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8vIGdsb2JhbF9wYXJhbWV0ZXJzX3VwZGF0ZV9vcGVyYXRpb24gY3VycmVudF9mZWVzXG5UeXBlcy5maXhlZF9hcnJheSA9IGZ1bmN0aW9uIChjb3VudCwgc3Rfb3BlcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKHJlc3VsdHMsIHN0X29wZXJhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgaSwgaiwgcmVmO1xuICAgICAgICAgICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHNvcnRPcGVyYXRpb24ob2JqZWN0LCBzdF9vcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IGNvdW50OyBqIDwgcmVmOyBpID0gaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgc3Rfb3BlcmF0aW9uLmFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCByZWYsIHJlc3VsdHM7XG4gICAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gY291bnQ7IGogPCByZWY7IGkgPSBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob2JqZWN0W2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCwgZGVidWcpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCBrLCByZWYsIHJlZjEsIHJlc3VsdHMsIHJlc3VsdHMxO1xuICAgICAgICAgICAgaWYgKGRlYnVnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBjb3VudDsgaiA8IHJlZjsgaSA9IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHZvaWQgMCwgZGVidWcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gayA9IDAsIHJlZjEgPSBjb3VudDsgayA8IHJlZjE7IGkgPSBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzMS5wdXNoKHN0X29wZXJhdGlvbi50b09iamVjdChvYmplY3RbaV0sIGRlYnVnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czE7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyogU3VwcG9ydHMgaW5zdGFuY2UgbnVtYmVycyAoMTEpIG9yIG9iamVjdCB0eXBlcyAoMS4yLjExKS4gIE9iamVjdCB0eXBlXG52YWxpZGF0aW9uIGlzIGVuZm9yY2VkIHdoZW4gYW4gb2JqZWN0IHR5cGUgaXMgdXNlZC4gKi9cbnZhciBpZF90eXBlID0gZnVuY3Rpb24gaWRfdHlwZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlKSB7XG4gICAgdi5yZXF1aXJlZChyZXNlcnZlZF9zcGFjZXMsIFwicmVzZXJ2ZWRfc3BhY2VzXCIpO1xuICAgIHYucmVxdWlyZWQob2JqZWN0X3R5cGUsIFwib2JqZWN0X3R5cGVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnZlcnQgMS4yLm4gaW50byBqdXN0IG5cbiAgICAgICAgICAgIGlmICgvXlswLTldK1xcLlswLTldK1xcLlswLTldKyQvLnRlc3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIodi50b19udW1iZXIob2JqZWN0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnJlc29sdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHYuaXNfZGlnaXRzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi50b19udW1iZXIob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2LmdldF9pbnN0YW5jZShyZXNlcnZlZF9zcGFjZXMsIG9iamVjdF90eXBlLCBvYmplY3QpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgb2JqZWN0X3R5cGVfaWQgPSBjaGFpbl90eXBlcy5vYmplY3RfdHlwZVtvYmplY3RfdHlwZV07XG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzZXJ2ZWRfc3BhY2VzICsgJy4nICsgb2JqZWN0X3R5cGVfaWQgKyAnLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXlswLTldK1xcLlswLTldK1xcLlswLTldKyQvLnRlc3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHYuZ2V0X2luc3RhbmNlKHJlc2VydmVkX3NwYWNlcywgb2JqZWN0X3R5cGUsIG9iamVjdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXNlcnZlZF9zcGFjZXMgKyAnLicgKyBvYmplY3RfdHlwZV9pZCArICcuJyArIG9iamVjdDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5UeXBlcy5wcm90b2NvbF9pZF90eXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2LnJlcXVpcmVkKG5hbWUsIFwibmFtZVwiKTtcbiAgICByZXR1cm4gaWRfdHlwZShjaGFpbl90eXBlcy5yZXNlcnZlZF9zcGFjZXMucHJvdG9jb2xfaWRzLCBuYW1lKTtcbn07XG5cblR5cGVzLm9iamVjdF9pZF90eXBlID0ge1xuICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tQnl0ZUJ1ZmZlcihiKTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0LmFwcGVuZEJ5dGVCdWZmZXIoYik7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3RJZC5mcm9tU3RyaW5nKG9iamVjdCk7XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwLjAuMFwiO1xuICAgICAgICB9XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5yZXNvbHZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdElkLmZyb21TdHJpbmcob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH1cbn07XG5cblR5cGVzLnZvdGVfaWQgPSB7IFRZUEU6IDB4MDAwMDAwRkYsXG4gICAgSUQ6IDB4RkZGRkZGMDAsXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYi5yZWFkVWludDMyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZSAmIHRoaXMuVFlQRSxcbiAgICAgICAgICAgIGlkOiB2YWx1ZSAmIHRoaXMuSURcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gXCJzdHJpbmdcIikgb2JqZWN0ID0gVHlwZXMudm90ZV9pZC5mcm9tT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmlkIDw8IDggfCBvYmplY3QudHlwZTtcbiAgICAgICAgYi53cml0ZVVpbnQzMih2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHYucmVxdWlyZWQob2JqZWN0LCBcIih0eXBlIHZvdGVfaWQpXCIpO1xuICAgICAgICBpZiAoKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC50eXBlLCBcInR5cGVcIik7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdC5pZCwgXCJpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdi5yZXF1aXJlX3Rlc3QoL15bMC05XSs6WzAtOV0rJC8sIG9iamVjdCwgJ3ZvdGVfaWQgZm9ybWF0ICcgKyBvYmplY3QpO1xuXG4gICAgICAgIHZhciBfb2JqZWN0JHNwbGl0MyA9IG9iamVjdC5zcGxpdCgnOicpLFxuICAgICAgICAgICAgX29iamVjdCRzcGxpdDQgPSBfc2xpY2VkVG9BcnJheShfb2JqZWN0JHNwbGl0MywgMiksXG4gICAgICAgICAgICB0eXBlID0gX29iamVjdCRzcGxpdDRbMF0sXG4gICAgICAgICAgICBpZCA9IF9vYmplY3Qkc3BsaXQ0WzFdO1xuXG4gICAgICAgIHYucmVxdWlyZV9yYW5nZSgwLCAweGZmLCB0eXBlLCAndm90ZSB0eXBlICcgKyBvYmplY3QpO1xuICAgICAgICB2LnJlcXVpcmVfcmFuZ2UoMCwgMHhmZmZmZmYsIGlkLCAndm90ZSBpZCAnICsgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgaWQ6IGlkIH07XG4gICAgfSxcbiAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwOjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiKSBvYmplY3QgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICByZXR1cm4gb2JqZWN0LnR5cGUgKyBcIjpcIiArIG9iamVjdC5pZDtcbiAgICB9LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgIT09IFwib2JqZWN0XCIpIGEgPSBUeXBlcy52b3RlX2lkLmZyb21PYmplY3QoYSk7XG4gICAgICAgIGlmICgodHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpKSAhPT0gXCJvYmplY3RcIikgYiA9IFR5cGVzLnZvdGVfaWQuZnJvbU9iamVjdChiKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGEuaWQpIC0gcGFyc2VJbnQoYi5pZCk7XG4gICAgfVxufTtcblxuVHlwZXMub3B0aW9uYWwgPSBmdW5jdGlvbiAoc3Rfb3BlcmF0aW9uKSB7XG4gICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sIFwic3Rfb3BlcmF0aW9uXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICBpZiAoIShiLnJlYWRVaW50OCgpID09PSAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGIud3JpdGVVaW50OCgxKTtcbiAgICAgICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiLndyaXRlVWludDgoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWJ1ZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIHRvT2JqZWN0IGlzIG9ubHkgbnVsbCBzYXZlIGlmIHVzZV9kZWZhdWx0IGlzIHRydWVcbiAgICAgICAgICAgIHZhciByZXN1bHRfb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdCwgZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLmFubm90YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzdWx0X29iamVjdCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocmVzdWx0X29iamVjdCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdF9vYmplY3QuX19vcHRpb25hbCA9IFwicGFyZW50IGlzIG9wdGlvbmFsXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0X29iamVjdCA9IHsgX19vcHRpb25hbDogcmVzdWx0X29iamVjdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRfb2JqZWN0O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLnN0YXRpY192YXJpYW50ID0gZnVuY3Rpb24gKF9zdF9vcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9zb3J0OiB0cnVlLFxuICAgICAgICBzdF9vcGVyYXRpb25zOiBfc3Rfb3BlcmF0aW9ucyxcbiAgICAgICAgb3BUeXBlSWQ6IGZ1bmN0aW9uIG9wVHlwZUlkKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gMCxcbiAgICAgICAgICAgICAgICB0eXBlX2lkID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikgdHlwZV9pZCA9IHZhbHVlO2Vsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aGlzLnN0X29wZXJhdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLm9wZXJhdGlvbl9uYW1lID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVfaWQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVfaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlQnVmZmVyOiBmdW5jdGlvbiBmcm9tQnl0ZUJ1ZmZlcihiKSB7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IGIucmVhZFZhcmludDMyKCk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgaWYgKEhFWF9EVU1QKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignc3RhdGljX3ZhcmlhbnQgaWQgMHgnICsgdHlwZV9pZC50b1N0cmluZygxNikgKyAnICgnICsgdHlwZV9pZCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICByZXR1cm4gW3R5cGVfaWQsIHN0X29wZXJhdGlvbi5mcm9tQnl0ZUJ1ZmZlcihiKV07XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IHRoaXMub3BUeXBlSWQob2JqZWN0WzBdKTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIodHlwZV9pZCk7XG4gICAgICAgICAgICBzdF9vcGVyYXRpb24uYXBwZW5kQnl0ZUJ1ZmZlcihiLCBvYmplY3RbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHR5cGVfaWQgPSB0aGlzLm9wVHlwZUlkKG9iamVjdFswXSk7XG4gICAgICAgICAgICB2YXIgc3Rfb3BlcmF0aW9uID0gdGhpcy5zdF9vcGVyYXRpb25zW3R5cGVfaWRdO1xuICAgICAgICAgICAgdi5yZXF1aXJlZChzdF9vcGVyYXRpb24sICdvcGVyYXRpb24gJyArIHR5cGVfaWQpO1xuICAgICAgICAgICAgcmV0dXJuIFt0eXBlX2lkLCBzdF9vcGVyYXRpb24uZnJvbU9iamVjdChvYmplY3RbMV0pXTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKGRlYnVnLnVzZV9kZWZhdWx0ICYmIG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnN0X29wZXJhdGlvbnNbMF0ub3BlcmF0aW9uX25hbWUsIHRoaXMuc3Rfb3BlcmF0aW9uc1swXS50b09iamVjdCh1bmRlZmluZWQsIGRlYnVnKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgICAgICB2YXIgdHlwZV9pZCA9IHRoaXMub3BUeXBlSWQob2JqZWN0WzBdKTtcbiAgICAgICAgICAgIHZhciBzdF9vcGVyYXRpb24gPSB0aGlzLnN0X29wZXJhdGlvbnNbdHlwZV9pZF07XG4gICAgICAgICAgICB2LnJlcXVpcmVkKHN0X29wZXJhdGlvbiwgJ29wZXJhdGlvbiAnICsgdHlwZV9pZCk7XG4gICAgICAgICAgICByZXR1cm4gW3N0X29wZXJhdGlvbi5vcGVyYXRpb25fbmFtZSwgc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KG9iamVjdFsxXSwgZGVidWcpXTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyQ21wKHRoaXMub3BUeXBlSWQoYVswXSksIHRoaXMub3BUeXBlSWQoYlswXSkpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblR5cGVzLm1hcCA9IGZ1bmN0aW9uIChrZXlfc3Rfb3BlcmF0aW9uLCB2YWx1ZV9zdF9vcGVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHVwX21hcCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBhcnJheVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgIGlmICghKG8ubGVuZ3RoID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RpbmcgdHdvIGVsZW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVmID0gX3R5cGVvZihvWzBdKSwgWydudW1iZXInLCAnc3RyaW5nJ10uaW5kZXhPZihyZWYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR1cF9tYXBbb1swXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIChtYXApXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGR1cF9tYXBbb1swXV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0T3BlcmF0aW9uKGFycmF5LCBrZXlfc3Rfb3BlcmF0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBiLnJlYWRWYXJpbnQzMigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IDAgPCBlbmQgPyBpIDwgZW5kIDogaSA+IGVuZDsgMCA8IGVuZCA/IGkrKyA6IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21CeXRlQnVmZmVyKGIpLCB2YWx1ZV9zdF9vcGVyYXRpb24uZnJvbUJ5dGVCdWZmZXIoYildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKHJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGVuZEJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZEJ5dGVCdWZmZXIoYiwgb2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKG9iamVjdCk7XG4gICAgICAgICAgICBiLndyaXRlVmFyaW50MzIob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG8gPSBvYmplY3RbaV07XG4gICAgICAgICAgICAgICAga2V5X3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlX3N0X29wZXJhdGlvbi5hcHBlbmRCeXRlQnVmZmVyKGIsIG9bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXlfc3Rfb3BlcmF0aW9uLmZyb21PYmplY3Qob1swXSksIHZhbHVlX3N0X29wZXJhdGlvbi5mcm9tT2JqZWN0KG9bMV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICB0b09iamVjdDogZnVuY3Rpb24gdG9PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1trZXlfc3Rfb3BlcmF0aW9uLnRvT2JqZWN0KHVuZGVmaW5lZCwgZGVidWcpLCB2YWx1ZV9zdF9vcGVyYXRpb24udG9PYmplY3QodW5kZWZpbmVkLCBkZWJ1ZyldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucmVxdWlyZWQob2JqZWN0KTtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXMudmFsaWRhdGUob2JqZWN0KTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbyA9IG9iamVjdFtpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChba2V5X3N0X29wZXJhdGlvbi50b09iamVjdChvWzBdLCBkZWJ1ZyksIHZhbHVlX3N0X29wZXJhdGlvbi50b09iamVjdChvWzFdLCBkZWJ1ZyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuVHlwZXMucHVibGljX2tleSA9IHtcbiAgICB0b1B1YmxpYzogZnVuY3Rpb24gdG9QdWJsaWMob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QucmVzb2x2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QucmVzb2x2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3QuUSA/IG9iamVjdCA6IFB1YmxpY0tleS5mcm9tU3RyaW5nT3JUaHJvdyhvYmplY3QpO1xuICAgIH0sXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIGZwLnB1YmxpY19rZXkoYik7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIGZwLnB1YmxpY19rZXkoYiwgVHlwZXMucHVibGljX2tleS50b1B1YmxpYyhvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgZnJvbU9iamVjdDogZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LlEpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVzLnB1YmxpY19rZXkudG9QdWJsaWMob2JqZWN0KTtcbiAgICB9LFxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiB0b09iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBpZiAoZGVidWcudXNlX2RlZmF1bHQgJiYgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGFpbkNvbmZpZy5hZGRyZXNzX3ByZWZpeCArIFwiODU5Z3hmblh5VXJpTWdVZVRoaDFmV3Yzb3FjcExGeUhhM1RmRllDNFBLMkhxaFRvVk1cIjtcbiAgICAgICAgfVxuICAgICAgICB2LnJlcXVpcmVkKG9iamVjdCk7XG4gICAgICAgIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gc3RyQ21wKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbiAgICB9XG59O1xuXG5UeXBlcy5hZGRyZXNzID0ge1xuICAgIF90b19hZGRyZXNzOiBmdW5jdGlvbiBfdG9fYWRkcmVzcyhvYmplY3QpIHtcbiAgICAgICAgdi5yZXF1aXJlZChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LmFkZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFkZHJlc3MuZnJvbVN0cmluZyhvYmplY3QpO1xuICAgIH0sXG4gICAgZnJvbUJ5dGVCdWZmZXI6IGZ1bmN0aW9uIGZyb21CeXRlQnVmZmVyKGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGZwLnJpcGVtZDE2MChiKSk7XG4gICAgfSxcbiAgICBhcHBlbmRCeXRlQnVmZmVyOiBmdW5jdGlvbiBhcHBlbmRCeXRlQnVmZmVyKGIsIG9iamVjdCkge1xuICAgICAgICBmcC5yaXBlbWQxNjAoYiwgVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvQnVmZmVyKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfSxcbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpO1xuICAgIH0sXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uIHRvT2JqZWN0KG9iamVjdCkge1xuICAgICAgICB2YXIgZGVidWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIGlmIChkZWJ1Zy51c2VfZGVmYXVsdCAmJiBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIENoYWluQ29uZmlnLmFkZHJlc3NfcHJlZml4ICsgXCI2NjRLbUh4U3VReURzZndvNFdFSnZXcHpnMVFLZGc2N1NcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZXMuYWRkcmVzcy5fdG9fYWRkcmVzcyhvYmplY3QpLnRvU3RyaW5nKCk7XG4gICAgfSxcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgLy8gc29ydCBkZWNlbmRpbmdcbiAgICAgICAgcmV0dXJuIC0xICogc3RyQ21wKGEudG9TdHJpbmcoKSwgYi50b1N0cmluZygpKTtcbiAgICB9XG59O1xuXG52YXIgc3RyQ21wID0gZnVuY3Rpb24gc3RyQ21wKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59O1xudmFyIGZpcnN0RWwgPSBmdW5jdGlvbiBmaXJzdEVsKGVsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWwpID8gZWxbMF0gOiBlbDtcbn07XG52YXIgc29ydE9wZXJhdGlvbiA9IGZ1bmN0aW9uIHNvcnRPcGVyYXRpb24oYXJyYXksIHN0X29wZXJhdGlvbikge1xuICAgIHJldHVybiBzdF9vcGVyYXRpb24ubm9zb3J0ID8gYXJyYXkgOiBzdF9vcGVyYXRpb24uY29tcGFyZSA/IGFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHN0X29wZXJhdGlvbi5jb21wYXJlKGZpcnN0RWwoYSksIGZpcnN0RWwoYikpO1xuICAgIH0pIDogLy8gY3VzdG9tIGNvbXBhcmUgb3BlcmF0aW9uXG4gICAgYXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZpcnN0RWwoYSkgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGZpcnN0RWwoYikgPT09IFwibnVtYmVyXCIgPyBmaXJzdEVsKGEpIC0gZmlyc3RFbChiKSA6XG4gICAgICAgIC8vIEEgYmluYXJ5IHN0cmluZyBjb21wYXJlIGRvZXMgbm90IHdvcmsuIFBlcmZvcm1hbmFuY2UgaXMgdmVyeSBnb29kIHNvIEhFWCBpcyB1c2VkLi4gIGxvY2FsZUNvbXBhcmUgaXMgYW5vdGhlciBvcHRpb24uXG4gICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihmaXJzdEVsKGEpKSAmJiBCdWZmZXIuaXNCdWZmZXIoZmlyc3RFbChiKSkgPyBzdHJDbXAoZmlyc3RFbChhKS50b1N0cmluZyhcImhleFwiKSwgZmlyc3RFbChiKS50b1N0cmluZyhcImhleFwiKSkgOiBzdHJDbXAoZmlyc3RFbChhKS50b1N0cmluZygpLCBmaXJzdEVsKGIpLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvZGlzdC9zZXJpYWxpemVyL3NyYy90eXBlcy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL2Rpc3Qvc2VyaWFsaXplci9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzLmpzJyk7XG52YXIgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2xpYi9pc19hcmd1bWVudHMuanMnKTtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCB8fCB0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvcHRzLnN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAoeCkge1xuICBpZiAoIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHR5cGVvZiB4Lmxlbmd0aCAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB4LmNvcHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHguc2xpY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHgubGVuZ3RoID4gMCAmJiB0eXBlb2YgeFswXSAhPT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIG9wdHMpIHtcbiAgdmFyIGksIGtleTtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBvcHRzKTtcbiAgfVxuICBpZiAoaXNCdWZmZXIoYSkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYik7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgb3B0cykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWxcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZXN0ZWVtLWxpYi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9lc3RlZW0tbGliL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2VzdGVlbS1saWIvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2V2ZW50c1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2llZWU3NTRcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9pbmhlcml0c1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBsb25nLmpzIChjKSAyMDEzIERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9sb25nLmpzIGZvciBkZXRhaWxzXHJcbiAqL1xyXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XHJcblxyXG4gICAgLyogQU1EICovIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVtcImFtZFwiXSlcclxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeSgpO1xyXG4gICAgLyogR2xvYmFsICovIGVsc2VcclxuICAgICAgICAoZ2xvYmFsW1wiZGNvZGVJT1wiXSA9IGdsb2JhbFtcImRjb2RlSU9cIl0gfHwge30pW1wiTG9uZ1wiXSA9IGZhY3RvcnkoKTtcclxuXHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbiAgICAvLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4gICAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbiAgICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbiAgICAvLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4gICAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbiAgICAvL1xyXG4gICAgLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4gICAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuICAgIC8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuICAgIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuICAgIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuICAgIC8vXHJcbiAgICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuICAgIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XHJcbiAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gICAgICogQHR5cGUgeyFPYmplY3R9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gICAgICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgICAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3Igc2lnbmVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIC8qIGlzIGNvbXBhdGlibGUgKi8gaW5zdGFuY2VvZiBMb25nKVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCk7XHJcbiAgICAgICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHZhbC51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIHplcm8uXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpZ25lZCBvbmUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuT05FID0gT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVuc2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiAnMCc7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICAgICAgcmVtID0gdGhpcztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgICAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgICAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAgICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICAgICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICAgICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgICAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgICAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgICAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICAgICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICAgICAgcmVzID0gWkVSTztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAgICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgICAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgbnVtQml0cyAmPSA2MztcclxuICAgICAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24obGUpIHtcclxuICAgICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICBsbyAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgIGhpICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAyNCkgJiAweGZmXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICBoaSAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAyNCkgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gIDgpICYgMHhmZixcclxuICAgICAgICAgICAgIGxvICAgICAgICAgJiAweGZmXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gTG9uZztcclxufSk7XHJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvbG9uZy9kaXN0L2xvbmcuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvbG9uZy9kaXN0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKiBAcHJlc2VydmVcbihjKSAyMDEyIGJ5IEPDqWRyaWMgTWVzbmlsLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gY29uc3RhbnRzIHRhYmxlXG52YXIgemwgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl1cblxudmFyIHpyID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dXG5cbnZhciBzbCA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl1cblxudmFyIHNyID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXVxuXG52YXIgaGwgPSBbMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV1cbnZhciBociA9IFsweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXVxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMgKGJ5dGVzKSB7XG4gIHZhciB3b3JkcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpIHtcbiAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpXG4gIH1cbiAgcmV0dXJuIHdvcmRzXG59XG5cbmZ1bmN0aW9uIHdvcmRzVG9CeXRlcyAod29yZHMpIHtcbiAgdmFyIGJ5dGVzID0gW11cbiAgZm9yICh2YXIgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KSB7XG4gICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrIChILCBNLCBvZmZzZXQpIHtcbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaVxuICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV1cblxuICAgIC8vIFN3YXBcbiAgICBNW29mZnNldF9pXSA9IChcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgKVxuICB9XG5cbiAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbFxuICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyXG5cbiAgYXIgPSBhbCA9IEhbMF1cbiAgYnIgPSBibCA9IEhbMV1cbiAgY3IgPSBjbCA9IEhbMl1cbiAgZHIgPSBkbCA9IEhbM11cbiAgZXIgPSBlbCA9IEhbNF1cblxuICAvLyBjb21wdXRhdGlvblxuICB2YXIgdFxuICBmb3IgKGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHQgPSAoYWwgKyBNW29mZnNldCArIHpsW2ldXSkgfCAwXG4gICAgaWYgKGkgPCAxNikge1xuICAgICAgdCArPSBmMShibCwgY2wsIGRsKSArIGhsWzBdXG4gICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgIHQgKz0gZjIoYmwsIGNsLCBkbCkgKyBobFsxXVxuICAgIH0gZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICB0ICs9IGYzKGJsLCBjbCwgZGwpICsgaGxbMl1cbiAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgdCArPSBmNChibCwgY2wsIGRsKSArIGhsWzNdXG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgdCArPSBmNShibCwgY2wsIGRsKSArIGhsWzRdXG4gICAgfVxuICAgIHQgPSB0IHwgMFxuICAgIHQgPSByb3RsKHQsIHNsW2ldKVxuICAgIHQgPSAodCArIGVsKSB8IDBcbiAgICBhbCA9IGVsXG4gICAgZWwgPSBkbFxuICAgIGRsID0gcm90bChjbCwgMTApXG4gICAgY2wgPSBibFxuICAgIGJsID0gdFxuXG4gICAgdCA9IChhciArIE1bb2Zmc2V0ICsgenJbaV1dKSB8IDBcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0ICs9IGY1KGJyLCBjciwgZHIpICsgaHJbMF1cbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdCArPSBmNChiciwgY3IsIGRyKSArIGhyWzFdXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHQgKz0gZjMoYnIsIGNyLCBkcikgKyBoclsyXVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0ICs9IGYyKGJyLCBjciwgZHIpICsgaHJbM11cbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICB0ICs9IGYxKGJyLCBjciwgZHIpICsgaHJbNF1cbiAgICB9XG5cbiAgICB0ID0gdCB8IDBcbiAgICB0ID0gcm90bCh0LCBzcltpXSlcbiAgICB0ID0gKHQgKyBlcikgfCAwXG4gICAgYXIgPSBlclxuICAgIGVyID0gZHJcbiAgICBkciA9IHJvdGwoY3IsIDEwKVxuICAgIGNyID0gYnJcbiAgICBiciA9IHRcbiAgfVxuXG4gIC8vIGludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gIHQgPSAoSFsxXSArIGNsICsgZHIpIHwgMFxuICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKSB8IDBcbiAgSFsyXSA9IChIWzNdICsgZWwgKyBhcikgfCAwXG4gIEhbM10gPSAoSFs0XSArIGFsICsgYnIpIHwgMFxuICBIWzRdID0gKEhbMF0gKyBibCArIGNyKSB8IDBcbiAgSFswXSA9IHRcbn1cblxuZnVuY3Rpb24gZjEgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGYyICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh5KSkgfCAoKH54KSAmICh6KSkpXG59XG5cbmZ1bmN0aW9uIGYzICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpXG59XG5cbmZ1bmN0aW9uIGY0ICh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpICYgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gZjUgKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCkgXiAoKHkpIHwgKH4oeikpKSlcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MCAobWVzc2FnZSkge1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXVxuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAndXRmOCcpXG4gIH1cblxuICB2YXIgbSA9IGJ5dGVzVG9Xb3JkcyhtZXNzYWdlKVxuXG4gIHZhciBuQml0c0xlZnQgPSBtZXNzYWdlLmxlbmd0aCAqIDhcbiAgdmFyIG5CaXRzVG90YWwgPSBtZXNzYWdlLmxlbmd0aCAqIDhcblxuICAvLyBBZGQgcGFkZGluZ1xuICBtW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMilcbiAgbVsoKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICgoKG5CaXRzVG90YWwgPDwgOCkgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICApXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgIHByb2Nlc3NCbG9jayhILCBtLCBpKVxuICB9XG5cbiAgLy8gc3dhcCBlbmRpYW5cbiAgZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICAgIC8vIHNob3J0Y3V0XG4gICAgdmFyIEhfaSA9IEhbaV1cblxuICAgIC8vIFN3YXBcbiAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICB9XG5cbiAgdmFyIGRpZ2VzdGJ5dGVzID0gd29yZHNUb0J5dGVzKEgpXG4gIHJldHVybiBuZXcgQnVmZmVyKGRpZ2VzdGJ5dGVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJpcGVtZDE2MFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9yaXBlbWQxNjAvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuIWZ1bmN0aW9uKGdsb2JhbHMpe1xuJ3VzZSBzdHJpY3QnXG5cbi8vKioqIFVNRCBCRUdJTlxuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHsgLy9yZXF1aXJlLmpzIC8gQU1EXG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlY3VyZVJhbmRvbVxuICB9KVxufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgeyAvL0NvbW1vbkpTXG4gIG1vZHVsZS5leHBvcnRzID0gc2VjdXJlUmFuZG9tXG59IGVsc2UgeyAvL3NjcmlwdCAvIGJyb3dzZXJcbiAgZ2xvYmFscy5zZWN1cmVSYW5kb20gPSBzZWN1cmVSYW5kb21cbn1cbi8vKioqIFVNRCBFTkRcblxuLy9vcHRpb25zLnR5cGUgaXMgdGhlIG9ubHkgdmFsaWQgb3B0aW9uXG5mdW5jdGlvbiBzZWN1cmVSYW5kb20oY291bnQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge3R5cGU6ICdBcnJheSd9XG4gIC8vd2UgY2hlY2sgZm9yIHByb2Nlc3MucGlkIHRvIHByZXZlbnQgYnJvd3NlcmlmeSBmcm9tIHRyaWNraW5nIHVzXG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5waWQgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbm9kZVJhbmRvbShjb3VudCwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG9cbiAgICBpZiAoIWNyeXB0bykgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgd2luZG93LmNyeXB0by5cIilcbiAgICByZXR1cm4gYnJvd3NlclJhbmRvbShjb3VudCwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBub2RlUmFuZG9tKGNvdW50LCBvcHRpb25zKSB7XG4gIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICB2YXIgYnVmID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGNvdW50KVxuXG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYnVmKVxuICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICByZXR1cm4gYnVmXG4gICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHsgYXJyW2ldID0gYnVmLnJlYWRVSW50OChpKSB9XG4gICAgICByZXR1cm4gYXJyXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnR5cGUgKyBcIiBpcyB1bnN1cHBvcnRlZC5cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBicm93c2VyUmFuZG9tKGNvdW50LCBvcHRpb25zKSB7XG4gIHZhciBuYXRpdmVBcnIgPSBuZXcgVWludDhBcnJheShjb3VudClcbiAgdmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvXG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmF0aXZlQXJyKVxuXG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwobmF0aXZlQXJyKVxuICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICB0cnkgeyB2YXIgYiA9IG5ldyBCdWZmZXIoMSkgfSBjYXRjaChlKSB7IHRocm93IG5ldyBFcnJvcignQnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4gVXNlIE5vZGUuanMgb3IgQnJvd3NlcmlmeSBmb3IgYnJvd3NlciBzdXBwb3J0LicpfVxuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIobmF0aXZlQXJyKVxuICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgcmV0dXJuIG5hdGl2ZUFyclxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iob3B0aW9ucy50eXBlICsgXCIgaXMgdW5zdXBwb3J0ZWQuXCIpXG4gIH1cbn1cblxuc2VjdXJlUmFuZG9tLnJhbmRvbUFycmF5ID0gZnVuY3Rpb24oYnl0ZUNvdW50KSB7XG4gIHJldHVybiBzZWN1cmVSYW5kb20oYnl0ZUNvdW50LCB7dHlwZTogJ0FycmF5J30pXG59XG5cbnNlY3VyZVJhbmRvbS5yYW5kb21VaW50OEFycmF5ID0gZnVuY3Rpb24oYnl0ZUNvdW50KSB7XG4gIHJldHVybiBzZWN1cmVSYW5kb20oYnl0ZUNvdW50LCB7dHlwZTogJ1VpbnQ4QXJyYXknfSlcbn1cblxuc2VjdXJlUmFuZG9tLnJhbmRvbUJ1ZmZlciA9IGZ1bmN0aW9uKGJ5dGVDb3VudCkge1xuICByZXR1cm4gc2VjdXJlUmFuZG9tKGJ5dGVDb3VudCwge3R5cGU6ICdCdWZmZXInfSlcbn1cblxuXG59KHRoaXMpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zZWN1cmUtcmFuZG9tL2xpYi9zZWN1cmUtcmFuZG9tLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3NlY3VyZS1yYW5kb20vbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG4gIHRoaXMuX3MgPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgbCA9IHRoaXMuX2xlbiArPSBkYXRhLmxlbmd0aFxuICB2YXIgcyA9IHRoaXMuX3MgfHwgMFxuICB2YXIgZiA9IDBcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuX2Jsb2NrXG5cbiAgd2hpbGUgKHMgPCBsKSB7XG4gICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICB2YXIgY2ggPSAodCAtIGYpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgfVxuXG4gICAgcyArPSBjaFxuICAgIGYgKz0gY2hcblxuICAgIGlmICgocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgfVxuICB9XG4gIHRoaXMuX3MgPSBzXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICB2YXIgbCA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAvLyBhbmQgdGhlbiBrIHplcm8gYml0cywgd2hlcmUgayBpcyB0aGUgc21hbGxlc3Qgbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobCArIDEgKyBrKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICB9XG5cbiAgLy8gdG8gdGhpcyBhcHBlbmQgdGhlIGJsb2NrIHdoaWNoIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgbCB3cml0dGVuIGluIGJpbmFyeVxuICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIHZhciBoYXNoID0gdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKSB8fCB0aGlzLl9oYXNoKClcblxuICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxufVxuXG5IYXNoLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU0hBIChhbGdvcml0aG0pIHtcbiAgYWxnb3JpdGhtID0gYWxnb3JpdGhtLnRvTG93ZXJDYXNlKClcblxuICB2YXIgQWxnb3JpdGhtID0gZXhwb3J0c1thbGdvcml0aG1dXG4gIGlmICghQWxnb3JpdGhtKSB0aHJvdyBuZXcgRXJyb3IoYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkICh3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cyknKVxuXG4gIHJldHVybiBuZXcgQWxnb3JpdGhtKClcbn1cblxuZXhwb3J0cy5zaGEgPSByZXF1aXJlKCcuL3NoYScpXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKVxuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYTIyNCcpXG5leHBvcnRzLnNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEzODQnKVxuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYTUxMicpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0wLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBkZXJpdmVkIGZyb20gc2hhMS5qcyBvZiB0aGUgc2FtZSByZXBvc2l0b3J5LlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBTSEEtMCBhbmQgU0hBLTEgaXMganVzdCBhIGJpdHdpc2Ugcm90YXRlIGxlZnRcbiAqIG9wZXJhdGlvbiB3YXMgYWRkZWQuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYSwgSGFzaClcblxuU2hhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjIHwgMCwgMHhjYTYyYzFkNiB8IDBcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoODApXG5cbmZ1bmN0aW9uIFNoYTEgKCkge1xuICB0aGlzLmluaXQoKVxuICB0aGlzLl93ID0gV1xuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTEsIEhhc2gpXG5cblNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweDY3NDUyMzAxXG4gIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gIHRoaXMuX2QgPSAweDEwMzI1NDc2XG4gIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcm90bDEgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAxKSB8IChudW0gPj4+IDMxKVxufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA4MDsgKytpKSBXW2ldID0gcm90bDEoV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XSlcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyArK2opIHtcbiAgICB2YXIgcyA9IH5+KGogLyAyMClcbiAgICB2YXIgdCA9IChyb3RsNShhKSArIGZ0KHMsIGIsIGMsIGQpICsgZSArIFdbal0gKyBLW3NdKSB8IDBcblxuICAgIGUgPSBkXG4gICAgZCA9IGNcbiAgICBjID0gcm90bDMwKGIpXG4gICAgYiA9IGFcbiAgICBhID0gdFxuICB9XG5cbiAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gIHRoaXMuX2IgPSAoYiArIHRoaXMuX2IpIHwgMFxuICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gIHRoaXMuX2UgPSAoZSArIHRoaXMuX2UpIHwgMFxufVxuXG5TaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKipcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMjU2LCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIDE4MC0yXG4gKiBWZXJzaW9uIDIuMi1iZXRhIENvcHlyaWdodCBBbmdlbCBNYXJpbiwgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwOS5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBuZXcgQnVmZmVyKDI4KVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMjI0XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEyMjQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcigzMilcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9nLCAyNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyNTZcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTI1Ni5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gbmV3IEJ1ZmZlcig0OClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEzODRcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTM4NC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IG5ldyBCdWZmZXIoNjQpXG5cbiAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFIChoLCBsLCBvZmZzZXQpIHtcbiAgICBILndyaXRlSW50MzJCRShoLCBvZmZzZXQpXG4gICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgfVxuXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9haCwgdGhpcy5fYWwsIDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9iaCwgdGhpcy5fYmwsIDgpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9jaCwgdGhpcy5fY2wsIDE2KVxuICB3cml0ZUludDY0QkUodGhpcy5fZGgsIHRoaXMuX2RsLCAyNClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2VoLCB0aGlzLl9lbCwgMzIpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9maCwgdGhpcy5fZmwsIDQwKVxuICB3cml0ZUludDY0QkUodGhpcy5fZ2gsIHRoaXMuX2dsLCA0OClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2hoLCB0aGlzLl9obCwgNTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGE1MTJcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zaGEuanNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFdzUnBjID0gcmVxdWlyZShcIi4vV2ViU29ja2V0UnBjXCIpO1xudmFyIFN0ZWVtQXBpID0gcmVxdWlyZShcIi4vU3RlZW1BcGlcIik7XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICB1cmw6IFwid3NzOi8vbm9kZS5zdGVlbS53c1wiLFxuICAgIHVzZXI6IFwiXCIsXG4gICAgcGFzczogXCJcIixcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgYXBpczogW1wiZGF0YWJhc2VfYXBpXCIsIFwibmV0d29ya19icm9hZGNhc3RfYXBpXCIsIFwiZm9sbG93X2FwaVwiLCBcIm1hcmtldF9oaXN0b3J5X2FwaVwiLCBcImxvZ2luX2FwaVwiLCBcInByaXZhdGVfbWVzc2FnZV9hcGlcIl1cbn07XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBhcGlJbnN0YW5jZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgaWYgKGFwaUluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXBpSW5zdGFuY2UgPSBuZXcgQXBpSW5zdGFuY2Uob3B0aW9ucyk7XG4gICAgICAgIGFwaUluc3RhbmNlLmNvbm5lY3QoKTtcblxuICAgICAgICByZXR1cm4gYXBpSW5zdGFuY2U7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgY29ubmVjdCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgICBpZiAoIWFwaUluc3RhbmNlKSB7XG4gICAgICAgICAgICBhcGlJbnN0YW5jZSA9IG5ldyBBcGlJbnN0YW5jZShvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25uZWN0KSB7XG4gICAgICAgICAgICBhcGlJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgYXBpSW5zdGFuY2UuY29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFwaUluc3RhbmNlO1xuICAgIH0sXG5cblxuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgYXBpSW5zdGFuY2UuY2xvc2UoKTthcGlJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxufTtcblxudmFyIEFwaUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwaUluc3RhbmNlKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFwaUluc3RhbmNlKTtcblxuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2FsbGJhY2sgPSBvcHRpb25zLnN0YXR1c0NhbGxiYWNrO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBcGlJbnN0YW5jZSwgW3tcbiAgICAgICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb2JqZWN0QXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7Ly9PYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFwaXMuaW5kZXhPZihcImRhdGFiYXNlX2FwaVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXBpcy51bnNoaWZ0KFwiZGF0YWJhc2VfYXBpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzUnBjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMud3NScGMgPSBuZXcgV3NScGModGhpcy5vcHRpb25zLCB0aGlzLm9uUmVjb25uZWN0LmJpbmQodGhpcyksIHRoaXMub25TdGF0dXNDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9naW4oKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ3c1JwYyBvcGVuIGVycm9yOlwiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibG9naW5cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ2luKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdFByb21pc2UgPSB0aGlzLndzUnBjLmxvZ2luKHRoaXMub3B0aW9ucy51c2VyLCB0aGlzLm9wdGlvbnMucGFzcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwaVByb21pc2VzID0gW107XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLmFwaXMuZm9yRWFjaChmdW5jdGlvbiAoYXBpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzW1wiX1wiICsgYXBpXSA9IG5ldyBTdGVlbUFwaShfdGhpcy53c1JwYywgYXBpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbYXBpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW1wiX1wiICsgYXBpXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXBpUHJvbWlzZXMucHVzaChfdGhpc1tcIl9cIiArIGFwaV0uaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFwaSA9PT0gXCJkYXRhYmFzZV9hcGlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1thcGldKCkuZXhlYyhcImdldF9jb25maWdcIiwgW10pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMuU1RFRU1JVF9DSEFJTl9JRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYWluSWQgPSByZXMuU1RFRU1JVF9DSEFJTl9JRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29ubmVjdGVkIHRvIFwiICsgYXBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb25uZWN0ZWQgdG8gXCIgKyBhcGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXBpUHJvbWlzZXMpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0b1wiLCB0aGlzLm9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0byBcIiArIF90aGlzLm9wdGlvbnMudXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib25SZWNvbm5lY3RcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVjb25uZWN0KCkge1xuICAgICAgICAgICAgdGhpcy5sb2dpbigpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwib25TdGF0dXNDaGFuZ2VcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3RhdHVzQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDYWxsYmFjayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndzUnBjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53c1JwYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMud3NScGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFwaUluc3RhbmNlO1xufSgpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9BcGlJbnN0YW5jZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTdGVlbUFwaSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gU3RlZW1BcGkod3NScGMsIGFwaU5hbWUpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlZW1BcGkpO1xuXG5cdFx0dGhpcy53c1JwYyA9IHdzUnBjO1xuXHRcdHRoaXMuYXBpTmFtZSA9IGFwaU5hbWU7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU3RlZW1BcGksIFt7XG5cdFx0a2V5OiBcImluaXRcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRcdHJldHVybiB0aGlzLndzUnBjLmdldEFwaUJ5TmFtZSh0aGlzLmFwaU5hbWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0XHRcdF90aGlzLmFwaUlkID0gcmVzcG9uc2U7XG5cdFx0XHRcdHJldHVybiBfdGhpcztcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJleGVjXCIsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGV4ZWMobWV0aG9kLCBwYXJhbXMpIHtcblx0XHRcdHJldHVybiB0aGlzLndzUnBjLmNhbGwoW3RoaXMuYXBpSWQsIG1ldGhvZCwgcGFyYW1zXSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJBcGkgZXJyb3I6XCIsIG1ldGhvZCwgcGFyYW1zLCBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuXHRcdFx0XHR2YXIgbmV3RXJyID0gbmV3IEVycm9yKFwiQXBpIGVycm9yOlwiICsgbWV0aG9kICsgcGFyYW1zICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcblx0XHRcdFx0bmV3RXJyLm9yaWdpbmFsID0gZXJyb3I7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5lcnJvciA9IDE7XG5cdFx0XHRcdGxvY2FsU3RvcmFnZS5lcnJvcm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlP2Vycm9yLm1lc3NhZ2Uuc3BsaXQoXCJcXG5cIilbMV06J0Nvbm5lY3Rpb24gbG9zdCwgcmVjb25uZWN0aW5nLi4uJztcblx0XHRcdFx0dGhyb3cgbmV3RXJyO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIFN0ZWVtQXBpO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0ZWVtQXBpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9TdGVlbUFwaS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSV2ViU29ja2V0ID0gcmVxdWlyZShcIi4vcmVjb25uZWN0aW5nLXdlYnNvY2tldFwiKTtcblxudmFyIFdlYlNvY2tldFJwYyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gV2ViU29ja2V0UnBjKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dmFyIHJjQ2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzFdO1xuXHRcdHZhciBzdGF0dXNDYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMl07XG5cblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU29ja2V0UnBjKTtcblxuXHRcdHRoaXMucmNDYWxsYmFjayA9IHJjQ2FsbGJhY2s7XG5cdFx0dGhpcy5zdGF0dXNDYWxsYmFjayA9IHN0YXR1c0NhbGxiYWNrO1xuXG5cdFx0aWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG9wdGlvbnMuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuXHRcdFx0b3B0aW9ucy5pZGxlVHJlc2hvbGQgPSBcImlkbGVUcmVzaG9sZFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmlkbGVUcmVzaG9sZCA6IDYwMDAwOyAvLyBPbmx5IHVzZSBpZGxlIHRocmVzaG9sZCBpbiBicm93c2Vyc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMuV2ViU29ja2V0ID0gcmVxdWlyZShcIndzXCIpO1xuXHRcdFx0XHRvcHRpb25zLmlkbGVUcmVzaG9sZCA9IDA7IC8vIEFsd2F5cyByZWNvbm5lY3QgaW4gbm9kZS5qc1xuXHRcdFx0fVxuXHRcdG9wdGlvbnMucmVjb25uZWN0SW50ZXJ2YWwgPSAxMDAwO1xuXHRcdG9wdGlvbnMucmVjb25uZWN0RGVjYXkgPSAxLjI7XG5cblx0XHR0aGlzLndzID0gbmV3IFJXZWJTb2NrZXQob3B0aW9ucyk7XG5cdFx0dGhpcy53cy50aW1lb3V0SW50ZXJ2YWwgPSAxNTAwMDtcblxuXHRcdHZhciBpbml0aWFsQ29ubmVjdCA9IHRydWU7XG5cblx0XHR0aGlzLmNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG5cdFx0XHRfdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChfdGhpcy5zdGF0dXNDYWxsYmFjaykgX3RoaXMuc3RhdHVzQ2FsbGJhY2soXCJvcGVuXCIpO1xuXHRcdFx0XHRpZiAoaW5pdGlhbENvbm5lY3QpIHtcblx0XHRcdFx0XHRpbml0aWFsQ29ubmVjdCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoX3RoaXMucmNDYWxsYmFjaykgX3RoaXMucmNDYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRfdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRpZiAoX3RoaXMuc3RhdHVzQ2FsbGJhY2spIF90aGlzLnN0YXR1c0NhbGxiYWNrKFwiZXJyb3JcIik7XG5cdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0fTtcblxuXHRcdFx0X3RoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJVbmFibGUgdG8gcGFyc2UgQVBJIHJlc3BvbnNlOlwiLCBlKTtcblx0XHRcdFx0XHRkYXRhLmVycm9yID0gXCJVbmFibGUgdG8gcGFyc2UgcmVzcG9uc2UgXCIgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfdGhpcy5saXN0ZW5lcihkYXRhKTtcblx0XHRcdH07XG5cblx0XHRcdF90aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIHdlYiBzb2NrZXQgbWF5IHJlLWNvbm5lY3Rcblx0XHRcdFx0X3RoaXMuY2JzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFsdWUucmVqZWN0KCdjb25uZWN0aW9uIGNsb3NlZCcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRfdGhpcy5tZXRob2RDYnMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHR2YWx1ZS5yZWplY3QoJ2Nvbm5lY3Rpb24gY2xvc2VkJyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdF90aGlzLmNicy5jbGVhcigpO1xuXHRcdFx0XHRfdGhpcy5tZXRob2RDYnMuY2xlYXIoKTtcblx0XHRcdFx0X3RoaXMuY2JJZCA9IDA7XG5cblx0XHRcdFx0aWYgKF90aGlzLnN0YXR1c0NhbGxiYWNrKSBfdGhpcy5zdGF0dXNDYWxsYmFjayhcImNsb3NlZFwiKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHR0aGlzLmNiSWQgPSAwO1xuXHRcdHRoaXMuY2JzID0gbmV3IE1hcCgpO1xuXHRcdHRoaXMubWV0aG9kQ2JzID0gbmV3IE1hcCgpO1xuXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXMuY2xvc2UoKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKFdlYlNvY2tldFJwYywgW3tcblx0XHRrZXk6IFwibGlzdGVuZXJcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gbGlzdGVuZXIobWVzc2FnZSkge1xuXHRcdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5jYnMuZ2V0KG1lc3NhZ2UuaWQpO1xuXHRcdFx0dmFyIG1ldGhvZENhbGxiYWNrID0gdGhpcy5tZXRob2RDYnMuZ2V0KG1lc3NhZ2UuaWQpO1xuXG5cdFx0XHRpZiAobWV0aG9kQ2FsbGJhY2spIHtcblx0XHRcdFx0dGhpcy5tZXRob2RDYnMuZGVsZXRlKG1lc3NhZ2UuaWQpO1xuXHRcdFx0XHRpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgJiYgXCJyZWplY3RcIiBpbiBtZXRob2RDYWxsYmFjaykge1xuXHRcdFx0XHRcdG1ldGhvZENhbGxiYWNrLnJlamVjdChtZXNzYWdlLmVycm9yKTtcblx0XHRcdFx0fSBlbHNlIGlmIChcInJlc29sdmVcIiBpbiBtZXRob2RDYWxsYmFjaykge1xuXHRcdFx0XHRcdG1ldGhvZENhbGxiYWNrLnJlc29sdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0dGhpcy5jYnMuZGVsZXRlKG1lc3NhZ2UuaWQpO1xuXHRcdFx0XHRpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5yZWplY3QobWVzc2FnZS5lcnJvcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sucmVzb2x2ZShtZXNzYWdlLnJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwiY2FsbFwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYWxsKHBhcmFtcykge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdHZhciByZXF1ZXN0ID0ge1xuXHRcdFx0XHRtZXRob2Q6IFwiY2FsbFwiLFxuXHRcdFx0XHRwYXJhbXM6IHBhcmFtcyxcblx0XHRcdFx0aWQ6IHRoaXMuY2JJZCsrXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXG5cdFx0XHRcdF90aGlzMi5jYnMuc2V0KHJlcXVlc3QuaWQsIHtcblx0XHRcdFx0XHR0aW1lOiBuZXcgRGF0ZSgpLFxuXHRcdFx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHRcdFx0cmVqZWN0OiByZWplY3Rcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHJlcXVlc3QucGFyYW1zWzFdID09PSBcImJyb2FkY2FzdF90cmFuc2FjdGlvbl93aXRoX2NhbGxiYWNrXCIgJiYgcmVxdWVzdC5wYXJhbXNbMl1bMF0pIHtcblx0XHRcdFx0XHRfdGhpczIubWV0aG9kQ2JzLnNldChyZXF1ZXN0LmlkLCByZXF1ZXN0LnBhcmFtc1syXVswXSk7XG5cdFx0XHRcdFx0cmVxdWVzdC5wYXJhbXNbMl1bMF0gPSByZXF1ZXN0LnBhcmFtc1syXVswXS5yZXNvbHZlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3RoaXMyLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdF90aGlzMi53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJnZXRBcGlCeU5hbWVcIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0QXBpQnlOYW1lKGFwaSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY2FsbChbMSwgXCJnZXRfYXBpX2J5X25hbWVcIiwgW2FwaV1dKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6IFwibG9naW5cIixcblx0XHR2YWx1ZTogZnVuY3Rpb24gbG9naW4odXNlciwgcGFzc3dvcmQpIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25uZWN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMy5jYWxsKFsxLCBcImxvZ2luXCIsIFt1c2VyLCBwYXNzd29yZF1dKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogXCJjbG9zZVwiLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdjbG9zaW5nIHdzJyk7XG5cdFx0XHRpZiAodGhpcy53cykge1xuXHRcdFx0XHR0aGlzLndzLm9uY2xvc2UoKTtcblx0XHRcdFx0dGhpcy53cy5jbG9zZSgpO1xuXHRcdFx0XHR0aGlzLndzID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gV2ViU29ja2V0UnBjO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJwYztcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWIvV2ViU29ja2V0UnBjLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENsaWVudCA9IHJlcXVpcmUoXCIuL0FwaUluc3RhbmNlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Q2xpZW50OiBDbGllbnRcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdGVlbS1ycGMvbGliL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIE1JVCBMaWNlbnNlOlxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAxMC0yMDEyLCBKb2UgV2FsbmVzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBUaGlzIGJlaGF2ZXMgbGlrZSBhIFdlYlNvY2tldCBpbiBldmVyeSB3YXksIGV4Y2VwdCBpZiBpdCBmYWlscyB0byBjb25uZWN0LFxuICogb3IgaXQgZ2V0cyBkaXNjb25uZWN0ZWQsIGl0IHdpbGwgcmVwZWF0ZWRseSBwb2xsIHVudGlsIGl0IHN1Y2Nlc3NmdWxseSBjb25uZWN0c1xuICogYWdhaW4uXG4gKlxuICogSXQgaXMgQVBJIGNvbXBhdGlibGUsIHNvIHdoZW4geW91IGhhdmU6XG4gKiAgIHdzID0gbmV3IFdlYlNvY2tldCgnd3M6Ly8uLi4uJyk7XG4gKiB5b3UgY2FuIHJlcGxhY2Ugd2l0aDpcbiAqICAgd3MgPSBuZXcgUmVjb25uZWN0aW5nV2ViU29ja2V0KCd3czovLy4uLi4nKTtcbiAqXG4gKiBUaGUgZXZlbnQgc3RyZWFtIHdpbGwgdHlwaWNhbGx5IGxvb2sgbGlrZTpcbiAqICBvbmNvbm5lY3RpbmdcbiAqICBvbm9wZW5cbiAqICBvbm1lc3NhZ2VcbiAqICBvbm1lc3NhZ2VcbiAqICBvbmNsb3NlIC8vIGxvc3QgY29ubmVjdGlvblxuICogIG9uY29ubmVjdGluZ1xuICogIG9ub3BlbiAgLy8gc29tZXRpbWUgbGF0ZXIuLi5cbiAqICBvbm1lc3NhZ2VcbiAqICBvbm1lc3NhZ2VcbiAqICBldGMuLi5cbiAqXG4gKiBJdCBpcyBBUEkgY29tcGF0aWJsZSB3aXRoIHRoZSBzdGFuZGFyZCBXZWJTb2NrZXQgQVBJLCBhcGFydCBmcm9tIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqXG4gKiAtIGBidWZmZXJlZEFtb3VudGBcbiAqIC0gYGV4dGVuc2lvbnNgXG4gKiAtIGBiaW5hcnlUeXBlYFxuICpcbiAqIExhdGVzdCB2ZXJzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vam9ld2FsbmVzL3JlY29ubmVjdGluZy13ZWJzb2NrZXQvXG4gKiAtIEpvZSBXYWxuZXNcbiAqXG4gKiBTeW50YXhcbiAqID09PT09PVxuICogdmFyIHNvY2tldCA9IG5ldyBSZWNvbm5lY3RpbmdXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICpcbiAqIFBhcmFtZXRlcnNcbiAqID09PT09PT09PT1cbiAqIHVybCAtIFRoZSB1cmwgeW91IGFyZSBjb25uZWN0aW5nIHRvLlxuICogcHJvdG9jb2xzIC0gT3B0aW9uYWwgc3RyaW5nIG9yIGFycmF5IG9mIHByb3RvY29scy5cbiAqIG9wdGlvbnMgLSBTZWUgYmVsb3dcbiAqXG4gKiBPcHRpb25zXG4gKiA9PT09PT09XG4gKiBPcHRpb25zIGNhbiBlaXRoZXIgYmUgcGFzc2VkIHVwb24gaW5zdGFudGlhdGlvbiBvciBzZXQgYWZ0ZXIgaW5zdGFudGlhdGlvbjpcbiAqXG4gKiB2YXIgc29ja2V0ID0gbmV3IFJlY29ubmVjdGluZ1dlYlNvY2tldCh1cmwsIG51bGwsIHsgZGVidWc6IHRydWUsIHJlY29ubmVjdEludGVydmFsOiA0MDAwIH0pO1xuICpcbiAqIG9yXG4gKlxuICogdmFyIHNvY2tldCA9IG5ldyBSZWNvbm5lY3RpbmdXZWJTb2NrZXQodXJsKTtcbiAqIHNvY2tldC5kZWJ1ZyA9IHRydWU7XG4gKiBzb2NrZXQucmVjb25uZWN0SW50ZXJ2YWwgPSA0MDAwO1xuICpcbiAqIGRlYnVnXG4gKiAtIFdoZXRoZXIgdGhpcyBpbnN0YW5jZSBzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzLiBBY2NlcHRzIHRydWUgb3IgZmFsc2UuIERlZmF1bHQ6IGZhbHNlLlxuICpcbiAqIGF1dG9tYXRpY09wZW5cbiAqIC0gV2hldGhlciBvciBub3QgdGhlIHdlYnNvY2tldCBzaG91bGQgYXR0ZW1wdCB0byBjb25uZWN0IGltbWVkaWF0ZWx5IHVwb24gaW5zdGFudGlhdGlvbi4gVGhlIHNvY2tldCBjYW4gYmUgbWFudWFsbHkgb3BlbmVkIG9yIGNsb3NlZCBhdCBhbnkgdGltZSB1c2luZyB3cy5vcGVuKCkgYW5kIHdzLmNsb3NlKCkuXG4gKlxuICogcmVjb25uZWN0SW50ZXJ2YWxcbiAqIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDEwMDAuXG4gKlxuICogbWF4UmVjb25uZWN0SW50ZXJ2YWxcbiAqIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDMwMDAwLlxuICpcbiAqIHJlY29ubmVjdERlY2F5XG4gKiAtIFRoZSByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSByZWNvbm5lY3QgZGVsYXkuIEFsbG93cyByZWNvbm5lY3QgYXR0ZW1wdHMgdG8gYmFjayBvZmYgd2hlbiBwcm9ibGVtcyBwZXJzaXN0LiBBY2NlcHRzIGludGVnZXIgb3IgZmxvYXQuIERlZmF1bHQ6IDEuNS5cbiAqXG4gKiB0aW1lb3V0SW50ZXJ2YWxcbiAqIC0gVGhlIG1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgYSBjb25uZWN0aW9uIHRvIHN1Y2NlZWQgYmVmb3JlIGNsb3NpbmcgYW5kIHJldHJ5aW5nLiBBY2NlcHRzIGludGVnZXIuIERlZmF1bHQ6IDIwMDAuXG4gKlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5SZWNvbm5lY3RpbmdXZWJTb2NrZXQgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL2lmICghKCdXZWJTb2NrZXQnIGluIHdpbmRvdykpIHtcbiAgICAvLyAgICByZXR1cm47XG4gICAgLy99XG5cbiAgICB2YXIgV2ViU29ja2V0O1xuXG4gICAgZnVuY3Rpb24gUmVjb25uZWN0aW5nV2ViU29ja2V0KG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcblxuICAgICAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBpbnN0YW5jZSBzaG91bGQgbG9nIGRlYnVnIG1lc3NhZ2VzLiAqL1xuICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHdlYnNvY2tldCBzaG91bGQgYXR0ZW1wdCB0byBjb25uZWN0IGltbWVkaWF0ZWx5IHVwb24gaW5zdGFudGlhdGlvbi4gKi9cbiAgICAgICAgICAgIGF1dG9tYXRpY09wZW46IHRydWUsXG5cbiAgICAgICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBiZWZvcmUgYXR0ZW1wdGluZyB0byByZWNvbm5lY3QuICovXG4gICAgICAgICAgICByZWNvbm5lY3RJbnRlcnZhbDogMjAwMCxcbiAgICAgICAgICAgIC8qKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGEgcmVjb25uZWN0aW9uIGF0dGVtcHQuICovXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3RJbnRlcnZhbDogMzAwMDAwLFxuICAgICAgICAgICAgLyoqIFRoZSByYXRlIG9mIGluY3JlYXNlIG9mIHRoZSByZWNvbm5lY3QgZGVsYXkuIEFsbG93cyByZWNvbm5lY3QgYXR0ZW1wdHMgdG8gYmFjayBvZmYgd2hlbiBwcm9ibGVtcyBwZXJzaXN0LiAqL1xuICAgICAgICAgICAgcmVjb25uZWN0RGVjYXk6IDEuNSxcblxuICAgICAgICAgICAgLyoqIFRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIGEgY29ubmVjdGlvbiB0byBzdWNjZWVkIGJlZm9yZSBjbG9zaW5nIGFuZCByZXRyeWluZy4gKi9cbiAgICAgICAgICAgIHRpbWVvdXRJbnRlcnZhbDogMjAwMCxcblxuICAgICAgICAgICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gbWFrZS4gVW5saW1pdGVkIGlmIG51bGwuICovXG4gICAgICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogMTAwLFxuXG4gICAgICAgICAgICAvKiogVGhlIGJpbmFyeSB0eXBlLCBwb3NzaWJsZSB2YWx1ZXMgJ2Jsb2InIG9yICdhcnJheWJ1ZmZlcicsIGRlZmF1bHQgJ2Jsb2InLiAqL1xuICAgICAgICAgICAgYmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcblxuICAgICAgICAgICAgLyoqIERvbid0IHJlY29ubmVjdCBpZiBpZGxlIChubyB1c2VyIGFjdGl2aXR5IGFmdGVyIGlkbGVUcmVzaG9sZCksIHBhc3MgMCB0byBhbHdheXMgcmVjb25uZWN0ICoqL1xuICAgICAgICAgICAgaWRsZVRyZXNob2xkOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgV2ViU29ja2V0ID0gb3B0aW9ucy5XZWJTb2NrZXQ7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DT05ORUNUSU5HID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5PUEVOID0gV2ViU29ja2V0Lk9QRU47XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DTE9TSU5HID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5DTE9TRUQgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgICBpZiAoIWNvbnNvbGUuZGVidWcpIGNvbnNvbGUuZGVidWcgPSBjb25zb2xlLmxvZztcblxuICAgICAgICAvLyBPdmVyd3JpdGUgYW5kIGRlZmluZSBzZXR0aW5ncyB3aXRoIG9wdGlvbnMgaWYgdGhleSBleGlzdC5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHNldHRpbmdzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgdHJlYXRlZCBhcyByZWFkLW9ubHkgcHJvcGVydGllc1xuXG4gICAgICAgIC8qKiBUaGUgVVJMIGFzIHJlc29sdmVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhpcyBpcyBhbHdheXMgYW4gYWJzb2x1dGUgVVJMLiBSZWFkIG9ubHkuICovXG4gICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG5cbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgYXR0ZW1wdGVkIHJlY29ubmVjdHMgc2luY2Ugc3RhcnRpbmcsIG9yIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi4gUmVhZCBvbmx5LiAqL1xuICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAqIENhbiBiZSBvbmUgb2Y6IFdlYlNvY2tldC5DT05ORUNUSU5HLCBXZWJTb2NrZXQuT1BFTiwgV2ViU29ja2V0LkNMT1NJTkcsIFdlYlNvY2tldC5DTE9TRURcbiAgICAgICAgICogUmVhZCBvbmx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIG5hbWUgb2YgdGhlIHN1Yi1wcm90b2NvbCB0aGUgc2VydmVyIHNlbGVjdGVkOyB0aGlzIHdpbGwgYmUgb25lIG9mXG4gICAgICAgICAqIHRoZSBzdHJpbmdzIHNwZWNpZmllZCBpbiB0aGUgcHJvdG9jb2xzIHBhcmFtZXRlciB3aGVuIGNyZWF0aW5nIHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgICAgICAgKiBSZWFkIG9ubHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcblxuICAgICAgICAvLyBQcml2YXRlIHN0YXRlIHZhcmlhYmxlc1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHdzO1xuICAgICAgICB2YXIgZm9yY2VkQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IHt9O1xuICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSB7XG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudC5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikgaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07IC8vZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gV2lyZSB1cCBcIm9uKlwiIHByb3BlcnRpZXMgYXMgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9ub3BlbihldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5vbmNsb3NlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3RpbmcnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYub25jb25uZWN0aW5nKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFeHBvc2UgdGhlIEFQSSByZXF1aXJlZCBieSBFdmVudFRhcmdldFxuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZChldmVudFRhcmdldCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCA9IGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQuYmluZChldmVudFRhcmdldCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkXG4gICAgICAgICAqIGNvbXBsaWFudCBicm93c2VycyBhbmQgSUU5IC0gSUUxMVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgcHJldmVudCB0aGUgZXJyb3I6XG4gICAgICAgICAqIE9iamVjdCBkb2Vzbid0IHN1cHBvcnQgdGhpcyBhY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xOTM0NTM5Mi93aHktYXJlbnQtbXktcGFyYW1ldGVycy1nZXR0aW5nLXBhc3NlZC10aHJvdWdoLXRvLWEtZGlzcGF0Y2hlZC1ldmVudC8xOTM0NTU2MyMxOTM0NTU2M1xuICAgICAgICAgKiBAcGFyYW0gcyBTdHJpbmcgVGhlIG5hbWUgdGhhdCB0aGUgZXZlbnQgc2hvdWxkIHVzZVxuICAgICAgICAgKiBAcGFyYW0gYXJncyBPYmplY3QgYW4gb3B0aW9uYWwgb2JqZWN0IHRoYXQgdGhlIGV2ZW50IHdpbGwgdXNlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZUV2ZW50KHMsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAvL2V2dC5pbml0Q3VzdG9tRXZlbnQocywgZmFsc2UsIGZhbHNlLCBhcmdzKTtcbiAgICAgICAgICAgIC8vcmV0dXJuIGV2dDtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IHMgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLnBlbmRpbmdSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5pZGxlU2luY2UgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlkbGVUcmVzaG9sZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5vbmtleXByZXNzID0gZG9jdW1lbnQub25tb3VzZW1vdmUgPSBkb2N1bWVudC5vbmNsaWNrID0gZG9jdW1lbnQub25zY3JvbGwgPSBkb2N1bWVudC50b3VjaHN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlkbGVTaW5jZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnBlbmRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1JlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5yZWNvbm5lY3RJbnRlcnZhbCAqIE1hdGgucG93KHNlbGYucmVjb25uZWN0RGVjYXksIHNlbGYucmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgPiBzZWxmLm1heFJlY29ubmVjdEludGVydmFsID8gc2VsZi5tYXhSZWNvbm5lY3RJbnRlcnZhbCA6IHRpbWVvdXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1dlYlNvY2tldDogd2lsbCB0cnkgdG8gcmVjb25uZWN0IGluICcgKyBwYXJzZUludCh0aW1lb3V0IC8gMTAwMCkgKyAnIHNlYywgYXR0ZW1wdCAjJyArIChzZWxmLnJlY29ubmVjdEF0dGVtcHRzICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgIHNlbGYub3Blbih0cnVlKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uIChyZWNvbm5lY3RBdHRlbXB0KSB7XG4gICAgICAgICAgICBpZiAocmVjb25uZWN0QXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzICYmIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPiB0aGlzLm1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY29ubmVjdGluZycpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1cmwgPSBzZWxmLnVybDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYudXJsKSkge1xuICAgICAgICAgICAgICAgIHN1cmwgPSBzZWxmLnVybFt0aGlzLnJlY29ubmVjdEF0dGVtcHRzICUgc2VsZi51cmwubGVuZ3RoXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdjb25uZWN0aW5nIHRvJywgc3VybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cyA9IG5ldyBXZWJTb2NrZXQoc3VybCk7XG4gICAgICAgICAgICB3cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnYXR0ZW1wdC1jb25uZWN0Jywgc2VsZi51cmwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbG9jYWxXcyA9IHdzO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVjb25uZWN0aW5nV2ViU29ja2V0JywgJ2Nvbm5lY3Rpb24tdGltZW91dCcsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvY2FsV3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aW1lZE91dCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgc2VsZi50aW1lb3V0SW50ZXJ2YWwpO1xuXG4gICAgICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCoqJywgJ29ub3BlbicsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5wcm90b2NvbCA9IHdzLnByb3RvY29sO1xuICAgICAgICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnb3BlbicpO1xuICAgICAgICAgICAgICAgIGUuaXNSZWNvbm5lY3QgPSByZWNvbm5lY3RBdHRlbXB0O1xuICAgICAgICAgICAgICAgIHJlY29ubmVjdEF0dGVtcHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb2RlICE9PSAxMDAwICYmIHNlbGYuZGVidWcpIGNvbnNvbGUubG9nKCdXQVJOSU5HISB3cyBjb25uZWN0aW9uJywgc3VybCwgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB3cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlZENsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY2xvc2UnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBlLmNvZGUgPSBldmVudC5jb2RlO1xuICAgICAgICAgICAgICAgICAgICBlLnJlYXNvbiA9IGV2ZW50LnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgZS53YXNDbGVhbiA9IGV2ZW50Lndhc0NsZWFuO1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY29ubmVjdEF0dGVtcHQgJiYgIXRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZWJ1ZyB8fCBSZWNvbm5lY3RpbmdXZWJTb2NrZXQuZGVidWdBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnb25jbG9zZScsIHNlbGYudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VuZXJhdGVFdmVudCgnY2xvc2UnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuaWRsZVRyZXNob2xkIHx8IG5ldyBEYXRlKCkgLSBzZWxmLmlkbGVTaW5jZSA8IHNlbGYuaWRsZVRyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdpZGxlIC0gd2lsbCByZWNvbm5lY3QgbGF0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGVuZGluZ1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCcsICdvbm1lc3NhZ2UnLCBzZWxmLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlID0gZ2VuZXJhdGVFdmVudCgnbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGUuZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3cy5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGVidWcgfHwgUmVjb25uZWN0aW5nV2ViU29ja2V0LmRlYnVnQWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlY29ubmVjdGluZ1dlYlNvY2tldCcsICdvbmVycm9yJywgc2VsZi51cmwsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuZGlzcGF0Y2hFdmVudChnZW5lcmF0ZUV2ZW50KGV2ZW50KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIGNyZWF0ZSBhIHdlYnNvY2tldCB1cG9uIGluc3RhbnRpYXRpb25cbiAgICAgICAgaWYgKHRoaXMuYXV0b21hdGljT3BlbiA9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zbWl0cyBkYXRhIHRvIHRoZSBzZXJ2ZXIgb3ZlciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIGEgdGV4dCBzdHJpbmcsIEFycmF5QnVmZmVyIG9yIEJsb2IgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlYnVnIHx8IFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdSZWNvbm5lY3RpbmdXZWJTb2NrZXQnLCAnc2VuZCcsIHNlbGYudXJsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdzLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICdJTlZBTElEX1NUQVRFX0VSUiA6IFBhdXNpbmcgdG8gcmVjb25uZWN0IHdlYnNvY2tldCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gb3IgY29ubmVjdGlvbiBhdHRlbXB0LCBpZiBhbnkuXG4gICAgICAgICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIGFscmVhZHkgQ0xPU0VELCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBDTE9TRV9OT1JNQUwgY29kZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZWRDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAod3MpIHtcbiAgICAgICAgICAgICAgICB3cy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIHB1YmxpYyBBUEkgbWV0aG9kIHRvIHJlZnJlc2ggdGhlIGNvbm5lY3Rpb24gaWYgc3RpbGwgb3BlbiAoY2xvc2UsIHJlLW9wZW4pLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGFwcCBzdXNwZWN0cyBiYWQgZGF0YSAvIG1pc3NlZCBoZWFydCBiZWF0cywgaXQgY2FuIHRyeSB0byByZWZyZXNoLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHdzKSB7XG4gICAgICAgICAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24ncyByZWFkeVN0YXRlIGNoYW5nZXMgdG8gT1BFTjtcbiAgICAgKiB0aGlzIGluZGljYXRlcyB0aGF0IHRoZSBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgYW5kIHJlY2VpdmUgZGF0YS5cbiAgICAgKi9cbiAgICBSZWNvbm5lY3RpbmdXZWJTb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uIChldmVudCkge307XG4gICAgLyoqIEFuIGV2ZW50IGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbidzIHJlYWR5U3RhdGUgY2hhbmdlcyB0byBDTE9TRUQuICovXG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7fTtcbiAgICAvKiogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGJlZ2lucyBiZWluZyBhdHRlbXB0ZWQuICovXG4gICAgUmVjb25uZWN0aW5nV2ViU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHt9O1xuICAgIC8qKiBBbiBldmVudCBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7fTtcbiAgICAvKiogQW4gZXZlbnQgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLiAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFsbCBpbnN0YW5jZXMgb2YgUmVjb25uZWN0aW5nV2ViU29ja2V0IHNob3VsZCBsb2cgZGVidWcgbWVzc2FnZXMuXG4gICAgICogU2V0dGluZyB0aGlzIHRvIHRydWUgaXMgdGhlIGVxdWl2YWxlbnQgb2Ygc2V0dGluZyBhbGwgaW5zdGFuY2VzIG9mIFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1ZyB0byB0cnVlLlxuICAgICAqL1xuICAgIFJlY29ubmVjdGluZ1dlYlNvY2tldC5kZWJ1Z0FsbCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIFJlY29ubmVjdGluZ1dlYlNvY2tldDtcbn0pO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RlZW0tcnBjL2xpYi9yZWNvbm5lY3Rpbmctd2Vic29ja2V0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0ZWVtLXJwYy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZS5qcycpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZS5qcycpO1xuXG5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuRHVwbGV4LnByb3RvdHlwZS53cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS53cml0ZTtcbkR1cGxleC5wcm90b3R5cGUuZW5kID0gV3JpdGFibGUucHJvdG90eXBlLmVuZDtcbkR1cGxleC5wcm90b3R5cGUuX3dyaXRlID0gV3JpdGFibGUucHJvdG90eXBlLl93cml0ZTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVuZCgpO1xuICB9KTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvZHVwbGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCcuL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnlcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybS5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3Bhc3N0aHJvdWdoLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgbiA9PT0gbnVsbCkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICAhZXIpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQgYW5kIHdlIGhhdmUgc29tZSBkYXRhIGxlZnQsIHRoZW4gZW1pdFxuICAvLyAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICBlbHNlXG4gICAgZW5kUmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgICByZXR1cm47XG5cbiAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLnN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgc2V0SW1tZWRpYXRlKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGlmIChyZWFkYWJsZSAhPT0gc3JjKSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICAvLyBjaGVjayBmb3IgbGlzdGVuZXJzIGJlZm9yZSBlbWl0IHJlbW92ZXMgb25lLXRpbWUgbGlzdGVuZXJzLlxuICB2YXIgZXJyTGlzdGVuZXJzID0gRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKTtcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGlmIChlcnJMaXN0ZW5lcnMgPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgZGVzdC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICB9O1xuXG4gIC8vIG5vdyBtYWtlIGl0IHN0YXJ0LCBqdXN0IGluIGNhc2UgaXQgaGFkbid0IGFscmVhZHkuXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0LmFwcGx5KHNlbGYsIGV2LCB4KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvcmVhZGFibGUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnlcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS90cmFuc2Zvcm0uanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnlcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxudmFyIGlzVWludDhBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgVWludDhBcnJheSB9XG4gIDogZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknXG4gIH1cbjtcbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcidcbiAgfVxuO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW0uRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiBpc1VpbnQ4QXJyYXkoY2h1bmspKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuayk7XG4gIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGNodW5rKSk7XG4gIFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBzdGF0ZS5uZWVkRHJhaW4gPSAhcmV0O1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvd3JpdGFibGUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnlcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0c1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcInBCR3ZBcFwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvdXRpbFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnJlcXVpcmUoJy4vcG9zdHMnKVxuLy9yZXF1aXJlKCdzdGVlbWpzLWxpYicpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZmFrZV9jYzM4OGEzMy5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuXHRhcHAuY29uc3RhbnQoJ0FQSV9FTkRfUE9JTlQnLCdodHRwOi8vYXBpLmVzdGVlbS53czo4MDgwJyk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvcG9zdHMvY29uZmlnLmpzXCIsXCIvcG9zdHNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbi8vYW5ndWxhci5tb2R1bGUoJ3N0ZWVtLmNvbnRyb2xsZXJzJywgW10pXG5cbmFwcC5jb250cm9sbGVyKCdBcHBDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkaW9uaWNNb2RhbCwgJHRpbWVvdXQsICRyb290U2NvcGUsICRzdGF0ZSwgJGlvbmljSGlzdG9yeSwgJGNvcmRvdmFTb2NpYWxTaGFyaW5nLCBJbWFnZVVwbG9hZFNlcnZpY2UsICRjb3Jkb3ZhQ2FtZXJhLCAkaW9uaWNTaWRlTWVudURlbGVnYXRlLCAkaW9uaWNQbGF0Zm9ybSwgJGZpbHRlciwgQVBJcywgJHdpbmRvdywgJGlvbmljUG9wb3Zlcikge1xuXG4gICRzY29wZS5sb2dpbkRhdGEgPSB7fTtcblxuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9sb2dpbi5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUubG9naW5Nb2RhbCA9IG1vZGFsO1xuICB9KTtcblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3BvcG92ZXIuaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlLFxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAkc2NvcGUubWVudXBvcG92ZXIgPSBwb3BvdmVyO1xuICB9KTtcblxuICAkc2NvcGUub3Blbk1lbnVQb3BvdmVyID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLnNob3coJGV2ZW50KTtcbiAgfTtcbiAgJHNjb3BlLmNsb3NlTWVudVBvcG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubWVudXBvcG92ZXIuaGlkZSgpO1xuICB9O1xuXG4gICRyb290U2NvcGUuJG9uKCdjbG9zZTpwb3BvdmVyJywgZnVuY3Rpb24oKXtcbiAgICBjb25zb2xlLmxvZygnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzY29wZS5tZW51cG9wb3Zlci5oaWRlKCk7XG5cbiAgICAkaW9uaWNIaXN0b3J5Lm5leHRWaWV3T3B0aW9ucyh7XG4gICAgICBkaXNhYmxlQmFjazogdHJ1ZVxuICAgIH0pO1xuICAgIC8vJHNjb3BlLmNsb3NlTWVudVBvcG92ZXIoKTtcbiAgICAvLyRzY29wZS5mZXRjaFBvc3RzKCk7XG4gIH0pO1xuXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLnJlbW92ZSgpO1xuICB9KTtcblxuICAkc2NvcGUuY2hhbmdlVXNlcm5hbWUgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5sb2dpbkRhdGEudXNlcm5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSgkc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9XG4gICRzY29wZS5vcGVuID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIGl0ZW0uanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oaXRlbS5qc29uX21ldGFkYXRhKTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gaXRlbTtcbiAgICAvL2NvbnNvbGUubG9nKGl0ZW0pO1xuXG4gICAgLy8kc3RhdGUuZ28oJ2FwcC5zaW5nbGUnKTsqL1xuICAgICRzdGF0ZS5nbygnYXBwLnBvc3QnLCB7Y2F0ZWdvcnk6IGl0ZW0uY2F0ZWdvcnksIGF1dGhvcjogaXRlbS5hdXRob3IsIHBlcm1saW5rOiBpdGVtLnBlcm1saW5rfSk7XG4gIH07XG5cbiAgJHJvb3RTY29wZS4kb24oJ29wZW5Db21tZW50cycsIGZ1bmN0aW9uKGUsIGFyZ3MpIHtcbiAgICAkc2NvcGUub3BlbihhcmdzLmRhdGEpO1xuICB9KTtcblxuXG4gICRzY29wZS5hZHZhbmNlZENoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKCRzY29wZS5sb2dpbkRhdGEuYWR2YW5jZWQpKTtcbiAgICBpZiAoJHNjb3BlLmxvZ2luRGF0YS5hZHZhbmNlZCkge1xuICAgICAgJHNjb3BlLmxvZ2luRGF0YS5wYXNzd29yZCA9IG51bGw7XG4gICAgfVxuICB9XG4gICRzY29wZS5jbG9zZUxvZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLmxvZ2luTW9kYWwuaGlkZSgpO1xuICB9O1xuICBcbiAgJHNjb3BlLm9wZW5TaWduVVAgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUuY2hhaW51cmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluPT0nc3RlZW0nPydodHRwczovL3N0ZWVtaXQuY29tL2NyZWF0ZV9hY2NvdW50JzonaHR0cHM6Ly9nb2xvcy5pby9jcmVhdGVfYWNjb3VudCc7XG4gICAgd2luZG93Lm9wZW4oJHNjb3BlLmNoYWludXJsLCAnX2JsYW5rJywgJ2xvY2F0aW9uPXllcycpO1xuICAgIHJldHVybiBmYWxzZTsgIFxuICB9XG4gICRzY29wZS5vcGVuTG9naW4gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9PSAncnUtUlUnKSB7XG4gICAgICAkc2NvcGUubG9naW5EYXRhLmNoYWluID0gXCJnb2xvc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUubG9naW5EYXRhLmNoYWluID0gXCJzdGVlbVwiO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmxvZ2luTW9kYWwuc2hvdygpO1xuICAgIH0sIDEpO1xuICB9O1xuICAkc2NvcGUuZ29Qcm9maWxlID0gZnVuY3Rpb24oKSB7XG4gICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZX0pO1xuICAgIC8vJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gIH1cbiAgJHNjb3BlLnNoYXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhvc3QgPSBcIlwiO1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdzdGVlbScpIHtcbiAgICAgIGhvc3QgPSBcImh0dHBzOi8vc3RlZW1pdC5jb20vXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvc3QgPSBcImh0dHBzOi8vZ29sb3MuaW8vXCI7XG4gICAgfVxuICAgIHZhciBsaW5rID0gaG9zdCskcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmNhdGVnb3J5K1wiL0BcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvcitcIi9cIiskcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rO1xuICAgIHZhciBtZXNzYWdlID0gXCJIZXkhIENoZWNrb3V0IGJsb2cgcG9zdCBvbiBTdGVlbSBcIitsaW5rO1xuICAgIHZhciBzdWJqZWN0ID0gXCJWaWEgZVN0ZWVtIE1vYmlsZVwiO1xuICAgIHZhciBmaWxlID0gbnVsbDtcbiAgICAkY29yZG92YVNvY2lhbFNoYXJpbmcuc2hhcmUobWVzc2FnZSwgc3ViamVjdCwgZmlsZSwgbGluaykgLy8gU2hhcmUgdmlhIG5hdGl2ZSBzaGFyZSBzaGVldFxuICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgLy8gU3VjY2VzcyFcbiAgICAgICRyb290U2NvcGUubG9nKFwic2hhcmVkXCIpO1xuICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgLy8gQW4gZXJyb3Igb2NjdXJlZC4gU2hvdyBhIG1lc3NhZ2UgdG8gdGhlIHVzZXJcbiAgICAgICRyb290U2NvcGUubG9nKFwibm90IHNoYXJlZFwiKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgJHNjb3BlLmxvZ2luQ2hhaW4gPSBmdW5jdGlvbih4KXtcbiAgICBjb25zb2xlLmxvZyh4KTtcbiAgICAkc2NvcGUubG9naW5EYXRhLmNoYWluID0geDtcblxuICB9XG4gIFxuICAkc2NvcGUuZG9Mb2dpbiA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKCdEb2luZyBsb2dpbicpO1xuICAgIGlmICgkc2NvcGUubG9naW5EYXRhLnBhc3N3b3JkIHx8ICRzY29wZS5sb2dpbkRhdGEucHJpdmF0ZVBvc3RpbmdLZXkpIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAkc2NvcGUubG9naW5EYXRhLnVzZXJuYW1lID0gJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZS50cmltKCk7XG4gICAgICBjb25zb2xlLmxvZygnZG9Mb2dpbicrJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZSskc2NvcGUubG9naW5EYXRhLnBhc3N3b3JkKTtcbiAgICAgIFxuICAgICAgaWYgKCRzY29wZS5sb2dpbkRhdGEuY2hhaW4gIT09ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pIHtcbiAgICAgICAgd2luZG93LkFwaS5jbG9zZSgpO1xuICAgICAgICB3aW5kb3cuQXBpID0gbnVsbDtcbiAgICAgICAgd2luZG93LnN0ZWVtUlBDLkNsaWVudC5jbG9zZSgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNvY2tldFVybCA9ICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskc2NvcGUubG9naW5EYXRhLmNoYWluXTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzb2NrZXRVcmwpO1xuXG4gICAgICAgIHdpbmRvdy5BcGkgPSB3aW5kb3cuc3RlZW1SUEMuQ2xpZW50LmdldCh7dXJsOnNvY2tldFVybH0sIHRydWUpO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjY291bnRzXCIsIFtbJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZV1dKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgICAgIGRkID0gZGRbMF07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkZCk7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLmlkID0gZGQuaWQ7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLm93bmVyID0gZGQub3duZXI7XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLmFjdGl2ZSA9IGRkLmFjdGl2ZTtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEucmVwdXRhdGlvbiA9IGRkLnJlcHV0YXRpb247XG4gICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhLnBvc3RpbmcgPSBkZC5wb3N0aW5nO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5tZW1vX2tleSA9IGRkLm1lbW9fa2V5O1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS5wb3N0X2NvdW50ID0gZGQucG9zdF9jb3VudDtcbiAgICAgICAgICAgICRzY29wZS5sb2dpbkRhdGEudm90aW5nX3Bvd2VyID0gZGQudm90aW5nX3Bvd2VyO1xuICAgICAgICAgICAgJHNjb3BlLmxvZ2luRGF0YS53aXRuZXNzX3ZvdGVzID0gZGQud2l0bmVzc192b3RlcztcbiAgICAgICAgICAgICRzY29wZS5sb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAkc2NvcGUubG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHNjb3BlLmxvZ2luRGF0YS51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogJHNjb3BlLmxvZ2luRGF0YS5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6IGRkLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkc2NvcGUubG9naW5EYXRhLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVNTV09SRF9JTkNPUlJFQ1QnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSAkc2NvcGUubG9naW5EYXRhO1xuICAgICAgICAgICAgICAkc2NvcGUubG9naW5EYXRhID0ge307XG4gICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHYgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHYudXNlcm5hbWUgPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICYmIHYuY2hhaW4gPT0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMucHVzaCgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpOyAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gJHNjb3BlLmxvZ2luO1xuICAgICAgICAgICAgICBBUElzLnVwZGF0ZVN1YnNjcmlwdGlvbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIHtkZXZpY2U6IGlvbmljLlBsYXRmb3JtLnBsYXRmb3JtKCksIHRpbWVzdGFtcDogJGZpbHRlcignZGF0ZScpKG5ldyBEYXRlKCksICdtZWRpdW0nKSwgYXBwdmVyc2lvbjogJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9ufSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJHNjb3BlLmxvZ2luTW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluICE9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuY2hhaW47ICBcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZENoYWluJyk7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZWRDdXJyZW5jeScsIHtjdXJyZW5jeTogJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSwgZW5mb3JjZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZldGNoUG9zdHMnKTtcbiAgICAgICAgICAgICAgICB9LCAxMDAwKTtcblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qaWYoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIDUwMCk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmxvZ2luTW9kYWwuaGlkZSgpO1xuICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5zZWxlY3RBY2NvdW50ID0gZnVuY3Rpb24odXNlcikge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHVzZXI7XG4gICAgJGlvbmljSGlzdG9yeS5uZXh0Vmlld09wdGlvbnMoe1xuICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiAhPT0gdXNlci5jaGFpbikge1xuICAgICAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPSB1c2VyLmNoYWluOyAgXG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZWRDaGFpbicpO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjaGFuZ2VkQ3VycmVuY3knLCB7Y3VycmVuY3k6ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3ksIGVuZm9yY2U6IHRydWV9KTtcbiAgICBcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTsgIFxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vJHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgfSwgNTAwKTtcbiAgfVxuXG4gICRyb290U2NvcGUuJG9uKCdyZWZyZXNoTG9jYWxVc2VyRGF0YScsIGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUubG9nKCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5jaGFpbiA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKSB7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjY291bnRzXCIsIFsgWyAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgXSBdKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgICAgIGRkID0gZGRbMF07XG4gICAgICAgICAgICBpZiAoZGQgJiYgZGQuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICBkZC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihkZC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLCBkZCk7XG5cbiAgICAgICAgICAgICRzY29wZS5tY3NzID0gKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZSsnKScsICdiYWNrZ3JvdW5kLXNpemUnOiAnY292ZXInLCAnYmFja2dyb3VuZC1wb3NpdGlvbic6J2ZpeGVkJ30gOiBudWxsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSlcblxuICAkc2NvcGUub3BlblBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdvcGVuUG9zdE1vZGFsJyk7XG4gIH1cblxuICAkc2NvcGUuY2hhbmdlVmlldyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcgPSB2aWV3O1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlVmlldycpO1xuICB9XG4gICRzY29wZS5jaGFuZ2VMaWdodCA9IGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS50aGVtZSA9IGxpZ2h0O1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlTGlnaHQnKTtcbiAgfVxuXG4gICRzY29wZS4kb24oXCIkaW9uaWNWaWV3LmVudGVyXCIsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICRzY29wZS50aGVtZSA9ICRyb290U2NvcGUuJHN0b3JhZ2UudGhlbWU7XG4gIH0pO1xuXG4gIC8vIGdldCBhcHAgdmVyc2lvblxuICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpe1xuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgY29yZG92YS5nZXRBcHBWZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmFwcHZlcnNpb24gPSAnMS40LjEnO1xuICAgIH1cbiAgfSk7XG5cbiAgJHNjb3BlLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdiA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnNbaV07XG4gICAgICBpZiAodi5jaGFpbiA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuY2hhaW4gJiYgdi51c2VybmFtZSA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycy5zcGxpY2UoaSwxKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzLmxlbmd0aD4xKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXJzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSBudWxsO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gdW5kZWZpbmVkO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gbnVsbDtcbiAgICB9XG4gICAgLy9tYWtlIHN1cmUgdXNlciBjcmVkZW50aWFscyBjbGVhcmVkLlxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKSB7XG4gICAgICBBUElzLmRlbGV0ZVN1YnNjcmlwdGlvbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICAgICAgICAvLyR3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpO1xuICAgICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycse3JlbmV3OnRydWV9LHtyZWxvYWQ6IHRydWV9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW9uaWNTaWRlTWVudURlbGVnYXRlLnRvZ2dsZUxlZnQoKTtcbiAgICAgIC8vJHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycse3JlbmV3OnRydWV9LHtyZWxvYWQ6IHRydWV9KTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSB1bmRlZmluZWQ7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgPSB1bmRlZmluZWQ7XG5cbiAgICAkaW9uaWNIaXN0b3J5LmNsZWFyQ2FjaGUoKTtcbiAgICAkaW9uaWNIaXN0b3J5LmNsZWFySGlzdG9yeSgpO1xuICB9O1xuICAkc2NvcGUuZGF0YSA9IHt9O1xuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9zZWFyY2guaHRtbCcsIHtcbiAgICBzY29wZTogJHNjb3BlLFxuICAgIGFuaW1hdGlvbjogJ3NsaWRlLWluLWRvd24nXG4gIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUuc21vZGFsID0gbW9kYWw7XG4gIH0pO1xuXG4gIC8vIFRyaWdnZXJlZCBpbiB0aGUgbG9naW4gbW9kYWwgdG8gY2xvc2UgaXRcbiAgJHNjb3BlLmNsb3NlU21vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnNtb2RhbC5oaWRlKCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBPcGVuIHRoZSBsb2dpbiBtb2RhbFxuICAkc2NvcGUub3BlblNtb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vaWYoISRzY29wZS5zbW9kYWwpIHJldHVybjtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmRhdGEudHlwZT1cInRhZ1wiO1xuICAgICAgJHNjb3BlLmRhdGEuc2VhcmNoUmVzdWx0ID0gW107XG4gICAgICAkc2NvcGUuc21vZGFsLnNob3coKTtcbiAgICB9LCA1KTtcbiAgfTtcbiAgJHNjb3BlLmNsZWFyU2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudGFnKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnbGltaXRzID0gdW5kZWZpbmVkO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZldGNoUG9zdHMnKTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5zaG93TWVFeHRyYSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkc2NvcGUuc2hvd0V4dHJhKSB7XG4gICAgICAkc2NvcGUuc2hvd0V4dHJhID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5zaG93RXh0cmEgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuc2VhcmNoID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ0RvaW5nIHNlYXJjaCAnKyRzY29wZS5kYXRhLnNlYXJjaCk7XG4gICAgJHNjb3BlLmRhdGEuc2VhcmNoID0gYW5ndWxhci5sb3dlcmNhc2UoJHNjb3BlLmRhdGEuc2VhcmNoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRzY29wZS5kYXRhLnNlYXJjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICgkc2NvcGUuZGF0YS50eXBlID09IFwidGFnXCIpe1xuICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3RyZW5kaW5nX3RhZ3NcIiwgWyRzY29wZS5kYXRhLnNlYXJjaCwgMTVdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgICAgIHZhciBlZSA9IFtdO1xuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgICAgICAgIC8qaWYgKHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgdmFyIGxsID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXS5uYW1lLmluZGV4T2YoJHNjb3BlLmRhdGEuc2VhcmNoKSA+IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgZWUucHVzaChyZXN1bHRbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSBlZTtcbiAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNjb3BlLmRhdGEudHlwZSA9PSBcInVzZXJcIil7XG4gICAgICAgICAgdmFyIGVlID0gW107XG4gICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJsb29rdXBfYWNjb3VudHNcIiwgWyRzY29wZS5kYXRhLnNlYXJjaCwgMTVdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpe1xuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9LCA1KTtcblxuICB9O1xuICAkc2NvcGUudHlwZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRyb290U2NvcGUubG9nKFwiY2hhbmdpbmcgc2VhcmNoIHR5cGVcIik7XG4gIH1cbiAgJHNjb3BlLm9wZW5UYWcgPSBmdW5jdGlvbih4eCwgeXkpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhcIm9wZW5pbmcgdGFnIFwiK3h4KTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyA9IHh4O1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2NyZWF0ZWQnO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnbGltaXRzID0geXk7XG4gICAgaWYgKCRzY29wZS5zbW9kYWwuaXNTaG93bigpKXtcbiAgICAgICRzY29wZS5jbG9zZVNtb2RhbCgpO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlOnBvcG92ZXInKTtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICRzdGF0ZS5nbyhcImFwcC5wb3N0c1wiLCB7dGFnczogeHh9KTtcbiAgfTtcbiAgJHNjb3BlLm9wZW5Vc2VyID0gZnVuY3Rpb24oeHkpIHtcbiAgICAkcm9vdFNjb3BlLmxvZyhcIm9wZW5pbmcgdXNlciBcIit4eSk7XG4gICAgJHNjb3BlLmNsb3NlU21vZGFsKCk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiB4eX0pO1xuICB9O1xuICAkc2NvcGUudGVzdGZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudF9oaXN0b3J5XCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIC0xLCAyNV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufSlcblxuYXBwLmNvbnRyb2xsZXIoJ1NlbmRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY1BvcHVwLCAkaW9uaWNQb3BvdmVyLCAkaW50ZXJ2YWwsICRmaWx0ZXIsICRxLCAkdGltZW91dCwgJGNvcmRvdmFCYXJjb2RlU2Nhbm5lciwgJGlvbmljUGxhdGZvcm0sICRpb25pY01vZGFsLCBBUElzKSB7XG5cbiAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gXCJzdGVlbVwiKSB7XG4gICAgJHNjb3BlLmRhdGEgPSB7dHlwZXM6IFt7dHlwZTogXCJzdGVlbVwiLCBuYW1lOlwiU3RlZW1cIiwgaWQ6MX0se3R5cGU6IFwic2JkXCIsIG5hbWU6XCJTdGVlbSBEb2xsYXJcIiwgaWQ6Mn0sIHt0eXBlOiBcInNwXCIsIG5hbWU6XCJTdGVlbSBQb3dlclwiLCBpZDozfV0sIHR5cGU6IFwic3RlZW1cIiwgYW1vdW50OiAwLjAwMSwgZXR5cGVzOiBbe3R5cGU6IFwiYXBwcm92ZVwiLCBuYW1lOiAkZmlsdGVyKCd0cmFuc2xhdGUnKShcIkFQUFJPVkVcIiksIGlkOjF9LHt0eXBlOiBcImRpc3B1dGVcIiwgbmFtZTogJGZpbHRlcigndHJhbnNsYXRlJykoXCJESVNQVVRFXCIpLCBpZDoyfSx7dHlwZTogXCJyZWxlYXNlXCIsIG5hbWU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKFwiUkVMRUFTRVwiKSwgaWQ6M31dfTtcbiAgfSBlbHNlIHtcbiAgICAkc2NvcGUuZGF0YSA9IHt0eXBlczogW3t0eXBlOiBcImdvbG9zXCIsIG5hbWU6IFwi0JPQntCb0J7QoVwiLCBpZDoxfSx7dHlwZTogXCJnYmdcIiwgbmFtZTpcItCX0J7Qm9Ce0KLQntCZXCIsIGlkOjJ9LCB7dHlwZTogXCJnb2xvc3BcIiwgbmFtZTpcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiLCBpZDozfV0sIHR5cGU6IFwiZ29sb3NcIiwgYW1vdW50OiAwLjAwMSwgZXR5cGVzOiBbe3R5cGU6IFwiYXBwcm92ZVwiLCBuYW1lOiAkZmlsdGVyKCd0cmFuc2xhdGUnKShcIkFQUFJPVkVcIiksIGlkOjF9LHt0eXBlOiBcImRpc3B1dGVcIiwgbmFtZTogJGZpbHRlcigndHJhbnNsYXRlJykoXCJESVNQVVRFXCIpLCBpZDoyfSx7dHlwZTogXCJyZWxlYXNlXCIsIG5hbWU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKFwiUkVMRUFTRVwiKSwgaWQ6M31dfTtcbiAgfVxuICAkc2NvcGUudHR5cGUgPSAndHJhbnNmZXInO1xuICAkc2NvcGUuY2hhbmdlVHJhbnNmZXIgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAkc2NvcGUudHR5cGUgPSB0eXBlO1xuICAgICRzY29wZS5kYXRhLmFkdmFuY2VkID0gZmFsc2U7XG4gIH1cbiAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCdteS1tb2RhbC5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tdXAnXG4gIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUubW9kYWwgPSBtb2RhbDtcbiAgfSk7XG4gICRzY29wZS5vcGVuVU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFsLnNob3coKTtcbiAgfTtcbiAgJHNjb3BlLmNsb3NlVU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgfTtcbiAgLy8gQ2xlYW51cCB0aGUgbW9kYWwgd2hlbiB3ZSdyZSBkb25lIHdpdGggaXQhXG4gICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLm1vZGFsLnJlbW92ZSgpO1xuICB9KTtcbiAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gaGlkZSBtb2RhbFxuICAkc2NvcGUuJG9uKCdtb2RhbC5oaWRkZW4nLCBmdW5jdGlvbigpIHtcbiAgICAvLyBFeGVjdXRlIGFjdGlvblxuICB9KTtcbiAgJHNjb3BlLnNob3dMaXF1aWQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW4udHlwZSAhPT0gJGZpbHRlcignbG93ZXJjYXNlJykoJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXB1bml0KTtcbiAgfVxuICAkc2NvcGUuc2VhcmNoVXNlciA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImxvb2t1cF9hY2NvdW50c1wiLCBbcXVlcnksIDE1XSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICRzY29wZS5zZWxlY3RBZ2VudCA9IGZ1bmN0aW9uKGFnZW50KSB7XG4gICAgJHNjb3BlLmRhdGEuYWdlbnQgPSBhZ2VudDtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRzY29wZS5jbG9zZVVNb2RhbCgpO1xuICB9XG4gICRzY29wZS5nZXRVc2VyQWdlbnQgPSBmdW5jdGlvbihxdWVyeSl7XG4gICAgcXVlcnkgPSBhbmd1bGFyLmxvd2VyY2FzZShxdWVyeSk7XG4gICAgJHNjb3BlLnJlcyA9IFtdO1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJsb29rdXBfYWNjb3VudF9uYW1lc1wiLCBbW3F1ZXJ5XV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3BvbnNlKVxuICAgICAgICB2YXIgZGQgPSByZXNwb25zZVswXTtcbiAgICAgICAgaWYgKGRkICYmIGRkLmpzb25fbWV0YWRhdGEpIHtcbiAgICAgICAgICB2YXIgdnYgPSBhbmd1bGFyLmZyb21Kc29uKGRkLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgIGlmICh2di5lc2Nyb3cpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlc2Nyb3cnKTtcbiAgICAgICAgICAgICRzY29wZS5yZXMucHVzaCh7bmFtZTogcXVlcnksIGVzY3JvdzogdnYuZXNjcm93fSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub2VzY3JvdycpO1xuICAgICAgICAgICAgJHNjb3BlLnJlcy5wdXNoKHtuYW1lOiBxdWVyeSwgZXNjcm93OiB7dGVybXM6IFwiLVwiLCBmZWVzOiB7XCJTVEVFTVwiOiAwLjAwMSwgXCJTQkRcIjogMC4wMDEsIFwiR0JHXCI6IDAuMDAxLCBcIkdPTE9TXCI6IDAuMDAxfX0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHF1ZXJ5ICYmICRzY29wZS5yZXMpIHtcbiAgICAgICAgICAkc2NvcGUuZGF0YS5zZWFyY2hSZXN1bHQgPSAkc2NvcGUucmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5kYXRhLnNlYXJjaFJlc3VsdCA9IFtdOyAgXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwKTsgICBcbiAgICB9XG4gIH1cbiAgJHNjb3BlLmNoYW5nZVVzZXJuYW1lID0gZnVuY3Rpb24odHlwZWQpIHtcbiAgICAkcm9vdFNjb3BlLmxvZygnc2VhcmNoaW5nJyk7XG4gICAgJHNjb3BlLmRhdGEudXNlcm5hbWUgPSBhbmd1bGFyLmxvd2VyY2FzZSgkc2NvcGUuZGF0YS51c2VybmFtZSk7XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJsb29rdXBfYWNjb3VudF9uYW1lc1wiLCBbWyRzY29wZS5kYXRhLnVzZXJuYW1lXV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAkc2NvcGUudXNlcnMgPSByZXNwb25zZVswXTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLnFyU2NhbiA9IGZ1bmN0aW9uKCkge1xuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgJGNvcmRvdmFCYXJjb2RlU2Nhbm5lci5zY2FuKHtcbiAgICAgICAgICBcInByZWZlckZyb250Q2FtZXJhXCIgOiBmYWxzZSwgLy8gaU9TIGFuZCBBbmRyb2lkXG4gICAgICAgICAgXCJzaG93RmxpcENhbWVyYUJ1dHRvblwiIDogZmFsc2UsIC8vIGlPUyBhbmQgQW5kcm9pZFxuICAgICAgICAgIFwicHJvbXB0XCIgOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUVJfVEVYVCcpLCAvLyBzdXBwb3J0ZWQgb24gQW5kcm9pZCBvbmx5XG4gICAgICAgICAgXCJmb3JtYXRzXCIgOiBcIlFSX0NPREVcIiAvLyBkZWZhdWx0OiBhbGwgYnV0IFBERl80MTcgYW5kIFJTU19FWFBBTkRFRFxuICAgICAgICAgIC8vXCJvcmllbnRhdGlvblwiIDogXCJsYW5kc2NhcGVcIiAvLyBBbmRyb2lkIG9ubHkgKHBvcnRyYWl0fGxhbmRzY2FwZSksIGRlZmF1bHQgdW5zZXQgc28gaXQgcm90YXRlcyB3aXRoIHRoZSBkZXZpY2VcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihiYXJjb2RlRGF0YSkge1xuICAgICAgICAvL2FsZXJ0KGJhcmNvZGVEYXRhKTtcbiAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuaW5kZXhPZignP2Ftb3VudCcpPi0xKSB7XG4gICAgICAgICAgLy9zdGVlbSBkb2xsYXI6YmxvY2t0cmFkZXM/YW1vdW50PTEyLjA4MFxuXG4gICAgICAgICAgJHNjb3BlLmRhdGEudXNlcm5hbWUgPSBiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMV0uc3BsaXQoJz8nKVswXS50cmltKCk7XG4gICAgICAgICAgJHNjb3BlLmRhdGEuYW1vdW50ID0gTnVtYmVyKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJzonKVswXT09PSdzdGVlbSBkb2xsYXInKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlID0gJ3NiZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXJjb2RlRGF0YS50ZXh0LnNwbGl0KCc6JylbMF09PT0nc3RlZW0nKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlID0gJ3N0ZWVtJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhcmNvZGVEYXRhLnRleHQuc3BsaXQoJzonKVswXT09PSdzdGVlbSBwb3dlcicpIHtcbiAgICAgICAgICAgICRzY29wZS5kYXRhLnR5cGUgPSAnc3AnO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5kYXRhLnVzZXJuYW1lID0gYmFyY29kZURhdGEudGV4dDtcbiAgICAgICAgfVxuICAgICAgICAkc2NvcGUuY2hhbmdlVXNlcm5hbWUoKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJ0Vycm9yJyxhbmd1bGFyLnRvSnNvbihlcnJvcikpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gICRzY29wZS5hZHZhbmNlZEVDaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIGNvbnNvbGUubG9nKCdhZHZhbmNlZEVDaGFuZ2UnLCAkc2NvcGUuZGF0YS5hZHZhbmNlZCk7XG4gICAgJHNjb3BlLmRhdGEuZXR5cGUgPSBcIlwiO1xuICAgICRzY29wZS5lc2Nyb3cgPSB7fTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH1cbiAgJHNjb3BlLmFjdGlvbkVDaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgIGNvbnNvbGUubG9nKCdhY3Rpb25FQ2hhbmdlJywgJHNjb3BlLmRhdGEuZXR5cGUpO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfVxuXG4gICRzY29wZS5lc2Nyb3dBY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIGNvbnNvbGUubG9nKCRzY29wZS5kYXRhLmV0eXBlKTtcbiAgICBpZiAoJHNjb3BlLmRhdGEuZXR5cGUgJiYgJHNjb3BlLmVzY3Jvdy5lc2Nyb3dfaWQpIHtcbiAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT05GSVJNQVRJT04nKSxcbiAgICAgICAgdGVtcGxhdGU6IFwiXCJcbiAgICAgIH0pO1xuICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuXG4gICAgICAgICAgdmFyIG15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgIG15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzcyA9IG15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCxcbiAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3NzKSB7XG4gICAgICAgICAgICB2YXIgdHJlID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuZXR5cGUgPT0gXCJhcHByb3ZlXCIpIHtcbiAgICAgICAgICAgICAgdHJlLmFkZF90eXBlX29wZXJhdGlvbihcImVzY3Jvd19hcHByb3ZlXCIsIHsgXG4gICAgICAgICAgICAgICAgZnJvbTogJHNjb3BlLmVzY3Jvdy5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiAkc2NvcGUuZXNjcm93LnRvLFxuICAgICAgICAgICAgICAgIGFnZW50OiAkc2NvcGUuZXNjcm93LmFnZW50LFxuICAgICAgICAgICAgICAgIHdobzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGVzY3Jvd19pZDogJHNjb3BlLmVzY3Jvdy5lc2Nyb3dfaWQsXG4gICAgICAgICAgICAgICAgYXBwcm92ZTogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNjb3BlLmRhdGEuZXR5cGUgPT0gXCJkaXNwdXRlXCIpIHtcbiAgICAgICAgICAgICAgdHJlLmFkZF90eXBlX29wZXJhdGlvbihcImVzY3Jvd19kaXNwdXRlXCIsIHsgXG4gICAgICAgICAgICAgICAgZnJvbTogJHNjb3BlLmVzY3Jvdy5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiAkc2NvcGUuZXNjcm93LnRvLFxuICAgICAgICAgICAgICAgIGFnZW50OiAkc2NvcGUuZXNjcm93LmFnZW50LFxuICAgICAgICAgICAgICAgIHdobzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGVzY3Jvd19pZDogJHNjb3BlLmVzY3Jvdy5lc2Nyb3dfaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRzY29wZS5kYXRhLmV0eXBlID09IFwicmVsZWFzZVwiKSB7XG4gICAgICAgICAgICAgIHRyZS5hZGRfdHlwZV9vcGVyYXRpb24oXCJlc2Nyb3dfcmVsZWFzZVwiLCB7XG4gICAgICAgICAgICAgICAgZnJvbTogJHNjb3BlLmVzY3Jvdy5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiAkc2NvcGUuZXNjcm93LnRvLFxuICAgICAgICAgICAgICAgIGFnZW50OiAkc2NvcGUuZXNjcm93LmFnZW50LFxuICAgICAgICAgICAgICAgIHdobzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGVzY3Jvd19pZDogJHNjb3BlLmVzY3Jvdy5lc2Nyb3dfaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXI6ICRzY29wZS5lc2Nyb3cucmVjZWl2ZXIsXG4gICAgICAgICAgICAgICAgc2JkX2Ftb3VudDogJHNjb3BlLmVzY3Jvdy5zYmRfYW1vdW50K1wiIFwiK2FuZ3VsYXIudXBwZXJjYXNlKCRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCksXG4gICAgICAgICAgICAgICAgc3RlZW1fYW1vdW50OiAkc2NvcGUuZXNjcm93LnN0ZWVtX2Ftb3VudCtcIiBcIithbmd1bGFyLnVwcGVyY2FzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQpIFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgIHRyZS5wcm9jZXNzX3RyYW5zYWN0aW9uKG15bG9naW4sIG51bGwsIHRydWUpOyAgXG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0lORk8nKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1RYX0JST0FEQ0FTVEVEJykpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnR5cGU9JHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbjtcbiAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmFtb3VudD0gMC4wMDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBcbiAgfVxuICAkc2NvcGUuZXNjcm93ID0ge307XG4gICRzY29wZS5zZWFyY2hFc2Nyb3dJRCA9IGZ1bmN0aW9uKGlkKXtcbiAgICBpZiAoaWQubGVuZ3RoPjMpe1xuICAgICAgQVBJcy5zZWFyY2hFc2Nyb3coaWQpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMuZGF0YSk7XG4gICAgICAgICRzY29wZS5lc2Nyb3cgPSByZXMuZGF0YVswXTtcbiAgICAgICAgJHNjb3BlLmVzY3Jvdy5qc29uX21ldGEgPSBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5lc2Nyb3cuanNvbl9tZXRhKTtcbiAgICAgIH0pOyAgXG4gICAgfVxuICB9XG4gICRzY29wZS50cmFuc2ZlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJHNjb3BlLmRhdGEudHlwZSA9PT0gJ3NiZCcgfHwgJHNjb3BlLmRhdGEudHlwZSA9PT0gJ2diZycpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuYW1vdW50ID4gTnVtYmVyKCRzY29wZS5iYWxhbmNlLnNiZF9iYWxhbmNlLnNwbGl0KFwiIFwiKVswXSkpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCQUxBTkNFX1RFWFQnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5va2JhbGFuY2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNjb3BlLmRhdGEudHlwZSA9PT0gJ3NwJyB8fCAkc2NvcGUuZGF0YS50eXBlID09PSAnc3RlZW0nIHx8ICRzY29wZS5kYXRhLnR5cGUgPT09ICdnb2xvcycgfHwgJHNjb3BlLmRhdGEudHlwZSA9PT0gJ2dvbG9zcCcpIHtcbiAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEuYW1vdW50ID4gTnVtYmVyKCRzY29wZS5iYWxhbmNlLmJhbGFuY2Uuc3BsaXQoXCIgXCIpWzBdKSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0JBTEFOQ0VfVEVYVCcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLm9rYmFsYW5jZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghJHNjb3BlLnVzZXJzIHx8ICRzY29wZS51c2Vycy5uYW1lICE9PSAkc2NvcGUuZGF0YS51c2VybmFtZSkge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT05FWElTVF9VU0VSJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5va3VzZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkc2NvcGUub2tiYWxhbmNlICYmICRzY29wZS5va3VzZXIpIHtcbiAgICAgICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTkZJUk1BVElPTicpLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdUUkFOU0ZFUl9URVhUJylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICh0eXBlID09ICd0cmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAvL3RyYW5zZmVyXG4gICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEudHlwZSAhPT0gJ3NwJyAmJiAkc2NvcGUuZGF0YS50eXBlICE9PSAnZ29sb3NwJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHQgPSAkZmlsdGVyKCdudW1iZXInKSgkc2NvcGUuZGF0YS5hbW91bnQsIDMpICtcIiBcIithbmd1bGFyLnVwcGVyY2FzZSgkc2NvcGUuZGF0YS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwidHJhbnNmZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGZyb206ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICB0bzogJHNjb3BlLmRhdGEudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiB0dCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW1vOiAkc2NvcGUuZGF0YS5tZW1vIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5GTycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFhfQlJPQURDQVNURUQnKSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlPSRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmFtb3VudD0gMC4wMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gJGZpbHRlcignbnVtYmVyJykoJHNjb3BlLmRhdGEuYW1vdW50LCAzKSArIFwiIFwiKyRmaWx0ZXIoJ3VwcGVyY2FzZScpKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pO1xuICAgICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJ0cmFuc2Zlcl90b192ZXN0aW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgdG86ICRzY29wZS5kYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGFtb3VudDogdHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5GTycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFhfQlJPQURDQVNURUQnKSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlPSRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmFtb3VudD0gMC4wMDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0eXBlID09ICdlc2Nyb3cnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHMsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgIG15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzcyA9IG15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3NzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJlID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgZXNjcm93X2lkID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKT4+PjA7XG4gICAgICAgICAgICAgICAgICB2YXIgdHQgPSAkZmlsdGVyKCdudW1iZXInKSgkc2NvcGUuZGF0YS5hbW91bnQsIDMpICtcIiBcIithbmd1bGFyLnVwcGVyY2FzZSgkc2NvcGUuZGF0YS50eXBlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzYmQgPSAoJHNjb3BlLmRhdGEudHlwZT09J3NiZCd8fCRzY29wZS5kYXRhLnR5cGU9PSdnYmcnKT90dDooXCIwLjAwMCBcIithbmd1bGFyLnVwcGVyY2FzZSgkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQpKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdGVtID0gKCRzY29wZS5kYXRhLnR5cGU9PSdzdGVlbSd8fCRzY29wZS5kYXRhLnR5cGU9PSdnb2xvcycpP3R0OihcIjAuMDAwIFwiK2FuZ3VsYXIudXBwZXJjYXNlKCRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGZlID0gJHNjb3BlLmRhdGEuYWdlbnQuZXNjcm93LmZlZXNbYW5ndWxhci51cHBlcmNhc2UoJHNjb3BlLmRhdGEudHlwZSldK1wiIFwiK2FuZ3VsYXIudXBwZXJjYXNlKCRzY29wZS5kYXRhLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHJ0ID0gbmV3IERhdGUoJHNjb3BlLmRhdGEucmF0aWZpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHZhciBldCA9IG5ldyBEYXRlKCRzY29wZS5kYXRhLmV4cGlyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgdmFyIGpuID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXJtczogJHNjb3BlLmRhdGEuYWdlbnQuZXNjcm93LnRlcm1zLCBcbiAgICAgICAgICAgICAgICAgICAgbWVtbzogKCRzY29wZS5kYXRhLm1lbW98fFwiXCIpK1wiIFwiK2VzY3Jvd19pZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdHJlLmFkZF90eXBlX29wZXJhdGlvbihcImVzY3Jvd190cmFuc2ZlclwiLCB7IFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIFxuICAgICAgICAgICAgICAgICAgICB0bzogJHNjb3BlLmRhdGEudXNlcm5hbWUsIFxuICAgICAgICAgICAgICAgICAgICBhZ2VudDogJHNjb3BlLmRhdGEuYWdlbnQubmFtZSwgXG4gICAgICAgICAgICAgICAgICAgIGVzY3Jvd19pZDogZXNjcm93X2lkLCBcbiAgICAgICAgICAgICAgICAgICAgc2JkX2Ftb3VudDogc2JkLCBcbiAgICAgICAgICAgICAgICAgICAgc3RlZW1fYW1vdW50OiBzdGVtLCBcbiAgICAgICAgICAgICAgICAgICAgZmVlOiBmZSwgXG4gICAgICAgICAgICAgICAgICAgIHJhdGlmaWNhdGlvbl9kZWFkbGluZTogcnQsIFxuICAgICAgICAgICAgICAgICAgICBlc2Nyb3dfZXhwaXJhdGlvbjogZXQsIFxuICAgICAgICAgICAgICAgICAgICBqc29uX21ldGE6IGFuZ3VsYXIudG9Kc29uKGpuKSBcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAvL3RyZS5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIC8vbXlsb2dpbi5zaWduVHJhbnNhY3Rpb24odHJlKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgdHJlLnByb2Nlc3NfdHJhbnNhY3Rpb24obXlsb2dpbiwgbnVsbCwgdHJ1ZSk7ICBcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvKnRyZS5maW5hbGl6ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJlLnNpZ24oKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2lnbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJlLmJyb2FkY2FzdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYnJvYWRjYXN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgIH0pOyovXG5cblxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU5GTycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFhfQlJPQURDQVNURUQnKSArIFwiIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFU0NST1cnKStcIiBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnSUQnKStcIjogXCIrZXNjcm93X2lkKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS50eXBlPSRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5hbW91bnQ9IDAuMDAxO1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgIH1cbiAgfTtcblxuXG4gICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbIFsgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lIF0gXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICRzY29wZS5iYWxhbmNlID0gZGRbMF07XG4gICAgICAgIGNvbnNvbGUubG9nKCRzY29wZS5iYWxhbmNlKTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICB9XG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjY291bnRzXCIsIFsgWyAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgXSBdKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgJHNjb3BlLmJhbGFuY2UgPSBkZFswXTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbn0pO1xuYXBwLmNvbnRyb2xsZXIoJ1Bvc3RzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHJvb3RTY29wZSwgJHN0YXRlLCAkaW9uaWNQb3B1cCwgJGlvbmljUG9wb3ZlciwgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGlvbmljTW9kYWwsICRmaWx0ZXIsICRzdGF0ZVBhcmFtcywgJGlvbmljU2xpZGVCb3hEZWxlZ2F0ZSwgJGlvbmljQWN0aW9uU2hlZXQsICRpb25pY1BsYXRmb3JtLCAkY29yZG92YUNhbWVyYSwgSW1hZ2VVcGxvYWRTZXJ2aWNlLCAkZmlsdGVyLCAkaW9uaWNIaXN0b3J5LCAkdGltZW91dCwgQVBJcywgJHRyYW5zbGF0ZSkge1xuXG4gIHZhciBmb3JtYXRUb1BlcmNlbnRhZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAnJSc7XG4gIH07XG5cbiAgJHNjb3BlLnBzbGlkZXIgPSB7XG4gICAgdmFsdWU6ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDAsXG4gICAgb3B0aW9uczoge1xuICAgICAgZmxvb3I6IDEsXG4gICAgICBjZWlsOiAxMDAsXG4gICAgICBoaWRlTGltaXRMYWJlbHM6IHRydWVcbiAgICAgIC8vdHJhbnNsYXRlOiBmb3JtYXRUb1BlcmNlbnRhZ2UsXG4gICAgICAvL3Nob3dTZWxlY3Rpb25CYXI6IHRydWUsXG4gICAgfVxuICB9O1xuXG4gICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyU2xpZGVyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIgPSBwb3BvdmVyO1xuICB9KTtcbiAgXG4gICRzY29wZS5vcGVuU2xpZGVyID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgJHNjb3BlLnZvdGluZ1Bvc3QgPSBkO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJHNjb3BlLnJhbmdlVmFsdWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwO1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyLnNob3coJGV2ZW50KTtcbiAgfTtcbiAgJHNjb3BlLmRyYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgLy9jb25zb2xlLmxvZyh2KTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSB2KjEwMDtcbiAgfVxuICAkc2NvcGUudm90ZVBvc3RTID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuaGlkZSgpO1xuICAgICRzY29wZS52b3RlUG9zdCgkc2NvcGUudm90aW5nUG9zdCk7XG4gIH1cbiAgJHNjb3BlLmNsb3NlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuaGlkZSgpO1xuICB9O1xuXG4gICRzY29wZS5vcHRpb25zID0ge1xuICAgIGxvb3A6IGZhbHNlLFxuICAgIHNwZWVkOiA1MDAsXG4gICAgLypwYWdpbmF0aW9uOiBmYWxzZSwqL1xuICAgIHNob3dQYWdlcjogZmFsc2UsXG4gICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICBzcGFjZUJldHdlZW46IDIwLFxuICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAxMDI0OiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogNSxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDE1XG4gICAgICB9LFxuICAgICAgNzY4OiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogNCxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDEwXG4gICAgICB9LFxuICAgICAgNjQwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDVcbiAgICAgIH0sXG4gICAgICAzMjA6IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAzLFxuICAgICAgICAgIHNwYWNlQmV0d2VlbjogM1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgJHJvb3RTY29wZS4kb24oJ2ZpbHRlcjpjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgJHJvb3RTY29wZS5sb2coJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpO1xuICAgIHZhciB0eXBlID0gJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgfHwgXCJ0cmVuZGluZ1wiO1xuICAgIHZhciB0YWcgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyB8fCBcIlwiO1xuICAgIGNvbnNvbGUubG9nKHR5cGUsICRzY29wZS5saW1pdCwgdGFnKTtcbiAgICAkc2NvcGUuZmV0Y2hQb3N0cyh0eXBlLCAkc2NvcGUubGltaXQsIHRhZyk7XG4gIH0pO1xuXG4gICRzY29wZS5maWx0ZXJDaGFuZ2VkID0gZnVuY3Rpb24odCkge1xuICAgIHZhciBmaWwgPSAkc2NvcGUubXltZW51W3RdLmN1c3RvbTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IGZpbDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHNjb3BlLm15bWVudS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHYgPSAkc2NvcGUubXltZW51W2ldO1xuICAgICAgaWYgKHYuY3VzdG9tID09IGZpbCkge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlck5hbWUgPSB2LnRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgICRzY29wZS5kYXRhID0gW107XG4gICAgJHNjb3BlLmVycm9yID0gZmFsc2U7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gIH1cbiAgJHNjb3BlLnNob3dGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmlsdGVyU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgYnV0dG9uczogJHNjb3BlLm15bWVudSxcbiAgICAgdGl0bGVUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU09SVF9QT1NUX0JZJyksXG4gICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgIH0sXG4gICAgIGJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICRzY29wZS5maWx0ZXJDaGFuZ2VkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyVC5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAkc2NvcGUudG9vbHRpcCA9IHBvcG92ZXI7XG4gIH0pO1xuXG4gICRzY29wZS5vcGVuVG9vbHRpcCA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgIHZhciB0cHB2ID0gTnVtYmVyKGQucGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHAgPSBOdW1iZXIoZC5wcm9tb3RlZC5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdHB2ID0gTnVtYmVyKGQudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBhciA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdLWQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIGNycCA9IE51bWJlcihkLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciB0ZXh0aCA9IFwiPGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1RFTlRJQUxfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwcHYsIDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQUk9NT1RFRCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVNUX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHYsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0FVVEhPUl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoYXIsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0NVUkFUSU9OX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShjcnAsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcigndGltZWFnbycpKGQuY2FzaG91dF90aW1lLCB0cnVlKStcIjwvZGl2PjwvZGl2PlwiO1xuICAgICRzY29wZS50b29sdGlwVGV4dCA9IHRleHRoO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgJHNjb3BlLnRvb2x0aXAuc2hvdygkZXZlbnQpO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZVRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b29sdGlwLmhpZGUoKTtcbiAgfTtcblxuICAgLy9DbGVhbnVwIHRoZSBwb3BvdmVyIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b29sdGlwLnJlbW92ZSgpO1xuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIGhpZGUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5oaWRkZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB1bmRlZmluZWQ7XG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gcmVtb3ZlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIucmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3N0b3J5Lmh0bWwnLCB7IHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAgICRzY29wZS5tb2RhbHAgPSBtb2RhbDtcbiAgfSk7XG4gICRzY29wZS5sYXN0Rm9jdXNlZDtcblxuICAkcm9vdFNjb3BlLiRvbignb3BlblBvc3RNb2RhbCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG5cbiAgICAkc2NvcGUuc3Bvc3QgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNwb3N0IHx8ICRzY29wZS5zcG9zdDtcblxuICAgIFxuXG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmICghJHNjb3BlLnNwb3N0Lm9wZXJhdGlvbl90eXBlKSB7XG4gICAgICAgICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSA9ICdkZWZhdWx0JztcbiAgICAgIH1cbiAgICAgICRzY29wZS50YWdzQ2hhbmdlKCk7XG5cbiAgICAgICRzY29wZS5tb2RhbHAuc2hvdygpO1xuICAgICAgLyphbmd1bGFyLmVsZW1lbnQoXCJ0ZXh0YXJlYVwiKS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmxhc3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgICB9KTsqL1xuICAgIH0sIDEwKTtcbiAgICAvLyRzY29wZS5tb2RhbHAuc2hvdygpO1xuICB9KTtcblxuICAkcm9vdFNjb3BlLiRvbignY2xvc2VQb3N0TW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubW9kYWxwLmhpZGUoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLmNsb3NlUG9zdE1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgLy8kc2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgICRzY29wZS5tb2RhbHAuaGlkZSgpO1xuICB9O1xuXG5cbiAgJHNjb3BlLmNmb2N1cyA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxhc3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2NDA4OS9pbnNlcnRpbmctYS10ZXh0LXdoZXJlLWN1cnNvci1pcy11c2luZy1qYXZhc2NyaXB0LWpxdWVyeVxuICAkc2NvcGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgaW5wdXQgPSAkc2NvcGUubGFzdEZvY3VzZWQ7XG4gICAgLy9jb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgaWYgKGlucHV0ID09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cbiAgICB2YXIgc2Nyb2xsUG9zID0gaW5wdXQuc2Nyb2xsVG9wO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBicm93c2VyID0gKChpbnB1dC5zZWxlY3Rpb25TdGFydCB8fCBpbnB1dC5zZWxlY3Rpb25TdGFydCA9PSBcIjBcIikgP1xuICAgICAgICAgICAgICAgICAgIFwiZmZcIiA6IChkb2N1bWVudC5zZWxlY3Rpb24gPyBcImllXCIgOiBmYWxzZSApICk7XG4gICAgaWYgKGJyb3dzZXIgPT0gXCJpZVwiKSB7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgICAgcG9zID0gcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7IHBvcyA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IH07XG5cbiAgICB2YXIgZnJvbnQgPSAoaW5wdXQudmFsdWUpLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIHZhciBiYWNrID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcocG9zLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIGlucHV0LnZhbHVlID0gZnJvbnQrdGV4dCtiYWNrO1xuICAgIHBvcyA9IHBvcyArIHRleHQubGVuZ3RoO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgcG9zKTtcbiAgICAgIHJhbmdlLm1vdmVFbmQgKFwiY2hhcmFjdGVyXCIsIDApO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHBvcztcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IHBvcztcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgfVxuICAgIGlucHV0LnNjcm9sbFRvcCA9IHNjcm9sbFBvcztcbiAgICAvL2NvbnNvbGUubG9nKGFuZ3VsYXIuZWxlbWVudChpbnB1dCkudmFsKCkpO1xuICAgIGFuZ3VsYXIuZWxlbWVudChpbnB1dCkudHJpZ2dlcignaW5wdXQnKTtcbiAgfVxuXG5cbiAgJHNjb3BlLnNob3dJbWcgPSBmdW5jdGlvbigpIHtcbiAgIHZhciBoaWRlU2hlZXQgPSAkaW9uaWNBY3Rpb25TaGVldC5zaG93KHtcbiAgICAgYnV0dG9uczogW1xuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBUFRVUkVfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VMRUNUX1BJQ1RVUkUnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9DVVNUT01fVVJMJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdHQUxMRVJZJykgfVxuICAgICBdLFxuICAgICB0aXRsZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTlNFUlRfUElDVFVSRScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAkc2NvcGUuaW5zZXJ0SW1hZ2UoaW5kZXgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfVxuICAgfSk7XG4gIH07XG4gICRzY29wZS5pbnNlcnRJbWFnZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IDEpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICBkZXN0aW5hdGlvblR5cGU6IENhbWVyYS5EZXN0aW5hdGlvblR5cGUuRklMRV9VUkksXG4gICAgICAgIHNvdXJjZVR5cGU6ICh0eXBlPT09MCk/Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLkNBTUVSQTpDYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuUEhPVE9MSUJSQVJZLFxuICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgZW5jb2RpbmdUeXBlOiBDYW1lcmEuRW5jb2RpbmdUeXBlLkpQRUcsXG4gICAgICAgIHBvcG92ZXJPcHRpb25zOiBDYW1lcmFQb3BvdmVyT3B0aW9ucyxcbiAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgLy9jb3JyZWN0T3JpZW50YXRpb246dHJ1ZVxuICAgICAgfTtcbiAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBJbWFnZVVwbG9hZFNlcnZpY2UudXBsb2FkSW1hZ2UoaW1hZ2VEYXRhKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICB2YXIgdXJsID0gcmVzdWx0LmltYWdlVXJsIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgIC8qaWYgKCRzY29wZS5zcG9zdC5ib2R5KSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ICs9IGZpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgPSBmaW5hbDtcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5jbGVhbnVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTUVSQV9DQU5DRUxMRUQnKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMil7XG4gICAgICAkaW9uaWNQb3B1cC5wcm9tcHQoe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9VUkwnKSxcbiAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgIGlucHV0VHlwZTogJ3RleHQnLFxuICAgICAgICBpbnB1dFBsYWNlaG9sZGVyOiAnaHR0cDovL2V4YW1wbGUuY29tL2ltYWdlLmpwZydcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3VyIHVybCBpcycgKyByZXMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAvKmlmICgkc2NvcGUuc3Bvc3QuYm9keSkge1xuICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgKz0gZmluYWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5zcG9zdC5ib2R5ID0gZmluYWw7XG4gICAgICAgICAgfSovXG4gICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLmdhbGxlcnkgPSBbXTtcbiAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIHZhciBpbWdzID0gcmVzLmRhdGE7XG4gICAgICAgIGlmIChpbWdzLmxlbmd0aD4wKXtcbiAgICAgICAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSB0cnVlO1xuICAgICAgICAgICRzY29wZS5nYWxsZXJ5LmltYWdlcyA9IGltZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTk9fSU1BR0UnKSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ25vIGltYWdlcyBhdmFpbGFibGUnKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gICRzY29wZS5jbG9zZUdhbGxlcnkgPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5zaG93Z2FsbGVyeSA9IGZhbHNlO1xuICB9XG4gICRzY29wZS5tYW5hZ2VHYWxsZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlUG9zdE1vZGFsJyk7XG4gICAgJHN0YXRlLmdvKCdhcHAuaW1hZ2VzJyk7XG4gIH1cbiAgZnVuY3Rpb24gc2x1Zyh0ZXh0KSB7XG4gICAgcmV0dXJuIGdldFNsdWcodGV4dCwge3RydW5jYXRlOiAxMjh9KTtcbiAgfTtcbiAgZnVuY3Rpb24gY3JlYXRlUGVybWxpbmsodGl0bGUpIHtcbiAgICB2YXIgcGVybWxpbms7XG4gICAgdmFyIHQgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciB0aW1lZm9ybWF0ID0gdC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkrKHQuZ2V0TW9udGgoKSsxKS50b1N0cmluZygpK3QuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkrXCJ0XCIrdC5nZXRIb3VycygpLnRvU3RyaW5nKCkrdC5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSt0LmdldFNlY29uZHMoKS50b1N0cmluZygpK3QuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKStcInpcIjtcbiAgICBpZiAodGl0bGUgJiYgdGl0bGUudHJpbSgpICE9PSAnJykge1xuICAgICAgdmFyIHMgPSBzbHVnKHRpdGxlKTtcbiAgICAgIHBlcm1saW5rID0gcy50b1N0cmluZygpK1wiLVwiK3RpbWVmb3JtYXQ7XG4gICAgICBpZihwZXJtbGluay5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgLy8gU1RFRU1JVF9NQVhfUEVSTUxJTktfTEVOR1RIXG4gICAgICAgIHBlcm1saW5rID0gcGVybWxpbmsuc3Vic3RyaW5nKHBlcm1saW5rLmxlbmd0aCAtIDI1NSwgcGVybWxpbmsubGVuZ3RoKVxuICAgICAgfVxuICAgICAgLy8gb25seSBsZXR0ZXJzIG51bWJlcnMgYW5kIGRhc2hlcyBzaGFsbCBzdXJ2aXZlXG4gICAgICBwZXJtbGluayA9IHBlcm1saW5rLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15hLXowLTktXSsvZywgJycpXG4gICAgICByZXR1cm4gcGVybWxpbms7XG4gICAgfVxuICB9O1xuICAvLyRzY29wZS5vcGVyYXRpb25fdHlwZSA9ICdkZWZhdWx0JztcbiAgJHNjb3BlLnNwb3N0ID0ge307XG4gICRzY29wZS50YWdzQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS5sb2coXCJ0YWdzQ2hhbmdlXCIpO1xuICAgICRzY29wZS5zcG9zdC50YWdzID0gJGZpbHRlcignbG93ZXJjYXNlJykoJHNjb3BlLnNwb3N0LnRhZ3MpO1xuICAgICRzY29wZS5zcG9zdC5jYXRlZ29yeSA9ICRzY29wZS5zcG9zdC50YWdzPyRzY29wZS5zcG9zdC50YWdzLnNwbGl0KFwiIFwiKTpbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHNjb3BlLnNwb3N0LmNhdGVnb3J5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdiA9ICRzY29wZS5zcG9zdC5jYXRlZ29yeVtpXTtcbiAgICAgIGlmKC9eW9CwLdGP0ZFdLy50ZXN0KHYpKSB7XG4gICAgICAgIHYgPSAncnUtLScgKyAkZmlsdGVyKCdkZXRyYW5zbGl0ZXJhdGUnKSh2LCB0cnVlKTtcbiAgICAgICAgJHNjb3BlLnNwb3N0LmNhdGVnb3J5W2ldID0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5zcG9zdC5jYXRlZ29yeSk7XG4gICAgaWYgKCRzY29wZS5zcG9zdC5jYXRlZ29yeS5sZW5ndGggPiA1KSB7XG4gICAgICAkc2NvcGUuZGlzYWJsZUJ0biA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5kaXNhYmxlQnRuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gICRzY29wZS5jb250ZW50Q2hhbmdlZCA9IGZ1bmN0aW9uIChlZGl0b3IsIGh0bWwsIHRleHQpIHtcbiAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5zcG9zdC5ib2R5KTtcbiAgICAvL2NvbnNvbGUubG9nKCdlZGl0b3I6ICcsIGVkaXRvciwgJ2h0bWw6ICcsIGh0bWwsICd0ZXh0OicsIHRleHQpO1xuICB9O1xuXG4gICRzY29wZS5zdWJtaXRTdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vY29uc29sZS5sb2coJHNjb3BlLnNwb3N0LmJvZHkpO1xuICAgICRzY29wZS50YWdzQ2hhbmdlKCk7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICB2YXIgcGVybWxpbmsgPSBjcmVhdGVQZXJtbGluaygkc2NvcGUuc3Bvc3QudGl0bGUpO1xuICAgICAgICB2YXIganNvbiA9ICRmaWx0ZXIoXCJtZXRhZGF0YVwiKSgkc2NvcGUuc3Bvc3QuYm9keSk7XG4gICAgICAgIGFuZ3VsYXIubWVyZ2UoanNvbiwge3RhZ3M6ICRzY29wZS5zcG9zdC5jYXRlZ29yeSwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9KTtcblxuICAgICAgICBpZiAoISRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSkge1xuICAgICAgICAgICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZSA9ICdkZWZhdWx0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHNjb3BlLnNwb3N0Lm9wZXJhdGlvbl90eXBlICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdOT1QgRGVmYXVsdCcpO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgcGFyZW50X2F1dGhvcjogXCJcIixcbiAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnNwb3N0LmNhdGVnb3J5WzBdLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogcGVybWxpbmssXG4gICAgICAgICAgICB0aXRsZTogJHNjb3BlLnNwb3N0LnRpdGxlLFxuICAgICAgICAgICAgYm9keTogJHNjb3BlLnNwb3N0LmJvZHksXG4gICAgICAgICAgICBqc29uX21ldGFkYXRhOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHBlcm1saW5rOiBwZXJtbGluayxcbiAgICAgICAgICAgIG1heF9hY2NlcHRlZF9wYXlvdXQ6ICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZT09PSdzcCc/XCIxMDAwMDAwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQ6XCIwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQsXG4gICAgICAgICAgICBwZXJjZW50X3N0ZWVtX2RvbGxhcnM6ICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZT09PSdzcCc/MDoxMDAwMCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHsgXCJiZW5lZmljaWFyaWVzXCI6IHsgXCJhY2NvdW50XCI6XCJlc3RlZW1hcHBcIiwgXCJ3ZWlnaHRcIjoxMDAgfSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnZGVmYXVsdCcpO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgcGFyZW50X2F1dGhvcjogXCJcIixcbiAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnNwb3N0LmNhdGVnb3J5WzBdLFxuICAgICAgICAgICAgYXV0aG9yOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwZXJtbGluazogcGVybWxpbmssXG4gICAgICAgICAgICB0aXRsZTogJHNjb3BlLnNwb3N0LnRpdGxlLFxuICAgICAgICAgICAgYm9keTogJHNjb3BlLnNwb3N0LmJvZHksXG4gICAgICAgICAgICBqc29uX21ldGFkYXRhOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHBlcm1saW5rOiBwZXJtbGluayxcbiAgICAgICAgICAgIG1heF9hY2NlcHRlZF9wYXlvdXQ6IFwiMTAwMDAwMC4wMDAgXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0LFxuICAgICAgICAgICAgcGVyY2VudF9zdGVlbV9kb2xsYXJzOiAxMDAwMCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IHsgXCJiZW5lZmljaWFyaWVzXCI6IHsgXCJhY2NvdW50XCI6XCJlc3RlZW1hcHBcIiwgXCJ3ZWlnaHRcIjoxMDAgfSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8kc2NvcGUuY2xvc2VQb3N0TW9kYWwoKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2VQb3N0TW9kYWwnKTtcblxuICAgICAgICAgICAgLy8kc2NvcGUubWVudXBvcG92ZXIuaGlkZSgpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgICAgICAgICAkc2NvcGUuc3Bvc3QgPSB7fTtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfU1VCTUlUVEVEJykpO1xuICAgICAgICAgICAgLy8kc2NvcGUuY2xvc2VNZW51UG9wb3ZlcigpO1xuICAgICAgICAgICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICB9XG4gIH1cbiAgJHNjb3BlLnNhdmVQb3N0ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJHNjb3BlLm1vZGFscCk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zcG9zdCA9ICRzY29wZS5zcG9zdDtcbiAgICAvL2FkZGRyYWZ0XG4gICAgdmFyIGRyID0ge3RpdGxlOiRzY29wZS5zcG9zdC50aXRsZSwgYm9keTogJHNjb3BlLnNwb3N0LmJvZHksIHRhZ3M6ICRzY29wZS5zcG9zdC50YWdzLCBwb3N0X3R5cGU6ICRzY29wZS5zcG9zdC5vcGVyYXRpb25fdHlwZX07XG4gICAgQVBJcy5hZGREcmFmdCgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIGRyKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICBjb25zb2xlLmxvZyhyZXMuZGF0YSk7XG4gICAgICAvLyRzY29wZS5kcmFmdHMgPSByZXMuZGF0YTtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlUG9zdE1vZGFsJyk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgJHNjb3BlLm1vZGFscC5oaWRlKCk7XG4gICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0FWRUQnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfTEFURVInKSk7XG4gIH1cbiAgJHNjb3BlLmNsZWFyUG9zdCA9IGZ1bmN0aW9uKCkge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc3Bvc3QgPSB7fTtcbiAgICAkc2NvcGUuc3Bvc3QgPSB7fTtcbiAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDTEVBUkVEJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUJykpO1xuICB9XG5cblxuICAkcm9vdFNjb3BlLiRvbignZmV0Y2hQb3N0cycsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmZldGNoUG9zdHMoKTtcbiAgfSk7XG5cbiAgJHJvb3RTY29wZS4kb24oJ2ZldGNoQ29udGVudCcsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKSB7XG4gICAgdmFyIHBvc3QgPSBhcmdzLmFueTtcbiAgICAvL2NvbnNvbGUubG9nKHBvc3QpO1xuICAgICRzY29wZS5mZXRjaENvbnRlbnQocG9zdC5hdXRob3IsIHBvc3QucGVybWxpbmspO1xuICB9KTtcblxuICAkc2NvcGUudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndXB2b3RlJywgJ2ZldGNoQ29udGVudCcpO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRvd252b3RlUG9zdCA9IGZ1bmN0aW9uKHBvc3QpIHtcblxuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZMQUdHSU5HX1RFWFQnKVxuICAgIH0pO1xuICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYocmVzKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAnZmV0Y2hDb250ZW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndW52b3RlJywgJ2ZldGNoQ29udGVudCcpO1xuICB9O1xuXG5cbiAgJHJvb3RTY29wZS4kb24oXCJ1c2VyOmxvZ291dFwiLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5mZXRjaFBvc3RzKCk7XG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gIH0pO1xuXG4gICRzY29wZS5sb2FkTW9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAkc2NvcGUubGltaXQgKz0gNTtcbiAgICAvL2lmICghJHNjb3BlLmVycm9yKSB7XG4gICAgJHNjb3BlLmZldGNoUG9zdHMobnVsbCwgJHNjb3BlLmxpbWl0LCBudWxsKTtcbiAgICAvL31cbiAgfTtcbiAgJHNjb3BlLnJlZnJlc2ggPSBmdW5jdGlvbigpe1xuICAgICRzY29wZS5saW1pdCA9IDEwO1xuICAgIC8vaWYgKCEkc2NvcGUuZXJyb3IpIHtcbiAgICAkc2NvcGUuZmV0Y2hQb3N0cyhudWxsLCAkc2NvcGUubGltaXQsIG51bGwpO1xuICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwucmVmcmVzaENvbXBsZXRlJyk7XG4gIH1cblxuICAkc2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgZnVuY3Rpb24gKGV2LCB0bywgdG9QYXJhbXMsIGZyb20sIGZyb21QYXJhbXMpIHtcbiAgICBjb25zb2xlLmxvZygnc3RhdGVDaGFuZ2VTdWNjZXNzJywgJHN0YXRlUGFyYW1zLnJlbmV3KTtcbiAgICBpZiAoZnJvbS5uYW1lID09ICdhcHAucG9zdHMnICYmIHRvLm5hbWUgPT0gJ2FwcC5wb3N0Jykge1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmcm9tLm5hbWUgPT0gJ2FwcC5wb3N0JyAmJiB0by5uYW1lID09ICdhcHAucG9zdHMnKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20ubmFtZSAhPT0gJ2FwcC5wb3N0Jykge1xuICAgICAgICBpZiAoJHN0YXRlUGFyYW1zLnJlbmV3KSB7XG4gICAgICAgICAgJHNjb3BlLmRhdGEgPSBudWxsO1xuICAgICAgICAgICRzY29wZS5kYXRhID0gW107XG4gICAgICAgIH1cbiAgICAgICAgJHNjb3BlLmxvYWRNb3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUubW9yZURhdGFDYW5CZUxvYWRlZCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEkc2NvcGUuZXJyb3I7XG4gIH1cblxuICAkcm9vdFNjb3BlLiRvbignY2hhbmdlVmlldycsIGZ1bmN0aW9uKCl7XG4gICAgLy8kc2NvcGUubWVudXBvcG92ZXIuaGlkZSgpO1xuICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjbG9zZTpwb3BvdmVyJyk7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudmlldyA9PT0gJ2NhcmQnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHNjb3BlLmRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSAkc2NvcGUuZGF0YVtpXTtcbiAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gICRyb290U2NvcGUuJG9uKCdjaGFuZ2VMaWdodCcsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLm1lbnVwb3BvdmVyLmhpZGUoKTtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2xvc2U6cG9wb3ZlcicpO1xuICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gYXJyYXlPYmplY3RJbmRleE9mKG15QXJyYXksIHNlYXJjaFRlcm0sIHByb3BlcnR5KSB7XG4gICAgdmFyIGxsZW4gPSBteUFycmF5Lmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChteUFycmF5W2ldW3Byb3BlcnR5XSA9PT0gc2VhcmNoVGVybSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICAkc2NvcGUuZGF0YSA9IFtdO1xuICAkc2NvcGUudGVtcERhdGEgPSBbXTtcblxuICAkc2NvcGUuZGF0YUNoYW5nZWQgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgdmFyIGxlbm4gPSBuZXdWYWx1ZS5sZW5ndGg7XG4gICAgICB2YXIgdXNlciA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciB8fCBudWxsO1xuICAgICAgdmFyIHZpZXcgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXc7XG5cbiAgICAgIGlmICh1c2VyKXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5uOyBpKyspIHtcbiAgICAgICAgICBpZiAobmV3VmFsdWVbaV0gJiYgbmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gbmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzLmxlbmd0aC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZVtpXS5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2ldLnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWVbaV0uYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2ldLnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpZXcgPT09ICdjYXJkJykge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmpzb25fbWV0YWRhdGEpe1xuICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2aWV3ID09PSAnY2FyZCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbm47IGkrKykge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlW2ldLmpzb25fbWV0YWRhdGEpe1xuICAgICAgICAgICAgICBuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihuZXdWYWx1ZVtpXS5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAkc2NvcGUuZmV0Y2hDb250ZW50ID0gZnVuY3Rpb24oYXV0aG9yLCBwZXJtbGluaykge1xuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2NvbnRlbnRcIiwgW2F1dGhvciwgcGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIHZhciBsZW4gPSByZXN1bHQuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXI7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHJlc3VsdC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRzY29wZS5kYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHYgPSAkc2NvcGUuZGF0YVtpXTtcbiAgICAgICAgICBpZiAodi5wZXJtbGluayA9PT0gcmVzdWx0LnBlcm1saW5rKSB7XG4gICAgICAgICAgICAkc2NvcGUuZGF0YVtpXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLmlmRXhpc3RzID0gZnVuY3Rpb24oeHgpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHNjb3BlLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZGF0YVtpXS5wZXJtbGluayA9PT0geHgpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRzY29wZS5mZXRjaFBvc3RzID0gZnVuY3Rpb24odHlwZSwgbGltaXQsIHRhZykge1xuICAgIHR5cGUgPSB0eXBlIHx8ICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyIHx8IFwidHJlbmRpbmdcIjtcbiAgICB0YWcgPSB0YWcgfHwgJHJvb3RTY29wZS4kc3RvcmFnZS50YWcgfHwgXCJcIjtcbiAgICBsaW1pdCA9IDEwOy8vbGltaXQgfHwgJHNjb3BlLmxpbWl0IHx8IDEwO1xuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHR5cGUgPT09IFwiZmVlZFwiICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgcGFyYW1zID0ge3RhZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBsaW1pdDogbGltaXQsIGZpbHRlcl90YWdzOltdfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSBcImZlZWRcIikge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IFwidHJlbmRpbmdcIjtcbiAgICAgICAgdHlwZSA9IFwidHJlbmRpbmdcIjtcbiAgICAgIH1cbiAgICAgIHBhcmFtcyA9IHt0YWc6IHRhZywgbGltaXQ6IGxpbWl0LCBmaWx0ZXJfdGFnczpbXX07XG4gICAgfVxuICAgIGlmICgkc2NvcGUuZGF0YSAmJiAkc2NvcGUuZGF0YS5sZW5ndGg+MCkge1xuICAgICAgcGFyYW1zLnN0YXJ0X2F1dGhvciA9ICRzY29wZS5kYXRhWyRzY29wZS5kYXRhLmxlbmd0aC0xXS5hdXRob3I7XG4gICAgICBwYXJhbXMuc3RhcnRfcGVybWxpbmsgPSAkc2NvcGUuZGF0YVskc2NvcGUuZGF0YS5sZW5ndGgtMV0ucGVybWxpbms7XG4gICAgfVxuICAgIGlmICgkc2NvcGUuZXJyb3IpIHtcbiAgICAgIC8vJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVFVRVNUX0xJTUlUX1RFWFQnKSk7XG4gICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImZldGNoaW5nLi4uXCIrdHlwZStcIiBcIitsaW1pdCtcIiBcIit0YWcpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvKndpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9zdGF0ZVwiLCBbXCIvXCIrdHlwZV0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgIH0pOyovXG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ2dvbG9zJyAmJiB0eXBlID09ICdmZWVkJykge1xuICAgICAgICAgICAgcGFyYW1zLnNlbGVjdF9hdXRob3JzID0gWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZV07IFxuICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50YWdzOyBcbiAgICAgICAgICB9XG4gICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2Rpc2N1c3Npb25zX2J5X1wiK3R5cGUsIFtwYXJhbXNdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAkc2NvcGUuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzcG9uc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVtpXS5qc29uX21ldGFkYXRhID0gcmVzcG9uc2VbaV0uanNvbl9tZXRhZGF0YT9hbmd1bGFyLmZyb21Kc29uKHJlc3BvbnNlW2ldLmpzb25fbWV0YWRhdGEpOnJlc3BvbnNlW2ldLmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIHBlcm1saW5rID0gcmVzcG9uc2VbaV0ucGVybWxpbms7XG4gICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuaWZFeGlzdHMocGVybWxpbmspKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdXNlciA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdleGlzdCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbaV0gJiYgcmVzcG9uc2VbaV0uYWN0aXZlX3ZvdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHJlc3BvbnNlW2ldLmFjdGl2ZV92b3Rlcy5sZW5ndGgtMTtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbaV0uYWN0aXZlX3ZvdGVzW2pdLnZvdGVyID09PSB1c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXS5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtpXS51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZVtpXS5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVtpXS5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2ldLmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2ldLnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy9pZiAoIS9ibS4qLy50ZXN0KHJlc3BvbnNlW2ldLmNhdGVnb3J5KSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5wdXNoKHJlc3BvbnNlW2ldKTtcbiAgICAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcubG9hZGVkJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUubGltaXQgPSAxMDtcbiAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl0pIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXSA9IGxvY2FsU3RvcmFnZS5zb2NrZXRVcmw7XG4gICAgfVxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS52aWV3KSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcgPSAnY2FyZCc7XG4gICAgfVxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gXCJ0cmVuZGluZ1wiO1xuICAgIH1cbiAgICBpZiAod2luZG93LkFwaSkge1xuICAgICAgLyppZiAoIWFuZ3VsYXIuaXNEZWZpbmVkKCRyb290U2NvcGUudGltZWludCkpIHtcbiAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJBcGkgcmVhZHk6XCIgKyBhbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgICAgICRyb290U2NvcGUudGltZWludCA9ICRpbnRlcnZhbChmdW5jdGlvbigpe1xuICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXNcIiwgW10pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzIFwiKyByZXNwb25zZS5oZWFkX2Jsb2NrX251bWJlcik7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZVBvc3RpbmdLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJsb2dpbiBcIitsb2dpblN1Y2Nlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxNTAwMCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmZXRjaFBvc3RzJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSovXG4gICAgfVxuXG4gICAgLypzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJGlvbmljU2Nyb2xsRGVsZWdhdGUuJGdldEJ5SGFuZGxlKCdtYWluU2Nyb2xsJykuc2Nyb2xsVG9wKCk7XG4gICAgfSwgMTApOyovXG4gIH0pO1xuICBcbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLnRoZW1lID0gJHJvb3RTY29wZS4kc3RvcmFnZS50aGVtZTtcbiAgICBpZiAoJHN0YXRlUGFyYW1zLnRhZ3MpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGFnID0gJHN0YXRlUGFyYW1zLnRhZ3M7XG4gICAgfVxuXG4gICAgaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlKSkge1xuICAgICAgaWYodHlwZW9mIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0UHJlZmVycmVkTGFuZ3VhZ2UoZnVuY3Rpb24obGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgJHRyYW5zbGF0ZS51c2UoKGxhbmd1YWdlLnZhbHVlKS5zcGxpdChcIi1cIilbMF0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTVUNDRVNTIC0+IFwiICsgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlID0gbGFuZ3VhZ2UudmFsdWUuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRVJST1IgLT4gXCIgKyBlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9ICdlbic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICR0cmFuc2xhdGUudXNlKCRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgICRzY29wZS5hY3RpdmVNZW51ID0gJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgfHwgXCJ0cmVuZGluZ1wiO1xuICAgICRzY29wZS5teW1lbnUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPyBbe3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGRUVEJyksIGN1c3RvbTonZmVlZCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1RSRU5ESU5HJyksIGN1c3RvbTondHJlbmRpbmcnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdIT1QnKSwgY3VzdG9tOidob3QnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdORVcnKSwgY3VzdG9tOidjcmVhdGVkJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQUNUSVZFJyksIGN1c3RvbTonYWN0aXZlJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKSwgY3VzdG9tOiAncHJvbW90ZWQnfSwge3RleHQ6JGZpbHRlcigndHJhbnNsYXRlJykoJ1ZPVEVTJyksIGN1c3RvbTondm90ZXMnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UUycpLCBjdXN0b206J2NoaWxkcmVuJ30sIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJyksIGN1c3RvbTogJ2Nhc2hvdXQnfV0gOiBbIHt0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVFJFTkRJTkcnKSwgY3VzdG9tOid0cmVuZGluZyd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0hPVCcpLCBjdXN0b206J2hvdCd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ05FVycpLCBjdXN0b206J2NyZWF0ZWQnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBQ1RJVkUnKSwgY3VzdG9tOidhY3RpdmUnfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQUk9NT1RFRCcpLCBjdXN0b206ICdwcm9tb3RlZCd9LCB7dGV4dDokZmlsdGVyKCd0cmFuc2xhdGUnKSgnVk9URVMnKSwgY3VzdG9tOid2b3Rlcyd9LCB7dGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NPTU1FTlRTJyksIGN1c3RvbTonY2hpbGRyZW4nfSwge3RleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKSwgY3VzdG9tOiAnY2FzaG91dCd9XTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gJHNjb3BlLm15bWVudS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHYgPSAkc2NvcGUubXltZW51W2ldO1xuICAgICAgaWYgKHYuY3VzdG9tID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlcikge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlck5hbWUgPSB2LnRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG59KVxuXG5hcHAuY29udHJvbGxlcignUG9zdEN0cmwnLCBmdW5jdGlvbigkc2NvcGUsICRzdGF0ZVBhcmFtcywgJHJvb3RTY29wZSwgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGlvbmljTW9kYWwsICRmaWx0ZXIsICRpb25pY0FjdGlvblNoZWV0LCAkY29yZG92YUNhbWVyYSwgJGlvbmljUG9wdXAsIEltYWdlVXBsb2FkU2VydmljZSwgJGlvbmljUGxhdGZvcm0sICRpb25pY1NsaWRlQm94RGVsZWdhdGUsICRpb25pY1BvcG92ZXIsICRmaWx0ZXIsICRzdGF0ZSwgQVBJcywgJGlvbmljSGlzdG9yeSwgJGlvbmljUG9zaXRpb24pIHtcbiAgJHNjb3BlLnBvc3QgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtO1xuICAkc2NvcGUuZGF0YSA9IHt9O1xuICAkc2NvcGUuc3Bvc3QgPSB7fTtcbiAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG5cbiAgJGlvbmljUG9wb3Zlci5mcm9tVGVtcGxhdGVVcmwoJ3BvcG92ZXJTbGlkZXJyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gIH0pLnRoZW4oZnVuY3Rpb24ocG9wb3Zlcikge1xuICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyID0gcG9wb3ZlcjtcbiAgfSk7XG4gIFxuICAkc2NvcGUub3BlblNsaWRlcnIgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICAkc2NvcGUudm90aW5nUG9zdCA9IGQ7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUucmFuZ2VWYWx1ZSA9ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDA7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyLnNob3coJGV2ZW50KTtcbiAgfTtcbiAgJHNjb3BlLnZvdGVQb3N0UyA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyci5oaWRlKCk7XG4gICAgJHNjb3BlLnVwdm90ZVBvc3QoJHNjb3BlLnZvdGluZ1Bvc3QpO1xuICB9XG4gICRzY29wZS5kcmFnID0gZnVuY3Rpb24odikge1xuICAgIC8vY29uc29sZS5sb2codik7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gdioxMDA7XG4gIH07XG5cbiAgJHNjb3BlLmNsb3NlU2xpZGVyciA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyci5oaWRlKCk7XG4gIH07XG5cbiAgJHNjb3BlLmlzQm9va21hcmtlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib29rbSA9ICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsgfHwgdW5kZWZpbmVkO1xuICAgIGlmIChib29rbSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtKSB7XG4gICAgICB2YXIgbGVuID0gYm9va20ubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYm9va21baV0gJiYgYm9va21baV0ucGVybWxpbmsgPT09ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICAkc2NvcGUub3B0aW9ucyA9IHtcbiAgICBsb29wOiBmYWxzZSxcbiAgICBzcGVlZDogNTAwLFxuICAgIC8qcGFnaW5hdGlvbjogZmFsc2UsKi9cbiAgICBzaG93UGFnZXI6IGZhbHNlLFxuICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgc3BhY2VCZXR3ZWVuOiAyMCxcbiAgICBicmVha3BvaW50czoge1xuICAgICAgMTAyNDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDUsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxNVxuICAgICAgfSxcbiAgICAgIDc2ODoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDQsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiAxMFxuICAgICAgfSxcbiAgICAgIDY0MDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDMsXG4gICAgICAgICAgc3BhY2VCZXR3ZWVuOiA1XG4gICAgICB9LFxuICAgICAgMzIwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMyxcbiAgICAgICAgICBzcGFjZUJldHdlZW46IDNcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHNjb3BlLmJvb2ttYXJrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvb2sgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrO1xuICAgIGlmICgkc2NvcGUuaXNCb29rbWFya2VkKCkpIHtcbiAgICAgIHZhciBsZW4gPSBib29rLmxlbmd0aDtcbiAgICAgIHZhciBpZCA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGJvb2tbaV0ucGVybWxpbmsgPT09ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspIHtcbiAgICAgICAgICBpZCA9IGJvb2tbaV0uX2lkO1xuICAgICAgICAgIGJvb2suc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaWQpe1xuICAgICAgICBBUElzLnJlbW92ZUJvb2ttYXJrKGlkLCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmsgPSBib29rO1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfVU5CT09LTUFSSycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChib29rKSB7XG4gICAgICAgIHZhciBvbyA9IHsgYXV0aG9yOiRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLHBlcm1saW5rOiRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmt9O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrLnB1c2gob28pO1xuICAgICAgICBBUElzLmFkZEJvb2ttYXJrKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgb28gKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9JU19CT09LTUFSSycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb28gPSB7IGF1dGhvcjokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmF1dGhvcixwZXJtbGluazokcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rfTtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyayA9IFtvb107XG5cbiAgICAgICAgQVBJcy5hZGRCb29rbWFyaygkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsIG9vICkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ1NVQ0NFU1MnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPU1RfSVNfQk9PS01BUksnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8kcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX0JPT0tNQVJLJykpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUubGFzdEZvY3VzZWQ7XG5cblxuICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2NDA4OS9pbnNlcnRpbmctYS10ZXh0LXdoZXJlLWN1cnNvci1pcy11c2luZy1qYXZhc2NyaXB0LWpxdWVyeVxuICAkc2NvcGUuaW5zZXJ0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgaW5wdXQgPSAkc2NvcGUubGFzdEZvY3VzZWQ7XG4gICAgLy9jb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgaWYgKGlucHV0ID09IHVuZGVmaW5lZCkgeyByZXR1cm47IH1cbiAgICB2YXIgc2Nyb2xsUG9zID0gaW5wdXQuc2Nyb2xsVG9wO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBicm93c2VyID0gKChpbnB1dC5zZWxlY3Rpb25TdGFydCB8fCBpbnB1dC5zZWxlY3Rpb25TdGFydCA9PSBcIjBcIikgP1xuICAgICAgICAgICAgICAgICAgIFwiZmZcIiA6IChkb2N1bWVudC5zZWxlY3Rpb24gPyBcImllXCIgOiBmYWxzZSApICk7XG4gICAgaWYgKGJyb3dzZXIgPT0gXCJpZVwiKSB7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQgKFwiY2hhcmFjdGVyXCIsIC1pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgICAgcG9zID0gcmFuZ2UudGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7IHBvcyA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IH07XG5cbiAgICB2YXIgZnJvbnQgPSAoaW5wdXQudmFsdWUpLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIHZhciBiYWNrID0gKGlucHV0LnZhbHVlKS5zdWJzdHJpbmcocG9zLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIGlucHV0LnZhbHVlID0gZnJvbnQrdGV4dCtiYWNrO1xuICAgIHBvcyA9IHBvcyArIHRleHQubGVuZ3RoO1xuICAgIGlmIChicm93c2VyID09IFwiaWVcIikge1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0IChcImNoYXJhY3RlclwiLCAtaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCAoXCJjaGFyYWN0ZXJcIiwgcG9zKTtcbiAgICAgIHJhbmdlLm1vdmVFbmQgKFwiY2hhcmFjdGVyXCIsIDApO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJyb3dzZXIgPT0gXCJmZlwiKSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHBvcztcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IHBvcztcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgfVxuICAgIGlucHV0LnNjcm9sbFRvcCA9IHNjcm9sbFBvcztcbiAgICBjb25zb2xlLmxvZyhhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnZhbCgpKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoaW5wdXQpLnRyaWdnZXIoJ2lucHV0Jyk7XG4gIH1cblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclRyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwID0gcG9wb3ZlcjtcbiAgIH0pO1xuXG4gICAkc2NvcGUub3BlblRvb2x0aXAgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICB2YXIgdHBwdiA9IE51bWJlcihkLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBwID0gTnVtYmVyKGQucHJvbW90ZWQuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRwdiA9IE51bWJlcihkLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciBjcnAgPSBOdW1iZXIoZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgdGV4dGggPSBcIjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9URU5USUFMX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHB2LCAzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUFJPTU9URUQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykocCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFTVF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHB2LDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBVVRIT1JfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGFyLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDVVJBVElPTl9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykoY3JwLDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ3RpbWVhZ28nKShkLmNhc2hvdXRfdGltZSwgdHJ1ZSkrXCI8L2Rpdj48L2Rpdj5cIjtcbiAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICAkc2NvcGUudG9vbHRpcC5zaG93KCRldmVudCk7XG4gICB9O1xuXG4gICAkc2NvcGUuY2xvc2VUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gICB9O1xuXG4gICAvL0NsZWFudXAgdGhlIHBvcG92ZXIgd2hlbiB3ZSdyZSBkb25lIHdpdGggaXQhXG4gICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvb2x0aXAucmVtb3ZlKCk7XG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gaGlkZSBwb3BvdmVyXG4gICAkc2NvcGUuJG9uKCdwb3BvdmVyLmhpZGRlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG4gICAvLyBFeGVjdXRlIGFjdGlvbiBvbiByZW1vdmUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5yZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBFeGVjdXRlIGFjdGlvblxuICAgfSk7XG5cblxuICAkc2NvcGUuaXNJbWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSkge1xuICAgICAgdmFyIGxlbiA9ICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uanNvbl9tZXRhZGF0YS5pbWFnZT8kcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLmpzb25fbWV0YWRhdGEuaW1hZ2UubGVuZ3RoOjA7XG4gICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAkc2NvcGUuaW1hZ2VzID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLmltYWdlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLnpvb21NaW4gPSAxO1xuICAkc2NvcGUuc2hvd0ltYWdlcyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgJHNjb3BlLmFjdGl2ZVNsaWRlID0gaW5kZXg7XG4gICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24oJHNjb3BlLmltYWdlc1tpbmRleF0pKTtcbiAgICAkc2NvcGUuc2hvd0dhbGxlcnlNb2RhbCgndGVtcGxhdGVzL2dhbGxlcnlfaW1hZ2VzLmh0bWwnKTtcbiAgfTtcblxuICAkc2NvcGUuc2hvd0dhbGxlcnlNb2RhbCA9IGZ1bmN0aW9uKHRlbXBsYXRlVXJsKSB7XG4gICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKHRlbXBsYXRlVXJsLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgJHNjb3BlLm1vZGFsZyA9IG1vZGFsO1xuICAgICAgJHNjb3BlLm1vZGFsZy5zaG93KCk7XG4gICAgfSk7XG4gIH1cblxuICAkc2NvcGUuY2xvc2VHYWxsZXJ5TW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubW9kYWxnLmhpZGUoKTtcbiAgICAkc2NvcGUubW9kYWxnLnJlbW92ZSgpXG4gIH07XG5cbiAgJHNjb3BlLnVwZGF0ZVNsaWRlU3RhdHVzID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICB2YXIgem9vbUZhY3RvciA9ICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnc2Nyb2xsSGFuZGxlJyArIHNsaWRlKS5nZXRTY3JvbGxQb3NpdGlvbigpLnpvb207XG4gICAgaWYgKHpvb21GYWN0b3IgPT0gJHNjb3BlLnpvb21NaW4pIHtcbiAgICAgICRpb25pY1NsaWRlQm94RGVsZWdhdGUuZW5hYmxlU2xpZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRpb25pY1NsaWRlQm94RGVsZWdhdGUuZW5hYmxlU2xpZGUoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuc2hvd0ltZyA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGhpZGVTaGVldCA9ICRpb25pY0FjdGlvblNoZWV0LnNob3coe1xuICAgICBidXR0b25zOiBbXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRUxFQ1RfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX0NVU1RPTV9VUkwnKSB9LFxuICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0dBTExFUlknKSB9XG4gICAgIF0sXG4gICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0lOU0VSVF9QSUNUVVJFJyksXG4gICAgIGNhbmNlbFRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU5DRUwnKSxcbiAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgIH0sXG4gICAgIGJ1dHRvbkNsaWNrZWQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICRzY29wZS5pbnNlcnRJbWFnZShpbmRleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICB9KTtcbiAgfTtcbiAgJHNjb3BlLmluc2VydEltYWdlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgaWYgKCRzY29wZS5lZGl0KSB7XG4gICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgIH07XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSArPSBmaW5hbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMil7XG4gICAgICAgICRpb25pY1BvcHVwLnByb21wdCh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdXIgdXJsIGlzJyArIHJlcyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgLyppZiAoJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgICAgICAgJHNjb3BlLnNwb3N0LmJvZHkgKz0gZmluYWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keSA9IGZpbmFsO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAkc2NvcGUuaW5zZXJ0VGV4dChmaW5hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgdmFyIGltZ3MgPSByZXMuZGF0YTtcbiAgICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmdhbGxlcnkuaW1hZ2VzID0gaW1ncztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT19JTUFHRScpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHF1YWxpdHk6IDUwLFxuICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICBzb3VyY2VUeXBlOiAodHlwZT09PTApP0NhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5DQU1FUkE6Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLlBIT1RPTElCUkFSWSxcbiAgICAgICAgICBhbGxvd0VkaXQ6ICh0eXBlPT09MCk/dHJ1ZTpmYWxzZSxcbiAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICBwb3BvdmVyT3B0aW9uczogQ2FtZXJhUG9wb3Zlck9wdGlvbnMsXG4gICAgICAgICAgc2F2ZVRvUGhvdG9BbGJ1bTogZmFsc2VcbiAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgIH07XG4gICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmdldFBpY3R1cmUob3B0aW9ucykudGhlbihmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgSW1hZ2VVcGxvYWRTZXJ2aWNlLnVwbG9hZEltYWdlKGltYWdlRGF0YSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgLy92YXIgdXJsID0gcmVzdWx0LnNlY3VyZV91cmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgLyppZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgKz0gZmluYWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgJHNjb3BlLmluc2VydFRleHQoZmluYWwpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0VSUk9SJykpO1xuICAgICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FNRVJBX0NBTkNFTExFRCcpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gMil7XG4gICAgICAgICRpb25pY1BvcHVwLnByb21wdCh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdXIgdXJsIGlzJyArIHJlcyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgICB2YXIgZmluYWwgPSBcIiAhW2ltYWdlXShcIiArIHVybCArIFwiKVwiO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coZmluYWwpO1xuICAgICAgICAgICAgLyppZiAoJHNjb3BlLmRhdGEuY29tbWVudCkge1xuICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9IGZpbmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IGZpbmFsO1xuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAkc2NvcGUuaW5zZXJ0VGV4dChmaW5hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5nYWxsZXJ5ID0gW107XG4gICAgICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgdmFyIGltZ3MgPSByZXMuZGF0YTtcbiAgICAgICAgICBpZiAoaW1ncy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSB0cnVlO1xuICAgICAgICAgICAgJHNjb3BlLmdhbGxlcnkuaW1hZ2VzID0gaW1ncztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLnNob3dnYWxsZXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdOT19JTUFHRScpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdubyBpbWFnZXMgYXZhaWxhYmxlJylcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9zdG9yeS5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUucG1vZGFsID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUub3BlblBvc3RNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vaWYoISRzY29wZS5wbW9kYWwpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnBtb2RhbC5zaG93KCk7XG4gICAgICAvKmFuZ3VsYXIuZWxlbWVudChcInRleHRhcmVhXCIpLmZvY3VzKGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUubGFzdEZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgICB9KTsqL1xuICAgIH0sIDEwKTtcbiAgfTtcblxuICAkcm9vdFNjb3BlLiRvbignY2xvc2VQb3N0TW9kYWwnLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5wbW9kYWwuaGlkZSgpO1xuICB9KTtcblxuICAkc2NvcGUuY2xvc2VHYWxsZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuc2hvd2dhbGxlcnkgPSBmYWxzZTtcbiAgfVxuICAkc2NvcGUubWFuYWdlR2FsbGVyeSA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgICAkc3RhdGUuZ28oJ2FwcC5pbWFnZXMnKTtcbiAgfVxuICB2YXIgZG1wID0gbmV3IHdpbmRvdy5kaWZmX21hdGNoX3BhdGNoKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlUGF0Y2godGV4dDEsIHRleHQyKSB7XG4gICAgICBpZiAoIXRleHQxICYmIHRleHQxID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBwYXRjaGVzID0gZG1wLnBhdGNoX21ha2UodGV4dDEsIHRleHQyKTtcbiAgICAgIHZhciBwYXRjaCA9IGRtcC5wYXRjaF90b1RleHQocGF0Y2hlcyk7XG4gICAgICByZXR1cm4gcGF0Y2g7XG4gIH1cbiAgJHNjb3BlLmNmb2N1cyA9IGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLmxhc3RGb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgfVxuICAkc2NvcGUuZGVsZXRlUG9zdCA9IGZ1bmN0aW9uKHh4KSB7XG4gICAgJHJvb3RTY29wZS5sb2coJ2RlbGV0ZSBwb3N0ICcrIGFuZ3VsYXIudG9Kc29uKHh4KSk7XG4gICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RFTEVURV9DT01NRU5UJylcbiAgICB9KTtcbiAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG5cbiAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJkZWxldGVfY29tbWVudFwiLCB7XG4gICAgICAgICAgICAgICAgICBhdXRob3I6IHh4LmF1dGhvcixcbiAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiB4eC5wZXJtbGlua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcbiAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnREVMRVRFRF9DT01NRU5UJykpO1xuICAgICAgICAgICAgICAgICAgICAkc3RhdGUuZ28oJ2FwcC5wb3N0cycpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgfSk7XG4gIH1cbiAgJHNjb3BlLmVkaXQgPSBmYWxzZTtcbiAgJHNjb3BlLmVkaXRQb3N0ID0gZnVuY3Rpb24oeHgpIHtcbiAgICAkc2NvcGUuZWRpdCA9IHRydWU7XG4gICAgJHNjb3BlLm9wZW5Qb3N0TW9kYWwoKTtcbiAgICBhbmd1bGFyLmVsZW1lbnQoXCJ0ZXh0YXJlYVwiKS5mb2N1cyhmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5sYXN0Rm9jdXNlZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zb2xlLmxvZyhkb2N1bWVudCk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmICghJHNjb3BlLnNwb3N0LmJvZHkpIHtcbiAgICAgICAgJHNjb3BlLnNwb3N0ID0geHg7XG4gICAgICAgICRzY29wZS5wYXRjaGJvZHkgPSB4eC5ib2R5O1xuICAgICAgfVxuICAgICAgJHNjb3BlLnNwb3N0LnRhZ3MgPSBhbmd1bGFyLmZyb21Kc29uKHh4Lmpzb25fbWV0YWRhdGEpLnRhZ3Muam9pbigpLnJlcGxhY2UoL1xcLC9nLCcgJyk7XG4gICAgfSwgMTApO1xuICB9XG5cbiAgJHNjb3BlLnN1Ym1pdFN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgaWYgKCRzY29wZS5lZGl0KSB7XG4gICAgICB2YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaCgkc2NvcGUucGF0Y2hib2R5LCAkc2NvcGUuc3Bvc3QuYm9keSlcbiAgICAgIC8vIFB1dHRpbmcgYm9keSBpbnRvIGJ1ZmZlciB3aWxsIGV4cGFuZCBVbmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGVpciB0cnVlIGxlbmd0aFxuICAgICAgaWYgKHBhdGNoICYmIHBhdGNoLmxlbmd0aCA8IG5ldyBCdWZmZXIoJHNjb3BlLnNwb3N0LmJvZHksICd1dGYtOCcpLmxlbmd0aCkge1xuICAgICAgICAkc2NvcGUuc3Bvc3QuYm9keTIgPSBwYXRjaDtcbiAgICAgIH1cbiAgICAgIC8vJHJvb3RTY29wZS5sb2cocGF0Y2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuc3Bvc3QuYm9keTIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICB2YXIgcGVybWxpbmsgPSAkc2NvcGUuc3Bvc3QucGVybWxpbms7XG4gICAgICAgIHZhciBqanNvbiA9ICRmaWx0ZXIoXCJtZXRhZGF0YVwiKSgkc2NvcGUuc3Bvc3QuYm9keSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coampzb24pO1xuICAgICAgICAvLyRzY29wZS5zcG9zdC50YWdzID0gJGZpbHRlcignbG93ZXJjYXNlJykoJHNjb3BlLnNwb3N0LnRhZ3MpO1xuICAgICAgICB2YXIganNvbiA9IGFuZ3VsYXIubWVyZ2Uoampzb24sIHt0YWdzOiAkc2NvcGUuc3Bvc3QudGFncy5zcGxpdChcIiBcIiksIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coanNvbik7XG4gICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgIHBhcmVudF9hdXRob3I6IFwiXCIsXG4gICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUuc3Bvc3QucGFyZW50X3Blcm1saW5rLFxuICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgIHBlcm1saW5rOiAkc2NvcGUuc3Bvc3QucGVybWxpbmssXG4gICAgICAgICAgdGl0bGU6ICRzY29wZS5zcG9zdC50aXRsZSxcbiAgICAgICAgICBib2R5OiAkc2NvcGUuc3Bvc3QuYm9keTIgfHwgJHNjb3BlLnNwb3N0LmJvZHksXG4gICAgICAgICAganNvbl9tZXRhZGF0YTogYW5ndWxhci50b0pzb24oanNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICBhbGxvd192b3RlczogdHJ1ZSxcbiAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICBwZXJtbGluazogJHNjb3BlLnNwb3N0LnBlcm1saW5rLFxuICAgICAgICAgIG1heF9hY2NlcHRlZF9wYXlvdXQ6IFwiMTAwMDAwMC4wMDAgXCIrJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0LFxuICAgICAgICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogMTAwMDAsXG4gICAgICAgICAgZXh0ZW5zaW9uczogeyBcImJlbmVmaWNpYXJpZXNcIjogeyBcImFjY291bnRcIjpcImVzdGVlbWFwcFwiLCBcIndlaWdodFwiOjEwMCB9IH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyRzY29wZS5jbG9zZVBvc3RNb2RhbCgpO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2Nsb3NlUG9zdE1vZGFsJyk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICRzY29wZS5zcG9zdCA9IHt9O1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgIC8vJHNjb3BlLmNsb3NlUG9zdFBvcG92ZXIoKTtcbiAgICAgICAgICAgICAgJHN0YXRlLmdvKFwiYXBwLnByb2ZpbGVcIiwge3VzZXJuYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9KTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgIH1cbiAgfVxuICAkc2NvcGUuYWRkSW1hZ2UgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9ICcgIVtpbWFnZV0oJyt1cmwrJykgJztcbiAgfVxuICAkc2NvcGUucmVwbHkgPSBmdW5jdGlvbiAoeHgpIHtcbiAgICAvLyRyb290U2NvcGUubG9nKHh4KTtcbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAkc2NvcGUubXlsb2dpbiA9IG5ldyB3aW5kb3cuZWpzLkxvZ2luKCk7XG4gICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIHZhciB0aW1lZm9ybWF0ID0gdC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkrKHQuZ2V0TW9udGgoKSsxKS50b1N0cmluZygpK3QuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkrXCJ0XCIrdC5nZXRIb3VycygpLnRvU3RyaW5nKCkrdC5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSt0LmdldFNlY29uZHMoKS50b1N0cmluZygpK3QuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKStcInpcIjtcbiAgICAgICAgICB2YXIganNvbiA9IHt0YWdzOiBhbmd1bGFyLmZyb21Kc29uKCRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGEpLnRhZ3NbMF0gfHwgW1wiZXN0ZWVtXCJdICwgYXBwOiAnZXN0ZWVtLycrJHJvb3RTY29wZS4kc3RvcmFnZS5hcHB2ZXJzaW9uLCBmb3JtYXQ6ICdtYXJrZG93bitodG1sJyB9O1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgcGFyZW50X2F1dGhvcjogJHNjb3BlLnBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgcGFyZW50X3Blcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluayxcbiAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgcGVybWxpbms6IFwicmUtXCIrJHNjb3BlLnBvc3QuYXV0aG9yK1wiLVwiKyRzY29wZS5wb3N0LnBlcm1saW5rK1wiLVwiK3RpbWVmb3JtYXQsXG4gICAgICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgICAgIGJvZHk6ICRzY29wZS5kYXRhLmNvbW1lbnQsXG4gICAgICAgICAgICBqc29uX21ldGFkYXRhOiBhbmd1bGFyLnRvSnNvbihqc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBhbGxvd19jdXJhdGlvbl9yZXdhcmRzOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgIHBlcm1saW5rOiBcInJlLVwiKyRzY29wZS5wb3N0LmF1dGhvcitcIi1cIiskc2NvcGUucG9zdC5wZXJtbGluaytcIi1cIit0aW1lZm9ybWF0LCAgXG4gICAgICAgICAgICBtYXhfYWNjZXB0ZWRfcGF5b3V0OiBcIjEwMDAwMDAuMDAwIFwiKyRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCxcbiAgICAgICAgICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogMTAwMDAsXG4gICAgICAgICAgICBleHRlbnNpb25zOiB7IFwiYmVuZWZpY2lhcmllc1wiOiB7IFwiYWNjb3VudFwiOlwiZXN0ZWVtYXBwXCIsIFwid2VpZ2h0XCI6MTAwIH0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwoKTtcbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09NTUVOVF9TVUJNSVRURUQnKSk7XG4gICAgICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50X3JlcGxpZXNcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNvbW1lbnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gICRyb290U2NvcGUuJG9uKFwidXBkYXRlOmNvbnRlbnRcIiwgZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLmxvZyhcInVwZGF0ZTpjb250ZW50XCIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuZ2V0Q29udGVudCgkc2NvcGUucG9zdC5hdXRob3IsICRzY29wZS5wb3N0LnBlcm1saW5rKTsgIFxuXG4gICAgLyp3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50X3JlcGxpZXNcIiwgWyRzY29wZS5wb3N0LmF1dGhvciwgJHNjb3BlLnBvc3QucGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vdG9kbyBmaXggYWN0aXZlX3ZvdGVzXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAkc2NvcGUuY29tbWVudHMgPSByZXN1bHQ7XG4gICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgfSk7XG4gICAgfSk7Ki9cbiAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuXG5cblxuICAgIH0sIDEwMCk7XG5cblxuXG4gICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgfSk7XG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3JlcGx5Lmh0bWwnLCB7XG4gICAgc2NvcGU6ICRzY29wZSAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICRzY29wZS5tb2RhbCA9IG1vZGFsO1xuICB9KTtcblxuICAkc2NvcGUub3Blbk1vZGFsID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIC8vaWYoISRzY29wZS5tb2RhbCkgcmV0dXJuO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUubW9kYWwuc2hvdygpO1xuICAgIH0sIDUpO1xuICB9O1xuXG4gICRzY29wZS5jbG9zZU1vZGFsID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgJHNjb3BlLm1vZGFsLmhpZGUoKTtcbiAgfTtcblxuICAkc2NvcGUuaXNyZXBseWluZyA9IGZ1bmN0aW9uKGNobywgeHgpIHtcbiAgICAkc2NvcGUucmVwbHlpbmcgPSB4eDtcbiAgICBhbmd1bGFyLm1lcmdlKCRzY29wZS5wb3N0LCBjaG8pO1xuICAgIGlmICh4eCkge1xuICAgICAgJHNjb3BlLm9wZW5Nb2RhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuY2xvc2VNb2RhbCgpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLmFjY291bnRzID0ge307XG4gICRzY29wZS5nZXRDb250ZW50ID0gZnVuY3Rpb24oYXV0aG9yLCBwZXJtbGluaykge1xuICAgIC8vY29uc29sZS50aW1lKCdzb21lRnVuY3Rpb24xJyk7XG4gICAgdmFyIHVybCA9IFwiL1wiKyRzdGF0ZVBhcmFtcy5jYXRlZ29yeStcIi9AXCIrYXV0aG9yK1wiL1wiK3Blcm1saW5rO1xuICAgIC8vY29uc29sZS5sb2codXJsKTtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50XCIsIFthdXRob3IsIHBlcm1saW5rXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIHZhciBsZW4gPSByZXN1bHQuYWN0aXZlX3ZvdGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXI7XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS52b3RlciA9PT0gdXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzICYmICRyb290U2NvcGUuJHN0b3JhZ2UucG9zdEFjY291bnRzLmluZGV4T2YocmVzdWx0LmF1dGhvcikgPT0gLTEpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cy5wdXNoKHJlc3VsdC5hdXRob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihyZXN1bHQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgIC8vJHNjb3BlLnBvc3QuYm9keSA9IHJlc3VsdC5ib2R5O1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gcmVzdWx0O1xuICAgICAgICBcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgncG9zdEFjY291bnRzJyk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBcbiAgICAgIC8qd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3N0YXRlXCIsIFt1cmxdKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhkZCk7XG4gICAgICAgIHZhciBjb24gPSBkZC5jb250ZW50O1xuICAgICAgICB2YXIgYWNvbiA9IGRkLmFjY291bnRzO1xuXG4gICAgICAgIGFuZ3VsYXIuZm9yRWFjaChjb24sIGZ1bmN0aW9uKHYsayl7XG4gICAgICAgICAgdi5jb21tZW50cyA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goY29uLCBmdW5jdGlvbih2LGspe1xuICAgICAgICAgIHZhciB2cGFyZW50ID0gdi5wYXJlbnRfYXV0aG9yPT1cIlwiP3YuYXV0aG9yOnYucGFyZW50X2F1dGhvcjtcbiAgICAgICAgICB2YXIgdnBlcm0gPSB2LnBhcmVudF9hdXRob3I9PVwiXCI/di5wZXJtbGluazp2LnBhcmVudF9wZXJtbGluaztcbiAgICAgICAgICB2YXIga2V5eSA9IHZwYXJlbnQrXCIvXCIrdnBlcm07XG4gICAgICAgICAgaWYgKHYuZGVwdGggPiA3KSB7XG4gICAgICAgICAgICB2LnNob3dDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodi5wYXJlbnRfcGVybWxpbmshPT12LmNhdGVnb3J5KSB7XG4gICAgICAgICAgICBpZiAoY29uW2tleXldKSB7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2codik7XG4gICAgICAgICAgICAgIHZhciBsbGVuID0gdi5hY3RpdmVfdm90ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgbHVzZXIgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXI7XG4gICAgICAgICAgICAgIGlmIChsdXNlcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGpsID0gbGxlbiAtIDE7IGpsID49IDA7IGpsLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqbF0udm90ZXIgPT09IGx1c2VyLnVzZXJuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LmFjdGl2ZV92b3Rlc1tqbF0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYuYWN0aXZlX3ZvdGVzW2psXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25ba2V5eV0uY29tbWVudHMucHVzaCh2KTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhhY29uKTsgIFxuICAgICAgICAvL30sIDEpO1xuICAgICAgICBhbmd1bGFyLmZvckVhY2goYWNvbiwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHYuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2Lmpzb25fbWV0YWRhdGEgPT09ICdzdHJpbmcnIHx8IHYuanNvbl9tZXRhZGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICBpZiAodi5qc29uX21ldGFkYXRhLmluZGV4T2YoXCJjcmVhdGVkX2F0XCIpPi0xKSB7XG4gICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihhbmd1bGFyLnRvSnNvbih2Lmpzb25fbWV0YWRhdGEpKTsgIFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb25bYXV0aG9yK1wiL1wiK3Blcm1saW5rXTtcblxuICAgICAgICB2YXIgbGVuID0gcmVzdWx0LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgIHZhciB1c2VyID0gJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09IHVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKHJlc3VsdC5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgJHNjb3BlLnBvc3QgPSByZXN1bHQ7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0gPSByZXN1bHQ7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzID0gYWNvbjtcblxuICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9Ki9cbiAgICB9KTtcbiAgLy8kcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAvL2NvbnNvbGUudGltZUVuZCgnc29tZUZ1bmN0aW9uMScpO1xuXG4gIH07XG4gIFxuICAkc2NvcGUuZmV0Y2hDb21tZW50cyA9IGZ1bmN0aW9uKGF1dGhvciwgcGVybWxpbmspe1xuICAgICRyb290U2NvcGUuZmV0Y2hpbmcgPSB0cnVlO1xuICAgIC8vY29uc29sZS5sb2coYXV0aG9yLHBlcm1saW5rKTtcbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50X3JlcGxpZXNcIiwgW2F1dGhvciwgcGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgLypmb3IgKHZhciBpID0gMDsgaSA8IGRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjdGl2ZV92b3Rlc1wiLCBbZGRbaV0uYXV0aG9yLCBkZFtpXS5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAgIGRkW2ldLmFjdGl2ZV92b3RlcyA9IHJlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSovXG4gICAgICAgICRzY29wZS5jb21tZW50cyA9IGRkO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmNvbW1lbnRzID0gZGQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coZGQuYWN0aXZlX3ZvdGVzKTtcbiAgICAgICAgJHJvb3RTY29wZS5mZXRjaGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgdiA9IGRkW2ldO1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cyAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cy5pbmRleE9mKHYuYXV0aG9yKSA9PSAtMSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHMucHVzaCh2LmF1dGhvcik7XG4gICAgICAgICAgfSAgXG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcDIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXktaGFuZGxlJyk7XG4gICAgICAgICAgJHNjb3BlLnF1b3RlUG9zaXRpb24gPSAkaW9uaWNQb3NpdGlvbi5wb3NpdGlvbihhbmd1bGFyLmVsZW1lbnQocDIpKTtcbiAgICAgICAgICAkaW9uaWNTY3JvbGxEZWxlZ2F0ZS4kZ2V0QnlIYW5kbGUoJ21haW5TY3JvbGwnKS5zY3JvbGxUbygwLCRzY29wZS5xdW90ZVBvc2l0aW9uLnRvcCwgdHJ1ZSk7ICBcbiAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgncG9zdEFjY291bnRzJyk7XG4gICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMCk7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gICRzY29wZS4kb24oJ3Bvc3RBY2NvdW50cycsIGZ1bmN0aW9uKCl7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wYWNjb3VudHMgPSB7fTtcbiAgICAvL2NvbnNvbGUubG9nKHdpbmRvdy5BcGkpO1xuICAgIC8vd2luZG93LkFwaSA9IHN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsfSwgdHJ1ZSk7XG5cbiAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY2NvdW50c1wiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHNdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgdiA9IHJlc1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHYuanNvbl9tZXRhZGF0YSA9PT0gJ3N0cmluZycgfHwgdi5qc29uX21ldGFkYXRhIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodi5qc29uX21ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIGlmICh2Lmpzb25fbWV0YWRhdGEuaW5kZXhPZihcImNyZWF0ZWRfYXRcIik+LTEpIHtcbiAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSBhbmd1bGFyLmZyb21Kc29uKGFuZ3VsYXIudG9Kc29uKHYuanNvbl9tZXRhZGF0YSkpOyAgXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBrZXkgPSB2Lm5hbWU7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzW2tleV0gPSB2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuZW50ZXInLCBmdW5jdGlvbihldil7XG4gICAgLy9jb25zb2xlLmxvZyhldik7XG4gICAgLy9pZihldi50YXJnZXRTY29wZSAhPT0gJHNjb3BlKVxuICAgIC8vICByZXR1cm47XG4gICAgJHJvb3RTY29wZS5sb2coJ2VudGVyIHBvc3RjdHJsJyk7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wb3N0QWNjb3VudHMgPSBbXTtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBhY2NvdW50cyA9IFtdO1xuICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICBpZiAoJHN0YXRlUGFyYW1zLmNhdGVnb3J5ID09PSAnMTExJykge1xuICAgICAgdmFyIHR0ZW1wID0gJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbTtcbiAgICAgICRzY29wZS5wb3N0ID0gdHRlbXA7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3VwZGF0ZTpjb250ZW50Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkc3RhdGVQYXJhbXMuYXV0aG9yLmluZGV4T2YoJ0AnKT4tMSl7XG4gICAgICAgICRzdGF0ZVBhcmFtcy5hdXRob3IgPSAkc3RhdGVQYXJhbXMuYXV0aG9yLnN1YnN0cigxKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdzb21lRnVuY3Rpb24nKTtcbiAgICAgICRzY29wZS5nZXRDb250ZW50KCRzdGF0ZVBhcmFtcy5hdXRob3IsICRzdGF0ZVBhcmFtcy5wZXJtbGluayk7XG4gICAgfVxuICB9KTtcbiAgXG4gICRzY29wZS51cHZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vwdm90ZScsICdnZXRDb250ZW50Jyk7XG4gIH07XG4gICRyb290U2NvcGUuJG9uKCdnZXRDb250ZW50JywgZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5nZXRDb250ZW50KCRyb290U2NvcGUuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtLnBlcm1saW5rKTsgIFxuICAgIH0sIDEwMCk7XG4gIH0pO1xuICAkc2NvcGUuZG93bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZMQUdHSU5HX1RFWFQnKVxuICAgIH0pO1xuICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYocmVzKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAnZ2V0Q29udGVudCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgJHNjb3BlLnVudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAndW52b3RlJywgJ2dldENvbnRlbnQnKTtcbiAgfTtcblxuXG4gICRzY29wZS5wYXVzZVZpZGVvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaWZyYW1lXCIpWzBdLmNvbnRlbnRXaW5kb3c7XG4gICAgaWZyYW1lLnBvc3RNZXNzYWdlKCd7XCJldmVudFwiOlwiY29tbWFuZFwiLFwiZnVuY1wiOlwiJyArICdwYXVzZVZpZGVvJyArICAgJ1wiLFwiYXJnc1wiOlwiXCJ9JywgJyonKTtcbiAgfVxuXG5cbiAgJHNjb3BlLnBsYXlWaWRlbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlmcmFtZVwiKVswXS5jb250ZW50V2luZG93O1xuICAgIGlmcmFtZS5wb3N0TWVzc2FnZSgne1wiZXZlbnRcIjpcImNvbW1hbmRcIixcImZ1bmNcIjpcIicgKyAncGxheVZpZGVvJyArICAgJ1wiLFwiYXJnc1wiOlwiXCJ9JywgJyonKTtcbiAgfVxuXG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVMZWF2ZScsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLnBhdXNlVmlkZW8oKTtcbiAgfSk7XG5cbn0pXG5hcHAuY29udHJvbGxlcignQm9va21hcmtDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRzdGF0ZSwgQVBJcywgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGZpbHRlcikge1xuXG4gICRzY29wZS5yZW1vdmVCb29rbWFyayA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuYm9va21hcmspIHtcbiAgICAgIEFQSXMucmVtb3ZlQm9va21hcmsoJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFya1tpbmRleF0uX2lkLCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJvb2ttYXJrLnNwbGljZShpbmRleCwxKTtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUE9TVF9JU19VTkJPT0tNQVJLJykpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgIEFQSXMuZ2V0Qm9va21hcmtzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ib29rbWFyayA9IHJlcy5kYXRhO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5hcHAuY29udHJvbGxlcignRHJhZnRzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkc3RhdGUsIEFQSXMsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUsICRmaWx0ZXIpIHtcbiAgLy9KU09OLnN0cmluZ2lmeSh7XG4gICRzY29wZS5yZW1vdmVEcmFmdCA9IGZ1bmN0aW9uKF9pZCkge1xuICAgIEFQSXMucmVtb3ZlRHJhZnQoX2lkLCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgQVBJcy5nZXREcmFmdHMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgJHNjb3BlLmRyYWZ0cyA9IHJlcy5kYXRhO1xuICAgICAgfSk7XG4gICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1NUX0lTX1VORFJBRlQnKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgQVBJcy5nZXREcmFmdHMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAkc2NvcGUuZHJhZnRzID0gcmVzLmRhdGE7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmFwcC5jb250cm9sbGVyKCdJbWFnZXNDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRzdGF0ZSwgQVBJcywgJGludGVydmFsLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJGZpbHRlcikge1xuICAvL0pTT04uc3RyaW5naWZ5KHtcbiAgJHNjb3BlLnJlbW92ZUltYWdlID0gZnVuY3Rpb24oX2lkKSB7XG4gICAgQVBJcy5yZW1vdmVJbWFnZShfaWQsJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICBBUElzLmZldGNoSW1hZ2VzKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICRzY29wZS5pbWFnZXMgPSByZXMuZGF0YTtcbiAgICAgIH0pO1xuICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnSU1BR0VfUkVNT1ZFRCcpKTtcbiAgICB9KTtcbiAgfTtcbiAgJHNjb3BlLmNvcHlJbWFnZSA9IGZ1bmN0aW9uKHVybCl7XG4gICAgY29yZG92YS5wbHVnaW5zLmNsaXBib2FyZC5jb3B5KHVybCk7XG4gIH07XG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgIEFQSXMuZmV0Y2hJbWFnZXMoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAkc2NvcGUuaW1hZ2VzID0gcmVzLmRhdGE7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbmFwcC5jb250cm9sbGVyKCdOb3RpZmljYXRpb25zQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkc3RhdGUsIEFQSXMsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUpIHtcblxuICAkc2NvcGUucmVtb3ZlTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZmljYXRpb25zKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LDEpO1xuICAgIH1cbiAgfTtcbn0pXG5hcHAuY29udHJvbGxlcignRm9sbG93Q3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkc3RhdGUsIEFQSXMsICRpbnRlcnZhbCwgJGlvbmljU2Nyb2xsRGVsZWdhdGUpIHtcbiAgJHNjb3BlLnNlYXJjaHUgPSB7fTtcblxuICAkc2NvcGUuJG9uKCckaW9uaWNWaWV3LmJlZm9yZUVudGVyJywgZnVuY3Rpb24oKXtcbiAgICAkc2NvcGUuYWN0aXZlID0gXCJmb2xsb3dlcnNcIjtcbiAgICAkc2NvcGUuZm9sbG93ZXJzID0gW107XG4gICAgJHNjb3BlLmZvbGxvd2luZyA9IFtdO1xuICAgICRzY29wZS5saW1pdCA9IDEwMDtcbiAgICAkc2NvcGUudHQgPSB7cnVzZXI6XCJcIiwgZHVzZXI6XCJcIn07XG5cbiAgICAkc2NvcGUucmZldGNoaW5nID0gZnVuY3Rpb24oKXtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd2Vyc1wiLCBbJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCAkc2NvcGUudHQucnVzZXIsIFwiYmxvZ1wiLCAkc2NvcGUubGltaXRdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoPT09JHNjb3BlLmxpbWl0KSB7XG4gICAgICAgICAgICAkc2NvcGUudHQucnVzZXIgPSByZXNbcmVzLmxlbmd0aC0xXS5mb2xsb3dlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgIHZhciBsbCA9IHJlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsbDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0uaWQgKz0gMTtcbiAgICAgICAgICAgICRzY29wZS5mb2xsb3dlcnMucHVzaChyZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA8ICRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgkc2NvcGUucmZldGNoaW5nLCA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5kZmV0Y2hpbmcgPSBmdW5jdGlvbigpe1xuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZm9sbG93X2FwaSgpLmV4ZWMoXCJnZXRfZm9sbG93aW5nXCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsICRzY29wZS50dC5kdXNlciwgXCJibG9nXCIsICRzY29wZS5saW1pdF0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICBpZiAocmVzICYmIHJlcy5sZW5ndGg9PT0kc2NvcGUubGltaXQpIHtcbiAgICAgICAgICAgICRzY29wZS50dC5kdXNlciA9IHJlc1tyZXMubGVuZ3RoLTFdLmZvbGxvd2luZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxsID0gcmVzLmxlbmd0aDtcblxuICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxsOyBpKyspIHtcbiAgICAgICAgICAgIHJlc1tpXS5pZCArPSAxO1xuICAgICAgICAgICAgJHNjb3BlLmZvbGxvd2luZy5wdXNoKHJlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMubGVuZ3RoPCRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgkc2NvcGUuZGZldGNoaW5nLCA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgICRzY29wZS5yZmV0Y2hpbmcoKTtcbiAgICAkc2NvcGUuZGZldGNoaW5nKCk7XG5cbiAgfSk7XG5cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5sZWF2ZScsIGZ1bmN0aW9uKCl7XG4gICAgLyppZiAoYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLmRmZXRjaGluZykpe1xuICAgICAgJGludGVydmFsLmNhbmNlbCgkc2NvcGUuZGZldGNoaW5nKTtcbiAgICAgICRzY29wZS5kZmV0Y2hpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAkc2NvcGUuZm9sbG93aW5nID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLnJmZXRjaGluZykpe1xuICAgICAgJGludGVydmFsLmNhbmNlbCgkc2NvcGUucmZldGNoaW5nKTtcbiAgICAgICRzY29wZS5yZmV0Y2hpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAkc2NvcGUuZm9sbG93ZXJzID0gdW5kZWZpbmVkO1xuICAgIH0qL1xuICB9KTtcbiAgJHNjb3BlLmlzRm9sbG93ZWQgPSBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGxlbiA9ICRzY29wZS5mb2xsb3dpbmcubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICgkc2NvcGUuZm9sbG93aW5nW2ldLmZvbGxvd2luZyA9PSB4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gICRzY29wZS5pc0ZvbGxvd2luZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgbGVuID0gJHNjb3BlLmZvbGxvd2Vycy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCRzY29wZS5mb2xsb3dlcnNbaV0uZm9sbG93ZXIgPT0geCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAkc2NvcGUuY2hhbmdlID0gZnVuY3Rpb24odHlwZSl7XG4gICAgJHNjb3BlLmFjdGl2ZSA9IHR5cGU7XG4gICAgY29uc29sZS5sb2codHlwZSk7XG5cbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICAgICRpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZSgnbGlzdFNjcm9sbCcpLnNjcm9sbFRvcCgpO1xuICAgIC8vJHNjb3BlLmxvYWRNb3JlKHR5cGUpO1xuICB9XG5cbiAgJHNjb3BlLiRvbignY3VycmVudDpyZWxvYWQnLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUubG9nKCdjdXJyZW50OnJlbG9hZCcpO1xuICAgIC8vJHN0YXRlLmdvKCRzdGF0ZS5jdXJyZW50LCB7fSwge3JlbG9hZDogdHJ1ZX0pO1xuICAgICRzY29wZS5mb2xsb3dlcnMgPSBbXTtcbiAgICAkc2NvcGUuZm9sbG93aW5nID0gW107XG4gICAgJHNjb3BlLnJmZXRjaGluZygpO1xuICAgICRzY29wZS5kZmV0Y2hpbmcoKTtcbiAgfSk7XG5cbiAgJHNjb3BlLnVuZm9sbG93VXNlciA9IGZ1bmN0aW9uKHh4KXtcbiAgICAkcm9vdFNjb3BlLmZvbGxvd2luZyh4eCwgXCJ1bmZvbGxvd1wiKTtcbiAgfTtcbiAgJHNjb3BlLmZvbGxvd1VzZXIgPSBmdW5jdGlvbih4eCl7XG4gICAgJHJvb3RTY29wZS5mb2xsb3dpbmcoeHgsIFwiZm9sbG93XCIpO1xuICB9O1xuICAkc2NvcGUucHJvZmlsZVZpZXcgPSBmdW5jdGlvbih4eCl7XG4gICAgJHN0YXRlLmdvKCdhcHAucHJvZmlsZScsIHt1c2VybmFtZTogeHh9KTtcbiAgfTtcblxufSlcblxuYXBwLmNvbnRyb2xsZXIoJ1Byb2ZpbGVDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUsICRpb25pY0FjdGlvblNoZWV0LCAkY29yZG92YUNhbWVyYSwgSW1hZ2VVcGxvYWRTZXJ2aWNlLCAkaW9uaWNQb3B1cCwgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZSwgJGlvbmljSGlzdG9yeSwgJHN0YXRlLCBBUElzLCAkaW9uaWNQb3BvdmVyLCAkZmlsdGVyLCAkaW9uaWNNb2RhbCkge1xuXG4gICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyU2xpZGVycnAuaHRtbCcsIHtcbiAgICAgIHNjb3BlOiAkc2NvcGVcbiAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcFNsaWRlciA9IHBvcG92ZXI7XG4gIH0pO1xuICBcbiAgJHNjb3BlLm9wZW5TbGlkZXIgPSBmdW5jdGlvbigkZXZlbnQsIGQpIHtcbiAgICAkc2NvcGUudm90aW5nUG9zdCA9IGQ7XG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICAkc2NvcGUucmFuZ2VWYWx1ZSA9ICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodC8xMDA7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuc2hvdygkZXZlbnQpO1xuICB9O1xuXG4gICRzY29wZS5kcmFnID0gZnVuY3Rpb24odikge1xuICAgIC8vY29uc29sZS5sb2codik7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0ID0gdioxMDA7XG4gIH1cbiAgJHNjb3BlLnZvdGVQb3N0UyA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwU2xpZGVyLmhpZGUoKTtcbiAgICAkc2NvcGUudXB2b3RlUG9zdCgkc2NvcGUudm90aW5nUG9zdCk7XG4gIH07XG5cbiAgJHNjb3BlLmNsb3NlU2xpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnRvb2x0aXBTbGlkZXIuaGlkZSgpO1xuICB9O1xuXG4gICRzY29wZS50cmFuc2xhdGlvbkRhdGEgPSB7IHBsYXRmb3JtbmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybW5hbWUsIHBsYXRmb3JtcG93ZXI6ICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciwgcGxhdGZvcm1zdW5pdDpcIiQxLjAwXCIgfTtcblxuICAkc2NvcGUuZ29CYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZpZXdIaXN0b3J5ID0gJGlvbmljSGlzdG9yeS52aWV3SGlzdG9yeSgpO1xuICAgIGlmICghdmlld0hpc3RvcnkuYmFja1ZpZXcpIHtcbiAgICAgICRzY29wZS5vcGVuTWVudSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW9uaWNIaXN0b3J5LmdvQmFjaygpO1xuICAgIH1cbiAgfTtcbiAgJHNjb3BlLmZvbGxvd1VzZXIgPSBmdW5jdGlvbih4eCl7XG4gICAgJHJvb3RTY29wZS5mb2xsb3dpbmcoeHgsIFwiZm9sbG93XCIpO1xuICB9O1xuICAkc2NvcGUudW5mb2xsb3dVc2VyID0gZnVuY3Rpb24oeHgpe1xuICAgICRyb290U2NvcGUubG9nKHh4KTtcbiAgICAkcm9vdFNjb3BlLmZvbGxvd2luZyh4eCwgXCJ1bmZvbGxvd1wiKTtcbiAgfTtcblxuICAkc2NvcGUuJG9uKCdjdXJyZW50OnJlbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgJHN0YXRlLmdvKCRzdGF0ZS5jdXJyZW50LCB7fSwge3JlbG9hZDogdHJ1ZX0pO1xuICB9KTtcblxuICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclBUci5odG1sJywge1xuICAgICAgc2NvcGU6ICRzY29wZVxuICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAkc2NvcGUudG9vbHRpcCA9IHBvcG92ZXI7XG4gICB9KTtcblxuICAgJHNjb3BlLm9wZW5Ub29sdGlwID0gZnVuY3Rpb24oJGV2ZW50LCBkKSB7XG4gICAgdmFyIHRwcHYgPSBOdW1iZXIoZC5wZW5kaW5nX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgcCA9IE51bWJlcihkLnByb21vdGVkLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgIHZhciB0cHYgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIGFyID0gTnVtYmVyKGQudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0tZC5jdXJhdG9yX3BheW91dF92YWx1ZS5zcGxpdCgnICcpWzBdKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcbiAgICB2YXIgY3JwID0gTnVtYmVyKGQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgdmFyIHRleHRoID0gXCI8ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BPVEVOVElBTF9QQVlPVVQnKStcIjwvYj48L2Rpdj48ZGl2IGNsYXNzPSdjb2wnPlwiKyRmaWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJykoJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSkrJGZpbHRlcignbnVtYmVyJykodHBwdiwgMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BST01PVEVEJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHAsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBU1RfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwdiwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVVUSE9SX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKShhciwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ1VSQVRJT05fUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKGNycCwzKStcIjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9J3Jvdyc+PGRpdiBjbGFzcz0nY29sJz48Yj5cIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCd0aW1lYWdvJykoZC5jYXNob3V0X3RpbWUsIHRydWUpK1wiPC9kaXY+PC9kaXY+XCI7XG4gICAgJHNjb3BlLnRvb2x0aXBUZXh0ID0gdGV4dGg7XG4gICAgJHNjb3BlLnRvb2x0aXAuc2hvdygkZXZlbnQpO1xuICAgfTtcblxuICAgJHNjb3BlLmNsb3NlVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLnRvb2x0aXAuaGlkZSgpO1xuICAgfTtcblxuICAgLy9DbGVhbnVwIHRoZSBwb3BvdmVyIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS50b29sdGlwLnJlbW92ZSgpO1xuICAgfSk7XG5cbiAgIC8vIEV4ZWN1dGUgYWN0aW9uIG9uIGhpZGUgcG9wb3ZlclxuICAgJHNjb3BlLiRvbigncG9wb3Zlci5oaWRkZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uXG4gICB9KTtcblxuICAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gcmVtb3ZlIHBvcG92ZXJcbiAgICRzY29wZS4kb24oJ3BvcG92ZXIucmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25cbiAgIH0pO1xuXG4gICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgnbXktZWRpdC5odG1sJywge1xuICAgIHNjb3BlOiAkc2NvcGUsXG4gICAgYW5pbWF0aW9uOiAnc2xpZGUtaW4tdXAnXG4gIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAkc2NvcGUubW9kYWxFZGl0ID0gbW9kYWw7XG4gIH0pO1xuICAkc2NvcGUuY2xvc2VFZGl0cyA9IGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS5tb2RhbEVkaXQuaGlkZSgpO1xuICB9O1xuICAvLyBDbGVhbnVwIHRoZSBtb2RhbCB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUubW9kYWxFZGl0LnJlbW92ZSgpO1xuICB9KTtcbiAgLy8gRXhlY3V0ZSBhY3Rpb24gb24gaGlkZSBtb2RhbFxuICAkc2NvcGUuJG9uKCdtb2RhbC5oaWRkZW4nLCBmdW5jdGlvbigpIHtcbiAgICAvLyBFeGVjdXRlIGFjdGlvblxuICB9KTtcbiAgJHNjb3BlLmVkaXQgPSB7fTtcbiAgJHNjb3BlLnNob3dFZGl0cyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vc2hvd2VkaXRzXG4gICAgJHNjb3BlLmVkaXQgPSB7fTtcbiAgICAkc2NvcGUuZWRpdCA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhIHx8IHt9O1xuICAgICRzY29wZS5tb2RhbEVkaXQuc2hvdygpO1xuICB9XG4gICRzY29wZS5zYXZlRWRpdCA9IGZ1bmN0aW9uKCl7XG4gICAgY29uc29sZS5sb2coJHNjb3BlLmVkaXQpO1xuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICB0ZW1wbGF0ZTogXCJcIlxuICAgIH0pO1xuICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYocmVzKSB7XG4gICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZSA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhO1xuICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkc2NvcGUuZWRpdCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZS5wcm9maWxlUGljVXJsKSB7ZGVsZXRlIHVwZGF0ZS5wcm9maWxlUGljVXJsO31cbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkc2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSB8fCBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3RvZG86IGlmIGpzb25fbWV0YWRhdGEgYWxyZWFkeSBleGlzdCBtYWtlIHN1cmUgdG8ga2VlcCBpdC5cbiAgICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgbWVtb19rZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5tZW1vX2tleSxcbiAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUubW9kYWxFZGl0LmhpZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gICRzY29wZS5zaG93UHJvZmlsZSA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGhpZGVTaGVldCA9ICRpb25pY0FjdGlvblNoZWV0LnNob3coe1xuICAgICBidXR0b25zOiBbXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRUxFQ1RfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX0NVU1RPTV9VUkwnKSB9LFxuICAgICBdLFxuICAgICBkZXN0cnVjdGl2ZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVNFVCcpLFxuICAgICB0aXRsZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdNT0RJRllfUElDVFVSRScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuY2hhbmdlUHJvZmlsZUluZm8oaW5kZXgsICdwcm9maWxlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgfSxcbiAgICAgZGVzdHJ1Y3RpdmVCdXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCl7XG4gICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVTRVRfUElDVFVSRV9URVhUJylcbiAgICAgIH0pO1xuICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkICYmICEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucHJpdmF0ZUFjdGl2ZUtleSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHtwcm9maWxlOiB7cHJvZmlsZV9pbWFnZTpcIlwifSB9O1xuICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUucHJvZmlsZVBpY1VybCkge2RlbGV0ZSB1cGRhdGUucHJvZmlsZVBpY1VybDt9XG5cbiAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgPSBcIlwiO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vdG9kbzogaWYganNvbl9tZXRhZGF0YSBhbHJlYWR5IGV4aXN0IG1ha2Ugc3VyZSB0byBrZWVwIGl0LlxuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgYWNjb3VudDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgbWVtb19rZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5tZW1vX2tleSxcbiAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICB9KTtcbiAgfTtcblxuXG4gICRzY29wZS5jaGFuZ2VQcm9maWxlSW5mbyA9IGZ1bmN0aW9uKHR5cGUsIHdoaWNoKSB7XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTF9BJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKHR5cGUgPT0gMCB8fCB0eXBlID09IDEpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgICBkZXN0aW5hdGlvblR5cGU6IENhbWVyYS5EZXN0aW5hdGlvblR5cGUuRklMRV9VUkksXG4gICAgICAgICAgc291cmNlVHlwZTogKHR5cGU9PT0wKT9DYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuQ0FNRVJBOkNhbWVyYS5QaWN0dXJlU291cmNlVHlwZS5QSE9UT0xJQlJBUlksXG4gICAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgICAgZW5jb2RpbmdUeXBlOiBDYW1lcmEuRW5jb2RpbmdUeXBlLkpQRUcsXG4gICAgICAgICAgdGFyZ2V0V2lkdGg6IHdoaWNoPT09J3Byb2ZpbGUnPzUwMDoxMDAwLFxuICAgICAgICAgIHRhcmdldEhlaWdodDogNTAwLFxuICAgICAgICAgIHBvcG92ZXJPcHRpb25zOiBDYW1lcmFQb3BvdmVyT3B0aW9ucyxcbiAgICAgICAgICBzYXZlVG9QaG90b0FsYnVtOiBmYWxzZVxuICAgICAgICAgIC8vY29ycmVjdE9yaWVudGF0aW9uOnRydWVcbiAgICAgICAgfTtcbiAgICAgICAgJGNvcmRvdmFDYW1lcmEuZ2V0UGljdHVyZShvcHRpb25zKS50aGVuKGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgICAgICAgIEltYWdlVXBsb2FkU2VydmljZS51cGxvYWRJbWFnZShpbWFnZURhdGEpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAvL3ZhciB1cmwgPSByZXN1bHQuc2VjdXJlX3VybCB8fCAnJztcbiAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0geyBwcm9maWxlOiB7IGNvdmVyX2ltYWdlOiBcIlwiLCBwcm9maWxlX2ltYWdlOiBcIlwifSB9O1xuICAgICAgICAgICAgaWYgKHdoaWNoID09PSAncHJvZmlsZScpIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZS5wcm9maWxlUGljVXJsKSB7ZGVsZXRlIHVwZGF0ZS5wcm9maWxlUGljVXJsO31cbiAgICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUucHJvZmlsZV9pbWFnZSA9IHVybDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLmNvdmVyX2ltYWdlID0gdXJsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZW1vX2tleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLm1lbW9fa2V5LFxuICAgICAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUxfQScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNSk7XG4gICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURfRVJST1InKSk7XG4gICAgICAgICAgICBpZiAoIWlvbmljLlBsYXRmb3JtLmlzQW5kcm9pZCgpIHx8ICFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgICAgICAgICRjb3Jkb3ZhQ2FtZXJhLmNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDQU1FUkFfQ0FOQ0VMTEVEJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpb25pY1BvcHVwLnByb21wdCh7XG4gICAgICAgICAgdGl0bGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfVVJMJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgaW5wdXRUeXBlOiAndGV4dCcsXG4gICAgICAgICAgaW5wdXRQbGFjZWhvbGRlcjogJ2h0dHA6Ly9leGFtcGxlLmNvbS9pbWFnZS5qcGcnXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdXIgdXJsIGlzJysgcmVzKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0geyBwcm9maWxlOiB7IHByb2ZpbGVfaW1hZ2U6IFwiXCIsIGNvdmVyX2ltYWdlOlwiXCIgfSB9O1xuICAgICAgICAgICAgaWYgKHdoaWNoPT09XCJwcm9maWxlXCIpIHtcbiAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZSh1cGRhdGUsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZS5wcm9maWxlUGljVXJsKSB7ZGVsZXRlIHVwZGF0ZS5wcm9maWxlUGljVXJsO31cbiAgICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUucHJvZmlsZV9pbWFnZSA9IHJlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2UodXBkYXRlLCAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgICAgIHVwZGF0ZS5wcm9maWxlLmNvdmVyX2ltYWdlID0gcmVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luLnNldFJvbGVzKFtcImFjdGl2ZVwiXSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImFjY291bnRfdXBkYXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBtZW1vX2tleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLm1lbW9fa2V5LFxuICAgICAgICAgICAgICAgICAgICBqc29uX21ldGFkYXRhOiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyRzY29wZS5yZWZyZXNoTG9jYWxVc2VyRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLnNob3dDb3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgdmFyIGhpZGVTaGVldCA9ICRpb25pY0FjdGlvblNoZWV0LnNob3coe1xuICAgICBidXR0b25zOiBbXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FQVFVSRV9QSUNUVVJFJykgfSxcbiAgICAgICB7IHRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRUxFQ1RfUElDVFVSRScpIH0sXG4gICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX0NVU1RPTV9VUkwnKSB9LFxuICAgICBdLFxuICAgICBkZXN0cnVjdGl2ZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVNFVCcpLFxuICAgICB0aXRsZVRleHQ6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdNT0RJRllfQ09WRVJfUElDVFVSRScpLFxuICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGFkZCBjYW5jZWwgY29kZS4uXG4gICAgICB9LFxuICAgICBidXR0b25DbGlja2VkOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgJiYgISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuY2hhbmdlUHJvZmlsZUluZm8oaW5kZXgsICdjb3ZlcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgIH0sXG4gICAgIGRlc3RydWN0aXZlQnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVCcpXG4gICAgICB9KTtcbiAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCAmJiAhJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSB7cHJvZmlsZToge2NvdmVyX2ltYWdlOlwiXCJ9IH07XG4gICAgICAgICAgICBhbmd1bGFyLm1lcmdlKHVwZGF0ZSwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgdXBkYXRlLnByb2ZpbGUuY292ZXJfaW1hZ2UgPSBcIlwiO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRzY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuYWN0aXZlLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5IHx8IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vdG9kbzogaWYganNvbl9tZXRhZGF0YSBhbHJlYWR5IGV4aXN0IG1ha2Ugc3VyZSB0byBrZWVwIGl0LlxuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiYWNjb3VudF91cGRhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgYWNjb3VudDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgbWVtb19rZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5tZW1vX2tleSxcbiAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIHRyLnByb2Nlc3NfdHJhbnNhY3Rpb24oJHNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdyZWZyZXNoTG9jYWxVc2VyRGF0YScpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMX0EnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdXQVJOSU5HJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9UT19YJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgICB9XG4gICB9KTtcbiAgfTtcblxuXG4gICRyb290U2NvcGUuJG9uKCdwcm9maWxlUmVmcmVzaCcsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLnJlZnJlc2goKTtcbiAgfSk7XG4gICRzY29wZS51cHZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vwdm90ZScsICdwcm9maWxlUmVmcmVzaCcpO1xuICB9O1xuICAkc2NvcGUuZG93bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0ZMQUdHSU5HX1RFWFQnKVxuICAgIH0pO1xuICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgaWYocmVzKSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgJHJvb3RTY29wZS52b3RlUG9zdChwb3N0LCAnZG93bnZvdGUnLCAncHJvZmlsZVJlZnJlc2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gICRzY29wZS51bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ3Vudm90ZScsICdwcm9maWxlUmVmcmVzaCcpO1xuICB9O1xuXG4gICRzY29wZS5pc0FtRm9sbG93aW5nID0gZnVuY3Rpb24oeHgpIHtcbiAgICBpZiAoJHNjb3BlLmZvbGxvd2luZyAmJiAkc2NvcGUuZm9sbG93aW5nLmluZGV4T2YoeHgpIT09LTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKiRzY29wZS4kd2F0Y2goJ2ZvbGxvd2luZycsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdoZXksIG15VmFyIGhhcyBjaGFuZ2VkIScpO1xuICB9KTsqL1xuICAkc2NvcGUuaWZFeGlzdHMgPSBmdW5jdGlvbih4eCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5wZXJtbGluayA9PT0geHgpe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRzY29wZS5lbmQgPSBmYWxzZTtcbiAgJHNjb3BlLmNsZW4gPSAyMDtcbiAgJHNjb3BlLm1vcmVEYXRhQ2FuQmVMb2FkZWQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAoJHNjb3BlLmRhdGEucHJvZmlsZSAmJiAkc2NvcGUuZGF0YS5wcm9maWxlLmxlbmd0aD4wKSAmJiAhJHNjb3BlLmVuZDtcbiAgfVxuXG4gICRzY29wZS5sb2FkbW9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vY29uc29sZS5sb2coJ2xvYWRtb3JlJyk7XG4gICAgdmFyIHBhcmFtcyA9IHt0YWc6ICRzdGF0ZVBhcmFtcy51c2VybmFtZSwgbGltaXQ6IDIwLCBmaWx0ZXJfdGFnczpbXX07XG4gICAgdmFyIGxlbiA9ICRzY29wZS5kYXRhLnByb2ZpbGU/JHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGg6MDtcblxuICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmRhdGEucHJvZmlsZSk7XG5cbiAgICBpZiAobGVuPjApIHtcbiAgICAgIGRlbGV0ZSBwYXJhbXMubGltaXQ7XG4gICAgICBwYXJhbXMuc3RhcnRfYXV0aG9yID0gJHNjb3BlLmRhdGEucHJvZmlsZVtsZW4tMV0uYXV0aG9yO1xuICAgICAgcGFyYW1zLnN0YXJ0X3Blcm1saW5rID0gJHNjb3BlLmRhdGEucHJvZmlsZVtsZW4tMV0ucGVybWxpbms7XG5cbiAgICAgIGlmICgkc2NvcGUuZW5kKSB7XG4gICAgICAgIC8vJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdSRVFVRVNUX0xJTUlUX1RFWFQnKSk7XG4gICAgICAgICRzY29wZS4kYnJvYWRjYXN0KCdzY3JvbGwuaW5maW5pdGVTY3JvbGxDb21wbGV0ZScpO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwYXJhbXMpO1xuICAgICAgICAvLyRyb290U2NvcGUubG9nKFwiZmV0Y2hpbmcgcHJvZmlsZS4uLmJsb2cgMjAgXCIpO1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICgkc2NvcGUuYWN0aXZlID09ICdibG9nJykge1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSAnZ29sb3MnKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnNlbGVjdF9hdXRob3JzID0gWyRzdGF0ZVBhcmFtcy51c2VybmFtZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy50YWdzOyAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9kaXNjdXNzaW9uc19ieV9ibG9nXCIsIFtwYXJhbXNdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXNwb25zZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlc3BvbnNlW2pdO1xuICAgICAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgISRzY29wZS4kJHBoYXNlPyRzY29wZS4kYXBwbHkoKTpjb25zb2xlLmxvZygncGhhc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gJHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCA9PT0gdi5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQsIHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnByb2ZpbGUucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuYWN0aXZlID09ICdwb3N0cycpIHtcbiAgICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2Rpc2N1c3Npb25zX2J5X2NvbW1lbnRzXCIsIFtwYXJhbXNdKS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXNwb25zZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlc3BvbnNlW2pdO1xuICAgICAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgISRzY29wZS4kJHBoYXNlPyRzY29wZS4kYXBwbHkoKTpjb25zb2xlLmxvZygncGhhc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gJHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCA9PT0gdi5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQsIHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnByb2ZpbGUucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkc2NvcGUuYWN0aXZlID09ICdyZWNlbnQtcmVwbGllcycpIHtcbiAgICAgICAgICAgICAgdmFyIHBwID0gWyRzY29wZS5kYXRhLnByb2ZpbGVbJHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGgtMV0uYXV0aG9yLCAkc2NvcGUuZGF0YS5wcm9maWxlWyRzY29wZS5kYXRhLnByb2ZpbGUubGVuZ3RoLTFdLnBlcm1saW5rLCAyMF07XG4gICAgICAgICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9yZXBsaWVzX2J5X2xhc3RfdXBkYXRlXCIsIFtwcF0pLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2Upe1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXNwb25zZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlc3BvbnNlW2pdO1xuICAgICAgICAgICAgICAgICAgICB2Lmpzb25fbWV0YWRhdGEgPSB2Lmpzb25fbWV0YWRhdGE/YW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpOnYuanNvbl9tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgISRzY29wZS4kJHBoYXNlPyRzY29wZS4kYXBwbHkoKTpjb25zb2xlLmxvZygncGhhc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gJHNjb3BlLmRhdGEucHJvZmlsZS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLmRhdGEucHJvZmlsZVtpXS5pZCA9PT0gdi5pZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRzY29wZS5kYXRhLnByb2ZpbGVbaV0uaWQsIHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLnByb2ZpbGUucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAkc2NvcGUuJGJyb2FkY2FzdCgnc2Nyb2xsLmluZmluaXRlU2Nyb2xsQ29tcGxldGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLnByb2ZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbiAgJHNjb3BlLiRvbignJGlvbmljVmlldy5iZWZvcmVFbnRlcicsIGZ1bmN0aW9uKCl7XG4gICAgJHNjb3BlLnVzZXIgPSB7dXNlcm5hbWU6ICRzdGF0ZVBhcmFtcy51c2VybmFtZX07XG4gICAgJHNjb3BlLmZvbGxvd2VyID0gW107XG4gICAgJHNjb3BlLmZvbGxvd2luZyA9IFtdO1xuICAgICRzY29wZS5saW1pdCA9IDEwMDtcbiAgICAkc2NvcGUudHQgPSB7ZHVzZXI6IFwiXCIsIHJ1c2VyOiBcIlwifTtcblxuICAgICRzY29wZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISRzY29wZS5hY3RpdmUpIHtcbiAgICAgICAgJHNjb3BlLmFjdGl2ZSA9IFwiYmxvZ1wiO1xuICAgICAgfVxuICAgICAgaWYgKCRzY29wZS5hY3RpdmUgIT0gXCJibG9nXCIpIHtcbiAgICAgICAgJHNjb3BlLnJlc3QgPSBcIi9cIiskc2NvcGUuYWN0aXZlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLnJlc3QgPSBcIlwiO1xuICAgICAgfVxuXG4gICAgICAkc2NvcGUubm9uZXhpc3QgPSBmYWxzZTtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfc3RhdGVcIiwgW1wiL0BcIiskc3RhdGVQYXJhbXMudXNlcm5hbWUrJHNjb3BlLnJlc3RdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgJHNjb3BlLmRhdGEgPSB7cHJvZmlsZTogW119O1xuICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzLmNvbnRlbnQpLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzLmNvbnRlbnQsIGZ1bmN0aW9uKHYsayl7XG4gICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IHYuanNvbl9tZXRhZGF0YT9hbmd1bGFyLmZyb21Kc29uKHYuanNvbl9tZXRhZGF0YSk6di5qc29uX21ldGFkYXRhO1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKXtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSB2LmF1dGhvcikge1xuICAgICAgICAgICAgICAgICAgdi5yZWJsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gdi5hY3RpdmVfdm90ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBsZW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnZvdGVyID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi51cHZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LnVwdm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB2LmRvd252b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRzY29wZS5kYXRhLnByb2ZpbGUucHVzaCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5ub25leGlzdCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJHNjb3BlLmRmZXRjaGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dpbmdcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgJHNjb3BlLnR0LmR1c2VyLCBcImJsb2dcIiwgJHNjb3BlLmxpbWl0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aD09PSRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgJHNjb3BlLnR0LmR1c2VyID0gcmVzW3Jlcy5sZW5ndGgtMV0uZm9sbG93aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuID0gcmVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAkc2NvcGUuZm9sbG93aW5nLnB1c2gocmVzW2ldLmZvbGxvd2luZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMubGVuZ3RoPCRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoJHNjb3BlLmRmZXRjaGluZywgNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgJHNjb3BlLnJmZXRjaGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dlcnNcIiwgWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgJHNjb3BlLnR0LnJ1c2VyLCBcImJsb2dcIiwgJHNjb3BlLmxpbWl0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aD09PSRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgJHNjb3BlLnR0LnJ1c2VyID0gcmVzW3Jlcy5sZW5ndGgtMV0uZm9sbG93ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW4gPSByZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICRzY29wZS5mb2xsb3dlci5wdXNoKHJlc1tpXS5mb2xsb3dlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMubGVuZ3RoPCRzY29wZS5saW1pdCkge1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoJHNjb3BlLnJmZXRjaGluZywgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgICRzY29wZS5nZXRGb2xsb3dzID0gZnVuY3Rpb24ocixkKSB7ICAgICAgXG4gICAgICBpZiAocikge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInJmZXRjaGluZ1wiKTtcbiAgICAgICAgJHNjb3BlLnJmZXRjaGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGQpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coXCJkZmV0Y2hpbmdcIik7XG4gICAgICAgICRzY29wZS5kZmV0Y2hpbmcoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRzY29wZS5nZXRPdGhlclVzZXJzRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5sb2coXCJnZXRPdGhlclVzZXJzRGF0YVwiKTtcbiAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfYWNjb3VudHNcIiwgW1skc3RhdGVQYXJhbXMudXNlcm5hbWVdXSkudGhlbihmdW5jdGlvbihkZCl7XG4gICAgICAgICAgZGQgPSBkZFswXTtcbiAgICAgICAgICBpZiAoZGQgJiYgZGQuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgZGQuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oZGQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFuZ3VsYXIubWVyZ2UoJHNjb3BlLnVzZXIsIGRkKTtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKCRzY29wZS51c2VyKSk7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpO1xuXG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgJHNjb3BlLmNzcyA9ICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgPT09ICRzY29wZS51c2VyLnVzZXJuYW1lICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpID8geydiYWNrZ3JvdW5kJzogJ3VybCgnKyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gJHNjb3BlLnVzZXIudXNlcm5hbWUgJiYgKCRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEgJiYgJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKSkgPyB7J2JhY2tncm91bmQnOiAndXJsKCcrJHNjb3BlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmNvdmVyX2ltYWdlKycpJywgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcicsICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzonZml4ZWQnfSA6IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzY29wZS5jc3MgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuQXBpLmZvbGxvd19hcGkoKS5leGVjKFwiZ2V0X2ZvbGxvd19jb3VudFwiLCBbJHN0YXRlUGFyYW1zLnVzZXJuYW1lXSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgICAkc2NvcGUuZm9sbG93ZGV0YWlscyA9IHJlcztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICRzY29wZS5nZXRGb2xsb3dzKG51bGwsIFwiZFwiKTtcbiAgICAgIGlmKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHNjb3BlLnJlZnJlc2goKTtcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSAkc3RhdGVQYXJhbXMudXNlcm5hbWUpIHtcbiAgICAgICAgJHNjb3BlLmdldE90aGVyVXNlcnNEYXRhKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKFwiZ2V0IGZvbGxvd3MgY291bnRzXCIpO1xuICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgd2luZG93LkFwaS5mb2xsb3dfYXBpKCkuZXhlYyhcImdldF9mb2xsb3dfY291bnRcIiwgWyRzdGF0ZVBhcmFtcy51c2VybmFtZV0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgICAgICAkc2NvcGUuZm9sbG93ZGV0YWlscyA9IHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJHN0YXRlUGFyYW1zLnVzZXJuYW1lKSB7XG4gICAgICAgICRzY29wZS5nZXRPdGhlclVzZXJzRGF0YSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5jc3MgPSAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyJiYgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lID09PSAkc2NvcGUudXNlci51c2VybmFtZSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YSAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpID8geydiYWNrZ3JvdW5kJzogJ3VybCgnKyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09ICRzY29wZS51c2VyLnVzZXJuYW1lICYmICgkc2NvcGUudXNlci5qc29uX21ldGFkYXRhICYmICRzY29wZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UpKSA/IHsnYmFja2dyb3VuZCc6ICd1cmwoJyskc2NvcGUudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UrJyknLCAnYmFja2dyb3VuZC1zaXplJzogJ2NvdmVyJywgJ2JhY2tncm91bmQtcG9zaXRpb24nOidmaXhlZCd9IDogbnVsbDtcbiAgICAgIC8vY29uc29sZS5sb2coJHNjb3BlLmNzcyk7XG4gICAgLy99LCAxKTtcblxuICB9KTtcbiAgJHNjb3BlLm9wZW5NZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gIH1cbiAgJHNjb3BlLmNoYW5nZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgICRzY29wZS5kYXRhID0gdW5kZWZpbmVkO1xuICAgIGNvbnNvbGUubG9nKHR5cGUpO1xuICAgICRzY29wZS5kYXRhID0ge3Byb2ZpbGU6IFtdfTtcbiAgICAkc2NvcGUuYWNjb3VudHMgPSBbXTtcbiAgICAkc2NvcGUuYWN0aXZlID0gdHlwZTtcbiAgICAkc2NvcGUuZW5kID0gZmFsc2U7XG4gICAgXG4gICAgaWYoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPSBcImJsb2dcIikge1xuICAgICAgJHNjb3BlLnJlc3QgPSBcIi9cIit0eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUucmVzdCA9IFwiXCI7XG4gICAgfVxuICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X3N0YXRlXCIsIFtcIi9AXCIrJHN0YXRlUGFyYW1zLnVzZXJuYW1lKyRzY29wZS5yZXN0XSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgIGlmIChyZXMuY29udGVudCkge1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXMuY29udGVudCkubGVuZ3RoPjApIHtcbiAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChyZXMuY29udGVudCwgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gdi5qc29uX21ldGFkYXRhP2FuZ3VsYXIuZnJvbUpzb24odi5qc29uX21ldGFkYXRhKTp2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpe1xuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT09IHYuYXV0aG9yKSB7XG4gICAgICAgICAgICAgICAgICB2LnJlYmxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2LmFjdGl2ZV92b3Rlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGxlbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbal0udm90ZXIgPT09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2LnVwdm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYuYWN0aXZlX3ZvdGVzW2pdLnBlcmNlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdi5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHYudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIHYuZG93bnZvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHNjb3BlLmRhdGEucHJvZmlsZS5wdXNoKHYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkc2NvcGUubm9uZXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGU9PT1cInRyYW5zZmVyc1wiIHx8IHR5cGU9PT1cInBlcm1pc3Npb25zXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiByZXMuYWNjb3VudHMpIHtcbiAgICAgICAgICAgIGlmIChyZXMuYWNjb3VudHMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICRzY29wZS5hY2NvdW50cyA9IHJlcy5hY2NvdW50c1twcm9wZXJ0eV07XG4gICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzLmFjY291bnRzW3Byb3BlcnR5XS50cmFuc2Zlcl9oaXN0b3J5KSk7XG5cbiAgICAgICAgICAgICAgJHNjb3BlLnRyYW5zZmVycyA9IHJlcy5hY2NvdW50c1twcm9wZXJ0eV0udHJhbnNmZXJfaGlzdG9yeTtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygkc2NvcGUudHJhbnNmZXJzKTtcbiAgICAgICAgICAgICAgJHNjb3BlLm5vbmV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59KVxuXG5hcHAuY29udHJvbGxlcignRXhjaGFuZ2VDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkc3RhdGVQYXJhbXMsICRyb290U2NvcGUpIHtcbiAgJHNjb3BlLnVzZXJuYW1lID0gJHN0YXRlUGFyYW1zLnVzZXJuYW1lO1xuXG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRzY29wZS5hY3RpdmUgPSAnYnV5JztcbiAgICAkc2NvcGUub3JkZXJzID0gW107XG4gICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfb3JkZXJfYm9va1wiLCBbMTVdKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRzY29wZS5vcmRlcnMgPSByZXM7XG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgICRzY29wZS5jaGFuZ2UgPSBmdW5jdGlvbih0eXBlKXtcbiAgICAgICRzY29wZS5hY3RpdmUgPSB0eXBlO1xuICAgICAgaWYgKHR5cGUgPT0gXCJvcGVuXCIpe1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfb3Blbl9vcmRlcnNcIiwgWyRzdGF0ZVBhcmFtcy51c2VybmFtZV0pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICRzY29wZS5vcGVub3JkZXJzID0gcmVzO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gXCJoaXN0b3J5XCIpe1xuICAgICAgICAkc2NvcGUuaGlzdG9yeSA9IFtdO1xuICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICB3aW5kb3cuQXBpLm1hcmtldF9oaXN0b3J5X2FwaSgpLmV4ZWMoXCJnZXRfcmVjZW50X3RyYWRlc1wiLCBbMTVdKS50aGVuKGZ1bmN0aW9uKHIpe1xuICAgICAgICAgICAgJHNjb3BlLnJlY2VudF90cmFkZXMgPSByO1xuICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG59KTtcbmFwcC5jb250cm9sbGVyKCdNYXJrZXRDdHJsJywgZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCAkZmlsdGVyLCAkdHJhbnNsYXRlLCAkaW9uaWNQbGF0Zm9ybSwgJHdpbmRvdykge1xuXG4gICRzY29wZS5yZXF1ZXN0QXBwID0gZnVuY3Rpb24obmFtZSkge1xuICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG5hbWUgPT0gJ05ldycpIHtcbiAgICAgICAgd2luZG93Lm9wZW4oXCJtYWlsdG86aW5mb0Blc3RlZW0ud3M/c3ViamVjdD1TdWdnZXN0aW5nJTIwTmV3JTIwQXBwJTIwZm9yJTIwTWFya2V0JTIwUGxhY2UmYm9keT1IZWxsbyElMEQlMEElMEQlMEFBcHBOYW1lOiUwRCUwQUFwcEF1dGhvcjolMEQlMEFBcHBMaW5rOiUwRCUwQSUwRCUwQVwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICB9XG4gICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSB8fCBpb25pYy5QbGF0Zm9ybS5pc0lQYWQoKSkge1xuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1Nb25pdG9yJykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdpZDExNTg5MTg2OTAnKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihcIml0bXMtYXBwczovL2l0dW5lcy5hcHBsZS5jb20vYXBwL2lkMTE1ODkxODY5MFwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gJ1N0ZWVtRmVzdCcpIHtcbiAgICAgICAgICAvL2NvcmRvdmEucGx1Z2lucy5tYXJrZXQub3BlbignaWQxMTcxMzcxNzA4Jyk7XG4gICAgICAgICAgd2luZG93Lm9wZW4oXCJpdG1zLWFwcHM6Ly9pdHVuZXMuYXBwbGUuY29tL2FwcC9pZDExNzEzNzE3MDhcIiwgXCJfc3lzdGVtXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1Nb25pdG9yJykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdjb20ubmV0c29sdXRpb25zLmVzdGVlbXdpdG5lc3MnKTtcbiAgICAgICAgICB3aW5kb3cub3BlbihcIm1hcmtldDovL2RldGFpbHM/aWQ9Y29tLm5ldHNvbHV0aW9ucy5lc3RlZW13aXRuZXNzXCIsIFwiX3N5c3RlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSAnU3RlZW1GZXN0Jykge1xuICAgICAgICAgIC8vY29yZG92YS5wbHVnaW5zLm1hcmtldC5vcGVuKCdjb20ubmV0c29sdXRpb25zLnN0ZWVtZmVzdCcpO1xuICAgICAgICAgIHdpbmRvdy5vcGVuKFwibWFya2V0Oi8vZGV0YWlscz9pZD1jb20ubmV0c29sdXRpb25zLnN0ZWVtZmVzdFwiLCBcIl9zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KTtcblxuYXBwLmNvbnRyb2xsZXIoJ1NldHRpbmdzQ3RybCcsIGZ1bmN0aW9uKCRzY29wZSwgJHN0YXRlUGFyYW1zLCAkcm9vdFNjb3BlLCAkaW9uaWNIaXN0b3J5LCAkc3RhdGUsICRpb25pY1BvcG92ZXIsICRpb25pY1BvcHVwLCBBUElzLCAkZmlsdGVyLCAkdHJhbnNsYXRlLCAkd2luZG93LCAkaW9uaWNTaWRlTWVudURlbGVnYXRlKSB7XG5cbiAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHNjb3BlXG4gICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICRzY29wZS50b29sdGlwID0gcG9wb3ZlcjtcbiAgIH0pO1xuICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPT0gJ3N0ZWVtJyl7XG4gICAgJHNjb3BlLm9wdGlvbnMgPSBbJ3dzczovL3N0ZWVtZC5zdGVlbWl0LmNvbScsICd3c3M6Ly9ub2RlLnN0ZWVtLndzJ107IFxuICAgfSBlbHNlIHtcbiAgICAkc2NvcGUub3B0aW9ucyA9IFsnd3NzOi8vd3MuZ29sb3MuaW8nLCAnd3NzOi8vbm9kZS5nb2xvcy53cyddO1xuICAgfVxuICAgXG5cbiAgICRzY29wZS5vcGVuVG9vbHRpcCA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgICAgdmFyIHRleHRoID0gZDtcbiAgICAgICRzY29wZS50b29sdGlwVGV4dCA9IHRleHRoO1xuICAgICAgJHNjb3BlLnRvb2x0aXAuc2hvdygkZXZlbnQpO1xuICAgfTtcblxuICBmdW5jdGlvbiBnZXREYXRlKHh4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHYgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXNbaV07XG4gICAgICBpZiAodi5pZCA9PSB4eCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hPYmoobmFtZUtleSwgbXlBcnJheSkge1xuICAgIGZvciAodmFyIGk9MDsgaSA8IG15QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG15QXJyYXlbaV0uaWQgPT09IG5hbWVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBteUFycmF5W2ldO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgJHNjb3BlLmNoYW5nZUN1cnJlbmN5ID0gZnVuY3Rpb24oeHgsIGlnbm9yZSkge1xuICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZEN1cnJlbmN5Jywge2N1cnJlbmN5OiB4eCwgZW5mb3JjZTogaWdub3JlfSk7XG4gIH1cbiAgJHNjb3BlLmNoYW5nZUNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnJlc3RhcnQgPSB0cnVlO1xuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdzdGVlbScpe1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybW5hbWUgPSBcIlN0ZWVtXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcIlN0ZWVtIFBvd2VyXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3Jtc3VuaXQgPSBcIlN0ZWVtXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyID0gXCJTdGVlbSBEb2xsYXJcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCA9IFwiU0JEXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcHVuaXQgPSBcIlNQXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbHVuaXQgPSBcIlNURUVNXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldHN0ZWVtID0gXCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIjtcbiAgICAgICRzY29wZS5zb2NrZXQgPSBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwi0JPQntCb0J7QoVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyID0gXCLQodCY0JvQkCDQk9Ce0JvQntCh0JBcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwi0JPQvtC70L7RgVwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhciA9IFwi0JfQntCb0J7QotCe0JlcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdCA9IFwiR0JHXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcHVuaXQgPSBcIkdPTE9TUFwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0ID0gXCJHT0xPU1wiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRnb2xvcyA9IFwid3NzOi8vd3MuZ29sb3MuaW8vXCI7XG4gICAgICAvLyRzY29wZS5zb2NrZXQgPSBcIndzczovL2dvbG9zLnN0ZWVtLndzXCI7XG4gICAgICAkc2NvcGUuc29ja2V0ID0gXCJ3c3M6Ly93cy5nb2xvcy5pby9cIjtcbiAgICB9XG4gICAgd2luZG93LmVqcy5DaGFpbkNvbmZpZy5zZXRDaGFpbklkKGxvY2FsU3RvcmFnZVskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluK1wiSWRcIl0pO1xuXG4gICAgJHNjb3BlLmNoYW5nZUN1cnJlbmN5KCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3ksIHRydWUpO1xuICB9XG4gICRzY29wZS5yZXN0YXJ0ID0gZmFsc2U7XG4gICRzY29wZS5jbG9zZVRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAkc2NvcGUudG9vbHRpcC5oaWRlKCk7XG4gIH07XG5cbiAgLy9DbGVhbnVwIHRoZSBwb3BvdmVyIHdoZW4gd2UncmUgZG9uZSB3aXRoIGl0IVxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICRzY29wZS50b29sdGlwLnJlbW92ZSgpO1xuICB9KTtcblxuICAkc2NvcGUuY2hhbmdlTGFuZ3VhZ2UgPSBmdW5jdGlvbihsb2NhbGUpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobG9jYWxlID09ICdhci1TQScgfHwgbG9jYWxlID09ICdoZS1JTCcgfHwgbG9jYWxlID09ICdmYS1JUicpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kaXIgPSAncnRsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGlyID0gJ2x0cic7XG4gICAgICB9XG4gICAgICAkdHJhbnNsYXRlLnVzZShsb2NhbGUpO1xuICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0sIDEpO1xuICB9XG4gICRzY29wZS5kcmFnID0gZnVuY3Rpb24odikge1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCA9IHYqMTAwO1xuICB9XG4gICRzY29wZS4kb24oJyRpb25pY1ZpZXcuYmVmb3JlRW50ZXInLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXSA9IGxvY2FsU3RvcmFnZS5zb2NrZXRVcmw7XG4gICAgJHNjb3BlLmRhdGEgPSB7fTtcbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uudm90ZVdlaWdodCl7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSAxMDAwMDtcbiAgICAgICRzY29wZS52dmFsdWUgPSAxMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS52dmFsdWUgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQvMTAwO1xuICAgIH1cbiAgICBpZighJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAkc2NvcGUuZGF0YSA9IHtwaW46IHRydWV9O1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NvcGUuZGF0YSA9IHtwaW46IGZhbHNlfTtcbiAgICB9XG5cbiAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyICYmICRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQpIHtcbiAgICAgIEFQSXMuZ2V0U3Vic2NyaXB0aW9ucygkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcy5kYXRhKSk7XG4gICAgICAgIHZhciBkID0gcmVzLmRhdGE7XG4gICAgICAgIC8vYW5ndWxhci5mb3JFYWNoKGQsIGZ1bmN0aW9uKHYsayl7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHYgPSBkW2ldO1xuICAgICAgICAgIGlmICh2LnVzZXJuYW1lID09ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSkge1xuICAgICAgICAgICAgYW5ndWxhci5tZXJnZSgkc2NvcGUuZGF0YSwge3ZvdGU6IHYuc3Vic2NyaXB0aW9uLnZvdGUsIGZvbGxvdzogdi5zdWJzY3JpcHRpb24uZm9sbG93LCBjb21tZW50OiB2LnN1YnNjcmlwdGlvbi5jb21tZW50LCBtZW50aW9uOiB2LnN1YnNjcmlwdGlvbi5tZW50aW9uLCByZXN0ZWVtOiB2LnN1YnNjcmlwdGlvbi5yZXN0ZWVtfSk7ICAgIFxuICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUubm90aWZpY2F0aW9uQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zdWJzY3JpcHRpb24gPSB7XG4gICAgICB2b3RlOiAkc2NvcGUuZGF0YS52b3RlLFxuICAgICAgY29tbWVudDogJHNjb3BlLmRhdGEuY29tbWVudCxcbiAgICAgIGZvbGxvdzogJHNjb3BlLmRhdGEuZm9sbG93LFxuICAgICAgbWVudGlvbjogJHNjb3BlLmRhdGEubWVudGlvbixcbiAgICAgIHJlc3RlZW06ICRzY29wZS5kYXRhLnJlc3RlZW0sXG4gICAgICBkZXZpY2U6IGlvbmljLlBsYXRmb3JtLnBsYXRmb3JtKCksXG4gICAgICB0aW1lc3RhbXA6ICRmaWx0ZXIoJ2RhdGUnKShuZXcgRGF0ZSgpLCAnbWVkaXVtJyksXG4gICAgICBhcHB2ZXJzaW9uOiAnMS4zLjknXG4gICAgfVxuICAgIEFQSXMudXBkYXRlU3Vic2NyaXB0aW9uKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQsICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgJHJvb3RTY29wZS4kc3RvcmFnZS5zdWJzY3JpcHRpb24pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgIGNvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcykpO1xuICAgIH0pO1xuXG4gIH1cblxuICAkc2NvcGUucGluQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgJHJvb3RTY29wZS5sb2coXCJwaW5DaGFuZ2VcIik7XG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwicGluOmNoZWNrXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46bmV3XCIpO1xuICAgIH1cbiAgfVxuXG4gICRyb290U2NvcGUuJG9uKFwicGluOmNvcnJlY3RcIiwgZnVuY3Rpb24oKXtcbiAgICAkcm9vdFNjb3BlLmxvZyhcInBpbjpjb3JyZWN0IFwiICsgJHNjb3BlLmRhdGEucGluKTtcbiAgICBpZiAoISRzY29wZS5kYXRhLnBpbikge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcbiAgICAgICRzY29wZS5kYXRhLnBpbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY29wZS5kYXRhLnBpbiA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICB9XG4gIH0pO1xuXG4gICRyb290U2NvcGUuJG9uKFwicGluOmZhaWxlZFwiLCBmdW5jdGlvbigpe1xuICAgICRyb290U2NvcGUubG9nKFwicGluOmZhaWxlZFwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgICAkc2NvcGUuZGF0YS5waW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHNjb3BlLmRhdGEucGluID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoISRzY29wZS4kJHBoYXNlKXtcbiAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0sIDEwKTtcblxuICB9KTtcbiAgJHNjb3BlLmxvZ291dHMgPSBmdW5jdGlvbigpIHtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyID0gbnVsbDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm15bG9naW4gPSB1bmRlZmluZWQ7XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5teWxvZ2luID0gbnVsbDtcbiAgICAvL21ha2Ugc3VyZSB1c2VyIGNyZWRlbnRpYWxzIGNsZWFyZWQuXG4gICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQpIHtcbiAgICAgIEFQSXMuZGVsZXRlU3Vic2NyaXB0aW9uKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQpLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgJGlvbmljU2lkZU1lbnVEZWxlZ2F0ZS50b2dnbGVMZWZ0KCk7XG4gICAgICAgIC8vJHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyx7cmVuZXc6dHJ1ZX0se3JlbG9hZDogdHJ1ZX0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRpb25pY1NpZGVNZW51RGVsZWdhdGUudG9nZ2xlTGVmdCgpO1xuICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyx7cmVuZXc6dHJ1ZX0se3JlbG9hZDogdHJ1ZX0pO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9IHVuZGVmaW5lZDtcbiAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnRhZyA9IHVuZGVmaW5lZDtcblxuICAgICRpb25pY0hpc3RvcnkuY2xlYXJDYWNoZSgpO1xuICAgICRpb25pY0hpc3RvcnkuY2xlYXJIaXN0b3J5KCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlvbmljLlBsYXRmb3JtLmV4aXRBcHAoKTsgLy8gc3RvcHMgdGhlIGFwcFxuICAgIH0sIDEwMCk7XG4gIH07XG4gICRzY29wZS5zb2NrZXQgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl07XG4gICRzY29wZS5zb2NrZXRDaGFuZ2UgPSBmdW5jdGlvbih4eCl7XG4gICAgY29uc29sZS5sb2coeHgpO1xuICAgICRyb290U2NvcGUuJHN0b3JhZ2VbXCJzb2NrZXRcIiskcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluXSA9IHh4O1xuICAgIGxvY2FsU3RvcmFnZS5zb2NrZXRVcmwgPSB4eDtcbiAgICAkc2NvcGUucmVzdGFydCA9IHRydWU7XG4gIH1cbiAgJHNjb3BlLnNhdmUgPSBmdW5jdGlvbigpe1xuICAgIGlmICgkc2NvcGUucmVzdGFydCkge1xuICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ1VQREFURV9SRVFVSVJFU19SRVNUQVJUJylcbiAgICAgIH0pO1xuICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIGlmKHJlcykge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsID0gJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dO1xuICAgICAgICAgIC8vJHNjb3BlLmxvZ291dHMoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luZG93LkFwaS5jbG9zZSgpO1xuICAgICAgICAgICAgd2luZG93LkFwaSA9IG51bGw7XG4gICAgICAgICAgICB3aW5kb3cuc3RlZW1SUEMuQ2xpZW50LmNsb3NlKCk7XG4gICAgICAgICAgICB2YXIgc29ja2V0VXJsID0gJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dO1xuICAgICAgICAgICAgd2luZG93LkFwaSA9IHdpbmRvdy5zdGVlbVJQQy5DbGllbnQuZ2V0KHt1cmw6c29ja2V0VXJsfSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmNoYWluICE9ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHYuY2hhaW4gPT0gJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbil7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIgPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICRzdGF0ZS5nbygnYXBwLnBvc3RzJyx7cmVuZXc6dHJ1ZX0se3JlbG9hZDogdHJ1ZX0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBub3Qgc3VyZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUVElOR1NfVVBEQVRFRCcpKTtcbiAgICAgICRpb25pY0hpc3RvcnkubmV4dFZpZXdPcHRpb25zKHtcbiAgICAgICAgZGlzYWJsZUJhY2s6IHRydWVcbiAgICAgIH0pO1xuICAgICAgLy8kd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTsgIFxuICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdHMnLHtyZW5ldzp0cnVlfSx7cmVsb2FkOiB0cnVlfSk7XG4gICAgfVxuICB9O1xuXG59KTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJwQkd2QXBcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9wb3N0cy9jb250cm9sbGVycy5qc1wiLFwiL3Bvc3RzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXG5cbnZhciBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnc3RlZW0nLCBbXG5cdCdpb25pYycsXG5cdCduZ1N0b3JhZ2UnLFxuXHQnbmdDb3Jkb3ZhJyxcbiAgJ2lvbi1mbG9hdGluZy1tZW51JyxcbiAgJ3Bhc2NhbHByZWNodC50cmFuc2xhdGUnLFxuICAnamEucXInLFxuICAnaW9uLWRhdGV0aW1lLXBpY2tlcidcbl0pO1xuXG5pZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJzb2NrZXRVcmxcIikgPT09IG51bGwpIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzb2NrZXRVcmxcIiwgXCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIik7XG59IGVsc2UgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic29ja2V0VXJsXCIpID09IFwid3NzOi8vc3RlZW1pdC5jb20vd3NwYVwiKSB7XG4gIGxvY2FsU3RvcmFnZS5zb2NrZXRVcmw9XCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIjtcbn1cblxubG9jYWxTdG9yYWdlLmdvbG9zSWQgPSBcIjc4MmEzMDM5YjQ3OGM4MzllNGNiMGM5NDFmZjRlYWViN2RmNDBiZGQ2OGJkNDQxYWZkNDQ0YjlkYTc2M2RlMTJcIjtcbmxvY2FsU3RvcmFnZS5zdGVlbUlkID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cbndpbmRvdy5zdGVlbVJQQyA9IHJlcXVpcmUoXCJzdGVlbS1ycGNcIik7XG53aW5kb3cuQXBpID0gd2luZG93LnN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDpsb2NhbFN0b3JhZ2Uuc29ja2V0VXJsfSwgdHJ1ZSk7XG4vL3dpbmRvdy5zdGVlbUpTID0gcmVxdWlyZShcInN0ZWVtanMtbGliXCIpO1xuXG53aW5kb3cuZWpzID0gcmVxdWlyZShcImVzdGVlbS1saWJcIik7XG5cbi8vd2luZG93LmdvbG9zSlMgPSByZXF1aXJlKFwiZ29sb3Nqcy1saWJcIik7XG53aW5kb3cuZGlmZl9tYXRjaF9wYXRjaCA9IHJlcXVpcmUoJ2RpZmYtbWF0Y2gtcGF0Y2gnKTtcbndpbmRvdy5nZXRTeW1ib2wgPSByZXF1aXJlKCdjdXJyZW5jeS1zeW1ib2wtbWFwJyk7XG5cbnJlcXVpcmUoJy4vY29uZmlnJykoYXBwKTtcbnJlcXVpcmUoJy4vc2VydmljZXMnKShhcHApO1xucmVxdWlyZSgnLi9jb250cm9sbGVycycpKGFwcCk7XG5cblxuYXBwLmNvbmZpZyhmdW5jdGlvbigkc3RhdGVQcm92aWRlciwgJHVybFJvdXRlclByb3ZpZGVyLCAkaW9uaWNDb25maWdQcm92aWRlciwgJHNjZURlbGVnYXRlUHJvdmlkZXIsICRsb2dQcm92aWRlciwgJGNvbXBpbGVQcm92aWRlciwgJGFuaW1hdGVQcm92aWRlciwgJHRyYW5zbGF0ZVByb3ZpZGVyKSB7XG4gICRzdGF0ZVByb3ZpZGVyXG5cbiAgLnN0YXRlKCdhcHAnLCB7XG4gICAgdXJsOiAnL2FwcCcsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgdGVtcGxhdGU6IFwiPGlvbi1zaWRlLW1lbnVzIGVuYWJsZS1tZW51LXdpdGgtYmFjay12aWV3cz1cXFwidHJ1ZVxcXCIgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiPlxcbiAgPGlvbi1zaWRlLW1lbnUtY29udGVudCBkcmFnLWNvbnRlbnQ9XFxcImZhbHNlXFxcIj5cXG4gICAgPGlvbi1uYXYtYmFyIGNsYXNzPVxcXCJiYXItcG9zaXRpdmVcXFwiPlxcbiAgICAgIDxpb24tbmF2LWJhY2stYnV0dG9uPlxcbiAgICAgIDwvaW9uLW5hdi1iYWNrLWJ1dHRvbj5cXG4gICAgICA8aW9uLW5hdi1idXR0b25zIHNpZGU9XFxcImxlZnRcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tbmF2aWNvblxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPlxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9pb24tbmF2LWJ1dHRvbnM+XFxuICAgIDwvaW9uLW5hdi1iYXI+XFxuICAgIDxpb24tbmF2LXZpZXcgbmFtZT1cXFwibWVudUNvbnRlbnRcXFwiPjwvaW9uLW5hdi12aWV3PlxcbiAgPC9pb24tc2lkZS1tZW51LWNvbnRlbnQ+XFxuICA8aW9uLXNpZGUtbWVudSBzaWRlPVxcXCJsZWZ0XFxcIj5cXG4gICAgPCEtLTxpb24taGVhZGVyLWJhciBjbGFzcz1cXFwiYmFyLXBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgIDxoMSBjbGFzcz1cXFwidGl0bGUgY2VudGVyXFxcIj5lU3RlZW08L2gxPlxcbiAgICA8L2lvbi1oZWFkZXItYmFyPi0tPlxcbiAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgPGRpdiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAgPHA+XFxuICAgICAgICAgICAgPGltZyBuZy1zcmM9XFxcImltZy9lc3RlZW0ucG5nXFxcIiB3aWR0aD1cXFwiMTUwXFxcIiAvPlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIiBuZy1zdHlsZT1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUuY292ZXJfaW1hZ2UgPyBtY3NzIDogbnVsbFxcXCI+XFxuICAgICAgPGJyPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAgPGEgbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9wcm9maWxlL3t7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19XFxcIiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpdGVtLW15YXZhdGFyXFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS51c2VyX2ltYWdlICYmICEkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlXFxcIj48aW1nIHNyYz1cXFwiaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICA8aW1nIG5nLXNyYz1cXFwie3skcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlIHx8ICRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS51c2VyX2ltYWdlfX1cXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEudXNlcl9pbWFnZSB8fCAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5wcm9maWxlX2ltYWdlXFxcIiAvPlxcbiAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDxkaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaDRcXFwiPkB7eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fSZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7JHJvb3QuJHN0b3JhZ2UudXNlci5yZXB1dGF0aW9ufHJlcHV0YXRpb246dHJ1ZXxudW1iZXI6MX19PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBuZy1jbGljaz1cXFwic2hvd01lRXh0cmEoKVxcXCIgY2xhc3M9XFxcInBhZGRpbmdcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWxpc3RcXFwiPjwvaT4mbmJzcDt7eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdF9jb3VudH19Jm5ic3A7Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LWdyYXBoLXVwLXJpZ2h0XFxcIj48L2k+Jm5ic3A7e3skcm9vdC4kc3RvcmFnZS51c2VyLnZvdGluZ19wb3dlci8xMDB8bnVtYmVyOjJ9fSA8aSBjbGFzcz1cXFwiaWNvbiBwdWxsLXJpZ2h0XFxcIiBuZy1jbGFzcz1cXFwieydpb24tYXJyb3ctZG93bi1iJzohc2hvd0V4dHJhLCAnaW9uLWFycm93LXVwLWInOnNob3dFeHRyYX1cXFwiPjwvaT48L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IG5nLWlmPVxcXCJzaG93RXh0cmFcXFwiPlxcbiAgICAgICAgPGlvbi1saXN0PlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2Vyc1xcXCIgbmctcmVwZWF0PVxcXCJ1c2VyIGluICRyb290LiRzdG9yYWdlLnVzZXJzXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0QWNjb3VudCh1c2VyKVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzogKHVzZXIudXNlcm5hbWU9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUmJnVzZXIuY2hhaW49PSRyb290LiRzdG9yYWdlLnVzZXIuY2hhaW4pIH1cXFwiPlxcbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcImljb24gbG9nb3NcXFwiIG5nLXNyYz1cXFwie3snaW1nLycrdXNlci5jaGFpbisnX2ljb24ucG5nJ319XFxcIiAvPlxcbiAgICAgICAgICAgIHt7dXNlci51c2VybmFtZX19XFxuICAgICAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVxcXCJiYWRnZSBiYWRnZS1hc3NlcnRpdmVcXFwiPnt7dXNlci5jaGFpbn19PC9zcGFuPi0tPlxcbiAgICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBuZy1jbGljaz1cXFwib3BlbkxvZ2luKClcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1wbHVzLXJvdW5kXFxcIj48L2k+XFxuICAgICAgICAgICAge3snQUREX0FDQ09VTlQnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJvcGVuUG9zdE1vZGFsKClcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWNyZWF0ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgIHt7J1NVQk1JVF9BX1NUT1JZJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9wcm9maWxlL3t7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uXFxcIj48L2k+XFxuICAgICAgICAgICAge3snUFJPRklMRSd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvZm9sbG93XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tcGVyc29uLXN0YWxrZXJcXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydGT0xMT1cnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJsb2dvdXQoKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxvZy1vdXRcXFwiPjwvaT5cXG4gICAgICAgICAgICB7eydMT0dPVVQnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8L2lvbi1saXN0PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxpb24tbGlzdD5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIG5nLWNsaWNrPVxcXCJvcGVuTG9naW4oKVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tbG9nLWluXFxcIj48L2k+XFxuICAgICAgICAgIHt7J0xPR0lOJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL3Bvc3RzL1xcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWhvbWVcXFwiPjwvaT5cXG4gICAgICAgICAge3snSE9NRSd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9ib29rbWFya1xcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1ib29rbWFya1xcXCI+PC9pPlxcbiAgICAgICAgICB7eydCT09LTUFSS1MnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvZHJhZnRzXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWNvbXBvc2VcXFwiPjwvaT5cXG4gICAgICAgICAge3snRFJBRlRTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDwhLS08aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9ub3RpZmljYXRpb25zXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ub3RpZmljYXRpb25zICYmICRyb290LiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMubGVuZ3RoPjBcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYm9va21hcmtcXFwiPjwvaT5cXG4gICAgICAgICAge3snTk9USUZJQ0FUSU9OUyd8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+LS0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9zZW5kXFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtc2VuZFxcXCI+PC9pPlxcbiAgICAgICAgICB7eydUUkFOU0ZFUid8dHJhbnNsYXRlfX1cXG4gICAgICAgIDwvaW9uLWl0ZW0+XFxuICAgICAgICA8aW9uLWl0ZW0gbWVudS1jbG9zZSBocmVmPVxcXCIjL2FwcC9leGNoYW5nZS97eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fVxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1zd2FwXFxcIj48L2k+XFxuICAgICAgICAgIHt7J0VYQ0hBTkdFJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL21hcmtldFxcXCIgY2xhc3M9XFxcIml0ZW0taWNvbi1sZWZ0XFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWN1YmVcXFwiPjwvaT5cXG4gICAgICAgICAge3snTUFSS0VUUExBQ0UnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgICAgPGlvbi1pdGVtIG1lbnUtY2xvc2UgaHJlZj1cXFwiIy9hcHAvc2V0dGluZ3NcXFwiIGNsYXNzPVxcXCJpdGVtLWljb24tbGVmdFxcXCI+XFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXNldHRpbmdzXFxcIj48L2k+XFxuICAgICAgICAgIHt7J1NFVFRJTkdTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9pb24taXRlbT5cXG4gICAgICAgIDxpb24taXRlbSBtZW51LWNsb3NlIGhyZWY9XFxcIiMvYXBwL2Fib3V0XFxcIiBjbGFzcz1cXFwiaXRlbS1pY29uLWxlZnRcXFwiPlxcbiAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taW5mb3JtYXRpb25cXFwiPjwvaT5cXG4gICAgICAgICAge3snQUJPVVQnfHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2lvbi1pdGVtPlxcbiAgICAgIDwvaW9uLWxpc3Q+XFxuICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgIDwhLS0gYWxpZ24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSAtLT5cXG4gICAgPGRpdiBzdHlsZT1cXFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IDBweDsgd2lkdGg6IDEwMCVcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5hcHB2ZXJzaW9uXFxcIj5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjsgY29sb3I6I2NjYztcXFwiPlxcbiAgICAgICAgICA8cD57eyRyb290LiRzdG9yYWdlLmFwcHZlcnNpb259fTwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLXNpZGUtbWVudT5cXG48L2lvbi1zaWRlLW1lbnVzPlxcblwiLFxuICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbWVudS5odG1sJyxcbiAgICBjb250cm9sbGVyOiAnQXBwQ3RybCdcbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5zZXR0aW5ncycsIHtcbiAgICB1cmw6ICcvc2V0dGluZ3MnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydTRVRUSU5HUyd8dHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nIGhhcy1oZWFkZXIgc2V0dGluZ3NcXFwiPlxcbiAgICA8YnIvPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tZGl2aWRlclxcXCI+XFxuICAgICAge3snU0VDVVJJVFknfHRyYW5zbGF0ZX19XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlBJTl9URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiZuYnNwO3t7J1BJTl9DT0RFJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnBpblxcXCIgbmctY2hhbmdlPVxcXCJwaW5DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWRpdmlkZXJcXFwiPlxcbiAgICAgIHt7J05PVElGSUNBVElPTlMnfHRyYW5zbGF0ZX19XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlZPVEVfVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydWT1RFJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnZvdGVcXFwiIG5nLWNoYW5nZT1cXFwibm90aWZpY2F0aW9uQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICA8c3BhbiBjbGFzcz1cXFwic2xhYmVsXFxcIiBuZy1jbGljaz0nb3BlblRvb2x0aXAoJGV2ZW50LFxcXCJ7e1xcXCJDT01NRU5UX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snQ09NTUVOVCd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHB1bGwtcmlnaHQgdHJpZ2h0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwidG9nZ2xlIHRvZ2dsZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5jb21tZW50XFxcIiBuZy1jaGFuZ2U9XFxcIm5vdGlmaWNhdGlvbkNoYW5nZSgpXFxcIj5cXG4gICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmFja1xcXCI+XFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoYW5kbGVcXFwiPjwvZGl2PlxcbiAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCI+XFxuICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiRk9MTE9XX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snRk9MTE9XJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLmZvbGxvd1xcXCIgbmctY2hhbmdlPVxcXCJub3RpZmljYXRpb25DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIk1FTlRJT05TX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snTUVOVElPTlMnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBwdWxsLXJpZ2h0IHRyaWdodFxcXCI+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInRvZ2dsZSB0b2dnbGUtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmctbW9kZWw9XFxcImRhdGEubWVudGlvblxcXCIgbmctY2hhbmdlPVxcXCJub3RpZmljYXRpb25DaGFuZ2UoKVxcXCI+XFxuICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJhY2tcXFwiPlxcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaGFuZGxlXFxcIj48L2Rpdj5cXG4gICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlJFU1RFRU1fVEVYVFxcXCJ8dHJhbnNsYXRlfX1cXFwiKSc+PGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1pbmZvcm1hdGlvbi1vdXRsaW5lIGdyYXlcXFwiPjwvaT4mbmJzcDt7eydSRVNURUVNJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgcHVsbC1yaWdodCB0cmlnaHRcXFwiPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJ0b2dnbGUgdG9nZ2xlLXBvc2l0aXZlXFxcIj5cXG4gICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnJlc3RlZW1cXFwiIG5nLWNoYW5nZT1cXFwibm90aWZpY2F0aW9uQ2hhbmdlKClcXFwiPlxcbiAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWNrXFxcIj5cXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1kaXZpZGVyXFxcIj5cXG4gICAgICB7eydDT05GSUdVUkFUSU9OUyd8dHJhbnNsYXRlfX1cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIlZPVElOR19URVhUXFxcInx0cmFuc2xhdGV9fVxcXCIpJz48aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWluZm9ybWF0aW9uLW91dGxpbmUgZ3JheVxcXCI+PC9pPiZuYnNwO3t7J1ZPVElORyd8dHJhbnNsYXRlfX0gKCUpPC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzID0gXFxcIml0ZW0gcmFuZ2UgcmFuZ2UtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgICAge3t2dmFsdWV9fSA8aW5wdXQgdHlwZT1cXFwicmFuZ2VcXFwiIG5hbWU9XFxcInJhbmdlMVxcXCIgbWluPVxcXCIxXFxcIiBtYXg9XFxcIjEwMFxcXCIgbmctbW9kZWw9XFxcInZ2YWx1ZVxcXCIgbmctY2hhbmdlPVxcXCJkcmFnKHZ2YWx1ZSlcXFwiPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwie3tcXFwiTEFOR1VBR0VTX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snTEFOR1VBR0VTJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiJHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2VcXFwiIG5nLWNoYW5nZT0nY2hhbmdlTGFuZ3VhZ2UoJHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2UpJz5cXG4gICAgICAgICAgPG9wdGlvbiBuZy1yZXBlYXQ9XFxcIm9wdGlvbiBpbiAkcm9vdC4kc3RvcmFnZS5sYW5ndWFnZXNcXFwiIHZhbHVlPVxcXCJ7e29wdGlvbi5pZH19XFxcIj57e29wdGlvbi5uYW1lfX08L29wdGlvbj5cXG4gICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgPCEtLTxkaXYgY2xhc3M9XFxcImNhcGl0YWxcXFwiPnt7JHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2V9fSA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvZGl2PjwvZGl2Pi0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkNVUlJFTkNZX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snQ1VSUkVOQ1knfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCIkcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVxcXCIgbmctY2hhbmdlPSdjaGFuZ2VDdXJyZW5jeSgkcm9vdC4kc3RvcmFnZS5jdXJyZW5jeSknPlxcbiAgICAgICAgICA8b3B0aW9uIG5nLXJlcGVhdD1cXFwib3B0aW9uIGluICRyb290LiRzdG9yYWdlLmN1cnJlbmNpZXNcXFwiIHZhbHVlPVxcXCJ7e29wdGlvbi5pZH19XFxcIj57e29wdGlvbi5uYW1lfX08L29wdGlvbj5cXG4gICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgPCEtLTxkaXYgY2xhc3M9XFxcImNhcGl0YWxcXFwiPnt7JHJvb3QuJHN0b3JhZ2UubGFuZ3VhZ2V9fSA8ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjwvZGl2PjwvZGl2Pi0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJzbGFiZWxcXFwiIG5nLWNsaWNrPSdvcGVuVG9vbHRpcCgkZXZlbnQsXFxcInt7XFxcIkNIQUlOX1RFWFRcXFwifHRyYW5zbGF0ZX19XFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snQ0hBSU4nfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8c2VsZWN0IG5nLW1vZGVsPVxcXCIkcm9vdC4kc3RvcmFnZS5jaGFpblxcXCIgbmctY2hhbmdlPSdjaGFuZ2VDaGFpbigkcm9vdC4kc3RvcmFnZS5jaGFpbiknPlxcbiAgICAgICAgICA8b3B0aW9uIG5nLXJlcGVhdD1cXFwib3B0aW9uIGluICRyb290LiRzdG9yYWdlLmNoYWluc1xcXCIgdmFsdWU9XFxcInt7b3B0aW9uLmlkfX1cXFwiPnt7b3B0aW9uLm5hbWV9fTwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICA8IS0tPGRpdiBjbGFzcz1cXFwiY2FwaXRhbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5sYW5ndWFnZX19IDxkaXYgY2xhc3M9XFxcInB1bGwtcmlnaHRcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PC9kaXY+PC9kaXY+LS0+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNsYWJlbFxcXCIgbmctY2xpY2s9J29wZW5Ub29sdGlwKCRldmVudCxcXFwiPHNwYW4gY2xhc3M9XFxcXFxcXCJib2xkXFxcXFxcXCI+e3tcXFwiU0VSVkVSX1RFWFRcXFwifHRyYW5zbGF0ZX19Ojwvc3Bhbj48YnI+PHNwYW4gY2xhc3M9XFxcXFxcXCJ3cmFwXFxcXFxcXCI+W3N0ZWVtaXRdIHdzczovL3N0ZWVtZC5zdGVlbWl0LmNvbTwvc3Bhbj48YnIvPjxici8+PHNwYW4gY2xhc3M9XFxcXFxcXCJ3cmFwXFxcXFxcXCI+W3N0ZWVtLndzXSB3c3M6Ly9ub2RlLnN0ZWVtLndzPC9zcGFuPjxici8+PGJyLz48c3BhbiBjbGFzcz1cXFxcXFxcIndyYXBcXFxcXFxcIj5bcGlzdG9uXSB3c3M6Ly90aGlzLnBpc3Rvbi5yb2Nrczwvc3Bhbj48YnIvPjxici8+PHNwYW4gY2xhc3M9XFxcXFxcXCJ3cmFwXFxcXFxcXCI+W2dvbG9zXSB3c3M6Ly93cy5nb2xvcy5pbzwvc3Bhbj48YnIvPjxici8+PHNwYW4gY2xhc3M9XFxcXFxcXCJ3cmFwXFxcXFxcXCI+W2dvbG9zLndzXSB3c3M6Ly9ub2RlLmdvbG9zLndzPC9zcGFuPlxcbiAgICAgICAgXFxcIiknPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtaW5mb3JtYXRpb24tb3V0bGluZSBncmF5XFxcIj48L2k+Jm5ic3A7e3snU0VSVkVSJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPCEtLTxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VydmVyXFxcIiBuZy1tb2RlbD1cXFwic29ja2V0XFxcIiBzdHlsZT1cXFwid2lkdGg6MTAwJTtcXFwiIG5nLWNoYW5nZT1cXFwic29ja2V0Q2hhbmdlKHNvY2tldClcXFwiPi0tPlxcbiAgICAgICAgPHNlbGVjdC1pbnB1dCBuZy1tb2RlbD1cXFwic29ja2V0XFxcIiBzZWxlY3Qtb3B0aW9ucz1cXFwib3B0aW9uc1xcXCIgPjwvc2VsZWN0LWlucHV0PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPCEtLTxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctY2xpY2s9XFxcImNoYW5nZUxhbmd1YWdlKCdydScpXFxcIj5DaGFuZ2UgUlU8L2J1dHRvbj4tLT5cXG4gICAgPGJyLz5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3PlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1iaW5kLWh0bWw9XFxcInRvb2x0aXBUZXh0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgXFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGNlbnRlclxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZVxcXCIgbmctY2xpY2s9XFxcInNhdmUoKVxcXCI+e3snU0FWRV9DSEFOR0VTJ3x0cmFuc2xhdGV9fTwvYnV0dG9uPlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1NldHRpbmdzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAuYWJvdXQnLCB7XG4gICAgdXJsOiAnL2Fib3V0JyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3NldHRpbmdzLmh0bWwnXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCIgdmlldy10aXRsZT1cXFwie3snQUJPVVQnIHwgdHJhbnNsYXRlfX0gLSB2e3skcm9vdC4kc3RvcmFnZS5hcHB2ZXJzaW9ufX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj5cXG4gICAgPGNlbnRlcj48aW1nIHNyYz1cXFwiaW1nL2Fib3V0LnBuZ1xcXCI+PC9jZW50ZXI+XFxuICAgIDxwPjxiPmVTdGVlbTwvYj4ge3snQUJPVVRfMid8dHJhbnNsYXRlfX0gPGRpdiBuZy1iaW5kLWh0bWw9XFxcIidBQk9VVF8xMSd8dHJhbnNsYXRlXFxcIj48L2Rpdj5cXG4gICAgPC9wPlxcbiAgICA8cCBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+e3tcXFwiRk9VTkRFUlxcXCJ8dHJhbnNsYXRlfX0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2dvb2Qta2FybWFcXFwiPmdvb2Qta2FybWE8L2E+PC9wPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ0Y2VudGVyXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlclxcXCI+PHNwYW4gbmctaWY9XFxcIiEkcm9vdC5pc1dpdG5lc3NWb3RlZCgpXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwiJHJvb3Qudm90ZVdpdG5lc3MoKVxcXCI+e3snQUJPVVRfOCd8dHJhbnNsYXRlfX08L2J1dHRvbj48L3NwYW4+PC9kaXY+XFxuICAgIDxwPlxcbiAgICA8Yj48dT57eydBQk9VVF85J3x0cmFuc2xhdGV9fTwvdT48L2I+XFxuICAgIDxicj48YSBocmVmPVxcXCJtYWlsdG86aW5mb0Blc3RlZW0ud3M/U3ViamVjdD1GZWVkYmFja1xcXCI+aW5mb0Blc3RlZW0ud3M8L2E+XFxuICAgIDxicj48YSBocmVmPVxcXCJodHRwOi8vZXN0ZWVtLndzXFxcIj5odHRwOi8vZXN0ZWVtLndzPC9hPlxcbiAgICA8L3A+XFxuICAgIDxwPlxcbiAgICAgICAgPGI+PHU+e3snVFJBTlNMQVRJT05TJ3x0cmFuc2xhdGV9fTwvdT48L2I+PGJyPlxcbiAgICAgICAg0KDRg9GB0YHQutC40LkgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdGVzdHpcXFwiPnRlc3R6PC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL29uMHRvbGVcXFwiPm9uMHRvbGU8L2E+PGJyPlxcbiAgICAgICAgRGV1dHNjaCAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9kZXoxMzM3XFxcIj5kZXoxMzM3PC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2hvbW9zYXBpZW5zXFxcIj5ob21vc2FwaWVuczwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS91d2VsYW5nXFxcIj51d2VsYW5nPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2FsZXhwZmVpZmZlclxcXCI+YWxleHBmZWlmZmVyPC9hPjxicj5cXG4gICAgICAgIEZyYW7Dp2FpcyAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9waWNrb3VtXFxcIj5waWNrb3VtPC9hPjxicj5cXG4gICAgICAgIEVzcGHDsW9sIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2RyZXNkZW5cXFwiPmRyZXNkZW48L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvcGdhcmNnb1xcXCI+cGdhcmNnbzwvYT48YnI+XFxuICAgICAgICDOlc67zrvOt869zrnOus6sIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2xpb25kYW5pXFxcIj5saW9uZGFuaTwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9zdGVlbXljaGlja2VuMVxcXCI+c3RlZW15Y2hpY2tlbjE8L2E+PGJyPlxcbiAgICAgICAg0JHRitC70LPQsNGA0YHQutC4IC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3Jvc3NlbnBhdmxvdlxcXCI+cm9zc2VucGF2bG92PC9hPjxicj5cXG4gICAgICAgIE5lZGVybGFuZHMgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvbWF4c2VcXFwiPm1heHNlPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2VkamVcXFwiPmVkamU8L2E+PGJyPlxcbiAgICAgICAgTWFneWFyIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3RpYm9ub3ZhXFxcIj50aWJvbm92YTwvYT48YnI+XFxuICAgICAgICDEjGXFoXRpbmEgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvdmFsdHJcXFwiPnZhbHRyPC9hPjxicj5cXG4gICAgICAgINei15HXqNeZ16rigI4gLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYm9zcmFkXFxcIj5ib3NyYWQ8L2E+PGJyPlxcbiAgICAgICAgUG9sc2tpIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2tuaXR0eWJ5bmF0dXJlXFxcIj5rbml0dHlieW5hdHVyZTwvYT4sIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9ndGdcXFwiPmd0ZzwvYT48YnI+XFxuICAgICAgICBQb3J0dWd1w6pzIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2FsYW15cmp1bmlvclxcXCI+YWxhbXlyanVuaW9yPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2NoYXJsaWU3NzdwdFxcXCI+Y2hhcmxpZTc3N3B0PC9hPjxicj5cXG4gICAgICAgIFBvcnR1Z3XDqnMgQlIgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvY2hhcmxpZTc3N3B0XFxcIj5jaGFybGllNzc3cHQ8L2E+PGJyPlxcbiAgICAgICAgQmFoYXNhIEluZG9uZXNpYSAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9sZXZ5Y29yZVxcXCI+bGV2eWNvcmU8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvaGFwcHlwaG9lbml4XFxcIj5oYXBweXBob2VuaXg8L2E+PGJyPlxcbiAgICAgICAg57mB6auU5Lit5paHIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2RlYW5saXVcXFwiPmRlYW5saXU8L2E+PGJyPlxcbiAgICAgICAg566A5L2T5Lit5paHIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2h1YW5nZGFzaHVhbmdcXFwiPmh1YW5nZGFzaHVhbmc8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvb2ZseWhpZ2hcXFwiPm9mbHloaWdoPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2x1Y2lkXFxcIj5sdWNpZDwvYT48YnI+XFxuICAgICAgICBEb2xhbiAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9tYXhzZVxcXCI+bWF4c2U8L2E+PGJyPlxcbiAgICAgICAgU3ZlbnNrIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2FjaWR5b1xcXCI+YWNpZHlvPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3RoZS1lZ28teW91XFxcIj50aGUtZWdvLWlzLXlvdTwvYT48YnI+XFxuICAgICAgICDQo9C60YDQsNGX0L3RgdGM0LrQsCAtIDxhIGhyZWY9XFxcIiNhcHAvcHJvZmlsZS9lcmlrYWZseW5uXFxcIj5lcmlrYWZseW5uPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2FydGVtLXNva29sb2ZmXFxcIj5hcnRlbS1zb2tvbG9mZjwvYT48YnI+XFxuICAgICAgICBCYWhhc2EgTWVsYXl1IC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2tldmlud29uZ1xcXCI+a2V2aW53b25nPC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2tpbGx1bWluYXRpY1xcXCI+a2lsbHVtaW5hdGljPC9hPjxicj5cXG4gICAgICAgIEhydmF0c2tpIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2ZpYnJhNTlcXFwiPmZpYnJhNTk8L2E+PGJyPlxcbiAgICAgICAgRsSBcnNpIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL21leXNhbVxcXCI+bWV5c2FtPC9hPjxicj5cXG4gICAgICAgIEl0YWxpYW5vIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2JodXpcXFwiPmJodXo8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZHVyYW56bzg5XFxcIj5kdXJhbnpvODk8L2E+LCA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvc2lsdmlhYmVuZWZvcnRpXFxcIj5zaWx2aWFiZW5lZm9ydGk8L2E+PGJyPlxcbiAgICAgICAgV2lrYW5nIEZpbGlwaW5vIC0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3RoZW1hbnVhbGJvdFxcXCI+dGhlbWFudWFsYm90PC9hPjxicj5cXG4gICAgICAgINi52Y7YsdmO2KjZkNmK2ZEgLSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvYmJrb29wc3RhXFxcIj5iYmtvb3BzdGE8L2E+PGJyPlxcbiAgICAgICAgXFxuICAgICAgICA8IS0tXFxuICAgICAgICBtYWxheS1raWxsdW1pbmF0aWNcXG4gICAgICAgIFdpa2FuZyBGaWxpcGlubyAtIHRoZW1hbnVhbGJvdFxcbiAgICAgICAgLS0+XFxuICAgIDwvcD5cXG4gICAgPHA+XFxuICAgIDxiPjx1Pnt7J0FCT1VUXzEwJ3x0cmFuc2xhdGV9fTwvdT48L2I+XFxuICAgIDxicj48YSBocmVmPVxcXCJodHRwczovL3N0ZWVtLmlvXFxcIj5odHRwczovL3N0ZWVtLmlvPC9hPlxcbiAgICA8YnI+PGEgaHJlZj1cXFwiaHR0cHM6Ly9nb2xvcy5pb1xcXCI+aHR0cHM6Ly9nb2xvcy5pbzwvYT5cXG4gICAgPC9wPlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cdC5zdGF0ZSgnYXBwLm1hcmtldCcsIHtcblx0XHR1cmw6ICcvbWFya2V0Jyxcblx0XHR2aWV3czoge1xuXHRcdFx0J21lbnVDb250ZW50Jzoge1xuXHRcdFx0XHQvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3NldHRpbmdzLmh0bWwnXG5cdFx0XHRcdHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LWNhY2hlPVxcXCJmYWxzZVxcXCIgdmlldy10aXRsZT1cXFwie3snTUFSS0VUUExBQ0UnIHwgdHJhbnNsYXRlfX1cXFwiPlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj5cXG4gICAgPGg0Pnt7J0VYVEVSTkFMX0FQUFMnfHRyYW5zbGF0ZX19PC9oND5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG5nLWNsaWNrPVxcXCJyZXF1ZXN0QXBwKCdTdGVlbU1vbml0b3InKVxcXCI+XFxuICAgICAgICA8Y2VudGVyPlxcbiAgICAgICAgICA8aW1nIHNyYz1cXFwiaW1nL2xvZ29fc3RlZW1tb25pdG9yLnBuZ1xcXCIgYWx0PVxcXCJTdGVlbSBNb25pdG9yXFxcIiBzdHlsZT1cXFwid2lkdGg6IDEwMCU7XFxcIj5cXG4gICAgICAgICAgPGI+U3RlZW0gTW9uaXRvcjwvYj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImdyYXlcXFwiPnt7J0JZJ3x0cmFuc2xhdGV9fSA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvZ29vZC1rYXJtYVxcXCI+RmVydXo8L2E+PC9wPlxcbiAgICAgICAgPC9jZW50ZXI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1jbGljaz1cXFwicmVxdWVzdEFwcCgnU3RlZW1GZXN0JylcXFwiPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAgPGltZyBzcmM9XFxcImltZy9sb2dvX3N0ZWVtZmVzdC5wbmdcXFwiIGFsdD1cXFwiU3RlZW0gRmVzdFxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlO1xcXCI+XFxuICAgICAgICAgIDxiPlN0ZWVtIEZlc3Q8L2I+XFxuICAgICAgICAgIDxwIGNsYXNzPVxcXCJncmF5XFxcIj57eydCWSd8dHJhbnNsYXRlfX0gPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL2dvb2Qta2FybWFcXFwiPkZlcnV6PC9hPiwgPGEgaHJlZj1cXFwiI2FwcC9wcm9maWxlL3JvZWxhbmRwXFxcIj5Sb2VsYW5kPC9hPiAmYW1wOyA8YSBocmVmPVxcXCIjYXBwL3Byb2ZpbGUvY2Fzc1xcXCI+Q2FzczwvYT48L3A+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+PGJyLz5cXG4gICAgPGg0Pnt7J1BMVUdJTlMnfHRyYW5zbGF0ZX19PC9oND5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgaXRhbGljXFxcIj5cXG4gICAgICAgIDxjZW50ZXI+XFxuICAgICAgICAgIHt7J0NPTUlOR19TT09OJ3x0cmFuc2xhdGV9fS4uLlxcbiAgICAgICAgPC9jZW50ZXI+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8YnIvPlxcbiAgICA8aDQ+e3snU1VHR0VTVCd8dHJhbnNsYXRlfX08L2g0Pjxici8+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1jbGljaz1cXFwicmVxdWVzdEFwcCgnTmV3JylcXFwiPlxcbiAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAgPGltZyBzcmM9XFxcImltZy9wbHVzLnBuZ1xcXCIgYWx0PVxcXCJTdWdnZXN0IE5ld1xcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlO1xcXCI+XFxuICAgICAgICAgIDxiPnt7J05FVyd8dHJhbnNsYXRlfX08L2I+XFxuICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcblx0XHRcdFx0Y29udHJvbGxlcjogJ01hcmtldEN0cmwnXG5cdFx0XHR9XG5cdFx0fVxuXHR9KVxuXG4gIC5zdGF0ZSgnYXBwLnNlbmQnLCB7XG4gICAgdXJsOiAnL3NlbmQnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvc2V0dGluZ3MuaHRtbCdcbiAgICAgICAgdGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydUUkFOU0ZFUid8dHJhbnNsYXRlfX1cXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwidGFicy1zdHJpcGVkIHRhYnMtdG9wIHRhYnMtYmFja2dyb3VuZC1wb3NpdGl2ZSB0YWJzLWNvbG9yLWxpZ2h0XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGFic1xcXCI+XFxuICAgICAgPGEgY2xhc3M9XFxcInRhYi1pdGVtXFxcIiBocmVmIG5nLWNsaWNrPVxcXCJjaGFuZ2VUcmFuc2ZlcigndHJhbnNmZXInKVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzogdHR5cGU9PSd0cmFuc2Zlcid9XFxcIj5cXG4gICAgICAgIHt7XFxcIlRSQU5TRkVSXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgIDwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwidGFiLWl0ZW1cXFwiIGhyZWYgbmctY2xpY2s9XFxcImNoYW5nZVRyYW5zZmVyKCdlc2Nyb3cnKVxcXCIgbmctY2xhc3M9XFxcInsnYWN0aXZlJzogdHR5cGU9PSdlc2Nyb3cnfVxcXCI+XFxuICAgICAgICB7e1xcXCJFU0NST1dcXFwifHRyYW5zbGF0ZX19XFxuICAgICAgPC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nIGhhcy10YWJzLXRvcFxcXCI+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3RcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dCBpdGVtLWljb24tcmlnaHRcXFwiIG5nLWlmPVxcXCIhZGF0YS5hZHZhbmNlZFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J1RPJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwiZGF0YS51c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1RPX0RFU0MnfHRyYW5zbGF0ZX19XFxcIiBuZy1jaGFuZ2U9XFxcImNoYW5nZVVzZXJuYW1lKClcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLWNhbWVyYS1vdXRsaW5lXFxcIiBuZy1jbGljaz1cXFwicXJTY2FuKClcXFwiIG5nLWlmPVxcXCJ0dHlwZT09J3RyYW5zZmVyJ1xcXCI+PC9pPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnJiYhZGF0YS5hZHZhbmNlZFxcXCI+XFxuICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3tcXFwiRVNDUk9XX0FHRU5UXFxcInx0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHJlYWRvbmx5PVxcXCJyZWFkb25seVxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1VTRVJOQU1FJ3x0cmFuc2xhdGV9fVxcXCIgbmctbW9kZWw9XFxcImRhdGEuYWdlbnQubmFtZVxcXCIgbmctY2xpY2s9XFxcIm9wZW5VTW9kYWwoZGF0YS5hZ2VudClcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwib2ZmXFxcIiBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCIvPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0IGl0ZW0taWNvbi1yaWdodFxcXCIgbmctaWY9XFxcInR0eXBlPT0nZXNjcm93JyYmZGF0YS5hZHZhbmNlZFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0VTQ1JPVyd8dHJhbnNsYXRlfX0ge3snSUQnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLmVzY3Jvd19pZFxcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1NFQVJDSCd8dHJhbnNsYXRlfX1cXFwiIG5nLWNoYW5nZT1cXFwic2VhcmNoRXNjcm93SUQoZGF0YS5lc2Nyb3dfaWQpXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0IGl0ZW0tc2VsZWN0XFxcIiBuZy1pZj1cXFwiZGF0YS5hZHZhbmNlZFxcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J09QVElPTlMnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiZGF0YS5ldHlwZVxcXCIgbmctaWY9XFxcInR0eXBlPT0nZXNjcm93J1xcXCIgbmctb3B0aW9ucz1cXFwiaXRlbS50eXBlIGFzIGl0ZW0ubmFtZSBmb3IgaXRlbSBpbiBkYXRhLmV0eXBlcyB0cmFjayBieSBpdGVtLmlkXFxcIiBuZy1jaGFuZ2U9XFxcImFjdGlvbkVDaGFuZ2UoKVxcXCI+PC9zZWxlY3Q+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dCBpdGVtLXNlbGVjdFxcXCIgbmctaWY9XFxcImRhdGEuYWR2YW5jZWQmJmRhdGEuZXR5cGU9PSdyZWxlYXNlJ1xcXCI+XFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J1JFQ0VJVkVSJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XFxcImVzY3Jvdy5yZWNlaXZlclxcXCI+XFxuICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7ZXNjcm93LnRvfX1cXFwiIG5nLWlmPVxcXCJlc2Nyb3cudG8hPSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7ZXNjcm93LnRvfX08L29wdGlvbj5cXG4gICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwie3tlc2Nyb3cuZnJvbX19XFxcIiBuZy1pZj1cXFwiZXNjcm93LmZyb20hPSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7ZXNjcm93LmZyb219fTwvb3B0aW9uPlxcbiAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dCBpdGVtLXNlbGVjdFxcXCIgbmctaWY9XFxcIiFkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snQVNTRVQnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgPHNlbGVjdCBuZy1tb2RlbD1cXFwiZGF0YS50eXBlXFxcIiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnXFxcIiBuZy1vcHRpb25zPVxcXCJpdGVtLnR5cGUgYXMgaXRlbS5uYW1lIGZvciBpdGVtIGluIGRhdGEudHlwZXMgfCBmaWx0ZXI6c2hvd0xpcXVpZCB0cmFjayBieSBpdGVtLmlkXFxcIj48L3NlbGVjdD5cXG4gICAgICAgIDxzZWxlY3QgbmctbW9kZWw9XFxcImRhdGEudHlwZVxcXCIgbmctaWY9XFxcInR0eXBlPT0ndHJhbnNmZXInXFxcIiBuZy1vcHRpb25zPVxcXCJpdGVtLnR5cGUgYXMgaXRlbS5uYW1lIGZvciBpdGVtIGluIGRhdGEudHlwZXMgdHJhY2sgYnkgaXRlbS5pZFxcXCI+PC9zZWxlY3Q+XFxuICAgICAgPC9sYWJlbD5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCIgbmctaWY9XFxcIiFkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snQU1PVU5UJ3x0cmFuc2xhdGV9fTwvc3Bhbj5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJudW1iZXJcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydBTU9VTlQnfHRyYW5zbGF0ZX19XFxcIiBzdGVwPVxcXCIwLjAwMVxcXCIgbmctbW9kZWw9XFxcImRhdGEuYW1vdW50XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiIG5nLWlmPVxcXCJkYXRhLnR5cGUgIT0gJ3NwJyYmZGF0YS50eXBlICE9ICdnb2xvc3AnICYmICFkYXRhLmFkdmFuY2VkXFxcIj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snTUVNTyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICA8dGV4dGFyZWEgbmctbW9kZWw9XFxcImRhdGEubWVtb1xcXCIgcm93cz1cXFwiM1xcXCIgcGxhY2Vob2xkZXI9XFxcInt7J1BVQkxJQ19NRU1PJ3x0cmFuc2xhdGV9fVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJvZmZcXFwiIHNwZWxsY2hlY2s9XFxcImZhbHNlXFxcIj48L3RleHRhcmVhPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgaW9uLWRhdGV0aW1lLXBpY2tlciBuZy1tb2RlbD1cXFwiZGF0YS5yYXRpZmljYXRpb25cXFwiIG9ubHktdmFsaWQ9XFxcInsnYWZ0ZXInOiAndG9kYXknLCAnaW5jbHVzaXZlJzogdHJ1ZX1cXFwiIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdycmJiFkYXRhLmFkdmFuY2VkXFxcIj57eydSQVRJRklDQVRJT05fREVBRExJTkUnfHRyYW5zbGF0ZX19OiB7e2RhdGEucmF0aWZpY2F0aW9ufCBkYXRlOiBcXFwieXl5eS1NTS1kZCBIOm1tOnNzXFxcIn19PC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgaW9uLWRhdGV0aW1lLXBpY2tlciBuZy1tb2RlbD1cXFwiZGF0YS5leHBpcmF0aW9uXFxcIiBvbmx5LXZhbGlkPVxcXCJ7J2FmdGVyJzogJ3RvZGF5JywgJ2luY2x1c2l2ZSc6IGZhbHNlfVxcXCIgbmctaWY9XFxcInR0eXBlPT0nZXNjcm93JyYmIWRhdGEuYWR2YW5jZWRcXFwiPnt7J0VTQ1JPV19FWFBJUkFUSU9OJ3x0cmFuc2xhdGV9fToge3tkYXRhLmV4cGlyYXRpb258IGRhdGU6IFxcXCJ5eXl5LU1NLWRkIEg6bW06c3NcXFwifX08L2Rpdj5cXG4gICAgICA8aW9uLXRvZ2dsZSBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnXFxcIiBuZy1tb2RlbD1cXFwiZGF0YS5hZHZhbmNlZFxcXCIgdG9nZ2xlLWNsYXNzPVxcXCJ0b2dnbGUtY2FsbVxcXCIgbmctY2hhbmdlPVxcXCJhZHZhbmNlZEVDaGFuZ2UoKVxcXCI+e3snQURWQU5DRUQnfHRyYW5zbGF0ZX19PC9pb24tdG9nZ2xlPlxcbiAgICAgIDxwIGNsYXNzPVxcXCJpdGVtXFxcIiBuZy1pZj1cXFwiYmFsYW5jZSAmJiAhZGF0YS5hZHZhbmNlZFxcXCI+e3snQVZBSUxBQkxFJ3x0cmFuc2xhdGV9fToge3tiYWxhbmNlLmJhbGFuY2V9fSwge3tiYWxhbmNlLnNiZF9iYWxhbmNlfX0gPGkgY2xhc3M9XFxcImljb24gaW9uLXJlZnJlc2ggcHVsbC1yaWdodFxcXCIgbmctY2xpY2s9XFxcInJlZnJlc2goKVxcXCI+PC9pPjwvcD5cXG4gICAgICA8YnI+XFxuICAgICAgPGRpdiBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnICYmIGRhdGEuYWR2YW5jZWQgJiYgZXNjcm93LmVzY3Jvd19pZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tcXFwiRlJPTVxcXCJ8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy5mcm9tfX08L2Rpdj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e1xcXCJUT1xcXCJ8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy50b319PC9kaXY+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tcXFwiRVNDUk9XX0FHRU5UXFxcInx0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LmFnZW50fX08L2Rpdj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e1xcXCJFU0NST1dfRkVFXFxcInx0cmFuc2xhdGV9fTo8L2Rpdj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7ZXNjcm93LmZlZX19IHt7ZXNjcm93LmZlZV9zeW1ib2x9fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1JBVElGSUNBVElPTl9ERUFETElORSd8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy5yYXRpZmljYXRpb25fZGVhZGxpbmV8ZGF0ZTonc2hvcnQnfX08L2Rpdj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydFU0NST1dfRVhQSVJBVElPTid8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy5lc2Nyb3dfZXhwaXJhdGlvbnxkYXRlOidzaG9ydCd9fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7XFxcIkVTQ1JPV19URVJNU1xcXCJ8dHJhbnNsYXRlfX06PC9kaXY+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2VzY3Jvdy5qc29uX21ldGEudGVybXN9fTwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J01FTU8nfHRyYW5zbGF0ZX19OjwvZGl2PjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tlc2Nyb3cuanNvbl9tZXRhLm1lbW99fTwvZGl2PjwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxjZW50ZXIgbmctaWY9XFxcInR0eXBlPT0ndHJhbnNmZXInXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwidHJhbnNmZXIoJ3RyYW5zZmVyJylcXFwiPlxcbiAgICAgICAge3snU0VORCd8dHJhbnNsYXRlfX1cXG4gICAgICA8L2J1dHRvbj48L2NlbnRlcj5cXG4gICAgICA8Y2VudGVyIG5nLWlmPVxcXCJ0dHlwZT09J2VzY3JvdycmJiFkYXRhLmFkdmFuY2VkXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwidHJhbnNmZXIoJ2VzY3JvdycpXFxcIj5cXG4gICAgICAgIHt7J1NFTkQnfHRyYW5zbGF0ZX19XFxuICAgICAgPC9idXR0b24+PC9jZW50ZXI+XFxuICAgICAgPGNlbnRlciBuZy1pZj1cXFwidHR5cGU9PSdlc2Nyb3cnJiZkYXRhLmFkdmFuY2VkXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwiZXNjcm93QWN0aW9uKClcXFwiPlxcbiAgICAgICAge3snU1VCTUlUJ3x0cmFuc2xhdGV9fVxcbiAgICAgIDwvYnV0dG9uPjwvY2VudGVyPlxcbiAgICAgIDxicj5cXG4gICAgICA8Y2VudGVyIG5nLWlmPVxcXCJ0dHlwZT09J3RyYW5zZmVyJ1xcXCI+PHFyIHRleHQ9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPjwvcXI+PC9jZW50ZXI+XFxuICAgICAgPGNlbnRlciBuZy1pZj1cXFwidHR5cGU9PSd0cmFuc2ZlcidcXFwiPjxpIGNsYXNzPVxcXCJpdGFsaWNcXFwiPnt7JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZX19PC9pPjwvY2VudGVyPlxcbiAgICA8L2Rpdj5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuICA8c2NyaXB0IGlkPVxcXCJteS1tb2RhbC5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgPGlvbi1tb2RhbC12aWV3PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJhciBiYXItaGVhZGVyIGJhci1wb3NpdGl2ZSBpdGVtLWlucHV0LWluc2V0XFxcIj5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbS1pbnB1dC13cmFwcGVyXFxcIj5cXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWlvcy1zZWFyY2ggcGxhY2Vob2xkZXItaWNvblxcXCI+PC9pPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwic2VhcmNoXFxcIiBwbGFjZWhvbGRlcj1cXFwie3snU0VBUkNIJ3x0cmFuc2xhdGV9fVxcXCIgbmctY2hhbmdlPVxcXCJnZXRVc2VyQWdlbnQoZGF0YS5xdWVyeSlcXFwiIG5nLW1vZGVsPVxcXCJkYXRhLnF1ZXJ5XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tY2xlYXIgYnV0dG9uLW91dGxpbmVcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVVNb2RhbCgpXFxcIj5cXG4gICAgICAgICAge3tcXFwiQ0FOQ0VMXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJoYXMtaGVhZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxpc3RcXFwiIG5nLWlmPVxcXCJkYXRhLnNlYXJjaFJlc3VsdC5sZW5ndGg+MFxcXCI+XFxuICAgICAgICAgIDxhIGNsYXNzPVxcXCJpdGVtXFxcIiBuZy1yZXBlYXQ9XFxcInggaW4gZGF0YS5zZWFyY2hSZXN1bHRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3RBZ2VudCh4KVxcXCI+XFxuICAgICAgICAgICAgPGgyPnt7J0VTQ1JPV19BR0VOVCd8dHJhbnNsYXRlfX06IHt7eC5uYW1lfX08L2gyPlxcbiAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInguZXNjcm93XFxcIiBjbGFzcz1cXFwid3JhcFxcXCI+e3snRVNDUk9XX1RFUk1TJ3x0cmFuc2xhdGV9fToge3t4LmVzY3Jvdy50ZXJtc319PC9kaXY+XFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcIndyYXBcXFwiPnt7J0VTQ1JPV19GRUUnfHRyYW5zbGF0ZX19OiB7e3guZXNjcm93LmZlZXNbJHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdF19fSB7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtbHVuaXR9fSAvIHt7eC5lc2Nyb3cuZmVlc1skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0XX19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdH19XFxuICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICA8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxjZW50ZXIgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWlmPVxcXCJkYXRhLnNlYXJjaFJlc3VsdC5sZW5ndGg9PTBcXFwiPlxcbiAgICAgICAgICB7e1xcXCJVU0VSX05PVEZPVU5EXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9jZW50ZXI+XFxuICAgICAgPC9pb24tY29udGVudD5cXG4gICAgPC9pb24tbW9kYWwtdmlldz5cXG5cXG4gIDwvc2NyaXB0PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdTZW5kQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAuZm9sbG93Jywge1xuICAgIHVybDogJy9mb2xsb3cnLFxuICAgIHZpZXdzOiB7XG4gICAgICAnbWVudUNvbnRlbnQnOiB7XG4gICAgICAgIC8vdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvZm9sbG93Lmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiIHZpZXctdGl0bGU9XFxcInt7J0ZPTExPVycgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLWZvb3RlclxcXCIgZGVsZWdhdGUtaGFuZGxlPVxcXCJsaXN0U2Nyb2xsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibGlzdCBsaXN0LWluc2V0XFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nZm9sbG93ZXJzJ1xcXCI+XFxuICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiPlxcbiAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLXNlYXJjaCBwbGFjZWhvbGRlci1pY29uXFxcIj48L2k+XFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcInNlYXJjaHUuZm9sbG93ZXJcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydTRUFSQ0hfRk9MTE9XRVJTJyB8IHRyYW5zbGF0ZX19XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGxpc3QtaW5zZXRcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dpbmcnXFxcIj5cXG4gICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tc2VhcmNoIHBsYWNlaG9sZGVyLWljb25cXFwiPjwvaT5cXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwic2VhcmNodS5mb2xsb3dpbmdcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydTRUFSQ0hfRk9MTE9XSU5HJyB8IHRyYW5zbGF0ZX19XFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCIgYXV0b2NvcnJlY3Q9XFxcIm9mZlxcXCIgYXV0b2NhcGl0YWxpemU9XFxcIm9mZlxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiPlxcbiAgICAgIDwvbGFiZWw+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0XFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0nZm9sbG93ZXJzJyAmJiBmb2xsb3dlcnMubGVuZ3RoPjBcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1idXR0b24tcmlnaHRcXFwiIG5nLXJlcGVhdD1cXFwiZiBpbiBmb2xsb3dlcnMgfCBmaWx0ZXI6c2VhcmNodSAgdHJhY2sgYnkgJGluZGV4XFxcIj5cXG4gICAgICAgIDxzcGFuIG5nLWNsaWNrPVxcXCJwcm9maWxlVmlldyhmLmZvbGxvd2VyKVxcXCI+e3tmLmZvbGxvd2VyfX08L3NwYW4+XFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlIGJ1dHRvbi1vdXRsaW5lXFxcIiBuZy1pZj1cXFwiIWlzRm9sbG93ZWQoZi5mb2xsb3dlcilcXFwiIG5nLWNsaWNrPVxcXCJmb2xsb3dVc2VyKGYuZm9sbG93ZXIpXFxcIj5cXG4gICAgICAgIHt7J0ZPTExPV19CQUNLJyB8IHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJpc0ZvbGxvd2VkKGYuZm9sbG93ZXIpXFxcIiBuZy1jbGljaz1cXFwidW5mb2xsb3dVc2VyKGYuZm9sbG93ZXIpXFxcIj5cXG4gICAgICAgIHt7J0ZPTExPV0VEJyB8IHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImxpc3RcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdmb2xsb3dpbmcnICYmIGZvbGxvd2luZy5sZW5ndGg+MFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJ1dHRvbi1yaWdodFxcXCIgbmctcmVwZWF0PVxcXCJmIGluIGZvbGxvd2luZyB8IGZpbHRlcjpzZWFyY2h1ICB0cmFjayBieSAkaW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gbmctY2xpY2s9XFxcInByb2ZpbGVWaWV3KGYuZm9sbG93aW5nKVxcXCI+e3tmLmZvbGxvd2luZ319PC9zcGFuPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBidXR0b24tb3V0bGluZVxcXCIgbmctaWY9XFxcIiFpc0ZvbGxvd2luZyhmLmZvbGxvd2luZylcXFwiIG5nLWNsaWNrPVxcXCJ1bmZvbGxvd1VzZXIoZi5mb2xsb3dpbmcpXFxcIj5cXG4gICAgICAgIHt7J1VORk9MTE9XJyB8IHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJpc0ZvbGxvd2luZyhmLmZvbGxvd2luZylcXFwiPlxcbiAgICAgICAge3snRk9MTE9XSU5HJyB8IHRyYW5zbGF0ZX19XFxuICAgICAgICA8L2J1dHRvbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDwhLS08aW9uLWluZmluaXRlLXNjcm9sbCBvbi1pbmZpbml0ZT1cXFwibG9hZE1vcmUoKVxcXCIgbmctaWY9XFxcImxhc3RkXFxcIiBkaXN0YW5jZT1cXFwiMiVcXFwiPjwvaW9uLWluZmluaXRlLXNjcm9sbD4tLT5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuICA8ZGl2IGNsYXNzPVxcXCJiYXIgcHJvZmlsZSBiYXItZm9vdGVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uLWJhclxcXCI+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tbGFyZ2UgYnV0dG9uLXJveWFsIGljb24gaW9uLWlvcy1wZW9wbGVcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nZm9sbG93ZXJzJ31cXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ2ZvbGxvd2VycycpXFxcIj4ge3snRk9MTE9XRVJTJyB8IHRyYW5zbGF0ZX19IDxzcGFuIG5nLWlmPVxcXCJmb2xsb3dlcnMubGVuZ3RoPjBcXFwiPih7e2ZvbGxvd2Vycy5sZW5ndGh9fSk8L3NwYW4+PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLXBlcnNvbi1hZGRcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nZm9sbG93aW5nJ31cXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ2ZvbGxvd2luZycpXFxcIj4ge3snRk9MTE9XRUQnIHwgdHJhbnNsYXRlfX0gPHNwYW4gbmctaWY9XFxcImZvbGxvd2luZy5sZW5ndGg+MFxcXCI+KHt7Zm9sbG93aW5nLmxlbmd0aH19KTwvc3Bhbj48L2E+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ0ZvbGxvd0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cbiAgLnN0YXRlKCdhcHAuZXhjaGFuZ2UnLCB7XG4gICAgdXJsOiAnL2V4Y2hhbmdlLzp1c2VybmFtZScsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgIFx0dGVtcGxhdGU6IFwiPGlvbi12aWV3IHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIiB2aWV3LXRpdGxlPVxcXCJ7eydNQVJLRVRfVklFVycgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcInBhZGRpbmcgaGFzLWZvb3RlciBleGNoYW5nZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlxcXCIgbmctaWY9XFxcImFjdGl2ZT09J2J1eSdcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInJvdyBoZWFkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydQUklDRScgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydBTU9VTlQnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snVE9UQUwnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiIG5nLXJlcGVhdD1cXFwiKGtleSwgZikgaW4gb3JkZXJzLmJpZHNcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YucmVhbF9wcmljZXxudW1iZXI6NH19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5vcmRlcl9wcmljZS5xdW90ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5vcmRlcl9wcmljZS5iYXNlfX08L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlxcXCIgbmctaWY9XFxcImFjdGl2ZT09J3NlbGwnXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgaGVhZGVyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snUFJJQ0UnIHwgdHJhbnNsYXRlfX08L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snQU1PVU5UJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1RPVEFMJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiBuZy1yZXBlYXQ9XFxcIihrZXksIGYpIGluIG9yZGVycy5hc2tzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3tmLnJlYWxfcHJpY2V8bnVtYmVyOjR9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2Yub3JkZXJfcHJpY2UucXVvdGV9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2Yub3JkZXJfcHJpY2UuYmFzZX19PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSdvcGVuJ1xcXCI+XFxuICAgICAgPHAgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWlmPVxcXCJvcGVub3JkZXJzLmxlbmd0aDwxXFxcIj5cXG4gICAgICAgIHt7J05PT1JERVJTJyB8IHRyYW5zbGF0ZX19IEB7e3VzZXJuYW1lfX1cXG4gICAgICA8L3A+XFxuICAgICAgPGRpdiBuZy1pZj1cXFwib3Blbm9yZGVycy5sZW5ndGg+MFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgaGVhZGVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eydQUklDRScgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J0FNT1VOVCcgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1RPVEFMJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgbmctcmVwZWF0PVxcXCIoa2V5LCBmKSBpbiBvcGVub3JkZXJzXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YucmVhbF9wcmljZXxudW1iZXI6NH19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctaWY9XFxcImYuc2VsbGVyPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj57e2Yuc2VsbF9wcmljZS5xdW90ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctaWY9XFxcImYuc2VsbGVyPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj57e2Yuc2VsbF9wcmljZS5iYXNlfX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBuZy1pZj1cXFwiZi5idXllcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+e3tmLmJ1eV9wcmljZS5xdW90ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctaWY9XFxcImYuYnV5ZXI9PSRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWVcXFwiPnt7Zi5idXlfcHJpY2UuYmFzZX19PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIlxcXCIgbmctaWY9XFxcImFjdGl2ZT09J2hpc3RvcnknXFxcIj5cXG4gICAgICA8IS0tPHAgY2xhc3M9XFxcInBhZGRpbmdcXFwiPk5vdGhpbmcgaGVyZSwgeWV0Li4uPC9wPi0tPlxcbiAgICAgIDxkaXYgbmctaWY9XFxcInJlY2VudF90cmFkZXMubGVuZ3RoPjBcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGhlYWRlclxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3snREFURScgfCB0cmFuc2xhdGV9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7J1BSSUNFJyB8IHRyYW5zbGF0ZX19PC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+e3skcm9vdC4kc3RvcmFnZS5wbGF0Zm9ybXN1bml0fX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyfX08L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIiBuZy1yZXBlYXQ9XFxcIihrZXksIGYpIGluIHJlY2VudF90cmFkZXNcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5kYXRlfHRpbWVhZ299fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5jdXJyZW50X3BheXMuc3BsaXQoXFxcIiBcXFwiKVswXS9mLm9wZW5fcGF5cy5zcGxpdChcXFwiIFxcXCIpWzBdfG51bWJlcjo2fX08L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj57e2YuY3VycmVudF9wYXlzLnNwbGl0KFxcXCIgXFxcIilbMF18bnVtYmVyOjN9fTwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPnt7Zi5vcGVuX3BheXMuc3BsaXQoXFxcIiBcXFwiKVswXXxudW1iZXI6M319PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2lvbi1jb250ZW50PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZSBiYXIgYmFyLWZvb3RlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbi1iYXJcXFwiPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWxhcmdlIGJ1dHRvbi1yb3lhbCBpY29uIGlvbi1hcnJvdy1kb3duLWFcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nYnV5J31cXFwiIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ2J1eScpXFxcIj4ge3snQlVZJyB8IHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLWFycm93LXVwLWFcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nc2VsbCd9XFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlKCdzZWxsJylcXFwiPiB7eydTRUxMJyB8IHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLWZsYWdcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nb3Blbid9XFxcIiBuZy1jbGljaz1cXFwiY2hhbmdlKCdvcGVuJylcXFwiPnt7J09QRU4nIHwgdHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcm95YWwgaWNvbiBpb24taW9zLWNsb2NrXFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2hpc3RvcnknfVxcXCIgIG5nLWNsaWNrPVxcXCJjaGFuZ2UoJ2hpc3RvcnknKVxcXCI+e3snSElTVE9SWScgfCB0cmFuc2xhdGV9fTwvYT5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2V4Y2hhbmdlLmh0bWwnLFxuICAgICAgICBjb250cm9sbGVyOiAnRXhjaGFuZ2VDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAuc3RhdGUoJ2FwcC5wcm9maWxlJywge1xuICAgIHVybDogJy9wcm9maWxlLzp1c2VybmFtZScsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9wcm9maWxlLmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy10aXRsZT1cXFwiXFxcIiBoaWRlLW5hdi1iYXI9XFxcInRydWVcXFwiIHZpZXctY2FjaGU9XFxcImZhbHNlXFxcIj48IS0tbmctY2xhc3M9XFxcInsnbXBiJzokcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5jb3Zlcl9pbWFnZX1cXFwiLS0+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1mb290ZXJcXFwiIG92ZXJmbG93LXNjcm9sbD1cXFwidHJ1ZVxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJhciBiYXItc3ViaGVhZGVyIG15c3ViaGVhZGVyIGJhci1wb3NpdGl2ZVxcXCIgbmctc3R5bGU9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgIT0gdXNlci51c2VybmFtZT9jc3M6bWNzc1xcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24taW9zLWFycm93LWJhY2sgcHJvZmlsZWJ0blxcXCIgb24tdGFwPVxcXCJnb0JhY2soKVxcXCI+PC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1vdXRsaW5lIGJ1dHRvbi1saWdodCBwcm9maWxlYnRuX2ZvbGxvd1xcXCIgb24tdGFwPVxcXCJmb2xsb3dVc2VyKHVzZXIudXNlcm5hbWUpXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9IHVzZXIudXNlcm5hbWUgJiYgIWlzQW1Gb2xsb3dpbmcodXNlci51c2VybmFtZSlcXFwiPjwhLS08aSBjbGFzcz1cXFwiZmEgZmEtdXNlci1wbHVzIGZhLWxnXFxcIj48L2k+LS0+e3snRk9MTE9XJ3x0cmFuc2xhdGV9fTwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tY2xlYXIgcHJvZmlsZWJ0bl9lZGl0IGJ1dHRvbi1pY29uIGlvbi1pb3MtY29tcG9zZS1vdXRsaW5lXFxcIiBvbi10YXA9XFxcInNob3dFZGl0cygpXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lID09PSB1c2VyLnVzZXJuYW1lXFxcIj48L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWNsZWFyIHByb2ZpbGVidG5fZm9sbG93IGJ1dHRvbi1pY29uIGlvbi1jYW1lcmFcXFwiIG9uLXRhcD1cXFwic2hvd0NvdmVyKClcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyICYmICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgPT09IHVzZXIudXNlcm5hbWVcXFwiPjwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tb3V0bGluZSBidXR0b24tbGlnaHQgcHJvZmlsZWJ0bl9mb2xsb3dcXFwiIG9uLXRhcD1cXFwidW5mb2xsb3dVc2VyKHVzZXIudXNlcm5hbWUpXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlciAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9IHVzZXIudXNlcm5hbWUgJiYgaXNBbUZvbGxvd2luZyh1c2VyLnVzZXJuYW1lKVxcXCI+PCEtLWJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhcjxpIGNsYXNzPVxcXCJmYSBmYS11c2VyLXRpbWVzIGZhLWxnXFxcIj48L2k+LS0+e3snVU5GT0xMT1cnfHRyYW5zbGF0ZX19PC9idXR0b24+Jm5ic3A7XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY2VudGVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIgJiYgJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSA9PSB1c2VyLnVzZXJuYW1lXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiEoJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZXx8JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UpXFxcIj48aW1nIHNyYz1cXFwiaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFwiIG9uLXRhcD1cXFwic2hvd1Byb2ZpbGUoKVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgfHwgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2V9fVxcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS51c2VyX2ltYWdlIHx8ICRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2VcXFwiIG9uLXRhcD1cXFwic2hvd1Byb2ZpbGUoKVxcXCIgLz5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb290cHJvZmlsZWluZm9cXFwiPlxcbiAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJjZW50ZXJcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwibGlnaHRcXFwiPkB7eyRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWV9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7JHJvb3QuJHN0b3JhZ2UudXNlci5yZXB1dGF0aW9ufHJlcHV0YXRpb259fVxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJhYm91dFxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5hYm91dH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtbGlzdFxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdF9jb3VudH19Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHwmbmJzcDtcXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LWdyYXBoLXVwLXJpZ2h0XFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UudXNlci52b3RpbmdfcG93ZXIvMTAwfG51bWJlcjoyfX0mbmJzcDtcXG4gICAgICAgICAgICAgICAgfCZuYnNwOzxpIGNsYXNzPVxcXCJpY29uIGlvbi1pb3MtcGVvcGxlXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7Zm9sbG93ZGV0YWlscy5mb2xsb3dlcl9jb3VudH19Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHwmbmJzcDs8aSBjbGFzcz1cXFwiaW9uLXBlcnNvbi1hZGRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2luZ19jb3VudH19XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDxwPjxzcGFuIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiAkcm9vdC4kc3RvcmFnZS51c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5sb2NhdGlvblxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1sb2NhdGlvblxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLnVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmxvY2F0aW9ufX1cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+Jm5ic3A7XFxuICAgICAgICAgICAgICA8c3BhbiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUgJiYgJHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUud2Vic2l0ZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1saW5rXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIDxhIG9uLXRhcD1cXFwid2luZG93Lm9wZW4oJ3t7JHJvb3QuJHN0b3JhZ2UudXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUud2Vic2l0ZX19JywgJ19zeXN0ZW0nKTtcXFwiIHN0eWxlPVxcXCJjb2xvcjp3aGl0ZSFpbXBvcnRhbnQ7dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxcIj5XZWJTaXRlPC9hPlxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDxzcGFuIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLmNyZWF0ZWRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tY2FsZW5kYXJcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAge3skcm9vdC4kc3RvcmFnZS51c2VyLmNyZWF0ZWR8ZGF0ZX19XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPjwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0tbXlhdmF0YXJcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICE9PSB1c2VyLnVzZXJuYW1lXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaXRlbS1teWF2YXRhclxcXCIgbmctaWY9XFxcIiEodXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUucHJvZmlsZV9pbWFnZXx8dXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2UpXFxcIj48aW1nIHNyYz1cXFwiaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFwiIC8+PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7e3VzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgfHwgdXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2V9fVxcXCIgbmctaWY9XFxcInVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLnByb2ZpbGVfaW1hZ2UgfHwgdXNlci5qc29uX21ldGFkYXRhLnVzZXJfaW1hZ2VcXFwiIC8+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9vdHByb2ZpbGVpbmZvXFxcIj5cXG4gICAgICAgICAgICAgIDxoNCBjbGFzcz1cXFwiY2VudGVyXFxcIj48c3BhbiBjbGFzcz1cXFwibGlnaHRcXFwiPkB7e3VzZXIudXNlcm5hbWV9fTwvc3Bhbj4mbmJzcDs8ZGl2IGNsYXNzPVxcXCJyZXB1dGF0aW9uXFxcIj57e3VzZXIucmVwdXRhdGlvbnxyZXB1dGF0aW9ufX08L2Rpdj48L2g0PlxcbiAgICAgICAgICAgICAgPHA+e3t1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS5hYm91dH19PC9wPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtbGlzdFxcXCI+PC9pPiZuYnNwO3t7dXNlci5wb3N0X2NvdW50fX0mbmJzcDt8Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LWdyYXBoLXVwLXJpZ2h0XFxcIj48L2k+Jm5ic3A7e3t1c2VyLnZvdGluZ19wb3dlci8xMDB8bnVtYmVyOjJ9fSZuYnNwO3wmbmJzcDs8aSBjbGFzcz1cXFwiaWNvbiBpb24taW9zLXBlb3BsZVxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAge3tmb2xsb3dkZXRhaWxzLmZvbGxvd2VyX2NvdW50fX0mbmJzcDtcXG4gICAgICAgICAgICAgIHwmbmJzcDs8aSBjbGFzcz1cXFwiaW9uLXBlcnNvbi1hZGRcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgIHt7Zm9sbG93ZGV0YWlscy5mb2xsb3dpbmdfY291bnR9fTwvZGl2PlxcbiAgICAgICAgICAgICAgPHA+PHNwYW4gbmctaWY9XFxcInVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlICYmIHVzZXIuanNvbl9tZXRhZGF0YS5wcm9maWxlLmxvY2F0aW9uXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxvY2F0aW9uXFxcIj48L2k+Jm5ic3A7XFxuICAgICAgICAgICAgICAgIHt7dXNlci5qc29uX21ldGFkYXRhLnByb2ZpbGUubG9jYXRpb259fVxcbiAgICAgICAgICAgICAgICAmbmJzcDtcXG4gICAgICAgICAgICAgIDwvc3Bhbj4mbmJzcDtcXG4gICAgICAgICAgICAgIDxzcGFuIG5nLWlmPVxcXCJ1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZSAmJiB1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImljb24gaW9uLWxpbmtcXFwiPjwvaT4mbmJzcDtcXG4gICAgICAgICAgICAgICAgPGEgb24tdGFwPVxcXCJ3aW5kb3cub3Blbigne3t1c2VyLmpzb25fbWV0YWRhdGEucHJvZmlsZS53ZWJzaXRlfX0nLCAnX3N5c3RlbScpO1xcXCIgc3R5bGU9XFxcImNvbG9yOndoaXRlIWltcG9ydGFudDt0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXFwiPldlYlNpdGU8L2E+XFxuICAgICAgICAgICAgICAgICZuYnNwO1xcbiAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPHNwYW4gbmctaWY9XFxcInVzZXIuY3JlYXRlZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJpY29uIGlvbi1jYWxlbmRhclxcXCI+PC9pPiZuYnNwO1xcbiAgICAgICAgICAgICAgICB7e3VzZXIuY3JlYXRlZHxkYXRlfX1cXG4gICAgICAgICAgICAgICAgJm5ic3A7XFxuICAgICAgICAgICAgICA8L3NwYW4+PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImhhcy1teXN1YmhlYWRlclxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJib3ggYmx1ZVxcXCIgbmctaWY9XFxcImFjdGl2ZSE9J3dhbGxldCd8fGFjdGl2ZSE9J3Blcm1pc3Npb25zJ1xcXCI+XFxuICAgICAgICAgIDxwIGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1pZj1cXFwibm9uZXhpc3RcXFwiPnt7J05PVEhJTkdfSEVSRSd8dHJhbnNsYXRlfX08L3A+XFxuICAgICAgICAgIDxpb24tbGlzdD5cXG4gICAgICAgICAgICA8IS0tPGRpdiBuZy1yZXBlYXQ9XFxcIihrZXksIHBsYXlsaXN0KSBpbiBwcm9maWxlXFxcIiBjbGFzcz1cXFwiaXRlbSB3cmFwXFxcIiBvbi10YXA9XFxcIm9wZW4ocGxheWxpc3QpXFxcIj5cXG4gICAgICAgICAgICA8aDMgY2xhc3M9XFxcImJvbGRcXFwiPnt7cGxheWxpc3Qucm9vdF90aXRsZX19PC9oMz5cXG4gICAgICAgICAgICA8c3BhbiBuZy1iaW5kLWh0bWw9XFxcInBsYXlsaXN0LmJvZHkuc3Vic3RyaW5nKDAsMTAwKXxwYXJzZVVybFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2Pi0tPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIG5nLXJlcGVhdD1cXFwicGxheWxpc3QgaW4gZGF0YS5wcm9maWxlIHwgb3JkZXJCeTonLWNyZWF0ZWQnIHwgbGltaXRUbzoyNSB0cmFjayBieSAkaW5kZXhcXFwiIG5nLWNsYXNzPVxcXCJ7J2l0ZW0tdGh1bWJuYWlsLWxlZnQnOiBwbGF5bGlzdC5qc29uX21ldGFkYXRhLmltYWdlfVxcXCI+XFxuICAgICAgICAgICAgICA8aW1nIG5nLXNyYz1cXFwie3twbGF5bGlzdC5qc29uX21ldGFkYXRhLmltYWdlWzBdfX1cXFwiIG9uLXRhcD1cXFwib3BlbihwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC5qc29uX21ldGFkYXRhLmltYWdlXFxcIiBvbmVycm9yPVxcXCJ0aGlzLnNyYz0naW1nL25vaW1hZ2UucG5nJ1xcXCIvPlxcbiAgICAgICAgICAgICAgICA8ZGl2IG9uLXRhcD1cXFwib3BlbihwbGF5bGlzdClcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3cmFwXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aDI+PGkgY2xhc3M9XFxcImZhIGZhLW1vbmV5IHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwicGxheWxpc3QucHJvbW90ZWQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+PC9pPiA8aSBjbGFzcz1cXFwiZmEgZmEtZmlyZSBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcInBsYXlsaXN0LnBlcmNlbnRfc3RlZW1fZG9sbGFycyA9PT0gMFxcXCI+PC9pPnt7cGxheWxpc3Qucm9vdF90aXRsZX19PC9oMj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxwIG5nLWJpbmQtaHRtbD1cXFwicGxheWxpc3QuYm9keXxsaW1pdFRvOjUwfGxkb3RzfHBhcnNlVXJsXFxcIiBuZy1pZj1cXFwiYWN0aXZlIT0nYmxvZydcXFwiPjwvcD5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicG9zdGRldGFpbHNcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4mbmJzcDt7e3BsYXlsaXN0LmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7e3snQlknfHRyYW5zbGF0ZX19Jm5ic3A7PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtcGVyc29uXFxcIj48L2k+Jm5ic3A7e3twbGF5bGlzdC5hdXRob3J9fSZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7cGxheWxpc3QuYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgZ3JheSBwcm9maWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwicGxheWxpc3QuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBvbi10YXA9XFxcInVwdm90ZVBvc3QocGxheWxpc3QpXFxcIiBuZy1pZj1cXFwiIXBsYXlsaXN0LnVwdm90ZWRcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50LCBwbGF5bGlzdClcXFwiPjwvaT48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChwbGF5bGlzdClcXFwiIG5nLWlmPVxcXCJwbGF5bGlzdC51cHZvdGVkXFxcIj48L2k+Jm5ic3A7Jm5ic3A7PHNwYW4gb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbyhwbGF5bGlzdClcXFwiPnt7cGxheWxpc3QubmV0X3ZvdGVzfX08L3NwYW4+Jm5ic3A7Jm5ic3A7XFxuICAgICAgICAgICAgICAgICAgIDwhLS08aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtZG93biBmYS1sZ1xcXCIgb24tdGFwPVxcXCJkb3dudm90ZVBvc3QocGxheWxpc3QpXFxcIiBuZy1pZj1cXFwiIXBsYXlsaXN0LmRvd252b3RlZFxcXCI+PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS1kb3duIGZhLWxnIHBvc2l0aXZlXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QocGxheWxpc3QpXFxcIiBuZy1pZj1cXFwicGxheWxpc3QuZG93bnZvdGVkXFxcIj48L2k+LS0+PC9kaXY+XFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxwbGF5bGlzdClcXFwiPiZuYnNwOyA8Yj57eyRyb290LiRzdG9yYWdlLmN1cnJlbmN5fGdldEN1cnJlbmN5U3ltYm9sfX08L2I+IDxzcGFuIG5nLWlmPVxcXCJwbGF5bGlzdC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gPT09ICcwLjAwMCdcXFwiPjxkZWw+e3twbGF5bGlzdCB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvZGVsPjwvc3Bhbj48c3BhbiBuZy1pZj1cXFwicGxheWxpc3QubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj57e3BsYXlsaXN0IHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPjwvZGl2PlxcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+Jm5ic3A7IDxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGF0YnViYmxlc1xcXCI+PC9pPiZuYnNwO3t7cGxheWxpc3QuY2hpbGRyZW59fTwvZGl2PlxcbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCIgbmctaWY9XFxcInBsYXlsaXN0LmF1dGhvciE9PXVzZXIudXNlcm5hbWUgJiYgYWN0aXZlIT09J3JlY2VudC1yZXBsaWVzJ1xcXCI+Jm5ic3A7IDxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiPjwvaT48L2Rpdj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvaW9uLWxpc3Q+XFxuICAgICAgICAgIDxpb24taW5maW5pdGUtc2Nyb2xsIG9uLWluZmluaXRlPVxcXCJsb2FkbW9yZSgpXFxcIiBuZy1pZj1cXFwibW9yZURhdGFDYW5CZUxvYWRlZCgpXFxcIiBkaXN0YW5jZT1cXFwiMTUlXFxcIj48L2lvbi1pbmZpbml0ZS1zY3JvbGw+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWlmPVxcXCJhY3RpdmU9PSd0cmFuc2ZlcnMnXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImJvbGQgdXBwZXJjYXNlXFxcIj5cXG4gICAgICAgICAgICB7eydCQUxBTkNFUyd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1uYW1lfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfMSd8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YSB9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgICAgICB7e2FjY291bnRzLmJhbGFuY2UgfCBzdCB8IG51bWJlcn19IHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtNjdcXFwiPlxcbiAgICAgICAgICAgIHt7JHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1wb3dlcn19IDxicj48c3BhbiBjbGFzcz1cXFwiZ3JheSB3cmFwXFxcIj57eydQUk9GSUxFXzInfHRyYW5zbGF0ZTp0cmFuc2xhdGlvbkRhdGF9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgICAgICB7e2FjY291bnRzLnZlc3Rpbmdfc2hhcmVzIHwgc3AgfCBudW1iZXJ9fSB7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtcHVuaXR9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTY3XFxcIj5cXG4gICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtZG9sbGFyfX0gPGJyPjxzcGFuIGNsYXNzPVxcXCJncmF5IHdyYXBcXFwiPnt7J1BST0ZJTEVfMyd8dHJhbnNsYXRlOnRyYW5zbGF0aW9uRGF0YX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiPlxcbiAgICAgICAgICAgIHt7YWNjb3VudHMuc2JkX2JhbGFuY2UgfCBzYmQgfCBudW1iZXJ9fSB7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtZHVuaXR9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTY3XFxcIj5cXG4gICAgICAgICAgICB7eydFU1RJTUFURURfVkFMVUUnfHRyYW5zbGF0ZX19IDxicj48c3BhbiBjbGFzcz1cXFwiZ3JheSB3cmFwXFxcIj57eydQUk9GSUxFXzQnfHRyYW5zbGF0ZTp0cmFuc2xhdGlvbkRhdGF9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIj5cXG4gICAgICAgICAgICB7eyRyb290LiRzdG9yYWdlLmN1cnJlbmN5fGdldEN1cnJlbmN5U3ltYm9sfX0ge3thY2NvdW50cy52ZXN0aW5nX3NoYXJlcyB8IHNkOmFjY291bnRzLmJhbGFuY2U6YWNjb3VudHMuc2JkX2JhbGFuY2UgfCBudW1iZXJ9fVxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImJvbGRcXFwiPnt7J1RSQU5TQUNUSU9OX0hJU1RPUlknfHRyYW5zbGF0ZX19PC9wPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IGxpc3QtaW5zZXRcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiIG5nLXJlcGVhdD1cXFwidHIgaW4gdHJhbnNmZXJzIHwgb3JkZXJCeTonLVswXScgfCBsaW1pdFRvOjE1IHRyYWNrIGJ5ICRpbmRleFxcXCI+XFxuICAgICAgICAgICAgICA8c3Bhbj57e3RyWzFdLnRpbWVzdGFtcCB8IHRpbWVhZ299fSAtIHt7dHJbMV0ub3BbMF19fTwvc3Bhbj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nY29tbWVudF9yZXdhcmQnXFxcIj57e3RyWzFdLm9wWzFdLnNiZF9wYXlvdXR9fSB8IHt7dHJbMV0ub3BbMV0udmVzdGluZ19wYXlvdXR9fTwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdhdXRob3JfcmV3YXJkJ1xcXCIgY2xhc3M9XFxcIndyYXBcXFwiPnt7dHJbMV0ub3BbMV0uc2JkX3BheW91dH19IHwge3t0clsxXS5vcFsxXS5zdGVlbV9wYXlvdXR9fSB8IHt7dHJbMV0ub3BbMV0udmVzdGluZ19wYXlvdXR9fTwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdjdXJhdGlvbl9yZXdhcmQnXFxcIj57e3RyWzFdLm9wWzFdLnJld2FyZH19IHwge3t0clsxXS5vcFsxXS52ZXN0aW5nX3BheW91dH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3RyYW5zZmVyJ1xcXCI+e3t0clsxXS5vcFsxXS5hbW91bnR9fSB8IHt7dHJbMV0ub3BbMV0ubWVtb319PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2ludGVyZXN0J1xcXCI+e3t0clsxXS5vcFsxXS5pbnRlcmVzdH19PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3RyYW5zZmVyX3RvX3Zlc3RpbmcnXFxcIj57e3RyWzFdLm9wWzFdLmFtb3VudH19IHwge3t0clsxXS5vcFsxXS5tZW1vfX08L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nd2l0aGRyYXdfdmVzdGluZydcXFwiPnt7dHJbMV0ub3BbMV0udmVzdGluZ19zaGFyZXN9fSB8IHt7dHJbMV0ub3BbMV0ubWVtb319PC9kaXY+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSdjb21tZW50X3Jld2FyZCdcXFwiPkB7e3RyWzFdLm9wWzFdLmF1dGhvcn19L3t7dHJbMV0ub3BbMV0ucGVybWxpbmt9fTwvcD5cXG4gICAgICAgICAgICAgIDxwIG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J2F1dGhvcl9yZXdhcmQnXFxcIiBjbGFzcz1cXFwid3JhcFxcXCI+QHt7dHJbMV0ub3BbMV0uYXV0aG9yfX0ve3t0clsxXS5vcFsxXS5wZXJtbGlua319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0nY3VyYXRpb25fcmV3YXJkJ1xcXCIgY2xhc3M9XFxcIndyYXBcXFwiPkB7e3RyWzFdLm9wWzFdLmNvbW1lbnRfYXV0aG9yfX0ve3t0clsxXS5vcFsxXS5jb21tZW50X3Blcm1saW5rfX08L3A+XFxuICAgICAgICAgICAgICA8cCBuZy1pZj1cXFwidHJbMV0ub3BbMF09PSd0cmFuc2ZlcidcXFwiPnt7dHJbMV0ub3BbMV0uZnJvbX19IHt7J1RPJ3x0cmFuc2xhdGV9fSAge3t0clsxXS5vcFsxXS50b319PC9wPlxcbiAgICAgICAgICAgICAgPHAgbmctaWY9XFxcInRyWzFdLm9wWzBdPT0ndHJhbnNmZXJfdG9fdmVzdGluZydcXFwiPiB7e3RyWzFdLm9wWzFdLmZyb219fSB7eydUTyd8dHJhbnNsYXRlfX0gIHt7dHJbMV0ub3BbMV0udG99fTwvcD5cXG4gICAgICAgICAgICAgIDxwIG5nLWlmPVxcXCJ0clsxXS5vcFswXT09J3dpdGhkcmF3X3Zlc3RpbmcnXFxcIj57e3RyWzFdLm9wWzFdLmFjY291bnR9fTwvcD5cXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJveCBwaW5rXFxcIiBuZy1pZj1cXFwiYWN0aXZlPT0ncGVybWlzc2lvbnMnXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGlzdCBjYXJkXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIj5cXG4gICAgICAgICAgICAgIDxoMj48ZGl2IGNsYXNzPVxcXCJib2xkXFxcIj57eydQT1NUSU5HJ3x0cmFuc2xhdGV9fTwvZGl2PjwvaDI+XFxuICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwid3JhcFxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzWzBdWzBdfX08L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgPGNlbnRlcj48cXJjb2RlIGNsYXNzPVxcXCJmdWxsLWltYWdlXFxcIiB0ZXh0PVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNbMF1bMF19fVxcXCI+PC9xcmNvZGU+PC9jZW50ZXI+XFxuICAgICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgICAge3snUFJPRklMRV81J3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgPGgyPjxkaXYgY2xhc3M9XFxcImJvbGRcXFwiPnt7J09XTkVSJ3x0cmFuc2xhdGV9fTwvZGl2PjwvaDI+XFxuICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwid3JhcFxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLm93bmVyLmtleV9hdXRoc1swXVswXX19PC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1ib2R5XFxcIj5cXG4gICAgICAgICAgICAgIDxjZW50ZXI+PHFyY29kZSBjbGFzcz1cXFwiZnVsbC1pbWFnZVxcXCIgdGV4dD1cXFwie3skcm9vdC4kc3RvcmFnZS51c2VyLm93bmVyLmtleV9hdXRoc1swXVswXX19XFxcIj48L3FyY29kZT48L2NlbnRlcj5cXG4gICAgICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgICAgICB7eydQUk9GSUxFXzYnfHRyYW5zbGF0ZX19XFxuICAgICAgICAgICAgICA8L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbVxcXCI+XFxuICAgICAgICAgICAgICA8aDI+PGRpdiBjbGFzcz1cXFwiYm9sZFxcXCI+e3snQUNUSVZFJ3x0cmFuc2xhdGV9fTwvZGl2PjwvaDI+XFxuICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwid3JhcFxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNbMF1bMF19fTwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtIGl0ZW0tYm9keVxcXCI+XFxuICAgICAgICAgICAgICA8Y2VudGVyPjxxcmNvZGUgY2xhc3M9XFxcImZ1bGwtaW1hZ2VcXFwiIHRleHQ9XFxcInt7JHJvb3QuJHN0b3JhZ2UudXNlci5hY3RpdmUua2V5X2F1dGhzWzBdWzBdfX1cXFwiPjwvcXJjb2RlPjwvY2VudGVyPlxcbiAgICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICAgIHt7J1BST0ZJTEVfNyd8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpdGVtXFxcIj5cXG4gICAgICAgICAgICAgIDxoMj48ZGl2IGNsYXNzPVxcXCJib2xkXFxcIj57eydNRU1PJ3x0cmFuc2xhdGV9fTwvZGl2PjwvaDI+XFxuICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwid3JhcFxcXCI+e3skcm9vdC4kc3RvcmFnZS51c2VyLm1lbW9fa2V5fX08L3A+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgPGNlbnRlcj48cXJjb2RlIGNsYXNzPVxcXCJmdWxsLWltYWdlXFxcIiB0ZXh0PVxcXCJ7eyRyb290LiRzdG9yYWdlLnVzZXIubWVtb19rZXl9fVxcXCI+PC9xcmNvZGU+PC9jZW50ZXI+XFxuICAgICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgICAge3snUFJPRklMRV84J3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyUFRyLmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICAgIDxpb24tcG9wb3Zlci12aWV3IGNsYXNzPVxcXCJkZXRhaWxlZFBvc3RcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJwYWRkaW5nXFxcIiBuZy1iaW5kLWh0bWw9XFxcInRvb2x0aXBUZXh0XFxcIj48L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gICAgPHNjcmlwdCBpZCA9IFxcXCJwb3BvdmVyU2xpZGVycnAuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkU2xpZGVcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMFxcXCI+PGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnXFxcIiBvbi10YXA9XFxcInZvdGVQb3N0UygpXFxcIj48L2J1dHRvbj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3MgPSBcXFwiaXRlbSByYW5nZSByYW5nZS1wb3NpdGl2ZVxcXCI+XFxuICAgICAgICAgICAgIHt7cmFuZ2VWYWx1ZX19IDxpbnB1dCB0eXBlPVxcXCJyYW5nZVxcXCIgbmFtZT1cXFwicmFuZ2UyXFxcIiBtaW49XFxcIjFcXFwiIG1heD1cXFwiMTAwXFxcIiBuZy1tb2RlbD1cXFwicmFuZ2VWYWx1ZVxcXCIgbmctY2hhbmdlPVxcXCJkcmFnKHJhbmdlVmFsdWUpXFxcIj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTBcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tY2xvc2Utcm91bmRcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVNsaWRlcigpXFxcIj48L2J1dHRvbj48L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICA8L2lvbi1jb250ZW50PlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvZmlsZSBiYXIgYmFyLWZvb3RlclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbi1iYXJcXFwiPlxcbiAgICAgIDwhLS08YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1sYXJnZSBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24taW9zLWhlYXJ0XFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J2ZlZWQnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ2ZlZWQnKVxcXCI+Jm5ic3A7RmVlZHM8L2E+LS0+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tbGFyZ2UgYnV0dG9uLXBvc2l0aXZlIGljb24gaW9uLWNvbXBvc2VcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0nYmxvZyd9XFxcIiBvbi10YXA9XFxcImNoYW5nZSgnYmxvZycpXFxcIj4mbmJzcDt7eydCTE9HJ3x0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8YSBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1wb3NpdGl2ZSBpY29uIGlvbi1kb2N1bWVudC10ZXh0XFxcIiBuZy1jbGFzcz1cXFwieydhY3RpdmUnOmFjdGl2ZT09J3Bvc3RzJ31cXFwiIG9uLXRhcD1cXFwiY2hhbmdlKCdwb3N0cycpXFxcIj4mbmJzcDt7eydQT1NUUyd8dHJhbnNsYXRlfX08L2E+XFxuICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgaWNvbiBpb24tY2hhdGJ1YmJsZXNcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ncmVjZW50LXJlcGxpZXMnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ3JlY2VudC1yZXBsaWVzJylcXFwiPiZuYnNwO3t7J1JFUExJRVMnfHRyYW5zbGF0ZX19PC9hPlxcbiAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlIGljb24gaW9uLWNhcmRcXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ndHJhbnNmZXJzJ31cXFwiICBvbi10YXA9XFxcImNoYW5nZSgndHJhbnNmZXJzJylcXFwiPiZuYnNwO3t7J1dBTExFVCd8dHJhbnNsYXRlfX08L2E+XFxuICAgICAgPCEtLTxhIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXJveWFsIGljb24gaW9uLWxvY2stY29tYmluYXRpb25cXFwiIG5nLWNsYXNzPVxcXCJ7J2FjdGl2ZSc6YWN0aXZlPT0ncGVybWlzc2lvbnMnfVxcXCIgb24tdGFwPVxcXCJjaGFuZ2UoJ3Blcm1pc3Npb25zJylcXFwiPktleXM8L2E+LS0+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuICA8c2NyaXB0IGlkPVxcXCJteS1lZGl0Lmh0bWxcXFwiIHR5cGU9XFxcInRleHQvbmctdGVtcGxhdGVcXFwiPlxcbiAgICA8aW9uLW1vZGFsLXZpZXc+XFxuICAgICAgPGlvbi1oZWFkZXItYmFyIGNsYXNzPSdiYXItcG9zaXRpdmUnPlxcbiAgICAgICAgIDxoMSBjbGFzcz1cXFwidGl0bGVcXFwiPnt7XFxcIkVESVRcXFwifHRyYW5zbGF0ZX19PC9oMT5cXG4gICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWNsZWFyIGJ1dHRvbi1vdXRsaW5lXFxcIiBuZy1jbGljaz1cXFwiY2xvc2VFZGl0cygpXFxcIj5cXG4gICAgICAgICAge3tcXFwiQ0FOQ0VMXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgICAgPC9idXR0b24+XFxuICAgICAgPC9pb24taGVhZGVyLWJhcj5cXG4gICAgICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1oZWFkZXJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibGlzdFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIml0ZW0gaXRlbS1kaXZpZGVyXFxcIj5cXG4gICAgICAgICAgICB7e1xcXCJQUk9GSUxFXFxcInx0cmFuc2xhdGV9fVxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snQUJPVVQnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDx0ZXh0YXJlYSBwbGFjZWhvbGRlcj1cXFwie3snQUJPVVQnfHRyYW5zbGF0ZX19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5wcm9maWxlLmFib3V0XFxcIj48L3RleHRhcmVhPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydMT0NBVElPTid8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydMT0NBVElPTid8dHJhbnNsYXRlfX1cXFwiIG5nLW1vZGVsPVxcXCJlZGl0LnByb2ZpbGUubG9jYXRpb25cXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydESVNQTEFZX05BTUUnfHRyYW5zbGF0ZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwie3snRElTUExBWV9OQU1FJ3x0cmFuc2xhdGV9fVxcXCIgbmctbW9kZWw9XFxcImVkaXQucHJvZmlsZS5uYW1lXFxcIj5cXG4gICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJpdGVtIGl0ZW0taW5wdXRcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpbnB1dC1sYWJlbFxcXCI+e3snV0VCU0lURSd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydXRUJTSVRFJ3x0cmFuc2xhdGV9fVxcXCIgbmctbW9kZWw9XFxcImVkaXQucHJvZmlsZS53ZWJzaXRlXFxcIj5cXG4gICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiaXRlbSBpdGVtLWRpdmlkZXJcXFwiPlxcbiAgICAgICAgICAgIHt7XFxcIkVTQ1JPV1xcXCJ8dHJhbnNsYXRlfX1cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwiaXRlbSBpdGVtLWlucHV0XFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaW5wdXQtbGFiZWxcXFwiPnt7J0VTQ1JPV19URVJNUyd8dHJhbnNsYXRlfX08L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eydFU0NST1dfVEVSTVMnfHRyYW5zbGF0ZX19XFxcIiBuZy1tb2RlbD1cXFwiZWRpdC5lc2Nyb3cudGVybXNcXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydFU0NST1dfRkVFJ3x0cmFuc2xhdGV9fSA8L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtbHVuaXR9fVxcXCIgbmctbW9kZWw9XFxcImVkaXQuZXNjcm93LmZlZXNbJHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdF1cXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIml0ZW0gaXRlbS1pbnB1dFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlucHV0LWxhYmVsXFxcIj57eydFU0NST1dfRkVFJ3x0cmFuc2xhdGV9fSA8L3NwYW4+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJ7eyRyb290LiRzdG9yYWdlLnBsYXRmb3JtZHVuaXR9fVxcXCIgbmctbW9kZWw9XFxcImVkaXQuZXNjcm93LmZlZXNbJHJvb3QuJHN0b3JhZ2UucGxhdGZvcm1kdW5pdF1cXFwiPlxcbiAgICAgICAgICA8L2xhYmVsPjxicj5cXG4gICAgICAgICAgPGNlbnRlcj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLXBvc2l0aXZlXFxcIiBuZy1jbGljaz1cXFwic2F2ZUVkaXQoKVxcXCI+XFxuICAgICAgICAgICAge3snU0FWRV9DSEFOR0VTJ3x0cmFuc2xhdGV9fVxcbiAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8L2NlbnRlcj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8L2lvbi1jb250ZW50PlxcbiAgICA8L2lvbi1tb2RhbC12aWV3PlxcblxcbiAgPC9zY3JpcHQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogXCJQcm9maWxlQ3RybFwiXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLnBvc3RzJywge1xuICAgIHVybDogJy9wb3N0cy86dGFncy86cmVuZXcnLFxuICAgIHBhcmFtczoge3JlbmV3OiB0cnVlfSxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3RzLmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy1jYWNoZT1cXFwiZmFsc2VcXFwiPlxcblxcdDxpb24tbmF2LWJhciBjbGFzcz1cXFwiYmFyLXBvc2l0aXZlXFxcIj5cXG5cXHRcXHQ8aW9uLW5hdi1iYWNrLWJ1dHRvbj5cXG4gIFxcdFxcdDwvaW9uLW5hdi1iYWNrLWJ1dHRvbj5cXG5cXHQgICAgPGlvbi1uYXYtYnV0dG9ucyBzaWRlPVxcXCJsZWZ0XFxcIj5cXG5cXHQgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gYnV0dG9uLWNsZWFyIGlvbi1uYXZpY29uXFxcIiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPjwvYnV0dG9uPlxcblxcdCAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXIgaW9uLW5hdmljb25cXFwiIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiIG1lbnUtdG9nZ2xlPVxcXCJsZWZ0XFxcIj57eydNRU5VJ3x0cmFuc2xhdGV9fTwvYT5cXG5cXHQgICAgPC9pb24tbmF2LWJ1dHRvbnM+XFxuXFx0ICAgIDxpb24tbmF2LXRpdGxlIG9uLXRhcD1cXFwic2hvd0ZpbHRlcigpXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+e3skcm9vdC4kc3RvcmFnZS5maWx0ZXJOYW1lfX0ge3skcm9vdC4kc3RvcmFnZS50YWd9fSAmZW1zcDsgPGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LWRvd24tYlxcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgPC9pb24tbmF2LXRpdGxlPlxcblxcdCAgICA8aW9uLW5hdi1idXR0b25zIHNpZGU9XFxcInJpZ2h0XFxcIj5cXG5cXHQgICAgICA8IS0tPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uXFxcIiBvbi10YXA9XFxcInRlc3RmdW5jdGlvbigpXFxcIj5UZXN0PC9idXR0b24+LS0+XFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGlvbi1tb3JlXFxcIiBuZy1pZj1cXFwiISRyb290LnZvaWNlT3ZlclxcXCIgb24tdGFwPVxcXCJvcGVuTWVudVBvcG92ZXIoJGV2ZW50KVxcXCI+PC9idXR0b24+XFxuXFx0ICAgICAgPGEgaHJlZiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGlvbi1tb3JlXFxcIiBvbi10YXA9XFxcIm9wZW5NZW51UG9wb3ZlcigkZXZlbnQpXFxcIiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj57eydPUFRJT05TJ3x0cmFuc2xhdGV9fTwvYT5cXG5cXHQgICAgPC9pb24tbmF2LWJ1dHRvbnM+XFxuXFx0PC9pb24tbmF2LWJhcj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCIgc2Nyb2xsPVxcXCJ0cnVlXFxcIiBkZWxlZ2F0ZS1oYW5kbGU9XFxcIm1haW5TY3JvbGxcXFwiIG92ZXJmbG93LXNjcm9sbD1cXFwidHJ1ZVxcXCIgbmctY2xhc3M9XFxcInsndGhlbWUtZGFyayc6JHJvb3QuJHN0b3JhZ2UudGhlbWUgPT0gJ25pZ2h0J31cXFwiPlxcblxcdFxcdDxpb24tcmVmcmVzaGVyIHB1bGxpbmctdGV4dD1cXFwie3snUFVMTF9ET1dOX1RPX1JFRlJFU0gnfHRyYW5zbGF0ZX19XFxcIiBvbi1yZWZyZXNoPVxcXCJyZWZyZXNoKClcXFwiPlxcbiAgXFx0PC9pb24tcmVmcmVzaGVyPlxcbiAgXFx0XFx0PGRpdiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uudmlldz09J2NvbXBhY3QnICYmIGRhdGEubGVuZ3RoPjBcXFwiIGNsYXNzPVxcXCJtYXNvbnJ5LWxheW91dFxcXCI+XFxuXFx0ICAgIFxcdDxkaXYgbmctcmVwZWF0PVxcXCJkIGluIGRhdGEgfCByZWdleDonY2F0ZWdvcnknOidibS4qJyB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJtYXNvbnJ5LWxheW91dF9fcGFuZWxcXFwiPlxcblxcdCAgICBcXHQgICA8ZGl2IGNsYXNzPVxcXCJsaXN0IG1hc29ucnktbGF5b3V0X19wYW5lbC1jb250ZW50XFxcIiBuZy1jbGFzcz1cXFwieyd0aGVtZS1kYXJrJzokcm9vdC4kc3RvcmFnZS50aGVtZSA9PSAnbmlnaHQnfVxcXCI+XFxuXFx0XFx0ICAgIFxcdDxkaXYgY2xhc3M9XFxcIml0ZW1cXFwiPlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IG9uLXRhcD1cXFwib3BlbihkKVxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgIDxzcGFuIG5nLWlmPVxcXCJkLnJlYmxvZ2dlZF9ieS5sZW5ndGg+MFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFycm93LXJldHVybi1yaWdodFxcXCI+PC9pPiB7eydSRVNURUVNRURfQlknfHRyYW5zbGF0ZX19IHt7ZC5yZWJsb2dnZWRfYnl9fTwvc3Bhbj5cXG5cXHRcXHRcXHRcXHQgICAgPHA+PGgyIGNsYXNzPVxcXCJ3cmFwd29yZFxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLW1vbmV5IHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiZC5wcm9tb3RlZC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj48L2k+IDxpIGNsYXNzPVxcXCJmYSBmYS1maXJlIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiZC5wZXJjZW50X3N0ZWVtX2RvbGxhcnMgPT09IDBcXFwiPjwvaT4ge3tkLnRpdGxlfX08L2gyPjwvcD5cXG5cXHRcXHRcXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2QuY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydCWSd8dHJhbnNsYXRlfX0mbmJzcDs8Yj57e2QuYXV0aG9yfX08L2I+Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3tkLmF1dGhvcl9yZXB1dGF0aW9ufHJlcHV0YXRpb258bnVtYmVyOjB9fTwvZGl2PiB7eydJTid8dHJhbnNsYXRlfX0ge3tkLmNhdGVnb3J5fGRldHJhbnNsaXRlcmF0ZTpmYWxzZX19ICZtaWRkb3Q7IHt7ZC5ib2R5fHJlYWRpbmd0aW1lfX0ge3snTUlOX1JFQUQnfHRyYW5zbGF0ZX19PC9kaXY+PC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcdFxcdFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxzcGFuIG5nLWlmPVxcXCIhJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcIiFkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZClcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXIoJGV2ZW50LCBkKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+PC9hPjxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiZC51cHZvdGVkXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QoZClcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZC5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQ8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhZC5pbnZvdGluZ1xcXCI+PC9pPjwvYT4mbmJzcDs8c3BhbiBjbGFzcz1cXFwiZ3JheVxcXCIgb24tdGFwPVxcXCJvcGVuVG9vbHRpcCgkZXZlbnQsZClcXFwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcImQubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdID09PSAnMC4wMDAnXFxcIj48ZGVsPjAuMDAwPC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJkLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSAhPT0gJzAuMDAwJ1xcXCI+e3tkIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPjwvc3Bhbj48L3NwYW4+XFxuXFx0XFx0XFx0XFx0ICAgICAgPHNwYW4gbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCI+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCIhZC51cHZvdGVkXFxcIiBvbi10YXA9XFxcInZvdGVQb3N0KGQpXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVyKCRldmVudCwgZClcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZC5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG5nLWlmPVxcXCIhZC5pbnZvdGluZ1xcXCI+PC9pPnt7J1VQVk9URSd8dHJhbnNsYXRlfX08L2E+PGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG5nLWlmPVxcXCJkLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChkKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZyBwb3NpdGl2ZVxcXCIgbmctaWY9XFxcIiFkLmludm90aW5nXFxcIj48L2k+e3snVU5WT1RFJ3x0cmFuc2xhdGV9fTwvYT4mbmJzcDs8c3BhbiBjbGFzcz1cXFwiZ3JheVxcXCIgb24tdGFwPVxcXCJvcGVuVG9vbHRpcCgkZXZlbnQsZClcXFwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcImQubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdID09PSAnMC4wMDAnXFxcIj48ZGVsPnt7ZCB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvZGVsPjwvc3Bhbj48c3BhbiBuZy1pZj1cXFwiZC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPnt7ZCB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvc3Bhbj48L3NwYW4+PC9zcGFuPlxcblxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdCAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMjUgdHJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbyhkKVxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLXBlcnNvbi1zdGFsa2VyXFxcIj48L2k+Jm5ic3A7e3tkLm5ldF92b3Rlc319PC9hPlxcblxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdCAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMjUgdHJpZ2h0XFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWNoYXRidWJibGVzXFxcIj48L2k+Jm5ic3A7e3tkLmNoaWxkcmVufX08L2E+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0xMCB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBvbi10YXA9XFxcIiRyb290LnJlQmxvZyhzLmF1dGhvciwgcy5wZXJtbGluaylcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiPjwvaT4mbmJzcDs8L2E+XFxuXFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0ICAgIDwvZGl2PlxcblxcdFxcdFxcdCAgXFx0PC9kaXY+XFxuXFx0XFx0XFx0ICA8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS52aWV3PT0nY2FyZCcgJiYgZGF0YS5sZW5ndGg+MFxcXCIgY2xhc3M9XFxcIm1hc29ucnktbGF5b3V0XFxcIj5cXG5cXHRcXHRcXHQ8ZGl2IG5nLXJlcGVhdD1cXFwiZHMgaW4gZGF0YSB8IHJlZ2V4OidjYXRlZ29yeSc6J2JtLionIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcIm1hc29ucnktbGF5b3V0X19wYW5lbFxcXCI+XFxuXFx0ICAgIFxcdCAgIDxkaXYgY2xhc3M9XFxcImxpc3QgY2FyZCBtYXNvbnJ5LWxheW91dF9fcGFuZWwtY29udGVudFxcXCIgbmctaWY9XFxcImRzXFxcIiBuZy1jbGFzcz1cXFwieyd0aGVtZS1kYXJrJzokcm9vdC4kc3RvcmFnZS50aGVtZSA9PSAnbmlnaHQnfVxcXCI+XFxuXFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaXRlbVxcXCIgb24tdGFwPVxcXCJvcGVuKGRzKVxcXCIgbmctY2xhc3M9XFxcInsndGhlbWUtZGFyayc6JHJvb3QuJHN0b3JhZ2UudGhlbWUgPT0gJ25pZ2h0J31cXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxzcGFuIG5nLWlmPVxcXCJkcy5yZWJsb2dnZWRfYnkubGVuZ3RoPjBcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hcnJvdy1yZXR1cm4tcmlnaHRcXFwiPjwvaT4ge3snUkVTVEVFTUVEX0JZJ3x0cmFuc2xhdGV9fSB7e2RzLnJlYmxvZ2dlZF9ieX19PC9zcGFuPlxcblxcdFxcdFxcdFxcdCAgICA8aDIgY2xhc3M9XFxcIndyYXB3b3JkXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtbW9uZXkgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCJkcy5wcm9tb3RlZC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj48L2k+IDxpIGNsYXNzPVxcXCJmYSBmYS1maXJlIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiZHMucGVyY2VudF9zdGVlbV9kb2xsYXJzID09PSAwXFxcIj48L2k+IHt7ZHMudGl0bGV9fTwvaDI+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB3cmFwXFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4ge3tkcy5jcmVhdGVkfHRpbWVhZ299fSZuYnNwO3t7J0JZJ3x0cmFuc2xhdGV9fSZuYnNwOzxiPnt7ZHMuYXV0aG9yfX08L2I+Jm5ic3A7PGRpdiBjbGFzcz1cXFwicmVwdXRhdGlvblxcXCI+e3tkcy5hdXRob3JfcmVwdXRhdGlvbnxyZXB1dGF0aW9ufG51bWJlcjowfX08L2Rpdj4ge3snSU4nfHRyYW5zbGF0ZX19IHt7ZHMuY2F0ZWdvcnl8ZGV0cmFuc2xpdGVyYXRlOmZhbHNlfX0gJm1pZGRvdDsge3tkcy5ib2R5fHJlYWRpbmd0aW1lfX0ge3snTUlOX1JFQUQnfHRyYW5zbGF0ZX19PC9kaXY+PC9kaXY+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaXRlbS1ib2R5XFxcIj5cXG5cXHRcXHRcXHRcXHQgICAgPGltZyBjbGFzcz1cXFwiZnVsbC1pbWFnZVxcXCIgbmctc3JjPVxcXCJ7e2RzLmpzb25fbWV0YWRhdGEuaW1hZ2VbMF19fVxcXCIgb24tdGFwPVxcXCJvcGVuKGRzKVxcXCIgbmctaWY9XFxcImRzLmpzb25fbWV0YWRhdGEuaW1hZ2VbMF1cXFwiIG9uZXJyb3I9XFxcInRoaXMuc3JjPSdpbWcvbm9pbWFnZS5wbmcnXFxcIi8+XFxuXFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiIWRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3QoZHMpXFxcIiBvbi1ob2xkPVxcXCJvcGVuU2xpZGVyKCRldmVudCwgZHMpXFxcIj48aW9uLXNwaW5uZXIgbmctaWY9XFxcImRzLmludm90aW5nXFxcIj48L2lvbi1zcGlubmVyPjxpIGNsYXNzPVxcXCJmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgbmctaWY9XFxcIiFkcy5pbnZvdGluZ1xcXCI+PC9pPjwvYT48YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcImRzLnVwdm90ZWRcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdChkcylcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiZHMuaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnIHBvc2l0aXZlXFxcIiBuZy1pZj1cXFwiIWRzLmludm90aW5nXFxcIj48L2k+PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkcylcXFwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcImRzLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSA9PT0gJzAuMDAwJ1xcXCI+PGRlbD57e2RzIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVxcXCJkcy5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KCcgJylbMF0gIT09ICcwLjAwMCdcXFwiPnt7ZHMgfCBzdW1Qb3N0VG90YWw6JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3lSYXRlIHwgbnVtYmVyfX08L3NwYW4+PC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwic3ViZHVlZFxcXCIgbmctaWY9XFxcIiFkcy51cHZvdGVkXFxcIiBvbi10YXA9XFxcInZvdGVQb3N0KGRzKVxcXCIgb24taG9sZD1cXFwib3BlblNsaWRlcigkZXZlbnQsIGRzKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkcy5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG5nLWlmPVxcXCIhZHMuaW52b3RpbmdcXFwiPjwvaT57eydVUFZPVEUnfHRyYW5zbGF0ZX19PC9hPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBuZy1pZj1cXFwiZHMudXB2b3RlZFxcXCIgb24tdGFwPVxcXCJ1bnZvdGVQb3N0KGRzKVxcXCI+PGlvbi1zcGlubmVyIG5nLWlmPVxcXCJkcy5pbnZvdGluZ1xcXCI+PC9pb24tc3Bpbm5lcj48aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGcgcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIhZHMuaW52b3RpbmdcXFwiPjwvaT57eydVTlZPVEUnfHRyYW5zbGF0ZX19PC9hPiZuYnNwOzxzcGFuIGNsYXNzPVxcXCJncmF5XFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCxkcylcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdDxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4gPHNwYW4gbmctaWY9XFxcImRzLm1heF9hY2NlcHRlZF9wYXlvdXQuc3BsaXQoJyAnKVswXSA9PT0gJzAuMDAwJ1xcXCI+PGRlbD4wLjAwMDwvZGVsPjwvc3Bhbj48c3BhbiBuZy1pZj1cXFwiZHMubWF4X2FjY2VwdGVkX3BheW91dC5zcGxpdCgnICcpWzBdICE9PSAnMC4wMDAnXFxcIj57e2RzIHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9zcGFuPjwvc3Bhbj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8L3NwYW4+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPC9kaXY+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0yNSB0cmlnaHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJzdWJkdWVkXFxcIiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKGRzKVxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLXBlcnNvbi1zdGFsa2VyXFxcIj48L2k+Jm5ic3A7e3tkcy5uZXRfdm90ZXN9fTwvYT5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTI1IHRyaWdodFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1jaGF0YnViYmxlc1xcXCI+PC9pPiZuYnNwO3t7ZHMuY2hpbGRyZW59fTwvYT5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHQgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwIHRyaWdodFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0ICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInN1YmR1ZWRcXFwiIG9uLXRhcD1cXFwiJHJvb3QucmVCbG9nKGRzLmF1dGhvciwgZHMucGVybWxpbmspXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYXJyb3ctcmV0dXJuLXJpZ2h0XFxcIj48L2k+Jm5ic3A7PC9hPlxcblxcdFxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdCAgICAgIDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcbiAgICA8aW9uLWluZmluaXRlLXNjcm9sbCBuZy1pZj1cXFwibW9yZURhdGFDYW5CZUxvYWRlZCgpXFxcIiBvbi1pbmZpbml0ZT1cXFwibG9hZE1vcmUoKVxcXCIgZGlzdGFuY2U9XFxcIjE1JVxcXCI+PC9pb24taW5maW5pdGUtc2Nyb2xsPlxcbiAgICA8YnI+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3ZlclQuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkUG9zdFxcXCI+XFxuICAgICAgICA8aW9uLWNvbnRlbnQ+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInBhZGRpbmdcXFwiIG5nLWJpbmQtaHRtbD1cXFwidG9vbHRpcFRleHRcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9pb24tY29udGVudD5cXG4gICAgICA8L2lvbi1wb3BvdmVyLXZpZXc+XFxuICAgIDwvc2NyaXB0PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJTbGlkZXIuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkU2xpZGVcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50PlxcbiAgICAgICAgICBcXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgICAgICBcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG9uLXRhcD1cXFwidm90ZVBvc3RTKClcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICBcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgICBcXHRcXHRcXHQ8ZGl2IGNsYXNzID0gXFxcIml0ZW0gcmFuZ2UgcmFuZ2UtcG9zaXRpdmVcXFwiPlxcblxcdFxcdFxcdFxcdFxcdCAgIHt7cmFuZ2VWYWx1ZX19IDxpbnB1dCB0eXBlPVxcXCJyYW5nZVxcXCIgbmFtZT1cXFwicmFuZ2UxXFxcIiBtaW49XFxcIjFcXFwiIG1heD1cXFwiMTAwXFxcIiBuZy1tb2RlbD1cXFwicmFuZ2VWYWx1ZVxcXCIgbmctY2hhbmdlPVxcXCJkcmFnKHJhbmdlVmFsdWUpXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG4gICAgICAgICAgXFx0XFx0PC9kaXY+XFxuICAgICAgICAgIFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTBcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tY2xvc2Utcm91bmRcXFwiIG5nLWNsaWNrPVxcXCJjbG9zZVNsaWRlcigpXFxcIj48L2J1dHRvbj48L2Rpdj5cXG4gICAgICAgICAgXFx0PC9kaXY+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICA8L2lvbi1jb250ZW50PlxcbjwvaW9uLXZpZXc+XFxuXCIsXG4gICAgICAgIGNvbnRyb2xsZXI6ICdQb3N0c0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC5zdGF0ZSgnYXBwLmJvb2ttYXJrJywge1xuICAgIHVybDogJy9ib29rbWFyaycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9wb3N0Lmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy10aXRsZT1cXFwie3snQk9PS01BUktTJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5ib29rbWFya1xcXCIgY2FuLXN3aXBlPVxcXCJ0cnVlXFxcIj5cXG4gIFxcdFxcdDxpb24taXRlbSBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gJHJvb3QuJHN0b3JhZ2UuYm9va21hcmtcXFwiIG5nLWNsaWNrPVxcXCIkcm9vdC5nZXRDb250ZW50QW5kT3BlbihpdGVtKVxcXCI+XFxuXFx0XFx0ICAgIDxwPjxoMj57e2l0ZW0uYXV0aG9yfX08L2gyPjwvcD5cXG4gICAgICAgIDxwPnt7aXRlbS5wZXJtbGlua319PC9wPlxcblxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgdHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2l0ZW0uY3JlYXRlZHx0aW1lYWdvfX08L2Rpdj48L2Rpdj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlQm9va21hcmsoJGluZGV4KVxcXCI+e3snUkVNT1ZFJyB8IHRyYW5zbGF0ZX19XFxuXFx0XFx0ICAgIDwvaW9uLW9wdGlvbi1idXR0b24+XFxuICAgIFxcdDwvaW9uLWl0ZW0+XFxuICAgIDwvaW9uLWxpc3Q+XFxuICAgIDxwIGNsYXNzPVxcXCJ0Y2VudGVyIGdyYXkgcGFkZGluZ1xcXCIgbmctaWY9XFxcIiRyb290LiRzdG9yYWdlLmJvb2ttYXJrLmxlbmd0aD4wXFxcIj57eydTV0lQRV9MRUZUJ3x0cmFuc2xhdGV9fTwvcD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheSBwYWRkaW5nXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UuYm9va21hcmsubGVuZ3RoPT0wXFxcIj57eydOT1RISU5HX0hFUkUnfHRyYW5zbGF0ZX19PC9wPlxcblxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnQm9va21hcmtDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuXHQuc3RhdGUoJ2FwcC5kcmFmdHMnLCB7XG4gICAgdXJsOiAnL2RyYWZ0cycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9wb3N0Lmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy10aXRsZT1cXFwie3snRFJBRlRTJyB8IHRyYW5zbGF0ZX19XFxcIj5cXG4gIDxpb24tY29udGVudCBjbGFzcz1cXFwiaGFzLWhlYWRlclxcXCI+XFxuXFx0PGlvbi1saXN0IG5nLWlmPVxcXCJkcmFmdHNcXFwiIGNhbi1zd2lwZT1cXFwidHJ1ZVxcXCI+XFxuICBcXHRcXHQ8aW9uLWl0ZW0gbmctcmVwZWF0PVxcXCJpdGVtIGluIGRyYWZ0c1xcXCIgbmctY2xpY2s9XFxcIiRyb290Lm9wZW5EcmFmdChpdGVtKVxcXCI+XFxuXFx0XFx0ICAgIDxwPjxoMj57e2l0ZW0udGl0bGV9fTwvaDI+PC9wPlxcblxcdFxcdFxcdCAgICA8ZGl2IGNsYXNzPVxcXCJyb3cgcG9zdGRldGFpbHMgdHdyYXBcXFwiPjxkaXYgY2xhc3M9XFxcImNvbFxcXCI+PGkgY2xhc3M9XFxcImljb24gaW9uLWFuZHJvaWQtdGltZVxcXCI+PC9pPiB7e2l0ZW0uY3JlYXRlZHx0aW1lYWdvfX0mbmJzcDt7eydUQUdTJyB8IHRyYW5zbGF0ZX19OiZuYnNwOzxiPnt7aXRlbS50YWdzfX08L2I+PC9kaXY+PC9kaXY+XFxuXFx0XFx0ICAgIDxpb24tb3B0aW9uLWJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uLWFzc2VydGl2ZVxcXCIgbmctY2xpY2s9XFxcInJlbW92ZURyYWZ0KGl0ZW0uX2lkKVxcXCI+e3snUkVNT1ZFJyB8IHRyYW5zbGF0ZX19XFxuXFx0XFx0ICAgIDwvaW9uLW9wdGlvbi1idXR0b24+XFxuICAgIFxcdDwvaW9uLWl0ZW0+XFxuICAgIDwvaW9uLWxpc3Q+XFxuICAgIDxwIGNsYXNzPVxcXCJ0Y2VudGVyIGdyYXlcXFwiIG5nLWlmPVxcXCJkcmFmdHMubGVuZ3RoPjBcXFwiPnt7J1NXSVBFX0xFRlQnfHRyYW5zbGF0ZX19PC9wPlxcbiAgICA8cCBjbGFzcz1cXFwidGNlbnRlciBncmF5XFxcIiBuZy1pZj1cXFwiZHJhZnRzLmxlbmd0aD09MFxcXCI+e3snTk9USElOR19IRVJFJ3x0cmFuc2xhdGV9fTwvcD5cXG5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ0RyYWZ0c0N0cmwnXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG5cdC5zdGF0ZSgnYXBwLmltYWdlcycsIHtcbiAgICB1cmw6ICcvaW1hZ2VzJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJ7eydNQU5BR0UnIHwgdHJhbnNsYXRlfX0ge3snR0FMTEVSWScgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1oZWFkZXJcXFwiPlxcblxcdDxpb24tbGlzdCBuZy1pZj1cXFwiaW1hZ2VzXFxcIiBjYW4tc3dpcGU9XFxcInRydWVcXFwiPlxcbiAgXFx0XFx0PGlvbi1pdGVtIG5nLXJlcGVhdD1cXFwiaXRlbSBpbiBpbWFnZXNcXFwiIGNsYXNzPVxcXCJpdGVtLXRodW1ibmFpbC1sZWZ0XFxcIj5cXG4gICAgICAgIDxpbWcgbmctc3JjPVxcXCJ7e2l0ZW0udXJsfX1cXFwiLz5cXG4gICAgICAgIDxwPjxoMj57e2l0ZW0udXJsfX08L2gyPjwvcD5cXG5cXHRcXHRcXHQgIDxkaXYgY2xhc3M9XFxcInJvdyBwb3N0ZGV0YWlscyB0d3JhcFxcXCI+PGRpdiBjbGFzcz1cXFwiY29sXFxcIj48aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC10aW1lXFxcIj48L2k+IHt7aXRlbS5jcmVhdGVkfHRpbWVhZ299fSZuYnNwOzwvZGl2PjwvZGl2PlxcbiAgICAgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tYXNzZXJ0aXZlXFxcIiBuZy1jbGljaz1cXFwicmVtb3ZlSW1hZ2UoaXRlbS5faWQpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG5cXHRcXHQgICAgPGlvbi1vcHRpb24tYnV0dG9uIGNsYXNzPVxcXCJidXR0b24tY2FsbVxcXCIgbmctY2xpY2s9XFxcImNvcHlJbWFnZShpdGVtLnVybClcXFwiPnt7J0NPUFknIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gICAgPHAgY2xhc3M9XFxcInRjZW50ZXIgZ3JheVxcXCIgbmctaWY9XFxcImltYWdlcy5sZW5ndGg+MFxcXCI+e3snU1dJUEVfTEVGVCd8dHJhbnNsYXRlfX08L3A+XFxuICAgIDxwIGNsYXNzPVxcXCJ0Y2VudGVyIGdyYXlcXFwiIG5nLWlmPVxcXCJpbWFnZXMubGVuZ3RoPT0wXFxcIj57eydOT1RISU5HX0hFUkUnfHRyYW5zbGF0ZX19PC9wPlxcbiAgPC9pb24tY29udGVudD5cXG48L2lvbi12aWV3PlxcblwiLFxuICAgICAgICBjb250cm9sbGVyOiAnSW1hZ2VzQ3RybCdcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLnN0YXRlKCdhcHAubm90aWZpY2F0aW9ucycsIHtcbiAgICB1cmw6ICcvbm90aWZpY2F0aW9ucycsXG4gICAgdmlld3M6IHtcbiAgICAgICdtZW51Q29udGVudCc6IHtcbiAgICAgICAgLy90ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9wb3N0Lmh0bWwnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8aW9uLXZpZXcgdmlldy10aXRsZT1cXFwie3snTk9USUZJQ0FUSU9OUycgfCB0cmFuc2xhdGV9fVxcXCI+XFxuICA8aW9uLWNvbnRlbnQgY2xhc3M9XFxcImhhcy1oZWFkZXJcXFwiPlxcblxcdDxpb24tbGlzdCBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uubm90aWZpY2F0aW9uc1xcXCIgY2FuLXN3aXBlPVxcXCJ0cnVlXFxcIj5cXG4gIFxcdFxcdDxpb24taXRlbSBuZy1yZXBlYXQ9XFxcIml0ZW0gaW4gJHJvb3QuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucyB8IG9yZGVyQnk6ICctY3JlYXRlZCcgXFxcIiBuZy1jbGljaz1cXFwiJHJvb3QuZ2V0Q29udGVudEFuZE9wZW4oaXRlbSlcXFwiPlxcblxcdFxcdCAgICA8cD48aDI+e3tpdGVtLnRpdGxlfX08L2gyPjwvcD5cXG5cXHRcXHQgICAgPHNwYW4+e3tpdGVtLm1lc3NhZ2V9fTwvc3Bhbj5cXG5cXHRcXHQgICAgPGRpdiBjbGFzcz1cXFwicm93IHBvc3RkZXRhaWxzIHR3cmFwXFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLXRpbWVcXFwiPjwvaT4ge3tpdGVtLmNyZWF0ZWR8dGltZWFnb319Jm5ic3A7e3snQlknIHwgdHJhbnNsYXRlfX0mbmJzcDs8Yj57e2l0ZW0uYXV0aG9yfX0mbmJzcDs8L2I+PC9kaXY+PC9kaXY+XFxuXFx0XFx0ICAgIDxpb24tb3B0aW9uLWJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uLWFzc2VydGl2ZVxcXCIgbmctY2xpY2s9XFxcInJlbW92ZU5vdGlmaWNhdGlvbigkaW5kZXgpXFxcIj57eydSRU1PVkUnIHwgdHJhbnNsYXRlfX1cXG5cXHRcXHQgICAgPC9pb24tb3B0aW9uLWJ1dHRvbj5cXG4gICAgXFx0PC9pb24taXRlbT5cXG4gICAgPC9pb24tbGlzdD5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ05vdGlmaWNhdGlvbnNDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcblxuXG4gIC5zdGF0ZSgnYXBwLnBvc3QnLCB7XG4gICAgdXJsOiAnL3Bvc3QvOmNhdGVnb3J5LzphdXRob3IvOnBlcm1saW5rJyxcbiAgICB2aWV3czoge1xuICAgICAgJ21lbnVDb250ZW50Jzoge1xuICAgICAgICAvL3RlbXBsYXRlVXJsOiAndGVtcGxhdGVzL3Bvc3QuaHRtbCcsXG4gICAgICAgIHRlbXBsYXRlOiBcIjxpb24tdmlldyB2aWV3LXRpdGxlPVxcXCJcXFwiPlxcblxcdDxpb24tbmF2LWJhciBjbGFzcz1cXFwiYmFyLXBvc2l0aXZlXFxcIj5cXG5cXHRcXHQgIDxpb24tbmF2LWJhY2stYnV0dG9uPlxcbiAgICBcXHQ8L2lvbi1uYXYtYmFjay1idXR0b24+XFxuXFx0ICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT0nbGVmdCc+XFxuXFx0ICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGJ1dHRvbi1pY29uIGJ1dHRvbi1jbGVhciBpb24tbmF2aWNvblxcXCIgbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiIG1lbnUtdG9nZ2xlPVxcXCJsZWZ0XFxcIj48L2J1dHRvbj5cXG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBpb24tbW9yZVxcXCIgbmctaWY9XFxcIiRyb290LnZvaWNlT3ZlclxcXCIgbWVudS10b2dnbGU9XFxcImxlZnRcXFwiPnt7J01FTlUnfHRyYW5zbGF0ZX19PC9hPlxcblxcdCAgICA8L2lvbi1uYXYtYnV0dG9ucz5cXG4gICAgICA8aW9uLW5hdi10aXRsZT5cXG4gICAgICA8L2lvbi1uYXYtdGl0bGU+XFxuXFx0ICAgIDxpb24tbmF2LWJ1dHRvbnMgc2lkZT0ncmlnaHQnPlxcbiAgICAgIDxzcGFuIG5nLWlmPVxcXCIhJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXJcXFwiIG9uLXRhcD1cXFwiYm9va21hcmsoKVxcXCI+PGkgY2xhc3M9XFxcImljb25cXFwiIG5nLWNsYXNzPVxcXCJ7J2lvbi1pb3MtYm9va21hcmtzJzppc0Jvb2ttYXJrZWQoKSwgJ2lvbi1pb3MtYm9va21hcmtzLW91dGxpbmUnOiFpc0Jvb2ttYXJrZWQoKX1cXFwiPjwvaT48L2J1dHRvbj4gJm5ic3A7IFxcblxcdCAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXIgaW9uLWFuZHJvaWQtc2hhcmUtYWx0XFxcIiBvbi10YXA9XFxcInNoYXJlKClcXFwiPjwvYnV0dG9uPlxcbiAgICAgIDwvc3Bhbj5cXG4gICAgICA8c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj5cXG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXJcXFwiIG9uLXRhcD1cXFwiYm9va21hcmsoKVxcXCI+PGkgY2xhc3M9XFxcImljb25cXFwiIG5nLWNsYXNzPVxcXCJ7J2lvbi1pb3MtYm9va21hcmtzJzppc0Jvb2ttYXJrZWQoKSwgJ2lvbi1pb3MtYm9va21hcmtzLW91dGxpbmUnOiFpc0Jvb2ttYXJrZWQoKX1cXFwiPjwvaT57eydCT09LTUFSSyd8dHJhbnNsYXRlfX08L2E+ICZuYnNwOyBcXG4gICAgICAgIDxhIGhyZWYgY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBidXR0b24tY2xlYXIgaW9uLWFuZHJvaWQtc2hhcmUtYWx0XFxcIiBvbi10YXA9XFxcInNoYXJlKClcXFwiPnt7J1NIQVJFJ3x0cmFuc2xhdGV9fTwvYT5cXG4gICAgICA8L3NwYW4+XFxuXFx0ICAgIDwvaW9uLW5hdi1idXR0b25zPlxcblxcdDwvaW9uLW5hdi1iYXI+XFxuICA8aW9uLWZsb2F0aW5nLW1lbnUgbWVudS1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgbWVudS1vcGVuLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBoYXMtZm9vdGVyPVxcXCJ0cnVlXFxcIj5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1jaGF0YnViYmxlc1xcXCIgY2xpY2s9XFxcImlzcmVwbHlpbmcoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0sIHRydWUpXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCIgYnV0dG9uLWNvbG9yPVxcXCIjMzg3ZWY1XFxcIiBpY29uLWNvbG9yPVxcXCIjZmZmXFxcIiB0ZXh0PVxcXCJ7eydSRVBMWSd8dHJhbnNsYXRlfX1cXFwiIHRleHQtY2xhc3M9XFxcInRleHQtY2xhc3NcXFwiPjwvaW9uLWZsb2F0aW5nLWl0ZW0+XFxuICAgIDxpb24tZmxvYXRpbmctaXRlbSBpY29uPVxcXCJpb24tYW5kcm9pZC1hcnJvdy1kcm9wdXAtY2lyY2xlXFxcIiBjbGljaz1cXFwidXB2b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snVVBWT1RFJ3x0cmFuc2xhdGV9fVxcXCIgdGV4dC1jbGFzcz1cXFwidGV4dC1jbGFzc1xcXCI+PC9pb24tZmxvYXRpbmctaXRlbT5cXG4gICAgPGlvbi1mbG9hdGluZy1pdGVtIGljb249XFxcImlvbi1lZGl0XFxcIiBjbGljaz1cXFwiZWRpdFBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIiBidXR0b24tY29sb3I9XFxcIiMzODdlZjVcXFwiIGljb24tY29sb3I9XFxcIiNmZmZcXFwiIHRleHQ9XFxcInt7J0VESVQnfHRyYW5zbGF0ZX19XFxcIiB0ZXh0LWNsYXNzPVxcXCJ0ZXh0LWNsYXNzXFxcIj48L2lvbi1mbG9hdGluZy1pdGVtPlxcbiAgICA8aW9uLWZsb2F0aW5nLWl0ZW0gaWNvbj1cXFwiaW9uLWltYWdlXFxcIiBjbGljaz1cXFwic2hvd0ltYWdlcygwKVxcXCIgbmctaWY9XFxcImlzSW1hZ2VzKClcXFwiIGJ1dHRvbi1jb2xvcj1cXFwiIzM4N2VmNVxcXCIgaWNvbi1jb2xvcj1cXFwiI2ZmZlxcXCIgdGV4dD1cXFwie3snR0FMTEVSWSd8dHJhbnNsYXRlfX1cXFwiIHRleHQtY2xhc3M9XFxcInRleHQtY2xhc3NcXFwiPjwvaW9uLWZsb2F0aW5nLWl0ZW0+XFxuICAgIDxpb24tZmxvYXRpbmctaXRlbSBpY29uPVxcXCJpb24tYXJyb3ctcmV0dXJuLXJpZ2h0XFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZSAhPT0gJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yXFxcIiBjbGljaz1cXFwiJHJvb3QucmVCbG9nKCRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspXFxcIiBidXR0b24tY29sb3I9XFxcIiMzODdlZjVcXFwiIGljb24tY29sb3I9XFxcIiNmZmZcXFwiIHRleHQ9XFxcInt7J1JFQkxPRyd8dHJhbnNsYXRlfX1cXFwiIHRleHQtY2xhc3M9XFxcInRleHQtY2xhc3NcXFwiPjwvaW9uLWZsb2F0aW5nLWl0ZW0+XFxuICA8L2lvbi1mbG9hdGluZy1tZW51PlxcbiAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nIGhhcy1oZWFkZXJcXFwiIGRlbGVnYXRlLWhhbmRsZT1cXFwibWFpblNjcm9sbFxcXCIgb3ZlcmZsb3ctc2Nyb2xsPVxcXCJ0cnVlXFxcIiBuZy1jbGFzcz1cXFwieyd0aGVtZS1kYXJrJzokcm9vdC4kc3RvcmFnZS50aGVtZSA9PSAnbmlnaHQnfVxcXCI+PCEtLS0tPlxcbiAgICA8ZGl2IG5nLWlmPSckcm9vdC4kc3RvcmFnZS5zaXRlbSc+XFxuICAgICAgPHAgY2xhc3M9XFxcInRpdGxlIGgzXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ucm9vdF90aXRsZSAmJiAkcm9vdC4kc3RvcmFnZS5zaXRlbS50aXRsZT09JydcXFwiPjxhIGhyZWY9XFxcIiMvYXBwL3Bvc3R7eyRyb290LiRzdG9yYWdlLnNpdGVtLnVybC5zcGxpdCgnIycpWzBdfX1cXFwiPnt7XFxcIlZJRVdfQ09OVEVYVFxcXCJ8dHJhbnNsYXRlfX08L2E+PC9wPlxcbiAgICBcXHQ8cCBjbGFzcz1cXFwidGl0bGUgaDNcXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udGl0bGV9fTwvcD5cXG4gICAgXFx0PGRpdiBjbGFzcz1cXFwic3RpdGxlIHJvdyBncmF5XFxcIj48ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPGltZyBjbGFzcz1cXFwicm91bmQtYXZhdGFyXFxcIiBzcmM9XFxcImltZy91c2VyX3Byb2ZpbGUucG5nXFxcIiBuZy1zcmM9XFxcInt7JHJvb3QuJHN0b3JhZ2UucGFjY291bnRzWyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcl0udXNlcl9pbWFnZXx8JHJvb3QuJHN0b3JhZ2UucGFjY291bnRzWyRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcl0ucHJvZmlsZS5wcm9maWxlX2ltYWdlfX1cXFwiIG9uZXJyb3I9XFxcInRoaXMuc3JjPVxcXFwnaW1nL3VzZXJfcHJvZmlsZS5wbmdcXFxcJ1xcXCIgb25hYm9ydD1cXFwidGhpcy5zcmM9XFxcXCdpbWcvdXNlcl9wcm9maWxlLnBuZ1xcXFwnXFxcIiAvPiA8Yj48YSBocmVmPVxcXCIjL2FwcC9wcm9maWxlL3t7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yfX1cXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yfX08L2E+PC9iPiZuYnNwOzxkaXYgY2xhc3M9XFxcInJlcHV0YXRpb25cXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yX3JlcHV0YXRpb258cmVwdXRhdGlvbnxudW1iZXI6MH19PC9kaXY+Jm1pZGRvdDt7eyRyb290LiRzdG9yYWdlLnNpdGVtLmNyZWF0ZWR8dGltZWFnb319IHt7J0lOJ3x0cmFuc2xhdGV9fSZuYnNwO3t7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uY2F0ZWdvcnl8ZGV0cmFuc2xpdGVyYXRlOmZhbHNlfX08L2Rpdj48ZGl2IGNsYXNzPVxcXCJwdWxsLXJpZ2h0XFxcIj48c3BhbiBuZy1pZj1cXFwiJHJvb3Qudm9pY2VPdmVyXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtZmxhZ1xcXCIgb24tdGFwPVxcXCJkb3dudm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnNpdGVtLmRvd252b3RlZFxcXCI+e3snRE9XTlZPVEUnfHRyYW5zbGF0ZX19PC9pPjxpIGNsYXNzPVxcXCJmYSBmYS1mbGFnIHBvc2l0aXZlXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uZG93bnZvdGVkXFxcIj57eydVTlZPVEVfRE9XTlZPVEVEJ3x0cmFuc2xhdGV9fTwvaT48L3NwYW4+PHNwYW4gbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1mbGFnXFxcIiBvbi10YXA9XFxcImRvd252b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uZG93bnZvdGVkXFxcIj48L2k+PGkgY2xhc3M9XFxcImZhIGZhLWZsYWcgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5kb3dudm90ZWRcXFwiPjwvaT48L3NwYW4+PC9kaXY+PC9kaXY+XFxuICAgIFxcdDxicj48IS0tLS0+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiYm9keXRleHQgc2VsZWN0YWJsZVxcXCIgbmctYmluZC1odG1sPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS5ib2R5IHwgcGFyc2VVcmwgXFxcIj5cXG4gICAgICA8L2Rpdj5cXG5cXG4gICAgICA8ZGl2IG5nLWlmPSckcm9vdC4kc3RvcmFnZS5zaXRlbS5qc29uX21ldGFkYXRhLnRhZ3MnIGNsYXNzPVxcXCJ0YWdzXFxcIj5cXG4gICAgICAgIDxkaXYgbmctcmVwZWF0PSd0YWcgaW4gJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uanNvbl9tZXRhZGF0YS50YWdzJz5cXG4gICAgICAgICAgPHNwYW4+PGRpdiBjbGFzcz1cXFwidGFnXFxcIiBvbi10YXA9XFxcIm9wZW5UYWcodGFnLCA1KVxcXCI+e3t0YWd8ZGV0cmFuc2xpdGVyYXRlOmZhbHNlfX08L2Rpdj48L2xpPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwicm93IGdyYXlcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIGNvbC0zM1xcXCIgbmctaWY9XFxcIiEkcm9vdC52b2ljZU92ZXJcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2hldnJvbi1jaXJjbGUtdXAgZmEtbGdcXFwiIG9uLXRhcD1cXFwidXB2b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udXB2b3RlZCAmJiAhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uaW52b3RpbmdcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXJyKCRldmVudCwgJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIj48L2k+PGkgY2xhc3M9XFxcImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwIGZhLWxnIHBvc2l0aXZlXFxcIiBvbi10YXA9XFxcInVudm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0udXB2b3RlZCAmJiAhJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uaW52b3RpbmdcXFwiPjwvaT4mbmJzcDsmbmJzcDsmbmJzcDs8c3BhbiBvbi10YXA9XFxcIiRyb290Lm9wZW5JbmZvKCRyb290LiRzdG9yYWdlLnNpdGVtKVxcXCI+e3skcm9vdC4kc3RvcmFnZS5zaXRlbS5uZXRfdm90ZXN9fTwvc3Bhbj48L2Rpdj5cXG5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMzNcXFwiIG5nLWlmPVxcXCIkcm9vdC52b2ljZU92ZXJcXFwiPjxpb24tc3Bpbm5lciBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uaW52b3RpbmdcXFwiPjwvaW9uLXNwaW5uZXI+XFxuICAgICAgICA8aSBjbGFzcz1cXFwiaWNvbiBpb24tYW5kcm9pZC1hcnJvdy1kcm9wdXAtY2lyY2xlXFxcIiBvbi10YXA9XFxcInVwdm90ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiISRyb290LiRzdG9yYWdlLnNpdGVtLnVwdm90ZWRcXFwiIG9uLWhvbGQ9XFxcIm9wZW5TbGlkZXJyKCRldmVudCwgJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIj57eydVUFZPVEUnfHRyYW5zbGF0ZX19PC9pPjxpIGNsYXNzPVxcXCJpY29uIGlvbi1hbmRyb2lkLWFycm93LWRyb3B1cC1jaXJjbGUgcG9zaXRpdmVcXFwiIG9uLXRhcD1cXFwidW52b3RlUG9zdCgkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiIG5nLWlmPVxcXCIkcm9vdC4kc3RvcmFnZS5zaXRlbS51cHZvdGVkXFxcIj57eydVTlZPVEVfVVBWT1RFRCd8dHJhbnNsYXRlfX08L2k+Jm5ic3A7Jm5ic3A7Jm5ic3A7PHNwYW4gb24tdGFwPVxcXCIkcm9vdC5vcGVuSW5mbygkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPnt7JHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ubmV0X3ZvdGVzfX08L3NwYW4+PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTMzXFxcIiBvbi10YXA9XFxcIm9wZW5Ub29sdGlwKCRldmVudCwkcm9vdC4kc3RvcmFnZS5zaXRlbSlcXFwiPjxiPnt7JHJvb3QuJHN0b3JhZ2UuY3VycmVuY3l8Z2V0Q3VycmVuY3lTeW1ib2x9fTwvYj4ge3skcm9vdC4kc3RvcmFnZS5zaXRlbSB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBvbi10YXA9XFxcImlzcmVwbHlpbmcoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0sIHRydWUpXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtcmVwbHlcXFwiPjwvaT4ge3skcm9vdC4kc3RvcmFnZS5zaXRlbS5jaGlsZHJlbn19PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiIG9uLXRhcD1cXFwiZWRpdFBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0uYXV0aG9yPT0kcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lXFxcIj48aSBjbGFzcz1cXFwiZmEgIGZhLXBlbmNpbC1zcXVhcmUtb1xcXCI+PC9pPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIiBvbi10YXA9XFxcImRlbGV0ZVBvc3QoJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0pXFxcIiBuZy1pZj1cXFwiJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ubmV0X3ZvdGVzPT0wICYmICRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvcj09JHJvb3QuJHN0b3JhZ2UudXNlci51c2VybmFtZVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLXRyYXNoLW9cXFwiPjwvaT48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8Y2VudGVyPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24tcG9zaXRpdmUgYnV0dG9uLW91dGxpbmUgYnV0dG9uLWljb24gaW9uLXJlZnJlc2ggaWNvbi1yaWdodFxcXCIgb24tdGFwPVxcXCJmZXRjaENvbW1lbnRzKCRyb290LiRzdG9yYWdlLnNpdGVtLmF1dGhvciwgJHJvb3QuJHN0b3JhZ2Uuc2l0ZW0ucGVybWxpbmspXFxcIj48aW9uLXNwaW5uZXIgY2xhc3M9XFxcInNwaW5uZXItcG9zaXRpdmVcXFwiIG5nLWlmPVxcXCIkcm9vdC5mZXRjaGluZ1xcXCI+PC9pb24tc3Bpbm5lcj4ge3tcXFwiQ09NTUVOVFNcXFwifHRyYW5zbGF0ZX19PC9idXR0b24+PC9jZW50ZXI+XFxuICAgICAgPGJyPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm15LWhhbmRsZVxcXCI+PC9kaXY+XFxuICAgICAgXFxuICAgICAgPGlvbi10aHJlYWQgY29tbWVudHM9XFxcImNvbW1lbnRzXFxcIj48L2lvbi10aHJlYWQ+XFxuICAgIDwvZGl2PlxcbiAgICA8c2NyaXB0IGlkID0gXFxcInBvcG92ZXJUci5odG1sXFxcIiB0eXBlPVxcXCJ0ZXh0L25nLXRlbXBsYXRlXFxcIj5cXG4gICAgICA8aW9uLXBvcG92ZXItdmlldyBjbGFzcz1cXFwiZGV0YWlsZWRQb3N0XFxcIj5cXG4gICAgICAgIDxpb24tY29udGVudD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicGFkZGluZ1xcXCIgbmctYmluZC1odG1sPVxcXCJ0b29sdGlwVGV4dFxcXCI+PC9kaXY+XFxuICAgICAgICA8L2lvbi1jb250ZW50PlxcbiAgICAgIFxcbiAgICAgIDwvaW9uLXBvcG92ZXItdmlldz5cXG4gICAgPC9zY3JpcHQ+XFxuICAgIDxzY3JpcHQgaWQgPSBcXFwicG9wb3ZlclNsaWRlcnIuaHRtbFxcXCIgdHlwZT1cXFwidGV4dC9uZy10ZW1wbGF0ZVxcXCI+XFxuICAgICAgPGlvbi1wb3BvdmVyLXZpZXcgY2xhc3M9XFxcImRldGFpbGVkU2xpZGVcXFwiPlxcbiAgICAgICAgPGlvbi1jb250ZW50IGNsYXNzPVxcXCJwYWRkaW5nXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBjb2wtMTBcXFwiPjxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBidXR0b24taWNvbiBmYSBmYS1jaGV2cm9uLWNpcmNsZS11cCBmYS1sZ1xcXCIgb24tdGFwPVxcXCJ2b3RlUG9zdFMoKVxcXCI+PC9idXR0b24+PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzID0gXFxcIml0ZW0gcmFuZ2UgcmFuZ2UtcG9zaXRpdmVcXFwiPlxcbiAgICAgICAgICAgICB7e3JhbmdlVmFsdWV9fSA8aW5wdXQgdHlwZT1cXFwicmFuZ2VcXFwiIG5hbWU9XFxcInJhbmdlMlxcXCIgbWluPVxcXCIxXFxcIiBtYXg9XFxcIjEwMFxcXCIgbmctbW9kZWw9XFxcInJhbmdlVmFsdWVcXFwiIG5nLWNoYW5nZT1cXFwiZHJhZyhyYW5nZVZhbHVlKVxcXCI+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgY29sLTEwXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gYnV0dG9uLWljb24gaW9uLWNsb3NlLXJvdW5kXFxcIiBuZy1jbGljaz1cXFwiY2xvc2VTbGlkZXJyKClcXFwiPjwvYnV0dG9uPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvaW9uLWNvbnRlbnQ+XFxuICAgICAgPC9pb24tcG9wb3Zlci12aWV3PlxcbiAgICA8L3NjcmlwdD5cXG4gIDwvaW9uLWNvbnRlbnQ+XFxuPC9pb24tdmlldz5cXG5cIixcbiAgICAgICAgY29udHJvbGxlcjogJ1Bvc3RDdHJsJ1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIC8vIGlmIG5vbmUgb2YgdGhlIGFib3ZlIHN0YXRlcyBhcmUgbWF0Y2hlZCwgdXNlIHRoaXMgYXMgdGhlIGZhbGxiYWNrXG4gICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy9hcHAvcG9zdHMvL3RydWUnKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIubmF2QmFyLmFsaWduVGl0bGUoJ2xlZnQnKVxuICAkaW9uaWNDb25maWdQcm92aWRlci5iYWNrQnV0dG9uLnRleHQoJycpLmljb24oJ2lvbi1jaGV2cm9uLWxlZnQnKTtcbiAgJGlvbmljQ29uZmlnUHJvdmlkZXIudmlld3Muc3dpcGVCYWNrRW5hYmxlZChmYWxzZSk7XG4gICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnZpZXdzLm1heENhY2hlKDMpO1xuXG4gICRhbmltYXRlUHJvdmlkZXIuY2xhc3NOYW1lRmlsdGVyKCAvXFxiYW5pbWF0ZWRcXGIvICk7XG4gICRpb25pY0NvbmZpZ1Byb3ZpZGVyLnNjcm9sbGluZy5qc1Njcm9sbGluZyhmYWxzZSk7XG5cbiAgaWYgKHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgICAkbG9nUHJvdmlkZXIuZGVidWdFbmFibGVkKGZhbHNlKTtcbiAgICAgICRjb21waWxlUHJvdmlkZXIuZGVidWdJbmZvRW5hYmxlZChmYWxzZSk7XG4gIH1cblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlbi1VUycsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9lbicpKTsgLy9FbmdsaXNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3J1LVJVJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3J1LVJVJykpOyAvL1J1c3NpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZGUtREUnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvZGUtREUnKSk7IC8vR2VybWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2ZyLUZSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2ZyLUZSJykpOyAvL0ZyZW5jaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdlcy1FUycsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9lcy1FUycpKTsgLy9TcGFuaXNoXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2VsLUdSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2VsLUdSJykpOyAvL0dyZWVrXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2JnLUJHJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2JnLUJHJykpOyAvL0J1bGdhcmlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdubC1OTCcsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9ubC1OTCcpKTsgLy9EdXRjaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdodS1IVScsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9odS1IVScpKTsgLy9IdW5nYXJpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnY3MtQ1onLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvY3MtQ1onKSk7IC8vQ3plY2hcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnaGUtSUwnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvaGUtSUwnKSk7IC8vSGVicmV3XG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3BsLVBMJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3BsLVBMJykpOyAvL1BvbGlzaFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdwdC1QVCcsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9wdC1QVCcpKTsgLy9Qb3J0dWd1ZXNlXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3B0LUJSJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3B0LUJSJykpOyAvL1BvcnR1Z3Vlc2UgQnJhemlsXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2lkLUlEJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2lkLUlEJykpOyAvL0luZG9uZXNpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnemgtVFcnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvemgtVFcnKSk7IC8vQ2hpbmVzZSB0cmFkaXRpb25hbFxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCd6aC1DTicsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS96aC1DTicpKTsgLy9DaGluZXNlIHNpbXBsaWZpZWRcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZG9sYW4nLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvZG9sYW4nKSk7IC8vRG9sYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnc3YtU0UnLCByZXF1aXJlKCcuL2xvY2FsZXMvcmVhZHkvc3YtU0UnKSk7IC8vQ2hpbmVzZSBzaW1wbGlmaWVkXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ3VrLVVBJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L3VrLVVBJykpOyAvL1VrcmFpbmlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdtcy1NWScsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9tcy1NWScpKTsgLy9NYWxheVxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdoci1IUicsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9oci1IUicpKTsgLy9Dcm9hdGlhblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdmYS1JUicsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9mYS1JUicpKTsgLy9QZXJzaWFuXG4gICR0cmFuc2xhdGVQcm92aWRlci50cmFuc2xhdGlvbnMoJ2l0LUlUJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2l0LUlUJykpOyAvL0l0YWxpYW5cbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLnRyYW5zbGF0aW9ucygnZmlsLVBIJywgcmVxdWlyZSgnLi9sb2NhbGVzL3JlYWR5L2ZpbC1QSCcpKTsgLy9GaWxpcGlub1xuICAkdHJhbnNsYXRlUHJvdmlkZXIudHJhbnNsYXRpb25zKCdhci1TQScsIHJlcXVpcmUoJy4vbG9jYWxlcy9yZWFkeS9hci1TQScpKTsgLy9BcmFiaWNcblxuICAkdHJhbnNsYXRlUHJvdmlkZXIudXNlU2FuaXRpemVWYWx1ZVN0cmF0ZWd5KG51bGwpO1xuXG4gICR0cmFuc2xhdGVQcm92aWRlci5wcmVmZXJyZWRMYW5ndWFnZSgnZW4tVVMnKTtcbiAgJHRyYW5zbGF0ZVByb3ZpZGVyLmZhbGxiYWNrTGFuZ3VhZ2UoJ2VuLVVTJyk7XG5cbn0pO1xuXG5hcHAucnVuKGZ1bmN0aW9uKCRpb25pY1BsYXRmb3JtLCAkcm9vdFNjb3BlLCAkbG9jYWxTdG9yYWdlLCAkaW50ZXJ2YWwsICRpb25pY1BvcHVwLCAkaW9uaWNMb2FkaW5nLCAkY29yZG92YVNwbGFzaHNjcmVlbiwgJGlvbmljTW9kYWwsICR0aW1lb3V0LCAkY29yZG92YVRvYXN0LCBBUElzLCAkc3RhdGUsICRsb2csICRpb25pY1Njcm9sbERlbGVnYXRlLCAkZmlsdGVyLCAkdHJhbnNsYXRlKSB7XG4gICRyb290U2NvcGUuJHN0b3JhZ2UgPSAkbG9jYWxTdG9yYWdlO1xuICAkcm9vdFNjb3BlLmxvZyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAkbG9nLmluZm8obWVzc2FnZSk7XG4gIH07XG5cbiAgJGlvbmljUGxhdGZvcm0ucmVnaXN0ZXJCYWNrQnV0dG9uQWN0aW9uKGZ1bmN0aW9uIChldmVudCkge1xuICBpZiAoICgkc3RhdGUuJGN1cnJlbnQubmFtZT09XCJhcHAucG9zdHNcIikgKXtcbiAgICAgICAgICAvLyBIL1cgQkFDSyBidXR0b24gaXMgZGlzYWJsZWQgZm9yIHRoZXNlIHN0YXRlcyAodGhlc2Ugdmlld3MpXG4gICAgICAgICAgLy8gRG8gbm90IGdvIHRvIHRoZSBwcmV2aW91cyBzdGF0ZSAob3IgdmlldykgZm9yIHRoZXNlIHN0YXRlcy4gXG4gICAgICAgICAgLy8gRG8gbm90aGluZyBoZXJlIHRvIGRpc2FibGUgSC9XIGJhY2sgYnV0dG9uLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb3IgYWxsIG90aGVyIHN0YXRlcywgdGhlIEgvVyBCQUNLIGJ1dHRvbiBpcyBlbmFibGVkXG4gICAgICAgICAgbmF2aWdhdG9yLmFwcC5iYWNrSGlzdG9yeSgpO1xuICAgICAgfVxuICB9LCAxMDApO1xuICAkaW9uaWNQbGF0Zm9ybS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlIHRoZSBhY2Nlc3NvcnkgYmFyIGJ5IGRlZmF1bHQgKHJlbW92ZSB0aGlzIHRvIHNob3cgdGhlIGFjY2Vzc29yeSBiYXIgYWJvdmUgdGhlIGtleWJvYXJkXG4gICAgLy8gZm9yIGZvcm0gaW5wdXRzKVxuICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkKSB7XG4gICAgICBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaGlkZUtleWJvYXJkQWNjZXNzb3J5QmFyKHRydWUpO1xuICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmRpc2FibGVTY3JvbGwodHJ1ZSk7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuU3RhdHVzQmFyKSB7XG4gICAgICAvLyBvcmcuYXBhY2hlLmNvcmRvdmEuc3RhdHVzYmFyIHJlcXVpcmVkXG4gICAgICBTdGF0dXNCYXIuc3R5bGVEZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS51c2Vycykge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VycyA9IFtdO1xuICAgIH1cbiAgICBcbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2UudGhlbWUpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudGhlbWUgPSAnZGF5JztcbiAgICB9XG5cbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0Z29sb3MpXG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldGdvbG9zID0gXCJ3c3M6Ly93cy5nb2xvcy5pby9cIjtcbiAgICBpZiAoISRyb290U2NvcGUuJHN0b3JhZ2Uuc29ja2V0c3RlZW0pXG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldHN0ZWVtID0gXCJ3c3M6Ly9zdGVlbWQuc3RlZW1pdC5jb21cIjtcblxuICAgIHdpbmRvdy5lanMuQ2hhaW5Db25maWcuc2V0Q2hhaW5JZChsb2NhbFN0b3JhZ2VbJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbitcIklkXCJdKTtcblxuICAgIGlmICghYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSkpIHtcbiAgICAgIGlmKHR5cGVvZiBuYXZpZ2F0b3IuZ2xvYmFsaXphdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIG5hdmlnYXRvci5nbG9iYWxpemF0aW9uLmdldFByZWZlcnJlZExhbmd1YWdlKGZ1bmN0aW9uKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICR0cmFuc2xhdGUudXNlKGxhbmd1YWdlLnZhbHVlKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU1VDQ0VTUyAtPiBcIiArIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlLnZhbHVlLmluZGV4T2YoXCJlblwiKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UubGFuZ3VhZ2UgPSAnZW4nOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSA9IGxhbmd1YWdlLnZhbHVlO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUiAtPiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmxhbmd1YWdlID0gJ2VuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJHRyYW5zbGF0ZS51c2UoJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZSk7XG4gICAgfVxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbil7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wb3dlciA9IFwiU3RlZW0gUG93ZXJcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1zdW5pdCA9IFwiU3RlZW1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXIgPSBcIlN0ZWVtIERvbGxhclwiO1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJTQkRcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1wdW5pdCA9IFwiU1BcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCA9IFwiU1RFRU1cIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4gPSBcInN0ZWVtXCI7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5ID0gXCJ1c2RcIjtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gMTtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kc3RvcmFnZS5sYW5ndWFnZXMgPSBbXG4gICAgICB7aWQ6J2VuJywgbmFtZTogJ0VuZ2xpc2gnfSwgXG4gICAgICB7aWQ6J2VzLUVTJywgbmFtZTogJ0VzcGHDsW9sJ30sIFxuICAgICAge2lkOidlbC1HUicsIG5hbWU6ICfOlc67zrvOt869zrnOus6sJ30sIFxuICAgICAge2lkOidmci1GUicsIG5hbWU6ICdGcmFuw6dhaXMnfSwgXG4gICAgICB7aWQ6J2RlLURFJywgbmFtZTogJ0RldXRzY2gnfSwgXG4gICAgICB7aWQ6J3J1LVJVJywgbmFtZTogJ9Cg0YPRgdGB0LrQuNC5J30sIFxuICAgICAge2lkOidiZy1CRycsIG5hbWU6ICfQkdGK0LvQs9Cw0YDRgdC60LgnfSwgXG4gICAgICB7aWQ6J25sLU5MJywgbmFtZTogJ05lZGVybGFuZHMnfSwgXG4gICAgICB7aWQ6J2h1LUhVJywgbmFtZTogJ01hZ3lhcid9LCBcbiAgICAgIHtpZDonY3MtQ1onLCBuYW1lOiAnxIxlxaF0aW5hJ30sIFxuICAgICAge2lkOidoZS1JTCcsIG5hbWU6ICfXoteR16jXmdeq4oCOJ30sIFxuICAgICAge2lkOidwbC1QTCcsIG5hbWU6ICdQb2xza2nigI4nfSwgXG4gICAgICB7aWQ6J3B0LVBUJywgbmFtZTogJ1BvcnR1Z3XDqnMnfSwgXG4gICAgICB7aWQ6J3B0LUJSJywgbmFtZTogJ1BvcnR1Z3XDqnMgQlInfSxcbiAgICAgIHtpZDonc3YtU0UnLCBuYW1lOiAnU3ZlbnNrJ30sXG4gICAgICB7aWQ6J2lkLUlEJywgbmFtZTogJ0JhaGFzYSBJbmRvbmVzaWEnfSwgXG4gICAgICB7aWQ6J3poLUNOJywgbmFtZTogJ+e5gemrlOS4reaWhyd9LCBcbiAgICAgIHtpZDonemgtVFcnLCBuYW1lOiAn566A5L2T5Lit5paHJ30sXG4gICAgICB7aWQ6J2RvbGFuJywgbmFtZTogJ0RvbGFuJ30sXG4gICAgICB7aWQ6J3VrLVVBJywgbmFtZTogJ9Cj0LrRgNCw0ZfQvdGB0YzQutCwJ30sXG4gICAgICB7aWQ6J21zLU1ZJywgbmFtZTogJ0JhaGFzYSBNZWxheXUnfSxcbiAgICAgIHtpZDonaHItSFInLCBuYW1lOiAnSHJ2YXRza2knfSxcbiAgICAgIHtpZDonZmEtSVInLCBuYW1lOiAnRsSBcnNpJ30sXG4gICAgICB7aWQ6J2l0LUlUJywgbmFtZTogJ0l0YWxpYW5vJ30sXG4gICAgICB7aWQ6J2ZpbC1QSCcsIG5hbWU6ICdXaWthbmcgRmlsaXBpbm8nfSxcbiAgICAgIHtpZDonYXItU0EnLCBuYW1lOiAn2LnZjtix2Y7YqNmQ2YrZkSd9XG4gICAgICBcbiAgICBdO1xuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5kaXIpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGlyID0gJ2x0cic7XG4gICAgfVxuICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5zID0gW3tpZDonc3RlZW0nLCBuYW1lOiAnU3RlZW0nfSwge2lkOidnb2xvcycsIG5hbWU6ICdHb2xvcyd9XTtcblxuICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jaWVzKSB7XG4gICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMgPSBbXG4gICAgICAgIHtpZDonYnRjJywgbmFtZTogJ0JUQycsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J3VzZCcsIG5hbWU6ICdVU0QnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidldXInLCBuYW1lOiAnRVVSJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDoncnViJywgbmFtZTogJ1JVQicsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2dicCcsIG5hbWU6ICdHQlAnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidqcHknLCBuYW1lOiAnSlBZJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDona3J3JywgbmFtZTogJ0tSVycsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J2lucicsIG5hbWU6ICdJTlInLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOidjbnknLCBuYW1lOiAnQ05ZJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSwgXG4gICAgICAgIHtpZDondWFoJywgbmFtZTogJ1VBSCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sIFxuICAgICAgICB7aWQ6J3NlaycsIG5hbWU6ICdTRUsnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LCBcbiAgICAgICAge2lkOid0cnknLCBuYW1lOiAnVFJZJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidjYWQnLCBuYW1lOiAnQ0FEJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidjaGYnLCBuYW1lOiAnQ0hGJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidhdWQnLCBuYW1lOiAnQVVEJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidub2snLCBuYW1lOiAnTk9LJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidwbG4nLCBuYW1lOiAnUExOJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAge2lkOidwaHAnLCBuYW1lOiAnUEhQJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmFkZGl0aW9uKSB7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuYWRkaXRpb24gPSBbXG4gICAgICAgICAge2lkOidjYWQnLCBuYW1lOiAnQ0FEJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAgICB7aWQ6J2NoZicsIG5hbWU6ICdDSEYnLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICAgIHtpZDonYXVkJywgbmFtZTogJ0FVRCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn0sXG4gICAgICAgICAge2lkOidub2snLCBuYW1lOiAnTk9LJywgcmF0ZTogMCwgZGF0ZTogXCIxLzEvMjAxNlwifSxcbiAgICAgICAgICB7aWQ6J3BsbicsIG5hbWU6ICdQTE4nLCByYXRlOiAwLCBkYXRlOiBcIjEvMS8yMDE2XCJ9LFxuICAgICAgICAgIHtpZDoncGhwJywgbmFtZTogJ1BIUCcsIHJhdGU6IDAsIGRhdGU6IFwiMS8xLzIwMTZcIn1dO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMgPSAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMuY29uY2F0KCRyb290U2NvcGUuJHN0b3JhZ2UuYWRkaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgaWYgKGlvbmljLlBsYXRmb3JtLmlzSVBhZCgpIHx8IGlvbmljLlBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgICAgTW9iaWxlQWNjZXNzaWJpbGl0eS5pc1ZvaWNlT3ZlclJ1bm5pbmcoZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiU2NyZWVuIHJlYWRlcjogT05cIik7XG4gICAgICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gYm9vbDtcbiAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnY2VudGVyJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJTY3JlZW4gcmVhZGVyOiBPRkZcIik7XG4gICAgICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gYm9vbDtcbiAgICAgICAgICAgICAgLy8kaW9uaWNDb25maWdQcm92aWRlci5uYXZCYXIuYWxpZ25UaXRsZSgnbGVmdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnZpZXcpIHtcbiAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudmlldyA9ICdjb21wYWN0JztcbiAgICB9XG4gICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlcikge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSBcInRyZW5kaW5nXCI7XG4gICAgfVxuICAgIGlmIChuYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBuYXZpZ2F0b3Iuc3BsYXNoc2NyZWVuLmhpZGUoKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICAkcm9vdFNjb3BlLmxvZyhcImFwcCBzdGFydCByZWFkeVwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSkge1xuICAgICAgICAkcm9vdFNjb3BlLnBpbmNoZWNrID0gdHJ1ZTtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwicGluOmNoZWNrXCIpO1xuICAgICAgfVxuICAgIH0sIDEwMDApO1xuICAgICRyb290U2NvcGUuc2hvd0FsZXJ0ID0gZnVuY3Rpb24odGl0bGUsIG1zZykge1xuICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5hbGVydCh7XG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGVtcGxhdGU6IG1zZ1xuICAgICAgfSk7XG4gICAgICBpZiAobXNnLmluZGV4T2YoXCJlcnJvclwiKT4tMSkge1xuICAgICAgICAvL3dpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImJyb2FkY2FzdCBlcnJvclwiKTtcbiAgICAgICAgLy99KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGVydFBvcHVwLyoudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coJ1RoYW5rIHlvdSAuLi4nKTtcbiAgICAgIH0pOyovXG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlID0gZnVuY3Rpb24odGl0bGUsIG1zZykge1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgICAgICRjb3Jkb3ZhVG9hc3Quc2hvd0xvbmdCb3R0b20odGl0bGUrXCI6IFwiK21zZykudGhlbihmdW5jdGlvbihzdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcInRvYXN0XCIrc3VjY2Vzcyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJ0b2FzdFwiK2Vycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCh0aXRsZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgJHJvb3RTY29wZS4kb24oJ3Nob3c6bG9hZGluZycsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcbiAgICAgICRyb290U2NvcGUubG9nKCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7XG4gICAgICAgIG5vQmFja2Ryb3AgOiB0cnVlLFxuICAgICAgICB0ZW1wbGF0ZTogJzxpb24tc3Bpbm5lciBpY29uPVwicmlwcGxlXCIgY2xhc3M9XCJzcGlubmVyLWVuZXJnaXplZFwiPjwvaW9uLXNwaW5uZXI+J1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kb24oJ2hpZGU6bG9hZGluZycsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcbiAgICAgICRyb290U2NvcGUubG9nKCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICRpb25pY0xvYWRpbmcuaGlkZSgpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfSk7XG5cbiAgICAkcm9vdFNjb3BlLiRvbignJHN0YXRlQ2hhbmdlU3RhcnQnLCBmdW5jdGlvbihldmVudCwgdG9TdGF0ZSwgdG9QYXJhbXMsIGZyb21TdGF0ZSwgZnJvbVBhcmFtcyl7XG4gICAgICAkcm9vdFNjb3BlLmxvZyhcImZyb20gXCIrZnJvbVN0YXRlLm5hbWUrXCIgdG8gXCIrdG9TdGF0ZS5uYW1lKTtcbiAgICB9KTtcblxuICAgICRpb25pY1BsYXRmb3JtLm9uKCdyZXN1bWUnLCBmdW5jdGlvbigpe1xuICAgICAgJHJvb3RTY29wZS5sb2coXCJhcHAgcmVzdW1lXCIpO1xuICAgICAgdmFyIHN0ZWVtUlBDID0gcmVxdWlyZShcInN0ZWVtLXJwY1wiKTtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNvY2tldFVybFwiKSA9PT0gbnVsbCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInNvY2tldFVybFwiLCBcIndzczovL3N0ZWVtZC5zdGVlbWl0LmNvbVwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5BcGkgPSBzdGVlbVJQQy5DbGllbnQuZ2V0KHt1cmw6bG9jYWxTdG9yYWdlLnNvY2tldFVybH0sIHRydWUpO1xuICAgICAgLy93aW5kb3cuc3RlZW1KUyA9IHJlcXVpcmUoXCJzdGVlbWpzLWxpYlwiKTtcbiAgICAgIC8vd2luZG93LmdvbG9zSlMgPSByZXF1aXJlKFwiZ29sb3Nqcy1saWJcIik7XG5cbiAgICAgIC8vaWYgKCFhbmd1bGFyLmlzRGVmaW5lZCgkcm9vdFNjb3BlLnRpbWVpbnQpKSB7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coXCJBcGkgcmVhZHkgc3RhdGUgY2hhbmdlOiBcIithbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgICAkcm9vdFNjb3BlLnRpbWVpbnQgPSAkaW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfZHluYW1pY19nbG9iYWxfcHJvcGVydGllc1wiLCBbXSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImdldF9keW5hbWljX2dsb2JhbF9wcm9wZXJ0aWVzIFwiICsgcmVzcG9uc2UuaGVhZF9ibG9ja19udW1iZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCAxNTAwMCk7XG4gICAgICB9KTtcbiAgICAgIC8vfVxuICAgICAgLyp3aW5kb3cuRmlyZWJhc2VQbHVnaW4ub25Ob3RpZmljYXRpb25PcGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuICAgICAgICBpZihkYXRhLnRhcCl7XG4gICAgICAgICAgLy9Ob3RpZmljYXRpb24gd2FzIHJlY2VpdmVkIG9uIGRldmljZSB0cmF5IGFuZCB0YXBwZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgICAgaWYgKGRhdGEuYXV0aG9yICYmIGRhdGEucGVybWxpbmspIHtcbiAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG5cbiAgICAgICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGF0YS5ib2R5ICsgJGZpbHRlcigndHJhbnNsYXRlJykoJ09QRU5JTkdfUE9TVCcpXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGFsZXJ0UG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnVGhhbmsgeW91IGZvciBzZWVpbmcgYWxlcnQgZnJvbSB0cmF5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3Blbih7YXV0aG9yOmRhdGEuYXV0aG9yLCBwZXJtbGluazpkYXRhLnBlcm1saW5rfSk7XG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSA9IHt0aXRsZTpkYXRhLnRpdGxlLCBib2R5OiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rfTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgaW4gZm9yZWdyb3VuZC4gTWF5YmUgdGhlIHVzZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQuXG4gICAgICAgICAgLy9hbGVydCggSlNPTi5zdHJpbmdpZnkoZGF0YSkgKTtcbiAgICAgICAgICBpZiAoZGF0YS5hdXRob3IgJiYgZGF0YS5wZXJtbGluaykge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkrXCIgXCIrZGF0YS5wZXJtbGluayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoZGF0YS50aXRsZSwgZGF0YS5ib2R5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9KTsqL1xuXG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG4gICAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSB0cnVlO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46Y2hlY2tcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgICBpZiAoaW9uaWMuUGxhdGZvcm0uaXNJUGFkKCkgfHwgaW9uaWMuUGxhdGZvcm0uaXNJT1MoKSkge1xuXG4gICAgICAgICAgTW9iaWxlQWNjZXNzaWJpbGl0eS5pc1ZvaWNlT3ZlclJ1bm5pbmcoZnVuY3Rpb24oYm9vbCkge1xuICAgICAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIlNjcmVlbiByZWFkZXI6IE9OXCIpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUudm9pY2VPdmVyID0gYm9vbDtcbiAgICAgICAgICAgICAgICAvLyRpb25pY0NvbmZpZ1Byb3ZpZGVyLm5hdkJhci5hbGlnblRpdGxlKCdjZW50ZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJTY3JlZW4gcmVhZGVyOiBPRkZcIik7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS52b2ljZU92ZXIgPSBib29sO1xuICAgICAgICAgICAgICAgIC8vJGlvbmljQ29uZmlnUHJvdmlkZXIubmF2QmFyLmFsaWduVGl0bGUoJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnZvaWNlT3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLnZvaWNlT3ZlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgfSk7XG4gICAgJGlvbmljUGxhdGZvcm0ub24oJ3BhdXNlJywgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUubG9nKFwiYXBwIHBhdXNlXCIpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRyb290U2NvcGUudGltZWludCkpIHtcbiAgICAgICAgJHJvb3RTY29wZS5sb2coXCJjYW5jZWwgaW50ZXJ2YWxcIik7XG4gICAgICAgICRpbnRlcnZhbC5jYW5jZWwoJHJvb3RTY29wZS50aW1laW50KTtcbiAgICAgICAgJHJvb3RTY29wZS50aW1laW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB3aW5kb3cuQXBpLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAkaW9uaWNQbGF0Zm9ybS5vbignb2ZmbGluZScsIGZ1bmN0aW9uKCl7XG4gICAgICAkcm9vdFNjb3BlLmxvZyhcImFwcCBvZmZsaW5lXCIpO1xuICAgIH0pO1xuXG4gICAgJHJvb3RTY29wZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAkcm9vdFNjb3BlLnBhc3Njb2RlID0gXCJcIjtcbiAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKSB7XG4gICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICRyb290U2NvcGUuYWRkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICRyb290U2NvcGUucGluZXJyb3IgPSBcIlwiO1xuICAgICAgaWYoJHJvb3RTY29wZS5wYXNzY29kZS5sZW5ndGggPCA0KSB7XG4gICAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSAkcm9vdFNjb3BlLnBhc3Njb2RlICsgdmFsdWU7XG4gICAgICAgIGlmKCRyb290U2NvcGUucGFzc2NvZGUubGVuZ3RoID09IDQpIHtcbiAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwiUElOIFwiKyRyb290U2NvcGUucGFzc2NvZGUpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUucGludHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUgPT0gJHJvb3RTY29wZS5wYXNzY29kZSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuY2xvc2VQaW4oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbnRyeSArPSAxO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGluZXJyb3IgPSAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTk9UX01BVENIJykrXCIoXCIrJHJvb3RTY29wZS5waW50cnkrXCIpXCI7XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUucGludHJ5PjMpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUucGludHJ5ID0gMDtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChcInBpbjpmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmNsb3NlUGluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50eXBlID09IDApIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJ0eXBlIDA6IHNldCBwaW5cIik7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmNoZWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJwaW46Y2hlY2tcIik7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9ICRyb290U2NvcGUucGFzc2NvZGU7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW5zdWJ0aXRsZSA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT05GSVJNX1BJTicpO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGludHlwZSA9IDM7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW50cnkgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50eXBlID09IDEpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJ0eXBlIDE6IGNoZWNrIHBpblwiKTtcbiAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UucGluY29kZSA9PSAkcm9vdFNjb3BlLnBhc3Njb2RlKXtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Bpbjpjb3JyZWN0Jyk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jbG9zZVBpbigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUucGludHJ5ICs9IDE7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdJTkNPUlJFQ1QnKStcIihcIiskcm9vdFNjb3BlLnBpbnRyeStcIilcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS5waW50cnk+Mykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS4kcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuY2xvc2VQaW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLmRlbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHJvb3RTY29wZS5waW5lcnJvciA9IFwiXCI7XG4gICAgICBpZigkcm9vdFNjb3BlLnBhc3Njb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJHJvb3RTY29wZS5wYXNzY29kZSA9ICRyb290U2NvcGUucGFzc2NvZGUuc3Vic3RyaW5nKDAsICRyb290U2NvcGUucGFzc2NvZGUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJGlvbmljTW9kYWwuZnJvbVRlbXBsYXRlVXJsKCd0ZW1wbGF0ZXMvcGluY29kZS5odG1sJywge1xuICAgICAgc2NvcGU6ICRyb290U2NvcGVcbiAgICB9KS50aGVuKGZ1bmN0aW9uKG1vZGFsKSB7XG4gICAgICAkcm9vdFNjb3BlLnBpbm1vZGFsID0gbW9kYWw7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS5jbG9zZVBpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHJvb3RTY29wZS5waW5tb2RhbC5oaWRlKCk7XG4gICAgICBpZiAoJHJvb3RTY29wZS5waW5lbmFibGVkKSB7XG4gICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmRGF0YSkge1xuICAgICAgICAgIHZhciBhbGVydFBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICB0aXRsZTogJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEudGl0bGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEuYm9keSArICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdPUEVOSU5HX1BPU1QnKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFsZXJ0UG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdUaGFuayB5b3UgZm9yIHNlZWluZyBhbGVydCBmcm9tIHRyYXknKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3Blbih7YXV0aG9yOiRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZEYXRhLmF1dGhvciwgcGVybWxpbms6JHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEucGVybWxpbmt9KTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcIm5vdCBzdXJlIHRvIG9wZW4gYWxlcnRcIik7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHJvb3RTY29wZS5waW5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgICRyb290U2NvcGUub3BlblBpbiA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICRyb290U2NvcGUucGFzc2NvZGUgPSBcIlwiO1xuICAgICAgaWYgKHR5cGUgPT0gMCkge1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnR5cGUgPSAwO1xuICAgICAgICAkcm9vdFNjb3BlLnBpbnRpdGxlID0gJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFVF9QSU4nKTtcbiAgICAgICAgJHJvb3RTY29wZS5waW5zdWJ0aXRsZSA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRVRfUElOJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PSAxKSB7XG4gICAgICAgICRyb290U2NvcGUucGludHlwZSA9IDE7XG4gICAgICAgICRyb290U2NvcGUucGludHJ5ID0gMDtcbiAgICAgICAgJHJvb3RTY29wZS5waW50aXRsZSA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFTlRFUl9QSU4nKTtcbiAgICAgICAgJHJvb3RTY29wZS5waW5zdWJ0aXRsZSA9ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFTlRFUl9QSU4nKTtcbiAgICAgIH1cbiAgICAgICRyb290U2NvcGUucGlubW9kYWwuc2hvdygpO1xuICAgIH07XG4gICAgJHJvb3RTY29wZS4kb24oXCJwaW46bmV3XCIsIGZ1bmN0aW9uKCl7XG4gICAgICAkcm9vdFNjb3BlLnBpbmNoZWNrID0gZmFsc2U7XG4gICAgICAkcm9vdFNjb3BlLm9wZW5QaW4oMCk7XG4gICAgfSk7XG4gICAgJHJvb3RTY29wZS4kb24oXCJwaW46Y2hlY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICRyb290U2NvcGUucGluY2hlY2sgPSB0cnVlO1xuICAgICAgJHJvb3RTY29wZS5vcGVuUGluKDEpO1xuICAgIH0pO1xuXG5cbiAgICAkaW9uaWNNb2RhbC5mcm9tVGVtcGxhdGVVcmwoJ3RlbXBsYXRlcy9pbmZvLmh0bWwnLCB7XG4gICAgICBzY29wZTogJHJvb3RTY29wZVxuICAgICAgLy9hbmltYXRpb246IFwibnVsbFwiXG4gICAgfSkudGhlbihmdW5jdGlvbihtb2RhbCkge1xuICAgICAgJHJvb3RTY29wZS5pbmZvbW9kYWwgPSBtb2RhbDtcbiAgICB9KTtcbiAgICAkcm9vdFNjb3BlLm9wZW5JbmZvID0gZnVuY3Rpb24oeHgpIHtcbiAgICAgIGlmICh4eC5hY3RpdmVfdm90ZXMubGVuZ3RoPT0wKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9hY3RpdmVfdm90ZXNcIiwgW3h4LmF1dGhvciwgeHgucGVybWxpbmtdKS50aGVuKGZ1bmN0aW9uKGRkKXtcbiAgICAgICAgICB4eC5hY3RpdmVfdm90ZXMgPSBkZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAkcm9vdFNjb3BlLnZvdGVycyA9IHh4O1xuICAgICAgJHJvb3RTY29wZS5pbmZvbW9kYWwuc2hvdygpO1xuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLmNsb3NlSW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgJHJvb3RTY29wZS5pbmZvbW9kYWwuaGlkZSgpO1xuICAgICAgLy8kcm9vdFNjb3BlLmluZm9tb2RhbC5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQXQ9ZnVuY3Rpb24oaW5kZXgsIGNoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzdHIoMCwgaW5kZXgpICsgY2hhcmFjdGVyICsgdGhpcy5zdWJzdHIoaW5kZXgrY2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgfVxuXHRcdCRyb290U2NvcGUub3BlbkRyYWZ0ID0gZnVuY3Rpb24oaXRlbSl7XG5cdFx0XHRpdGVtLm9wZXJhdGlvbl90eXBlID0gaXRlbS5wb3N0X3R5cGU7XG5cdFx0XHQkcm9vdFNjb3BlLiRzdG9yYWdlLnNwb3N0ID0gaXRlbTtcblx0XHRcdCRzdGF0ZS5nbygnYXBwLnBvc3RzJyk7XG5cdFx0XHQkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ29wZW5Qb3N0TW9kYWwnKTtcblx0XHR9XG4gICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3BlbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHdpbmRvdy5BcGkuZGF0YWJhc2VfYXBpKCkuZXhlYyhcImdldF9jb250ZW50XCIsIFtpdGVtLmF1dGhvciwgaXRlbS5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICB2YXIgX2xlbiA9IHJlc3VsdC5hY3RpdmVfdm90ZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGogPSBfbGVuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWN0aXZlX3ZvdGVzW2pdLnZvdGVyID09PSAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3RpdmVfdm90ZXNbal0ucGVyY2VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmFjdGl2ZV92b3Rlc1tqXS5wZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kb3dudm90ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXN1bHQudXB2b3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbihyZXN1bHQuanNvbl9tZXRhZGF0YSk7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZXN1bHQ7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IGl0ZW07XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vJHN0YXRlLmdvKCdhcHAucG9zdCcpO1xuICAgICAgICAgICAgJHN0YXRlLmdvKCdhcHAucG9zdCcsIHtjYXRlZ29yeTogaXRlbS5jYXRlZ29yeSwgYXV0aG9yOiBpdGVtLmF1dGhvciwgcGVybWxpbms6IGl0ZW0ucGVybWxpbmt9KTtcblxuICAgICAgICAgIH0sIDUpO1xuXG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5yZUJsb2cgPSBmdW5jdGlvbihhdXRob3IsIHBlcm1saW5rKSB7XG4gICAgICB2YXIgY29uZmlybVBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVCTE9HX1RFWFQnKVxuICAgICAgfSk7XG4gICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgICAgIHZhciBsb2dpblN1Y2Nlc3MgPSAkcm9vdFNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc3Rpbmc6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wb3N0aW5nLmtleV9hdXRoc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgdmFyIGpzb247XG5cbiAgICAgICAgICAgICAgICBqc29uID0gW1wicmVibG9nXCIse2FjY291bnQ6JHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBhdXRob3I6YXV0aG9yLCBwZXJtbGluazpwZXJtbGlua31dO1xuXG4gICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY3VzdG9tX2pzb25cIiwge1xuICAgICAgICAgICAgICAgICAgaWQ6ICdmb2xsb3cnLFxuICAgICAgICAgICAgICAgICAgcmVxdWlyZWRfcG9zdGluZ19hdXRoczogWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZV0sXG4gICAgICAgICAgICAgICAgICBqc29uOiBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkcm9vdFNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ1JFQkxPR19URVhUJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLnJlZnJlc2hGb2xsb3dlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnUkVCTE9HR0VEX1BPU1QnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkcm9vdFNjb3BlLnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCwgdHlwZSwgYWZ0ZXJ3YXJkKSB7XG4gICAgICBwb3N0Lmludm90aW5nID0gdHJ1ZTtcbiAgICAgIHZhciB0dCA9IDE7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ1cHZvdGVcIikge1xuICAgICAgICB0dCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJkb3dudm90ZVwiKSB7XG4gICAgICAgIHR0ID0gLTE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJ1bnZvdGVcIikge1xuICAgICAgICB0dCA9IDA7XG4gICAgICB9XG4gICAgICAkcm9vdFNjb3BlLmxvZygndm90aW5nICcrdHQpO1xuICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJBcGkgcmVhZHk6XCIgKyBhbmd1bGFyLnRvSnNvbihyZXNwb25zZSkpO1xuICAgICAgICAgIHZhciBteWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICBteWxvZ2luLnNldFJvbGVzKFtcInBvc3RpbmdcIl0pO1xuICAgICAgICAgIC8vY29uc29sZS5sb2coJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKTtcbiAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gbXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwidm90ZVwiLCB7XG4gICAgICAgICAgICAgICAgdm90ZXI6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBhdXRob3I6IHBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgICAgIHBlcm1saW5rOiBwb3N0LnBlcm1saW5rLFxuICAgICAgICAgICAgICAgIHdlaWdodDogJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0KnR0IHx8IDEwMDAwKnR0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKG15bG9naW4sIG51bGwsIHRydWUpOyAgXG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHBvc3QuaW52b3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0dD4wKXtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc3QudXB2b3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0dDwwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3N0LmRvd252b3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc3QudXB2b3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zdC5kb3dudm90ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyd2FyZCA9PT0gJ2ZldGNoQ29udGVudCcpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdChhZnRlcndhcmQsIHsgYW55OiB7YXV0aG9yOiBwb3N0LmF1dGhvciwgcGVybWxpbms6IHBvc3QucGVybWxpbmt9IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoYWZ0ZXJ3YXJkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcblxuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgIHBvc3QuaW52b3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgcG9zdC5pbnZvdGluZyA9IGZhbHNlO1xuICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5pc1dpdG5lc3NWb3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlciAmJiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIud2l0bmVzc192b3Rlcy5pbmRleE9mKFwiZ29vZC1rYXJtYVwiKT4tMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgICRyb290U2NvcGUudm90ZVdpdG5lc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmZpcm1Qb3B1cCA9ICRpb25pY1BvcHVwLmNvbmZpcm0oe1xuICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdWT1RFX0ZPUl9XSVRORVNTJykrXCIgQGdvb2Qta2FybWFcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlybVBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91IGFyZSBzdXJlJyk7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ3Nob3c6bG9hZGluZycpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlQWN0aXZlS2V5KSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wiYWN0aXZlXCJdKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHJvb3RTY29wZS5teWxvZ2luLmNoZWNrS2V5cyh7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnROYW1lOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYXV0aHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLmFjdGl2ZS5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVBY3RpdmVLZXkgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGxvZ2luU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHRyID0gbmV3IHdpbmRvdy5lanMuVHJhbnNhY3Rpb25CdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJhY2NvdW50X3dpdG5lc3Nfdm90ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGFwcHJvdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgd2l0bmVzczogXCJnb29kLWthcm1hXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmVycm9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkcm9vdFNjb3BlLm15bG9naW4sIG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmVycm9yID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLnJlZnJlc2hGb2xsb3dlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksJGZpbHRlcigndHJhbnNsYXRlJykoJ1ZPVEVEX0ZPUl9XSVRORVNTJykrJyBAZ29vZC1rYXJtYScpO1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgncmVmcmVzaExvY2FsVXNlckRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd01lc3NhZ2UoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdMT0dJTl9GQUlMJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJHJvb3RTY29wZS5mb2xsb3dpbmcgPSBmdW5jdGlvbih4eCwgbXR5cGUpIHtcbiAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAkcm9vdFNjb3BlLmxvZyh4eCk7XG4gICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgJHJvb3RTY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgdmFyIGxvZ2luU3VjY2VzcyA9ICRyb290U2NvcGUubXlsb2dpbi5jaGVja0tleXMoe1xuICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICBwYXNzd29yZDogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICAgICAgICAgIGF1dGhzOiB7XG4gICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnByaXZhdGVQb3N0aW5nS2V5IHx8IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsb2dpblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgICAgICAgICAgdmFyIGpzb247XG4gICAgICAgICAgICBpZiAobXR5cGUgPT09IFwiZm9sbG93XCIpIHtcbiAgICAgICAgICAgICAganNvbiA9IFsnZm9sbG93Jyx7Zm9sbG93ZXI6JHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCBmb2xsb3dpbmc6eHgsIHdoYXQ6IFtcImJsb2dcIl19XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGpzb24gPSBbJ2ZvbGxvdycse2ZvbGxvd2VyOiRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSwgZm9sbG93aW5nOnh4LCB3aGF0OiBbXX1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ci5hZGRfdHlwZV9vcGVyYXRpb24oXCJjdXN0b21fanNvblwiLCB7XG4gICAgICAgICAgICAgIGlkOiAnZm9sbG93JyxcbiAgICAgICAgICAgICAgcmVxdWlyZWRfcG9zdGluZ19hdXRoczogWyRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZV0sXG4gICAgICAgICAgICAgIGpzb246IGFuZ3VsYXIudG9Kc29uKGpzb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5lcnJvciA9IDA7XG4gICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRyb290U2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyRzY29wZS5yZWZyZXNoRm9sbG93ZXJzKCk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdjdXJyZW50OnJlbG9hZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2ZlZWRfaGlzdG9yeVwiLCBbXSkudGhlbihmdW5jdGlvbihyKXtcbiAgICAgICAgLy8kcm9vdFNjb3BlLmxvZyhyKTtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmJhc2UgPSByLmN1cnJlbnRfbWVkaWFuX2hpc3RvcnkuYmFzZS5zcGxpdChcIiBcIilbMF07XG4gICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2R5bmFtaWNfZ2xvYmFsX3Byb3BlcnRpZXNcIiwgW10pLnRoZW4oZnVuY3Rpb24ocil7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhyKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2Uuc3RlZW1fcGVyX212ZXN0cyA9IChOdW1iZXIoci50b3RhbF92ZXN0aW5nX2Z1bmRfc3RlZW0uc3Vic3RyaW5nKDAsIHIudG90YWxfdmVzdGluZ19mdW5kX3N0ZWVtLmxlbmd0aCAtIDYpKSAvIE51bWJlcihyLnRvdGFsX3Zlc3Rpbmdfc2hhcmVzLnN1YnN0cmluZygwLCByLnRvdGFsX3Zlc3Rpbmdfc2hhcmVzLmxlbmd0aCAtIDYpKSkgKiAxZTY7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgMTApO1xuICAgIGlmICghYW5ndWxhci5pc0RlZmluZWQoJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZmljYXRpb25zKSkge1xuICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZmljYXRpb25zID0gW107XG4gICAgfVxuICAgICRyb290U2NvcGUuJG9uKCdjaGFuZ2VkQ2hhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgY29uc29sZS5sb2coJ2NoYWluIGRpZmZlcnMnKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zb2NrZXRVcmwgPSAkcm9vdFNjb3BlLiRzdG9yYWdlW1wic29ja2V0XCIrJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbl07XG4gICAgICB3aW5kb3cuZWpzLkNoYWluQ29uZmlnLnNldENoYWluSWQobG9jYWxTdG9yYWdlWyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCJJZFwiXSk7XG4gICAgICB3aW5kb3cuQXBpLmNsb3NlKCk7XG4gICAgICB3aW5kb3cuQXBpID0gd2luZG93LnN0ZWVtUlBDLkNsaWVudC5nZXQoe3VybDogbG9jYWxTdG9yYWdlLnNvY2tldFVybH0sIHRydWUpO1xuICAgICAgXG4gICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHsgIFxuICAgICAgICBhbmd1bGFyLmZvckVhY2goJHJvb3RTY29wZS4kc3RvcmFnZS51c2VycywgZnVuY3Rpb24odixrKXtcbiAgICAgICAgICBpZiAodi5jaGFpbiA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKXtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UudXNlciA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICBcbiAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID09ICdzdGVlbScpe1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwiU3RlZW1cIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXBvd2VyID0gXCJTdGVlbSBQb3dlclwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3Jtc3VuaXQgPSBcIlN0ZWVtXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1kb2xsYXIgPSBcIlN0ZWVtIERvbGxhclwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQgPSBcIlNCRFwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcHVuaXQgPSBcIlNQXCI7XG4gICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGxhdGZvcm1sdW5pdCA9IFwiU1RFRU1cIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5zb2NrZXRzdGVlbSA9IFwid3NzOi8vc3RlZW1kLnN0ZWVtaXQuY29tXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtbmFtZSA9IFwi0JPQntCb0J7QoVwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtcG93ZXIgPSBcItCh0JjQm9CQINCT0J7Qm9Ce0KHQkFwiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3Jtc3VuaXQgPSBcItCT0L7Qu9C+0YFcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWRvbGxhciA9IFwi0JfQntCb0J7QotCe0JlcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWR1bml0ID0gXCJHQkdcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybXB1bml0ID0gXCJHT0xPU1BcIjtcbiAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5wbGF0Zm9ybWx1bml0ID0gXCJHT0xPU1wiO1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnNvY2tldGdvbG9zID0gXCJ3c3M6Ly93cy5nb2xvcy5pby9cIjtcbiAgICAgICAgLy8kc2NvcGUuc29ja2V0ID0gXCJ3c3M6Ly9nb2xvcy5zdGVlbS53c1wiO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrRGF0ZShkYXRlLCBpZ25vcmUpIHtcbiAgICAgIHZhciBlb2xkID0gODY0MDAwMDA7IC8vMSAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vMSBkYXkgb2xkXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICB2YXIgb2xkID0gbmV3IERhdGUoZGF0ZSkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIGlnbm9yZXx8bm93LW9sZD49ZW9sZDtcbiAgICB9XG4gICAgJHJvb3RTY29wZS4kb24oJ2NoYW5nZWRDdXJyZW5jeScsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcbiAgICAgIHZhciB4eCA9IGFyZ3MuY3VycmVuY3k7XG4gICAgICB2YXIgaWdub3JlID0gYXJncy5lbmZvcmNlO1xuICAgICAgY29uc29sZS5sb2coeHgpO1xuICAgICAgdmFyIHJlc3VsdE9iamVjdCA9ICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5maWx0ZXIoZnVuY3Rpb24gKCBvYmogKSB7XG4gICAgICAgICAgcmV0dXJuIG9iai5pZCA9PT0geHg7XG4gICAgICB9KVswXTtcbiAgICAgIC8vc2VhcmNoT2JqKHh4LCAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmNpZXMpO1xuICAgICAgaWYgKGNoZWNrRGF0ZShyZXN1bHRPYmplY3QuZGF0ZSwgaWdub3JlKSkge1xuICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbiA9PSAnc3RlZW0nKXtcbiAgICAgICAgICBBUElzLmdldEN1cnJlbmN5UmF0ZShcIlVTRFwiLCB4eCApLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlID0gTnVtYmVyKHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5SYXRlKTtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5maWx0ZXIoZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgICAgaWYgKG9iai5pZCA9PSB4eCkge1xuICAgICAgICAgICAgICAgIG9iai5yYXRlID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgb2JqLmRhdGUgPSByZXMuZGF0YS5xdWVyeS5yZXN1bHRzLnJhdGUuRGF0ZT09PVwiTi9BXCI/bmV3IERhdGUoKSA6IHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5EYXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBUElzLmdldEN1cnJlbmN5UmF0ZShcIlhBVVwiLCB4eCApLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIC8vWEFVIC0gMzEuMTAzNDc2OGdcbiAgICAgICAgICAgIC8vR0JHIHJhdGUgaW4gbWcuIHNvIGV4Y2hhbmdlUmF0ZS8zMTEwMy40NzY4XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSA9IE51bWJlcihyZXMuZGF0YS5xdWVyeS5yZXN1bHRzLnJhdGUuUmF0ZSkvMzExMDMuNDc2ODtcbiAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY2llcy5maWx0ZXIoZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgICAgICAgaWYgKG9iai5pZCA9PSB4eCkge1xuICAgICAgICAgICAgICAgIG9iai5yYXRlID0gJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgb2JqLmRhdGUgPSByZXMuZGF0YS5xdWVyeS5yZXN1bHRzLnJhdGUuRGF0ZT09PVwiTi9BXCI/bmV3IERhdGUoKSA6IHJlcy5kYXRhLnF1ZXJ5LnJlc3VsdHMucmF0ZS5EYXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSA9IHJlc3VsdE9iamVjdC5yYXRlO1xuICAgICAgfVxuICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh3aW5kb3cuY29yZG92YSkge1xuICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc1dpbmRvd3NQaG9uZSgpKSB7XG4gICAgICAgIGlmIChpb25pYy5QbGF0Zm9ybS5pc0lPUygpIHx8IGlvbmljLlBsYXRmb3JtLmlzSVBhZCgpKSB7XG4gICAgICAgICAgLy93aW5kb3cuRmlyZWJhc2VQbHVnaW4uZ3JhbnRQZXJtaXNzaW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5nZXRUb2tlbihmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSB0aGlzIHNlcnZlci1zaWRlIGFuZCB1c2UgaXQgdG8gcHVzaCBub3RpZmljYXRpb25zIHRvIHRoaXMgZGV2aWNlXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImRldmljZSBcIit0b2tlbik7XG4gICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkID0gdG9rZW47XG4gICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQVBJcy5zYXZlU3Vic2NyaXB0aW9uKHRva2VuLCBcIlwiLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pOyovXG5cbiAgICAgICAgRkNNUGx1Z2luLmdldFRva2VuKGZ1bmN0aW9uKHRva2VuKXtcbiAgICAgICAgICAvLyBzYXZlIHRoaXMgc2VydmVyLXNpZGUgYW5kIHVzZSBpdCB0byBwdXNoIG5vdGlmaWNhdGlvbnMgdG8gdGhpcyBkZXZpY2VcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhcImRldmljZSBcIit0b2tlbik7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5kZXZpY2VpZCA9IHRva2VuO1xuICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLCB7IGRldmljZTogaW9uaWMuUGxhdGZvcm0ucGxhdGZvcm0oKSB9KS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGFuZ3VsYXIudG9Kc29uKHJlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFQSXMuc2F2ZVN1YnNjcmlwdGlvbih0b2tlbiwgXCJcIiwgeyBkZXZpY2U6IGlvbmljLlBsYXRmb3JtLnBsYXRmb3JtKCkgfSkudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyp3aW5kb3cuRmlyZWJhc2VQbHVnaW4ub25Ub2tlblJlZnJlc2goZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICBBUElzLnVwZGF0ZVRva2VuKCRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQsIHRva2VuKS50aGVuKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhhbmd1bGFyLnRvSnNvbihyZXMpKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZGV2aWNlaWQgPSB0b2tlbiAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH0pOyovXG4gICAgICAgIEZDTVBsdWdpbi5vblRva2VuUmVmcmVzaChmdW5jdGlvbih0b2tlbil7XG4gICAgICAgICAgQVBJcy51cGRhdGVUb2tlbigkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkLCB0b2tlbikudGhlbihmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coYW5ndWxhci50b0pzb24ocmVzKSk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cykge1xuICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmRldmljZWlkID0gdG9rZW4gIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kJHBoYXNlKXtcbiAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvKndpbmRvdy5GaXJlYmFzZVBsdWdpbi5vbk5vdGlmaWNhdGlvbk9wZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFuZ3VsYXIudG9Kc29uKGRhdGEpKTtcblxuICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLm5vdGlmaWNhdGlvbnMucHVzaCh7dGl0bGU6ZGF0YS50aXRsZSwgbWVzc2FnZTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGluaywgY3JlYXRlZDogbmV3IERhdGUoKX0pO1xuXG4gICAgICAgICAgICBpZihkYXRhLnRhcCl7XG4gICAgICAgICAgICAgIC8vTm90aWZpY2F0aW9uIHdhcyByZWNlaXZlZCBvbiBkZXZpY2UgdHJheSBhbmQgdGFwcGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgICAgICBpZiAoZGF0YS5hdXRob3IgJiYgZGF0YS5wZXJtbGluaykge1xuICAgICAgICAgICAgICAgIGlmICghJHJvb3RTY29wZS4kc3RvcmFnZS5waW5jb2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBhbGVydFBvcHVwID0gJGlvbmljUG9wdXAuY29uZmlybSh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGF0YS5ib2R5ICsgJGZpbHRlcigndHJhbnNsYXRlJykoJ09QRU5JTkdfUE9TVCcpXG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgYWxlcnRQb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnVGhhbmsgeW91IGZvciBzZWVpbmcgYWxlcnQgZnJvbSB0cmF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3Blbih7YXV0aG9yOmRhdGEuYXV0aG9yLCBwZXJtbGluazpkYXRhLnBlcm1saW5rfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB7dGl0bGU6ZGF0YS50aXRsZSwgYm9keTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGlua307XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgaW4gZm9yZWdyb3VuZC4gTWF5YmUgdGhlIHVzZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQuXG4gICAgICAgICAgICAgIC8vYWxlcnQoIEpTT04uc3RyaW5naWZ5KGRhdGEpICk7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkrXCIgXCIrZGF0YS5wZXJtbGluayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgICovXG5cbiAgICAgICAgLy9GQ01QbHVnaW4ub25Ob3RpZmljYXRpb24oIG9uTm90aWZpY2F0aW9uQ2FsbGJhY2soZGF0YSksIHN1Y2Nlc3NDYWxsYmFjayhtc2cpLCBlcnJvckNhbGxiYWNrKGVycikgKVxuICAgICAgICAvL0hlcmUgeW91IGRlZmluZSB5b3VyIGFwcGxpY2F0aW9uIGJlaGF2aW91ciBiYXNlZCBvbiB0aGUgbm90aWZpY2F0aW9uIGRhdGEuXG4gICAgICAgIEZDTVBsdWdpbi5vbk5vdGlmaWNhdGlvbihmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihkYXRhKSk7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYW5ndWxhci50b0pzb24oZGF0YSkpO1xuXG4gICAgICAgICAgICAvLyRyb290U2NvcGUuJHN0b3JhZ2Uubm90aWZpY2F0aW9ucy5wdXNoKHt0aXRsZTpkYXRhLnRpdGxlLCBtZXNzYWdlOiBkYXRhLmJvZHksIGF1dGhvcjogZGF0YS5hdXRob3IsIHBlcm1saW5rOiBkYXRhLnBlcm1saW5rLCBjcmVhdGVkOiBuZXcgRGF0ZSgpfSk7XG5cbiAgICAgICAgICAgIGlmKGRhdGEud2FzVGFwcGVkKXtcbiAgICAgICAgICAgICAgLy9Ob3RpZmljYXRpb24gd2FzIHJlY2VpdmVkIG9uIGRldmljZSB0cmF5IGFuZCB0YXBwZWQgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiRzdG9yYWdlLnBpbmNvZGUpIHtcblxuICAgICAgICAgICAgICAgICAgdmFyIGFsZXJ0UG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkYXRhLmJvZHkgKyAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnT1BFTklOR19QT1NUJylcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBhbGVydFBvcHVwLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdUaGFuayB5b3UgZm9yIHNlZWluZyBhbGVydCBmcm9tIHRyYXknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoYWluICE9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWluID0gZGF0YS5jaGFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnY2hhbmdlZENoYWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2NoYW5nZWRDdXJyZW5jeScsIHtjdXJyZW5jeTogJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeSwgZW5mb3JjZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5nZXRDb250ZW50QW5kT3Blbih7YXV0aG9yOmRhdGEuYXV0aG9yLCBwZXJtbGluazpkYXRhLnBlcm1saW5rfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKFwibm90IHN1cmUgdG8gb3BlbiBhbGVydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5ub3RpZkRhdGEgPSB7dGl0bGU6ZGF0YS50aXRsZSwgYm9keTogZGF0YS5ib2R5LCBhdXRob3I6IGRhdGEuYXV0aG9yLCBwZXJtbGluazogZGF0YS5wZXJtbGlua307XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnBpbmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAvL05vdGlmaWNhdGlvbiB3YXMgcmVjZWl2ZWQgaW4gZm9yZWdyb3VuZC4gTWF5YmUgdGhlIHVzZXIgbmVlZHMgdG8gYmUgbm90aWZpZWQuXG4gICAgICAgICAgICAgIC8vYWxlcnQoIEpTT04uc3RyaW5naWZ5KGRhdGEpICk7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmF1dGhvciAmJiBkYXRhLnBlcm1saW5rKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkrXCIgXCIrZGF0YS5wZXJtbGluayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZShkYXRhLnRpdGxlLCBkYXRhLmJvZHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfVxuXG4gIH0pO1xufSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvcG9zdHMvaW5kZXguanNcIixcIi9wb3N0c1wiKSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi2KfZhNi12YHYrdipINin2YTYsdim2YrYs9mK2KlcIixcblx0XCJMT0dJTlwiOiBcItiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEXCIsXG5cdFwiTE9HT1VUXCI6IFwi2KrYs9is2YrZhCDYp9mE2K7YsdmI2KxcIixcblx0XCJQUk9GSUxFXCI6IFwi2KfZhNi12YHYrdipINin2YTYtNiu2LXZitipXCIsXG5cdFwiRk9MTE9XXCI6IFwi2KrYp9io2LlcIixcblx0XCJCT09LTUFSS1NcIjogXCLZhdik2LTYsdin2KpcIixcblx0XCJUUkFOU0ZFUlwiOiBcItiq2K3ZiNmK2YRcIixcblx0XCJNQVJLRVRcIjogXCLYp9mE2LPZiNmCXCIsXG5cdFwiU0VUVElOR1NcIjogXCLYpdi52K/Yp9iv2KfYqlwiLFxuXHRcIkFCT1VUXCI6IFwi2LnZhlwiLFxuXHRcIkFCT1VUXzFcIjogXCLYrdmK2Ksg2YrYs9iq2LfZiti5INin2Yog2LTYrti1INin2YTYrdi12YjZhCDYudmE2Yog2YXZg9in2YHYptin2Kog2YXZgtin2KjZhCDYp9mE2YXYrdiq2YjZiiDYp9mE2K7Yp9i1INio2YdcIixcblx0XCJBQk9VVF8yXCI6IFwi2YXYr9i52YjZhSDZhdmGIHsgfSDZhdmG2LXYqS4gXCIsXG5cdFwiQUJPVVRfM1wiOiBcItmI2YfZiCDZhdmB2KrZiNitINin2YTZhdi12K/YsdiMINiw2KfYqiDYqti12YXZitmFINil2KzYqtmF2KfYudmKINmF2LXZhdmFINmE2YTZh9mI2KfYqtmBINin2YTZhtmC2KfZhNipLiDZiCDZitmI2YHYsSDYp9mE2YjYtdmI2YQg2KXZhNmJINin2YTZhdit2KrZiNmJINmE2YTZgtix2KfYodip2Iwg2KfZhNiq2LnZhNmK2YLYjCDZiNin2YTYqti12YjZitiq2Iwg2YjYp9mE2KrYr9mI2YrZhtiMINmG2YLZhCDYp9mE2KPYsdio2KfYrdiMINil2YTYriDYp9mE2YXZitiy2KfYqiDYp9mE2KrZiiDYqtiq2YrYrdmH2Kcg2LPZhNiz2YTYqSDYp9mE2YPYqtmEIHt7cGxhdGZvcm1uYW1lfX0g2Ygge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCLZhNinXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuINin2YTYqti32KjZitmCINmK2YjZgdixINmG2YXZiNiw2Kwg2KPZhdmGINmF2YbYrdin2LIg2YTZhNi52YXZitmE2Iwg2YXYuSDYp9mE2YXZgdin2KrZititINin2YTYrtin2LXYqSDYpdiz2KrYttin2YHYqiDZhdit2YTZitinINmIINmE2YYg2KrYsdiz2YQg2KPYqNiv2Kcg2KXZhNmJINij2YrYqSDYrtmI2KfYr9mFLlwiLFxuXHRcIkFCT1VUXzZcIjogXCLZitmC2K/ZhSDYp9mE2KrYt9io2YrZgiDZiNin2KzZh9in2Kog2KfZhNmF2LPYqtiu2K/ZhSDYqNiz2YrYt9ip2Iwg2KzYsNin2KjYqSDZiNiq2KjYp9iv2YQg2KfZhNiu2KjYsdin2KogXCIsXG5cdFwiQUJPVVRfN1wiOiBcItmE2Kcg2YrYt9mE2Kgg2KfZhNiq2LfYqNmK2YIg2YXZhiDYp9mE2YXYs9iq2K7Yr9mF2YrZhiDYp9iv2K7Yp9mEINmF2LnZhNmI2YXYp9iq2YfZhSDYp9mE2LTYrti12YrYqVwiLFxuXHRcIkFCT1VUXzhcIjogXCLYtdmI2Kog2YQgZ29vZC1rYXJtYSDZg9i02KfZh9ivXCIsXG5cdFwiQUJPVVRfOVwiOiBcItmE2YTYqtmI2KfYtdmELyDZhdmE2KfYrdi42KfYqlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi2YTZhNmF2LLZitivINmF2YYg2KfZhNmF2LnZhNmI2YXYp9iqXCIsXG5cdFwiUkVNT1ZFXCI6IFwi2K3YsNmBXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLYudix2LYg2KfZhNiz2YjZglwiLFxuXHRcIlBSSUNFXCI6IFwi2KfZhNiz2LnYsVwiLFxuXHRcIkFNT1VOVFwiOiBcItmD2YXZitipXCIsXG5cdFwiVE9UQUxcIjogXCLZhdis2YXZiNi5XCIsXG5cdFwiTk9PUkRFUlNcIjogXCLZhNinINiq2YjYrNivINi32YTYqNin2KpcIixcblx0XCJEQVRFXCI6IFwi2KfZhNiq2KfYsdmK2K5cIixcblx0XCJCVVlcIjogXCLYtNix2KfYoVwiLFxuXHRcIlNFTExcIjogXCLYqNmK2LlcIixcblx0XCJPUEVOXCI6IFwi2YXZgdiq2YjYrVwiLFxuXHRcIkhJU1RPUllcIjogXCLYp9mE2KrYp9ix2YrYrlwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwi2YXYqtin2KjYudipXCIsXG5cdFwiRk9MTE9XRURcIjogXCLYp9mE2YXYqtin2KjYudipXCIsXG5cdFwiVU5GT0xMT1dcIjogXCLYp9mE2LrYp9ihINin2YTZhdiq2KfYqNi52KlcIixcblx0XCJGT0xMT1dJTkdcIjogXCLYqtmFINin2YTZhdiq2KfYqNi52KlcIixcblx0XCJGT0xMT1dFUlNcIjogXCLZhdiq2KfYqNi52YjZhlwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLYp9io2K3YqyDZgdmKINin2YTZhdiq2KfYqNi52YjZhlwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCLYp9io2K3YqyDZgdmKINin2YTZhdiq2KjYudmI2YZcIixcblx0XCJCWVwiOiBcItio2YjYp9iz2LfYqVwiLFxuXHRcIklOXCI6IFwi2YHZiVwiLFxuXHRcIk1FTlVcIjogXCLYp9mE2YLYp9im2YXYqVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwi2KfZhNmF2YHYttmE2KlcIixcblx0XCJSRUJMT0dcIjogXCLYtNin2LHZg1wiLFxuXHRcIlVQVk9URVwiOiBcItin2YTYqti12YjZitiqINmE2YTYo9i52YTZilwiLFxuXHRcIkRPV05WT1RFXCI6IFwi2KfZhNiq2LXZiNmK2Kog2YTZhNij2LPZgdmEXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcItmE2KfYs9iq2LHYrNin2Lkg2KfZhNiq2LXZiNmK2Kog2YTZhNij2LPZgdmEXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLZhNin2LPYqtix2KzYp9i5INin2YTYqti12YjZitiqINmE2YTYo9i52YTZilwiLFxuXHRcIlJFUExZXCI6IFwi2YTZhNiq2LnZhNmK2YJcIixcblx0XCJFRElUXCI6IFwi2KrYudiv2YrZhFwiLFxuXHRcIlBPU1RfMVwiOiBcItil2LPYrdioINin2YTYqti52YTZitmC2KfYqiDZhNmE2YrYs9in2LEg2YTZhdi02KfZh9iv2Kkg2KfZhNiu2YrYp9ix2KfYqlwiLFxuXHRcIlBPU1RfMlwiOiBcItin2LbYuti3INi52YTZiSDYqti52YTZitmC2KfYqiDZhNmF2LTYp9mH2K/YqSDYp9mE2KrYudmE2YrZgtin2Kog2KfZhNmB2LHYudmK2KlcIixcblx0XCJPUFRJT05TXCI6IFwi2KfZhNiu2YrYp9ix2KfYqlwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcItiq2YXYqiDZhdi02KfYsdmD2KrZhyDZhdmGXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwi2YTYpyDZitmI2KzYryDYtNimINmH2YbYpyDYrdiq2Ykg2KfZhNin2YZcIixcblx0XCJCQUxBTkNFU1wiOiBcItin2YTYrdiz2KfYqNin2KpcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX192Iwg2KfZhNix2YXZiNiyINin2YTZgtin2KjZhNipINmE2YTYqtiv2KfZiNmEINin2YTYqtmKINmK2YXZg9mGINmG2YLZhNmH2Kcg2YHZiiDYo9mKINmI2YLYqi4g2YjZitmF2YPZhiDYqtit2YjZitmE2YfYpyB7e3BsYXRmb3JtbmFtZX19INil2YTZiSB7e3BsYXRmb3JtcG93ZXJ9fSDZgdmKINi52YXZhNmK2Kkg2KrYs9mF2Ykg2LHZgdi5INin2YTYt9in2YLYqS5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fdiMINix2YXZiNiyINin2YTYqtij2KvZitixINin2YTZhdmF2YrYstipINin2YTYqtmKINiq2YPYs9ioINin2YTZhdiy2YrYryDZhdmGINin2YTYs9mE2LfYqSDZhNi52YLYryDYt9mI2YrZhCDYp9mE2KPYrNmE2Iwg2YjYp9mE2KrYtdmI2YrYqiDYudmE2Ykg2KfZhNmF2YjYp9i22YrYuS4g2YPZhNmF2Kcg2KfZhNmF2LHYoSDZitit2YXZhCDYo9mD2KvYsSDZg9mE2YXYpyDZitij2KvYsSDYo9mD2KvYsSDYudmE2Ykg2YXZg9in2YHYotiqINin2YTYotiu2LHZitmGINmIINmK2YPYs9ioINmF2YPYp9mB2KLYqiDZhNmE2KrYtdmI2YrYqtin2Kog2K/ZgtmK2YLYqS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCLYp9mE2LnZhdmE2KfYqiDYp9mE2LHZhdiy2YrYqSDYqti12YQg2YLZitmF2KrZh9inINil2YTZiSDYrdmI2KfZhNmKIHt7cGxhdGZvcm1zdW5pdH19IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi2KfZhNmC2YrZhdmHINin2YTZhdiq2YjZgti52YdcIixcblx0XCJQUk9GSUxFXzRcIjogXCLYp9mE2YLZitmF2Ycg2KfZhNmF2KrZiNmC2LnZhyDYqtiz2KrZhtiv2LnZhNmJINmF2KrZiNiz2Lcg2YLZitmF2Kk3INij2YrYp9mFXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcItiq2KfYsdmK2K4g2KfZhNiq2K3ZiNmK2YTYp9iqXCIsXG5cdFwiUE9TVElOR1wiOiBcItil2LHYs9in2YRcIixcblx0XCJQUk9GSUxFXzVcIjogXCLZhdmB2KrYp9itINin2YTZhti02LEg2YrYs9iq2K7Yr9mFINmE2YTZhti02LEg2Ygg2KfZhNiq2LXZiNmK2KouINmK2YbYqNi62Yog2KPZhiDZitmD2YjZhiDZhdiu2KrZhNmBINi52YYg2KfZhNmF2YHYp9iq2YrYrSDYp9mE2YbYtNi32Kkg2Ygg2KfZhNmF2KfZhNmDLlwiLFxuXHRcIk9XTkVSXCI6IFwi2KfZhNmF2KfZhNmDXCIsXG5cdFwiUFJPRklMRV82XCI6IFwi2YXZgdiq2KfYrSDYp9mE2YXYp9mE2YMg2YfZiCDYp9mE2YXZgdiq2KfYrSDYp9mE2LHYptmK2LPZiiDZhNmE2K3Ys9in2Kgg2Ygg2KfZhNmF2LfZhNmI2Kgg2YTYqti62YrZitixINmF2YHYp9iq2YrYrSDYo9iu2LHZiS4g2KfZhNmF2YHYqtin2K0g2KfZhNiu2KfYtSDYo9mIINmD2YTZhdipINmF2LHZiNixINmE2YXZgdiq2KfYrSDZhdin2YTZgyDZitmG2KjYutmKINij2YYg2KrYuNmEINiv2YjZhiDYp9iq2LXYp9mEINmC2K/YsSDYp9mE2KXZhdmD2KfZhi5cIixcblx0XCJBQ1RJVkVcIjogXCLZhti02LdcIixcblx0XCJQUk9GSUxFXzdcIjogXCLZitiq2YUg2KfYs9iq2K7Yr9in2YUg2KfZhNmF2YHYqtin2K0g2KfZhNmG2LTYtyDZhNiq2K3ZiNmK2YQg2KfZhNij2YXZiNin2YQg2YjZiNi22Lkg2KfZhNij2YjYp9mF2LEg2YHZiiDYp9mE2LPZiNmCINin2YTYr9in2K7ZhNmK2KkuXCIsXG5cdFwiTUVNT1wiOiBcItmF2YHZg9ix2YdcIixcblx0XCJQUk9GSUxFXzhcIjogXCLZhdmB2KrYp9itINin2YTZhdiw2YPYsdipINmK2LPYqtiu2K/ZhSDZhNil2YbYtNin2KEg2Ygg2YLYsdin2KHYqSDYp9mE2YXYsNmD2LHYp9iqLlwiLFxuXHRcIkJMT0dcIjogXCLZhdiv2YjZhtmHXCIsXG5cdFwiUE9TVFNcIjogXCLYp9mE2YXZiNin2LbZiti5XCIsXG5cdFwiUkVQTElFU1wiOiBcItin2YTYsdiv2YjYr1wiLFxuXHRcIldBTExFVFwiOiBcItin2YTZhdit2YHYuNmHXCIsXG5cdFwiVEFHXCI6IFwi2LTYp9ix2KlcIixcblx0XCJVU0VSXCI6IFwi2KfZhNmF2LPYqtiu2K/ZhVwiLFxuXHRcIkNMT1NFXCI6IFwi2KXYutmE2KfZglwiLFxuXHRcIlRPXCI6IFwi2KXZhNmJXCIsXG5cdFwiQVNTRVRcIjogXCLZhdmE2YPZitmHXCIsXG5cdFwiU0VORFwiOiBcItil2LHYs9in2YRcIixcblx0XCJTRUNVUklUWVwiOiBcItin2YTYo9mF2KfZhlwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcItmF2KrYp9itXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLZhdmB2YPYsdip2LnYp9mF2YdcIixcblx0XCJUT19ERVNDXCI6IFwi2KfZhNmF2LPYqtiu2K/ZhSDZhdir2YTYpyBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCLYp9mE2LHZgtmFINin2YTYs9ix2YpcIixcblx0XCJQSU5fVEVYVFwiOiBcItmK2LPYp9i52K/ZgyDYsdmF2LIgUElOINmE2KrYo9mF2YrZhiDYp9mE2KrYt9io2YrZgiDZiNin2YTYqNmK2KfZhtin2Kog2KfZhNiu2KfYtdipINio2YMuIDxici8+IDxici8+IDxiPtmF2YTYp9it2LjYqTo8L2I+INio2YXYrNix2K8g2KfZhNiq2YXZg9mK2YbYjCDZhNiv2YrZgyDZg9it2K8g2KPZgti12YkgNCDZhdit2KfZiNmE2KfYqiDZhNmE2YHYqtit2Iwg2KXYsNinINmD2YbYqiDZgtivINmG2LPZitiqINix2YLZhSBwaW4g2KPZiCDYqtmB2LTZhNiMINiz2YrYqtmFINil2LLYp9mE2Kkg2KjZitin2YbYp9iqINiq2LPYrNmK2YQg2KfZhNmF2LPYqtiu2K/ZhSDZhdmGINin2YTYqti32KjZitmCLiDZitmF2YPZhtmDINil2LnYp9iv2Kkg2KfZhNiv2K7ZiNmEINmI2KfZhNin2LPYqtmF2LHYp9ixINmB2Yog2KfYs9iq2K7Yr9in2YUg2KfZhNiq2LfYqNmK2YIuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcItin2YTYpdi02LnYp9ix2KfYqlwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcItiz2YjZgSDYqtit2LXZhCDYudmE2Ykg2KXYtNi52KfYsSDYudmG2K/ZhdinINi02K7YtSDZhdinINi12YjYqiDZhNmE2YXYrdiq2YjZiSDYp9mE2K7Yp9i1INio2YMhIDxici8+IDwvYj7ZhdmE2KfYrdi42Kk6L2I+INiq2LTZhdmEINin2YTYpdi02LnYp9ix2KfYqiDZiNiy2YYg2KfZhNiq2LXZiNmK2KrYjCDZiNmD2LDZhNmDINmB2Yog2LHYs9in2YTYqSDYp9mE2KrZhtio2YrZhy4gKNiz2YjYp9ihINmD2KfZhiDYp9mE2KrYtdmI2YrYqiDYo9i52YTZidiMINmIINin2YTYqti12YjZitiqINmE2YTYo9iz2YHZhNiMINmG2LLYuSDYp9mE2KrYtdmI2YrYqikuXCIsXG5cdFwiVk9URVwiOiBcIti12YjYqlwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcItiz2YjZgSDYqtit2LXZhCDYudmE2Ykg2KXYtNi52KfYsSDYudmG2K/ZhdinINi02K7YtSDZhdinINmK2LnZhNmCINi52YTZiSDYp9mE2YXYtNin2LHZg9in2Kog2KPZiCDYp9mE2KrYudmE2YrZgtin2Kog2KfZhNiu2KfYtdipINio2YMhIDxici8+IDxiPtmF2YTYp9it2LjYqTo8L2I+INiq2LTZhdmEINin2YTYpdi02LnYp9ix2KfYqiDYudmG2K/ZhdinINin2YTYo9i02K7Yp9i1INmK2YLZiNmF2YjYpyA8Yj7YqNiq2LnYr9mK2YQ8L2I+INiq2LnZhNmK2YLYp9iq2YfZhSDZg9iw2YTZgy5cIixcblx0XCJDT01NRU5UXCI6IFwi2KrYudmE2YrZglwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwi2LPZiNmBINiq2LPYqtmC2KjZhCDYp9i02LnYp9ixINi52YbYr9mF2Kcg2YrYqtio2LnZgyDYtNiu2LUg2KPZiCDZitmE2LrZiiDZhdiq2KfYqNi52KrZgyFcIixcblx0XCJNRU5USU9OU1wiOiBcItmF2LDZg9mI2LFcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwi2LPZiNmBINiq2LPYqtmC2KjZhCDYp9i02LnYp9ixINi52YbYr9mF2Kcg2YrYsNmD2LEg2LTYrti1INmB2Yog2KrYudmE2YrZgtmHL9mF2YjYttmI2LnZhyFcIixcblx0XCJSRVNURUVNXCI6IFwi2LTYp9ix2YNcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLYs9mK2KrZhSDYpdi02LnYp9ix2YMg2LnZhtiv2YXYpyDZitiq2YUg2YXYtNin2LHZg9ipINmF2YjYttmI2LnZgyDZhdmGINi32LHZgSDYtNiu2LUg2YXYpyFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcItin2YTYttio2LdcIixcblx0XCJWT1RJTkdcIjogXCLYqti12YjZitiqXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLZiNiy2YYg2KfZhNiq2LXZiNmK2Kog2KPZiCDYp9mE2YbYs9io2Kkg2KfZhNmF2KbZiNmK2Kkg2YrYpNir2LHYp9mGINi52YTZiSDZgtmI2Kkg2KfZhNiq2LXZiNmK2Kog2YHZiiDYp9mE2KrYt9io2YrZgtiMINit2YrYqyDZitmF2YPZhtmDINiq2YbYuNmK2YUg2YXZg9in2YHYo9ipINin2YTYqti12YjZitiqINin2YTYrtin2LUg2KjZgy4gPGJyLz4gPGJyLz4gPGI+2YXZhNin2K3YuNipOjwvYj4g2LPZitik2K/ZiiDYsNmE2YMg2KXZhNmJINiq2LrZitmK2LEg2KfZhNmI2LLZhi/Zhtiz2KjYqSDYsdmB2LYg2KrYtdmI2YrYqiDZgdmKINmD2YQg2YXZg9in2YYg2YHZiiDYp9mE2KrYt9io2YrZglwiLFxuXHRcIlNFUlZFUlwiOiBcItiu2KfYr9mFXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLYp9mE2YXYsdi02K1cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLYp9it2YHYuCDYp9mE2KrYutmK2YrYsdin2KpcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItmF2LnZhNmI2YXYp9iqINi52YYg2KfZhNmF2LXZiNiq2YrZhlwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcItmF2LHYrdio2Kcg2KjYudmI2K/YqtmDXCIsXG5cdFwiTE9HSU5fMVwiOiBcItmC2YUg2KjYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNij2LPZhSDYp9mE2YXYs9iq2K7Yr9mFINmI2YPZhNmF2Kkg2KfZhNiz2LEg2YTZhNij2LPYqtmF2LHYp9ixXCIsXG5cdFwiTE9HSU5fMlwiOiBcItmK2LPYqtiu2K/ZhSDZg9mI2K8g2KfZhNiq2K/ZiNmK2YYg2YHZiiDYp9mE2YbYtNixINmI2KfZhNiq2LnZhNmK2YIg2LnZhNmJINin2YTZhdmI2KfYttmK2Lkg2YPZhdinINij2YYg2KPZiti22Kcg2YrYs9iq2K7Yr9mFINij2YrYttinINmE2YTYqti12YjZitiqINi52YTZiSDYp9mE2YXZhti02YjYsdin2Kog2YjZhdiq2KfYqNi52Kkg2KfZhNmF2K/ZiNmG2YrZhiDYp9mE2YXZgdi22YTZitmGLlwiLFxuXHRcIkxPR0lOXzNcIjogXCLZitiz2KrYrtiv2YUg2YPZiNivINin2YTZgdi52KfZhCDZgdmKINil2LHYs9in2YQg2KfZhNij2YXZiNin2YQg2YjYqti62YrZitixINin2YTYtdmI2LHYqSDYp9mE2LTYrti12YrYqS5cIixcblx0XCJMT0dJTl80XCI6IFwi2YrYqtmFINin2YTYpdit2KrZgdin2Lgg2KjYqNmK2KfZhtin2Kog2KfZhNmF2LPYqtiu2K/ZhSDZhdit2YTZitinINi52YTZiSDYp9mE2KzZh9in2LIuINiq2KrZhSDYpdiy2KfZhNipINin2YTYqNmK2KfZhtin2Kog2LnZhtivINiq2LPYrNmK2YQg2KfZhNiu2LHZiNisIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcItmE2Kcg2KrZhdmE2YMg2K3Ys9in2KhcIixcblx0XCJTSUdOX1VQX05PV1wiOiBcItmC2YUg2KjYp9mE2KrYs9is2YrZhCDYp9mE2KfZhlwiLFxuXHRcIkNBTkNFTFwiOiBcItil2YTYutin2KFcIixcblx0XCJBRFZBTkNFRFwiOiBcItmF2KrZgtiv2YVcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwi2YPZiNivINin2YTZgdi52KfZhCDYp9mE2K7Yp9i1XCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCLZhti02LEg2KfZhNmF2YHYqtin2K0g2KfZhNiu2KfYtVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwi2YPZhNmF2Kkg2KfZhNmF2LHZiNixINin2YTYsdim2YrYs9mK2KlcIixcblx0XCJVU0VSTkFNRVwiOiBcItin2LPZhSDYp9mE2YXYs9iq2K7Yr9mFXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi2LnYsdi2INin2YTYqNi32KfZgtipXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwi2KjYrdirXCIsXG5cdFwiU0VBUkNIXCI6IFwi2KfZhNio2K3Yq1wiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi2KfYr9iu2KfZhCDYp9mE2YXYtNin2LHZg9ipXCIsXG5cdFwiUkVQTFlUT1wiOiBcItin2YPYqtioINix2LPYp9mE2KlcIixcblx0XCJQT1NUXCI6IFwi2KPZhti02LFcIixcblx0XCJQUkVWSUVXXCI6IFwi2LnYsdi2INmF2LPYqNmCXCIsXG5cdFwiREVGQVVMVFwiOiBcItin2YTYp9mB2KrYsdin2LbZiiA1MCUvNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcItix2YHYuSDYp9mE2LfYp9mC2KkgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwi2LHZgdi2INiv2YHYuSDYp9mE2KrYudmI2YrYttin2KpcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcItin2K3Zgdi4INmE2YjZgtiqINmE2KfYrdmCXCIsXG5cdFwiQ0xFQVJcIjogXCLZiNin2LbYrVwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcItmF2K3YqtmI2Ykg2KfZhNiq2K/ZiNmK2YbZitipIFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcItmF2K3YqtmI2Ykg2KfZhNiq2LnZhNmK2YJcIixcblx0XCJUSVRMRVwiOiBcIti52YbZiNin2YZcIixcblx0XCJUQUdTXCI6IFwi2LTYp9ix2KfYqlwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIti62YrYsSDZhdiq2LfYp9io2YJcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcItij2YPYryDYp9mE2LHZhdiyINin2YTYs9ix2YpcIixcblx0XCJJTkNPUlJFQ1RcIjogXCLYutmK2LEg2LXYrdmK2K1cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLYqtiv2YjZitmG2YrYqSDZhdmB2KrZiNit2KkgXCIsXG5cdFwiU0VUX1BJTlwiOiBcItis2K/YryDYp9mE2LHZhdiyINin2YTYs9ix2YpcIixcblx0XCJFTlRFUl9QSU5cIjogXCLYp9iv2K7ZhCDYp9mE2LHZhdiyXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwi2YfZhCDYo9mG2Kog2YjYp9ir2YLYn1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwi2LHZitiz2KrZitmFINmE2Kcg2LHYrNi52Kkg2YHZitmH2Iwg2YfZhCDYqtix2YrYryDYp9mE2YXYqtin2KjYudipXCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwi2K7Yt9ij2Iwg2KfZhNmF2LHYrNmIINin2YTZhdit2KfZiNmE2Kkg2YXYsdipINij2K7YsdmJIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLZhdmI2YHZglwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwi2KrYr9mI2YrZhtipINmF2LTYp9ix2YPYqSFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwi2YHYtNmEINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEISDYp9mE2LHYrNin2KEg2KfZhNiq2KPZg9ivINil2YYg2YPZhtiqINmC2K8g2YLZhdiqINio2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KjYp9iz2KrYrtiv2KfZhSDZg9mE2YXYqSDZhdix2YjYsdmDINin2YTYsdim2YrYs9mK2Kkg2KPZiCDYqtmI2YHZitixINmD2YjYryDYp9mE2YbYtNixINin2YTYrtin2LUg2LnZhNmJINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINil2LDYpyDYpdiu2KrYsdiqINin2YTZiNi22Lkg2KfZhNmF2KrZgtiv2YUuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwi2YHYtNmEINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEISDYp9mE2LHYrNin2KEg2KfZhNiq2KPZg9ivINil2YYg2YPZhtiqINmC2K8g2YLZhdiqINio2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KjYp9iz2KrYrtiv2KfZhSDZg9mE2YXYqSDZhdix2YjYsSDYsdim2YrYs9mK2Kkg2KPZiCDYqtmI2YHZitixINmD2YjYryDYp9mE2YbYtNixINin2YTYrtin2LUg2LnZhNmJINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINil2LDYpyDYpdiu2KrYsdiqINin2YTZiNi22Lkg2KfZhNmF2KrZgtiv2YUuXCIsXG5cdFwiV0FSTklOR1wiOiBcItiq2K3YsNmK2LFcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwi2KfZhNiq2LXZiNmK2Kog2YTZhNi02KfZh9ivXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCLYqtmFINin2YTYqti12YjZitiqINmE2YTYtNin2YfYr1wiLFxuXHRcIkFHT1wiOiBcItmF2YbYsFwiLFxuXHRcIkZST01fTk9XXCI6IFwi2YXZhiDYp9mE2KPZhlwiLFxuXHRcIlNFQ1NcIjogXCLYq9mI2KfZhtmKXCIsXG5cdFwiQV9NSU5cIjogXCLYr9mC2YrZgtipINmI2KfYrdiv2KlcIixcblx0XCJNSU5TXCI6IFwi2K/Zgtin2KbZglwiLFxuXHRcIkFOX0hPVVJcIjogXCLYs9in2LnYqSDZiNin2K3Yr9ipXCIsXG5cdFwiSE9VUlNcIjogXCLYs9in2LnYp9iqXCIsXG5cdFwiQV9EQVlcIjogXCLZitmI2YVcIixcblx0XCJEQVlTXCI6IFwi2KPZitin2YVcIixcblx0XCJBX01PTlRIXCI6IFwi2LTZh9ixXCIsXG5cdFwiTU9OVEhTXCI6IFwi2KPYtNmH2LFcIixcblx0XCJBX1lFQVJcIjogXCLYs9mG2KlcIixcblx0XCJZRUFSU1wiOiBcItiz2YbZiNin2KpcIixcblx0XCJNSU5fUkVBRFwiOiBcItiv2YLZitmC2Kkg2YLYsdin2KHYqVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCLYtdmI2Kog2YTZhNij2LPZgdmEINij2Ygg2LnZhNmFXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi2KPZhNiq2YLYtyDYtdmI2LHYqVwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwi2K3Yr9mQ2ZHYryDYtdmI2LHYqSDYrNiv2YrYr9ipXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLYudmK2YYg2LHYp9io2Lcg2K7Yp9i1XCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCLYo9iv2K7ZhCDYtdmI2LHYqVwiLFxuXHRcIkVSUk9SXCI6IFwi2K7Yt9ijXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi2K7Yt9ijINmB2Yog2LnZhdmE2YrYqSDYp9mE2LHZgdi5XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcItij2YTYutmK2Kog2KfZhNmD2KfZhdmK2LHYp1wiLFxuXHRcIlNFVF9VUkxcIjogXCLYo9i22KjYtyDYp9mE2LHYp9io2LdcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi2LHYp9io2Lcg2YXYqNin2LTYsSDZhNmE2LXZiNix2KlcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcItiq2YUg2KXYttin2YHYqSDYp9mE2KrYudmE2YrZgiFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcItmE2Kcg2YrZhdmD2YbZgyDYp9mE2LHYrNmI2Lkg2LnZhiDYrdiw2YEg2KfZhNiq2LnZhNmK2YLYp9iqLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi2KPYrdiw2YEg2KrYudmE2YrZglwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi2KzYp9ix2Yog2LHZgdi5INin2YTYtdmI2LHYqVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLYqtmFINin2YTYsdmB2Lkg2KjZhtis2KfYrVwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLZgdi02YQg2LnZhdmE2YrYqSDYp9mE2LHZgdi5XCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwi2YrZiNis2K8g2K7Yt9in2KEg2YHZiiDYo9iz2YUg2KfZhNmF2LPYqtiu2K/ZhSDYo9mIINmD2YTZhdipINin2YTYs9ixXCIsXG5cdFwiSU5GT1wiOiBcItmE2YTZhdi52YTZiNmF2KfYqlwiLFxuXHRcIlFSX1RFWFRcIjogXCLYtti5INix2YXYsiDYp9mE2KfYs9iq2KzYp9io2Kkg2KfZhNiz2LHZiti52Kkg2K/Yp9iu2YQg2YXZhti32YLYqSDYp9mE2YXYs9itINin2YTYttmI2KbZilwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcItin2YTZhdix2KzZiCDYp9mE2KrYo9mD2K8g2YXZhiDYp9mE2KrZiNmB2LEg2LnZhNmJINix2LXZitivINmD2KfZgdmKINmE2KXYrNix2KfYoSDYp9mE2LnZhdmE2YrYqVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLYp9mE2YXYs9iq2K7Yr9mFINin2YTYsNmKINiq2K3Yp9mI2YQg2KXYsdiz2KfZhCDYp9mE2LHYtdmK2K8g2YTZh9iMINi62YrYsSDZhdmI2KzZiNivIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLZh9mEINij2YbYqiDZhdiq2KPZg9ivINmF2YYg2KfZhNiq2K3ZiNmK2YQg2J9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLYqtij2YPZitivXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLYqtmFINil2LHYs9in2YQg2KfZhNix2LXZitivXCIsXG5cdFwiRkVFRFwiOiBcItin2YTYsdim2YrYs9mK2ZHYqSBcIixcblx0XCJUUkVORElOR1wiOiBcIti02KfYpti5XCIsXG5cdFwiSE9UXCI6IFwi2KfZhNiz2KfYrtmG2KlcIixcblx0XCJORVdcIjogXCLYrNiv2YrYr1wiLFxuXHRcIlBST01PVEVEXCI6IFwi2YXYsdmI2Kwg2YTZh1wiLFxuXHRcIlZPVEVTXCI6IFwi2LnYr9ivINin2YTYo9i12YjYp9iqIFwiLFxuXHRcIlBBWU9VVFwiOiBcItiv2YHYuSDYp9mE2KrYudmI2YrYttin2KpcIixcblx0XCJDT01NRU5UU1wiOiBcItin2YTYqti52YTZitmC2KfYqlwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwi2YXYtNmH2YjYsSDZhNir2YTYp9ir2YjZhiDZitmI2YXYp1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItix2KrYqCDYp9mE2YXZiNin2LbZiti5INio2K3Ys9ioXCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi2K/ZiNix2Kkg2YXYtdix2YHZitipXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcItin2YTYudin2KbYr9in2Kog2KfZhNmF2K3YqtmF2YTYqVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwi2KfZhNiq2LnZiNmK2LbYp9iqINin2YTYs9in2KjZgtipXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcItiq2LnZiNmK2LbYp9iqINin2YTZg9in2KrYqCBcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLYudin2KbYr9in2Kog2KfZhNiq2YLZitmK2YVcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcItiq2YUg2KfYr9iu2KfZhCDYp9mE2KrYr9mI2YrZhtmK2Kkg2KjZhtis2KfYrVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLYo9mG2LTYsSDZhNiq2YLYr9mK2YXZh9inINmE2KfYrdmC2KchXCIsXG5cdFwiU0FWRURcIjogXCLYqtmFINin2YTYrdmB2LhcIixcblx0XCJDTEVBUkVEXCI6IFwi2KrZhSDYp9mE2YXYs9itXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcItmI2LbYuSDYudmE2KfZhdin2Kog2LnZhNmJINmF2YjYttmI2Lkg2YrZhdmD2YYg2KXYstin2YTYqSDYp9mE2YXZg9in2YHYotiqINmI2KzYudmEINmH2LDZhyDYp9mE2YXZiNin2K8g2KPZgtmEINi42YfZiNix2Kcg2YTZhNi52YrYp9mGLiA8YnI+PGJyPtin2YTYudmE2YUg2YrZhtio2LrZiiDYo9mGINiq2LPYqtiu2K/ZhSDZhNmF2Kcg2YrZhNmKOiA8dWw+PGxpPtin2YTYuti0INij2Ygg2KfZhNin2YbYqtit2KfZhDwvbGk+IDxsaT7Yrti32KfYqCDYp9mE2YPYsdin2YfZitipINij2Ygg2KfZhNiq2LXZitivPC9saT4gPGxpPtiz2YjYoSDYp9mE2KrYtdmG2YrZgSDYp9mE2YXYqti52YXYryDZhNmE2YXYrdiq2YjZiSDYo9mIINin2YTYsdiz2KfYptmEINin2YTZhdiy2LnYrNipPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcItiq2YUg2KfZhNmI2LXZiNmEINmE2KPZgti12Yog2K3YryDZhNmE2LfZhNio2KfYqi4g2KfZgdit2LUg2LTYp9im2Lkv2LTYp9ix2Kkg2KPYrtix2YohXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi2KrZhSDYrdiw2YEg2KfZhNmF2YjYttmI2Lkg2YXZhiDYp9mE2YXZgdi22YTYqSFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwi2KrZhSDYp9i22KfZgdipINin2YTZhdmI2LbZiNi5INmE2YTZhdmB2LbZhNipIVwiLFxuXHRcIlJFU0VUXCI6IFwi2KfZhNmI2LbYuSDYp9mE2LPYp9io2YJcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcItiq2K3Yr9mK2Ksg2KfZhNi12YjYsdipINin2YTYtNiu2LXZitipXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCLYqtit2K/ZitirINi12YjYsdipINin2YTYutmE2KfZgVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcItin2YTYsdis2KfYoSDYqtmC2K/ZitmFINin2YTZhdmB2KrYp9itINin2YTYrtin2LUg2KfZhNmG2LTYtyDYpdiw2Kcg2YLZhdiqINio2KXYrtiq2YrYp9ixINmI2LbYudmK2Kkg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KfZhNmF2KrZgtiv2YXYqSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCLYsNmE2YMg2LPZiNmBINio2LnZitivINin2YTYtdmI2LHYqSDYp9mE2LTYrti12YrYqSDZhNmE2YjYtti5INin2YTYs9in2KjZglwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcItiw2YTZgyDYs9mI2YEg2KjYudmK2K8g2LXZiNix2Kkg2KfZhNi62YTYp9mBINmE2YTZiNi22Lkg2KfZhNiz2KfYqNmCXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLZhNiq2K3Yr9mK2Ksg2KfZhNiz2YrYsdmB2LEg2YrZhtio2LrZiiDYp9i52KfYr9ipINin2YTYqti02LrZitmEIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCLYqtmFINiq2K3Yr9mK2Ksg2KfZhNi22KjYt1wiLFxuXHRcIkxBTkdVQUdFU1wiOiBcItin2YTZhNi62KfYqlwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi2YXZhiDZh9mG2Kcg2YrZhdmD2YbZgyDYqti62YrYsSDZhNi62Kkg2KfZhNiq2LfYqNmK2YJcIixcblx0XCJMT0dJTl9UT19YXCI6IFwi2KrYqti32YTYqCDZh9iw2Ycg2KfZhNi52YXZhNmK2Kkg2KfZhNmF2LPYqtiu2K/ZhSDYqtiz2KzZitmEINin2YTYr9iu2YjZhCDYqNmD2YTZhdipINin2YTZhdix2YjYsSDYp9mE2LHYptmK2LPZitip2Iwg2YXZgdiq2KfYrSDZhti02Lcv2KfZhNmG2LTYsS4g2KfZhNix2KzYp9ihINiq2LPYrNmK2YQg2KfZhNiv2K7ZiNmEINmI2KfZhNmF2K3Yp9mI2YTYqSDZhdix2Kkg2KPYrtix2YkuXCIsXG5cdFwiR0FMTEVSWVwiOiBcItin2YTYtdmI2LFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLYp9mE2YLYp9im2YXZiNmGINi52YTZiiDYp9mE2KrYsdis2YXYqVwiLFxuXHRcIlNIQVJFXCI6IFwi2YXYtNin2LHZg9ipXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLYp9mE2LPZiNmCXCIsXG5cdFwiRVhDSEFOR0VcIjogXCLYqtio2KfYr9mEXCIsXG5cdFwiRFJBRlRTXCI6IFwi2YXYs9mI2K/Yp9iqXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi2KrZhSDYrdiw2YEg2KfZhNmF2YjYttmI2Lkg2YXZhiDYp9mE2YXYs9mI2K/Yp9iqIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCLYqtmFINil2LbYp9mB2Kkg2KfZhNmF2YjYttmI2Lkg2YTZhNmF2LPZiNiv2KfYqiFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwi2KXYs9it2Kgg2YTZhNmK2LPYp9ixINmE2YXYtNin2YfYr9ipINin2YTYrtmK2KfYsdin2KpcIixcblx0XCJNQU5BR0VcIjogXCLYpdiv2KfYsdipIFwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLYqtmFINmF2LPYrSDYp9mE2LXZiNix2KlcIixcblx0XCJDT1BZXCI6IFwi2KPZhtiz2K5cIixcblx0XCJOT19JTUFHRVwiOiBcItmE2YUg2KrZgtmFINio2KrYrdmF2YrZhCDYo9mKINi12YjYsdipIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwi2KXYs9it2Kgg2KPYs9mB2YQg2YTZhNiq2K3Yr9mK2KtcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi2KrYt9io2YrZgtin2Kog2KXYttin2YHZitipXCIsXG5cdFwiUExVR0lOU1wiOiBcItil2LbYp9mB2KfYqlwiLFxuXHRcIlNVR0dFU1RcIjogXCLYp9mC2KrYsdin2K3Yp9iqXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCLZgtix2YrYqNinXCIsXG5cdFwiQ0hBSU5cIjogXCLYs9mE2LPZhNipXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcItmH2YbYpyDZitmF2YPZhtmDINiq2LrZitmK2LEg2KfZhNmF2YbYtdipINin2YTYp9mB2KrYsdin2LbZitipINij2Ygg2LPZhNiz2YTYqSDYp9mE2YPYqtmELlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi2KfZhNi52YXZhNipXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcItmH2YbYpyDZitmF2YPZhtmDINiq2LrZitmK2LEg2KfZhNi52YXZhNipINin2YTYp9mB2KrYsdin2LbZitipINin2YTYrtin2LXYqSDYqNmDLiDYs9iq2LTYp9mH2K8g2YLZitmF2Kkg2KfZhNmF2YPYp9mB2KPYqSDYp9mE2YXZiNi22YjYuS/Yp9mE2KrYudmE2YrZgiDYqNmH2LDZhyDYp9mE2LnZhdmE2KkuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8Yj48YnI+2YLYp9im2YXYqSDYp9mE2YXZitiy2KfYqjxicj48L2I+LSDZitmF2YPZhtmDINin2YTYr9iu2YjZhCDYpdmE2Ykg2KfZhNmF2YLYp9mE2KfYqiDZgdmKINij2Yog2YXZiNi22YjYuSDYqtix2LrYqCDZgdmKINmC2LHYp9ih2KrZhy48YnI+LSDYp9mE2KrZgdin2LnZhCDZhdi5INin2YTZhdik2YTZgdmK2YYg2YXZhiDYrtmE2KfZhCDYp9mE2KrYudmE2YrZgiDZiNmF2YbYp9mC2LTYqSDYp9mE2YXZiNi22YjYudin2KouPGJyPi0g2KfZhNiq2LXZiNmK2Kog2LnZhNmJINin2YTZhdi02KfYsdmD2KfYqiDZhNmF2YPYp9mB2KPYqSDYp9mE2YXYpNmE2YEg2YHYttmE2Kcg2LnZhiDZg9iz2Kgg2YXZg9in2YHYo9ipINin2YTYqtij2YTZitmBLjxicj4tINmG2LTYsSDZhdmC2KfZhNin2KrZg9iMINin2YTYqtiv2YjZitmGINmI2KfYs9iq2LbYp9mB2Kkg2YTZh9mFINmF2KzYp9mG2Kcg2YjZg9iz2Kgg2KfZhNmF2YPYp9mB2KLYqiDZhdmGINiu2YTYp9mEINil2LTYsdin2YMg2YjZg9iz2Kgg2YXYqtin2KjYudmK2YYuPGJyPi0g2YPYqtin2KjYqSDZhdmC2KfZhNin2Kog2LnZhNmJINin2YTYsNmH2KfYqNiMINmI2K3Zgdi4INmF2LPZiNiv2KfYqiDZhdiq2LnYr9iv2Kkg2YXZhiDZiNi42YrZgdipINmE2YbYtNixINmB2Yog2YjZgtiqINmE2KfYrdmCLjxicj4tINmK2YXZg9mG2YMg2YjYtti5INil2LTYp9ix2Kkg2YXYsdis2LnZitipINi52YTZiSDZhdmC2KfZhNin2KrZgyDYp9mE2YXZgdi22YTYqSDZhNmC2LHYp9ih2KrZh9inINmE2KfYrdmC2KcuPGJyPi0g2YrZhdmD2YbZgyDYqtio2KfYr9mEINij2LHYqNin2K3ZgyDYo9mIINmG2YLZiNiv2YfYpy48YnI+LSDYpdix2LPYp9mEINij2YXZiNin2YTZgyDYpdmE2Ykg2KPZiiDZhdik2YTZgdmK2YYg2KPZiCDZhdiz2KrYrtiv2YXZitmGINij2Ygg2KPYtdiv2YLYp9ihINij2Ygg2YXYqtin2KjYudmK2YYg2KPZiCDYutmK2LHZh9mFIDxicj4tINmF2KrYp9io2LnYqSDYp9mE2YXYpNmE2YHZitmGINin2YTZhdir2YrYsdmK2YYg2YjYp9mE2YXYr9mI2YbZitmGLiA8YnI+IC0g2KfYqNit2Ksg2LnZhiDZhdiq2KfYqNi52YrZgyDZiNmF2KTZhNmB2YrZgyDYp9mE2LDZitmGINiq2KrYp9io2LnZh9mFLjxicj4tINin2K3YtdmEINi52YTZiSDYpdi02LnYp9ix2KfYqiDZhNmE2KjZgtin2KEg2LnZhNmJINin2KrYtdin2YQg2YXYuSDZhdiq2KfYqNi52YrZgyDZiNmF2YbYp9mC2LTYp9iq2YMg2KfZhNiq2Yog2KrYtNin2LHZgyDZgdmK2YfYpy48YnI+LSDYp9io2K3YqyDYudmGINi52YTYp9mF2KfYqiDZhdir2YrYsdipINmE2YTYp9mH2KrZhdin2YUgLyDZgdim2KfYqiDYp9mE2YXZgtin2YTYp9iqINmI2KfZhNmF2KTZhNmB2YrZhi48YnI+LSDYqtiu2LXZiti1INmF2YTZgdmDINin2YTYtNiu2LXZii48YnI+LSDYp9mE2YXYstmK2K8g2YXZhiDYp9mE2YXZitiy2KfYqiDYp9mE2YLYp9iv2YXYqS48Yj48YnI+PGJyPiDYp9mE2KPZhdin2YY8YnI+PC9iPi4g2KfZhNiq2LfYqNmK2YIg2YTYpyDZitmF2YPZhtmHINin2YTZiNi12YjZhCDYo9mIINin2YTYqtmF2LPZgyDYqNij2YXZiNin2YQg2KfZhNmF2LPYqtiu2K/ZhS48YnI+LiDZitmC2K/ZhSDYp9mE2KrYt9io2YrZgiDZhtmF2YjYsNisINij2YXYp9mGINmF2YYg2KzYp9mG2Kgg2KfZhNi52YXZitmE2Iwg2YXYuSDYp9iz2KrYttin2YHYqSDZhdmB2KfYqtmK2K0g2K7Yp9i12Kkg2YXYrdmE2YrYpyDZiNi52K/ZhSDYpdix2LPYp9mE2YfYpyDZhdi32YTZgtinINil2YTZiSDYo9mKINiu2YjYp9iv2YXYjCDZgdij2YbYqiDZhdiz2KTZiNmEINi52YYg2KfZhNin2K3YqtmB2KfYuCDYqNmG2LPYrtipINin2K3YqtmK2KfYt9mK2Kkg2YXZhiDZg9mE2YXYp9iqINin2YTZhdix2YjYsS48YnI+LiDYp9mE2KrYt9io2YrZgiDZitmI2YHYsSDZiNin2KzZh9in2Kog2KfZhNmF2LPYqtiu2K/ZhSDYqNiz2YrYt9ipINmI2KzYsNin2KjYqSDZiCDYqtis2KfYsdioPGJyPi4g2YrZiNmB2LEg2KfZhNiq2LfYqNmK2YIg2LfYqNmC2Kkg2KXYttin2YHZitipINmF2YYg2KfZhNij2YXYp9mGINmF2Lkg2LHZhdiyINin2YTYo9mF2KfZhjxicj48YnI+2KXYs9iq2YrZhSDZitiv2LnZhSDZhti42KfZhdmKINiz2KrZitmFINmIINi62YjZhNmI2LMuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLYp9mE2YXYpNiz2LMg2YjYp9mE2YXYt9mI2LEg2KfZhNix2KbZitiz2YpcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcItil2LbYp9mB2Kkg2K3Ys9in2KhcIixcblx0XCJQTEFURk9STVwiOiBcItin2YTZhdmG2LXYqVwiLFxuXHRcIkVTQ1JPV1wiOiBcItin2YTYttmF2KfZhlwiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcItmI2YPZitmEINin2YTYttmF2KfZhlwiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcItin2YTZhdmI2LnYryDYp9mE2YbZh9in2KbZiiDZhNmE2YXYtdin2K/ZgtipXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCLYp9mG2KrZh9in2KEg2LXZhNin2K3ZitipINin2YTYttmF2KfZhlwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCLYsdiz2YjZhSDYp9mE2LbZhdin2YZcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCLYtNix2YjYtyDYp9mE2LbZhdin2YZcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwi2KfZhNmI2LbYuSDYp9mE2YTZitmE2YpcIixcblx0XCJEQVlfTU9ERVwiOiBcItin2YTZiNi22Lkg2KfZhNmK2YjZhdmKXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwi2LnYsdi2INin2YTZhdit2KrZiNmJINin2YTZg9in2YXZhFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCLYp9mE2YXYs9iq2K7Yr9mFINi62YrYsSDZhdmI2KzZiNivXCIsXG5cdFwiQVBQUk9WRVwiOiBcItmF2YjYp9mB2YLYqVwiLFxuXHRcIkRJU1BVVEVcIjogXCLYp9mE2K7ZhNin2YFcIixcblx0XCJSRUxFQVNFXCI6IFwi2KXYtdiv2KfYsVwiLFxuXHRcIkZST01cIjogXCLZhdmGXCIsXG5cdFwiSURcIjogXCLZhdi52LHZgVwiLFxuXHRcIlNVQk1JVFwiOiBcItil2YrYr9in2LlcIixcblx0XCJSRUNFSVZFUlwiOiBcItin2YTZhdiz2KrZgtio2YRcIixcblx0XCJMT0NBVElPTlwiOiBcItin2YTYudmG2YjYp9mGXCIsXG5cdFwiV0VCU0lURVwiOiBcItin2YTZhdmI2YLYuVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcItil2LPZhSDYp9mE2YXYs9iq2K7Yr9mFXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcItCd0LDRh9Cw0LvQvlwiLFxuXHRcIkxPR0lOXCI6IFwi0JLRhdC+0LRcIixcblx0XCJMT0dPVVRcIjogXCLQntGC0L/QuNGB0LLQsNC90LVcIixcblx0XCJQUk9GSUxFXCI6IFwi0J/RgNC+0YTQuNC7XCIsXG5cdFwiRk9MTE9XXCI6IFwi0KHQu9C10LTQstCw0L3QtVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcItCb0Y7QsdC40LzQuFwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi0KLRgNCw0L3RgdGE0LXRgFwiLFxuXHRcIk1BUktFVFwiOiBcItCf0LDQt9Cw0YBcIixcblx0XCJTRVRUSU5HU1wiOiBcItCd0LDRgdGC0YDQvtC50LrQuFwiLFxuXHRcIkFCT1VUXCI6IFwi0JfQsCDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L5cIixcblx0XCJBQk9VVF8xXCI6IFwi0JLRgdC10LrQuCDQvNC+0LbQtSDQtNCwINC/0LXRh9C10LvQuCDQvtGCINC/0YPQsdC70LjQutGD0LLQsNC90LUg0L3QsCDRgdGC0LDRgtC40LghXCIsXG5cdFwiQUJPVVRfMlwiOiBcItC1INGB0L7RhtC40LDQu9C90LAg0LzRgNC10LbQsCwg0LrQvtGP0YLQviDQstC4INCy0YrQttC80LDQs9GA0LDQttC00LDQstCwINC30LAg0L/Rg9Cx0LvQuNC60LDRhtC40LgsINC60L7QvNC10L3RgtCw0YDQuCDQuCDQutGD0YDQsNGC0L7RgNGB0YLQstC+LlwiLFxuXHRcIkFCT1VUXzNcIjogXCLQuCDQtSDQvNC+0LHQuNC70L3QviDQv9GA0LjQu9C+0LbQtdC90LjQtSDRgSDQvtGC0LLQvtGA0LXQvSDQutC+0LQuINCY0LzQsNGC0LUg0YHQstC+0LHQvtC00LXQvSDQtNC+0YHRgtGK0L8g0LTQviDRgdGK0LTRitGA0LbQsNC90LjQtSDQt9CwINGH0LXRgtC10L3QtSwg0LrQvtC80LXQvdGC0LDRgNC4LCDQs9C70LDRgdGD0LLQsNC90LUsINC/0YPQsdC70LjQutGD0LLQsNC90LUsINGD0L/RgNCw0LLQu9C10L3QuNC1INC90LAg0L/RgNC40YXQvtC00Lgg0LfQsCDRgtGA0LDQvdGB0YTQtdGAINC4INGCLtC9LiDRhNGD0L3QutGG0LjQuCwg0L/RgNC10LTQu9Cw0LPQsNC90Lgg0L7RgiB7e3BsYXRmb3JtbmFtZX19INCx0LvQvtC60YfQtdC50L3QsCDQvdCwIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQvdGP0LzQsCDQtNC40YDQtdC60YLQtdC9INC00L7RgdGC0YrQvyDQtNC+INGB0YDQtdC00YHRgtCy0LDRgtCwINC90LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQv9GA0LXQtNC70LDQs9CwINC80L7QtNC10Lsg0L3QsCDRgdC40LPRg9GA0L3QvtGB0YIg0LfQsCDRgdGC0YDQsNC90LAg0L3QsCDQutC70LjQtdC90YLQsCwg0YEg0YfQsNGB0YLQvdC4INC60LvRjtGH0L7QstC1LCDRgdGK0YXRgNCw0L3QtdC90Lgg0YHQsNC80L4g0LLRitCyINCy0LDRiNC10YLQviDRg9GB0YLRgNC+0LnRgdGC0LLQviDQuCDQvdC40LrQvtCz0LAg0L3QtSDRgdC1INC40LfQv9GA0LDRidCw0YIg0LTQviDRgdGK0YDQstGK0YDQuC5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQv9GA0LXQtNC70LDQs9CwINC/0YDQvtGB0YIg0Lgg0LDRgtGA0LDQutGC0LjQstC10L0g0L/QvtGC0YDQtdCx0LjRgtC10LvRgdC60Lgg0LjQvdGC0LXRgNGE0LXQudGBLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC90LjQutC+0LPQsCDQvdC1INC40LfQuNGB0LrQstCwINC+0YIg0L/QvtGC0YDQtdCx0LjRgtC10LvRj9GCINC00LAg0LLRitCy0LXQttC00LAg0LvQuNGH0L3QuCDQtNCw0L3QvdC4LlwiLFxuXHRcIkFCT1VUXzhcIjogXCLQk9C70LDRgdGD0LLQsNC50YLQtSDQt9CwIGdvb2Qta2FybWEuXCIsXG5cdFwiQUJPVVRfOVwiOiBcItCa0L7QvdGC0LDQutGCINC4INC+0LHRgNCw0YLQvdCwINCy0YDRitC30LrQsDpcIixcblx0XCJBQk9VVF8xMFwiOiBcItCe0YnQtSDQuNC90YTQvtGA0LzQsNGG0LjRj1wiLFxuXHRcIlJFTU9WRVwiOiBcItCf0YDQtdC80LDRhdC90LhcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcItCY0LfQs9C70LXQtCDQvdCwINC/0LDQt9Cw0YDQsFwiLFxuXHRcIlBSSUNFXCI6IFwi0KbQtdC90LBcIixcblx0XCJBTU9VTlRcIjogXCLQodGD0LzQsFwiLFxuXHRcIlRPVEFMXCI6IFwi0J7QsdGJ0L5cIixcblx0XCJOT09SREVSU1wiOiBcItCd0Y/QvNCwINC+0YLQstC+0YDQtdC90Lgg0LfQsNGP0LLQutC4XCIsXG5cdFwiREFURVwiOiBcItCU0LDRgtCwXCIsXG5cdFwiQlVZXCI6IFwi0JrRg9C/0LhcIixcblx0XCJTRUxMXCI6IFwi0J/RgNC+0LTQsNC5XCIsXG5cdFwiT1BFTlwiOiBcItCe0YLQstC+0YDQuFwiLFxuXHRcIkhJU1RPUllcIjogXCLQmNGB0YLQvtGA0LjRj1wiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwi0KHQu9C10LTQstCw0L3QtSDQvtCx0YDQsNGC0L3QvlwiLFxuXHRcIkZPTExPV0VEXCI6IFwi0KHQu9C10LTQstCw0L1cIixcblx0XCJVTkZPTExPV1wiOiBcItCh0L/RgNC10YLQtSDRgdC70LXQtNC10L3QtdGC0L5cIixcblx0XCJGT0xMT1dJTkdcIjogXCLQodC70LXQtNCy0LDQvdC1XCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwi0J/QvtGB0LvQtdC00L7QstCw0YLQtdC70LhcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwi0KLRitGA0YHQuCDQv9C+0YHQu9C10LTQvtCy0LDRgtC10LvQuFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCLQotGK0YDRgdC4INGB0LvQtdC00LLQsNC90LhcIixcblx0XCJCWVwiOiBcItC+0YJcIixcblx0XCJJTlwiOiBcItCyXCIsXG5cdFwiTUVOVVwiOiBcItCc0LXQvdGOXCIsXG5cdFwiQk9PS01BUktcIjogXCLQm9GO0LHQuNC80LhcIixcblx0XCJSRUJMT0dcIjogXCLQoNC10LHQu9C+0LNcIixcblx0XCJVUFZPVEVcIjogXCLQk9C70LDRgVwiLFxuXHRcIkRPV05WT1RFXCI6IFwi0J3QtdCz0LDRgtC40LLQtdC9INCz0LvQsNGBXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcItCe0YLQutCw0LbQuCDQvdC10LPQsNGC0LjQstC90LjRjyDQs9C70LDRgVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi0J7RgtC60LDQttC4INCz0LvQsNGB0LBcIixcblx0XCJSRVBMWVwiOiBcItCe0YLQs9C+0LLQvtGAXCIsXG5cdFwiRURJVFwiOiBcItCg0LXQtNCw0LrRgtC40YDQsNC90LVcIixcblx0XCJQT1NUXzFcIjogXCLQn9C70YrQt9C90LXRgtC1INC90LAg0LvRj9Cy0L4sINC30LAg0LTQsCDQstC40LTQuNGC0LUg0L7Qv9GG0LjQuNGC0LVcIixcblx0XCJQT1NUXzJcIjogXCLQmNC30LHQtdGA0LXRgtC1INC90Y/QutC+0Lkg0LrQvtC80LXQvdGC0LDRgCwg0LfQsCDQtNCwINCy0LjQtNC40YLQtSDQv9C+0LQt0LrQvtC80LXQvdGC0LDRgNC4INC60YrQvCDRgtGP0YUuXCIsXG5cdFwiT1BUSU9OU1wiOiBcItCd0LDRgdGC0YDQvtC50LrQuFwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcItCf0YDQtdC/0YDQsNGC0LXQvdC+INC+0YJcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLQktGB0LUg0L7RidC1INC90LjRidC+Li4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCLQkdCw0LvQsNC90YHQuCDQv9C+INGB0LzQtdGC0LrQsFwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0g0LUg0YDQsNC30LzQtdC90Y/QtdC80LAg0LrRgNC40L/RgtC+0LLQsNC70YPRgtCwLCDQutC+0Y/RgtC+INC80L7QttC1INC00LAg0LHRitC00LUg0YLRgNCw0L3RgdGE0LXRgNC40YDQsNC90LAg0LLRitCyINCy0YHQtdC60Lgg0LXQtNC40L0g0LzQvtC80LXQvdGCLiB7e3BsYXRmb3JtbmFtZX19INC80L7QttC1INC00LAg0LHRitC00LUg0L7QsdGK0YDQvdCw0YLQsCDQsiB7e3BsYXRmb3JtcG93ZXJ9fSDRh9GA0LXQtyDQv9GA0L7RhtC10YEg0L3QsNGA0YfQtdC9INCX0LDRhdGA0LDQvdCy0LDQvdC1LlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19INCy0LvQuNGP0LUg0LLRitGA0YXRgyDQv9C10YfQsNC70LHQuNGC0LUuINCa0L7Qu9C60L7RgtC+INC/0L7QstC10YfQtSDQuNC80LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjywg0YHQuNGB0YLQtdC80LDRgtCwINCz0L4g0L3QsNCz0YDQsNC20LTQsNCy0LAg0L/QvtCy0LXRh9C1INC60L7Qs9Cw0YLQviDQs9C70LDRgdGD0LLQsCDQuCDQv9GD0LHQu9C40LrRg9Cy0LAuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwi0J7QutC+0LvQviB7e3BsYXRmb3Jtc3VuaXR9fSDQvdCwIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi0J/RgNC40LHQu9C40LfQuNGC0LXQu9C90LAg0YHRgtC+0LnQvdC+0YHRglwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcItCf0YDQuNCx0LvQuNC30LjRgtC10LvQvdCw0YLQsCDRgdGC0L7QudC90L7RgdGCINGB0LUg0L7RhtC10L3Rj9Cy0LAg0L3QsCA3INC00L3QuCDQvtGCINGB0YDQtdC00L3QsCDRgdGC0L7QudC90L7RgdGCINC90LAge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi0JjRgdGC0L7RgNC40Y8g0L3QsCDRgtGA0LDQvdC30LDQutGG0LjQudGC0LVcIixcblx0XCJQT1NUSU5HXCI6IFwi0J/Rg9Cx0LvQuNC60YPQstCw0L3QtVwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcItCa0LvRjtGH0YrRgiDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LUg0YHQtSDQuNC30L/QvtC70LfQstCwINC30LAg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDQuCDQs9C70LDRgdGD0LLQsNC90LUuINCi0YDRj9Cx0LLQsCDQtNCwINCx0YrQtNC1INGA0LDQt9C70LjRh9C10L0g0L7RgiDQkNC60YLQuNCy0L3QuNGPINC4INCh0L7QsdGB0YLQstC10L3QuNGPINC60LvRjtGHLlwiLFxuXHRcIk9XTkVSXCI6IFwi0KHQvtCx0YHRgtCy0LXQvdC40LpcIixcblx0XCJQUk9GSUxFXzZcIjogXCLQodC+0LHRgdGC0LLQtdC90LjRj9GCINC60LvRjtGHINC1INC+0YHQvdC+0LLQvdC40Y/RgiDQutC70Y7RhyDQvdCwINC/0YDRhNC40LvQsCDQuCDQtSDQvdC10L7QsdGF0L7QtNC40Lwg0LfQsCDQv9GA0L7QvNGP0L3QsCDQvdCwINC00YDRg9Cz0LjRgtC1INC60LvRjtGH0L7QstC1LiDQm9C40YfQvdC40Y/RgiDQutC70Y7RhyDQuNC70Lgg0L/QsNGA0L7Qu9CwINC30LAg0LrQu9GO0YfQsCDQvdCwINGB0L7QsdGB0YLQstC10L3QuNC60LAg0YLRgNGP0LHQstCwINGB0LUg0YHRitGF0YDQsNC90Y/QstCwINC90LAg0YHQuNCz0YPRgNC90L4g0LzRj9GB0YLQvi5cIixcblx0XCJBQ1RJVkVcIjogXCLQkNC60YLQuNCy0L3QuFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcItCQ0LrRgtC40LLQvdC40Y/RgiDQutC70Y7RhyDRgdC1INC40LfQv9C+0LvQt9Cy0LAsINC30LAg0YLRgNCw0L3RgdGE0LXRgNC4INC4INC00LDQstCw0L3QtSDQv9C+0YDRitGH0LrQuCDQsiDRgNCw0LzQutC40YLQtSDQvdCwINCy0YrRgtGA0LXRiNC90LjRjyDQv9Cw0LfQsNGALlwiLFxuXHRcIk1FTU9cIjogXCLQkdC10LvQtdC20LrQsFwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcItCa0LvRjtGH0YrRgiDQt9CwINCx0LXQu9C10LbQutCwINGB0LUg0LjQt9C/0L7Qu9C30LLQsCDQt9CwINGB0YrQt9C00LDQstCw0L3QtSDQuCDRh9C10YLQtdC90LUg0L3QsCDQsdC10LvQtdC20LrQuC5cIixcblx0XCJCTE9HXCI6IFwi0JHQu9C+0LNcIixcblx0XCJQT1NUU1wiOiBcItCh0YLQsNGC0LjQuFwiLFxuXHRcIlJFUExJRVNcIjogXCLQntGC0LPQvtCy0L7RgNC4XCIsXG5cdFwiV0FMTEVUXCI6IFwi0J/QvtGA0YLRhNC10LnQu1wiLFxuXHRcIlRBR1wiOiBcItCi0LDQs1wiLFxuXHRcIlVTRVJcIjogXCLQn9C+0YLRgNC10LHQuNGC0LXQu1wiLFxuXHRcIkNMT1NFXCI6IFwi0JfQsNGC0LLQsNGA0Y/QvdC1XCIsXG5cdFwiVE9cIjogXCLQl9CwXCIsXG5cdFwiQVNTRVRcIjogXCLQkNC60YLQuNCyXCIsXG5cdFwiU0VORFwiOiBcItCf0YDQsNGC0LhcIixcblx0XCJTRUNVUklUWVwiOiBcItCh0LjQs9GD0YDQvdC+0YHRglwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcItCd0LDQu9C40YfQvdC+0YHRglwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwi0J/Rg9Cx0LvQuNGH0L3QsCDQsdC10LvQtdC20LrQsFwiLFxuXHRcIlRPX0RFU0NcIjogXCLQn9C+0YLRgNC10LHQuNGC0LXQuywg0L3QsNC/0YDQuNC80LXRgCBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCLQn9C40L0t0LrQvtC0XCIsXG5cdFwiUElOX1RFWFRcIjogXCLQn9C40L0t0LrQvtC00YrRgiDQvtCx0LXQt9C+0L/QsNGB0Y/QstCwINC00LDQvdC90LjRgtC1INCy0Lgg0LIg0L/RgNC40LvQvtC20LXQvdC40LXRgtC+LiA8YnIvPjxici8+0JLQtdC00L3RitC2INCw0LrRgtC40LLQuNGA0LDQvSwg0LjQvNCw0YLQtSDRgdCw0LzQviA0INC+0L/QuNGC0LAg0LfQsCDQtNCwINCz0L4g0L7RgtC60LvRjtGH0LjRgtC1LCDQsNC60L4g0YHRgtC1INC30LDQsdGA0LDQstC40LvQuCDRgdCy0L7RgtGPINC/0LjQvS3QutC+0LQg0LjQu9C4INC90LUg0YHRgtC1INCz0L4g0LLRitCy0LXQu9C4INC/0YDQsNCy0LjQu9C90L4sINCw0L/Qu9C40LrQsNGG0LjRj9GC0LAg0YnQtSDQv9GA0LXQvNCw0YXQvdC1INC00LDQvdC90LjRgtC1INC90LAg0L/QvtGC0YDQtdCx0LjRgtC10LvRjyDQv9GA0Lgg0LLQu9C40LfQsNC90LUuINCc0L7QttC10YLQtSDQv9C+0LLRgtC+0YDQvdC+INC00LAg0LLQu9C10LfQvdC10YLQtSDQuCDQv9GA0L7QtNGK0LvQttC40YLQtSDQtNCwINC40LfQv9C+0LvQt9Cy0LDRgtC1INC/0YDQuNC70L7QttC10L3QuNC10YLQvi5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi0JjQt9Cy0LXRgdGC0LjRj1wiLFxuXHRcIlZPVEVfVEVYVFwiOiBcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQs9C70LDRgdGD0LLQsCDQt9CwINCy0LDRiNCwINGB0YLQsNGC0LjRjy4gPGJyLz7Qo9Cy0LXQtNC+0LzQu9C10L3QuNGP0YLQsCDQstC60LvRjtGH0LLQsNGCINCh0LjQu9CwINC90LAg0LPQu9Cw0YEg0LrQsNC60YLQviDQuCDQv9GA0LXQtNGD0L/RgNC10LTQuNGC0LXQu9C90Lgg0YHRitC+0LHRidC10L3QuNGPLlwiLFxuXHRcIlZPVEVcIjogXCLQk9C70LDRgVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcItCp0LUg0L/QvtC70YPRh9C40YLQtSDQuNC30LLQtdGB0YLQuNC1LCDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDQutC+0LzQtdC90YLQuNGA0LAg0LLQsNGI0LjRgtC1INC/0YPQsdC70LjQutCw0YbQuNC4INC40LvQuCDQutC+0LzQtdC90YLQsNGA0LghPGJyLz4g0JjQt9Cy0LXRgdGC0LjRj9GC0LAg0YHRitGJ0L4g0LLQutC70Y7Rh9Cy0LDRgiDQutC+0LPQsNGC0L4g0L3Rj9C60L7QuSDRgNC10LTQsNC60YLQuNGA0LAg0YHQstC+0LjRgtC1INC60L7QvNC10L3RgtCw0YDQuC5cIixcblx0XCJDT01NRU5UXCI6IFwi0JrQvtC80LXQvdGC0LDRgFwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INCy0Lgg0YHQu9C10LTQuCDQuNC70Lgg0YnQtSDRgdC/0YDQtSDQtNCwINCy0Lgg0YHQu9C10LTQuCFcIixcblx0XCJNRU5USU9OU1wiOiBcItCh0L/QvtC80LXQvdCw0LLQsNC90LjRj1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLQqdC1INC/0L7Qu9GD0YfQuNGC0LUg0LjQt9Cy0LXRgdGC0LjQtSwg0LrQvtCz0LDRgtC+INC90Y/QutC+0Lkg0LLQuCDRgdC/0L7QvNC10L3QtSDQsiDRgdCy0L7RjyDQv9GD0LHQu9C40LrQsNGG0LjRjyDQuNC70Lgg0LrQvtC80LXQvdGC0LDRgCFcIixcblx0XCJSRVNURUVNXCI6IFwi0KHQv9C+0LTQtdC70Y/QvdC1XCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwi0KnQtSDQv9C+0LvRg9GH0LjRgtC1INC40LfQstC10YHRgtC40LUsINC60L7Qs9Cw0YLQviDQvdGP0LrQvtC5INGB0L/QvtC00LXQu9C4INCy0LDRiCDQv9C+0YHRgiFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcItCd0LDRgdGC0YDQvtC50LrQuFwiLFxuXHRcIlZPVElOR1wiOiBcItCT0LvQsNGB0YPQstCw0L3QtVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi0JjQt9Cx0LXRgNC10YLQtSDQsiDQv9GA0L7RhtC10L3RgtC4INGB0LjQu9Cw0YLQsCDQvdCwINCz0LvQsNGB0LAg0LLQuC5cXG4gPGJyLz48YnIvPtCi0L7QstCwINGJ0LUg0L7Qv9GA0LXQtNC10LvQuCDRgNCw0LfQvNC10YDQsCDQstGK0LbQvdCw0LPRgNCw0LbQtNC10L3QuNGPICwg0LrQvtC40YLQviDQv9C+0LvRg9GH0LDQstCw0YIg0YHRgtCw0YLQuNC40YLQtSwg0LfQsCDQutC+0LjRgtC+INCz0LvQsNGB0YPQstCw0YLQtS5cIixcblx0XCJTRVJWRVJcIjogXCLQodGK0YDQstGK0YBcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcItCf0YDQtdC/0L7RgNGK0YfQuNGC0LXQu9C90L5cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLQl9Cw0L/QsNC30LhcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItCY0L3RhNC+0YDQvNCw0YbQuNGPINC30LAg0LPQu9Cw0YHRg9Cy0LDQu9C40YLQtVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcItCX0LTRgNCw0LLQtdC5LCDQvtGC0L3QvtCy0L4hXCIsXG5cdFwiTE9HSU5fMVwiOiBcItCS0LvQtdC30YLQtSDRgSDQv9C+0YLRgNC10LHQuNGC0LXQu9GB0LrQviDQuNC80LUg0Lgg0L/QsNGA0L7Qu9CwINC30LAg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtS5cIixcblx0XCJMT0dJTl8yXCI6IFwi0JrQu9GO0YfRitGCINC30LAg0L/Rg9Cx0LvQuNC60YPQstCw0L3QtSDRgdC1INC40LfQv9C+0LvQt9Cy0LAg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1LCDQutC+0LzQtdC90YLQuNGA0LDQvdC1LCDQs9C70LDRgdGD0LLQsNC90LUg0Lgg0YHQu9C10LTQtdC90LUuXCIsXG5cdFwiTE9HSU5fM1wiOiBcItCQ0LrRgtC40LLQvdC40Y/RgiDQutC70Y7RhyDRgdC1INC40LfQv9C+0LvQt9Cy0LAg0LfQsCDRgtGA0LDQvdGB0YTQtdGA0Lgg0Lgg0L7QsdC90L7QstC70LXQvdC40LUg0L3QsCDQv9GA0L7RhNC40LvQvdCwINGB0L3QuNC80LrQsC5cIixcblx0XCJMT0dJTl80XCI6IFwi0J/QvtGC0YDQtdCx0LjRgtC10LvRgdC60Lgg0LjQtNC10L3RgtC40YTQuNC60LDRhtC40L7QvdC90Lgg0LTQsNC90L3QuCDRgdC1INGB0YrRhdGA0LDQvdGP0LLQsNGCINC70L7QutCw0LvQvdC+INC90LAg0YPRgdGC0YDQvtC50YHRgtCy0LDRgtCwINCy0LguINCf0YDQuCDQuNC30YXQvtC0INC/0YrQu9C90L7QvNC+0YnQuNGP0YLQsCDRgdC1INC+0YLRgdGC0YDQsNC90Y/QstCw0YIhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi0J3Rj9C80LDRgtC1INC/0YDQvtGE0LjQuz9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcItCg0LXQs9C40YHRgtGA0LjRgNCw0LnRgtC1INGB0LUg0YHQtdCz0LAhXCIsXG5cdFwiQ0FOQ0VMXCI6IFwi0J7RgtC60LDQt1wiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi0KDQsNC30YjQuNGA0LXQvSDRgNC10LbQuNC8XCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcItCQ0LrRgtC40LLQtdC9INC70LjRh9C10L0g0LrQu9GO0YdcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcItCb0LjRh9C10L0g0LrQu9GO0Ycg0LfQsCDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1XCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCLQntGB0L3QvtCy0L3QsCDQv9Cw0YDQvtC70LBcIixcblx0XCJVU0VSTkFNRVwiOiBcItCf0L7RgtGA0LXQsdC40YLQtdC70YHQutC+INC40LzQtVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcItCa0LDRgNGC0LjRh9C60LhcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLQodC/0LjRgdGK0YbQuFwiLFxuXHRcIlNFQVJDSFwiOiBcItCi0YrRgNGB0LhcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcItCf0YPQsdC70LjQutGD0LLQsNC50YLQtSDQvdC10YnQvlwiLFxuXHRcIlJFUExZVE9cIjogXCLQntGC0LPQvtCy0L7RgCDQvdCwXCIsXG5cdFwiUE9TVFwiOiBcItCf0YPQsdC70LjQutGD0LLQsNC90LVcIixcblx0XCJQUkVWSUVXXCI6IFwi0J/RgNC10LPQu9C10LRcIixcblx0XCJERUZBVUxUXCI6IFwiNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcItCX0LDRhdGA0LDQvdCy0LDQvdC1IDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcItCe0YLQutCw0Lcg0L3QsCDQstGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCLQl9Cw0L/QsNC30LLQsNC90LUg0LfQsCDQv9C+LdC60YrRgdC90L5cIixcblx0XCJDTEVBUlwiOiBcItCY0LfRh9C40YHRgtCy0LDQvdC1XCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi0JrQvtC80LXQvdGC0LDRgFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcItCh0YrQtNGK0YDQttCw0L3QuNC1INC90LAg0LrQvtC80LXQvdGC0LDRgNCwXCIsXG5cdFwiVElUTEVcIjogXCLQl9Cw0LPQu9Cw0LLQuNC1XCIsXG5cdFwiVEFHU1wiOiBcItCi0LDQs9C+0LLQtVwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcItCd0LUg0YHRitCy0L/QsNC00LBcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcItCf0L7RgtCy0YrRgNC00LXRgtC1INC/0LjQvS3QutC+0LTQsFwiLFxuXHRcIklOQ09SUkVDVFwiOiBcItCT0YDQtdGI0L3QvlwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcItCe0YLQstCw0YDQsNC90LUg0L3QsCDRgdGC0LDRgtC40Y8uXCIsXG5cdFwiU0VUX1BJTlwiOiBcItCX0LDQtNCw0LnRgtC1INC/0LjQvS3QutC+0LQuXCIsXG5cdFwiRU5URVJfUElOXCI6IFwi0JLRitCy0LXQtNC10YLQtSDQv9C40L0t0LrQvtC0LlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcItCh0LjQs9GD0YDQvdC4INC70Lgg0YHRgtC1P1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwi0KHQv9C+0LTQtdC70Y/QvdC10YLQviDQtSDQvdC10L7QsdGA0LDRgtC40LzQviwg0LjRgdC60LDRgtC1INC70Lgg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLQk9GA0LXRiNC60LAg0L/RgNC4INGB0LLRitGA0LfQstCw0L3QtSwg0L7Qv9C40YLQsNC50YLQtSDQvtGC0L3QvtCy0L4hXCIsXG5cdFwiU1VDQ0VTU1wiOiBcItCj0YHQv9C10YUhXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLQodC/0L7QtNC10LvQtdC90LAg0L/Rg9Cx0LvQuNC60LDRhtC40Y8hXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcItCd0LXRg9GB0L/QtdGI0L3QviDQstC70LjQt9Cw0L3QtSEg0JzQvtC70Y8sINGD0LLQtdGA0LXRgtC1INGB0LUsINGH0LUg0YHRgtC1INCy0LvQtdC30LvQuCDQsiDRgdC40YHRgtC10LzQsNGC0LAg0YEg0LPQu9Cw0LLQvdCw0YLQsCDQv9Cw0YDQvtC70LAg0LjQu9C4INGBINGH0LDRgdGC0LXQvSDQutC70Y7RhyDQt9CwINC/0YPQsdC70LjQutGD0LLQsNC90LUg0L/RgNC4INCy0LvQuNC30LDQvdC1LCDQsNC60L4g0YHRgtC1INC40LfQsdGA0LDQu9C4INCg0LDQt9GI0LjRgNC10L0g0YDQtdC20LjQvC5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLQndC10YPRgdC/0LXRiNC90L4g0LLQu9C40LfQsNC90LUhINCc0L7Qu9GPLCDRg9Cy0LXRgNC10YLQtSDRgdC1LCDRh9C1INGB0YLQtSDQstC70LXQt9C70Lgg0LIg0YHQuNGB0YLQtdC80LDRgtCwINGBINCz0LvQsNCy0L3QsNGC0LAg0L/QsNGA0L7Qu9CwINC40LvQuCDRgSDQkNC60YLQuNCy0L3QuNGPINGH0LDRgdGC0LXQvSDQutC70Y7RhyDQv9GA0Lgg0LLQu9C40LfQsNC90LUsINCw0LrQviDRgdGC0LUg0LjQt9Cx0YDQsNC70Lgg0KDQsNC30YjQuNGA0LXQvSDRgNC10LbQuNC8LlwiLFxuXHRcIldBUk5JTkdcIjogXCLQktC90LjQvNCw0L3QuNC1XCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcItCT0LvQsNGB0YPQstCw0L3QtSDQt9CwIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcItCT0LvQsNGB0YPQstCw0L3QviDQt9CwIHdpdG5lc3NcIixcblx0XCJBR09cIjogXCItXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLQvtGC0L/RgNC10LTQuFwiLFxuXHRcIlNFQ1NcIjogXCLRgdC10LpcIixcblx0XCJBX01JTlwiOiBcItC80LjQvVwiLFxuXHRcIk1JTlNcIjogXCLQvNC40L1cIixcblx0XCJBTl9IT1VSXCI6IFwi0YfQsNGBXCIsXG5cdFwiSE9VUlNcIjogXCLRh9Cw0YHQsFwiLFxuXHRcIkFfREFZXCI6IFwi0LTQtdC9XCIsXG5cdFwiREFZU1wiOiBcItC00L3QuFwiLFxuXHRcIkFfTU9OVEhcIjogXCLQvNC10YHQtdGGXCIsXG5cdFwiTU9OVEhTXCI6IFwi0LzQtdGB0LXRhtCwXCIsXG5cdFwiQV9ZRUFSXCI6IFwi0LPQvtC00LjQvdCwXCIsXG5cdFwiWUVBUlNcIjogXCLQs9C+0LTQuNC90LhcIixcblx0XCJNSU5fUkVBRFwiOiBcIi3QvNC40L3Rg9GC0L3QviDRh9C10YLQtdC90LUuXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcItCe0YLRgNC40YbQsNGC0LXQu9C10L0g0LPQu9Cw0YEg0LjQu9C4INGB0LvQsNCz0LDQvdC1INC90LAg0YTQu9Cw0LMuXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwi0KHQvdC40LzQutCwXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLQmNC30LHQtdGA0LXRgtC1INGB0L3QuNC80LrQsFwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwi0JfQsNC00LDQudGC0LUgVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCLQlNC+0LHQsNCy0LXRgtC1INGB0L3QuNC80LrQsFwiLFxuXHRcIkVSUk9SXCI6IFwi0JPRgNC10YjQutCwXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi0JPRgNC10YjQutCwINC/0YDQuCDQutCw0YfQstCw0L3QtVwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCLQndGP0LzQsCDQtNC+0YHRgtGK0L8g0LTQviDQutCw0LzQtdGA0LDRgtCwLlwiLFxuXHRcIlNFVF9VUkxcIjogXCLQodC70L7QttC10YLQtSBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi0JTQuNGA0LXQutGC0L3QsCDQstGA0YrQt9C60LAg0LrRitC8INGB0L3QuNC80LrQsNGC0LBcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcItCa0L7QvNC10L3RgtCw0YDRitGCINC1INC/0YPQsdC70LjQutGD0LLQsNC9IVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi0JjQt9GC0YDQuNCy0LDQvdC10YLQviDQvdCwINC60L7QvNC10L3RgtCw0YDQuCDQtSDQvdC10L7QsdGA0LDRgtC40LzQvlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcItCY0LfRgtGA0LjRgiDQutC+0LzQtdC90YLQsNGAXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLQmtCw0YfQstCw0L3QtSDQvdCwINGB0L3QuNC80LrQsFwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLQmtCw0YfQstCw0L3QtdGC0L4g0L/RgNC40LrQu9GO0YfQuFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLQk9GA0LXRiNC60LAg0L/RgNC4INC60LDRh9Cy0LDQvdC1XCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwi0J/QsNGA0L7Qu9Cw0YLQsCDQuNC70Lgg0L/QvtGC0YDQtdCx0LjRgtC10LvRgdC60L7RgtC+INC40LzQtSDRgdCwINCz0YDQtdGI0L3QuFwiLFxuXHRcIklORk9cIjogXCLQmNC90YTQvtGA0LzQsNGG0LjRj1wiLFxuXHRcIlFSX1RFWFRcIjogXCLQn9C+0YHRgtCw0LLQtdGC0LUg0L3QsCBRUiDQutC+0LQg0LIg0L/QvtC70LXRgtC+INC30LAg0YHQutCw0L3QuNGA0LDQvdC1XCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi0KPQstC10YDQtdGC0LUg0YHQtSwg0YfQtSDQuNC80LDRgtC1INC00L7RgdGC0LDRgtGK0YfQvdCwINGB0YPQvNCwINC30LAg0YLRgNCw0L3RgdGE0LXRgCFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi0J/QvtGC0YDQtdCx0LjRgtC10LvRj9GCINC60YrQvCwg0LrQvtCz0L7RgtC+INGB0LUg0L7Qv9C40YLQstCw0YLQtSDQtNCwINC/0YDQtdGF0LLRitGA0LvQuNGC0LUg0YHRg9C80LDRgtCwINC90LUg0YHRitGJ0LXRgdGC0LLRg9Cy0LAhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcItCh0LjQs9GD0YDQvdC4INC70Lgg0YHRgtC1LCDRh9C1INC40YHQutCw0YLQtSDQtNCwINC/0YDQtdCy0LXQtNC10YLQtSDRgdGD0LzQsNGC0LA/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwi0J/QvtGC0LLRitGA0LbQtNCw0LLQsNC90LVcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcItCi0YDQsNC90LfQsNC60YbQuNGP0YLQsCDRgdC1INC40LfQu9GK0YfQstCwLi4uXCIsXG5cdFwiRkVFRFwiOiBcItCf0L7RgtC+0LpcIixcblx0XCJUUkVORElOR1wiOiBcItCi0LXQvdC00LXQvdGG0LjQuFwiLFxuXHRcIkhPVFwiOiBcItCT0L7RgNC10YnQuFwiLFxuXHRcIk5FV1wiOiBcItCd0L7QstC4XCIsXG5cdFwiUFJPTU9URURcIjogXCLQn9GA0L7QvNC+0YLQuNGA0LDQvdC4XCIsXG5cdFwiVk9URVNcIjogXCLQk9C70LDRgdC+0LLQtVwiLFxuXHRcIlBBWU9VVFwiOiBcItCY0LfQv9C70LDRidCw0L3QtVwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi0JrQvtC80LXQvdGC0LDRgNC4XCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCLQotC10L3QtNC10L3RhtC40Lgg0LfQsCDQv9C+0YHQu9C10LTQvdC40YLQtSAzMCDQtNC90LhcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCLQodC+0YDRgtC40YDQsNC90LUg0L/QvjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLQptC40LrRitC7INC90LAg0LjQt9C/0LvQsNGJ0LDQvdC1XCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcItCf0L7RgtC10L3RhtC40LDQu9C90L4g0LjQt9C/0LvQsNGJ0LDQvdC1XCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLQn9C+0YHQu9C10LTQvdC+INC40LfQv9C70LDRidCw0L3QtVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLQkNCy0YLQvtGA0YHQutC+INCy0YrQt9C90LDQs9GA0LDQttC00LXQvdC40LVcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLQktGK0LfQvdCw0LPRgNCw0LbQtNC10L3QuNGPINC+0YIg0LrRg9GA0LDRgtC+0YDRgdGC0LLQvlwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi0KHRgtCw0YLQuNGP0YLQsCDQtSDQv9GD0LHQu9C40LrRg9Cy0LDQvdCwXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcItCf0YPQsdC70LjQutGD0LLQsNC50YLQtSDQv9C+LdC60YrRgdC90L4hXCIsXG5cdFwiU0FWRURcIjogXCLQl9Cw0L/QsNC30LXQvdC+XCIsXG5cdFwiQ0xFQVJFRFwiOiBcItCY0LfRh9C40YHRgtC10L3QvlwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCLQodC70LDQs9Cw0L3QtdGC0L4g0L3QsCDRhNC70LDQsyDQvNC+0LbQtSDQtNCwINC90LDQvNCw0LvQuCDQvdCw0LPRgNCw0LTQuNGC0LUg0Lgg0LTQsCDRgdCy0LDQu9C4INGB0YLQsNGC0LjRj9GC0LAg0L7RgiDQv9GA0LXQtNC90LjRgtC1INGA0LXQtNC40YbQuC48YnI+PGJyPtCk0LvQsNCz0YrRgiDQsdC40LLQsCDQtNCwINGB0LUg0L/QvtC70LfQstCwINC/0YDQuCDQuNC30LzQsNC80Lgg0LjQu9C4INC/0LvQsNCz0Y/RgtGB0YLQstC+LCDQvtC80YDQsNC30L3QsCDRgNC10YcsINC40L3RgtC10YDQvdC10YIg0YLRgNC+0LvQuCwg0YPQvNC40YjQu9C10L3QviDQvdC10L/RgNCw0LLQuNC70L3QviDQutCw0YLQtdCz0L7RgNC40LfQuNGA0LDQvdC+INGB0YrQtNGK0YDQttCw0L3QuNC1INC4INGB0L/QsNC8LlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcItCb0LjQvNC40YIg0LfQsCDQt9Cw0Y/QstC60LAg0LUg0LTQvtGB0YLQuNCz0L3QsNGCLiDQoNCw0LfQs9C70LXQtNCw0LnRgtC1INC00YDRg9Cz0Lgg0YLQtdC90LTQtdC90YbQuNC4L9GC0LDQs9C+0LLQtSFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLQodGC0LDRgtC40Y/RgtCwINC1INC/0YDQtdC80LDRhdC90LDRgtCwINC+0YIg0LvRjtCx0LjQvNC4IVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLQodGC0LDRgtC40Y/RgtCwINC1INC00L7QsdCw0LLQtdC90LAg0LIg0JvRjtCx0LjQvNC4IVwiLFxuXHRcIlJFU0VUXCI6IFwi0JjQt9GH0LjRgdGC0LLQsNC90LVcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcItCf0YDQvtC80Y/QvdCwINC90LAg0L/RgNC+0YTQuNC70L3QsCDRgdC90LjQvNC60LBcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItCf0YDQvtC80Y/QvdCwINC90LAg0YjQsNCx0LvQvtC90L3QsNGC0LAg0YHQvdC40LzQutCwXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi0JzQvtC70Y8sINC/0YDQtdC00YHRgtCw0LLQtdGC0LUg0JDQutGC0LjQstC10L0g0YfQsNGB0YLQtdC9INC60LvRjtGHLCDQsNC60L4g0YHRgtC1INC40LfQsdGA0LDQu9C4INCg0LDQt9GI0LjRgNC10L0g0YDQtdC20LjQvCDQt9CwINCy0YXQvtC0IVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcItCi0L7QstCwINGJ0LUg0L/RgNC10LzQsNGF0L3QtSDQv9GA0L7RhNC40LvQvdCw0YLQsCDRgdC90LjQutC80LrQsFwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcItCi0L7QstCwINGJ0LUg0L/RgNC10LzQsNGF0L3QtSDRiNCw0LHQu9C+0L3QvdCw0YLQsCDRgdC90LjQutC80LrQsFwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwi0J3Rg9C20LXQvSDQtSDRgNC10YHRgtCw0YDRgiDQvdCwINGB0YrRgNCy0YrRgNCwIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCLQndCw0YHRgtGA0L7QudC60LjRgtC1INGB0LAg0L7QsdC90L7QstC10L3QuCFcIixcblx0XCJMQU5HVUFHRVNcIjogXCLQldC30LjQulwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi0J7RgiDRgtGD0Log0YHQtSDRgdC80LXQvdGP0YIg0LXQt9C40YbQuNGC0LUg0L3QsCDQsNC/0LvQuNC60LDRhtC40Y/RgtCwLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLQotCw0LfQuCDQvtC/0LXRgNCw0YbQuNGPINC40LfQuNGB0LrQstCwINC/0L7RgtGA0LXQsdC40YLQtdC70Y8g0LTQsCDQstC70LXQt9C10YLQtSDQsiDQv9GA0L7RhNC40LvQsCDRgSDQvtGB0L3QvtCy0L3QsCDQv9Cw0YDQvtC70LAsINGBINCw0LrRgtC40LLQtdC9L9C/0YPQsdC70LjQutGD0LLQsNC90LUg0LrQu9GO0YcuINCc0L7Qu9GPLCDQstC70LXQt9GC0LUg0Lgg0L7Qv9C40YLQsNC50YLQtSDQvtGC0L3QvtCy0L4uXCIsXG5cdFwiR0FMTEVSWVwiOiBcItCT0LDQu9C10YDQuNGPXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi0J/RgNC10LLQvtC00LDRh9C4XCIsXG5cdFwiU0hBUkVcIjogXCLQodC/0L7QtNC10LvQuFwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwi0JHQvtGA0YHQsFwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwi0J7QsdC80Y/QvdCwXCIsXG5cdFwiRFJBRlRTXCI6IFwi0KfQtdGA0L3QvtCy0LhcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLQodGC0LDRgtC40Y/RgtCwINC1INC/0YDQtdC80LDRhdC90LDRgtCwINC+0YIg0YfQtdGA0L3QvtCy0LjRgtC1IVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCLQodGC0LDRgtC40Y/RgtCwINC1INC00L7QsdCw0LLQtdC90LAg0LIg0YfQtdGA0L3QvtCy0LjRgtC1IVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLQn9GK0LvQt9C90LXRgtC1INC90LDQu9GP0LLQviDQt9CwINC+0L/RhtC40LhcIixcblx0XCJNQU5BR0VcIjogXCLQo9C/0YDQsNCy0LvQtdC90LjQtVwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLQodC90LjQvNC60LDRgtCwINC1INC/0YDQtdC80LDRhdC90LDRgtCwXCIsXG5cdFwiQ09QWVwiOiBcItCa0L7Qv9C40YDQsNC90LVcIixcblx0XCJOT19JTUFHRVwiOiBcItCS0YHQtSDQvtGJ0LUg0L3QtSDRgdGC0LUg0LrQsNGH0LjQu9C4INGB0L3QuNC80LrQsCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcItCf0LvRitC30L3QtdGC0LUg0L3QsNC00L7Qu9GDINC30LAg0L7Qv9GA0LXRgdC90Y/QstCw0L3QtVwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLQktGK0L3RiNC90Lgg0LDQv9C70LjQutCw0YbQuNC4XCIsXG5cdFwiUExVR0lOU1wiOiBcItCU0L7QsdCw0LLQutC4XCIsXG5cdFwiU1VHR0VTVFwiOiBcItCf0YDQtdC00LvQvtC20LXRgtC1XFxuXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCLQntGH0LDQutCy0LDQudGC0LUg0YHQutC+0YDQvlwiLFxuXHRcIkNIQUlOXCI6IFwi0JHQu9C+0LrRh9C10LnQvVwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCLQntGCINGC0YPQuiDRgdC1INC40LfQsdC40YDQsCDQsdC70L7QutGH0LXQudC9INC40LvQuCDQsdCw0LfQvtCy0LDRgtCwINC/0LvQsNGC0YTQvtGA0LzQsC5cIixcblx0XCJDVVJSRU5DWVwiOiBcItCS0LDQu9GD0YJhXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcItCi0YPQuiDQvNC+0LbQtdGC0LUg0LTQsCDQv9GA0L7QvNC10L3QuNGC0LUg0LLQsNC70YPRgtCw0YLQsCDQsiDQutC+0Y/RgtC+INC40YHQutCw0YLQtSDQtNCwINCy0LjQttC00LDRgtC1INCy0YrQt9C90LDQs9GA0LDQttC00LXQvdC40Y/RgtCwLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPtCk0YPQvdC60YbQuNC4INCyIGVTdGVlbTwvYj48YnI+LdCU0L7RgdGC0YrQvyDQtNC+INGD0L3QuNC60LDQu9C90Lgg0YHRgtCw0YLQuNC4INC90LAg0LLRgdGP0LrQsNC60LLQuCDRgtC10LzQuCwg0LrQvtC40YLQviDQstC4INC40L3RgtC10YDQtdGB0YPQstCw0YIuIDxicj4t0JDQstGC0L7RgtC40YLQtSDQv9C+0LvRg9GH0LDQstCw0YIg0LLRitC30L3QsNCz0YDQsNC20LXQvdC40Y8g0LHQu9Cw0LPQvtC00LDRgNC10L3QuNC1INC90LAg0LPQu9Cw0YHQvtCy0LXRgtC1INC+0YIg0LrRg9GA0LDRgtC+0YDQuNGC0LUsINC60L7QuNGC0L4g0YHRitGJ0L4g0L/QvtC70YPRh9Cw0LLQsNGCINC00Y/QuyDQvtGCINC/0LXRh9Cw0LvQsdC40YLQtS48YnI+LdCf0LXRh9C10LvQuNGC0LUg0L7RgiDQs9C70LDRgdC+0LLQtdGC0LUsINC60L7QuNGC0L4g0L/QvtC70YPRh9Cw0LLQsNGCINCy0LDRiNC40YLQtSDRgdGC0LDRgtC40LgsINC60LDQutGC0L4g0Lgg0L7RgiDQutGD0YDQsNGC0L7RgNGB0YLQstC+LiDQlNCw0LLQsNC50LrQuCDRgdCy0L7RjyDQs9C70LDRgSDQvdCwINC00YDRg9Cz0Lgg0LDQstGC0L7RgNC4INGB0YrRidC+INC/0LXRh9C10LvQuNGC0LUg0LLRitC30L3QsNCz0YDQsNC20LTQtdC90LjQtS48YnI+LdCf0YPQsdC70LjQutGD0LLQsNC50YLQtSDQstCw0YjQuNGC0LUg0YHRgtCw0YLQuNC4INC4INCz0Lgg0YHRitGF0YDQsNC90Y/QstCw0LnRgtC1INCx0LXQt9C/0LvQsNGC0L1vLiDQn9C10YfQtdC70LXRgtC1INCy0YrQt9C90LDQs9GA0LDQttC00LXQvdC40Y8g0L7RgiDQstCw0YjQuNGPINCx0LvQvtCzLjxicj4t0J/QuNGI0LXRgtC1INGB0YLQsNGC0LjQuSDQsiDQtNCy0LjQttC10L3QuNC1LiDQmNC80LDRgtC1INC+0L/RhtC40Y8g0LfQsCDQt9Cw0L/QsNC30LLQsNC90LUg0L3QsCDQvdGP0LrQvtC70LrQviDRh9C10YDQvdC+0LLQuCDQt9CwINC/0L4t0LrRitGB0L3QviDQv9GD0LHQu9C40LrRg9Cy0LDQvdC1Ljxicj4t0JfQsNC/0LDQt9C10YLQtSDRgdGC0LDRgtC40Lgg0LIgXFxcItCb0Y7QsdC40LzQuFxcXCIsINC30LAg0LTQsCDQs9C4INC/0YDQvtGH0LXRgtC10YLQtSDQv9C+LdC60YrRgdC90L4uPGJyPi3QkdC+0YDRgdCwINC4INGC0LXQs9C70LXQvdC1INC90LAg0L/RgNC40YXQvtC00LguPGJyPi3QmNC30L/RgNCw0YnQsNC90LUg0L3QsCDRgdGA0LXQtNGB0YLQstCwINC60YrQvCDQutC+0LPQvtGC0L4g0Lgg0LTQsCDQtSDQsNCy0YLQvtGALCDQv9C+0YLRgNC10LHQuNGC0LXQuywg0L/RgNC40Y/RgtC10LssINC/0L7RgdC70LXRhNC+0LLQsNGC0LXQuyDQuCDRgtC9Ljxicj4t0KHQu9C10LTQstCw0LnRgtC1INC40L3RgtC10YDQtdGB0L3QuCDQsdC70L7Qs9GK0YDQuC48YnI+LdCd0LDQvNC10YDQtdGC0LUg0LLQsNGI0LjRgtC1INC/0L7RgdC70LXQtNC+0LLQsNGC0LXQu9C4INC4INGF0L7RgNCwLCDQutC+0LjRgtC+INGB0LvQtdC00LjRgtC1Ljxicj4t0J/QvtC70YPRh9Cw0LLQsNC90LUg0L3QsCDQuNC30LLQsNGB0YLQuNGPLiDQn9C+0LTRitGA0LbQsNC50YLQtSDQstGA0YrQt9C60LAg0YHRitGBINGB0LLQvtC40YLQtSDQv9C+0YHQu9C10LTQvtCy0LDRgtC10LvQuCwg0YHQu9C10LTQtdGC0LUg0LTQuNGB0LrRg9GB0YLQuNC4LCDQsiDQutC+0LjRgtC+INGD0YfQsNGB0YLQstCw0YLQtS48YnI+LdCi0YrRgNGB0LXQvdC1INC90LAg0LjQvdGC0LXRgNC10YHQvdC4INGC0LDQs9C+0LLQtS/QutCw0YLQtdCz0L7RgNC40Lgg0Lgg0LDQstGC0L7RgNC4LiA8YnI+IC3Qn9C10YDRgdC+0L3QsNC70LjQt9C40YDQsNC90LUg0L3QsCDQstCw0YjQuNGPINC/0YDQvtGE0LjQuy4gPGJyPtCc0L3QvtCz0L4g0YTRg9C90LrRhtC40Lgg0YnQtSDQsdGK0LTQsNGCINC00L7QsdCw0LLQtdC90LguIDxicj48YnI+PGI+0KHQuNCz0YPRgNC90L7RgdGCPC9iPiA8YnI+MS4g0JDQv9C70LjQutCw0YbQuNGP0YLQsCDQvdGP0LzQsCDQtNC40YDQtdC60YLQtdC9INC00L7RgdGC0YrQvyDQutGK0Lwg0LLQsNGI0LjRgtC1INGB0YDQtdC00YHRgtCy0LAuIDxicj4yLiDQkNC/0LvQuNC60LDRhtC40Y/RgtCwINC/0YDQtdC00LvQsNCz0LAg0LzQvtC00LXQuyDQt9CwINGB0LjQs9GD0YDQvdC+0YHRgiDQvtGCINGB0YLRgNCw0L3QsCDQvdCwINC/0L7RgtGA0LXQsdC40YLQtdC70Y8uINCn0LDRgdGC0L3QuNGC0LUg0LrQu9GO0YfQvtCy0LUg0YHQtSDRgdGK0YXRgNCw0L3Rj9Cy0LDRgiDQu9C+0LrQsNC70L3QviDQuCDQvdC40LrQvtCz0LAg0L3QtSDRgdC1INC40LfQv9GA0LDRidCw0YIg0LrRitC8INGB0YrRgNCy0YrRgNC4LiDQktC40LUg0YHRgtC1INC+0YLQs9C+0LLQvtGA0L3QuCDQt9CwINC30LDQv9Cw0LfQstCw0L3QtdGC0L4g0Lgg0YHRitGF0YDQsNC90LDQvdC40LXRgtC+INC90LAg0LLQsNGI0LjRgtC1INC/0LDRgNC+0LvQuC4gPGJyPjMuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQvtC/0YDQvtGB0YLQtdC9INC4INC/0YDQuNCy0LvQtdC60LDRgtC10LvQtdC9INC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40L3RgtC10YDRhNC10LnRgS4gPGJyPjQuINCQ0L/Qu9C40LrQsNGG0LjRj9GC0LAg0L/RgNC10LTQu9Cw0LPQsCDQtNC+0L/RitC70L3QuNGC0LXQu9C90L4g0L3QuNCy0L4g0L3QsCDRgdC40LPRg9GA0L3QvtGB0YIg0YEg0L/QuNC9LdC60L7QtCA8YnI+PGJyPmVTdGVlbSDQv9C+0LTRitGA0LbQsCDQv9C70LDRgtGE0L7RgNC80LjRgtC1IFN0ZWVtINC4IEdvbG9zLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwi0J7RgdC90L7QstCw0YLQtdC7INC4INCz0LvQsNCy0LXQvSDQv9GA0L7Qs9GA0LDQvNC40YHRglwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwi0JTQvtCx0LDQstGP0L3QtSDQvdCwINC00L7Qv9GK0LvQvdC40YLQtdC70LXQvSDQv9GA0L7RhNC40LtcIixcblx0XCJQTEFURk9STVwiOiBcItCf0LvQsNGC0YTQvtGA0LzQsFwiLFxuXHRcIkVTQ1JPV1wiOiBcItCV0YHQutGA0L7Rg1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkVzY3JvdyDQsNCz0LXQvdGCXCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwi0JrRgNCw0LXQvSDRgdGA0L7QuiDQt9CwINGA0LDRgtC40YTQuNGG0LjRgNCw0L3QtVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwi0JjQt9GC0LjRh9Cw0L3QtSDQvdCwIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cg0YLQsNC60YHQsFwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIkVzY3JvdyDQv9GA0LDQstC40LvQsFwiLFxuXHRcIk5JR0hUX01PREVcIjogXCLQndC+0YnQtdC9INGA0LXQttC40LxcIixcblx0XCJEQVlfTU9ERVwiOiBcItCU0L3QtdCy0LXQvSDRgNC10LbQuNC8XCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwi0J/QvtC60LDQttC4INGG0LXQu9C40Y8g0LrQvtC90YLQtdC60YHRglwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCLQn9C+0YLRgNC10LHQuNGC0LXQu9GP0YIg0L3QtSDQtSDQvdCw0LzQtdGA0LXQvVwiLFxuXHRcIkFQUFJPVkVcIjogXCLQntC00L7QsdGA0LhcIixcblx0XCJESVNQVVRFXCI6IFwi0KHQv9C+0YBcIixcblx0XCJSRUxFQVNFXCI6IFwi0J/Rg9GB0LrQsNC90LVcIixcblx0XCJGUk9NXCI6IFwiT9GCXCIsXG5cdFwiSURcIjogXCLQmNC00LXQvdGC0LjRhNC40LrQsNGG0LjRj1wiLFxuXHRcIlNVQk1JVFwiOiBcItCY0LfQv9GA0LDRidCw0L3QtVwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwi0J/QvtC70YPRh9Cw0YLQtdC7XCIsXG5cdFwiTE9DQVRJT05cIjogXCLQnNC10YHRgtC+0L/QvtC70L7QttC10L3QuNC1XCIsXG5cdFwiV0VCU0lURVwiOiBcItCh0YLRgNCw0L3QuNGG0LBcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCLQmNC80LVcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiRG9txa9cIixcblx0XCJMT0dJTlwiOiBcIlDFmWlobMOhxaFlbsOtXCIsXG5cdFwiTE9HT1VUXCI6IFwiT2RobMOhxaFlbsOtXCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbFwiLFxuXHRcIkZPTExPV1wiOiBcIk7DoXNsZWR1alwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlrDoWxvxb5reVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiUMWZZXZvZFwiLFxuXHRcIk1BUktFVFwiOiBcIlRyaFwiLFxuXHRcIlNFVFRJTkdTXCI6IFwiTmFzdGF2ZW7DrVwiLFxuXHRcIkFCT1VUXCI6IFwiTyBuw6FzXCIsXG5cdFwiQUJPVVRfMVwiOiBcImtkZSBrZG9rb2xpdiBtxa/FvmUgesOtc2thdCBvZG3Em251IHphIHN2xa9qIG9ic2FoIVwiLFxuXHRcIkFCT1VUXzJcIjogXCJqZSBwb3N0YXZlbiBuYSB7e3BsYXRmb3JtbmFtZX19IHBsYXRmb3JtxJsuIEFwbGlrYWNpIHZ5dHZvxZlpbFwiLFxuXHRcIkFCT1VUXzNcIjogXCJhIGplIHRvIGtvbXVuaXRuw60sIG9wZW4tc291cmNlIG1vYmlsbsOtIHByb2pla3QuIE5hYsOtesOtIHDFmcOtc3R1cCBrIG9ic2FodSBwcm8gxI10ZW7DrSwga29tZW50b3bDoW7DrSwgaGxhc292w6Fuw60sIHZ5c3Rhdm92w6Fuw60gcMWZw61zcMSbdmvFrywgcMWZZXZvZCB2w71kxJtsa8WvIGF0ZC4gcG9za3l0b3ZhbsOpIHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbmVtIGEge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBBcGxpa2FjZSBuZW3DoSBwxZnDrXN0dXAgayB1xb5pdmF0ZWxvdsO9bSBmb25kxa9tIGFuaSBqZSBuaWtkeSBuZXZsYXN0bsOtLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBcGxpa2FjZSBuYWLDrXrDrSBiZXpwZcSNbm9zdG7DrSBtb2RlbCBuYSBzdHJhbsSbIGtsaWVudGEuIFByaXbDoXRuw60ga2zDrcSNZSBqc291IGRyxb5lbnkgbG9rw6FsbsSbIGEgbmlrZHkgbmVqc291IHBvc8OtbMOhbnkgxb7DoWRuw71tIHNlcnZlcsWvbS5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gQXBsaWthY2UgbmFiw616w60gamVkbm9kdWNow6EsIGF0cmFrdGl2bsOtIHXFvml2YXRlbHNrw6Egcm96aHJhbsOtIGEgesOhxb5pdGt5LlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBBcGxpa2FjZSBwbyB1xb5pdmF0ZWzDrWNoIG5pa2R5IG5lcG/FvmFkdWplIMW+w6FkbsOpIG9zb2Juw60gaW5mb3JtYWNlLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJIbGFzdWp0ZSBwcm8gc3bEm2RrYSBnb29kLWthcm1hXCIsXG5cdFwiQUJPVVRfOVwiOiBcIktvbnRha3QvWnDEm3Ruw6EgdmF6YmE6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJWw61jZSBpbmZvcm1hY8OtOlwiLFxuXHRcIlJFTU9WRVwiOiBcIk9kc3RyYW5pdFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiWm9icmF6ZW7DrSB0cmh1XCIsXG5cdFwiUFJJQ0VcIjogXCJDZW5hXCIsXG5cdFwiQU1PVU5UXCI6IFwiU3VtYVwiLFxuXHRcIlRPVEFMXCI6IFwiQ2Vsa2VtXCIsXG5cdFwiTk9PUkRFUlNcIjogXCLFvcOhZG7DqSBvdGV2xZllbsOpIG9iamVkbsOhdmt5IHByb1wiLFxuXHRcIkRBVEVcIjogXCJEYXR1bVwiLFxuXHRcIkJVWVwiOiBcIk7DoWt1cFwiLFxuXHRcIlNFTExcIjogXCJQcm9kZWpcIixcblx0XCJPUEVOXCI6IFwiT3RldsWZZW5vXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcmllXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJTbGVkb3ZhdFwiLFxuXHRcIkZPTExPV0VEXCI6IFwiU2xlZG92w6FuXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJQxZllc3RhdCBzbGVkb3ZhdFwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIlNsZWRvdmFuw61cIixcblx0XCJGT0xMT1dFUlNcIjogXCJTbGVkdWrDrWPDrVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJIbGVkZWogc2xlZHVqw61jw61cIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiSGxlZGVqIHNsZWRvdmFuw6lcIixcblx0XCJCWVwiOiBcImvDvW1cIixcblx0XCJJTlwiOiBcInZcIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiWsOhbG/FvmthXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVibG9nXCIsXG5cdFwiVVBWT1RFXCI6IFwiSGxhc3VqdGUgcHJvXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJIbGFzdWp0ZSBwcm90aVwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJWcmHFpXRlIGhsYXMgcHJvdGlcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlZyYcWldGUgaGxhcyBwcm9cIixcblx0XCJSRVBMWVwiOiBcIk9kcG92xJt6dGVcIixcblx0XCJFRElUXCI6IFwiVXByYXZ0ZVwiLFxuXHRcIlBPU1RfMVwiOiBcIlBybyB6b2JyYXplbsOtIHZvbGViIHDFmWVqZcSPIHZsZXZvIG5hIGtvbWVudMOhxZllXCIsXG5cdFwiUE9TVF8yXCI6IFwiUHJvIHpvYnJhemVuw60gc3Via29tZW50w6HFmcWvIGtsZXBuxJt0ZSBuYSBrb21lbnTDocWZZVwiLFxuXHRcIk9QVElPTlNcIjogXCJWb2xieVwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlc3RlZW1vdsOhbm8ga8O9bVwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIlDFmWlwcmF2dWplIHNlXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJaxa9zdGF0a3lcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBvYmNob2RvdmF0ZWxuw6kgdG9rZW55LCBrdGVyw6kgbW9ob3UgYsO9dCBrZHlrb2xpdiBwxZlldmVkZW55LiB7e3BsYXRmb3JtbmFtZX19IG1vaG91IGLDvXQgcMWZZXZlZGVueSBuYSB7e3BsYXRmb3JtcG93ZXJ9fSB2IHByb2Nlc3UgenZhbsOpbSBwb3dlcmluZyB1cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgdmxpdm92w6kgdG9rZW55LCBrdGVyw6kgcG9zaWx1asOtIHDFmWkgZGxvdWhvZG9iw6ltIGRyxb5lbsOtIGEgaGxhc292w6Fuw60gbyBwxZnDrXNwxJt2Y8OtY2guIMSMw61tIHbDrWNlIGppY2ggbsSba2RvIGRyxb7DrSwgdMOtbSB2w61jZSBtxa/FvmUgb3ZsaXZuaXQgb2RtxJtueSBkcnVow71jaCBhIHPDoW0gesOtc2thdCBvZG3Em251IHphIHNwcsOhdm7DqSBobGFzb3bDoW7DrS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbnkgdiBjZW7EmyBva29sbyB7e3BsYXRmb3Jtc3VuaXR9fSB2IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiT8SNZWvDoXZhbsOhIGNlbmFcIixcblx0XCJQUk9GSUxFXzRcIjogXCJPxI1la8OhdmFuw6EgY2VuYSBqZSB6YWxvxb5lbmEgbmEgNyBkZW5uw60gcHLFr23Em3Juw6kgY2VuxJsge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiSGlzdG9yaWUgdHJhbnNha2PDrVwiLFxuXHRcIlBPU1RJTkdcIjogXCJPZGVzw61sw6Fuw61cIixcblx0XCJQUk9GSUxFXzVcIjogXCJPZGVzw61sYWPDrSBrbMOtxI0gamUgcG91xb7DrXbDoW4gcHJvIG9kZXPDrWzDoW7DrSBwxZnDrXNwxJt2a8WvIGEgaGxhc292w6Fuw60uIE3Em2wgYnkgYsO9dCByb3pkw61sbsO9IG9kIGFrdGl2bsOtaG8gYSB2bGFzdG5pY2vDqWhvIGtsw63EjWUuXCIsXG5cdFwiT1dORVJcIjogXCJWbGFzdG7DrWtcIixcblx0XCJQUk9GSUxFXzZcIjogXCJWbGFzdG5pY2vDvSBrbMOtxI0gamUgaGxhdm7DrSBrbMOtxI0gw7rEjXR1IGEgamUgcG/FvmFkb3bDoW4gcHJvIHptxJtudSBvc3RhdG7DrWNoIMO6xI10xa8uIFByaXbDoXRuw60ga2zDrcSNIG5lYm8gaGVzbG8gcHJvIHZsYXN0bmlja8O9IGtsw63EjSBieSBtxJtseSBiw710IGRyxb5lbnkgcG9rdWQgbW/Fvm5vIGNvIG5lanbDrWNlIG9mZmxpbmUuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0aXZuw61cIixcblx0XCJQUk9GSUxFXzdcIjogXCJBa3Rpdm7DrSBrbMOtxI0gc2UgcG91xb7DrXbDoSBwcm8gcMWZZXZvZHkgYSB6YWTDoW7DrSBvYmplZG7DoXZlayBuYSB2bml0xZluw61tIHRyaHUuXCIsXG5cdFwiTUVNT1wiOiBcIlBvem7DoW1rYVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIlBvem7DoW1rb3bDvSBrbMOtxI0gc2UgcG91xb7DrXbDoSBwcm8gdHZvcmJ1IGEgxI10ZW7DrSBwb3puw6FtZWsuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIlDFmcOtc3DEm3ZreVwiLFxuXHRcIlJFUExJRVNcIjogXCJPZHBvdsSbZGlcIixcblx0XCJXQUxMRVRcIjogXCJQZW7Em8W+ZW5rYVwiLFxuXHRcIlRBR1wiOiBcIsWgdMOtdGVrXCIsXG5cdFwiVVNFUlwiOiBcIlXFvml2YXRlbFwiLFxuXHRcIkNMT1NFXCI6IFwiWmF2xZnDrXRcIixcblx0XCJUT1wiOiBcImRvXCIsXG5cdFwiQVNTRVRcIjogXCJBa3RpdnVtXCIsXG5cdFwiU0VORFwiOiBcIlBvc2xhdFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiWmFiZXpwZcSNZW7DrVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRvc3R1cG7DvVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiVmXFmWVqbsOhIHBvem7DoW1rYVwiLFxuXHRcIlRPX0RFU0NcIjogXCJVxb5pdmF0ZWwgbmFwxZkuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbiBrw7NkXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU4ga8OzZCBwb23DoWjDoSB6YWJlenBlxI1pdCBhcGxpa2FjaSBhIGRhdGEuIDxici8+PGJyLz48Yj5Qb3puw6Fta2E6PC9iPiBKYWttaWxlIGplIGFrdGl2bsOtLCBtw6F0ZSBtYXhpbcOhbG7EmyA0IHBva3VzeSBuYSBvZGVtxI1lbsOtLiBQb2t1ZCBwaW4gemFwb21lbmV0ZSBuZWJvIG5ldXNwxJtqZXRlLCBhcGxpa2FjZSBvZHN0cmFuw60gdcW+aXZhdGVsc2vDoSBkYXRhIHRvaG90byBwxZlpaGzDocWhZW7DrS4gTcWvxb5ldGUgc2Ugb3DEm3QgcMWZaWhsw6FzaXQgYSBwb2tyYcSNb3ZhdCB2IHByw6FjaS5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiT3puw6FtZW7DrVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIlBva3VkIG7Em2tkbyBobGFzdWplIHBybyBWw6HFoSBwxZnDrXNwxJt2ZWssIG9iZHLFvsOtdGUgdXBvem9ybsSbbsOtISA8YnIvPiA8Yj5Qb3puw6Fta2E6PC9iPiBUYXRvIG96bsOhbWVuw60gb2JzYWh1asOtIHbDoWh1IGhsYXN1IChhxaUgdcW+IGplIHRvIGhsYXMgcHJvLCBwcm90aSwgbmVibyBvZHZvbMOhbsOtIGhsYXNvdsOhbsOtKS5cIixcblx0XCJWT1RFXCI6IFwiSGxhc3VqdGVcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJQb2t1ZCBuxJtrZG8ga29tZW50dWplIFbDocWhIHDFmcOtc3DEm3ZlayBuZWJvIGtvbWVudMOhxZksIG9iZHLFvsOtdGUgb3puw6FtZW7DrSEgPGJyLz4gPGI+UG96bsOhbWthOjwvYj4gVXBvem9ybsSbbsOtIGplIHphc2zDoW5vIHTDqcW+IHBva3VkIG7Em2tkbyA8Yj5lZGl0dWplPC9iPiBzdsWvaiBrb21lbnTDocWZLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJQb3puw6Fta2FcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIk9iZHLFvsOtdGUgdXBvem9ybsSbbsOtIGtkecW+IHbDoXMgbsSba2RvIHphxI1uZSBzbGVkb3ZhdCwgbmVibyBzbGVkb3bDoW7DrSB6cnXFocOtIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiWm3DrW5reVwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJQb2t1ZCB2w6FzIG7Em2tkbyB6bcOtbsOtIHYgcMWZw61zcMSbdmt1L2tvbWVudMOhxZlpLCBvYmRyxb7DrXRlIHVwb3pvcm7Em27DrSFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiUG9rdWQgbsSba2RvIHJlc3RlZW11amUgdsOhxaEgcMWZw61zcMSbdmVrLCBkb3N0YW5ldGUgb3puw6FtZW7DrSFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3VyYWNlXCIsXG5cdFwiVk9USU5HXCI6IFwiSGxhc292w6Fuw61cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIlbDoWhhIGhsYXN1IG5lYm8gcHJvY2VudG8gb3ZsaXbFiHVqZSBobGFzb3ZhY8OtIHPDrWx1IGFwbGlrYWNlLCB0YWvFvmUgbcWvxb5ldGUgcmVndWxvdmF0IHbDvcWhaSBvZG3Em255IHZhxaFlaG8gaGxhc292w6Fuw60uIDxici8+PGJyLz48Yj5Qb3puw6Fta2E6PC9iPiBUbyBvdmxpdm7DrSB2w6FodSBobGFzdS9wcm9jZW50byBpIHDFmWkgaGxhc292w6Fuw60gcHJvdGkgYSBqZSB0byBwbGF0bsOpIHYgY2Vsw6kgYXBsaWthY2kuXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJEb3BvcnXEjWVuw6lcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJVbG/Fvml0IHptxJtueVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiSW5mb3JtYWNlIG8gdm9sacSNaVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIlbDrXRlanRlIHpwxJt0IVwiLFxuXHRcIkxPR0lOXzFcIjogXCJQcm8gcG9rcmHEjW92w6Fuw60gc2UgcMWZaWhsYcWhdGUgc3bDvW0gdcW+aXZhdGVsc2vDvW0gam3DqW5lbSBhIGhlc2xlbS5cIixcblx0XCJMT0dJTl8yXCI6IFwiT2Rlc8OtbGFjw60ga2zDrcSNIGplIHVyxI1lbiBwcm8gdnlzdGF2b3ZhbsOtIHDFmcOtc3DEm3Zrxa8sIGtvbWVudMOhxZllLCBobGFzb3bDoW7DrSwgc2xlZG92w6Fuw60uXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFrdGl2bsOtIGtsw63EjSBqZSB1csSNZW4gcHJvIHDFmWV2b2R5IGEgYWt0dWFsaXphY2kgcHJvZmlsb3bDqWhvIG9icsOhemt1LlwiLFxuXHRcIkxPR0lOXzRcIjogXCJVxb5pdmF0ZWxvdnkgcMWZaWhsYcWhb3ZhY8OtIMO6ZGFqZSBqc291IGRyxb5lbnkgbG9rw6FsbsSbIHYgcMWZw61zdHJvamkuIFBvIG9kaGzDocWhZW7DrSBqc291IG9kc3RyYW7Em255IVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIk5lbcOhdGUgw7rEjWV0P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiWsWZacSPdGUgc2kgw7rEjWV0XCIsXG5cdFwiQ0FOQ0VMXCI6IFwiWnJ1xaFpdFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiUG9rcm/EjWlsw71cIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQWt0aXZuw60gc291a3JvbcO9IGtsw63EjVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiT2Rlc8OtbGFjw60gc291a3JvbcO9IGtsw63EjVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiSGxhdm7DrSBoZXNsb1wiLFxuXHRcIlVTRVJOQU1FXCI6IFwiVcW+aXZhdGVsc2vDqSBqbcOpbm9cIixcblx0XCJDQVJEX1ZJRVdcIjogXCJab2JyYXplbsOtIGthcnRhXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiWm9icmF6ZW7DrSBrb21wYWt0XCIsXG5cdFwiU0VBUkNIXCI6IFwiSGxlZGF0XCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJWbG/FviDEjWzDoW5la1wiLFxuXHRcIlJFUExZVE9cIjogXCJPZHBvdsSbenRlXCIsXG5cdFwiUE9TVFwiOiBcIk9kZXNsYXRcIixcblx0XCJQUkVWSUVXXCI6IFwiTsOhaGxlZFwiLFxuXHRcIkRFRkFVTFRcIjogXCJOYXN0YXZlbsOtIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCIxMDAlIFN0ZWVtIFBvd2VyXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJPZG3DrXRub3UgdsO9cGxhdHVcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlVzY2hvdmF0IG5hIHBvemTEm2ppXCIsXG5cdFwiQ0xFQVJcIjogXCJWecSNaXN0aXRcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJPZGVzbGF0IG9ic2FoXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiS29tZW50b3ZhdCBvYnNhaFwiLFxuXHRcIlRJVExFXCI6IFwiTmFkcGlzXCIsXG5cdFwiVEFHU1wiOiBcIsWgdMOtdGt5XCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTmVzaG9kdWplIHNlXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJQb3R2csSPdGUgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiTmVzcHLDoXZuw71cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLDunZvZG7DrSBwxZnDrXNwxJt2ZWtcIixcblx0XCJTRVRfUElOXCI6IFwiTmFzdGF2dGUgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiVmxvxb50ZSBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJVcsSNaXTEmz9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZyBqZSBuZXZyYXRuw70sIHDFmWVqZXRlIHNpIHBva3JhxI1vdmF0P1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkNoeWJhIG9kZXNsw6Fuw60sIHprdXN0ZSB6bm92dSFcIixcblx0XCJTVUNDRVNTXCI6IFwiw5pzcMSbY2hcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlJlYmxvZ292YW7DvSBwxZnDrXNwxJt2ZWshXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIlDFmWlobMOhxaFlbsOtIHNlbGhhbG8hIFVqaXN0xJt0ZSBzZSwgxb5lIGpzdGUgc2UgcMWZaWhsw6FzaWxpIGhsYXZuw61tIGhlc2xlbSwgbmVibyDFvmUganN0ZSBwxZlpIHDFmWlobMOhxaFlbsOtIHphZGFsaSBPZGVzw61sYWPDrSBrbMOtxI0sIHBva3VkIGpzdGUgenZvbGlsaSBQb2tyb8SNaWzDvSByZcW+aW0uXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiUMWZaWhsw6HFoWVuw60gc2VsaGFsbyEgVWppc3TEm3RlIHNlLCDFvmUganN0ZSBzZSBwxZlpaGzDoXNpbGkgaGxhdm7DrW0gaGVzbGVtLCBuZWJvIMW+ZSBqc3RlIHDFmWkgcMWZaWhsw6HFoWVuw60gemFkYWxpIEFrdGl2bsOtIGtsw63EjSwgcG9rdWQganN0ZSB6dm9saWxpIFBva3JvxI1pbMO9IHJlxb5pbS5cIixcblx0XCJXQVJOSU5HXCI6IFwiVsO9c3RyYWhhXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIkhsYXNvdsOhbsOtIG8gc3bEm2Rjw61jaFwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiSGxhc292YWwgcHJvIHN2xJtka2FcIixcblx0XCJBR09cIjogXCJwxZllZFwiLFxuXHRcIkZST01fTk9XXCI6IFwib2QgdGXEj1wiLFxuXHRcIlNFQ1NcIjogXCJ2dGXFmWlueVwiLFxuXHRcIkFfTUlOXCI6IFwibWludXRhXCIsXG5cdFwiTUlOU1wiOiBcIm1pbnV0eVwiLFxuXHRcIkFOX0hPVVJcIjogXCJob2RpbmFcIixcblx0XCJIT1VSU1wiOiBcImhvZGlueVwiLFxuXHRcIkFfREFZXCI6IFwiZGVuXCIsXG5cdFwiREFZU1wiOiBcImRueVwiLFxuXHRcIkFfTU9OVEhcIjogXCJtxJtzw61jXCIsXG5cdFwiTU9OVEhTXCI6IFwibcSbc8OtY2VcIixcblx0XCJBX1lFQVJcIjogXCJyb2tcIixcblx0XCJZRUFSU1wiOiBcInJva3lcIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbnV0IMSNdGVuw61cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiSGxhc3VqdGUgcHJvdGkgbmVibyBvem5hxI10ZSBqYWtvIHrDoXZhZG7DqVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIlphY2h5xaV0ZSBvYnLDoXpla1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiVnliZXJ0ZSBvYnLDoXpla1wiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiTmFzdGF2dGUgesOha2F6bmlja8OpIFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiVmxvxb50ZSBvYnLDoXpla1wiLFxuXHRcIkVSUk9SXCI6IFwiQ2h5YmFcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJOYWhyYWp0ZSBjaHlidVwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJGb3RvYXBhcsOhdCB6cnXFoWVuXCIsXG5cdFwiU0VUX1VSTFwiOiBcIk5hc3RhdnRlIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJQxZnDrW3DvSBvZGtheiBuYSBvYnLDoXpla1wiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiS29tZW50w6HFmSB2bG/FvmVuIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiTWF6w6Fuw60ga29tZW50w6HFmWUgamUgbmV2cmF0bsOpLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiT2RzdHJhbsSbbsO9IGtvbWVudMOhxZlcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIk5haHLDoXbDoW7DrSBvYnLDoXprdVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJOYWhyw6F2w6Fuw60gaG90b3ZvXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIk5haHLDoXbDoW7DrSBzZWxoYWxvXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiSGVzbG8gbmVibyBqbcOpbm8gw7rEjXR1IGJ5bG8gbmVzcHLDoXZuw6lcIixcblx0XCJJTkZPXCI6IFwiSW5mb3JtYWNlXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlFSIGvDs2QgdW3DrXN0xJt0ZSBkbyBvYmxhc3RpIHBybyBza2VuXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiVWppc3TEm3RlIHNlLCDFvmUgbcOhdGUgZG9zdGF0ZcSNbsO9IHrFr3N0YXRlayBwcm8gdHJhbnNha2NpIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJVxb5pdmF0ZWwsIGt0ZXLDqW11IHNlIHNuYcW+w610ZSBwxZlldsOpc3QgZm9uZHkgbmVleGlzdHVqZSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiSnN0ZSBzaSBqaXN0aSwgxb5lIHNpIHDFmWVqZXRlIHByb3bDqXN0IHDFmWV2b2Q/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiUG90dnJ6ZW7DrVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNha2NlIGplIG9kZXPDrWzDoW5hXCIsXG5cdFwiRkVFRFwiOiBcIlpkcm9qXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJWIHRyZW5kdVwiLFxuXHRcIkhPVFwiOiBcIsW9aGF2w6lcIixcblx0XCJORVdcIjogXCJOb3bDqVwiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvcGFnb3ZhbsOpXCIsXG5cdFwiVk9URVNcIjogXCJIbGFzeVwiLFxuXHRcIlBBWU9VVFwiOiBcIlbDvXBsYXRhXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJLb21lbnTDocWZZVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiViB0cmVuZHUgcG8gMzAgZG7DrVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlJvenTFmcOtZGl0IHDFmcOtc3DEm3ZreSBkbGVcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDeWtsdXMgdsO9cGxhdHlcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW5jacOhbG7DrSB2w71wbGF0YVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiTWludWzDoSB2w71wbGF0YVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJBdXRvcnNrw6Egb2RtxJtuYVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkt1csOhdG9yc2vDoSBvZG3Em25hXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLEjGzDoW5layBqZSBvZGVzbMOhbiFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiVXNjaG92YXQgcHJvIHBvemTEm2rFocOtIG9kZXNsw6Fuw60hXCIsXG5cdFwiU0FWRURcIjogXCJVbG/FvmVuw71cIixcblx0XCJDTEVBUkVEXCI6IFwiVnnEjWnFoXTEm25vXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIk96bmHEjWVuw60gcMWZw61zcMSbdmt1IHphIHrDoXZhZG7DvSBtxa/FvmUgb2RlYnJhdCBvZG3Em255IGEgdcSNaW5pdCB0ZW50byBtYXRlcmnDoWwgbcOpbsSbIHZpZGl0ZWxuw71tLjxicj48YnI+VG90byBvem5hxI1lbsOtIGJ5IG3Em2xvIGLDvXQgcG91xb5pdG8gbmEgbsOhc2xlZHVqw61jw606IDx1bD48bGk+cG9kdm9kIG5lYm8gcGxhZ2nDoXRvcnN0dsOtPC9saT48bGk+cHJvamV2eSBuZW7DoXZpc3RpIG5lYm8gaW50ZXJuZXRvdsOpIHRyb2xvdsOhbsOtPC9saT48bGk+esOhbcSbcm7EmyBjaHlibsOhIGthdGVnb3JpemFjZSBvYnNhaHUgbmVibyBzcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWl0IHBvxb5hZGF2a8WvIGRvc2HFvmVuLiBaa29udHJvbHVqdGUgb3N0YXRuw60gdHJlbmR5L8WhdMOtdGt5IVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIlDFmcOtc3DEm3ZlayBqZSBvZHN0cmFuxJtuIHplIHrDoWxvxb5layFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiUMWZw61zcMSbdmVrIGplIHDFmWlkw6FuIGRvIHrDoWxvxb5layFcIixcblx0XCJSRVNFVFwiOiBcIlJlc2V0b3ZhdFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiVXByYXZpdCBwcm9maWxvdsO9IG9icsOhemVrXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJVcHJhdml0IHRpdHVsbsOtIG9icsOhemVrXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiWmFkZWp0ZSBBa3Rpdm7DrSBzb3Vrcm9tw70ga2zDrcSNLCBwb2t1ZCBqc3RlIHZ5YnJhbGkgcG9rcm/EjWlsw70gbcOzZCBwxZnDrXN0dXB1IVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIlTDrW10byByZXNldHVqZXRlIHByb2ZpbG92w70gb2Jyw6F6ZWsgdcW+aXZhdGVsZSFcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJUw61tdG8gcmVzZXR1amV0ZSB0aXR1bG7DrSBvYnLDoXplayB1xb5pdmF0ZWxlIVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiQWt0dWFsaXphY2Ugc2VydmVydSB2ecW+YWR1amUgcmVzdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiTmFzdGF2ZW7DrSBqc291IGFrdHVhbGl6b3bDoW5hLlwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkphenlreVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiWmRlIG3Fr8W+ZXRlIHptxJtuaXQgamF6eWsgYXBsaWthY2UuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIlRhdG8gb3BlcmFjZSB2ecW+YWR1amUgcMWZaWhsw6HFoWVuw60gdcW+aXZhdGVsZSBobGF2bsOtbSBoZXNsZW0sIEFrdGl2bsOtbS9PZGVzw61sYWPDrW0ga2zDrcSNZW0uIFByb3PDrW0gcMWZaWhsYcWhdGUgc2UgYSBvcGFrdWp0ZSBwb2t1cy5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXJpZVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlDFmWVsb8W+aWxpXCIsXG5cdFwiU0hBUkVcIjogXCJBa2NpZVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiVHJoXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJCdXJ6YVwiLFxuXHRcIkRSQUZUU1wiOiBcIktvbmNlcHR5XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiUMWZw61zcMSbdmVrIGplIHoga29uY2VwdMWvIG9kc3RyYW7Em24gIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQxZnDrXNwxJt2ZWsgamUgcMWZaWTDoW4gZG8ga29uY2VwdMWvIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJQcm8gem9icmF6ZW7DrSBtb8W+bm9zdMOtIHDFmWVqZcSPIHZsZXZvXCIsXG5cdFwiTUFOQUdFXCI6IFwiU3ByYXZvdmF0XCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIk9icmF6IGplIG9kc3RyYW7Em25cIixcblx0XCJDT1BZXCI6IFwiS29ww61yb3ZhdFwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiRG9zdWQganN0ZSBuZW5haHLDoWwgxb7DoWRuw70gb2JyYXouXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJQcm8gb2Jub3ZlbsOtIHphdMOhaG5pIGRvbMWvXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkV4dGVybsOtIGFwbGlrYWNlXCIsXG5cdFwiUExVR0lOU1wiOiBcIlDFmcOtZGF2bsOpIG1vZHVseVwiLFxuXHRcIlNVR0dFU1RcIjogXCJOw6F2cmhcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkppxb4gYnJ6eSBjaHlzdMOhbWVcIixcblx0XCJDSEFJTlwiOiBcIkNoYWluXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIlpkZSBtxa/FvmV0ZSB6bcSbbml0IGJsb2NrY2hhaW4gbmVibyB2w71jaG96w60gcGxhdGZvcm11LlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwiTcSbbmFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiWmRlIG3Fr8W+ZXRlIHptxJtuaXQgc3ZvamkgdsO9Y2hvesOtIG3Em251LiBWIHTDqXRvIG3Em27EmyBzZSBwb3TDqSBidWRvdSB6b2JyYXpvdmF0IG9kbcSbbnkgemEgcMWZw61zcMSbdmt5L2tvbWVudMOhxZllLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPlNlem5hbSBmdW5rY8OtPC9iPiA8YnI+LVDFmcOtc3R1cCBrIGplZGluZcSNbsO9bSDEjWzDoW5rxa9tIHYga2HFvmTDqW0gdMOpbWF0dSwga3RlcsO9IGpzb3UgemFqw61tYXbDqSBrZSDEjXRlbsOtPGJyPkFuZ2HFvm92w6Fuw60gc2UgcyBhdXRvcnkga29tZW50b3bDoW7DrW0gYSBkaXNrdXRvdsOhbsOtbSB0w6ltYXQuPGJyPkhsYXNvdsOhbsOtbSBwxZnDrXNwxJt2a8WvIG9kbcSbxYhvdmF0IGF1dG9yeSBzdGVqbsSbIHRhayBqYWtvIHrDrXNrw6F2YXQga3Vyw6F0b3Jza8OpIG9kbcSbbnkuIDxicj5QdWJsaWtvdmF0IMSNbMOhbmt5LCBwxZnDrXNwxJt2a3kgZG8gYmxvZ3UgYSBob3N0b3ZhdCBqZSB6ZGFybWEsIGRvc3TDoXZhdCBvZG3Em255IHphIHB1Ymxpa292w6Fuw60gYSB6w61za8OhdmF0IHN0b3VwZW5jZS4gPGJyPlBzw6F0IMSNbMOhbmt5IGtkZWtvbGl2IGEga2R5a29saXYgYSBtw610IG1vxb5ub3N0IHVsb8W+aXQgamVqaWNoIGtvbmNlcHR5IHBybyBwb3pkxJtqxaHDrSBwdWJsaWthY2kuIDxicj5VbG/Fvml0IHNpIG9ibMOtYmVuw6kgxI1sw6Fua3kgZG8gesOhbG/FvmVrIHBybyBwb3pkxJtqxaHDrSBwxZllxI10ZW7DrS4gPGJyPlbDvW3Em25hIG5lYm8gcHJvcGxhY2Vuw60gdmHFoWVobyB2w71kxJtsa3UuIDxicj5Nb8W+bm9zdCBwb3NsYXQgdmHFoWUgcHJvc3TFmWVka3kgamFrw6ltdWtvbGl2IGF1dG9yb3ZpLCB1xb5pdmF0ZWxvdmksIHDFmcOtdGVsaSwgc3RvdXBlbmPFr20gYXRkLjxicj5Ow6FzbGVkb3ZhdCB6YWrDrW1hdsOpIGF1dG9yeSwgYmxvZ2dlcnkuIDxicj5Qcm9obMOtxb5ldCBzaSBwxZnDrXNwxJt2a3kgc3RvdXBlbmPFryBhIGF1dG9yxa8sIGt0ZXLDqSBzbGVkdWpldGUuIDxicj5Eb3N0w6F2YXQgb3puw6FtZW7DrSwgYWJ5c3RlIHrFr3N0YWxpIHYga29udGFrdHUgc2Ugc3bDvW1pIHN0b3VwZW5jaSBhIGRpc2t1emVtaSwgdmUga3RlcsO9Y2gganN0ZSB6YXBvamVuPGJyPlByb2hsZWTDoXZhdCB6YWrDrW1hdsOpIHRhZ3kva2F0ZWdvcmllIMSNbMOhbmvFryBhIHphasOtbWF2w6kgYXV0b3J5LiA8YnI+UMWZaXpwxa9zb2J0ZSBzaSBzdsWvaiBwcm9maWwuIDxicj5BIG1ub2hlbSB2w61jZSBmdW5rY8OtLCBrdGVyw6kgcMWZaWpkb3UgPGJyPjxicj48Yj5CZXpwZcSNbm9zdDwvYj4gPGJyPjEuIEFwbGlrYWNlIG5lbcOhIHDFmcOtc3R1cCBhbmkgbmVkcsW+w60gcGVuxJvFvm7DrSBwcm9zdMWZZWRreSB1xb5pdmF0ZWzFry4gPGJyPjIuIEFwbGlrYWNlIG5hYsOtesOtIG1vZGVsIHphYmV6cGXEjWVuw60gbmEgc3RyYW7EmyBrbGllbnRhIHNlIHNvdWtyb23DvW1pIGtsw63EjWkgdW3DrXN0xJtuw6kgbG9rw6FsbsSbIGEgbmlrZHkgamUgbmVvZGVzw61sw6EgbmEgc2VydmVyLCBqc3RlIHNhbWkgem9kcG92xJtkbsOtIHphIHrDoWxvaG92w6Fuw60gVmHFoWljaCBoZXNlbC4gPGJyPjMuIEFwbGlrYWNlIG5hYsOtesOtIGplZG5vZHVjaMOpLCBhdHJha3Rpdm7DrSB1xb5pdmF0ZWxza8OpIHJvemhyYW7DrS4gPGJyPjQuIEFwbGlrYWNlIG5hYsOtesOtIGRhbMWhw60gdnJzdHZ1IHphYmV6cGXEjWVuw60gcG9tb2PDrSBwaW4ta8OzZHUgPGJyPjxicj5lU3RlZW0gcG9kcG9ydWplIHBsYXRmb3JteSBTdGVlbSBhIEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIlpha2xhZGF0ZWwgYSBobGF2bsOtIHbDvXZvasOhxZlcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIlDFmWlkYXQgw7rEjWV0XCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0Zm9ybWFcIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3cgenByb3N0xZllZGtvdmF0ZWxcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJLb25lxI1uw70gdGVybcOtbiByYXRpZmlrYWNlXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgZXhwaXJhY2VcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiRXNjcm93IHBvcGxhdGVrXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IHBvZG3DrW5reVwiLFxuXHRcIk5JR0hUX01PREVcIjogXCJOb8SNbsOtIHJlxb5pbVwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiRGVubsOtIHJlxb5pbVwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIlpvYnJheml0IHBsbsO9IGtvbnRleHRcIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiVcW+aXZhdGVsIG5lbmFsZXplblwiLFxuXHRcIkFQUFJPVkVcIjogXCJTY2h2w6FsaXRcIixcblx0XCJESVNQVVRFXCI6IFwiT2Rwb3JvdmF0XCIsXG5cdFwiUkVMRUFTRVwiOiBcIlZ5ZGF0XCIsXG5cdFwiRlJPTVwiOiBcIk9kXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIk9kZXNsYXRcIixcblx0XCJSRUNFSVZFUlwiOiBcIlDFmcOtamVtY2VcIixcblx0XCJMT0NBVElPTlwiOiBcIlVtw61zdMSbbsOtXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYlwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIlpvYnJhem92YW7DqSBqbcOpbm9cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiU3RhcnRzZWl0ZVwiLFxuXHRcIkxPR0lOXCI6IFwiQW5tZWxkZW5cIixcblx0XCJMT0dPVVRcIjogXCJBYm1lbGRlblwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJGb2xnZW5cIixcblx0XCJCT09LTUFSS1NcIjogXCJMZXNlemVpY2hlblwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiw5xiZXJ0cmFnZW5cIixcblx0XCJNQVJLRVRcIjogXCJNYXJrdFwiLFxuXHRcIlNFVFRJTkdTXCI6IFwiRWluc3RlbGx1bmdlblwiLFxuXHRcIkFCT1VUXCI6IFwiSW5mb1wiLFxuXHRcIkFCT1VUXzFcIjogXCJkaWUgUGxhdHRmb3JtLCBiZWkgZGVyIGplZGVyIGbDvHIgc2VpbmUgSW5oYWx0ZSB2ZXJnw7x0ZXQgd2lyZCFcIixcblx0XCJBQk9VVF8yXCI6IFwid2lyZCB1bnRlcnN0w7x0enQgZHVyY2ggZGllIHt7cGxhdGZvcm1uYW1lfX0gUGxhdHRmb3JtLiBBbndlbmR1bmcgZXJzdGVsbHQgdm9uXCIsXG5cdFwiQUJPVVRfM1wiOiBcInVuZCBpc3QgZWluZSBtb2JpbGUgT3BlbiBTb3VyY2UgQW53ZW5kdW5nLCBkaWUgZHVyY2ggZGllIENvbW11bml0eSB1bnRlcnN0w7x0enQgd2lyZC4gRGllIEFud2VuZHVuZyBlcmxhdWJ0IGRlbiBadWdyaWZmIGF1ZiBkaWUgSW5oYWx0ZSBmw7xyIGRhcyBMZXNlbiwgS29tbWVudGllcmVuLCBBYnN0aW1tZW4sIFBvc3Rlbiwgw5xiZXJ0cmFnZW4gdm9uIEVpbmvDvG5mdGVuIGV0Yy4gRGllIEZ1bmt0aW9uZW4gd2VyZGVuIGR1cmNoIGRpZSB7e3BsYXRmb3JtbmFtZX19IEJsb2NrY2hhaW4gdW5kIHt7c2l0ZW5hbWV9fSBiZXJlaXRnZXN0ZWxsdC5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gRGllIEFud2VuZHVuZyBncmVpZnQgbmllbWFscyBhdWYgSWhyZSBNaXR0ZWwgenUuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIERpZSBBbndlbmR1bmcgbnV0enQgZWluIENsaWVudC1iYXNpZXJ0ZXMgU2ljaGVyaGVpdHNrb256ZXB0LCBkYXNzIGF1ZiBTY2hsw7xzc2VsbiBiYXNpZXJ0LCBkaWUgbG9rYWwgdm9yaGFuZGVuIHNpbmQgdW5kIG5pZW1hbHMgYW4gZWluZW4gU2VydmVyIMO8YmVydHJhZ2VuIHdlcmRlbi5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gRGllIEFud2VuZHVuZyBiaWV0ZXQgZWluIHNpbXBsZXMsIGF0dHJha3RpdmVzIEludGVyZmFjZS5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gRGllIEFud2VuZHVuZyBmcmFndCBuaWVtYWxzIG5hY2ggcGVyc8O2bmxpY2hlbiBEYXRlbi5cIixcblx0XCJBQk9VVF84XCI6IFwiR29vZC1LYXJtYSBhbHMgWmV1Z2UgYWJzdGltbWVuXCIsXG5cdFwiQUJPVVRfOVwiOiBcIktvbnRha3QvRmVlZGJhY2s6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJXZWl0ZXJlIEluZm9ybWF0aW9uZW46XCIsXG5cdFwiUkVNT1ZFXCI6IFwiRW50ZmVybmVuXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJNYXJrdGFuc2ljaHRcIixcblx0XCJQUklDRVwiOiBcIlByZWlzXCIsXG5cdFwiQU1PVU5UXCI6IFwiTWVuZ2VcIixcblx0XCJUT1RBTFwiOiBcIkdlc2FtdFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiS2VpbmUgb2ZmZW5lbiBPcmRlclwiLFxuXHRcIkRBVEVcIjogXCJEYXR1bVwiLFxuXHRcIkJVWVwiOiBcIkthdWZlblwiLFxuXHRcIlNFTExcIjogXCJWZXJrYXVmZW5cIixcblx0XCJPUEVOXCI6IFwiT2ZmZW5cIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaWVcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIkViZW5mYWxscyBmb2xnZW5cIixcblx0XCJGT0xMT1dFRFwiOiBcIlNpZSBmb2xnZW4gbnVuIGRpZXNlbSBOdXR6ZXJcIixcblx0XCJVTkZPTExPV1wiOiBcIk5pY2h0IG1laHIgZm9sZ2VuXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiU2llIGZvbGdlbiBkaWVzZW0gTnV0emVyXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiUGVyc29uZW4sIGRpZSBJaG5lbiBmb2xnZW5cIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiRHVyY2hzdWNoZW4gZGVyIE51dHplciwgZGllIElobmVuIGZvbGdlblwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJEdXJjaHN1Y2hlbiBkZXIgTnV0emVyLCBkZW5lbiBTaWUgZm9sZ2VuXCIsXG5cdFwiQllcIjogXCJ2b25cIixcblx0XCJJTlwiOiBcImluXCIsXG5cdFwiTUVOVVwiOiBcIk1lbsO8XCIsXG5cdFwiQk9PS01BUktcIjogXCJMZXNlemVpY2hlblwiLFxuXHRcIlJFQkxPR1wiOiBcIlJlYmxvZ1wiLFxuXHRcIlVQVk9URVwiOiBcIlVwdm90ZVwiLFxuXHRcIkRPV05WT1RFXCI6IFwiRG93bnZvdGVcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiRG93bnZvdGUgZW50ZmVybmVuXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJVcHZvdGUgZW50ZmVybmVuXCIsXG5cdFwiUkVQTFlcIjogXCJBbnR3b3J0ZW5cIixcblx0XCJFRElUXCI6IFwiRWRpdGllcmVuXCIsXG5cdFwiUE9TVF8xXCI6IFwiTmFjaCBsaW5rcyB3aXNjaGVuIHVtIEtvbW1lbnRhcmUgenUgc2VoZW5cIixcblx0XCJQT1NUXzJcIjogXCJBdWYgS29tbWVudGFyZSB0aXBwZW4gdW0gZGVzc2VuIEFudHdvcnRlbiB6dSBzZWhlblwiLFxuXHRcIk9QVElPTlNcIjogXCJPcHRpb25lblwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlc3RlZW1lZCB2b25cIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJIaWVyIGdpYnQgZXMgbm9jaCBuaWNodHMgenUgc2VoZW4uLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIktvbnRvc3RhbmRcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBoYW5kZWxiYXJlIFRva2VucyBkaWUgenUgamVkZXIgWmVpdCDDvGJlcnRyYWdlbiB3ZXJkZW4ga8O2bm5lbi4ge3twbGF0Zm9ybW5hbWV9fSBrYW5uIGluIHt7cGxhdGZvcm1wb3dlcn19IGtvbnZlcnRpZXJ0IHdlcmRlbi4gRGllc2VyIFByb3plc3MgaGVpw590IFxcXCJwb3dlcmluZyB1cFxcXCIuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIHRva2VucyBkaWUgc2ljaCBhdXRvbWF0aXNjaCB2ZXJtZWhyZW4sIHdlbm4gU2llIGJlc2Vzc2VuIHdlcmRlbiB1bmQgYmVlaW5mbHVzc2VuLCB3aWUgdmllbCBJaHJlIFN0aW1tZSB3ZXJ0IGlzdC4gRGVzdG8gbWVociBTaWUgYmVzaXR6ZW4sIGRlc3RvIG1laHIgRWluZmx1c3MgaGF0IElocmUgU3RpbW1lLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VucyBtaXQgZWluZW0gV2VydCB2b24gZXR3YSB7e3BsYXRmb3Jtc3VuaXR9fSBpbiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkdlc2Now6R0enRlciBXZXJ0XCIsXG5cdFwiUFJPRklMRV80XCI6IFwiRGVyIGdlc2Now6R0enRlIFdlcnQgYmFzaWVydCBhdWYgZWluZW0gNy1UYWdlLUR1cmNoc2Nobml0dHN3ZXJ0IHZvbiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJUcmFuc2FrdGlvbnMgSGlzdG9yaWVcIixcblx0XCJQT1NUSU5HXCI6IFwiQmVpdHJhZ1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkRlciBcXFwicG9zdGluZyBrZXlcXFwiIHdpcmQgZsO8ciBkYXMgVmVyw7ZmZmVudGxpY2hlbiB1bmQgQWJzdGltbWVuIGJlbsO2dGlndC4gRXIgc29sbHRlIHNpY2ggdm9tIFxcXCJhY3RpdmUga2V5XFxcIiB1bmQgdm9tIFxcXCJvd25lciBrZXlcXFwiIHVudGVyc2NoZWlkZW4uXCIsXG5cdFwiT1dORVJcIjogXCJCZXNpdHplclwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkRlciBcXFwib3duZXIga2V5XFxcIiBpc3QgZGVyIEhhdXB0c2NobMO8c3NlbCBmw7xyIGRlbiBBY2NvdW50IHVuZCB3aXJkIGJlbsO2dGlndCwgdW0gYW5kZXJlIFNjaGzDvHNzZWwgenUgw6RuZGVybi4gRGVyIFxcXCJwcml2YXRlIGtleVxcXCIgb2RlciBkYXMgUGFzc3dvcnQgc29sbHRlbiBudXIgb2ZmbGluZSB2ZXJmw7xnYmFyIHNlaW4uXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWt0aXZcIixcblx0XCJQUk9GSUxFXzdcIjogXCJEZXIgXFxcImFjdGl2ZSBrZXlcXFwiIHdpcmQgYmVudXR6dCwgdW0gw5xiZXJ0cmFndW5nZW4gZHVyY2h6dWbDvGhyZW4gb2RlciBHZWJvdGUgYXVmIGRlbSBNYXJrdCB6dSBwbGF0emllcmVuLlwiLFxuXHRcIk1FTU9cIjogXCJOb3RpelwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkRlciBcXFwibWVtbyBrZXlcXFwiIHdpcmQgYmVuw7Z0aWd0LCB1bSBNZW1vcyB6dSBsZXNlbiB1bmQgenUgc3BlaWNoZXJuLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJCZWl0csOkZ2VcIixcblx0XCJSRVBMSUVTXCI6IFwiQW50d29ydGVuXCIsXG5cdFwiV0FMTEVUXCI6IFwiQnJpZWZ0YXNjaGVcIixcblx0XCJUQUdcIjogXCJUYWdcIixcblx0XCJVU0VSXCI6IFwiQmVudXR6ZXJcIixcblx0XCJDTE9TRVwiOiBcIlNjaGxpZcOfZW5cIixcblx0XCJUT1wiOiBcIkVtcGbDpG5nZXJcIixcblx0XCJBU1NFVFwiOiBcIlp1c2F0elwiLFxuXHRcIlNFTkRcIjogXCJTZW5kZW5cIixcblx0XCJTRUNVUklUWVwiOiBcIlNpY2hlcmhlaXRcIixcblx0XCJBVkFJTEFCTEVcIjogXCJWZXJmw7xnYmFyXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLDlmZmZW50bGljaGUgTm90aXpcIixcblx0XCJUT19ERVNDXCI6IFwiQmVudXR6ZXIgei5CLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJQaW5cIixcblx0XCJQSU5fVEVYVFwiOiBcIkRlciBQSU4gZGllbnQgZGVyIFNpY2hlcmhlaXQgZGVyIEFud2VuZHVuZywgc293aWUgZGVyZW4gRGF0ZW4uIDxici8+PGJyLz48Yj5IaW53ZWlzOjwvYj4gTmFjaCBBa3RpdmllcnVuZyBzdGVoZW4gbWF4aW1hbCA0IEFubWVsZGV2ZXJzdWNoZSB6dXIgVmVyZsO8Z3VuZy4gRGFuYWNoIHdlcmRlbiBkaWUgRGF0ZW4gZGVzIGFrdHVlbGwgYW5nZW1lbGRldGVuIE51dHplcnMgZ2Vsw7ZzY2h0IHVuZCBkaWUgQW53ZW5kdW5nIGthbm4gd2llZGVyIG5vcm1hbCBnZW51dHp0IHdlcmRlbi5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiQmVuYWNocmljaHRpZ3VuZ2VuXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiU2llIHdlcmRlbiBpbmZvcm1pZXJ0LCBzb2JhbGQgamVtYW5kIGbDvHIgSWhyZSBCZWl0csOkZ2UgYWJnZXN0aW1tdCBoYXQhIDxici8+IDxiPkhpbndlaXM6PC9iPiBEaWUgTm90aWZpa2F0aW9uIGdpYnQgYXVmc2NobHVzcyDDvGJlciBkaWUgQXJ0IGRlciBBYnN0aW1tdW5nIChQb3NpdGl2LCBOZWdhdGl2LCB3aWVkZXIgZW50ZmVybnQpIHVuZCBkaWUgR2V3aWNodHVuZyBkZXIgU3RpbW1lLlwiLFxuXHRcIlZPVEVcIjogXCJBYnN0aW1tZW5cIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJTaWUgd2VyZGVuIGluZm9ybWllcnQsIHNvYmFsZCBqZW1hbmQgYXVmIElocmUgQmVpdHLDpGdlIG9kZXIgS29tbWVudGFyZSBhbnR3b3J0ZXQhPGJyLz4gPGI+SGlud2Vpczo8L2I+IFNpZSB3ZXJkZW4gYXVjaCBiZWltIMOEbmRlcm4gZWluZXMgQmVpdHJhZ3MvS29tbWVudGFycyBlcm5ldXQgaW5mb3JtaWVydC5cIixcblx0XCJDT01NRU5UXCI6IFwiS29tbWVudGFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJTaWUgd2VyZGVuIGJlbmFjaHJpY2h0aWd0LCBzb2JhbGQgSWhuZW4gamVtYW5kIGZvbGd0IG9kZXIgbmljaHQgbWVociBmb2xndCFcIixcblx0XCJNRU5USU9OU1wiOiBcIkVyd8OkaG51bmdlblwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJTaWUgd2VyZGVuIGJlbmFjaHJpY2h0aWd0LCBzb2JhbGQgU2llIHZvbiBqZW1hbmRlbiBpbiBLb21tZW50YXJlbiBvZGVyIEJlaXRyYWdlbiBlcnfDpGhudCB3ZXJkZW4hXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlJlYmxvZ1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIlNpZSB3ZXJkZW4gYmVuYWNocmljaHRpZ3Qgc29iYWxkIGplbWFuZCBJaHJlbiBQb3N0IGVybmV1dCB2ZXLDtmZmZW50bGljaHQgaGF0IVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwiRWluc3RlbGx1bmdlblwiLFxuXHRcIlZPVElOR1wiOiBcIkFic3RpbW11bmdcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIkRhcyBHZXdpY2h0IC8gZGVyIHByb3plbnR1YWxlIEFudGVpbCBkZXIgU3RpbW1lIGJlZWluZmx1c3N0IGRpZSBNZW5nZSBkZXIgVmVyZ8O8dHVuZyBmw7xyIGRlbiBBdXRvci4gPGJyLz48YnIvPjxiPkhpbndlaXM6PC9iPiBEaWVzZSBFaW5zdGVsbHVuZyDDpG5kZXJ0IGF1Y2ggZGllIEdld2ljaHR1bmcvIGRlbiBwcm96ZW50dWFsZW4gQW50ZWlsIGbDvHIgbmVnYXRpdmUgU3RpbW1lbi4gRGllc2UgRWluc3RlbGx1bmcgd2lyZCBpbiBkZXIgZ2VzYW10ZW4gQW53ZW5kdW5nIHZlcndlbmRldC5cIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIkVtcGZvaGxlblwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIsOEbmRlcnVuZ2VuIHNwZWljaGVyblwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiQWJzdGltbXVuZ3NpbmZvcm1hdGlvbmVuXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiV2lsbGtvbW1lbiB6dXLDvGNrIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJNZWxkZW4gU2llIHNpY2ggbWl0IElocmVtIEJlbnV0emVybmFtZW4gdW5kIFBhc3N3b3J0IGFuLCB1bSBmb3J0enVmYWhyZW4uXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkRlciBcXFwiUG9zdGluZyBrZXlcXFwiIHdpcmQgZsO8ciBkYXMgVmVyw7ZmZmVudGxpY2hlbiB2b24gQmVpdHJhZ2VuLCBLb21tZW50YXJlbiB1bmQgQWJzdGltbXVuZ2VuLCBzb3dpZSBkZW0gRm9sZ2VuIHZvbiBOdXR6ZXJuIGJlbsO2dGlndC5cIixcblx0XCJMT0dJTl8zXCI6IFwiRGVyIFxcXCJBY3RpdmUga2V5XFxcIiB3aXJkIGbDvHIgZGllIMOcYmVydHJhZ3VuZyB1bmQgZGFzIGFrdHVhbGlzaWVyZW4gZGVzIFByb2ZpbGJpbGRzIGJlbsO2dGlndC5cIixcblx0XCJMT0dJTl80XCI6IFwiWnVnYW5nc2RhdGVuIHdlcmRlbiBsb2NhbCBpbSBHZXLDpHQgZ2VzcGVpY2hlcnQgdW5kIG5hY2ggZGVtIExvZ291dCBnZWzDtnNjaHQhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTm9jaCBrZWluZW4gQWNjb3VudD9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIkpldHp0IHJlZ2lzdHJpZXJlblwiLFxuXHRcIkNBTkNFTFwiOiBcIkFiYnJlY2hlblwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiRXJ3ZWl0ZXJ0XCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkFrdGl2ZXIgcHJpdmF0ZXIgWnVnYW5nc3NjaGzDvHNzZWxcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIlByaXZhdGVyIFp1Z2FuZ3NzY2hsw7xzc2VsIGbDvHIgZGFzIFZlcsO2ZmZlbnRsaWNoZW4gdm9uIEluaGFsdGVuXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJNYXN0ZXItIC9IYXVwdC1QYXNzd29ydFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiQmVudXR6ZXJuYW1lXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiS2FydGVuLUFuc2ljaHRcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJLb21wYWt0YW5zaWNodFwiLFxuXHRcIlNFQVJDSFwiOiBcIlN1Y2hlblwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiQmVpdHJhZyBlcnN0ZWxsZW5cIixcblx0XCJSRVBMWVRPXCI6IFwiQW50d29ydGVuXCIsXG5cdFwiUE9TVFwiOiBcIlZlcsO2ZmZlbnRsaWNoZW5cIixcblx0XCJQUkVWSUVXXCI6IFwiVm9yc2NoYXVcIixcblx0XCJERUZBVUxUXCI6IFwiU3RhbmRhcmQgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIGVyaMO2aGVuIG1pdCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJBdWYgZGllIEF1c3phaGx1bmcgdmVyemljaHRlblwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiRsO8ciBlaW5lbiBzcMOkdGVyZW4gWmVpdHB1bmt0IHNwZWljaGVyblwiLFxuXHRcIkNMRUFSXCI6IFwiTMOWU0NIRU5cIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJJbmhhbHQgdmVyw7ZmZmVudGxpY2hlblwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIkluaGFsdCBrb21tZW50aWVyZW5cIixcblx0XCJUSVRMRVwiOiBcIlRpdGVsXCIsXG5cdFwiVEFHU1wiOiBcIlRhZ3NcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJLRUlORSDDnEJFUkVJTlNUSU1NVU5HXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJQSU4gYmVzdMOkdGlnZW5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJGQUxTQ0hcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLDtmZmbmUgQmVpdHJhZ1wiLFxuXHRcIlNFVF9QSU5cIjogXCJTZXR6ZW4gU2llIElocmVuIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkJpdHRlIGdlYmVuIFNpZSBJaHJlbiBQSU4gZWluXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiU2luZCBTaWUgc2ljaGVyP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiRGFzIG5ldSB2ZXLDtmZmZW50bGljaGVuIGthbm4gbmljaHQgcsO8Y2tnw6RuZ2lnIGdlbWFjaHQgd2VyZGVuLCB3b2xsZW4gU2llIHdlaXRlciBtYWNoZW4/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiRmVobGVyIGJlaW0gdmVyw7ZmZmVudGxpY2hlbiwgYml0dGUgdmVyc3VjaGVuIFNpZSBlcyBlcm5ldXQhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIkVyZm9sZ3JlaWNoXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJOZXUgdmVyw7ZmZmVudGxpY2h0IVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJBbm1lbGR1bmcgZmVobGdlc2NobGFnZW4hIEJpdHRlIHN0ZWxsZW4gU2llIHNpY2ggc2ljaGVyLCBkYXNzIFNpZSBkYXMgTWFzdGVyLVBhc3N3b3J0IG9kZXIsIGbDvHIgZGVuIGVyd2VpdGVydGVuIEFubWVsZGUtTW9kdXMsIGRlbiBiZXJlaXRnZXN0ZWxsdGVuIFxcXCJBY3RpdmUgcHJpdmF0ZSBrZXlcXFwiIHZlcndlbmRlbi5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJBbm1lbGR1bmcgZmVobGdlc2NobGFnZW4hIEJpdHRlIHN0ZWxsZW4gU2llIHNpY2ggc2ljaGVyLCBkYXNzIFNpZSBkYXMgTWFzdGVyLVBhc3N3b3J0IG9kZXIsIGbDvHIgZGVuIGVyd2VpdGVydGVuIEFubWVsZGUtTW9kdXMsIGRlbiBiZXJlaXRnZXN0ZWxsdGVuIFxcXCJBY3RpdmUgcHJpdmF0ZSBrZXlcXFwiIHZlcndlbmRlbi5cIixcblx0XCJXQVJOSU5HXCI6IFwiV2FybnVuZ1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJGw7xyIGVpbmVuIFdpdG5lc3MgYWJzdGltbWVuXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJFcmZvbGdyZWljaCBmw7xyIGVpbmVuIFdpdG5lc3MgYWJnZXN0aW1tdFwiLFxuXHRcIkFHT1wiOiBcInNlaXRcIixcblx0XCJGUk9NX05PV1wiOiBcImFiIGpldHp0XCIsXG5cdFwiU0VDU1wiOiBcIlNla3VuZGVuXCIsXG5cdFwiQV9NSU5cIjogXCJlaW5lIE1pbnV0ZVwiLFxuXHRcIk1JTlNcIjogXCJNaW51dGVuXCIsXG5cdFwiQU5fSE9VUlwiOiBcImVpbmUgU3R1bmRlXCIsXG5cdFwiSE9VUlNcIjogXCJTdHVuZGVuXCIsXG5cdFwiQV9EQVlcIjogXCJlaW5lbiBUYWdcIixcblx0XCJEQVlTXCI6IFwiVGFnZVwiLFxuXHRcIkFfTU9OVEhcIjogXCJlaW5lbiBNb25hdFwiLFxuXHRcIk1PTlRIU1wiOiBcIk1vbmF0ZVwiLFxuXHRcIkFfWUVBUlwiOiBcImVpbiBKYWhyXCIsXG5cdFwiWUVBUlNcIjogXCJKYWhyZVwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluLiBsZXNlblwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJOZWdhdGl2IGJld2VydGVuIG9kZXIgbWFya2llcmVuXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiQmlsZCBhdWZuZWhtZW5cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIkJpbGQgYXVzd8OkaGxlblwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiRWlnZW5lIFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiQmlsZCBlaW5mw7xnZW5cIixcblx0XCJFUlJPUlwiOiBcIkZlaGxlclwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIlVwbG9hZCBmZWhsZ2VzY2hsYWdlblwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJLYW1lcmEgZ2VzY2hsb3NzZW5cIixcblx0XCJTRVRfVVJMXCI6IFwiVVJMIHNldHplblwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJEaXJla3RlciBMaW5rIHp1bSBCaWxkXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJLb21tZW50YXIgYWJnZWdlYmVuIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiR2Vsw7ZzY2h0ZSBLb21tZW50YXJlIGvDtm5uZW4gbmljaHQgd2lkZXJoZXJnZXN0ZWxsdCB3ZXJkZW4uLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJLb21tZW50YXIgZ2Vsw7ZzY2h0XCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJCaWxkIHdpcmQgaG9jaGdlbGFkZW5cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiSG9jaGxhZGVuIGFiZ2VzY2hsb3NzZW5cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiSG9jaGxhZGVuIGZlaGxnZXNjaGxhZ2VuXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiUGFzc3dvcnQgb2RlciBCZW51dHplcm5hbWUgbmljaHQga29ycmVrdFwiLFxuXHRcIklORk9cIjogXCJJbmZvcm1hdGlvblwiLFxuXHRcIlFSX1RFWFRcIjogXCJQbGF0emllcmVuIFNpZSBlaW5lbiBRUiBjb2RlIGlubmVyaGFsYiBkZXMgQmVyZWljaHNcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJTdGVsbGVuIFNpZSBzaWNoZXIsIGRhc3MgU2llIMO8YmVyIGF1c3JlaWNoZW5kZSBNaXR0ZWwgdmVyZsO8Z2VuIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJTaWUgdmVyZsO8Z2VuIG5pY2h0IMO8YmVyIGF1c3JlaWNoZW5kZSBNaXR0ZWwgZsO8ciBkaWVzZSBBa3Rpb24hXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIldvbGxlbiBTaWUgd2lya2xpY2ggw7xiZXJ0cmFnZW4/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiQmVzdMOkdGlndW5nZW5cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIkRpZSBUcmFuc2FrdGlvbiB3dXJkZSDDvGJlcnRyYWdlblwiLFxuXHRcIkZFRURcIjogXCJGZWVkXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJJbSBUcmVuZFwiLFxuXHRcIkhPVFwiOiBcIkJlbGllYnRcIixcblx0XCJORVdcIjogXCJOZXVcIixcblx0XCJQUk9NT1RFRFwiOiBcIkJld29yYmVuXCIsXG5cdFwiVk9URVNcIjogXCJTdGltbWVuXCIsXG5cdFwiUEFZT1VUXCI6IFwiQXVzemFobHVuZ1wiLFxuXHRcIkNPTU1FTlRTXCI6IFwiS29tbWVudGFyZVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiU2VpdCAzMCBUYWdlbiBpbSBUcmVuZFwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlNvcnRpZXJlbiBkZXIgUG9zdHMgbmFjaDpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJBdXN6YWhsdW5nc2tyZWlzbGF1ZlwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJWb3JhdXNzaWNodGxpY2hlIEF1c3phaGx1bmdlblwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiVmVyZ2FuZ2VuZSBBdXN6YWhsdW5nZW5cIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiQXVzemFobHVuZyBhbiBkZW4gQXV0b3JcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJLdXJhdGlvbnNhdXN6YWhsdW5nZW5cIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIlBvc3Qgd3VyZGUgdmVyw7ZmZmVudGxpY2h0IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQb3N0cyB6dXIgc3DDpHRlcmVuIFZlcsO2ZmZlbnRsaWNodW5nIVwiLFxuXHRcIlNBVkVEXCI6IFwiR2VzcGVpY2hlcnRcIixcblx0XCJDTEVBUkVEXCI6IFwiR2VsZWVydFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJEYXMgbWFya2llcmVuIGVpbmVzIFBvc3RzIGthbm4genVtIFZlcmx1c3QgZGVyIFZlcmfDvHR1bmcgZsO8aHJlbiB1bmQgdmVycmluZ2VydCBkaWUgU2ljaHRiYXJrZWl0IGRlcyBQb3N0cy48YnI+PGJyPlNpZSBzb2xsdGVuIFBvc3RzIG51ciB1bnRlciBtYXJraWVyZW4sIHdlbm4gZWluZXIgZGVyIGZvbGdlbmRlbiBQdW5rdGUgenV0cmlmZnQ6IDx1bD48bGk+QmV0cnVnIG9kZXIgUGxhZ2lhdDwvbGk+PGxpPlZ1bGfDpHJlIEF1c2RydWNrZSBvZGVyIFxcXCJUcm9sbGluZ1xcXCI8L2xpPjxsaT5NdXR3aWxsaWcgZmFsc2NoIGthdGVnb3Jpc2llcnQgb2RlciBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIk1heGltYWxlIEFuemFobCB2b24gQW5mcmFnZW4gZXJyZWljaHQuIEJpdHRlIHNjaGF1ZW4gU2llIHNpY2ggYW5kZXJlIHRyZW5kL3RhZ3MgYW4hXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiUG9zdCB2b24gZGVuIExlc2V6ZWljaGVuIGVudGZlcm50IVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQb3N0IHp1IGRlbiBMZXNlemVpY2hlbiBoaW56dWdlZsO8Z3QhXCIsXG5cdFwiUkVTRVRcIjogXCJadXLDvGNrc2V0emVuXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJQcm9maWxiaWxkIMOkbmRlcm5cIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIlRpdGVsYmlsZCDDpG5kZXJuXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiQml0dGUgdHJhZ2VuIFNpZSBkZW4gXFxcIkFjdGl2ZSBwcml2YXRlIGtleVxcXCIgZWluLCB3ZW5uIFNpZSBkZW4gZXJ3ZWl0ZXJ0ZW4gTG9naW4gTW9kdXMgZ2V3w6RobHQgaGFiZW4hXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiWnVyw7xja3NldHplbiBkZXMgUHJvZmlsYmlsZHNcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJadXLDvGNrc2V0emVuIGRlcyBUaXRlbGJpbGRzLlwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiQXVmZ3J1bmQgZWluZXMgU2VydmVydXBkYXRlcyBtdXNzIGVpbiBkaWUgQW53ZW5kdW5nIG5ldWdlc3RhcnRldCB3ZXJkZW4hXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkVpbnN0ZWxsdW5nZW4gYWt0dWFsaXNpZXJ0IVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIlNwcmFjaGVuXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJIaWVyIGthbm4gZGllIFNwcmFjaGUgZGVyIEFud2VuZHVuZyBnZcOkbmRlcnQgd2VyZGVuLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJGw7xyIGRpZSBnZXfDvG5zY2h0ZSBPcGVyYXRpb24gbcO8c3NlbiBTaWUgYW5nZW1lbGRldCBzZWluLiBCaXR0ZSBtZWxkZW4gU2llIHNpY2ggbWl0IElocmVtIFBhc3N3b3J0IG9kZXIgZGVtIFxcXCJhY3RpdmUvcG9zdGluZ1xcXCItU2NobMO8c3NlbCBzZWluXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGxlcmllXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiTWl0d2lya2VuZGUgYW4gZGVyIMOcYmVyc2V0enVuZ1wiLFxuXHRcIlNIQVJFXCI6IFwiVGVpbGVuXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNYXJrdHBsYXR6XCIsXG5cdFwiRVhDSEFOR0VcIjogXCJCw7Zyc2VcIixcblx0XCJEUkFGVFNcIjogXCJFbnR3w7xyZmVcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJCZWl0cmFnIGF1cyBFbnR3w7xyZmVuIGVudGZlcm50IVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJCZWl0cmFnIHp1IEVudHfDvHJmZW4gaGluenVnZWbDvGd0IVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJMaW5rcyB3aXNjaGVuIGbDvHIgT3B0aW9uZW5cIixcblx0XCJNQU5BR0VcIjogXCJWZXJ3YWx0ZW5cIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiQmlsZCBlbnRmZXJudFwiLFxuXHRcIkNPUFlcIjogXCJLb3BpZXJlblwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiU2llIGhhYmVuIG5vY2gga2VpbiBGb3RvIGhvY2hnZWxhZGVuIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiTmFjaCB1bnRlbiB6aWVoZW4genVtIGFrdHVhbGlzaWVyZW5cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiRXh0ZXJuZSBBcHBzXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWctSW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlZvcnNjaGxhZ2VuXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJLb21tdCBiYWxkXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJIaWVyIGthbm5zdCBkdSBkaWUgQmxvY2tjaGFpbiBvZGVyIGRpZSBTdGFuZGFyZHBsYXR0Zm9ybSB3ZWNoc2Vsbi5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlfDpGhydW5nXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkhpZXIga8O2bm5lbiBTaWUgSWhyZSBTdGFuZGFyZHfDpGhydW5nIMOkbmRlcm4uIFNpZSBzZWhlbiBhbGwgSWhyZSBWZXJkaWVuc3RlIGbDvHIgQmVpdHLDpGdlIC8gS29tbWVudGFyZSBpbiBkaWVzZXIgU3RhbmRhcmR3w6RocnVuZy5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj5GZWF0dXJlIExpc3RlPC9iPjxicj4tIFp1Z2FuZyBlcmhhbHRlbiB6dSBlaW56aWdhcnRpZ2VuIEFydGlrZWxuIGFsbCBkZXIgVGhlbWVuZ2ViaWV0ZSwgZGllIFNpZSBnZXJuZSBsZXNlbiBtw7ZjaHRlbi48YnI+LSBJbnRlcmFnaWVyZW4gU2llIG1pdCBkZW4gQXV0b3JlbiwgaW4gZGVtIFNpZSBkaWUgQmVpdHLDpGdlIGtvbW1lbnRpZXJlbiB1bmQgbWl0IGFuZGVyZW4gZGlza3V0aWVyZW4uPGJyPi0gU3RpbW1lbiBTaWUgZsO8ciBBcnRpa2VsIHVtIEF1dG9yZW4genUgYmVsb2huZW4gdW5kIHNlbGJzdCBDdXJhdGlvbiBSZXdhcmRzIHp1IHZlcmRpZW5lbi48YnI+LSBWZXLDtmZmZW50bGljaGVuIFNpZSBJaHJlIEFydGlrZWwsIEJsb2cgUG9zdHMsIGRpZSBrb3N0ZW5sb3MgZ2Vob3N0ZWQgd2VyZGVuIHVuZCBlcmhhbHRlbiBTaWUgRW50Z2VsdCBmw7xyIEludGVyYWdpZXJlbiB1bmQgZ2V3aW5uZW4gU2llIHp1c8OkdHpsaWNoIEFuaMOkbmdlciBmw7xyIElocmUgSW5oYWx0ZS48YnI+LSBTY2hyZWliZW4gU2llIEFydGlrZWwgdm9uIHVudGVyd2Vncy4gU3BlaWNoZXJuIFNpZSBlaW5lIFZpZWx6YWhsIHZvbiBFbnR3w7xyZmVuIHVtIGRpZXNlIHNww6R0ZXIgenUgdmVyw7ZmZmVudGxpY2hlbi48YnI+LSBCb29rbWFya2VuIFNpZSBJaHJlIExpZWJsaW5nc2FydGlrZWwsIHVtIGRpZXNlIHNww6R0ZXIgenUgbGVzZW4uPGJyPi0gRWlubmFobWVuIHRhdXNjaGVuIG9kZXIgYXVzemFobGVuLjxicj4tIMOcYmVyd2Vpc2VuIFNpZSBHdXRoYWJlbiBhbiBBdXRvcmVuLCBOdXR6ZXIsIEZyZXVuZGUsIEFuaMOkbmdlciwgZXRjLjxicj4tIEZvbGdlbiBTaWUgaW50ZXJlc3NhbnRlbiBBdXRvcmVuLCBCbG9nZ2Vybi48YnI+LSBEdXJjaHN1Y2hlbiBTaWUgSW5oYWx0ZSBJaHJlciBGb2xsb3dlciB1bmQgQXV0b3Jlbi48YnI+LSBFcmhhbHRlbiBTaWUgQmVuYWNocmljaHRpZ3VuZ2VuIHZvbiBJaHJlbiBGb2xsb3dlciB1bmQgRGlza3Vzc2lvbmVuLCBhbiBkZW5lbiBTaWUgdGVpbGdlbm9tbWVuIGhhYmVuLjxicj4tIFN1Y2hlbiBTaWUgaW50ZXJlc3NhbnRlIFRhZ3MgLyBLYXRlZ29yaWVuIGFsbGVyIEFydGlrZWwgdW5kIEF1dG9yZW4uPGJyPi0gUGVyc29uYWxpc2llcmVuIFNpZSBJaHJlIFByb2ZpbC48YnI+LSBWaWVsZSBuZXVlIEZlYXR1cmVzIHdlcmRlbiBkZW1uw6RjaHN0IHZvcmdlc3RlbGx0Ljxicj48YnI+PGI+U2ljaGVyaGVpdDwvYj48YnI+MS4gQXBwIGhhdCBrZWluZW4gWnVncmlmZiBhdWYgSWhyZSBFaW5uYWhtZW4uPGJyPjIuIEFwcCBiaWV0ZW4gZWluZmxpZcOfdC1zaWRlIFNpY2hlcmhlaXRzLU1vZGVsbCBtaXQgcHJpdmF0ZW4gU2NobMO8c3NlbG4sIGRpZSBsb2thbCBnZWhvc3RldCB1bmQgbmllbWFscyBhbiBhbmRlcmUgU2VydmVyIGdlc2NoaWNrdCB3ZXJkZW4uIFNpZSBzaW5kIGxlZGlnbGljaCBkYWbDvHIgdmVyYW50d29ydGxpY2ggSWhyZSBQYXNzd29ydCB6dSBzaWNoZXJuLjxicj4zLiBEaWUgQXBwIGJpZXRldCBzaW1wbGVzIE51dHplciBJbnRlcmZhY2UgdW5kIGF0dHJha3RpdmUgVXNlciBFcmZhaHJ1bmdlbjxicj40LiBEaWUgQXBwIGJlaW5oYWx0ZXQgZWluZSB6dXPDpHR6bGljaGUgU2ljaGVyaGVpdHNlYmVuZSBkdXJjaCBlaW5lbiBQaW4tQ29kZTxicj48YnI+ZVN0ZWVtIHVudGVyc3TDvHR6IGRpZSBQbGF0dGZvcm1lbiBTdGVlbSBzb3dpZSBHb2xvcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkdyw7xuZGVyIHVuZCBsZWl0ZW5kZXIgRW50d2lja2xlclwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiQWNjb3VudCBoaW56dWbDvGdlblwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdHRmb3JtXCIsXG5cdFwiRVNDUk9XXCI6IFwiVHJldWhhbmRzZXJ2aWNlXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93IEFnZW50XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUmF0aWZpemllcnVuZ3NmcmlzdFwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiRXNjcm93IEFibGF1ZmRhdHVtXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkVzY3JvdyBHZWLDvGhyXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IEJlZGluZ3VuZ2VuXCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIk5hY2h0bW9kdXNcIixcblx0XCJEQVlfTU9ERVwiOiBcIlRhZ21vZHVzXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiRGVuIGdhbnplbiBBcnRpa2VsIGFuc2VoZW5cIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiQmVudXR6ZXIgbmljaHQgZ2VmdW5kZW5cIixcblx0XCJBUFBST1ZFXCI6IFwiWnVzdGltbWVuXCIsXG5cdFwiRElTUFVURVwiOiBcIkFuZmVjaHRlblwiLFxuXHRcIlJFTEVBU0VcIjogXCJWZXLDtmZmZW50bGljaHVuZ1wiLFxuXHRcIkZST01cIjogXCJWb25cIixcblx0XCJJRFwiOiBcImlEXCIsXG5cdFwiU1VCTUlUXCI6IFwiU2VuZGVuXCIsXG5cdFwiUkVDRUlWRVJcIjogXCJFbXBmw6RuZ2VyXCIsXG5cdFwiTE9DQVRJT05cIjogXCJQb3NpdGlvblwiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJzZWl0ZVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIkFuZ2V6ZWlndGVyIE5hbWVcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiaG9tXCIsXG5cdFwiTE9HSU5cIjogXCJsZ2luXCIsXG5cdFwiTE9HT1VUXCI6IFwibGdvb3R1XCIsXG5cdFwiUFJPRklMRVwiOiBcInBvcmZsaVwiLFxuXHRcIkZPTExPV1wiOiBcImZsdXdcIixcblx0XCJCT09LTUFSS1NcIjogXCJia3VtYWtyelwiLFxuXHRcIlRSQU5TRkVSXCI6IFwidGFybnNlZnJcIixcblx0XCJNQVJLRVRcIjogXCJtcmFrdGVcIixcblx0XCJTRVRUSU5HU1wiOiBcInN0ZXRpZ256XCIsXG5cdFwiQUJPVVRcIjogXCJhYnV0XCIsXG5cdFwiQUJPVVRfMVwiOiBcIndlciBhbnlvbiBjbmEgZXJhbiByd2FyZHogZmVyIHRoaXIgY250bnQhXCIsXG5cdFwiQUJPVVRfMlwiOiBcIml6IHB3ZXJlZCBiaSB7e3BsYXRmb3JtbmFtZX19IHBhbHRmcm9tLiBhcHAgaXogY3JhdGVkIGJpXCIsXG5cdFwiQUJPVVRfM1wiOiBcImFuZCBpdCBpeiBvcG4tc3JjLCBjbW91bnRpIGRpcnZuZSBtYmlsIHByamN0LiBpdCBvZmZlenIgY250bnQgYWNjZXpzIGZlciByZG5nLCBjb2VtbnRuZywgdnRvaWduLCBwc3RuZywgdGFybnNlZnIgZXJhbmlnbnosIGV0Yy4gZnRyeiBvZmZlcmVkIGJpIHt7cGxhdGZvcm1uYW1lfX0gYmxja2NoaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gYXBwIG52ZXIgYWNjZXpzIG9yIGhsb2Qgb3RubyB1ZXNyIGZuZHouXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIGFwcCBvZmZlenIgYSBjbG50LXNpZCBzY2V1cnRpIG1kZWwsIHd0aWggcGlydnRhIGt5ZXogaHNvdGRlIGxjb2FpbCBhbmQgbnZlciBzbmV0IHR1IGFuaSBzcnZyei5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gYXBwIG9mZmV6ciBzbXBsLCBhdHJ0YWNpdiB1ZXNyIGluZXRyZmN6IGFuZCBleHBybmN6LlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBhcHAgbnZlciBycWV1cmkgdXNyeiB0dSBpbnB0IGFuaSBwcmVzb2FubCBpbmZybWF0bi5cIixcblx0XCJBQk9VVF84XCI6IFwidm90IGdvb2Qta2FybWEgYXogd2l0bnNlelwiLFxuXHRcIkFCT1VUXzlcIjogXCJrb250YWt0L2ZlZGJhazpcIixcblx0XCJBQk9VVF8xMFwiOiBcIm11ciBpbmY6XCIsXG5cdFwiUkVNT1ZFXCI6IFwicm1vdlwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwibXJha3RlIHZlaXdcIixcblx0XCJQUklDRVwiOiBcInBpcmNcIixcblx0XCJBTU9VTlRcIjogXCJhb211dG5cIixcblx0XCJUT1RBTFwiOiBcInR0YWxcIixcblx0XCJOT09SREVSU1wiOiBcIm5vIG9lcG4gb2RyZXpyIGZlclwiLFxuXHRcIkRBVEVcIjogXCJkYXRcIixcblx0XCJCVVlcIjogXCJidWlcIixcblx0XCJTRUxMXCI6IFwic2VsXCIsXG5cdFwiT1BFTlwiOiBcIm9lcG5cIixcblx0XCJISVNUT1JZXCI6IFwiaHN0clwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiZmx1dyBiYWtcIixcblx0XCJGT0xMT1dFRFwiOiBcImZsb3dlZFwiLFxuXHRcIlVORk9MTE9XXCI6IFwidW5mb2xvd1wiLFxuXHRcIkZPTExPV0lOR1wiOiBcImZsb293bmlnXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiZmxvb3dyZXpcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwic2FlcmhjIGZsb293cmV6XCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcInNhZXJoYyBmbG9vd25pZ1wiLFxuXHRcIkJZXCI6IFwiYmlcIixcblx0XCJNRU5VXCI6IFwibW5ldVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiYmttcmtcIixcblx0XCJSRUJMT0dcIjogXCJyYmVsZ29cIixcblx0XCJVUFZPVEVcIjogXCJ1cHZ0XCIsXG5cdFwiRE9XTlZPVEVcIjogXCJkd252b3RcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwidW52dCBkb253dm9lZFwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwidW52dCB1cHZvZWRcIixcblx0XCJSRVBMWVwiOiBcInJwbGlcIixcblx0XCJFRElUXCI6IFwiZWlkdFwiLFxuXHRcIlBPU1RfMVwiOiBcInNpd3AgbGZldCBvbiBjbWVudHogdHUgYyBvcHRpbnpcIixcblx0XCJQT1NUXzJcIjogXCJ0YXAgb24gY21lbnR6IHR1IGMgc3ViLWNtbnR6XCIsXG5cdFwiT1BUSU9OU1wiOiBcIm9wdGluelwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcInJzZXRlZW1kIGJpXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwibnRobmcgaGlyLCB5ZXQuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcImJsYW5jelwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIHRyYWVkYmFsICQkIGRhdCBjbiBiIHRybnNmcmVkIGFueXRpZW0uIHt7cGxhdGZvcm1uYW1lfX0gY24gYiBjb3ZuZXJlZCAyIHt7cGxhdGZvcm1wb3dlcn19IGluIGEgcHJjc3ogY2xlZCBwd29lcm5pZyB1cC5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgaWZubHVuZWMgJCQgZGF0IGVybiBtdXIgcHdlciBmZXIgaGxkbmcgbG5vZyB0aWVtIGFuZCB2b3RpZ24gb24gcG9zdHouIHRlaCBtdXIgdSBob2xkeiB0ZWggbXVyIHUgY25hIGlmbmx1bmVjIG90aGVyeiByd2FyZHogYW5kIGVybiByd2FyZHogZmVyIGFjY3VyYXQgdm90aWduLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIiQkIHdydGggYWJ1dCB7e3BsYXRmb3Jtc3VuaXR9fSBvZiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcImVzaXRtYWVkIHZsYXVcIixcblx0XCJQUk9GSUxFXzRcIjogXCJ0ZWggZXNpdG1hZWQgdmxhdSBpeiBic2VkIG9uIGEgNyBkYWkgYWV2cmdhIHZsYXUgb2Yge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwidHJhbnNhY3RuIGhzdHJcIixcblx0XCJQT1NUSU5HXCI6IFwicHN0bmdcIixcblx0XCJQUk9GSUxFXzVcIjogXCJ0ZWggcHN0bmcga2VpIGl6IHVlc2QgZmVyIHBzdG5nIGFuZCB2dG9pZ24uIGl0IHNvaHVkbCBiIGRpZmZlcm50IGZydW0gdGVoIGFjdHYgYW5kIG93bnIga3llei5cIixcblx0XCJPV05FUlwiOiBcIm93bnJcIixcblx0XCJQUk9GSUxFXzZcIjogXCJ0ZWggb3duciBrZWkgaXogdGVoIG1zYXRyZSBrZWkgZmVyIHRlaCBhY2NvbnQgYW5kIGl6IHJxZXVpZXJkIHR1IGNobmcgdGVoIG90aHIga3llei4gdGVoIHBpcnZ0YSBrZWkgb3IgcHNhc3dyb2QgZmVyIHRlaCBvd25yIGtlaSBzb2h1ZGwgYiBrcGV0IG9mZmxuaSBheiBtY3VoIGF6IHBzc2JsLlwiLFxuXHRcIkFDVElWRVwiOiBcImFjdHZcIixcblx0XCJQUk9GSUxFXzdcIjogXCJ0ZWggYWN0diBrZWkgaXogdWVzZCB0dSBtYWVrIHRybmFzZnJ6IGFuZCBwYWxjIG9kcmV6ciBpbiB0ZWggaXRuZXJhbmwgbXJha3RlLlwiLFxuXHRcIk1FTU9cIjogXCJtbWVvXCIsXG5cdFwiUFJPRklMRV84XCI6IFwidGVoIG1tZW8ga2VpIGl6IHVlc2QgdHUgY3JhdCBhbmQgcmFlZCBtbW96LlwiLFxuXHRcIkJMT0dcIjogXCJib2xnXCIsXG5cdFwiUE9TVFNcIjogXCJwc3R6XCIsXG5cdFwiUkVQTElFU1wiOiBcInJwbGllc1wiLFxuXHRcIldBTExFVFwiOiBcIndsZXRcIixcblx0XCJUQUdcIjogXCJ0YWdnXCIsXG5cdFwiVVNFUlwiOiBcInVlc3JcIixcblx0XCJDTE9TRVwiOiBcImNvbHNcIixcblx0XCJUT1wiOiBcInRvXCIsXG5cdFwiQVNTRVRcIjogXCJhc3N0XCIsXG5cdFwiU0VORFwiOiBcInNuZFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwic2NldXJ0aVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcImFhdmlsYmFsXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJwYnVsY2kgbW1lb1wiLFxuXHRcIlRPX0RFU0NcIjogXCJ1ZXNyIGUuZy4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwicGluIGNvZFwiLFxuXHRcIlBJTl9URVhUXCI6IFwicGluIGNvZCBobHB6IHl1IHR1IHNjdXIgYXBwIGFuZCB1ciBkdGFhLiA8YnIvPjxici8+PGI+bm90ZTo8L2I+IG9uYyBlbmJsZWQsIHl1IGhldiBtYXggNCB0aXJ6IHR1IHVubGssIGlmIHl1IGZyZ3QgcGluIG9yIGZpYWwsIGFwcCB3aWwgcm1vdiBsZ29nZGUgaW4gdWVzciBkdGFhLiB5dSBjbmEgci1lbG9pZ24gYW5kIGNudG4gdXNuZyBhcHAuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIm5vdGlmaWthdGlvbnpcIixcblx0XCJWT1RFX1RFWFRcIjogXCJ5dSB3aWwgZ2V0IG5vdGZpa2F0aW4gd2VobiBzbW9lbm8gdnRveiB1ciBjbnRudCEgPGJyLz4gPGI+bnQ6PC9iPiBub3RpZmlrYXRpb256IGljbmxkdSB2dG9pZ24gd2llZ3RoIGF6IHdlbCBpbiBhbHJ0IG1lc3NpZy4gKGIgaXQgdXB2dCwgZHdudm90LCB1bnZ0KS5cIixcblx0XCJWT1RFXCI6IFwidm90XCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwieXUgd2lsIGdldCBub3RmaWthdGluIHdlaG4gc21vZW5vIGNtZW50eiBvbiB1ciBwc3R6IG9yIGtvbWVudHMhPGJyLz4gPGI+bnQ6PC9iPiBub3RpZmlrYXRpb256IGljbmxkdSB3ZWhuIHNtb2VubyA8Yj5kdHM8L2I+IHRoaXIgY21lbnR6IGF6IHdlbC5cIixcblx0XCJDT01NRU5UXCI6IFwiY21vZXRuXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJ5dSB3aWwgZ2V0IG5vdGZpa2F0aW4gd2VobiBzbW9lbm8gZmx1dyBvciB1bmZvbG93IHl1IVwiLFxuXHRcIk1FTlRJT05TXCI6IFwibW5ldGlub3pcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwieXUgd2lsIGdldCBub3RmaWthdGluIHdlaG4gc21vZW5vIG1uZXRpbm96IHl1IGluIHRoaXIgcHN0L2NtbnQhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJrb25mZ3VyYXRvbnpcIixcblx0XCJWT1RJTkdcIjogXCJ2dG9pZ25cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcInZvdCB3aWVndGggb3IgcGVjcmVuYWcgYWZmZWN0eiB2dG9pZ24gcHdlciBvbiBhcHAsIHNvIHl1IGNuYSByZ3VsYXQgdXIgdnRvaWduIHJ3ZWFkci4gPGJyLz48YnIvPjxiPm5vdGU6PC9iPiBkaXogd2lsIGNobmcgdnRvaWduIHdlaWdodC9wZXJjZW50YWcgZmVyIGR3bnZ0aW5nIGF6IHdlbCBhbmQgaXQgaXogZXZyZXl3ZXIgb24gYXBwXCIsXG5cdFwiU0VSVkVSXCI6IFwic3JldnJlXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJyY21uZGVkXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwic2F2IGNhaG56Z1wiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwidnRvZXpyIGlmbm9cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJ3bGN1bSBiYWshXCIsXG5cdFwiTE9HSU5fMVwiOiBcInNnaW4gaW4gd3RpaCB1ciB1c3JuYW0gYW5kIHBzYXN3cm9kIHR1IGNudG4uXCIsXG5cdFwiTE9HSU5fMlwiOiBcInBzdG5nIGtlaSBpeiB1ZXNkIGZlciBwc290LCBjbW9ldG4sIHZvdCwgZmx1dy5cIixcblx0XCJMT0dJTl8zXCI6IFwiYWN0diBrZWkgaXogdWVzZCBmZXIgdHJuYXNmcnogYW5kIHBvcmZsaSBwY2l0cnUgdXBkdC5cIixcblx0XCJMT0dJTl80XCI6IFwidWVzciBjcmRudGFseiBhciBrcGV0IGxjb2FpbCBvbiB0ZWggZHZpYy4gdW9wbiBsZ29vdHUgY3JkbnRhbHogYXIgcm1vdmVkIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcImRudCBoZXYgYW4gYWNjb250P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwic2dpbiB1cCBub3dcIixcblx0XCJDQU5DRUxcIjogXCJjbmFjbGVcIixcblx0XCJBRFZBTkNFRFwiOiBcImF2ZGFuZWNkXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcImFjdHYgcGlydnRhIGtlaVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwicHN0bmcgcGlydnRhIGtlaVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwibWFzdHIvbWFuIHBzYXN3cm9kXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJ1c3JuYW1cIixcblx0XCJDQVJEX1ZJRVdcIjogXCJjcmFkIHZlaXdcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJjbXBjdCB2ZWl3XCIsXG5cdFwiU0VBUkNIXCI6IFwic2FlcmhjXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJzYnVtdGkgYSBzdHJpXCIsXG5cdFwiUkVQTFlUT1wiOiBcInJwbGkgdHVcIixcblx0XCJQT1NUXCI6IFwicHNvdFwiLFxuXHRcIlBSRVZJRVdcIjogXCJwcnZld1wiLFxuXHRcIkRFRkFVTFRcIjogXCJkZmFsdCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwicHdlciB1cCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJkY2VsbmkgcHlhb3R1XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJzYXYgZmVyIGx0ZXJcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJwc290IGNudG50XCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiY21vZXRuIGNudG50XCIsXG5cdFwiVElUTEVcIjogXCJ0dGlsXCIsXG5cdFwiVEFHU1wiOiBcInRlZ3pcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJub3QgbXRjaFwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiY25mcm0gcGluXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwib3BubmcgcHNvdFwiLFxuXHRcIlNFVF9QSU5cIjogXCJzZXQgcGluXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiZW50ciBwaW5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJhciB5dSBzdXI/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiYnJhb2Rjc3QgZW9yciwgdHJpIGFnbiFcIixcblx0XCJTVUNDRVNTXCI6IFwic2Njc3pcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcInJlbGJvZ2VkIHBzb3QhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcImxnaW4gZmlhbGRlISBwbHogbWFlayBzdXIgeXUgaGV2IGxnb2dkZSBpbiB3dGloIG1zYXRyZSBwc2Fzd3JvZCBvciBwb3J2aWVkZCBwc3RuZyBwaXJ2dGEga2VpIG9uIGxnaW4gaWYgeXUgaGV2IGN1aHNkZSBhdmRhbmVjZCBtb2QuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwibGdpbiBmaWFsZGUhIHBseiBtYWVrIHN1ciB5dSBoZXYgbGdvZ2RlIGluIHd0aWggbXNhdHJlIHBzYXN3cm9kIG9yIHBvcnZpZWRkIGFjdHYgcGlydnRhIGtlaSBvbiBsZ2luIGlmIHl1IGhldiBjb2hzbmUgYXZkYW5lY2QgbW9kLlwiLFxuXHRcIldBUk5JTkdcIjogXCJ3cm5uZ1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJ2dG9pZ24gZmVyIHd0bnN6XCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJ2dGVkIGZlciB3dG5zelwiLFxuXHRcIkZST01fTk9XXCI6IFwiZnJ1bSBub3dcIixcblx0XCJTRUNTXCI6IFwic2VjelwiLFxuXHRcIk1JTlNcIjogXCJtaW56XCIsXG5cdFwiQU5fSE9VUlwiOiBcImFuIGhyelwiLFxuXHRcIkhPVVJTXCI6IFwiaHJ6XCIsXG5cdFwiQV9EQVlcIjogXCJhIGRhaVwiLFxuXHRcIkRBWVNcIjogXCJkeWF6XCIsXG5cdFwiQV9NT05USFwiOiBcImEgbW50aFwiLFxuXHRcIk1PTlRIU1wiOiBcIm1ub3R6aFwiLFxuXHRcIkFfWUVBUlwiOiBcImEgeWFlclwiLFxuXHRcIllFQVJTXCI6IFwieWFyelwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluIHJhZWRcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiZHdudm90IG9yIGZhbGdcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJjcGF0cnUgcGNpdHVyXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJzaWxlY3QgcGNpdHVyXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJzZXQgY3N1dG1vIHVybFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiaXNuZXRyIHBjaXRydVwiLFxuXHRcIkVSUk9SXCI6IFwiZW9yclwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcInVscG9kYSBlb3JyXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcImNtYWVhciBjbmFjZWVsZFwiLFxuXHRcIlNFVF9VUkxcIjogXCJzZXQgdXJsXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcImRyaWV0YyB3ZWIgbG5payBmZXIgdGVoIHBjaXRydVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiY21vZXRuIGl6IHN1bWJpdGVkIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiZGxlZXRuaWcgY21lbnR6IGFyIGlydnJzYmwuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJkbGV0ZWQgY21vZXRuXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJ1cG9sYWRuZyBwY2l0cnVcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwidWxwb2RhIGNvcG1sZWVkXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcInVscG9kYSBmaWFsZGVcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJ0ZWggcHNhc3dyb2Qgb3IgYWNjb250IG5hbSB3YXogaWNub3JjZXRcIixcblx0XCJJTkZPXCI6IFwiaWZub1wiLFxuXHRcIlFSX1RFWFRcIjogXCJwYWxjIGEgcXIgY29kIGluc2QgdGVoIHNhY24gYWVyYVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIm1hZWsgc3VyIHl1IGhldiBlb251aGcgJCQgZmVyIHRyYW5zYWN0biFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwidWVzciB5dSBhciB0eXJpZ24gdHUgdGFybnNlZnIgJCQsIGRzbid0IGV4c3QhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcImFyIHl1IHN1ciB5dSB3YW5hbiB0dSB0YXJuc2Vmcj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJrb25mcm1hdGluXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJ0cmFuc2FjdG4gaXogYnJhZGNhc3RkXCIsXG5cdFwiRkVFRFwiOiBcImZlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwidGVybmRuaWdcIixcblx0XCJIT1RcIjogXCJob3RcIixcblx0XCJORVdcIjogXCJuZXdcIixcblx0XCJQUk9NT1RFRFwiOiBcInBvcm1vZXRkXCIsXG5cdFwiVk9URVNcIjogXCJ2dG96XCIsXG5cdFwiUEFZT1VUXCI6IFwicHlhb3R1XCIsXG5cdFwiQ09NTUVOVFNcIjogXCJjbWVudHpcIixcblx0XCJUUkVORElOR18zMFwiOiBcInRlcm5kbmlnIGZlciAzMCBkeWF6XCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwic3JvdCBwc3R6IGJ5OlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcInB5YW90dSBjY3lsXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcInBvZXRudGFsIHB5YW90dVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwicHNhdCBweWFvdHVcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiYXR1aHJvIHB5YW90dVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcImNydWF0b2luIHB5YW90dVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwicHNvdCBpeiBzdW1iaXRlZCFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwicHNvdCBmZXIgbHRlciBzYm1zc29uIVwiLFxuXHRcIlNBVkVEXCI6IFwic3ZlZFwiLFxuXHRcIkNMRUFSRURcIjogXCJjbGFyZWRcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiZmFsZ2duaWcgYSBwc290IGNuYSBybW92IHJ3YXJkeiBhbmQgbWFlayBkaXogbXRhZXJhaWwgbHNleiB2aXNpYmxlLjxicj48YnI+dGggZmFsZyBzb2h1ZGwgYiB1ZXNkIGZlciB0ZWggZm9vbHdpZzogPHVsPjxsaT5mcmF1dCBvciBwbGFnaWFyaXNtPC9saT48bGk+aGF0IHNwY2ggb3IgaXRuZXJlbnQgdHJvbGluZzwvbGk+PGxpPmludGVudGlvbmFsIG1za2F0ZWdvcnplZCBjbnRudCBvciBzcGFtPC9sPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwicnF1c3QgbG1pdCByY2hlZC4gY2VoayBvdXQgb3RociB0cm5kL3RlZ3ohXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwicHNvdCBpeiBybW92ZWQgZnJ1bSBia3VtYWtyeiFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwicHNvdCBpeiBhZGRkIHR1IGJrdW1ha3J6IVwiLFxuXHRcIlJFU0VUXCI6IFwicnNldFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiY2huZyBwb3JmbGkgcGNpdHJ1XCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJjaG5nIGN2ZXIgcGNpdHJ1XCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwicGx6IHBvcnZkaSBhY3R2IHBpcnZ0YSBrZWkgaWYgeXUgaGV2IGNvaHNuZSBhdmRhbmVjZCBsZ2luIG1vZCFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJkaXogd2lsIHJzZXQgdWVzciBwb3JmbGkgcGNpdHJ1XCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiZGl6IHdpbCByc2V0IHVlc3IgY3ZlciBwY2l0cnVcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcInNyZXZyZSB1cGR0IHJxdXJ6IHJzdHJ0IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJzdGV0aWdueiBhciB1cGRhdGVkIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcImxuYWd1Z2F6XCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJoaXIgeXUgY25hIGNobmcgbG5nYWcgb2YgdGVoIGFwcC5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiZGl6IG9wcmVhdG9uIHJxdXJ6IHVlc3IgdHUgYiBsZ29nZGUgaW4gd3RpaCBtaWFuIHBzYXN3cm9kLCBha3R2ZS9wb3N0bmcga2VpLiBwbHogbGdpbiBhbmQgdHJpIGFnbi5cIixcblx0XCJHQUxMRVJZXCI6IFwiZ2xhZWlyXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwidHJhbnNsYXRuIGtvbnRyYnV0cnpcIixcblx0XCJTSEFSRVwiOiBcInNocmVcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIm1yYWt0ZSBwYWxjXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJleGNobmdcIixcblx0XCJEUkFGVFNcIjogXCJkYXJmenRcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJwc290IGl6IHJtb3ZlZCBmcnVtIGRhcmZ6dCFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwicHNvdCBpeiBhZGRkIHR1IGRhcmZ6dCFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwic2l3cCBsZmV0IHR1IGMgb3B0aW56XCIsXG5cdFwiTUFOQUdFXCI6IFwibW5hZ1wiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJpYW1nIGl6IHJtb3ZlZFwiLFxuXHRcIkNPUFlcIjogXCJjcG9pXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJ5dSBoZXYgbm90IHVscG9hZWRkIGFuaSBpYW1nLCB5ZXQhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJwdWwgZHdvbiB0dSByZnJzaFwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJldHhlcmFubCBhcHB6XCIsXG5cdFwiUExVR0lOU1wiOiBcInBsZ256XCIsXG5cdFwiU1VHR0VTVFwiOiBcInNnZ3N0XCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJjbW9pZ24gc3VuXCIsXG5cdFwiQ0hBSU5cIjogXCJjaGluXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcImhpciB5dSBjbmEgY2huZyBibGNrY2hpbiBvciBkZmFsdCBwYWx0ZnJvbS5cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwizpHPgc+HzrnOus6uXCIsXG5cdFwiTE9HSU5cIjogXCLOlc6vz4POv860zr/PglwiLFxuXHRcIkxPR09VVFwiOiBcIs6Rz4DOv8+Dz43Ovc60zrXPg863XCIsXG5cdFwiUFJPRklMRVwiOiBcIs6gz4HOv8+Gzq/Ou1wiLFxuXHRcIkZPTExPV1wiOiBcIs6RzrrOv867zr/Pjc64zrfPg861XCIsXG5cdFwiQk9PS01BUktTXCI6IFwizqPOtc67zrnOtM6/zrTOtc6vzrrPhM61z4JcIixcblx0XCJUUkFOU0ZFUlwiOiBcIs6czrXPhM6xz4bOv8+BzqxcIixcblx0XCJNQVJLRVRcIjogXCLOkc69z4TOsc67zrHOus+Ezq7Pgc65zr9cIixcblx0XCJTRVRUSU5HU1wiOiBcIs6hz4XOuM68zq/Pg861zrnPglwiLFxuXHRcIkFCT1VUXCI6IFwizqPPh861z4TOuc66zqxcIixcblx0XCJBQk9VVF8xXCI6IFwiz4zPgM6/z4Ugzr8gzrrOsc64zq3Ovc6xz4IgzrzPgM6/z4HOtc6vIM69zrEgzrrOtc+BzrTOr8+DzrXOuSDOsc+Azr/Ou86xzrLOrc+CIM6xz4DPjCDPhM6/IM+AzrXPgc65zrXPh8+MzrzOtc69z4wgz4TOv8+FIVwiLFxuXHRcIkFCT1VUXzJcIjogXCLOtc6vzr3Osc65IM6yzrHPg865z4POvM6tzr3OvyDPg8+EzrfOvSDPgM67zrHPhM+Gz4zPgc68zrEge3twbGF0Zm9ybW5hbWV9fS4gzpTOt868zrnOv8+Fz4HOs86vzrEgzrXPhs6xz4HOvM6/zrPOrs+CIM6xz4DPjFwiLFxuXHRcIkFCT1VUXzNcIjogXCLOus6xzrkgzrXOr869zrHOuSDOsc69zr/Ouc+Hz4TPjM+CIM66z47OtM65zrrOsc+CLCDOus6xz4TOtc+FzrjPhc69z4zOvM61zr3Ov8+CIM6xz4DPjCDPhM63zr0gzrrOv865zr3PjM+EzrfPhM6xLs6gz4HOv8+Dz4bOrc+BzrXOuSwgz4DPgc+Mz4POss6xz4POtyDPg861IM+AzrXPgc65zrXPh8+MzrzOtc69zr8gzrPOuc6xIM6xzr3OrM6zzr3Pic+DzrcsIM+Dz4fOv867zrnOsc+DzrzPjCwgz4jOrs+GzrnPg863LCDOsc69zqzPgc+EzrfPg863LCDOvM61z4TOsc+Gzr/Pgc6sIM6xz4DOv867zrHOss+Ozr0sIM66z4TOuy4gzrTPhc69zrHPhM+Mz4TOt8+EzrXPgiDPhM65z4Igzr/PgM6/zq/Otc+CIM+Az4HOv8+Dz4bOrc+BzrXOuSDPhM6/IHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiDOus6xzrkgz4TOvyB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIM6XIM61z4bOsc+BzrzOv86zzq4gzrTOtc69IM6tz4fOtc65IM+Azr/PhM6tIM+Az4HPjM+DzrLOsc+Dzrcgzr/Pjc+EzrUgzrrPgc6xz4TOrM61zrkgz4TOsSDOus61z4bOrM67zrHOuc6xIM+Ez4nOvSDPh8+BzrfPg8+Ez47OvS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gzpcgzrXPhs6xz4HOvM6/zrPOriDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzq3Ovc6xIM68zr/Ovc+Ezq3Ou86/IM6xz4PPhs6xzrvOtc6vzrHPgiDOsc+Az4wgz4TOt869IM+AzrvOtc+Fz4HOrCDPhM6/z4Ugz4TOtc+BzrzOsc+EzrnOus6/z40gz4TOv8+FIM+Hz4HOrs+Dz4TOtywgzrzOtSDPhM6xIM65zrTOuc+Jz4TOuc66zqwgzrrOu861zrnOtM65zqwgzr3OsSBcXFwiz4bOuc67zr/Ovs61zr3Ov8+Nzr3PhM6xzrlcXFwiIM+Ezr/PgM65zrrOrCDPh8+Jz4HOr8+CIM+Azr/PhM6tIM69zrEgzrHPgM6/z4PPhM6tzrvOu86/zr3PhM6xzrkgz4POtSDOv8+Azr/Ouc6/zrTOrs+Azr/PhM61IM60zrnOsc66zr/OvM65z4PPhM6uLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOsc+AzrvPjCDOus6xzrkgzrXOu866z4XPg8+EzrnOus+MIM+AzrXPgc65zrLOrM67zrvOv869IM+Hz4HOrs+DzrfPgiDOus6xzrkgzrXOvM+AzrXOuc+Bzq/Osc+CLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LCDOlyDOtc+GzrHPgc68zr/Os86uIM60zrXOvSDOuM6xIM62zrfPhM6uz4POtc65IM+Azr/PhM6tIM+Az4HOv8+Dz4nPgM65zrrOrc+CIM+AzrvOt8+Bzr/Phs6/z4HOr861z4IuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIs6ozq7Phs65z4POtSBnb29kLWthcm1hIM6zzrnOsSB3aXRuZXNzXCIsXG5cdFwiQUJPVVRfOVwiOiBcIs6Vz4DOuc66zr/Ouc69z4nOvc6vzrEvzqDOsc+BzrHPhM63z4HOrs+DzrXOuc+CXCIsXG5cdFwiQUJPVVRfMTBcIjogXCLOoM61z4HOuc+Dz4PPjM+EzrXPgc61z4Igz4DOu863z4HOv8+Gzr/Pgc6vzrXPgjpcIixcblx0XCJSRU1PVkVcIjogXCLOkc+Azr/OvM6szrrPgc+Fzr3Pg863XCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLOlc+Azr/PgM+EzrXOr86xIM6RzrPOv8+BzqzPglwiLFxuXHRcIlBSSUNFXCI6IFwizqTOuc68zq5cIixcblx0XCJBTU9VTlRcIjogXCLOoM6/z4PPjFwiLFxuXHRcIlRPVEFMXCI6IFwizqPPjc69zr/Ou86/XCIsXG5cdFwiTk9PUkRFUlNcIjogXCLOlM61zr0gz4XPgM6sz4HPh86/z4XOvSDOsc69zr/Ouc+Hz4TOrc+CIM61zr3PhM6/zrvOrc+CIM6zzrnOsVwiLFxuXHRcIkRBVEVcIjogXCLOl868zrXPgc6/zrzOt869zq/OsVwiLFxuXHRcIkJVWVwiOiBcIs6RzrPOv8+BzqxcIixcblx0XCJTRUxMXCI6IFwizqDPjs67zrfPg863XCIsXG5cdFwiT1BFTlwiOiBcIs6Gzr3Ov865zrPOvM6xXCIsXG5cdFwiSElTVE9SWVwiOiBcIs6Zz4PPhM6/z4HOuc66z4xcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIs6Rzr3Osc+DzrrPjM+AzrfPg863XCIsXG5cdFwiRk9MTE9XRURcIjogXCLOkc66zr/Ou86/z4XOuM61zq/PglwiLFxuXHRcIlVORk9MTE9XXCI6IFwizpzOtyDOsc66zr/Ou86/z4XOuM61zq/PglwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIs6RzrrOv867zr/Phc64zrXOr8+CXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwizqPOtSDOsc66zr/Ou86/z4XOuM6/z43OvVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLOqM6szr7OtSDPgM6/zrnOv865IM+DzrUgzrHOus6/zrvOv8+FzrjOv8+Nzr1cIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwizqjOrM6+zrUgz4DOv865zr/Phc+CIM6xzrrOv867zr/Phc64zrXOr8+CXCIsXG5cdFwiQllcIjogXCLOsc+Az4xcIixcblx0XCJJTlwiOiBcIs+DzrVcIixcblx0XCJNRU5VXCI6IFwizprOsc+EzqzOu86/zrPOv8+CIM61z4DOuc67zr/Os8+Ozr1cIixcblx0XCJCT09LTUFSS1wiOiBcIs6jzrXOu865zrTOv860zrXOr866z4TOt8+CXCIsXG5cdFwiUkVCTE9HXCI6IFwizpHOvc6xzrTOt868zr/Pg86vzrXPhc+DzrdcIixcblx0XCJVUFZPVEVcIjogXCLOmM61z4TOuc66zq4gz4jOrs+Gzr/PglwiLFxuXHRcIkRPV05WT1RFXCI6IFwizpHPgc69zrfPhM65zrrOriDPiM6uz4bOv8+CXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIs6Vz4DOsc69zq3Phs61z4HOtSDOkc+Bzr3Ot8+EzrnOus6sLc+IzrfPhs65z4POvM6tzr3Ov1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwizpXPgM6xzr3Orc+GzrXPgc61IM6YzrXPhM65zrrOrC3PiM63z4bOuc+DzrzOrc69zr9cIixcblx0XCJSRVBMWVwiOiBcIs6Rz4DOrM69z4TOt8+DzrdcIixcblx0XCJFRElUXCI6IFwizpXPgM61zr7Otc+BzrPOsc+Dzq/OsVwiLFxuXHRcIlBPU1RfMVwiOiBcIs6jz43Pgc61IM6xz4HOuc+Dz4TOtc+Bzqwgz4TOsSDPg8+Hz4zOu865zrEgzrPOuc6xIM69zrEgzrTOtc65z4IgzrXPgM65zrvOv86zzq3PglwiLFxuXHRcIlBPU1RfMlwiOiBcIs6RzrrOv8+NzrzPgM6xIM+EzrEgz4PPh8+MzrvOuc6xIM6zzrnOsSDOvc6xIM60zrXOuc+CIM+Fz4DPjC3Pg8+Hz4zOu865zrFcIixcblx0XCJPUFRJT05TXCI6IFwizpXPgM65zrvOv86zzq3PglwiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIs6Rzr3Osc60zrfOvM6/z4POr861z4XPg863IM6xz4DPjFwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIs6kzq/PgM6/z4TOsSDOtc60z44sIM6xzrrPjM68zrEuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIs6UzrnOsc64zq3Pg865zrzOsVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIM60zrnOsc+Az4HOsc6zzrzOsc+EzrXPjc+DzrnOvM61z4IgzrzOrM+BzrrOtc+CLCDPgM6/z4UgzrzPgM6/z4HOv8+Nzr0gzr3OsSDOvM61z4TOsc+GzrXPgc64zr/Pjc69IM6/z4DOv865zrHOtM6uz4DOv8+EzrUgz4PPhM65zrPOvM6uLiB7e3BsYXRmb3JtbmFtZX19IM68z4DOv8+Bzr/Pjc69IM69zrEgzrzOtc+EzrHPhM+BzrHPgM6/z43OvSDPg861IHt7cGxhdGZvcm1wb3dlcn19IM68zq3Pg8+JIM68zq/Osc+CIM60zrnOsc60zrnOus6xz4POr86xz4Igz4DOv8+FIM6/zr3Ov868zqzOts61z4TOsc65IHBvd2VyaW5nIHVwLiBcIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgzrzOrM+BzrrOtc+CIM61z4DOuc+Bz4HOv86uz4Igz4DOv8+FIM68z4DOv8+Bzr/Pjc69IM69zrEgzrHPgM6/zrrPhM6uz4POv8+Fzr0gz4DOtc+BzrnPg8+Dz4zPhM61z4HOtyDOtM+Nzr3Osc68zrcsIM66z4HOsc+Ez47Ovc+EzrHPgiDPhM65z4IgzrzOsc66z4HOv8+Az4HPjM64zrXPg868zrEgzrrOsc65IM+IzrfPhs6vzrbOv869z4TOsc+CIM6xzr3Osc+Bz4TOrs+DzrXOuc+CLiDOjM+DzrXPgiDPgM61z4HOuc+Dz4PPjM+EzrXPgc61z4Igzq3Ph861zrkgz4PPhM63zr0gzrrOsc+Ezr/Ph86uIM+Ezr/PhSDOus6sz4DOv865zr/Pgiwgz4TPjM+Dzr8gz4DOtc+BzrnPg8+Dz4zPhM61z4HOvyDOvM+Azr/Pgc61zq8gzr3OsSDOtc+AzrfPgc61zqzPg861zrkgz4TOuc+CIM6xzrzOv865zrLOrc+CIM6szrvOu8+Jzr0gzqzOu867zrEgzrrOsc65IM+EzrnPgiDOtM65zrrOrc+CIM+Ezr/PhS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCLOnM6sz4HOus61z4IgzrHOvs6vzrHPgiDPgM61z4HOr8+Azr/PhSB7e3BsYXRmb3Jtc3VuaXR9fSDPhM6/z4Uge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLOkc6+zq/OsSDOus6xz4TOrCDOtc66z4TOr868zrfPg863IFwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIs6XIM6xzr7Or86xIM66zrHPhM6sIM61zrrPhM6vzrzOt8+DzrcgzrXOr869zrHOuSDOss6xz4POuc+DzrzOrc69zrcgz4PPhM6/zr0gzrXOss60zr/OvM6xzrTOuc6xzq/OvyDOvM6tz4POvyDPjM+Bzr8gz4TOv8+Fe3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwizpnPg8+Ezr/Pgc65zrrPjCDOo8+Fzr3Osc67zrvOsc6zz47OvVwiLFxuXHRcIlBPU1RJTkdcIjogXCLOkc69zqzPgc+EzrfPg863XCIsXG5cdFwiUFJPRklMRV81XCI6IFwizp8gzrrPic60zrnOus+Mz4IgzrTOt868zr/Pg86vzrXPhc+DzrfPgiDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xIM60zrfOvM6/z4POuc61z43Pg861zrnPgiDOus6xzrkgz4TOt869IM60z4XOvc6xz4TPjM+EzrfPhM6xIM6xz4DPjM60zr/Pg863z4Igz4jOrs+Gzr/PhS4gzpjOsSDPgM+Bzq3PgM61zrkgzr3OsSDOtc6vzr3Osc65IM60zrnOsc+Gzr/Pgc61z4TOuc66z4zPgiDOsc+Az4wgz4TOv869IFxcXCLOtc69zrXPgc6zz4xcXFwiIM66z4nOtM65zrrPjCDOus6xzrkgz4TOvyDOus+JzrTOuc66z4wgXFxcIs65zrTOuc6/zrrPhM63z4POr86xz4JcXFwiLlwiLFxuXHRcIk9XTkVSXCI6IFwizpnOtM65zr/Ous+Ezq7PhM63z4JcIixcblx0XCJQUk9GSUxFXzZcIjogXCLOpM6/IM66zrvOtc65zrTOryDOuc60zrnOv866z4TOt8+Dzq/Osc+CIM61zq/Ovc6xzrkgz4TOvyDOus61zr3PhM+BzrnOus+MIM66zrvOtc65zrTOryDPhM6/z4UgzrvOv86zzrHPgc65zrHPg868zr/PjSDOus6xzrkgzrHPgM6xzrnPhM61zq/PhM6xzrkgzrPOuc6xIM69zrEgzrHOu867zqzOvs61zrkgz4zOu86xIM+EzrEgz4XPgM+MzrvOv865z4DOsSDOus67zrXOuc60zrnOrC4gzpjOsSDPgM+Bzq3PgM61zrkgzr3OsSDOus+BzrHPhM6sz4TOtSDOtc66z4TPjM+CIM+Dz43Ovc60zrXPg863z4Igz4TOvyDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOryDOriDOus+JzrTOuc66z4wgz4TOv8+FIM66zrvOtc65zrTOuc6/z40gzrnOtM65zr/Ous+EzrfPg86vzrHPgiDPjM+Dzr8gzrHPhc+Ez4wgzrXOr869zrHOuSDOtM+Fzr3Osc+Ez4zOvS5cIixcblx0XCJBQ1RJVkVcIjogXCLOlc69zrXPgc6zz4xcIixcblx0XCJQUk9GSUxFXzdcIjogXCLOpM6/IM61zr3Otc+BzrPPjCDOus67zrXOuc60zq8gz4fPgc63z4POuc68zr/PgM6/zrnOtc6vz4TOsc65IM6zzrnOsSDOtc68zrLOrM+DzrzOsc+EzrEgzrrOsc65IM61zr3PhM6/zrvOrc+CIM6xzrPOv8+BzrHPgM+JzrvOt8+DzrnPjs69IM+Dz4TOvyDOtc+Dz4nPhM61z4HOuc66z4wgzrHOvc+EzrHOu867zrHOus+Ezq7Pgc65zr8uXCIsXG5cdFwiTUVNT1wiOiBcIs6azrvOtc65zrTOuSAtIM6czrfOvc+FzrzOrM+Ez4nOvVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIs6kzr8gzprOu861zrnOtM6vIM6czrfOvc+FzrzOrM+Ez4nOvSDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xIM60zrfOvM65zr/Phc+BzrPOr86xIM66zrHOuSDOsc69zqzOs869z4nPg863IM68zrfOvc+FzrzOrM+Ez4nOvS5cIixcblx0XCJCTE9HXCI6IFwizpnPg8+Ezr/Ou8+MzrPOuc6/XCIsXG5cdFwiUE9TVFNcIjogXCLOkc69zrHPgc+Ezq7Pg861zrnPglwiLFxuXHRcIlJFUExJRVNcIjogXCLOkc+AzrHOvc+Ezq7Pg861zrnPglwiLFxuXHRcIldBTExFVFwiOiBcIs6gzr/Pgc+Ezr/Phs+MzrvOuVwiLFxuXHRcIlRBR1wiOiBcIs6Vz4TOuc66zq3PhM6xXCIsXG5cdFwiVVNFUlwiOiBcIs6nz4HOrs+Dz4TOt8+CXCIsXG5cdFwiQ0xPU0VcIjogXCLOms67zrXOr8+DzrnOvM6/XCIsXG5cdFwiVE9cIjogXCLOo861XCIsXG5cdFwiQVNTRVRcIjogXCLOms61z4bOrM67zrHOuc6/XCIsXG5cdFwiU0VORFwiOiBcIs6Rz4DOv8+Dz4TOv867zq5cIixcblx0XCJTRUNVUklUWVwiOiBcIs6Rz4PPhs6szrvOtc65zrFcIixcblx0XCJBVkFJTEFCTEVcIjogXCLOlM65zrHOuM6tz4POuc68zr9cIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIs6UzrfOvM+Mz4POuc6/IM68zq7Ovc+FzrzOsVwiLFxuXHRcIlRPX0RFU0NcIjogXCLOp8+Bzq7Pg8+EzrfPgiDPgC7PhyBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCLOms+JzrTOuc66z4zPgiBQSU5cIixcblx0XCJQSU5fVEVYVFwiOiBcIs6az4nOtM65zrrPjM+CIFBJTiDPg861IM6yzr/Ot864zqzOtc65IM69zrEgzrHPg8+GzrHOu86vz4POtc65z4Igz4TOt869IM61z4bOsc+BzrzOv86zzq4gzrrOsc65IM+EzrEgzrTOtc60zr/OvM6tzr3OsSDPg86/z4UuIDxici8+PGJyLz48Yj7Oo863zrzOtc6vz4nPg863OjwvYj4gzobPgM6xzr4gzrrOsc65IM61zr3Otc+BzrPOv8+Azr/Ouc63zrjOtc6vLCDOrc+HzrXOuc+CIG1heCA0IM+Az4HOv8+Dz4DOrM64zrXOuc61z4IgzrPOuc6xIM6+zrXOus67zrXOr860z4nOvM6xLiDOkc69IM6+zrXPh86sz4POtc65z4Igz4TOv869IM66z4nOtM65zrrPjCBQSU4gzq4gzrHPgM6/z4TPjc+HzrXOuc+CLCDOtyDOtc+GzrHPgc68zr/Os86uIM64zrEgzrrOsc+EzrHPgc6zzq7Pg861zrkgz4TOsSDPg8+Ezr/Ouc+HzrXOr86xIM61zrnPg8+MzrTOv8+FIM+Ezr/PhSDPh8+Bzq7Pg8+EzrcuzpzPgM6/z4HOtc6vz4Igzr3OsSDOvs6xzr3OrCDPg8+Fzr3OtM61zrjOtc6vz4IgzrrOsc65IM69zrEgz4PPhc69zrXPh86vz4POtc65z4Igzr3OsSDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PgiDPhM63zr0gzrXPhs6xz4HOvM6/zrPOri5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwizpXOuc60zr/PgM6/zrnOrs+DzrXOuc+CXCIsXG5cdFwiVk9URV9URVhUXCI6IFwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4Igz4jOt8+Gzq/Pg861zrkgz4TOt869IM6xzr3OrM+Bz4TOt8+Dzrcgz4POv8+FLiA8YnIvPiA8Yj7Oo863zrzOtc6vz4nPg863OjwvYj4gzp/OuSDOtc65zrTOv8+Azr/Ouc6uz4POtc65z4Igz4PPhc68z4DOtc+BzrnOu86xzrzOss6szr3Ov8+Fzr0gz4TOt869IM6yzrHPgc+Nz4TOt8+EzrEgz4TOt8+CIM+Izq7Phs6/z4UgzrrOsc64z47PgiDOtc+Azq/Pg863z4Igz4POtSDOrc66z4TOsc66z4TOsSDOvM63zr3Pjc68zrHPhM6xLiAozrjOtc+EzrnOus6uIM+Izq7Phs6/LCDOsc+Bzr3Ot8+EzrnOus6uIM+Izq7Phs6/LCDOsc+Az4wtz4jOrs+GzrnPg863KS5cIixcblx0XCJWT1RFXCI6IFwizqjOrs+Gz4nOvVwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIs6YzrEgzrvOrM6yzrXOuc+CIM61zrnOtM6/z4DOv86vzrfPg863IM+Mz4TOsc69IM66zqzPgM6/zrnOv8+CIM+Dz4fOv867zrnOrM+DzrXOuSDOsc69zrHPgc+Ezq7Pg861zrnPgiDOtyDPg8+Hz4zOu865zrEgz4POv8+FITxici8+IDxiPs6jzrfOvM61zq/Pic+Dzrc6PC9iPiDOn865IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDPg8+FzrzPgM61z4HOuc67zrHOvM6yzqzOvc6/zr3PhM6xzrkgzrHOus+MzrzOsSDOus6xzrkgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4IgPGI+zrXPgM61zr7Otc+BzrPOsc+Dz4TOtc6vPC9iPiDPhM6xIM+Dz4fPjM67zrnOsSDPhM6/z4UuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIs6jz4fOv867zq/Pic69XCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLOmM6xIM67zqzOss61zrnPgiDOtc65zrTOv8+Azr/Or863z4POtyDPjM+EzrHOvSDOus6sz4DOv865zr/PgiDPg861IM6xzrrOv867zr/Phc64zq7Pg861zrkgzq4gz4DOrM+IzrXOuSDOvc6xIM+DzrUgzrHOus6/zrvOv8+FzrjOtc6vLlwiLFxuXHRcIk1FTlRJT05TXCI6IFwizpXPgM65z4POt868zqzOvc+DzrXPic69XCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIs6YzrEgzrvOrM6yzrXOuc+CIM61zrnOtM6/z4DOv86vzrfPg863IM+Mz4TOsc69IM66zqzPgM6/zrnOv8+CIM+DzrUgzrHOvc6xz4bOrc+BzrXOuSDPg861IM6xzr3OrM+Bz4TOt8+Dzrcvz4PPh8+MzrvOuc+MIM+Ezr/PhS5cIixcblx0XCJSRVNURUVNXCI6IFwizpHOvc6xzrTOt868zr/Pg865zrXPjc+DzrXPic69XCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwizpjOsSDOu86szrLOtc65z4IgzrXOuc60zr/PgM6/zq/Ot8+Dzrcgz4zPhM6xzr0gzrrOrM+Azr/Ouc6/z4IgzrHOvc6xzrTOt868zr/Pg865zrXPjc+DzrXOuSDOsc69zqzPgc+EzrfPg86uIM+Dzr/PhS5cIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIs6hz4XOuM68zq/Pg861zrnPglwiLFxuXHRcIlZPVElOR1wiOiBcIs6ozrfPhs6/z4bOv8+Bzq/OsVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiXFxcIs6SzqzPgc6/z4JcXFwiIM+Izq7Phs6/z4Ugzq4gz4DOv8+Dzr/Pg8+Ez4wgzrXPgM63z4HOtc6szrbOtc65IM+EzrfOvSDOuc+Dz4fPjc+CIM+Izq7Phs6/z4Ugz4PPhM63zr0gzrXPhs6xz4HOvM6/zrPOriwgz47Pg8+EzrUgzr3OsSDPgc+FzrjOvM6vzrbOtc65z4Igz4TOuc+CIM6xz4DOv867zrHOss6tz4Igz4jOrs+Gz4nOvSA8YnIvPjxici8+PGI+zqPOt868zrXOr8+Jz4POtzo8L2I+IM6Rz4XPhM+MIM64zrEgzrHOu867zqzOvs61zrkgz4TOvyBcXFwizrLOrM+Bzr/PglxcXCIvz4DOv8+Dzr/Pg8+Ez4wgz4jOrs+Gzr/PhSDOs865zrEgzr3OsSDPiM63z4bOr8+DzrXOuc+CIM61z4DOr8+DzrfPgiDOsc+Bzr3Ot8+EzrnOus6sIM66zrHOuSDOuM6xIM65z4PPh8+NzrXOuSDPgM6xzr3PhM6/z40gz4PPhM63zr0gzrXPhs6xz4HOvM6/zrPOrlwiLFxuXHRcIlNFUlZFUlwiOiBcIs6UzrnOsc66zr/OvM65z4PPhM6uz4JcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIs6gz4HOv8+EzrXOuc69z4zOvM61zr3OsVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIs6Rz4DOv864zq7Ous61z4XPg863IM6RzrvOu86xzrPPjs69XCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCLOoM67zrfPgc6/z4bOv8+Bzq/Otc+CIM+IzrfPhs6/z4bPjM+Bzr/PhVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIs6azrHOu8+Oz4Igzq7Pgc64zrXPgiDOvs6xzr3OrCFcIixcblx0XCJMT0dJTl8xXCI6IFwizqPPhc69zrTOrc+Dzr/PhSDOvM61IM+Ezr8gz4zOvc6/zrzOsSDPh8+Bzq7Pg8+EzrcgzrrOsc65IM66z4nOtM65zrrPjCDOs865zrEgzr3OsSDPg8+Fzr3Otc+Hzq/Pg861zrnPgi5cIixcblx0XCJMT0dJTl8yXCI6IFwizqTOvyDOus67zrXOuc60zq8gzrTOt868zr/Pg86vzrXPhc+DzrfPgiDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xIM6xzr3OrM+Bz4TOt8+DzrcsIM+Dz4fOv867zrnOsc+DzrzPjCwgz4jOrs+Gzr8gzrrOsc65IM+EzrfOvSDOtM+Fzr3Osc+Ez4zPhM63z4TOsSDOvc6xIM6xzrrOv867zr/Phc64zq7Pg861zrnPgiDOus6sz4DOv865zr/OvS5cIixcblx0XCJMT0dJTl8zXCI6IFwizqTOvyDOtc69zrXPgc6zz4wgzrrOu861zrnOtM6vIM+Hz4HOt8+DzrnOvM6/z4DOv865zrXOr8+EzrHOuSDOs865zrEgzrzOtc+EzrHPhs6/z4HOrc+CIM66zrHOuSDOsc67zrvOsc6zzq4gz4bPic+Ezr/Os8+BzrHPhs6vzrHPgiDPhM6/z4Ugz4DPgc6/z4bOr867LlwiLFxuXHRcIkxPR0lOXzRcIjogXCLOpM6xIM+Dz4TOv865z4fOtc6vzrEgz4fPgc6uz4PPhM63IM6xz4DOv864zrfOus61z43Ov869z4TOsc65IM+Dz4TOtyDPg8+Fz4POus61z4XOriDPhM6/z4DOuc66zqwuIM6azrHPhM6sIM+EzrfOvSDOtM65zqzPgc66zrXOuc6xIM6xz4DOv8+Dz43Ovc60zrXPg863z4Igz4TOsSDPg8+Ezr/Ouc+HzrXOr86xIM60zrnOsc6zz4HOrM+Gzr/Ovc+EzrHOuS5cIixcblx0XCJET05UX0hBVkVcIjogXCLOlM61zr0gzq3Ph861zrnPgiDOu86/zrPOsc+BzrnOsc+DzrzPjD9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIs6azqzOvc61IM61zrPOs8+BzrHPhs6uIM+Ez47Pgc6xXCIsXG5cdFwiQ0FOQ0VMXCI6IFwizpHOus+Nz4HPic+DzrdcIixcblx0XCJBRFZBTkNFRFwiOiBcIs6TzrnOsSDPgM+Bzr/Ph8+Jz4HOt868zq3Ovc6/z4XPglwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLOlc69zrXPgc6zz4wgzrnOtM65z4nPhM65zrrPjCDOus67zrXOuc60zq9cIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIs6ZzrTOuc+Jz4TOuc66z4wgzrrOu861zrnOtM6vIM60zrfOvM6/z4POr861z4XPg863z4JcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIs6az4XPgc6vz4nPgi/OoM+Bz4nPhM61z43Pic69IM66z4nOtM65zrrPjM+CXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLOjM69zr/OvM6xIM6nz4HOt8+Dz4TOt1wiLFxuXHRcIkNBUkRfVklFV1wiOiBcIs6gz4HOv86yzr/Ou86uIM+DzrUgzprOsc+Bz4TOrc67zrXPglwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIs6jz4XOvc61z4DPhM+FzrPOvM6tzr3OtyDOoM+Bzr/Oss6/zrvOrlwiLFxuXHRcIlNFQVJDSFwiOiBcIs6Rzr3Osc62zq7PhM63z4POt1wiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwizp7Otc66zq/Ovc6xIM6xzr3OrM+Bz4TOt8+DzrdcIixcblx0XCJSRVBMWVRPXCI6IFwizpHPgM6szr3PhM63z4POtSDPg861XCIsXG5cdFwiUE9TVFwiOiBcIs6Rzr3OrM+Bz4TOt8+DzrVcIixcblx0XCJQUkVWSUVXXCI6IFwizqDPgc6/zrXPgM65z4POus+Mz4DOt8+DzrdcIixcblx0XCJERUZBVUxUXCI6IFwizqDPgc6/zrXPgM65zrvOv86zzq4gNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIs6Rz43Ovs63z4POtyDOmc+Dz4fPjc6/z4IgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwizpHPgM+Mz4HPgc65z4jOtyDOkc+Azr/Ou86xzrLPjs69XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCLOkc6gzp/OmM6JzprOlc6lzqPOlSDOk86ZzpEgzpHOoc6Tzp/OpM6VzqHOkVwiLFxuXHRcIkNMRUFSXCI6IFwizprOkc6YzpHOoc6ZzqPOnM6RXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwizpHOvc6sz4HPhM63z4POtyDPgM61z4HOuc61z4fOv868zq3Ovc6/z4VcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCLOo8+Hzr/Ou86vzrHPg861IM+AzrXPgc65zrXPh8+MzrzOtc69zr9cIixcblx0XCJUSVRMRVwiOiBcIs6kzq/PhM67zr/PglwiLFxuXHRcIlRBR1NcIjogXCLOlc+EzrnOus6tz4TOtc+CXCIsXG5cdFwiTk9UX01BVENIXCI6IFwizpTOlSDOo86lzpzOoM6KzqDOpM6VzplcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIs6Vz4DOuc6yzrXOss6xzq/Pic+DzrUgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwizpvOkc6dzpjOkc6jzpzOlc6dzp9cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLOhs69zr/Ouc6+zrUgzpHOvc6sz4HPhM63z4POt1wiLFxuXHRcIlNFVF9QSU5cIjogXCLOjM+BzrnPg861IFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIs6VzrnPg86xzrPPic6zzq4gUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwizpXOr8+DzrHOuSDPg86vzrPOv8+Fz4HOv8+CP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwizpcgzrHOvc6xzrTOt868zr/Pg86vzrXPhc+DzrcgzrXOr869zrHOuSDOvM63IM6xzr3Osc+Dz4TPgc6tz4jOuc68zrcsIM64zq3Ou861zrnPgiDOvc6xIM+Dz4XOvc61z4fOr8+DzrXOuc+CP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIs6bzqzOuM6/z4IgzrzOtc+EzqzOtM6/z4POt8+CLCDPgM+Bzr/Pg8+AzqzOuM63z4POtSDOvs6xzr3OrCFcIixcblx0XCJTVUNDRVNTXCI6IFwizpXPgM65z4TPhc+Hzq3PglwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwizpHOvc6xzrTOt868zr/Pg865zrXPhc68zq3Ovc63IM6xzr3OrM+Bz4TOt8+DzrchXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIs6XIM+Dz43Ovc60zrXPg863IM6xz4DOrc+Ez4XPh861ISDOoM6xz4HOsc66zrHOu8+OIM61zr7Osc66z4HOuc6yz47Pg8+EzrUgzrHOvSDPg8+Fzr3OtM61zrjOrs66zrHPhM61IM68zrUgz4TOv869IM66z4XPgc6vz4nPgiDOus+JzrTOuc66z4wgzq4gzrTPjs+DzrHPhM61IM+Ezr8gzrnOtM65z4nPhM65zrrPjCDOus67zrXOuc60zq8gzrTOt868zr/Pg86vzrXPhc+DzrfPgiDPjM+EzrHOvSDOtc+AzrnOu86tzr7Osc+EzrUgz4PPjc69zrTOtc+DzrcgzrPOuc6xIM+Az4HOv8+Hz4nPgc63zrzOrc69zr/Phc+CLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIs6XIM+Dz43Ovc60zrXPg863IM6xz4DOrc+Ez4XPh861ISDOoM6xz4HOsc66zrHOu8+OIM61zr7Osc66z4HOuc6yz47Pg8+EzrUgzrHOvSDPg8+Fzr3OtM61zrjOrs66zrHPhM61IM68zrUgz4TOv869IM66z4XPgc6vz4nPgiDOus+JzrTOuc66z4wgzq4gzrTPjs+DzrHPhM61IM+Ezr8gzrXOvc61z4HOs8+MIM66zrvOtc65zrTOryDOtM63zrzOv8+Dzq/Otc+Fz4POt8+CIM+Mz4TOsc69IM61z4DOuc67zq3Ovs6xz4TOtSDPg8+Nzr3OtM61z4POtyDOs865zrEgz4DPgc6/z4fPic+BzrfOvM6tzr3Ov8+Fz4IuXCIsXG5cdFwiV0FSTklOR1wiOiBcIs6gz4HOv861zrnOtM6/z4DOv86vzrfPg863XCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIs6ozq7Phs65z4POtSDOs865zrEgd2l0bmVzc1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwizqjOt8+Gzq/Pg8+EzrfOus61IM6zzrnOsSB3aXRuZXNzXCIsXG5cdFwiQUdPXCI6IFwiz4DPgc65zr1cIixcblx0XCJGUk9NX05PV1wiOiBcIs6xz4DPjCDPhM+Oz4HOsVwiLFxuXHRcIlNFQ1NcIjogXCLOtM61z4XPhC5cIixcblx0XCJBX01JTlwiOiBcIs+Ezr8gzrvOtc+Az4TPjFwiLFxuXHRcIk1JTlNcIjogXCLOu861z4DPhM6sXCIsXG5cdFwiQU5fSE9VUlwiOiBcIs68zq/OsSDPjs+BzrFcIixcblx0XCJIT1VSU1wiOiBcIs+Oz4HOtc+CXCIsXG5cdFwiQV9EQVlcIjogXCLOvM6vzrEgzrfOvM6tz4HOsVwiLFxuXHRcIkRBWVNcIjogXCLOvM6tz4HOtc+CXCIsXG5cdFwiQV9NT05USFwiOiBcIs6tzr3OsSDOvM6uzr3OsVwiLFxuXHRcIk1PTlRIU1wiOiBcIs68zq7Ovc61z4JcIixcblx0XCJBX1lFQVJcIjogXCLOrc69zrEgz4fPgc+Mzr3Ov1wiLFxuXHRcIllFQVJTXCI6IFwiz4fPgc+Mzr3Ouc6xXCIsXG5cdFwiTUlOX1JFQURcIjogXCLOu861z4DPhM6sIM6xzr3OrM6zzr3Pic+DzrfPglwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCLOqM6uz4bOuc+DzrUgzrHPgc69zrfPhM65zrrOrCDOriDOus6szr3OtSBGbGFnXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwizpHPgM6/zrjOsc69zqzPhM65z4POtSDOps+Jz4TOv86zz4HOsc+Gzq/OsVwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwizpXPgM6tzrvOtc6+zrUgzqbPic+Ezr/Os8+BzrHPhs6vzrFcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIs6azrHOuM+Mz4HOuc+DzrUgz4DPgc6/z4POsc+BzrzOv8+DzrzOrc69zr8gVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCLOlc65z4POrs6zzrHOs861IM6mz4nPhM6/zrPPgc6xz4bOr86xXCIsXG5cdFwiRVJST1JcIjogXCLOm86szrjOv8+CXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwizpvOrM64zr/PgiDOsc+Azr/Pg8+Ezr/Ou86uz4JcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwizprOrM68zrXPgc6xIM6RzrrPhc+Bz47OuM63zrrOtVwiLFxuXHRcIlNFVF9VUkxcIjogXCLOms6xzrjPjM+BzrnPg861IFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCLOhs68zrXPg86/z4Igz4PPjc69zrTOtc+DzrzOv8+CIM6zzrnOsSDPhM63zr0gz4bPic+Ezr/Os8+BzrHPhs6vzrFcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIs6kzr8gz4PPh8+MzrvOuc6/IM+Fz4DOv86yzrvOrs64zrfOus61IVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwizpcgzrTOuc6xzrPPgc6xz4bOriDPg8+Hzr/Ou86vz4nOvSDOtc6vzr3Osc65IM68zrcgzrHOvc6xz4PPhM+Bzq3PiM65zrzOty4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIs6UzrnOsc6zz4HOsc68zrzOrc69zr8gz4PPh8+MzrvOuc6/XCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLOkc+Azr/Pg8+Ezr/Ou86uIM6mz4nPhM6/zrPPgc6xz4bOr86xz4JcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwizpHPgM6/z4PPhM6/zrvOriDOn867zr/Ous67zrfPgc+OzrjOt866zrVcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwizpHPgM6/z4PPhM6/zrvOriDOkc+Azq3PhM+Fz4fOtVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIs6fIM66z4nOtM65zrrPjM+CIM6uIM+Ezr8gz4zOvc6/zrzOsSDOu86/zrPOsc+BzrnOsc+DzrzOv8+NIM6uz4TOsc69IM67zrHOvc64zrHPg868zq3Ovc6/XCIsXG5cdFwiSU5GT1wiOiBcIs6gzrvOt8+Bzr/Phs6/z4HOr861z4JcIixcblx0XCJRUl9URVhUXCI6IFwizqTOv8+Azr/OuM6tz4TOt8+DzrUgzq3Ovc6xIFFSIM66z4nOtM65zrrPjCDPg8+EzrfOvSDPhM6/z4DOv864zrXPg86vzrEgz4POrM+Bz4nPg863z4JcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCLOlc6+zrHOus+Bzq/Oss+Jz4POtSDPjM+Ezrkgzq3Ph861zrnPgiDOtM65zrHOuM6tz4POuc68zrEgzrrOtc+GzqzOu86xzrnOsSDOs865zrEgz4PPhc69zrHOu867zrHOs86uIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLOnyDPh8+Bzq7Pg8+EzrfPgiDPgM6/z4Ugz4DPgc6/z4PPgM6xzrjOtc6vz4Igzr3OsSDOvM61z4TOsc+Gzq3Pgc61zrnPgiDOus61z4bOrM67zrHOuc6xLCDOtM61zr0gz4XPgM6sz4HPh861zrkhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIs6Vzq/Pg8+EzrUgz4POr86zzr/Phc+Bzr/PgiDPjM+EzrkgzrjOrc67zrXPhM61IM69zrEgzrrOrM69zrXPhM61IM68zrXPhM6xz4bOv8+Bzqw/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwizpXPgM65zrLOtc6yzrHOr8+Jz4POt1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwizpcgz4PPhc69zrHOu867zrHOs86uIM68zrXPhM6xzrTPjM64zrfOus61XCIsXG5cdFwiRkVFRFwiOiBcIs6Rzr3Osc+Bz4TOrs+DzrXOuc+CIM6xz4DPjCDPh8+Bzq7Pg8+EzrXPgiDPgM6/z4UgzrHOus6/zrvOv8+FzrjOtc6vz4JcIixcblx0XCJUUkVORElOR1wiOiBcIs6UzrfOvM6/z4bOuc67zq3Pg8+EzrXPgc61z4IgzrHOvc6xz4HPhM6uz4POtc65z4JcIixcblx0XCJIT1RcIjogXCLOkc69zrHPgc+Ezq7Pg861zrnPgiDOvM61IM+Fz4jOt867zq4gzrTPgc6xz4PPhM63z4HOuc+Mz4TOt8+EzrFcIixcblx0XCJORVdcIjogXCLOoM+Bz4zPg8+GzrHPhM61z4IgzrHOvc6xz4HPhM6uz4POtc65z4JcIixcblx0XCJQUk9NT1RFRFwiOiBcIs6gz4HOv8+JzrjOv8+NzrzOtc69zrFcIixcblx0XCJWT1RFU1wiOiBcIs6SzqzPg863IM+Izq7Phs+Jzr1cIixcblx0XCJQQVlPVVRcIjogXCLOks6sz4POtyDOsc+Azr/OtM6/z4fPjs69XCIsXG5cdFwiQ09NTUVOVFNcIjogXCLOks6sz4POtyDPg8+Hzr/Ou86vz4nOvVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwizpTOt868zr/Phs65zrvOrc+Dz4TOtc+BzrXPgiDOsc69zrHPgc+Ezq7Pg861zrnPgiAzMCDOt868zrXPgc+Ozr1cIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCLOpM6xzr7Ouc69z4zOvM63z4POtyDOss6sz4POtzpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLOms+NzrrOu86/z4Igz4DOu863z4HPic68zq7PglwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCLOoM65zrjOsc69zq3PgiDOkc+Azr/OtM6/z4fOrc+CXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLOoM6xzrvOsc65z4zPhM61z4HOtc+CIM6Rz4DOv860zr/Ph86tz4JcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwizpHPgM6/zrTOv8+Hzq3PgiDOo8+FzrPOs8+BzrHPhs6tzrFcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLOkc+Azr/OtM6/z4fOrc+CIM6xz4DPjCBDdXJhdGlvblwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwizpcgzrHOvc6sz4HPhM63z4POtyDPhc+Azr/Oss67zq7OuM63zrrOtSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwizpHOvc6sz4HPhM63z4POtyDOs865zrEgzrzOtc67zrvOv869z4TOuc66zq4gzrrOv865zr3Ov8+Azr/Or863z4POtyFcIixcblx0XCJTQVZFRFwiOiBcIs6Rz4DOv864zrfOus61z43PhM63zrrOtVwiLFxuXHRcIkNMRUFSRURcIjogXCLOo86yzq7Pg8+EzrfOus61XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIs6azrHPhM6xz4jOt8+Gzq/Ots6/zr3PhM6xz4IgzrzOuc6xIM6xzr3OrM+Bz4TOt8+DzrcgzrzPgM6/z4HOtc6vIM69zrEgz4TOt8+CIM6xz4bOsc65z4HOrc+DzrXOuSDOsc68zr/Ouc6yzq3PgiDOus6xzrkgzr3OsSDPhM63zr0gzrrOrM69zrXOuSDOu865zrPPjM+EzrXPgc6/IM6/z4HOsc+Ezq4uPGJyPjxicj4gzpcgzrrOsc+EzrHPiM6uz4bOuc+DzrcgzrjOsSDOrc+Az4HOtc+AzrUgzr3OsSDPh8+BzrfPg865zrzOv8+Azr/Ouc61zq/PhM6xzrkgzrPOuc6xOiA8dWw+PGxpPs6Rz4DOrM+Ezrcgzq4gzrrOu86/z4DOriDPgM69zrXPhc68zrHPhM65zrrPjs69IM60zrnOus6xzrnPjs68zrHPhM+Jzr08L2xpPjxsaT7Opc6yz4HOuc+Dz4TOuc66zq4gzrPOu8+Oz4PPg86xIM66zrHOuSBUcm9sbGluZzwvbGk+PGxpPs6Vz4POus61zrzOvM6tzr3OtyDPhM6/z4DOv864zq3PhM63z4POtyDPg861IM67zqzOuM6/z4IgzrrOsc+EzrfOs86/z4HOr86xIM+AzrXPgc65zrXPh86/zrzOrc69zr/PhSDOriBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIs6kzr8gzrHOr8+EzrfOvM6xIM6tz4bPhM6xz4POtSDPg8+Ezr8gz4zPgc65zr8gz4TOv8+FLiDOlc67zq3Os86+z4TOtSDOrM67zrvOtc+CIM61z4TOuc66zq3PhM61z4IvzrrOsc+EzrfOs86/z4HOr861z4JcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCLOlyDOsc69zqzPgc+EzrfPg863IM6xz4DOv868zrHOus+Bz43Ovc64zrfOus61IM6xz4DPjCDPhM6/z4XPgiDPg861zrvOuc60zr/OtM61zq/Ous+EzrXPgiFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwizpcgzrHOvc6sz4HPhM63z4POtyDPgM+Bzr/Pg8+Ezq3OuM63zrrOtSDPg8+Ezr/Phc+CIM+DzrXOu865zrTOv860zrXOr866z4TOtc+CIVwiLFxuXHRcIlJFU0VUXCI6IFwizpXPgM6xzr3Osc+Gzr/Pgc6sIM6xz4HPh865zrrPjs69IM+Bz4XOuM68zq/Pg861z4nOvVwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwizpXPgM61zr7Otc+BzrPOsc+Dzq/OsSDOps+Jz4TOv86zz4HOsc+Gzq/Osc+CIM6gz4HOv8+Gzq/Ou1wiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwizpXPgM61zr7Otc+BzrPOsc+Dzq/OsSDPhs+Jz4TOv86zz4HOsc+Gzq/Osc+CIM+Az4HOv8+Gzq/Ou1wiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIs6gzrHPgc6xzrrOsc67z44gzrTPjs+DzrUgzpXOvc61z4HOs8+ML0FjdGl2ZSDOuc60zrnPic+EzrnOus+MIM66zrvOtc65zrTOryDOtc6szr0gzrXPgM6tzrvOtc6+zrXPgiDPg8+Nzr3OtM61z4POtyDOs865zrEgz4DPgc6/z4fPic+BzrfOvM6tzr3Ov8+Fz4IhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwizpHPhc+Ez4wgzrjOsSDOus6szr3Otc65IM61z4DOsc69zrHPhs6/z4HOrCDPhM63z4Igz4bPic+Ezr/Os8+BzrHPhs6vzrHPgiDPhM6/z4Ugz4DPgc6/z4bOr867XCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwizpHPhc+Ez4wgzrjOsSDOtc+AzrHOvc6xz4bOrc+BzrXOuSDPhM63zr0gzrXOuc66z4zOvc6xIM+Hz4HOrs+Dz4TOt1wiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwizpcgzrHOvc6xzrLOrM64zrzOuc+Dzrcgz4TOv8+FIM60zrnOsc66zr/OvM65z4PPhM6uIM6xz4DOsc65z4TOtc6vIM61z4DOsc69zrXOus66zq/Ovc63z4POtyFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwizp/OuSDPgc+FzrjOvM6vz4POtc65z4IgzrXOvc61z4HOs86/z4DOv865zq7OuM63zrrOsc69IVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIs6TzrvPjs+Dz4POtc+CXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLOlc60z44gzrzPgM6/z4HOtc6vz4Igzr3OsSDOsc67zrvOrM6+zrXOuc+CIM+EzrfOvSDOs867z47Pg8+DzrEgz4TOt8+CIM61z4bOsc+BzrzOv86zzq7Pgi5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwizpHPhc+Ezq4gzrcgzrvOtc65z4TOv8+Fz4HOs86vzrEgzrHPgM6xzrnPhM61zq8gzr8gz4fPgc6uz4PPhM63z4Igzr3OsSDOtc6vzr3Osc65IM+Dz4XOvc60zrXOtM61zrzOrc69zr/PgiDOvM61IM+Ezr/OvSDOus+Fz4HOuc+Oz4IgzrrPic60zrnOus+MIGFjdGl2ZS9wb3N0aW5nIGtleS7OoM6xz4HOsc66zrHOu8+OIM+Dz4XOvc60zq3Pg86/z4UgzrrOsc65IM+Az4HOv8+Dz4DOrM64zrfPg861IM6+zrHOvc6sLlwiLFxuXHRcIkdBTExFUllcIjogXCLOiM66zrjOtc+DzrdcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLOo8+Fzr3PhM61zrvOtc+Dz4TOrc+CIM68zrXPhM6sz4bPgc6xz4POt8+CXCIsXG5cdFwiU0hBUkVcIjogXCLOnM6/zrnPgc6sz4POv8+FXFxuXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLOkc6zzr/Pgc6sXCIsXG5cdFwiRVhDSEFOR0VcIjogXCLOkc69z4TOsc67zrvOsc66z4TOrs+BzrnOv1wiLFxuXHRcIkRSQUZUU1wiOiBcIs6gz4HPjM+HzrXOuc+BzrFcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLOlyDOtM63zrzOv8+Dzq/Otc+Fz4POtyDOsc+GzrHOuc+Bzq3OuM63zrrOtSDOsc+Az4wgz4TOvyDPgM+Bz4zPh861zrnPgc6/XCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIs6XIM60zrfOvM6/z4POr861z4XPg863IM+Az4HOv8+Dz4TOrc64zrfOus61IM+Dz4TOvyDPgM+Bz4zPh861zrnPgc6/XCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIs6jz43Pgc61IM6xz4HOuc+Dz4TOrc+BzrEgzrPOuc6xIM69zrEgzrTOtc65z4Igz4TOuc+CIM61z4DOuc67zr/Os86tz4JcIixcblx0XCJNQU5BR0VcIjogXCLOlM65zrHPh861zq/Pgc63z4POt1wiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLOlyDOtc65zrrPjM69zrEgzrHPhs6xzrnPgc6tzrjOt866zrVcIixcblx0XCJDT1BZXCI6IFwizpHOvc+EzrnOs8+BzrHPhs6uXCIsXG5cdFwiTk9fSU1BR0VcIjogXCLOlM61zr0gzq3Ph861zrnPgiDOsc69zrXOss6sz4POtc65IM61zrnOus+Mzr3OsSDOsc66z4zOvM6xXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLOo8+Nz4HPhM61IM+Az4HOv8+CIM+EzrEgzrrOrM+Ez4kgzrPOuc6xIM6xzr3Osc69zq3Pic+DzrdcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwizpXOvs+Jz4TOtc+BzrnOus6tz4IgzrXPhs6xz4HOvM6/zrPOrc+CXCIsXG5cdFwiUExVR0lOU1wiOiBcIs6gz4HPjM+DzrjOtc+EzrFcIixcblx0XCJTVUdHRVNUXCI6IFwizqDPgc+Mz4TOtc65zr3OtVwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwizojPgc+HzrXPhM6xzrkgz4PPjc69z4TOv868zrFcIixcblx0XCJDSEFJTlwiOiBcIs6RzrvPhc+Dzq/OtM6xXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIs6VzrTPjiDOvM+Azr/Pgc61zq/PgiDOvc6xIM6xzrvOu86szr7Otc65z4Igz4TOt869IM6xzrvPhc+Dzq/OtM6xIM+Ez4nOvSDOvM+AzrvOv866IM6uIM+EzrfOvSDPgM+Bzr/Otc+AzrnOu861zrPOvM6tzr3OtyDPgM67zrHPhM+Gz4zPgc68zrEuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCLOnc+MzrzOuc+DzrzOsVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCLOlc60z44gzrzPgM6/z4HOtc6vz4TOtSDOvc6xIM6xzrvOu86szr7Otc+EzrUgz4TOvyDPgM+Bzr/Otc+AzrnOu861zrPOvM6tzr3OvyDPg86xz4Igzr3PjM68zrnPg868zrEuIM6YzrEgzrTOtc6vz4TOtSDPhM63zr0gzrHOvc+EzrHOvM6/zrnOss6uIM+EzrfPgiDOsc69zqzPgc+EzrfPg863z4Ivz4PPh86/zrvOr86/z4Ugz4POsc+CIM+DzrUgzrHPhc+Ez4wgz4TOvyDOvc+MzrzOuc+DzrzOsS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj7Om86vz4PPhM6xIM68zrUgz4TOsSDPh86xz4HOsc66z4TOt8+BzrnPg8+EzrnOus6sPC9iPiA8YnI+Lc6gz4HPjM+DzrLOsc+Dzrcgz4POtSDOvM6/zr3Osc60zrnOus6sIM6sz4HOuM+BzrEgz4POtSDOv8+Azr/Ouc6/zrTOrs+Azr/PhM61IM64zq3OvM6xIM+DzrHPgiDOtc69zrTOuc6xz4bOrc+BzrXOuS4gPGJyPiAtXFxcIs6gzrvOt8+Dzq/Osc+DzrVcXFwiIM+Dz4XOs86zz4HOsc+GzrXOr8+CIM+Dz4fOv867zrnOrM62zr/Ovc+EzrHPgiDOus6xzrkgz4PPhc62zrfPhM+Ozr3PhM6xz4IgzrjOrc68zrHPhM6xLiA8YnI+Lc6ozq7Phs65z4POtSDOsc69zrHPgc+Ezq7Pg861zrnPgiDPjs+Dz4TOtSDOvc6xIM6xzr3PhM6xzrzOtc65z4bOuM6/z43OvSDPg8+FzrPOs8+BzrHPhs61zq/PgiDOus6xzrkgzrrOrc+BzrTOuc+DzrUgzrHOvc+EzrHOvM6/zrnOss6tz4IgzrXPgM65zrzOrc67zrXOuc6xz4IuIDxicj4tzpTOt868zr/Pg86vzrXPhc+DzrUgz4TOsSDOrM+BzrjPgc6xIM+Dzr/PhSwgzrHOvc6sz4HPhM63z4POtSDPgM6/z4PPhCDOus6xzrkgz4bOuc67zr/Ovs6tzr3Ot8+DzrUgz4TOsSDOtM+Jz4HOtc6szr0gzrrOsc64z47PgiDOtc+Azq/Pg863z4IgzrvOrM6yzrUgzrHOvc+EzrHOvM6/zrnOss6tz4Igz4PPhc68zrzOtc+Ezq3Ph86/zr3PhM6xz4IgzrrOsc65IM6xz4DOv866z4TPjs69z4TOsc+CIM6/z4DOsc60zr/Pjc+CLiA8YnI+Lc6Tz4HOrM+IzrUgzqzPgc64z4HOsSDPgM+Bzr/Ph8+Jz4HPjs69z4TOsc+CIM66zrHOuSDOsc+Azr/OuM6uzrrOtc+Fz4POtSDPgM6/zrvOu86xz4DOu86sIM+Az4HPjM+HzrXOuc+BzrEgz4DOv8+Dz4QsIM6tz4TOv865zrzOsSDOs865zrEgzrzOtc67zrvOv869z4TOuc66zq4gzrTOt868zr/Pg86vzrXPhc+DzrcuIDxicj4tzpLOrM67zrUgz4POtc67zrnOtM6/zrTOtc6vzrrPhM61z4Igz4POtSDOsc6zzrHPgM63zrzOrc69zrEgzqzPgc64z4HOsSDOs865zrEgzr3OsSDPhM6xIM60zrnOsc6yzqzPg861zrnPgiDOsc+BzrPPjM+EzrXPgc6xLiA8YnI+Lc6Rzr3PhM6szrvOu86xzr7OtSDOriDOtc6+zrHPgc6zz43Pgc+Jz4POtSDPhM6xIM66zq3Pgc60zrcgz4POv8+FLiA8YnI+Lc6jz4TOtc6vzrvOtSDPh8+Bzq7OvM6xz4TOsSDPg861IM6/z4DOv865zr/OtM6uz4DOv8+EzrUgz4PPhc6zzrPPgc6xz4bOrc6xLCDPh8+Bzq7Pg8+EzrcsIM+Gzq/Ou86/LCDOsc69zrHOs869z47Pg8+EzrcgzrrOu8+AIDxicj4tzpHOus6/zrvOv8+NzrjOt8+DzrUgzrXOvc60zrnOsc+Gzq3Pgc6/zr3PhM61z4Igz4PPhc6zzrPPgc6xz4bOtc6vz4IsIGJsb2dnZXJzLiA8YnI+IC3Oks+BzrXPgiDPhM6/z4XPgiDOsc69zrHOs869z47Pg8+EzrXPgiDOus6xzrkgz4PPhc6zzrPPgc6xz4bOtc6vz4Igz4DOv8+FIM+DzrUgzrHOus6/zrvOv8+FzrjOv8+Nzr0uIDxicj4tzpvOrM6yzrXPhM61IM61zrnOtM6/z4DOv865zq7Pg861zrnPgiDOs865zrEgzr3OsSDOvM61zq/Ovc61z4TOtSDPg861IM61z4DOsc+Gzq4gzrzOtSDPhM6/z4XPgiDOsc69zrHOs869z47Pg8+EzrXPgiDPg86xz4IgzrrOsc65IM+EzrnPgiDPg8+FzrbOt8+Ezq7Pg861zrnPgiDPgM6/z4Ugz4PPhc68zrzOtc+Ezq3Ph861z4TOtS4gPGJyPi3OqM6szr7OtSDOtc69zrTOuc6xz4bOrc+Bzr/Phc+DzrXPgiDOtc+EzrnOus6tz4TOtc+CL866zrHPhM63zrPOv8+Bzq/Otc+CIM6sz4HOuM+Bz4nOvSwgz4PPhc69z4TOsc66z4TPjs69LiA8YnI+IC3Olc6+zrHPhM6/zrzOr866zrXPhc+DzrUgz4TOvyDPgM+Bzr/Phs6vzrsgz4POv8+FLiA8YnI+Lc6gzr/Ou867zqwgz4DOtc+BzrnPg8+Dz4zPhM61z4HOsSDPh86xz4HOsc66z4TOt8+BzrnPg8+EzrnOus6sIM+Az4HPjM66zrXOuc+EzrHOuSDOvc6xIM6xzrrOv867zr/Phc64zq7Pg86/z4XOvS4gPGJyPjxicj48Yj7Okc+Dz4bOrM67zrXOuc6xPC9iPiA8YnI+MS4gzpcgzrXPhs6xz4HOvM6/zrPOriDOtM61zr0gzq3Ph861zrkgz4DOv8+Ezq0gz4DPgc+Mz4POss6xz4POtyDOriDOv8+Azr/Ouc6xzrTOrs+Azr/PhM61IM6xzr3OrM68zrnOvs63IM+Dz4TOsSDOus61z4bOrM67zrHOuc6xIM+Ezr/PhSDPh8+Bzq7Pg8+EzrcuIDxicj4yLiDOlyDOtc+GzrHPgc68zr/Os86uIM+Az4HOv8+Dz4bOrc+BzrXOuSDOrc69zrEgzrzOv869z4TOrc67zr8gzrHPg8+GzrHOu861zq/Osc+CIM6xz4DPjCDPhM63zr0gz4DOu861z4XPgc6sIM+Ezr/PhSDPgM+Bzr/Os8+BzqzOvM68zrHPhM6/z4Itz4DOtc67zqzPhM63LCDOvM61IM+EzrEgzrnOtM65z4nPhM65zrrOrCDOus67zrXOuc60zrnOrCDOvc6xIM+GzrnOu86/zr7Otc69zr/Pjc69z4TOsc65IM+Ezr/PgM65zrrOrCDPh8+Jz4HOr8+CIM69zrEgzrHPgM6/z4PPhM6tzrvOu86/zr3PhM6xzrkgz4DOv8+Ezq0gz4POtSDOv8+Azr/Ouc6/zrTOrs+Azr/PhM61IM60zrnOsc66zr/OvM65z4PPhM6uLCDOtc+Dz40gzrXOr8+DzrHOuSDPhc+AzrXPjc64z4XOvc6/z4IgzrPOuc6xIM+EzrcgzrTOt868zrnOv8+Fz4HOs86vzrEgzrHOvc+EzrnOs8+BzqzPhs+Jzr0gzrHPg8+GzrHOu861zq/Osc+CIM+Ez4nOvSDOus+JzrTOuc66z47OvSDPgM+Bz4zPg86yzrHPg863z4Igz4POv8+FLiA8YnI+My4gzpcgzrXPhs6xz4HOvM6/zrPOriDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzrHPgM67z4wgzrrOsc65IM61zrvOus+Fz4PPhM65zrrPjCDPgM61z4HOuc6yzqzOu867zr/OvSDPh8+Bzq7Pg863z4IgzrrOsc65IM61zrzPgM61zrnPgc6vzrHPgiA8YnI+NC4gzpcgzrXPhs6xz4HOvM6/zrPOriDPgM+Bzr/Pg8+Gzq3Pgc61zrkgzrXPgM65z4DOu86tzr/OvSDPg8+Ez4HPjs68zrEgz4TOt8+CIM6xz4PPhs6szrvOtc65zrHPgiDOvM61IM66z4nOtM65zrrPjCBwaW4gPGJyPjxicj7Otc66z4TOr868zrfPg863IM+Fz4DOv8+Dz4TOt8+Bzq/Ots61zrkgz4DOu86xz4TPhs+Mz4HOvM61z4IgU3RlZW0gzrrOsc65IEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIs6ZzrTPgc+Fz4TOrs+CIM66zrHOuSDOtc+AzrnOus61z4bOsc67zq7PgiDPgM+Bzr/Os8+BzrHOvM68zrHPhM65z4PPhM6uz4JcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIs6gz4HOv8+DzrjOrs66zrcgzrvOv86zzrHPgc65zrHPg868zr/PjVwiLFxuXHRcIlBMQVRGT1JNXCI6IFwizqDOu86xz4TPhs+Mz4HOvM6xXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkhvbWVcIixcblx0XCJMT0dJTlwiOiBcIkxvZ2luXCIsXG5cdFwiTE9HT1VUXCI6IFwiTG9nb3V0XCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbGVcIixcblx0XCJGT0xMT1dcIjogXCJGb2xsb3dcIixcblx0XCJCT09LTUFSS1NcIjogXCJCb29rbWFya3NcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVyXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWFya2V0XCIsXG5cdFwiU0VUVElOR1NcIjogXCJTZXR0aW5nc1wiLFxuXHRcIkFCT1VUXCI6IFwiQWJvdXRcIixcblx0XCJBQk9VVF8xXCI6IFwid2hlcmUgYW55b25lIGNhbiBlYXJuIHJld2FyZHMgZm9yIHRoZWlyIGNvbnRlbnQhXCIsXG5cdFwiQUJPVVRfMlwiOiBcImlzIHNvY2lhbCBhcHBsaWNhdGlvbiB3aGVyZSB5b3UgZ2V0IHBhaWQgZm9yIGJsb2dnaW5nLCBjb21tZW50aW5nIGFuZCBjdXJhdGluZy5cIixcblx0XCJBQk9VVF8zXCI6IFwiYW5kIGl0IGlzIG9wZW4tc291cmNlLCBjb21tdW5pdHkgZHJpdmVuIG1vYmlsZSBwcm9qZWN0LiBJdCBvZmZlcnMgY29udGVudCBhY2Nlc3MgZm9yIHJlYWRpbmcsIGNvbW1lbnRpbmcsIHZvdGluZywgcG9zdGluZywgdHJhbnNmZXIgZWFybmluZ3MsIGV0Yy4gZmVhdHVyZXMgb2ZmZXJlZCBieSB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gYW5kIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gQXBwIG5ldmVyIGFjY2VzcyBvciBob2xkIG9udG8gdXNlciBmdW5kcy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQXBwIG9mZmVycyBhIGNsaWVudC1zaWRlIHNlY3VyaXR5IG1vZGVsLCB3aXRoIHByaXZhdGUga2V5cyBob3N0ZWQgbG9jYWxseSBhbmQgbmV2ZXIgc2VudCB0byBhbnkgc2VydmVycy5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gQXBwIG9mZmVycyBzaW1wbGUsIGF0dHJhY3RpdmUgdXNlciBpbnRlcmZhY2VzIGFuZCBleHBlcmllbmNlcy5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXBwIG5ldmVyIHJlcXVpcmUgdXNlcnMgdG8gaW5wdXQgYW55IHBlcnNvbmFsIGluZm9ybWF0aW9uLlwiLFxuXHRcIkFCT1VUXzhcIjogXCJWb3RlIGdvb2Qta2FybWEgYXMgd2l0bmVzc1wiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YWN0L0ZlZWRiYWNrOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTW9yZSBpbmZvOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlJlbW92ZVwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiTWFya2V0IFZpZXdcIixcblx0XCJQUklDRVwiOiBcIlByaWNlXCIsXG5cdFwiQU1PVU5UXCI6IFwiQW1vdW50XCIsXG5cdFwiVE9UQUxcIjogXCJUb3RhbFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiTm8gb3BlbiBvcmRlcnMgZm9yXCIsXG5cdFwiREFURVwiOiBcIkRhdGVcIixcblx0XCJCVVlcIjogXCJCdXlcIixcblx0XCJTRUxMXCI6IFwiU2VsbFwiLFxuXHRcIk9QRU5cIjogXCJPcGVuXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcnlcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIkZvbGxvdyBiYWNrXCIsXG5cdFwiRk9MTE9XRURcIjogXCJGb2xsb3dlZFwiLFxuXHRcIlVORk9MTE9XXCI6IFwiVW5mb2xsb3dcIixcblx0XCJGT0xMT1dJTkdcIjogXCJGb2xsb3dpbmdcIixcblx0XCJGT0xMT1dFUlNcIjogXCJGb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiU2VhcmNoIGZvbGxvd2Vyc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJTZWFyY2ggZm9sbG93aW5nXCIsXG5cdFwiQllcIjogXCJieVwiLFxuXHRcIklOXCI6IFwiaW5cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiQm9va21hcmtcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJVcHZvdGVcIixcblx0XCJET1dOVk9URVwiOiBcIkRvd252b3RlXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlVudm90ZSBEb3dudm90ZWRcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlVudm90ZSB1cHZvdGVkXCIsXG5cdFwiUkVQTFlcIjogXCJSZXBseVwiLFxuXHRcIkVESVRcIjogXCJFZGl0XCIsXG5cdFwiUE9TVF8xXCI6IFwiU3dpcGUgbGVmdCBvbiBjb21tZW50cyB0byBzZWUgb3B0aW9uc1wiLFxuXHRcIlBPU1RfMlwiOiBcIlRhcCBvbiBjb21tZW50cyB0byBzZWUgc3ViLWNvbW1lbnRzXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wdGlvbnNcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZWJsb2dnZWQgYnlcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOb3RoaW5nIGhlcmUsIHlldC4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiQmFsYW5jZXNcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCB0cmFkZWFibGUgdG9rZW5zIHRoYXQgbWF5IGJlIHRyYW5zZmVycmVkIGF0IGFueXRpbWUuIHt7cGxhdGZvcm1uYW1lfX0gY2FuIGJlIGNvbnZlcnRlZCB0byB7e3BsYXRmb3JtcG93ZXJ9fSBpbiBhIHByb2Nlc3MgY2FsbGVkIHBvd2VyaW5nIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBpbmZsdWVuY2UgdG9rZW5zIHRoYXQgZWFybiBtb3JlIHBvd2VyIGZvciBob2xkaW5nIGxvbmcgdGVybSBhbmQgdm90aW5nIG9uIHBvc3RzLiBUaGUgbW9yZSBvbmUgaG9sZHMgdGhlIG1vcmUgb25lIGNhbiBpbmZsdWVuY2Ugb3RoZXLigJlzIHJld2FyZHMgYW5kIGVhcm4gcmV3YXJkcyBmb3IgYWNjdXJhdGUgdm90aW5nLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VucyB3b3J0aCBhYm91dCB7e3BsYXRmb3Jtc3VuaXR9fSBvZiB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkVzdGltYXRlZCBWYWx1ZVwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIlRoZSBlc3RpbWF0ZWQgdmFsdWUgaXMgYmFzZWQgb24gYSA3IGRheSBhdmVyYWdlIHZhbHVlIG9mIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlRyYW5zYWN0aW9uIEhpc3RvcnlcIixcblx0XCJQT1NUSU5HXCI6IFwiUG9zdGluZ1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIlRoZSBwb3N0aW5nIGtleSBpcyB1c2VkIGZvciBwb3N0aW5nIGFuZCB2b3RpbmcuIEl0IHNob3VsZCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgYWN0aXZlIGFuZCBvd25lciBrZXlzLlwiLFxuXHRcIk9XTkVSXCI6IFwiT3duZXJcIixcblx0XCJQUk9GSUxFXzZcIjogXCJUaGUgb3duZXIga2V5IGlzIHRoZSBtYXN0ZXIga2V5IGZvciB0aGUgYWNjb3VudCBhbmQgaXMgcmVxdWlyZWQgdG8gY2hhbmdlIHRoZSBvdGhlciBrZXlzLiBUaGUgcHJpdmF0ZSBrZXkgb3IgcGFzc3dvcmQgZm9yIHRoZSBvd25lciBrZXkgc2hvdWxkIGJlIGtlcHQgb2ZmbGluZSBhcyBtdWNoIGFzIHBvc3NpYmxlLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFjdGl2ZVwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIlRoZSBhY3RpdmUga2V5IGlzIHVzZWQgdG8gbWFrZSB0cmFuc2ZlcnMgYW5kIHBsYWNlIG9yZGVycyBpbiB0aGUgaW50ZXJuYWwgbWFya2V0LlwiLFxuXHRcIk1FTU9cIjogXCJNZW1vXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiVGhlIG1lbW8ga2V5IGlzIHVzZWQgdG8gY3JlYXRlIGFuZCByZWFkIG1lbW9zLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJQb3N0c1wiLFxuXHRcIlJFUExJRVNcIjogXCJSZXBsaWVzXCIsXG5cdFwiV0FMTEVUXCI6IFwiV2FsbGV0XCIsXG5cdFwiVEFHXCI6IFwiVGFnXCIsXG5cdFwiVVNFUlwiOiBcIlVzZXJcIixcblx0XCJDTE9TRVwiOiBcIkNsb3NlXCIsXG5cdFwiVE9cIjogXCJUb1wiLFxuXHRcIkFTU0VUXCI6IFwiQXNzZXRcIixcblx0XCJTRU5EXCI6IFwiU2VuZFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU2VjdXJpdHlcIixcblx0XCJBVkFJTEFCTEVcIjogXCJBdmFpbGFibGVcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIlB1YmxpYyBNZW1vXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlVzZXIgZS5nLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJQaW4gQ29kZVwiLFxuXHRcIlBJTl9URVhUXCI6IFwiUElOIGNvZGUgaGVscHMgeW91IHRvIHNlY3VyZSBhcHAgYW5kIHlvdXIgZGF0YS4gPGJyLz48YnIvPjxiPk5vdGU6PC9iPiBPbmNlIGVuYWJsZWQsIHlvdSBoYXZlIG1heCA0IHRyaWVzIHRvIHVubG9jaywgaWYgeW91IGZvcmdvdCBwaW4gb3IgZmFpbCwgYXBwIHdpbGwgcmVtb3ZlIGxvZ2dlZCBpbiB1c2VyIGRhdGEuIFlvdSBjYW4gcmUtbG9naW4gYW5kIGNvbnRpbnVlIHVzaW5nIGFwcC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTm90aWZpY2F0aW9uc1wiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIllvdSB3aWxsIGdldCBub3RpZmljYXRpb24gd2hlbiBzb21lb25lIHZvdGVzIHlvdXIgY29udGVudCEgPGJyLz4gPGI+Tm90ZTo8L2I+IE5vdGlmaWNhdGlvbnMgaW5jbHVkZSB2b3Rpbmcgd2VpZ2h0IGFzIHdlbGwgaW4gYWxlcnQgbWVzc2FnZS4gKGJlIGl0IHVwLXZvdGUsIGRvd24tdm90ZSwgdW4tdm90ZSkuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGVcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSBjb21tZW50cyBvbiB5b3VyIHBvc3RzIG9yIGNvbW1lbnRzITxici8+IDxiPk5vdGU6PC9iPiBOb3RpZmljYXRpb25zIGluY2x1ZGUgd2hlbiBzb21lb25lIDxiPmVkaXRzPC9iPiB0aGVpciBjb21tZW50cyBhcyB3ZWxsLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21tZW50XCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJZb3Ugd2lsbCBnZXQgbm90aWZpY2F0aW9uIHdoZW4gc29tZW9uZSBGb2xsb3cgb3IgVW5mb2xsb3cgeW91IVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiTWVudGlvbnNcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiWW91IHdpbGwgZ2V0IG5vdGlmaWNhdGlvbiB3aGVuIHNvbWVvbmUgbWVudGlvbnMgeW91IGluIHRoZWlyIHBvc3QvY29tbWVudCFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiWW91IHdpbGwgZ2V0IG5vdGlmaWNhdGlvbiB3aGVuIHNvbWVvbmUgcmVibG9ncyB5b3VyIHBvc3QhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJDb25maWd1cmF0aW9uc1wiLFxuXHRcIlZPVElOR1wiOiBcIlZvdGluZ1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiVm90ZSB3ZWlnaHQgb3IgcGVyY2VudGFnZSBhZmZlY3RzIHZvdGluZyBwb3dlciBvbiBhcHAsIHNvIHlvdSBjYW4gcmVndWxhdGUgeW91ciB2b3RpbmcgcmV3YXJkLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IFRoaXMgd2lsbCBjaGFuZ2Ugdm90aW5nIHdlaWdodC9wZXJjZW50YWdlIGZvciBkb3dudm90aW5nIGFzIHdlbGwgYW5kIGl0IGlzIGV2ZXJ5d2hlcmUgb24gYXBwXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJSZWNvbW1lbmRlZFwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNhdmUgQ2hhbmdlc1wiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiVm90ZXJzIGluZm9cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJXZWxjb21lIGJhY2shXCIsXG5cdFwiTE9HSU5fMVwiOiBcIlNpZ24gaW4gd2l0aCB5b3VyIHVzZXJuYW1lIGFuZCBwYXNzd29yZCB0byBjb250aW51ZS5cIixcblx0XCJMT0dJTl8yXCI6IFwiUG9zdGluZyBrZXkgaXMgdXNlZCBmb3IgcG9zdCwgY29tbWVudCwgdm90ZSwgZm9sbG93LlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBY3RpdmUga2V5IGlzIHVzZWQgZm9yIHRyYW5zZmVycyBhbmQgcHJvZmlsZSBwaWN0dXJlIHVwZGF0ZS5cIixcblx0XCJMT0dJTl80XCI6IFwiVXNlciBjcmVkZW50aWFscyBhcmUga2VwdCBsb2NhbGx5IG9uIHRoZSBkZXZpY2UuIFVwb24gTG9nb3V0IGNyZWRlbnRpYWxzIGFyZSByZW1vdmVkIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIkRvbid0IGhhdmUgYW4gYWNjb3VudD9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlNpZ24gdXAgbm93XCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQ2FuY2VsXCIsXG5cdFwiQURWQU5DRURcIjogXCJBZHZhbmNlZFwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJBY3RpdmUgcHJpdmF0ZSBrZXlcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIlBvc3RpbmcgcHJpdmF0ZSBrZXlcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIk1hc3Rlci9tYWluIHBhc3N3b3JkXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJVc2VybmFtZVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIkNhcmQgdmlld1wiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIkNvbXBhY3Qgdmlld1wiLFxuXHRcIlNFQVJDSFwiOiBcIlNlYXJjaFwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiU3VibWl0IGEgc3RvcnlcIixcblx0XCJSRVBMWVRPXCI6IFwiUmVwbHkgdG9cIixcblx0XCJQT1NUXCI6IFwiUG9zdFwiLFxuXHRcIlBSRVZJRVdcIjogXCJQcmV2aWV3XCIsXG5cdFwiREVGQVVMVFwiOiBcIkRlZmF1bHQgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIFVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIkRlY2xpbmUgUGF5b3V0XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJTQVZFIEZPUiBMQVRFUlwiLFxuXHRcIkNMRUFSXCI6IFwiQ0xFQVJcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJQb3N0IGNvbnRlbnRcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJDb21tZW50IGNvbnRlbnRcIixcblx0XCJUSVRMRVwiOiBcIlRpdGxlXCIsXG5cdFwiVEFHU1wiOiBcIlRhZ3NcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJOT1QgTUFUQ0hcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZpcm0gUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiSU5DT1JSRUNUXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwib3BlbmluZyBwb3N0XCIsXG5cdFwiU0VUX1BJTlwiOiBcIlNldCBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJFbnRlciBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJBcmUgeW91IHN1cmU/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJSZWJsb2cgaXMgaXJyZXZlcnNpYmxlLCBkbyB5b3Ugd2FudCB0byBjb250aW51ZT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJCcm9hZGNhc3QgZXJyb3IsIHRyeSBhZ2FpbiFcIixcblx0XCJTVUNDRVNTXCI6IFwiU3VjY2Vzc1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUmVibG9nZ2VkIHBvc3QhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkxvZ2luIGZhaWxlZCEgUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBsb2dnZWQgaW4gd2l0aCBtYXN0ZXIgcGFzc3dvcmQgb3IgcHJvdmlkZWQgUG9zdGluZyBwcml2YXRlIGtleSBvbiBMb2dpbiBpZiB5b3UgaGF2ZSBjaG9vc2VkIEFkdmFuY2VkIG1vZGUuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiTG9naW4gZmFpbGVkISBQbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGxvZ2dlZCBpbiB3aXRoIG1hc3RlciBwYXNzd29yZCBvciBwcm92aWRlZCBBY3RpdmUgcHJpdmF0ZSBrZXkgb24gTG9naW4gaWYgeW91IGhhdmUgY2hvc2VuIEFkdmFuY2VkIG1vZGUuXCIsXG5cdFwiV0FSTklOR1wiOiBcIldhcm5pbmdcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiVm90aW5nIGZvciB3aXRuZXNzXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJWb3RlZCBmb3Igd2l0bmVzc1wiLFxuXHRcIkFHT1wiOiBcImFnb1wiLFxuXHRcIkZST01fTk9XXCI6IFwiZnJvbSBub3dcIixcblx0XCJTRUNTXCI6IFwic2Vjc1wiLFxuXHRcIkFfTUlOXCI6IFwiYSBtaW5cIixcblx0XCJNSU5TXCI6IFwibWluc1wiLFxuXHRcIkFOX0hPVVJcIjogXCJhbiBoclwiLFxuXHRcIkhPVVJTXCI6IFwiaHJzXCIsXG5cdFwiQV9EQVlcIjogXCJhIGRheVwiLFxuXHRcIkRBWVNcIjogXCJkYXlzXCIsXG5cdFwiQV9NT05USFwiOiBcImEgbW9udGhcIixcblx0XCJNT05USFNcIjogXCJtb250aHNcIixcblx0XCJBX1lFQVJcIjogXCJhIHllYXJcIixcblx0XCJZRUFSU1wiOiBcInllYXJzXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gcmVhZFwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJEb3dudm90ZSBvciBGbGFnXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiQ2FwdHVyZSBQaWN0dXJlXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJTZWxlY3QgUGljdHVyZVwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiU2V0IEN1c3RvbSBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluc2VydCBQaWN0dXJlXCIsXG5cdFwiRVJST1JcIjogXCJFcnJvclwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIlVwbG9hZCBFcnJvclwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJDYW1lcmEgQ2FuY2VsbGVkXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlNldCBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWN0IHdlYiBsaW5rIGZvciB0aGUgcGljdHVyZVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiQ29tbWVudCBpcyBzdWJtaXR0ZWQhXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJEZWxldGluZyBjb21tZW50cyBhcmUgaXJyZXZlcnNpYmxlLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiRGVsZXRlZCBjb21tZW50XCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJVcGxvYWRpbmcgUGljdHVyZVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJVcGxvYWQgQ29tcGxldGVkXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIlVwbG9hZCBGYWlsZWRcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJUaGUgcGFzc3dvcmQgb3IgYWNjb3VudCBuYW1lIHdhcyBpbmNvcnJlY3RcIixcblx0XCJJTkZPXCI6IFwiSW5mb1wiLFxuXHRcIlFSX1RFWFRcIjogXCJQbGFjZSBhIFFSIGNvZGUgaW5zaWRlIHRoZSBzY2FuIGFyZWFcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJNYWtlIHN1cmUgeW91IGhhdmUgZW5vdWdoIGJhbGFuY2UgZm9yIHRyYW5zYWN0aW9uIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJVc2VyIHlvdSBhcmUgdHJ5aW5nIHRvIHRyYW5zZmVyIGZ1bmQsIGRvZXNuJ3QgZXhpc3QhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byB0cmFuc2Zlcj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJDb25maXJtYXRpb25cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYWN0aW9uIGlzIGJyb2FkY2FzdGVkXCIsXG5cdFwiRkVFRFwiOiBcIkZlZWRcIixcblx0XCJUUkVORElOR1wiOiBcIlRyZW5kaW5nXCIsXG5cdFwiSE9UXCI6IFwiSG90XCIsXG5cdFwiTkVXXCI6IFwiTmV3XCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3RlZFwiLFxuXHRcIlZPVEVTXCI6IFwiVm90ZXNcIixcblx0XCJQQVlPVVRcIjogXCJQYXlvdXRcIixcblx0XCJDT01NRU5UU1wiOiBcIkNvbW1lbnRzXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuZGluZyBmb3IgMzAgZGF5c1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlNvcnQgUG9zdHMgQnk6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiUGF5b3V0IEN5Y2xlXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBvdGVudGlhbCBQYXlvdXRcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlBhc3QgUGF5b3V0XCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIkF1dGhvciBQYXlvdXRcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJDdXJhdGlvbiBQYXlvdXRcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIlBvc3QgaXMgc3VibWl0dGVkIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQb3N0IGZvciBsYXRlciBzdWJtaXNzaW9uIVwiLFxuXHRcIlNBVkVEXCI6IFwiU2F2ZWRcIixcblx0XCJDTEVBUkVEXCI6IFwiQ2xlYXJlZFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJGbGFnZ2luZyBhIHBvc3QgY2FuIHJlbW92ZSByZXdhcmRzIGFuZCBtYWtlIHRoaXMgbWF0ZXJpYWwgbGVzcyB2aXNpYmxlLjxicj48YnI+VGhlIGZsYWcgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBmb2xsb3dpbmc6IDx1bD48bGk+RnJhdWQgb3IgUGxhZ2lhcmlzbTwvbGk+PGxpPkhhdGUgU3BlZWNoIG9yIEludGVybmV0IFRyb2xsaW5nPC9saT48bGk+SW50ZW50aW9uYWwgbWlzY2F0ZWdvcml6ZWQgY29udGVudCBvciBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIlJlcXVlc3QgbGltaXQgcmVhY2hlZC4gQ2hlY2sgb3V0IG90aGVyIHRyZW5kL3RhZ3MhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiUG9zdCBpcyByZW1vdmVkIGZyb20gYm9va21hcmtzIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQb3N0IGlzIGFkZGVkIHRvIGJvb2ttYXJrcyFcIixcblx0XCJSRVNFVFwiOiBcIlJlc2V0XCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJNb2RpZnkgUHJvZmlsZSBQaWN0dXJlXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZnkgQ292ZXIgUGljdHVyZVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlBsZWFzZSBwcm92aWRlIEFjdGl2ZSBwcml2YXRlIGtleSBpZiB5b3UgaGF2ZSBjaG9zZW4gQWR2YW5jZWQgbG9naW4gbW9kZSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJUaGlzIHdpbGwgcmVzZXQgdXNlciBwcm9maWxlIHBpY3R1cmVcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJUaGlzIHdpbGwgcmVzZXQgdXNlciBjb3ZlciBwaWN0dXJlXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJTZXJ2ZXIgdXBkYXRlIHJlcXVpcmVzIFJlc3RhcnQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIlNldHRpbmdzIGFyZSB1cGRhdGVkIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkxhbmd1YWdlc1wiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiSGVyZSB5b3UgY2FuIGNoYW5nZSBsYW5ndWFnZSBvZiB0aGUgYXBwLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJUaGlzIG9wZXJhdGlvbiByZXF1aXJlcyB1c2VyIHRvIGJlIGxvZ2dlZCBpbiB3aXRoIG1haW4gcGFzc3dvcmQsIGFjdGl2ZS9wb3N0aW5nIGtleS4gUGxlYXNlIGxvZ2luIGFuZCB0cnkgYWdhaW4uXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGxlcnlcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJUcmFuc2xhdGlvbiBjb250cmlidXRvcnNcIixcblx0XCJTSEFSRVwiOiBcIlNoYXJlXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNYXJrZXQgUGxhY2VcIixcblx0XCJFWENIQU5HRVwiOiBcIkV4Y2hhbmdlXCIsXG5cdFwiRFJBRlRTXCI6IFwiRHJhZnRzXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiUG9zdCBpcyByZW1vdmVkIGZyb20gZHJhZnRzIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQb3N0IGlzIGFkZGVkIHRvIGRyYWZ0cyFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiU3dpcGUgbGVmdCB0byBzZWUgb3B0aW9uc1wiLFxuXHRcIk1BTkFHRVwiOiBcIk1hbmFnZVwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJJbWFnZSBpcyByZW1vdmVkXCIsXG5cdFwiQ09QWVwiOiBcIkNvcHlcIixcblx0XCJOT19JTUFHRVwiOiBcIllvdSBoYXZlIG5vdCB1cGxvYWRlZCBhbnkgaW1hZ2UsIHlldCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlB1bGwgZG93biB0byByZWZyZXNoXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkV4dGVybmFsIEFwcHNcIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Z2luc1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTdWdnZXN0XCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJDb21pbmcgc29vblwiLFxuXHRcIkNIQUlOXCI6IFwiQ2hhaW5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiSGVyZSB5b3UgY2FuIGNoYW5nZSBibG9ja2NoYWluIG9yIGRlZmF1bHQgcGxhdGZvcm0uXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJDdXJyZW5jeVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJIZXJlIHlvdSBjYW4gY2hhbmdlIHlvdXIgZGVmYXVsdCBjdXJyZW5jeS4gWW91IHdpbGwgc2VlIHBvc3QvY29tbWVudCByZXdhcmQgdmFsdWUgaW4gdGhpcyBjdXJyZW5jeS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj5GZWF0dXJlIGxpc3Q8L2I+PGJyPi0gQWNjZXNzIHVuaXF1ZSBhcnRpY2xlcyBpbiBhbnkgc3ViamVjdCB5b3UgYXJlIGludGVyZXN0ZWQgcmVhZGluZy48YnI+LSBFbmdhZ2Ugd2l0aCBhdXRob3JzIGJ5IGNvbW1lbnRpbmcsIGRpc2N1c3NpbmcgdG9waWNzLjxicj4tIFZvdGluZyBmb3IgcG9zdHMgdG8gcmV3YXJkIGF1dGhvciBhcyB3ZWxsIGFzIGVhcm4gY3VyYXRpb24gcmV3YXJkLjxicj4tIFB1Ymxpc2ggeW91ciBhcnRpY2xlcywgYmxvZyBwb3N0cyBhbmQgaG9zdCB0aGVtIGZvciBmcmVlIGFuZCBlYXJuIHJld2FyZHMgYnkgZW5nYWdpbmcgYW5kIGdhaW4gZm9sbG93ZXJzLjxicj4tIFdyaXRlIGFydGljbGVzIG9uIGdvLCBzYXZlIG11bHRpcGxlIGRyYWZ0cyBvZiB0aGUgcG9zdCBmb3IgbGF0ZXIgcHVibGljYXRpb24uPGJyPi0gQm9va21hcmsgZmF2b3JpdGUgYXJ0aWNsZXMgdG8gcmVhZCBsYXRlci48YnI+LSBFeGNoYW5nZSBvciBjYXNoIG91dCB5b3VyIGVhcm5pbmdzLjxicj4tIFNlbmQgeW91ciBmdW5kcyB0byBhbnkgYXV0aG9ycyBvciB1c2VycywgZnJpZW5kcywgZm9sbG93ZXJzLCBldGMuPGJyPi0gRm9sbG93IGludGVyZXN0aW5nIGF1dGhvcnMsIGJsb2dnZXJzLjxicj4tIFNlYXJjaCB5b3VyIGZvbGxvd2VycyBhbmQgYXV0aG9ycyB5b3UgYXJlIGZvbGxvd2luZy48YnI+LSBHZXQgbm90aWZpY2F0aW9ucyB0byBzdGF5IGluIHRvdWNoIHdpdGggeW91ciBmb2xsb3dlcnMgYW5kIGRpc2N1c3Npb25zIHlvdSBhcmUgaW52b2x2ZWQgaW4uPGJyPi0gU2VhcmNoIGZvciBpbnRlcmVzdGluZyB0YWdzL2NhdGVnb3JpZXMgb2YgYXJ0aWNsZXMsIGF1dGhvcnMuPGJyPi0gUGVyc29uYWxpemUgeW91ciBwcm9maWxlLjxicj4tIE1hbnkgbW9yZSBmZWF0dXJlcyB0byBjb21lLjxicj48YnI+PGI+U2VjdXJpdHk8L2I+PGJyPjEuIEFwcCBuZXZlciBhY2Nlc3Mgb3IgaG9sZCBvbnRvIHVzZXIgZnVuZHMuPGJyPjIuIEFwcCBvZmZlciBhIGNsaWVudC1zaWRlIHNlY3VyaXR5IG1vZGVsLCB3aXRoIHByaXZhdGUga2V5cyBob3N0ZWQgbG9jYWxseSBhbmQgbmV2ZXIgc2VudCB0byBhbnkgc2VydmVycywgeW91IGFyZSByZXNwb25zaWJsZSB0byBiYWNraW5nIHVwIHlvdXIgcGFzc3dvcmRzLjxicj4zLiBBcHAgb2ZmZXJzIHNpbXBsZSwgYXR0cmFjdGl2ZSB1c2VyIGludGVyZmFjZXMgYW5kIGV4cGVyaWVuY2VzPGJyPjQuIEFwcCBvZmZlcnMgZXh0cmEgbGF5ZXIgb2Ygc2VjdXJpdHkgd2l0aCBwaW4tY29kZTxicj48YnI+ZVN0ZWVtIHN1cHBvcnRzIFN0ZWVtIGFuZCBHb2xvcyBwbGF0Zm9ybXMuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJGb3VuZGVyIGFuZCBMZWFkIGRldmVsb3BlclwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiQWRkIGFjY291bnRcIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtXCIsXG5cdFwiRVNDUk9XXCI6IFwiRXNjcm93XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93IGFnZW50XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUmF0aWZpY2F0aW9uIGRlYWRsaW5lXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgZXhwaXJhdGlvblwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgZmVlXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IHRlcm1zXCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIk5pZ2h0IG1vZGVcIixcblx0XCJEQVlfTU9ERVwiOiBcIkRheSBtb2RlXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiVmlldyB0aGUgZnVsbCBjb250ZXh0XCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIlVzZXIgTm90IEZvdW5kXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkFwcHJvdmVcIixcblx0XCJESVNQVVRFXCI6IFwiRGlzcHV0ZVwiLFxuXHRcIlJFTEVBU0VcIjogXCJSZWxlYXNlXCIsXG5cdFwiRlJPTVwiOiBcIkZyb21cIixcblx0XCJJRFwiOiBcImlkXCIsXG5cdFwiU1VCTUlUXCI6IFwiU3VibWl0XCIsXG5cdFwiUkVDRUlWRVJcIjogXCJSZWNlaXZlclwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9jYXRpb25cIixcblx0XCJXRUJTSVRFXCI6IFwiV2Vic2l0ZVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIkRpc3BsYXkgbmFtZVwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJIb2dhclwiLFxuXHRcIkxPR0lOXCI6IFwiSW5pY2lhciBTZXNpw7NuXCIsXG5cdFwiTE9HT1VUXCI6IFwiQ2VycmFyIFNlc2nDs25cIixcblx0XCJQUk9GSUxFXCI6IFwiUGVyZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiU2VndWlyXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiTWFyY2Fkb3Jlc1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwiVHJhbnNmZXJpclwiLFxuXHRcIk1BUktFVFwiOiBcIk1lcmNhZG9cIixcblx0XCJTRVRUSU5HU1wiOiBcIkFqdXN0ZXNcIixcblx0XCJBQk9VVFwiOiBcIkFjZXJjYSBkZVwiLFxuXHRcIkFCT1VUXzFcIjogXCJkb25kZSB0b2RvIGVsIG11bmRvIHB1ZWRlIG9idGVuZXIgZ2FuYW5jaWFzIHBvciBzdSBjb250ZW5pZG9cIixcblx0XCJBQk9VVF8yXCI6IFwicHJvdmlzdG8gcG9yIGxhIHBsYXRhZm9ybWEge3twbGF0Zm9ybW5hbWV9fS4gQXBwIGNyZWFkYSBwb3JcIixcblx0XCJBQk9VVF8zXCI6IFwiZXMgdW4gcHJveWVjdG8gZGUgbcOzdmlsIGltcHVsc2FkbyBwb3IgbGEgY29tdW5pZGFkLCBkZSBjw7NkaWdvIGFiaWVydG8uIE9mcmVjZSBhY2Nlc28gYWwgY29udGVuaWRvIHBhcmEgc3UgbGVjdHVyYSwgY29tZW50YXJpb3MsIHZvdG9zLCBwdWJsaWNhY2lvbmVzLCB0cmFuc2ZlcmVuY2lhIGRlIGdhbmFuY2lhcywgZXRjOyBjYXJhY3RlcsOtc3RpY2FzIG9mcmVjaWRhcyBwb3IgbGEgY2FkZW5hIGRlIGJsb3F1ZXMge3twbGF0Zm9ybW5hbWV9fSB5IHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gTGEgQXBwIG51bmNhIGFjY2VkZSBvIHJldGllbmUgZm9uZG9zIGRlIGxvcyB1c3Vhcmlvcy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gTGEgQXBwIG9mcmVjZSB1biBtb2RlbG8gZGUgc2VndXJpZGFkIGRlbCBjbGllbnRlIGNvbiBjb250cmFzZcOxYXMgcHJpdmFkYXMgYWxtYWNlbmFkYXMgbG9jYWxtZW50ZSB5IHF1ZSBubyBzb24gbnVuY2EgZW52aWFkYXMgYSBuaW5nw7puIHNlcnZpZG9yLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBMYSBBcHAgb2ZyZWNlIHVuYSBleHBlcmllbmNpYSB5IHVuYSBpbnRlcmZheiBzaW1wbGUgeSBhdHJhY3RpY2EuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIExhIEFwcCBudW5jYSBwaWRlIHF1ZSBsb3MgdXN1YXJpb3MgaW50cm9kdXpjYW4gbmluZ3VuYSBpbmZvcm1hY2nDs24gcGVyc29uYWwuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlZvdGEgYSBnb29kLWthcm1hIGNvbW8gdGVzdGlnb1wiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YWN0by9TdWdlcmVuY2lhc1wiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTcOhcyBpbmZvcm1hY2nDs25cIixcblx0XCJSRU1PVkVcIjogXCJFbGltaW5hclwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiVmlzdGEgZGUgTWVyY2Fkb1wiLFxuXHRcIlBSSUNFXCI6IFwiUHJlY2lvXCIsXG5cdFwiQU1PVU5UXCI6IFwiQ2FudGlkYWRcIixcblx0XCJUT1RBTFwiOiBcIlRvdGFsXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJTaW4gw7NyZGVuZXMgYWJpZXJ0YXMgcGFyYVwiLFxuXHRcIkRBVEVcIjogXCJGZWNoYVwiLFxuXHRcIkJVWVwiOiBcIkNvbXByYXJcIixcblx0XCJTRUxMXCI6IFwiVmVuZGVyXCIsXG5cdFwiT1BFTlwiOiBcIkFicmlyXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcmlhbFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiRGV2b2x2ZXIgU2VndWltaWVudG9cIixcblx0XCJGT0xMT1dFRFwiOiBcIlNlZ3VpZG9cIixcblx0XCJVTkZPTExPV1wiOiBcIkRlamFyIGRlIFNlZ3VpclwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIlNpZ3VpZW5kb1wiLFxuXHRcIkZPTExPV0VSU1wiOiBcIlNlZ3VpZG9yZXNcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiQnVzY2FyIHNlZ3VpZG9yZXNcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiQnVzY2FyIHNlZ3VpZG9zXCIsXG5cdFwiQllcIjogXCJwb3JcIixcblx0XCJJTlwiOiBcImVuXCIsXG5cdFwiTUVOVVwiOiBcIk1lbsO6XCIsXG5cdFwiQk9PS01BUktcIjogXCJNYXJjYWRvclwiLFxuXHRcIlJFQkxPR1wiOiBcIlJlYmxvZ3VlYXJcIixcblx0XCJVUFZPVEVcIjogXCJWb3RvIFBvc2l0aXZvXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJWb3RvIE5lZ2F0aXZvXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkRlc2hhY2VyIFZvdG8gTmVnYXRpdm9cIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIkRlc2hhY2VyIFZvdG8gUG9zaXRpdm9cIixcblx0XCJSRVBMWVwiOiBcIlJlc3BvbmRlclwiLFxuXHRcIkVESVRcIjogXCJFZGl0YXJcIixcblx0XCJQT1NUXzFcIjogXCJEZXNsaXphIGEgbGEgaXpxdWllcmRhIGVuIGxvcyBjb21lbnRhcmlvcyBwYXJhIHZlciBsYXMgb3BjaW9uZXNcIixcblx0XCJQT1NUXzJcIjogXCJQdWxzYSBlbiBsb3MgY29tZW50YXJpb3MgcGFyYSB2ZXIgbG9zIHN1YmNvbWVudGFyaW9zXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wY2lvbmVzXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVzdGVlbWVkIHBvclwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIk5hZGEgcG9yIGFxdcOtIGHDum4uLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlNhbGRvc1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIGZpY2hhcyBjb21lcmNpYWJsZXMgcXVlIHB1ZWRlbiBzZXIgdHJhbnNmZXJpZGFzIGVuIGN1YWxxdWllciBtb21lbnRvLiB7e3BsYXRmb3JtbmFtZX19IHB1ZWRlbiBzZXIgY29udmVydGlkYXMgYSB7e3BsYXRmb3JtcG93ZXJ9fSBlbiB1biBwcm9jZXNvIGxsYW1hZG8gcG93ZXIgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGZpY2hhcyBkZSBpbmZsdWVuY2lhIHF1ZSBjb25zaWd1ZW4gbcOhcyBwb2RlciBwb3IgbWFudGVuZXJsYXMgYSBsYXJnbyBwbGF6byB5IHZvdGFyIGVuIGxvcyBwb3N0cy4gQ3VhbnRhcyBtw6FzIHRlbmdhcyBtw6FzIGluZmx1ZW5jaWEgdGVuZHLDoXMgZW4gbGFzIHJlY29tcGVuc2FzIHF1ZSBsZSBkYXMgYWwgcmVzdG8gZGUgdXN1YXJpb3MgeSBtw6FzIHJlY29tcGVuc2FzIG9idGVuZHLDoXMgcG9yIHR1cyB2b3Rvcy5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJWYWxvciBkZSBsYXMgZmljaGFzIHt7cGxhdGZvcm1zdW5pdH19IGRlIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiVmFsb3IgRXN0aW1hZG9cIixcblx0XCJQUk9GSUxFXzRcIjogXCJFbCB2YWxvciBlc3RpbWFkbyBzZSBiYXNhIGVuIHVuIHZhbG9yIHByb21lZGlvIGRlIDcgZMOtYXMgZGUge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiSGlzdG9yaWFsIGRlIFRyYW5zYWNjaW9uZXNcIixcblx0XCJQT1NUSU5HXCI6IFwiUHVibGljYWNpw7NuXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiTGEgY2xhdmUgZGUgcHVibGljYWNpw7NuIGVzIHV0aWxpemFkYSBwYXJhIHB1YmxpY2FyIHkgdm90YXIuIFRpZW5lIHF1ZSBzZXIgZGlmZXJlbnRlIGEgbGEgY2xhdmUgYWN0aXZhIHkgYSBsYSBjbGF2ZSBkZSBwcm9waWV0YXJpby5cIixcblx0XCJPV05FUlwiOiBcIlByb3BpZXRhcmlvXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiTGEgY2xhdmUgZGUgcHJvcGlldGFyaW8gZXMgbGEgY2xhdmUgbWFlc3RyYSBkZSBsYSBjdWVudGEgeSBzZSByZXF1aWVyZSBwYXJhIGNhbWJpYXIgbGFzIG90cmFzIGNsYXZlcy4gTGEgY2xhdmUgbyBjb250cmFzZcOxYSBwcml2YWRhIGRlIGxhIGNsYXZlIGRlIHByb3BpZXRhcmlvIGRlYmVyw61hIHNlciBtYW50ZW5pZGEgXFxcIm9mZmxpbmVcXFwiIHRhbnRvIGNvbW8gc2VhIHBvc2libGUuXCIsXG5cdFwiQUNUSVZFXCI6IFwiQWN0aXZhXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiTGEgY2xhdmUgYWN0aXZhIHNlIHV0aWxpemEgcGFyYSBoYWNlciB0cmFuc2ZlcmVuY2lhcyB5IGhhY2VyIHBlZGlkb3MgZW4gZWwgbWVyY2FkbyBpbnRlcm5vLlwiLFxuXHRcIk1FTU9cIjogXCJNZW1vcsOhbmR1bVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkxhIGNsYXZlIGRlIG1lbW9yw6FuZHVtcyBzZSB1dGlsaXphIHBhcmEgY3JlYXIgeSBsZWVyIG1lbW9yw6FuZHVtcy5cIixcblx0XCJCTE9HXCI6IFwiRXNjcmliZVwiLFxuXHRcIlBPU1RTXCI6IFwiUHVibGljYWNpb25lc1wiLFxuXHRcIlJFUExJRVNcIjogXCJSZXNwdWVzdGFzXCIsXG5cdFwiV0FMTEVUXCI6IFwiTW9uZWRlcm9cIixcblx0XCJUQUdcIjogXCJFdGlxdWV0YVwiLFxuXHRcIlVTRVJcIjogXCJVc3VhcmlvXCIsXG5cdFwiQ0xPU0VcIjogXCJDZXJyYXJcIixcblx0XCJUT1wiOiBcIkFcIixcblx0XCJBU1NFVFwiOiBcIlBvc2VzacOzbiBkZSBDYXBpdGFsXCIsXG5cdFwiU0VORFwiOiBcIkVudmlhclwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU2VndXJpZGFkXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiRGlzcG9uaWJsZVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTWVtb3LDoW5kdW0gUMO6YmxpY29cIixcblx0XCJUT19ERVNDXCI6IFwiVXN1YXJpbyBlai4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiQ8OzZGlnbyBQaW5cIixcblx0XCJQSU5fVEVYVFwiOiBcIkVsIGPDs2RpZ28gUElOIHRlIGF5dWRhIGEgZGFyIHNlZ3VyaWRhZCBhIGxhIGFwcCB5IGEgdHVzIGRhdG9zLlxcbjxici8+PGJyLz48Yj5Ob3RhOjwvYj4gVW5hIHZleiBhY3RpdmFkbywgdGllbmVzIHVuIG3DoXhpbW8gZGUgNCBpbnRlbnRvcyBwYXJhIGRlc2Jsb3F1ZWFybG87IHNpIHRlIG9sdmlkYXMgZGUgdHUgcGluIG8gZmFsbGFzLCBsYSBhcHAgZWxpbWluYXLDoSBsb3MgcmVnaXN0cm9zIGVuIGxvcyBkYXRvcyBkZSB1c3VhcmlvLiBQdWVkZXMgdm9sdmVyIGEgaW5pY2lhciBzZXNpw7NuIHkgY29udGludWFyIHVzYW5kbyBsYSBhcHAuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWNhY2lvbmVzXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiB2b3RlIHR1IGNvbnRlbmlkbyEgPGJyLz4gPGI+Tm90YTo8L2I+IExhcyBub3RpZmljYWNpb25lcyBpbmNsdXllbiB0YW1iacOpbiBlbCBwZXNvIGRlIGxhIHZvdGFjacOzbiBlbiBlbCBtZW5zYWplIGRlIGFsZXJ0YS4gKHlhIHNlYSBwb3Igdm90YWNpw7NuIHBvc2l0aXZhLCB2b3RhY2nDs24gbmVnYXRpdmEsIGRlc2hhY2VyIHZvdGFjacOzbikuXCIsXG5cdFwiVk9URVwiOiBcIlZvdGFyXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiBjb21lbnRlIGVuIHR1cyBwdWJsaWNhY2lvbmVzIG8gY29tZW50YXJpb3MhPGJyLz4gPGI+Tm90ZTo8L2I+IExhcyBub3RpZmljYWNpb25lcyBpbmNsdXllbiBjdWFuZG8gYWxndWllbiA8Yj5lZGl0YTwvYj4gc3VzIGNvbWVudGFyaW9zIHRhbWJpw6luLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21lbnRhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiB0ZSBzaWdhIG8gdGUgZGVqZSBkZSBzZWd1aXIhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW5jaW9uZXNcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiUmVjaWJpcsOhcyB1bmEgbm90aWZpY2FjacOzbiBjdWFuZG8gYWxndWllbiB0ZSBtZW5jaW9uZSBlbiBzdSBwdWJsaWNhY2nDs24vY29tZW50YXJpbyFcIixcblx0XCJSRVNURUVNXCI6IFwiUmVibG9ndWVhclwiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIlJlY2liaXLDoXMgdW5hIG5vdGlmaWNhY2nDs24gY3VhbmRvIGFsZ3VpZW4gaGFnYSByZWJsb2cgYSB0dSBwdWJsaWNhY2nDs24hXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJDb25maWd1cmFjaW9uZXNcIixcblx0XCJWT1RJTkdcIjogXCJWb3RvXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJFbCBwZXNvIG8gcG9yY2VudGFqZSBkZWwgdm90byBhZmVjdGEgYWwgcG9kZXIgZGUgdm90YWNpw7NuIGVuIGxhIGFwcCwgZGUgdGFsIG1hbmVyYSBxdWUgcHVlZGVzIHJlZ3VsYXIgdHUgcmVjb21wZW5zYSBkZSB2b3RhY2nDs24uIDxici8+PGJyLz48Yj5Ob3RhOjwvYj4gRXN0byBjYW1iaWFyw6EgdGFtYmnDqW4gZWwgcGVzby9wb3JjZW50YWplIGRlbCB2b3RvIGEgbGEgaG9yYSBkZSBoYWNlciB1biB2b3RvIG5lZ2F0aXZvXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2Vydmlkb3JcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJlY29tZW5kYWRvXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiR3VhcmRhciBDYW1iaW9zXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvIGRlIHZvdGFudGVzXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiQmllbnZlbmlkbyFcIixcblx0XCJMT0dJTl8xXCI6IFwiUmVnw61zdHJhdGUgY29uIHR1IG5vbWJyZSBkZSB1c3VhcmlvIHkgY29udHJhc2XDsWEgcGFyYSBjb250aW51YXIuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkxhIGNsYXZlIGRlIHB1YmxpY2FjacOzbiBzZSB1c2EgcGFyYSBwdWJsaWNhciwgY29tZW50YXIsIHZvdGFyLCBzZWd1aXIuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkxhIGNsYXZlIGFjdGl2YSBzZSB1c2EgcGFyYSBsYXMgdHJhbnNmZXJlbmNpYXMgeSBsYSBhY3R1YWxpemFjacOzbiBkZSBsYSBmb3RvIGRlIHBlcmZpbC5cIixcblx0XCJMT0dJTl80XCI6IFwiTGFzIGNyZWRlbmNpYWxlcyBkZWwgdXN1YXJpbyBzZSBndWFyZGFuIGxvY2FsbWVudGUgZW4gZWwgZGlzcG9zaXRpdm8uIEFsIGNlcnJhciBsYSBzZXNpw7NuIGxhcyBjcmVkZW5jaWFsZXMgc29uIGVsaW1pbmFkYXMhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTm8gdGllbmVzIHVuYSBjdWVudGE/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJSZWfDrXN0cmF0ZSBhaG9yYVwiLFxuXHRcIkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG5cdFwiQURWQU5DRURcIjogXCJBdmFuemFkb1wiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJDbGF2ZSBhY3RpdmEgcHJpdmFkYVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiQ2xhdmUgZGUgcHVibGljYWNpw7NuIHByaXZhZGFcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIkNvbnRyYXNlw7FhIG1hZXN0cmEvcHJpbmNpcGFsXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJOb21icmUgZGUgVXN1YXJpb1wiLFxuXHRcIkNBUkRfVklFV1wiOiBcIlZpc3RhIGRlIGNhc2lsbGFzXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVmlzdGEgY29tcGFjdGFcIixcblx0XCJTRUFSQ0hcIjogXCJCdXNjYXJcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIlB1YmxpY2FyIHVuIGFydMOtY3Vsb1wiLFxuXHRcIlJFUExZVE9cIjogXCJSZXNwb25kZXIgYVwiLFxuXHRcIlBPU1RcIjogXCJQdWJsaWNhclwiLFxuXHRcIlBSRVZJRVdcIjogXCJQcmV2aXN1YWxpemFjacOzblwiLFxuXHRcIkRFRkFVTFRcIjogXCJQb3IgZGVmZWN0byA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG90ZW5jaWFjacOzbiAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJSZWNoYXphciBQYWdvXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJHVUFSREFSIFBBUkEgTcOBUyBUQVJERVwiLFxuXHRcIkNMRUFSXCI6IFwiQk9SUkFSXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiUHVibGljYXIgY29udGVuaWRvXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiQ29tZW50YXIgY29udGVuaWRvXCIsXG5cdFwiVElUTEVcIjogXCJUw610dWxvXCIsXG5cdFwiVEFHU1wiOiBcIkV0aXF1ZXRhc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk5PIENPSU5DSURFXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJDb25maXJtYXIgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiSU5DT1JSRUNUT1wiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIlBvc3QgaW5pY2lhbFwiLFxuXHRcIlNFVF9QSU5cIjogXCJFc3RhYmxlY2VyIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkludHJvZHVjaXIgUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiRXN0w6FzIHNlZ3Vybz9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZ2VhciBlcyBpcnJldmVyc2libGUgwr9kZXNlYXMgY29udGludWFyP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIkVycm9yIGRlIHRyYW5zbWlzacOzbiwgaW50w6ludGFsbyBkZSBudWV2byFcIixcblx0XCJTVUNDRVNTXCI6IFwiQ29uc2VndWlkb1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUHVibGljYWNpw7NuIFJlYmxvZ3VlYWRhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkluaWNpbyBkZSBzZXNpw7NuIGZhbGxpZG8hIFBvciBmYXZvciBhc2Vnw7pyYXRlIGRlIHF1ZSBoYXMgaW5pY2lhZG8gc2VzacOzbiBjb24gdHUgY29udHJhc2XDsWEgbWFlc3RyYSBvIGNvbiBsYSBjbGF2ZSBkZSBQdWJsaWNhY2nDs24gcHJpdmFkYSBwcm9wb3JjaW9uYWRhIGVuIGVsIGFwYXJ0YWRvIEluaWNpYXIgU2VzacOzbiBzaSBlbGVnaXN0ZSBlbCBNb2RvIEF2YW56YWRvLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkluaWNpbyBkZSBzZXNpw7NuIGZhbGxpZG8hIFBvciBmYXZvciBhc2Vnw7pyYXRlIGRlIHF1ZSBoYXMgaW5pY2lhZG8gc2VzacOzbiBjb24gdHUgY29udHJhc2XDsWEgbWFlc3RyYSBvIGNvbiBsYSBjbGF2ZSBBY3RpdmEgcHJpdmFkYSBlbiBlbCBhcGFydGFkbyBJbmljaWFyIFNlc2nDs24gc2kgZWxlZ2lzdGUgZWwgTW9kbyBBdmFuemFkby5cIixcblx0XCJXQVJOSU5HXCI6IFwiQWR2ZXJ0ZW5jaWFcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiVm90YXIgYSB0ZXN0aWdvXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJWb3RhZG8gYSB0ZXN0aWdvXCIsXG5cdFwiQUdPXCI6IFwiaGFjZVwiLFxuXHRcIkZST01fTk9XXCI6IFwiZGVzZGUgYWhvcmFcIixcblx0XCJTRUNTXCI6IFwic2VndW5kb3NcIixcblx0XCJBX01JTlwiOiBcInVuIG1pbnV0b1wiLFxuXHRcIk1JTlNcIjogXCJtaW51dG9zXCIsXG5cdFwiQU5fSE9VUlwiOiBcInVuYSBob3JhXCIsXG5cdFwiSE9VUlNcIjogXCJob3Jhc1wiLFxuXHRcIkFfREFZXCI6IFwidW4gZMOtYVwiLFxuXHRcIkRBWVNcIjogXCJkw61hc1wiLFxuXHRcIkFfTU9OVEhcIjogXCJ1biBtZXNcIixcblx0XCJNT05USFNcIjogXCJtZXNlc1wiLFxuXHRcIkFfWUVBUlwiOiBcInVuIGHDsW9cIixcblx0XCJZRUFSU1wiOiBcImHDsW9zXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW51dG9zIGRlIGxlY3R1cmFcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiVm90YXIgTmVnYXRpdmFtZW50ZSBvIE1hcmNhciBDb21vIEluYXByb3BpYWRvXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiVG9tYXIgZm90b1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiU2VsZWNjaW9uYXIgSW1hZ2VuXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJFc3RhYmxlY2VyIFVSTCBwZXJzb25hbGl6YWRhXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJJbnNlcnRhciBJbWFnZW5cIixcblx0XCJFUlJPUlwiOiBcIkVycm9yXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiRXJyb3IgYWwgQ2FyZ2FyXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkPDoW1hcmEgQ2FuY2VsYWRhXCIsXG5cdFwiU0VUX1VSTFwiOiBcIkVzdGFibGVjZXIgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkVubGFjZSB3ZWIgZGlyZWN0byBhIGxhIGltYWdlblwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiRWwgY29tZW50YXJpbyBzZSBoYSBlbnRyZWdhZG8hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJFbGltaW5hciBjb21lbnRhcmlvcyBlcyBpcnJldmVyc2libGUuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJFbGltaW5hciBjb21lbnRhcmlvXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJTdWJpZW5kbyBJbWFnZW5cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiU3ViaWRhIENvbXBsZXRhZGFcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiTGEgc3ViaWRhIGhhIGZhbGxhZG9cIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJMYSBjb250cmFzZcOxYSBvIGVsIG5vbWJyZSBkZSBjdWVudGEgc29uIGluY29ycmVjdG9zXCIsXG5cdFwiSU5GT1wiOiBcIkluZm9ybWFjacOzblwiLFxuXHRcIlFSX1RFWFRcIjogXCJDb2xvY2EgZWwgY8OzZGlnbyBRUiBkZW50cm8gZGUgbGEgem9uYSBkZSBlc2NhbmVvXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiQXNlZ8O6cmF0ZSBkZSBxdWUgdGllbmVzIHN1ZmljaWVudGUgc2FsZG8gcGFyYSBsYSB0cmFuc2FjY2nDs24hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkVsIHVzdWFyaW8gYWwgcXVlIGVzdMOhcyBpbnRlbnRhbmRvIHRyYW5zZmVyaXIgZm9uZG9zIG5vIGV4aXN0ZSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiRXN0w6FzIHNlZ3VybyBkZSBxdWUgcXVpZXJlcyBoYWNlciBsYSB0cmFuc2ZlcmVuY2lhP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZpcm1hY2nDs25cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYWNjacOzbiB0cmFuc21pdGlkYVwiLFxuXHRcIkZFRURcIjogXCJJbmljaW9cIixcblx0XCJUUkVORElOR1wiOiBcIlRlbmRlbmNpYXNcIixcblx0XCJIT1RcIjogXCJDYWxpZW50ZVwiLFxuXHRcIk5FV1wiOiBcIk51ZXZvXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb2Npb25hZG9cIixcblx0XCJWT1RFU1wiOiBcIlZvdG9zXCIsXG5cdFwiUEFZT1VUXCI6IFwiUGFnb1wiLFxuXHRcIkNPTU1FTlRTXCI6IFwiQ29tZW50YXJpb3NcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlNpZW5kbyBUZW5kZW5jaWEgZHVyYW50ZSAzMCBkw61hc1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIk9yZGVuYXIgUHVibGljYWNpb25lcyBQb3JcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDaWNsbyBkZSBQYWdvXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBhZ28gUG90ZW5jaWFsXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJQYWdvIFBhc2Fkb1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJQYWdvIGRlIEF1dG9yXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUGFnbyBkZSBDdXJhY2nDs25cIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIkxhIHB1YmxpY2FjacOzbiBmdWUgZW52aWFkYSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiUHVibGljYWNpw7NuIHBhcmEgcG9zdGVyaW9yIHByZXNlbnRhY2nDs24hXCIsXG5cdFwiU0FWRURcIjogXCJHdWFyZGFkb1wiLFxuXHRcIkNMRUFSRURcIjogXCJCb3JyYWRvXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIk1hcmNhciBjb21vIGluYXByb3BpYWRhIHVuYSBwdWJsaWNhY2nDs24gcHVlZGUgZWxpbWluYXIgbGFzIHJlY29tcGVuc2FzIHkgaGFjZXIgcXVlIGVsIG1hdGVyaWFsIG1hcmNhZG8gc2VhIG1lbm9zIHZpc2libGUuPGJyPjxicj4gTWFyY2FyIGNvbW8gaW5hcHJvcGlhZG8gZGViZSB1dGlsaXphcnNlIGVuIGxvcyBzaWd1aWVudGVzIGNhc29zOiA8dWw+PGxpPkZyYXVkZSBvIFBsYWdpbzwvbGk+PGxpPkRpc2N1cnNvcyBkZSBPZGlvIG8gQWN0aXR1ZGVzIGRlIFByb3ZvY2FjacOzbiB5IE1vbGVzdGlhIENvbnN0YW50ZXM8L2xpPjxsaT5Db250ZW5pZG8gY2F0ZWdyaXphZG8gbWFsIGludGVuY2lvbmFkYW1lbnRlIG8gU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJMw61taXRlIGRlIHNvbGljaXR1ZCBhbGNhbnphZG8uIFJldmlzYSBvdHJhcyBldGlxdWV0YXMvdGVuZGVuY2lhcyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQdWJsaWNhY2nDs24gZWxpbWluYWRhIGRlIGxvcyBtYXJjYWRvcmVzIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQdWJsaWNhY2nDs24gYcOxYWRpZGEgYSBtYXJjYWRvcmVzIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVpbmljaWFyXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJNb2RpZmljYXIgRm90byBkZSBQZXJmaWxcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIk1vZGlmaWNhciBGb3RvIGRlIFBvcnRhZGFcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJQb3IgZmF2b3IgcHJvcG9yY2lvbmEgbGEgY2xhdmUgQWN0aXZhIHByaXZhZGEgc2kgaGFzIGVsZWdpZG8gZWwgbW9kbyBkZSBJbmljaW8gZGUgU2VzacOzbiBBdmFuemFkbyFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJFc3RvIHJlaW5pY2lhcsOhIGxhIGZvdG8gZGUgcGVyZmlsIGRlbCB1c3VhcmlvXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiRXN0byByZWluaWNpYXLDoSBsYSBmb3RvIGRlIHBvcnRhZGEgZGVsIHVzdWFyaW9cIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkxhIGFjdHVhbGl6YWNpw7NuIGRlbCBzZXJ2aWRvciByZXF1aWVyZSB1biByZWluaWNpbyFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiQWp1c3RlcyBhY3R1YWxpemFkb3MhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiSWRpb21hc1wiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiQXF1w60gcHVlZGVzIGNhbWJpYXIgZWwgaWRpb21hIGRlIGxhIGFwcFwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJFc3RhIG9wZXJhY2nDs24gcmVxdWllcmUgcXVlIGVsIHVzdWFyaW8gaW5pY2llIHNlc2nDs24gY29uIGxhIGNvbnRyYXNlw7FhIG1hZXN0cmEvcHJpbmNpcGFsLCBjbGF2ZSBhY3RpdmEvcHVibGljYXIuIFBvciBmYXZvciBpbmljaWEgc2VzacOzbiB5IHZ1ZWx2ZSBhIGludGVudGFybG8uXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGVyw61hXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiQ29sYWJvcmFkb3JlcyBkZSB0cmFkdWNjaW9uZXNcIixcblx0XCJTSEFSRVwiOiBcIkNvbXBhcnRpclwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiTWVyY2Fkb1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiQ2FtYmlvXCIsXG5cdFwiRFJBRlRTXCI6IFwiQm9ycmFkb3Jlc1wiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIsKhTGEgcHVibGljYWNpw7NuIHNlIGhhIGVsaW1pbmFkbyBkZSBib3JyYWRvcmVzIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCLCoUxhIHB1YmxpY2FjacOzbiBzZSBoYSBhw7FhZGlkbyBhIGJvcnJhZG9yZXMhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkRlc2xpY2UgaGFjaWEgbGEgaXpxdWllcmRhIHBhcmEgdmVyIGxhcyBvcGNpb25lc1wiLFxuXHRcIk1BTkFHRVwiOiBcIkdlc3Rpb25hclwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJMYSBmb3RvIHNlIGhhIGVsaW1pbmFkb1wiLFxuXHRcIkNPUFlcIjogXCJDb3BpYXJcIixcblx0XCJOT19JTUFHRVwiOiBcIsKhQcO6biBubyBoYXMgc3ViaWRvIG5pbmd1bmEgZm90byFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlRpcmUgaGFjaWEgYWJham8gcGFyYSBhY3R1YWxpemFyXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkFwcHMgZXh0ZXJuYXNcIixcblx0XCJQTFVHSU5TXCI6IFwiRXh0ZW5zaW9uZXNcIixcblx0XCJTVUdHRVNUXCI6IFwiU3VnZXJpclwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiTXV5IHByb250b1wiLFxuXHRcIkNIQUlOXCI6IFwiQ2hhaW5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiQXF1w60gcHVlZGVzIGNhbWJpYXIgbGEgYmxvY2tjaGFpbiBvIGxhIHBsYXRhZm9ybWEgcG9yIGRlZmVjdG8uXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJEaXZpc2FcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiQXF1w60gcHVlZGUgY2FtYmlhciBzdSBtb25lZGEgcG9yIGRlZmVjdG8uIFZlcsOhIGVsIHZhbG9yIGRlIHJlY29tcGVuc2EgcG9zdC9jb21lbnRhcmlvIGVuIGVzdGEgbW9uZWRhLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIGRlIENhcmFjdGVyw61zdGljYXM8L2I+PGJyPiBBY2NlZGUgYSBhcnTDrWN1bG9zIMO6bmljb3MgZGUgY3VhbHF1aWVyIHRlbWEgZW4gbG9zIHF1ZSBlc3TDqXMgaW50ZXJlc2FkbyA8YnI+IENvbXBhcnRlIGNvbiBsb3MgYXV0b3JlcyBjb21lbnRhbmRvLCBkaXNjdXRpZW5kbyB0ZW1hcy48YnI+IFZvdGFyIGxvcyBhcnTDrWN1bG9zIHJlY29tcGVuc2EgYWwgYXV0b3IgdGFudG8gY29tbyBnYW5hIHJlY29tcGVuc2FzIHBvciBjdXJhY2nDs24gZGUgY29udGVuaWRvcy4gPGJyPiBQdWJsaWNhIHR1cyBhcnTDrWN1bG9zLCBub3RhcyBkZSBibG9nLCBob3NwZWRhIGdyYXR1aXRhbWVudGUgeSBnYW5hIHJlY29tcGVuc2FzIGFsIGF0cmFlciB5IGdhbmFyIHNlZ3VpZG9yZXMuPGJyPiBFc2NyaWJlIGFydMOtY3Vsb3MgZW4gdml2bywgYXPDrSBjb21vIHRhbWJpw6luIGd1YXJkYXIgbcO6bHRpcGxlcyBib3JyYWRvcmVzIGRlbCBhcnRpY3VsbyBwYXJhIGZ1dHVyYSBwdWJsaWNhY2nDs24uPGJyPiBNYXJjYSB0dXMgYXJ0w61jdWxvcyBmYXZvcml0b3MgcGFyYSBsZWVybG9zIG1hcyB0YXJkZS48YnI+IEludGVyY2FtYmlhIG8gc2FjYSBkaW5lcm8gZGUgdHVzIGdhbmFuY2lhczxicj4gRW52aWEgZm9uZG9zIGEgY3VhbHF1aWVyIGF1dG9yIG8gdXN1YXJpbywgYW1pZ29zLCBzZWd1aWRvcmVzLCBldGMuPGJyPiBTaWd1ZSBhdXRvcmVzIGludGVyZXNhbnRlcywgYmxvZ2dlcnMuPGJyPiBCdXNjYSB0dXMgc2VndWlkb3JlcyB5IGF1dG9yZXMgcXVlIHNpZ3Vlcy48YnI+IFJlY2liZSBub3RpZmljYWNpb25lcyBwYXJhIG1hbnRlbmVydGUgZW4gY29udGFjdG8gY29uIHR1cyBzZWd1aWRvcmVzIHkgZGlzY3VzaW9uZXMgZW4gbGFzIHF1ZSBlc3RlcyBpbnZvbHVjcmFkby4gPGJyPiBCdXNjYSBjYXRlZ29yw61hcy9ldGlxdWV0YXMgZGUgYXJ0w61jdWxvcyB5IGF1dG9yZXMuPGJyPlBlcnNvbmFsaXphIHR1IHBlcmZpbC48YnI+IE11Y2hhcyBtYXMgZnVuY2lvbmFsaWRhZGVzIHBvciB2ZW5pci48YnI+PGJyPjxiPlNlZ3VyaWRhZDwvYj48YnI+MS4gTGEgYXBsaWNhY2nDs24gbnVuY2EgYWNjZWRlcsOhIG8gbWFudGVuZHLDoSBmb25kb3MgZGUgdXN1YXJpb3MuIDxicj4yLiBMYSBhcGxpY2FjacOzbiBvZnJlY2UgdW4gbW9kZWxvIGRlIHNlZ3VyaWRhZCBsYWRvLWNsaWVudGUsIGNvbiBjbGF2ZXMgcHJpdmFkYXMgaG9zcGVkYWRhcyBsb2NhbG1lbnRlIHkgbnVuY2EgZW52aWFkYXMgYSBuaW5nw7puIHNlcnZpZG9yLCB1c3RlZCBlcyByZXNwb25zYWJsZSBkZSByZXNwYWxkYXIgc3VzIGNvbnRyYXNlw7Fhcy48YnI+My4gTGEgYXBsaWNhY2nDs24gb2ZyZWNlIHVuYSBleHBlcmllbmNpYSBkZWwgdXN1YXJpbyBzaW1wbGUgeSBhdHJhY3RpdmEsIGEgdHJhdsOpcyBkZSBzdSBpbnRlcmZhei4gPGJyPjQuIExhIGFwbGljYWNpw7NuIG9mcmVjZSB1bmEgY2FwYSBleHRyYSBkZSBzZWd1cmlkYWQgY29uIHVuIGPDs2RpZ28tcGluPGJyPjxicj5Tb3BvcnRlIGRlIGVTdGVlbSBzb3BvcnRhIFN0ZWVtIHkgUGxhdGFmb3JtYXMgR29sb3MuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJGdW5kYWRvciB5IGRlc2Fycm9sbGFkb3IgUHJpbmNpcGFsXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBw7FhZGlyIGN1ZW50YVwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGFmb3JtYVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkRlcMOzc2l0byBkZSBnYXJhbnTDrWFcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJBZ2VudGUgRXNjcm93XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiRmVjaGEgbMOtbWl0ZSBkZSByYXRpZmljYWNpw7NuXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJWZW5jaW1pZW50byBFc2Nyb3dcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiVGFyaWZhIGRlIEVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIlTDqXJtaW5vcyBkZSBFc2Nyb3dcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTW9kbyBOb2NoZVwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiTW9kbyBEw61hXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiVmVyIGVsIHRleHRvIGNvbXBsZXRvXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIlVzdWFyaW8gTm8gRW5jb250cmFkb1wiLFxuXHRcIkFQUFJPVkVcIjogXCJBcHJvYmFkYVwiLFxuXHRcIkRJU1BVVEVcIjogXCJDb25mbGljdG9cIixcblx0XCJSRUxFQVNFXCI6IFwiTGliZXJhclwiLFxuXHRcIkZST01cIjogXCJEZXNkZVwiLFxuXHRcIklEXCI6IFwiSURcIixcblx0XCJTVUJNSVRcIjogXCJFbnZpYXJcIixcblx0XCJSRUNFSVZFUlwiOiBcIlJlY2liaXJcIixcblx0XCJMT0NBVElPTlwiOiBcIkxvY2FsaXphY2nDs25cIixcblx0XCJXRUJTSVRFXCI6IFwiUMOhZ2luYSBXZWJcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJNb3N0cmFyIG5vbWJyZVwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCLYrtin2YbZh1wiLFxuXHRcIkxPR0lOXCI6IFwi2YjYsdmI2K9cIixcblx0XCJMT0dPVVRcIjogXCLYrtix2YjYrFwiLFxuXHRcIlBST0ZJTEVcIjogXCLZvtix2YjZgdin24zZhFwiLFxuXHRcIkZPTExPV1wiOiBcItiv2YbYqNin2YQg2qnYsdiv2YZcIixcblx0XCJCT09LTUFSS1NcIjogXCLZhti02KfZhtqp4oCM2YfYp1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwi2KfZhtiq2YLYp9mEXCIsXG5cdFwiTUFSS0VUXCI6IFwi2KjYp9iy2KfYsVwiLFxuXHRcIlNFVFRJTkdTXCI6IFwi2KrZhti424zZhdin2KpcIixcblx0XCJBQk9VVFwiOiBcItiv2LHYqNin2LHZh1wiLFxuXHRcIkFCT1VUXzFcIjogXCLYrNin24zbjCDaqdmHINmH2LEg2qnYs9uMINmF24zYqtmI2KfZhtivINio2LHYp9uMINmF2K3YqtmI2KfbjCDYqtmI2YTbjNiv24wg2K7ZiNivINiv2LHYp9mF2K8g2qnYs9ioINqp2YbYryFcIixcblx0XCJBQk9VVF8yXCI6IFwi2KjYpyDYp9iz2KrZgdin2K/ZhyDYp9iyINiy24zYsdiz2KfYrtiqe3vZhtin2YUg2LLbjNix2LPYp9iu2Kp9fSDYqtmI2YTbjNivINi02K/ZhyDYp9iz2KouINin24zZhiDYp9m+2YTbjNqp24zYtNmGINiz2KfYrtiq2Ycg2LTYr9mHINiq2YjYs9i3XCIsXG5cdFwiQUJPVVRfM1wiOiBcItin24zZhiDbjNqpINm+2LHZiNqY2Ycg2YXZiNio2KfbjNmE24wg2KfYs9iqINqp2Ycg2KjZhyDYtdmI2LHYqiDZhdiq2YYg2KjYp9iyINmIINiq2K3YqiDYp9iv2KfYsdmHINuM2qkg2qnZhduM2KrZhyDZhdix2K/ZhduMINmF24wg2KjYp9i02K8uINin24zZhiDYqNix2YbYp9mF2Ycg2KfZhdqp2KfZhiDYr9iz2KrYsdiz24wg2KjZhyDZhdit2KrZiNinINix2Kcg2KjYsdin24wg2K7ZiNin2YbYr9mG2Iwg2K/YsdisINmG2LjYsdin2KrYjCDYsdij24wg2K/Yp9iv2YbYjCDYqtmI2YTbjNivINmF2K3YqtmI2KfYjCDYp9mG2KrZgtin2YTYjCDYr9ix2KfZhdivINiy2KfbjNuMINmIwqDYutuM2LHZhyDYsdinINmF24wg2K/Zh9ivLiDZiNuM2pjar9uM4oCM2YfYp9uMINqp2Ycg2KrZiNiz2Lcg2KjZhNin2qnigIzahtuM2YYge3vZhtin2YUg2b7ZhNiq2YHZiNix2YV9fSDZiCB7e9mG2KfZhSDYs9in24zYqn19INin2LHYp9im2Ycg2LTYr9mHINin2LPYqi5cIixcblx0XCJBQk9VVF80XCI6IFwi27EuINin2b7ZhNuM2qnbjNi02YYg2YfYsdqv2LIg2KjZhyDZvtmI2YTigIzZh9in24wg2qnYp9ix2KjYsSDYr9iz2KrYsdiz24wg2b7bjNiv2Kcg2YbZhduM4oCM2qnZhtivINmIINin2K7YqtuM2KfYsduMINiv2LEg2YXZiNix2K8g2KLZhiDZhtiv2KfYsdivLlwiLFxuXHRcIkFCT1VUXzVcIjogXCLbsi4g2KfZvtmE24zaqduM2LTZhiDZhdiv2YQg2KfZhdmG24zYqtuMINiz2YXYqiDZhdi02KrYsduMINiv2KfYsdiv2Iwg2KjZhyDYt9mI2LHbjCDaqdmHINqp2YTbjNiv2YfYp9uMINiu2LXZiNi124wg2KjZhyDYtdmI2LHYqiDZhdit2YTbjCDYsNiu24zYsdmHINmF24zigIzYtNmI2YbYryDZiCDZh9ix2q/YsiDYqNmHINmH24zahiDYs9ix2YjYsduMINmB2LHYs9iq2KfYr9mHINmG2YXbjOKAjNi02YjZhtivLlwiLFxuXHRcIkFCT1VUXzZcIjogXCLbsy4g2KfZvtmE24zaqduM2LTZhiDYsdin2KjYtyDZiCDYqtis2LHYqNmH4oCM24wg2qnYp9ix2KjYsduMINiz2KfYr9mHINmIINis2LDYp9io24wg2K/Yp9ix2K8uXCIsXG5cdFwiQUJPVVRfN1wiOiBcItu0LiDYqtix2YUg2KfZgdiy2KfYsdmH24zahtqv2KfZhyDZhtuM2KfYsiDYqNmHINiv2LHbjNin2YHYqiDYp9i32YTYp9i52KfYqiDYtNiu2LXbjCDaqdin2LHYqNix2KrYr9in2LHYry5cIixcblx0XCJBQk9VVF84XCI6IFwi2KjZhyBnb29kLWthcm1hINio2Ycg2LnZhtmI2KfZhiDYtNin2YfYryDYsdij24wg2KjYr9mH24zYr1wiLFxuXHRcIkFCT1VUXzlcIjogXCLYqtmF2KfYsy/YqNin2LLYrtmI2LHYrzpcIixcblx0XCJBQk9VVF8xMFwiOiBcItin2LfZhNin2LnYp9iqINio24zYtNiq2LE6XCIsXG5cdFwiUkVNT1ZFXCI6IFwi2K3YsNmBXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLZiNi22LnbjNiqINio2KfYstin2LFcIixcblx0XCJQUklDRVwiOiBcItmC24zZhdiqXCIsXG5cdFwiQU1PVU5UXCI6IFwi2YXYqNmE2LpcIixcblx0XCJUT1RBTFwiOiBcItis2YXYuVwiLFxuXHRcIk5PT1JERVJTXCI6IFwi2YfbjNqG2q/ZiNmG2Ycg2LPZgdin2LHYtCDYqNin2LLbjCDYqNix2KfbjFwiLFxuXHRcIkRBVEVcIjogXCLYqtin2LHbjNiuXCIsXG5cdFwiQlVZXCI6IFwi2K7YsduM2K9cIixcblx0XCJTRUxMXCI6IFwi2YHYsdmI2LRcIixcblx0XCJPUEVOXCI6IFwi2KjYp9iyXCIsXG5cdFwiSElTVE9SWVwiOiBcItiq2KfYsduM2K7ahtmHXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLYr9mG2KjYp9mEINqp2LHYr9mGINmF2KrZgtin2KjZhFwiLFxuXHRcIkZPTExPV0VEXCI6IFwi2K/Zhtio2KfZhCDYtNiv2YdcIixcblx0XCJVTkZPTExPV1wiOiBcIti52K/ZhSDYr9mG2KjYp9mEINqp2LHYr9mGXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwi2K/Zhtio2KfZhCDZhduM2qnZhtuM2K9cIixcblx0XCJGT0xMT1dFUlNcIjogXCLYr9mG2KjYp9mEINqp2YbZhtiv2q/Yp9mGXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcItis2LPYqtis2YjbjCDYr9mG2KjYp9mEINqp2YbZhtiv2q/Yp9mGXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcItis2LPYqtis2YjbjCDYr9mG2KjYp9mEINi02YjZhtiv2q/Yp9mGXCIsXG5cdFwiQllcIjogXCLYqtmI2LPYt1wiLFxuXHRcIklOXCI6IFwi2K/YsVwiLFxuXHRcIk1FTlVcIjogXCLZgdmH2LHYs9iqXCIsXG5cdFwiQk9PS01BUktcIjogXCLZhti02KfZhtqpXCIsXG5cdFwiUkVCTE9HXCI6IFwi2KfYtNiq2LHYp9qpINmF2KzYr9ivXCIsXG5cdFwiVVBWT1RFXCI6IFwi2LHYo9uMINmF2KvYqNiqXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLYsdij24wg2YXZhtmB24xcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwi2K3YsNmBINix2KPbjCDZhdmG2YHbjFwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi2K3YsNmBINix2KPbjCDZhdir2KjYqlwiLFxuXHRcIlJFUExZXCI6IFwi2b7Yp9iz2K5cIixcblx0XCJFRElUXCI6IFwi2YjbjNix2KfbjNi0XCIsXG5cdFwiUE9TVF8xXCI6IFwi2KjYsdin24wg2K/bjNiv2YYg2q/YstuM2YbZh+KAjNmH2KfYjCDYsdmI24wg2YbYuNix2KfYqiDYqNmHINqG2b4g2Kjaqdi024zYry5cIixcblx0XCJQT1NUXzJcIjogXCLYqNix2KfbjCDYr9uM2K/ZhiDZhti42LHYp9iqINmB2LHYuduM2Iwg2LHZiNuMINmG2LjYsdin2Kog2qnZhNuM2qkg2qnbjNmG2K8uXCIsXG5cdFwiT1BUSU9OU1wiOiBcItqv2LLbjNmG2YfigIzZh9inXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi2KfYtNiq2LHYp9qpINmF2KzYr9ivINiq2YjYs9i3XCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwi2KfbjNmG2KzYpyDZh9mG2YjYsiDahtuM2LLbjCDZhtuM2LPYqi4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwi2YXYp9mG2K/Zh+KAjNmH2KdcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e9mG2KfZhSDZvtmE2KrZgdmI2LHZhX192Iwg2YbZhdin2K/Zh9in24wg2YLYp9io2YQg2K/Yp9ivwqDZiMKg2LPYqtivINqp2Ycg2YXbjOKAjNiq2YjYp9mGINii2YYg2LHYpyDYr9ixINmH2LEg2LLZhdin2YYg2KfZhtiq2YLYp9mEINiv2KfYry4ge3vZhtin2YUg2b7ZhNiq2YHZiNix2YV9fSDYsdinINmF24zigIzYqtmI2KfZhiDYp9iyINi32LHbjNmCINmB2LHYotuM2YbYr9uMINio2Ycg2YbYp9mFINio2KfZhNinINio2LHYr9mGINmC2K/YsdiqINio2Ycge3vYqtmI2KfZhiDYqtin2KvbjNixINqv2LDYp9ix2b7ZhNiq2YHZiNix2YV9fSDYqtio2K/bjNmEINqp2LHYry5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e9iq2YjYp9mGINiq2KfYq9uM2LEg2q/YsNin2LHZvtmE2KrZgdmI2LHZhX192Iwg2YbZhdin2K/Zh9in24wg2KrYo9ir24zYsdqv2LDYp9ix24wg2qnZhyDZgtiv2LHYqiDYqNuM2LTYqtix24wg2KjYsdin24wg2Ybar9mH2K/Yp9ix24wg2KjZhNmG2K/Zhdiv2Kog2Ygg2LHYo9uMINiv2KfYr9mGINiv2LEg2b7Ys9iq4oCM2YfYpyDaqdiz2Kgg2YXbjOKAjNqp2YbZhtivLiDZh9ixINqG2Ycg2KfbjNmGINix2Kcg2KjbjNi02KrYsSDZhtqv2YfYr9in2LHbjCDaqdmG24zYr9iMINio24zYtNiq2LEg2YXbjOKAjNiq2YjYp9mG24zYryDYqNixINm+2KfYr9in2LTigIzZh9in24wg2K/bjNqv2LHYp9mGINiq2KPYq9uM2LEg2K/Yp9i02KrZhyDYqNin2LTbjNivINmIINiv2LEg2KfYstin24wg2LHYo9uMINiv2KfYr9mGINiv2YLbjNmC2Iwg2b7Yp9iv2KfYtCDaqdiz2Kgg2YbZhdin24zbjNivLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcItmG2YXYp9iv2YfYp9uM24wg2KjYpyDYp9ix2LLYtCDYrdiv2YjYryB7e3BsYXRmb3Jtc3VuaXR9fSDYp9iyIHt72YbYp9mFINm+2YTYqtmB2YjYsdmFfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi2KfYsdiy2LQg2KjYsdii2YjYsdivINi02K/Zh1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcItin2LHYsti0INio2LHYotmI2LHYryDYtNiv2Ycg2YXYqNiq24wg2KjYsSDYp9ix2LLYtCDZhdiq2YjYs9i3INu3INix2YjYstmH4oCM24wge3vZhtin2YUg2b7ZhNiq2YHZiNix2YV9fSDYp9iz2KouXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcItiq2KfYsduM2K7ahtmH4oCM24wg2KrYsdin2qnZhti0XCIsXG5cdFwiUE9TVElOR1wiOiBcItin2LHYs9in2YQg2YXYt9mE2KhcIixcblx0XCJQUk9GSUxFXzVcIjogXCLaqdmE24zYryDYp9ix2LPYp9mEINmF2LfZhNioINio2LHYp9uMINin2LHYs9in2YQg2qnYsdiv2YYg2YXYt9mE2Kgg2Ygg2LHYo9uMINiv2KfYr9mGINin2LPYqtmB2KfYr9mHINmF24zigIzYtNmI2K8uINin24zZhiDYqNin24zYryDYqNinINqp2YTbjNiv2YfYp9uMINmB2LnYp9mEINmIINmF2KfZhNqpINmF2KrZgdin2YjYqiDYqNin2LTYry5cIixcblx0XCJPV05FUlwiOiBcItmF2KfZhNqpXCIsXG5cdFwiUFJPRklMRV82XCI6IFwi2qnZhNuM2K8g2YXYp9mE2qkg2qnZhNuM2K8g2KfYtdmE24wg2K3Ys9in2Kgg2KfYs9iqINmIINio2LHYp9uMINiq2LrbjNuM2LEg2K/Yp9iv2YYg2qnZhNuM2K/Zh9in24wg2K/bjNqv2LEg2YXZiNix2K8g2YbbjNin2LIg2KfYs9iqLiDaqdmE24zYryDYrti12YjYtduMINuM2Kcg2q/YsNix2YjYp9qY2Ycg2KjYsdin24wg2qnZhNuM2K8g2YXYp9mE2qkg2KjYp9uM2K8g2KrYpyDYrdivINin2YXaqdin2YYg2KLZgdmE2KfbjNmGINmG2q/Zh9iv2KfYsduMINi02YjYry5cIixcblx0XCJBQ1RJVkVcIjogXCLZgdi52KfZhFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcItqp2YTbjNivINmB2LnYp9mEINio2LHYp9uMINin2YbYqtmC2KfZhCDZiCDYs9mB2KfYsdi0INiv2KfYr9mGINiv2LEg2KjYp9iy2KfYsSDYr9in2K7ZhNuMINin2LPYqtmB2KfYr9mHINmF24zigIzYtNmI2K8uXCIsXG5cdFwiTUVNT1wiOiBcItuM2KfYr9iv2KfYtNiqXCIsXG5cdFwiUFJPRklMRV84XCI6IFwi2qnZhNuM2K8g24zYp9iv2K/Yp9i02Kog2KjYsdin24wg2KfbjNis2KfYryDZiCDYrtmI2KfZhtiv2YYg24zYp9iv2K/Yp9i02KrigIzZh9inINin2LPYqtmB2KfYr9mHINmF24zigIzYtNmI2K8uXCIsXG5cdFwiQkxPR1wiOiBcItio2YTYp9qvXCIsXG5cdFwiUE9TVFNcIjogXCLZvtiz2KrigIzZh9inXCIsXG5cdFwiUkVQTElFU1wiOiBcItm+2KfYs9iu4oCM2YfYp1wiLFxuXHRcIldBTExFVFwiOiBcItqp24zZgSDZvtmI2YRcIixcblx0XCJUQUdcIjogXCLYqNix2obYs9ioXCIsXG5cdFwiVVNFUlwiOiBcItqp2KfYsdio2LFcIixcblx0XCJDTE9TRVwiOiBcItio2LPYqtmGXCIsXG5cdFwiVE9cIjogXCLYqNmHXCIsXG5cdFwiQVNTRVRcIjogXCLYr9in2LHYp9uM24xcIixcblx0XCJTRU5EXCI6IFwi2YHYsdiz2KrYp9iv2YZcIixcblx0XCJTRUNVUklUWVwiOiBcItin2YXZhtuM2KpcIixcblx0XCJBVkFJTEFCTEVcIjogXCLZhdmI2KzZiNivXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLbjNin2K/Yr9in2LTYqiDYudmF2YjZhduMXCIsXG5cdFwiVE9fREVTQ1wiOiBcItqp2KfYsdio2LEg2YXYq9mE2KfZiyBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCLZvtuM2YbigIzaqdivXCIsXG5cdFwiUElOX1RFWFRcIjogXCLZvtuM2YbigIzaqdivINio2Ycg2KfZhdmGINqp2LHYr9mGINin2b7ZhNuM2qnbjNi02YYg2Ygg2K/Yp9iv2YfigIzZh9in24wg2LTZhdinINqp2YXaqSDZhduM4oCM2qnZhtivLiA8YnIvPjxici8+PGI+2KrZiNis2Yc6PC9iPiDZvtizINin2LIg2YHYudin2YTigIzYs9in2LLbjNiMINi02YXYpyDZgdmC2Lcg27Qg2KjYp9ixINio2LHYp9uMINio2KfYsiDaqdix2K/ZhiDZgdix2LXYqiDYr9in2LHbjNiv2Jsg2Kfar9ixINm+24zZhiDYsdinINmB2LHYp9mF2YjYtCDaqdmG24zYryDbjNinINin2LTYqtio2KfZhyDZiNin2LHYryDaqdmG24zYr9iMINin2b7ZhNuM2qnbjNi02YYg2K/Yp9iv2YfigIzZh9in24wg2KvYqNiqINi02K/Zh+KAjNuMINqp2KfYsdio2LEg2LHYpyDYrdiw2YEg2K7ZiNin2YfYryDaqdix2K8uINmF24zigIzYqtmI2KfZhtuM2K8g2K/ZiNio2KfYsdmHINmI2KfYsdivINi02YjbjNivINmIINio2Ycg2KfYs9iq2YHYp9iv2Ycg2KfYsiDYp9m+2YTbjNqp24zYtNmGINin2K/Yp9mF2Ycg2K/Zh9uM2K8uXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcItin2LfZhNin2Lkg2LHYs9in2YbbjOKAjNmH2KdcIixcblx0XCJWT1RFX1RFWFRcIjogXCLZiNmC2KrbjCDaqdmHINqp2LPbjCDYqNmHINmF2K3YqtmI2KfbjCDYtNmF2Kcg2LHYo9uMINmF24zigIzYr9mH2K/YjCDYqNmHINi02YXYpyDYp9i32YTYp9i5INix2LPYp9mG24wg2YXbjCDar9ix2K/YryEgPGJyLz4gPGI+2KrZiNis2Yc6PC9iPiDYp9i32YTYp9i5INix2LPYp9mG24zigIzZh9inINi02KfZhdmEINmI2LLZhiDYsdij24wg2Ygg2YbbjNiyINm+24zYp9mFINmH2LTYr9in2LEg2KfYs9iqLiAo2LTYp9mF2YQg2LHYo9uMINmF2KvYqNiq2Iwg2LHYo9uMINmF2YbZgduM2Iwg2K3YsNmBINix2KPbjCkuXCIsXG5cdFwiVk9URVwiOiBcItix2KPbjCDYr9in2K/ZhlwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcItmI2YLYqtuMINqp2Ycg2qnYs9uMINiv2LHCoNio2KfYsdmH4oCM24wg2YXYt9in2YTYqCDYp9ix2LPYp9mE24wg2LTZhdinINmG2LjYsSDZhduM4oCM2K/Zh9iv2Iwg2KjZhyDYtNmF2Kcg2KfYt9mE2KfYuSDYsdiz2KfZhtuMINmF24zar9ix2K/YryE8YnIvPiA8Yj7YqtmI2KzZhzo8L2I+2KfYt9mE2KfYuSDYsdiz2KfZhtuMINi02KfZhdmEINiy2YXYp9mG24wg2qnZhyDaqdiz24wg2YbYuNixINiu2YjYryDYsdinIDxiPtmI24zYsdin24zYtDwvYj4g2YXbjOKAjNqp2YbYr9iMINmG24zYsiDZh9iz2KouXCIsXG5cdFwiQ09NTUVOVFwiOiBcItmG2LjYsSDYr9in2K/ZhlwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwi2YjZgtiq24wg2qnZhyDaqdiz24wg2LTZhdinINix2Kcg2K/Zhtio2KfZhCDZhduM4oCM2qnZhtivINuM2Kcg2K/Zhtio2KfZhCDaqdix2K/ZhiDYsdinINit2LDZgSDZhduM4oCM2qnZhtiv2IzYqNmHINi02YXYpyDYp9i32YTYp9i5INix2LPYp9mG24wg2YXbjNqv2LHYr9ivIdmLXCIsXG5cdFwiTUVOVElPTlNcIjogXCLYsNqp2LEg2YbYp9mFXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcItmI2YLYqtuMINqp2Ycg2qnYs9uMINmG2KfZhSDYtNmF2Kcg2LHYpyDYr9ixINm+2LPYqi/Zhti42LEg2K7ZiNivINiw2qnYsSDZhduM4oCM2qnZhtiv2Iwg2KjZhyDYtNmF2Kcg2KfYt9mE2KfYuSDYsdiz2KfZhtuMINmF24zar9ix2K/YryFcIixcblx0XCJSRVNURUVNXCI6IFwi2KfYtNiq2LHYp9qpINqv2LDYp9ix24wg2YXYrNiv2K9cIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCLZiNmC2KrbjCDaqdmHINqp2LPbjCDZvtiz2Kog2LTZhdinINix2Kcg2YXYrNiv2K8g2KjZhyDYp9i02KrYsdin2qkg2q/YsNin2LHYr9iMINio2Ycg2LTZhdinINin2LfZhNin2Lkg2LHYs9in2YbbjCDZhduM2q/Ysdiv2K8hXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCLZvtuM2qnYsdio2YbYr9uM4oCM2YfYp1wiLFxuXHRcIlZPVElOR1wiOiBcItix2KPbjOKAjNiv2YfbjFwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi2YjYstmGINuM2Kcg2K/Ysdi12K8g2LHYo9uM4oCM2K/Zh9uMINio2LEg2YLYr9ix2Kog2LHYo9uM4oCM2K/Zh9uMINiv2LEg2YbYsdmFINin2YHYstin2LHYqtij2KvbjNixINmF24zigIzar9iw2KfYsdiv2Iwg2KjZhtinwqDYqNixwqDYp9uM2YbYjCDZhduM4oCM2KrZiNin2YbbjNivINm+2KfYr9in2LQg2LHYo9uM4oCM2K/Zh9uMINiu2YjYryDYsdinINiq2YbYuNuM2YUg2qnZhtuM2K8uIDxici8+PGJyLz48Yj7YqtmI2KzZhzo8L2I+INin24zZhiDZiNiy2YYv2K/Ysdi12K8g2LHYo9uM4oCM2K/Zh9uMINix2Kcg2KjYsdin24wg2LHYo9uMINmF2YbZgduMINmH2YUg2KrYutuM24zYsSDYrtmI2KfZh9ivINiv2KfYryDZiCDYr9ixINiq2YXYp9mFINis2KfZh9in24wg2YbYsdmFINin2YHYstin2LHYp9i52YXYp9mEINiu2YjYp9mH2K8g2LTYr1wiLFxuXHRcIlNFUlZFUlwiOiBcItiz2LHZiNixXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLYqtmI2LXbjNmHINi02K/Zh1wiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItiw2K7bjNix2Ycg2qnYsdiv2YYg2KrYutuM24zYsdin2KpcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItin2LfZhNin2LnYp9iqINix2KPbjCDYr9mH2YbYr9qv2KfZhlwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcItiu2YjYtCDYotmF2K/bjNivIVwiLFxuXHRcIkxPR0lOXzFcIjogXCLYrNmH2Kog2KfYr9in2YXZhyDYqNinINmG2KfZhSDaqdin2LHYqNix24wg2Ygg2q/YsNix2YjYp9qY2YfigIzbjCDYrtmI2K8g2YjYp9ix2K8g2LTZiNuM2K8uXCIsXG5cdFwiTE9HSU5fMlwiOiBcItqp2YTbjNivINin2LHYs9in2YQg2YXYt9mE2Kgg2KjYsdin24wg2KfYsdiz2KfZhCDaqdix2K/ZhiDZhdi32YTYqNiMINmG2LjYsSDYr9in2K/ZhtiMINix2KPbjCDYr9in2K/ZhtiMINmIINiv2YbYqNin2YQg2qnYsdiv2YYg2KfYs9iq2YHYp9iv2Ycg2YXbjOKAjNi02YjYry5cIixcblx0XCJMT0dJTl8zXCI6IFwi2qnZhNuM2K8g2YHYudin2YQg2KjYsdin24wg2KfZhtiq2YLYp9mEINmIINio2YfigIwg2LHZiNiyINix2LPYp9mG24wg2KrYtdmI24zYsSDZvtix2YjZgdin24zZhCDYp9iz2KrZgdin2K/ZhyDZhduM4oCM2LTZiNivLlwiLFxuXHRcIkxPR0lOXzRcIjogXCLZhdiv2KfYsdqpINqp2KfYsdio2LEg2KjZhyDYt9mI2LEg2YXYrdmE24wg2LHZiNuMINiv2LPYqtqv2KfZhyDZhtqv2YfYr9in2LHbjCDZhduM4oCM2LTZiNivLiDYr9ixINmH2Ybar9in2YUg2K7YsdmI2KzYjCDZhdiv2KfYsdqpINit2LDZgSDZhduM4oCM2LTZiNivIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcItit2LPYp9ioINmG2K/Yp9ix24zYr9ifXCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCLYp9qp2YbZiNmGINir2KjYquKAjNmG2KfZhSDaqdmG24zYr1wiLFxuXHRcIkNBTkNFTFwiOiBcItmE2LrZiCDaqdix2K/ZhlwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi2K3Yp9mE2Kog2b7bjNi02LHZgdiq2YdcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwi2qnZhNuM2K8g2K7YtdmI2LXbjCDZgdi52KfZhFwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi2qnZhNuM2K8g2K7YtdmI2LXbjCDYp9ix2LPYp9mEINmF2LfZhNioXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCLar9iw2LHZiNin2pjZh+KAjNuMINin2LXZhNuMXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLZhtin2YUg2qnYp9ix2KjYsduMXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi2YbZhdin24wg2qnYp9ix2KpcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLZhtmF2KfbjCDZgdi02LHYr9mHXCIsXG5cdFwiU0VBUkNIXCI6IFwi2KzYs9iq2KzZiFwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwi2KvYqNiqINuM2qkg2K/Yp9iz2KrYp9mGXCIsXG5cdFwiUkVQTFlUT1wiOiBcItm+2KfYs9iuINiv2KfYr9mGINio2YdcIixcblx0XCJQT1NUXCI6IFwi2KfYsdiz2KfZhCDZhdi32YTYqFwiLFxuXHRcIlBSRVZJRVdcIjogXCLZvtuM2LTigIzZhtmF2KfbjNi0XCIsXG5cdFwiREVGQVVMVFwiOiBcItm+24zYtOKAjNmB2LHYtiDbtduw2aogLyDbtduw2apcIixcblx0XCJQT1dFUlVQXCI6IFwi27HbsNuw2aog2KjYp9mE2Kcg2KjYsdiv2YYg2YLYr9ix2KpcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcItin2YXYqtmG2KfYuSDYp9iyINm+2LHYr9in2K7YqlwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi2LDYrtuM2LHZhyDaqdix2K/ZhiDYqNix2KfbjCDYqNi52K9cIixcblx0XCJDTEVBUlwiOiBcItm+2KfaqSDaqdix2K/ZhlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcItmF2K3YqtmI2KfbjCDZhdi32YTYqFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcItmF2K3YqtmI2KfbjCDZhti42LFcIixcblx0XCJUSVRMRVwiOiBcIti52YbZiNin2YZcIixcblx0XCJUQUdTXCI6IFwi2KjYsdqG2LPYqOKAjNmH2KdcIixcblx0XCJOT1RfTUFUQ0hcIjogXCLYudiv2YUg2KfZhti32KjYp9mCXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCLYqtij24zbjNivINm+24zZhlwiLFxuXHRcIklOQ09SUkVDVFwiOiBcItmG2KfYr9ix2LPYqlwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcItio2KfYsiDaqdix2K/ZhiDZhdi32YTYqFwiLFxuXHRcIlNFVF9QSU5cIjogXCLYqti524zbjNmGINm+24zZhlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcItmI2KfYsdivINqp2LHYr9mGINm+24zZhlwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcItmF2LfZhdim2YbbjNiv2J9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcItin2LTYqtix2KfaqSDar9iv2KfYsduMINmF2KzYr9ivINi624zYsdmC2KfYqNmEINio2LHar9i02Kog2KfYs9iq2Iwg2YXbjOKAjNiu2YjYp9mH24zYryDYp9iv2KfZhdmHINiv2YfbjNiv2J9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLYrti32KfbjCDZvtiu2LTYjCDYr9mI2KjYp9ix2Ycg2KrZhNin2LQg2qnZhtuM2K8hXCIsXG5cdFwiU1VDQ0VTU1wiOiBcItmF2YjZgdmC24zYqlwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwi2YXYt9mE2Kgg2KfYsdiz2KfZhCDZhdis2K/YryDYtNivIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLZiNix2YjYryDYqNinINi02qnYs9iqINmF2YjYp9is2Ycg2LTYryEg2YTYt9mB2KfZiyDYp9i32YXbjNmG2KfZhiDYrdin2LXZhCDaqdmG24zYryDaqdmHINio2Kcg2q/YsNix2YjYp9qY2YfigIzbjCDYp9i12YTbjCDZiNin2LHYryDYtNiv2YfigIzYp9uM2K8g24zYpyDYr9ixINi12YjYsdiq24wg2qnZhyDYrdin2YTYqiDZvtuM2LTYsdmB2KrZhyDYsdinINin2YbYqtiu2KfYqCDaqdix2K/Zh+KAjNin24zYr9iMINqp2YTbjNivINiu2LXZiNi124wg2KfYsdiz2KfZhCDZhdi32YTYqCDYsdinINiv2LEg2YjYsdmI2K8g2KfYsdin2KbZhyDaqdix2K/Zh+KAjNin24zYry5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLZiNix2YjYryDYqNinINi02qnYs9iqINmF2YjYp9is2Ycg2LTYryEg2YTYt9mB2KfZiyDYp9i32YXbjNmG2KfZhiDYrdin2LXZhCDaqdmG24zYryDaqdmHINio2Kcg2q/YsNix2YjYp9qY2YfigIzbjCDYp9i12YTbjCDZiNin2LHYryDYtNiv2YfigIzYp9uM2K8g24zYpyDYr9ixINi12YjYsdiq24wg2qnZhyDYrdin2YTYqiDZvtuM2LTYsdmB2KrZhyDYsdinINin2YbYqtiu2KfYqCDaqdix2K/Zh+KAjNin24zYr9iMINqp2YTbjNivINiu2LXZiNi124wg2YHYudin2YQg2LHYpyDYr9ixINmI2LHZiNivINin2LHYp9im2Ycg2qnYsdiv2YfigIzYp9uM2K8uXCIsXG5cdFwiV0FSTklOR1wiOiBcItmH2LTYr9in2LFcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwi2LHYo9uMINiv2KfYr9mGINio2LHYp9uMINi02KfZh9ivXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCLYsdij24wg2K/Yp9iv2Ycg2LTYr9mHINio2LHYp9uMINi02KfZh9ivXCIsXG5cdFwiQUdPXCI6IFwi2YLYqNmEXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLYp9iyINit2KfZhNinXCIsXG5cdFwiU0VDU1wiOiBcItir2KfZhtuM2YdcIixcblx0XCJBX01JTlwiOiBcItuM2qkg2K/ZgtuM2YLZh1wiLFxuXHRcIk1JTlNcIjogXCLYr9mC24zZgtmHXCIsXG5cdFwiQU5fSE9VUlwiOiBcItuM2qkg2LPYp9i52KpcIixcblx0XCJIT1VSU1wiOiBcItiz2KfYudiqXCIsXG5cdFwiQV9EQVlcIjogXCLbjNqpINix2YjYslwiLFxuXHRcIkRBWVNcIjogXCLYsdmI2LJcIixcblx0XCJBX01PTlRIXCI6IFwi24zaqSDZhdin2YdcIixcblx0XCJNT05USFNcIjogXCLZhdin2YdcIixcblx0XCJBX1lFQVJcIjogXCLbjNqpINiz2KfZhFwiLFxuXHRcIllFQVJTXCI6IFwi2LPYp9mEXCIsXG5cdFwiTUlOX1JFQURcIjogXCLYr9mC24zZgtmHINiu2YjYp9mG2K/ZhlwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCLYsdij24wg2YXZhtmB24wg24zYpyDYudmE2KfZhdiqINqv2LDYp9i02KrZhlwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcItqv2LHZgdiq2YYg2LnaqdizXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLYp9mG2KrYrtin2Kgg2KrYtdmI24zYsVwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwi2KrYuduM24zZhiDZhti02KfZhtuMINin24zZhtiq2LHZhtiq24wg2LPZgdin2LHYtNuMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCLYr9ix2Kwg2qnYsdiv2YYg2KrYtdmI24zYsVwiLFxuXHRcIkVSUk9SXCI6IFwi2K7Yt9inXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi2K7Yt9in24wg2KLZvtmE2YjYr1wiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCLYr9mI2LHYqNuM2YYg2YTYutmIINi02K9cIixcblx0XCJTRVRfVVJMXCI6IFwi2KrYuduM24zZhiDZhti02KfZhtuMINin24zZhtiq2LHZhtiq24xcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi2YTbjNmG2qkg2YjYqCDZhdiz2KrZgtuM2YUg2KjYsdin24wg2KrYtdmI24zYsVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwi2YbYuNixINir2KjYqiDYtNivIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwi2K3YsNmBINqp2LHYr9mGINmG2LjYsdin2Kog2KjYsdqv2LTYquKAjNmG2KfZvtiw24zYsSDYp9iz2KouLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCLZhti42LEg2K3YsNmBINi02K9cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcItiv2LEg2K3Yp9mEINii2b7ZhNmI2K8g2qnYsdiv2YYg2KrYtdmI24zYsVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLYotm+2YTZiNivINqp2KfZhdmEINi02K9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwi2KLZvtmE2YjYryDYqNinINi02qnYs9iqINmF2YjYp9is2Ycg2LTYr1wiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcItqv2LDYsdmI2KfamNmHINuM2Kcg2YbYp9mFINit2LPYp9ioINmG2KfYr9ix2LPYqiDYqNmI2K9cIixcblx0XCJJTkZPXCI6IFwi2KfYt9mE2KfYudin2KpcIixcblx0XCJRUl9URVhUXCI6IFwi24zaqSDaqduM2YjYotix2qnYryDYsdinINiv2LEg2K/Yp9iu2YQg2YbYp9it24zZh+KAjNuMINin2LPaqdmGINmC2LHYp9ixINiv2YfbjNivXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwi2K/ZgtiqINqp2YbbjNivINqp2Ycg2KjYsdin24wg2KrYsdin2qnZhti0INmF2KfZhtiv2YfigIzbjCDaqdin2YHbjCDYr9in2LTYqtmHINio2KfYtNuM2K8hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcItqp2KfYsdio2LHbjCDaqdmHINmF24zigIzYrtmI2KfZh9uM2K8g2KjYsdin24zYtCDZvtmI2YQg2KjZgdix2LPYqtuM2K/YjCDZiNis2YjYryDZhtiv2KfYsdivIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLZhdi32YXYptmG24zYryDZhduM4oCM2K7ZiNin2YfbjNivINin2YbYqtmC2KfZhCDYsdinINin2YbYrNin2YUg2K/Zh9uM2K/Yn1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcItiq2KPbjNuM2K9cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcItiq2LHYp9qp2YbYtCDZvtiu2LQg2LTYr1wiLFxuXHRcIkZFRURcIjogXCLZgduM2K9cIixcblx0XCJUUkVORElOR1wiOiBcItm+2LHYt9ix2YHYr9in2LFcIixcblx0XCJIT1RcIjogXCLYr9in2LpcIixcblx0XCJORVdcIjogXCLYrNiv24zYr1wiLFxuXHRcIlBST01PVEVEXCI6IFwi2KfYsdiq2YLYpyDYr9in2K/ZhyDYtNiv2YdcIixcblx0XCJWT1RFU1wiOiBcItix2KPbjOKAjNmH2KdcIixcblx0XCJQQVlPVVRcIjogXCLZvtix2K/Yp9iu2KpcIixcblx0XCJDT01NRU5UU1wiOiBcItmG2LjYsdin2KpcIixcblx0XCJUUkVORElOR18zMFwiOiBcItm+2LHYt9ix2YHYr9in2LEg2K/YsSDbs9uwINix2YjYslwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItmF2LHYqtio4oCM2LPYp9iy24wg2YXYt9in2YTYqCDYqNixwqDYrdiz2Kg6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi2obYsdiu2YfigIzbjCDZvtix2K/Yp9iu2KpcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwi2b7Ysdiv2KfYrtiqINin2K3YqtmF2KfZhNuMXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLZvtix2K/Yp9iu2Kog2q/YsNi02KrZh1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLZvtix2K/Yp9iu2Kog2YbZiNuM2LPZhtiv2q/bjFwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcItm+2LHYr9in2K7YqiDZiNuM2LHYp9iz2KrYp9ix24xcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcItmF2LfZhNioINir2KjYqiDYtNivIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLZhdi32YTYqCDYqNix2KfbjCDYq9io2Kog2K/YsSDYotuM2YbYr9mHIVwiLFxuXHRcIlNBVkVEXCI6IFwi2LDYrtuM2LHZhyDYtNivXCIsXG5cdFwiQ0xFQVJFRFwiOiBcItm+2KfaqSDYtNivXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcItqv2LDYp9i02KrZhiDYudmE2KfZhdiqINm+2LHahtmFINio2LHYp9uMINuM2qkg2YXYt9mE2Kgg2YXbjOKAjNiq2YjYp9mG2K8g2YXZiNis2Kgg2K3YsNmBINm+2KfYr9in2LTigIzZh9inINi02K/ZhyDZiCDZhduM2LLYp9mGINmG2YXYp9uM2LQg2KLZhiDZhdi32YTYqCDYsdinINqp2KfZh9i0INiv2YfYry48YnI+PGJyPtm+2LHahtmFINqv2LDYp9i02KrZhiDYqNin24zYryDYqNix2KfbjCDZhdmI2KfYsdivINiy24zYsSDYp9iz2KrZgdin2K/ZhyDYtNmI2K86IDx1bD48bGk+2qnZhNin2YfYqNix2K/Yp9ix24wg24zYpyDYs9ix2YLYqiDYp9iv2KjbjDwvbGk+PGxpPtmG2YHYsdiq4oCM2b7Ysdin2qnZhtuMINuM2Kcg2YXYstin2K3ZhdiqINin24zZhtiq2LHZhtiq24w8L2xpPjxsaT7Yr9iz2KrZh+KAjNio2YbYr9uMINi62YTYtyDYudmF2K/bjCDZhdit2KrZiNinINuM2Kcg2YfYsdiy2YbYp9mF2Yc8L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi2K3YryDYqtmC2KfYttinINm+2LEg2LTYry4g2KjZhyDYsdmI2YbYr9mH2Kcv2KjYsdqG2LPYqOKAjNmH2KfbjCDYr9uM2q/YsSDZhdix2KfYrNi52Ycg2qnZhtuM2K8hXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi2YXYt9mE2Kgg2KfYsiDZhti02KfZhtqp4oCM2YfYpyDYrdiw2YEg2LTYryFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwi2YXYt9mE2Kgg2KjZhyDZhti02KfZhtqp4oCM2YfYpyDYp9i22KfZgdmHINi02K8hXCIsXG5cdFwiUkVTRVRcIjogXCLYtNix2YjYuSDZhdis2K/Yr1wiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi2KrYutuM24zYsSDYqti12YjbjNixINm+2LHZiNmB2KfbjNmEXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCLYqti624zbjNixINiq2LXZiNuM2LEg2LLZhduM2YbZh1wiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcItmE2LfZgdin2Ysg2K/YsSDYtdmI2LHYqtuMINqp2Ycg2K3Yp9mE2Kog2YjYsdmI2K8g2b7bjNi02LHZgdiq2Ycg2LHYpyDYp9mG2KrYrtin2Kgg2qnYsdiv2YfigIzYp9uM2K/YjCDaqdmE24zYryDYrti12YjYtduMINmB2LnYp9mEINix2Kcg2KfYsdin2KbZhyDaqdmG24zYryFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCLYp9uM2YYg2YXZiNis2Kgg2KjYp9iy2YbYtNin2YbbjCDYqti12YjbjNixINm+2LHZiNmB2KfbjNmEINqp2KfYsdio2LEg2K7ZiNin2YfYryDYtNivXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi2KfbjNmGINmF2YjYrNioINio2KfYstmG2LTYp9mG24wg2KrYtdmI24zYsSDYstmF24zZhtmH4oCM24wg2qnYp9ix2KjYsSDYrtmI2KfZh9ivINi02K9cIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcItio2YfigIzYsdmI2LLYsdiz2KfZhtuMINiz2LHZiNixINmG24zYp9iy2YXZhtivINi02LHZiNi5INmF2KzYr9ivINin2LPYqiFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwi2KrZhti424zZhdin2Kog2KjZh+KAjNix2YjYstii2YjYsduMINi02K8hXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi2LLYqNin2YbigIzZh9inXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLYr9ixINin24zZhtis2Kcg2YXbjOKAjNiq2YjYp9mG24zYryDYstio2KfZhiDZhtix2YUg2KfZgdiy2KfYsdix2Kcg2KrYutuM24zYsSDYr9mH24zYry5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwi2KjYsdin24wg2KfbjNmGINi52YXZhNiMINmE2KfYstmFINin2LPYqiDaqdmHINqp2KfYsdio2LEg2KjYpyDar9iw2LHZiNin2pjZh+KAjNuMINin2LXZhNuM2Iwg2qnZhNuM2K8g2YHYudin2YQv2KfYsdiz2KfZhCDZhdi32YTYqCDZiNin2LHYryDYtNiv2Ycg2KjYp9i02K8uINmE2LfZgdin2Ysg2YjYp9ix2K8g2LTZiNuM2K8g2Ygg2K/ZiNio2KfYsdmHINiq2YTYp9i0INqp2YbbjNivLlwiLFxuXHRcIkdBTExFUllcIjogXCLar9in2YTYsduMXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi2KrYsdis2YXZhyDaqdmG2YbYr9qv2KfZhlwiLFxuXHRcIlNIQVJFXCI6IFwi2KfYtNiq2LHYp9qpINqv2LDYp9ix24xcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcItio2KfYstin2LFcIixcblx0XCJFWENIQU5HRVwiOiBcItiq2KjYp9iv2YQg2KfYsdiyXCIsXG5cdFwiRFJBRlRTXCI6IFwi2b7bjNi0INmG2YjbjNizXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi2YXYt9mE2Kgg2KfYsiDZgtiz2YXYqiDZvtuM2LQg2YbZiNuM2LMg2YfYpyDYrdiw2YEg2q/Ysdiv24zYryFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi2YXYt9mE2Kgg2KjZhyDZgtiz2YXYqiDZvtuM2LQg2YbZiNuM2LMg2YfYpyDYp9i22KfZgdmHINqv2LHYr9uM2K8hXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcItio2LHYp9uMINmF2LTYp9mH2K/ZhyDar9iy24zZhtmHINmH2Kcg2KjZhyDahtm+INio2qnYtNuM2K9cIixcblx0XCJNQU5BR0VcIjogXCLZhdiv24zYsduM2KpcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwi2LnaqdizINit2LDZgSDar9ix2K/bjNivXCIsXG5cdFwiQ09QWVwiOiBcItqp2b7bjFwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi2LTZhdinINmH2YbZiNiyINi52qnYs9uMINio2KfYsdqv2LDYp9ix24wg2Ybaqdix2K/bjNivIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwi2KzZh9iqINio2KfYsSDar9iw2KfYsduMINmF2KzYr9ivINio2Ycg2b7Yp9uM24zZhiDYqNqp2LTbjNivXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcItin2b7ZhNuM2qnbjNi02YbigIzZh9in24wg2KjbjNix2YjZhtuMXCIsXG5cdFwiUExVR0lOU1wiOiBcItm+2YTYp9qv24zZhuKAjNmH2KdcIixcblx0XCJTVUdHRVNUXCI6IFwi2b7bjNi02YbZh9in2K9cIixcblx0XCJDT01JTkdfU09PTlwiOiBcItio2Ycg2LLZiNiv24xcIixcblx0XCJDSEFJTlwiOiBcItiy2YbYrNuM2LHZh1wiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCLYr9ixINin24zZhtis2Kcg2YXbjOKAjNiq2YjYp9mG24zYryDYqNmE2KfaqeKAjNqG24zZhiDbjNinINm+2YTYqtmB2LHZhSDZvtuM2LTigIzZgdix2LYg2LHYpyDYqti624zbjNixINiv2YfbjNivLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi2YjYp9it2K8g2b7ZiNmEXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcItiv2LEg2KfbjNmG2KzYpyDYtNmF2Kcg2YXbjCDYqtmI2KfZhtuM2K8g2KrZhti424zZhdin2Kog2YjYp9it2K8g2b7ZiNmEINiu2YjYryDYsdinINiq2LrbjNuM2LEg2K/Zh9uM2K/YjNin2LHYsti0INm+2KfYr9in2LQg2b7Ys9iq2YfYpy/Zhti42LHYp9iqINi02YXYpyDYqNinINmI2KfYrdivINm+2YjZhCDYqtmG2LjbjNmFINi02K/ZhyDZhti02KfZhiDYr9in2K/ZhyDZhduMINi02YjYry5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj7ZhNuM2LPYqiDZgtin2KjZhNuM2Kog2YfYpzwvYj48YnI+LSDYr9iz2KrYsdiz24wg2KjZhyDZhdmC2KfZhNmHINmH2KfbjCDYrtin2LUg2Ygg2YXZhtit2LXYsSDYqNmHINmB2LHYryDYr9ixINmH2LEg2YXZiNix2K/bjCDaqdmHINio2Ycg2KLZhiDYudmE2KfZgtmHINmF2YbYryDZh9iz2KrbjNivLjxicj4tINin2LHYqtio2KfYtyDYqNinINmG2YjbjNiz2YbYr9qv2KfZhiDYqNmHINmI2LPbjNmE2Ycg2YbYuNixINiv2YfbjCDZiCDYqNit2Ksg2K/YsSDZhdmI2LHYryDZhdmI2LbZiNi5INmF2YjYsdivINmG2LjYsSDZvtiz2KouPGJyPi0g2LHYp9uMINiv2YfbjCDYqNmHINm+2LPYqiDZh9inINis2YfYqiDYp9mF2KrbjNin2LIg2K/Zh9uMINmIINis2KfbjNiy2Ycg2K/Yp9iv2YYg2KjZhyDZhtmI24zYs9mG2K/ar9in2YbYjCDZiCDZh9mF2obZhtuM2YYg2qnYs9ioINiv2LHYp9mF2K8g2KjYsdin24wg2K7ZiNivLjxicj4tINmF2YLYp9mE2KfYqiDZiCDZvtiz2Kog2YfYp9uMINiu2YjYryDYsdinINio2Ycg2LHYp9uM2q/Yp9mGINin2LTYqtix2KfaqSDYqNqv2LDYp9ix24zYr9iMINmIINio2Ycg2YjYs9uM2YTZhyDYp9mB2LHYp9iv24wg2qnZhyDYtNmF2Kcg2LHYpyDYr9mG2KjYp9mEINmF24wg2qnZhtmG2K8g2Ygg2KjZhyDZvtiz2Kog2YfYp9uMINi02YXYpyDYsdin24wg2YXbjCDYr9mH2YbYryDYr9ix2KfZhdivINqp2LPYqCDaqdmG24zYry48YnI+LSDZhdmC2KfZhNin2Kog2K7ZiNivINix2Kcg2K/YsSDZh9ixINqp2KzYpyDaqdmHINmH2LPYqtuM2K8g2KjZhtmI24zYs9uM2K8g2Ygg2b7bjNi0INmG2YjbjNizINmH2KfbjCDZhdiu2KrZhNmB24wg2LHYpyDYqNix2KfbjCDYp9i02KrYsdin2qkg2q/YsNin2LHbjCDYr9ixINii24zZhtiv2Ycg2LDYrtuM2LHZhyDaqdmG24zYry48YnI+LSDZhdmC2KfZhNin2Kog2YXZiNix2K8g2LnZhNin2YLZhyDYrtmI2K8g2LHYpyDYqNix2KfbjCDYr9iz2KrYsdiz24wg2KLYs9in2YYg2K/YsSDYotuM2YbYr9mHINmG2LTYp9mG2Ycg2q/YsNin2LHbjCDaqdmG24zYry48YnI+LSDYr9ix2KfZhdivINiu2YjYryDYsdinINio2Kcg2KrYqNiv24zZhCDYqNmHINm+2YjZhCDZhtmC2K8g2Ygg24zYpyDYr9uM2q/YsSDYp9ix2LIg2YfYp9uMINiv24zYrNuM2KrYp9mEINmG2YXYp9uM24zYry48YnI+LSDYr9ix2KfZhdivINiu2YjYryDYsdinINio2Ycg2YbZiNuM2LPZhtiv2q/Yp9mG2Iwg2qnYp9ix2KjYsdin2YbYjNiv2YjYs9iq2KfZhiDZiCDYutuM2LHZhyDYp9ix2LPYp9mEINmG2YXYp9uM24zYry48YnI+LSDZhtmI24zYs9mG2K/ar9in2YYg2Ygg2KjZhNin2q8g2YbZiNuM2LPYp9mGINmF2YjYsdivINi52YTYp9mC2Ycg2K7ZiNivINix2Kcg2K/Zhtio2KfZhCDZhtmF2KfbjNuM2K8uPGJyPi0g2K/YsSDZhNuM2LPYqiDZhtmI24zYs9mG2K/ar9in2YYg2Ygg2K/Zhtio2KfZhCDaqdmG2YbYr9qv2KfZhiDYrtmI2K8g2K/Zhtio2KfZhCDYp9iz2YUg2YXZiNix2K8g2YbYuNixINiu2YjYryDYqNqv2LHYr9uM2K8uPGJyPi0g2KzZh9iqINiv2LEg2KfYsdiq2KjYp9i3INmF2KfZhtiv2YYg2KjYpyDYr9mG2KjYp9mEINqp2YbZhtiv2q/Yp9mGINiu2YjYryDZiCDZh9mF2obZhtuM2YYg2YXZgtin2YTYp9iq24wg2K/YsSDYotmG2YfYpyDZhtmC2LTbjCDYr9in2LTYqtmHINin24zYryDZvtuM2LrYp9mFINiv2LHbjNin2YHYqiDZhtmF2KfbjNuM2K8uPGJyPi0g2q/YsdmI2Ycg2YfYpyDZiCDYqtqvINmH2KfbjCDZhdmI2LHYryDYudmE2KfZgtmHINiu2YjYryDYsdinINio2LEg2KfYs9in2LMg2YbYp9mFINmG2YjbjNiz2YbYr9qv2KfZhiDZiCDZhdmI2LbZiNi5INmF2YHYp9mE2KfYqiDZvtio2K/YpyDZhtmF2KfbjNuM2K8uPGJyPi0g2b7YsdmI2YHYp9uM2YQg2K7ZiNivINix2Kcg2LTYrti124wg2LPYp9iy24wg2YbZhdin24zbjNivLjxicj4tINmC2KfYqNmE24zYqiDZh9in24wg2KjbjNi02KrYsduMINiv2LEg2LHYp9mHINin2LPYqi48YnI+PGJyPjxiPtin2YXZhtuM2Ko8L2I+PGJyPjEuINmG2LHZhSDYp9mB2LLYp9ixINmH2LHar9iyINio2Ycg2K3Ys9in2Kgg2LTZhdinINiv2LPYqtix2LPbjCDZhtiu2YjYp9mH2K8g2K/Yp9i02KouPGJyPjIuINmG2LHZhSDYp9mB2LLYp9ixINuM2qkg2LHZiNi0INin2YXZhtuM2KrbjCDYs9mF2Kog2qnYp9ix2KjYsSDYsdinINm+2KjYp9iv2Ycg2LPYp9iy24wg2YXbjCDZhtmF2KfbjNivINqp2Ycg2qnZhNuM2K8g2YfYp9uMINiu2LXZiNi124wg2LPZhdiqINqp2KfYsdio2LEg2Ybar9mH2K/Yp9ix24wg2LTYr9mHINmIINio2Ycg2YfbjNqGINiz2LHZiNix24wg2KfYsdiz2KfZhCDZhtmF24wg2q/Ysdiv2K/YjCDZhdiz2KbZiNmE24zYqiDZvti02KrbjNio2KfZhiDar9uM2LHbjCDYp9iyINqp2YTbjNivINmH2KfbjCDYtNiu2LXbjCDYqNmHINi52YfYr9mHINi02YXYp9iz2KouPGJyPjMuINmG2LHZhSDYp9mB2LLYp9ixINuM2qkg2LHYp9io2Lcg2qnYp9ix2KjYsduMINiz2KfYr9mHINmIINiq2KzYsdio2Ycg2KfbjCDYstuM2KjYpyDYp9ix2KfYptmHINmF24wg2YbZhdin24zYrzxicj40LiDZhtix2YUg2KfZgdiy2KfYsSDYqNmHINmI2LPbjNmE2Ycg2LHZhdiyINm+24zZhiDbjNqpINmE2KfbjNmHINin2YXZhtuM2KrbjCDYp9i22KfZgdmHINin2LHYp9im2Ycg2YXbjCDZhtmF2KfbjNivLjxicj48YnI+ZXN0ZWVtINin2LIg2b7ZhNiq2YHZiNix2YUg2YfYp9uMIFN0ZWVtINmIIEdvbG9zINm+2LTYqtuM2KjYp9mG24wg2YXbjCDZhtmF2KfbjNivLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwi2YXZiNiz2LMg2Ygg2KjYsdmG2KfZhdmHINmG2YjbjNizINin2LHYtNivXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCLYp9mB2LLZiNiv2YYg2K3Ys9in2Kgg2qnYp9ix2KjYsduMXCIsXG5cdFwiUExBVEZPUk1cIjogXCLZvtmE2KrZgdix2YVcIixcblx0XCJFU0NST1dcIjogXCLZhdio2KfYr9mE2Ycg2KrYttmF24zZhtuMXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwi2YXYp9mF2YjYsSDZiNqp2KfZhNiqINiv2KfYr9mHINi02K/Zh1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcItmF2YfZhNiqINiq2LXZiNuM2KhcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcItm+2KfbjNin2YYg2LLZhdin2YYg2Yjaqdin2YTYqlwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCLZh9iy24zZhtmHINmI2qnYp9mE2KpcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCLYtNix2KfbjNi3INmI2qnYp9mE2KpcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwi2K3Yp9mE2Kog2LTYqFwiLFxuXHRcIkRBWV9NT0RFXCI6IFwi2K3Yp9mE2Kog2LHZiNiyXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwi2YXYtNin2YfYr9mHINmF2KrZhiDaqdin2YXZhFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCLaqdin2LHYqNixINuM2KfZgdiqINmG2LTYr1wiLFxuXHRcIkFQUFJPVkVcIjogXCLYqtin24zbjNivXCIsXG5cdFwiRElTUFVURVwiOiBcItin2K7YqtmE2KfZgVwiLFxuXHRcIlJFTEVBU0VcIjogXCLYp9mG2KrYtNin2LEg2YbYs9iu2YdcIixcblx0XCJGUk9NXCI6IFwi2KfYsiDYt9ix2YFcIixcblx0XCJJRFwiOiBcIti02YbYp9iz2Ycg2qnYp9ix2KjYsVwiLFxuXHRcIlNVQk1JVFwiOiBcItir2KjYqlwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwi2K/YsduM2KfZgdiqINqp2YbZhtiv2YdcIixcblx0XCJMT0NBVElPTlwiOiBcItmF2K3ZhFwiLFxuXHRcIldFQlNJVEVcIjogXCLZiNioINiz2KfbjNiqXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwi2YbYp9mF24wg2qnZhyDZhtmF2KfbjNi0INiv2KfYr9mHINmF24wg2LTZiNivXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkJhaGF5XCIsXG5cdFwiTE9HSU5cIjogXCJNYWctTG9naW5cIixcblx0XCJMT0dPVVRcIjogXCJMdW1hYmFzXCIsXG5cdFwiUFJPRklMRVwiOiBcIkl5b25nIFByb2ZpbGVcIixcblx0XCJGT0xMT1dcIjogXCJzdW5kYW5cIixcblx0XCJCT09LTUFSS1NcIjogXCJNZ2EgQm9va21hcmtcIixcblx0XCJUUkFOU0ZFUlwiOiBcIklsaXBhdFwiLFxuXHRcIk1BUktFVFwiOiBcIk1lcmthZG9cIixcblx0XCJTRVRUSU5HU1wiOiBcIk1nYSBTZXR0aW5nXCIsXG5cdFwiQUJPVVRcIjogXCJUdW5na29sIGRpdG9cIixcblx0XCJBQk9VVF8xXCI6IFwia3VuZyBzYWFuIG5hIGthaGl0IHNpbm8gYW5nIHB1d2VkZW5nIGt1bWl0YSBzYSBrYW5pbGFuZyBuaWxhdGhhbGEhXCIsXG5cdFwiQUJPVVRfMlwiOiBcImF5IHNvc3lhbCBuYSBhcGxpa2FzeW9uIGt1bmcgc2FhbiBiYWJheWFyYW4ga2Egc2EgcGFnLWJvYmxvZywgcGFnLWt1a3VtZW50YXJ5byBhdCBwYWdwaWxpIG5nIHRhbWEuXCIsXG5cdFwiQUJPVVRfM1wiOiBcImF0IGl0byBheSBvcGVuLXNvdXJjZSwgcHJveWVrdG9uZyBwYW5nIGt1bXVuaW5kYWQuIE5hZyBvLW9mZmVyIG5nIGFrc2VzIHNhIHBhZ2Jhc2EgbmcgbWdhIG5pbGF0aGFsYSwgcGFna3VtZW50YXJ5bywgcGFnYm90bywgcGFnbGF0aGFsYSwgcGFnbGlwYXQgbmcgcGVyYSBhdCBpYmEgcGEgbmEgaW5vLW9mZmVyIG5nIHt7cGxhdGZvcm1uYW1lfX0gYXQgbmcge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBEaSBwaW5hcGF5YWdhbiBuZyBBcHAgYW5nIHBhZy1ha3NlcyBvIHBhZy1oYXdhayBuZyBwb25kbyBuZyBtYXktYXJpLlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBbmcgQXBwIGF5IG5hZyBvLW9mZmVyIG5nIGNsaWVudC1zaWRlIG5hIHNlZ3VyaWRhZCwgbmEgbWF5IHByaWJhZG9uZyBrZXlzIG5hIGxva2FsIGF0IGhpbmRpIG5hZ3BhcGFkYWxhIHNhIGFudW1hbmcgc2VydmVyLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBbmcgQXBwIGF5IG5hZyBvLW9mZmVyIG5nIHBheWFrLCBtZ2EgYXRyYWt0aWIgbmEgdXNlciBpbnRlcmZhY2VzIGF0IG1nYSBrYXJhbmFzYW4uXCIsXG5cdFwiQUJPVVRfN1wiOiBcIkFuZyBBcHAgYXkgaGluZGkga2FpbGFubWFuIHB1bWlwaWxpdCBzYSBtZ2EgbWF5LWFyaSBuYSBtYWdsYWdheSBuZyBwZXJzb25hbCBuYSBpbXBvcm1hc3lvbi5cIixcblx0XCJBQk9VVF84XCI6IFwiSWJvdG8gYW5nIGdvb2Qta2FybWEgYmlsYW5nIHRpc3RpZ29cIixcblx0XCJBQk9VVF85XCI6IFwiS29udGFrL1R1Z29uOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTWFyYW1pbmcgaW5mbzpcIixcblx0XCJSRU1PVkVcIjogXCJUaW5hbmdhbFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiVGFuYXdpbiBuZyBNZXJrYWRvXCIsXG5cdFwiUFJJQ0VcIjogXCJQcmVzeW9cIixcblx0XCJBTU9VTlRcIjogXCJIYWxhZ2RcIixcblx0XCJUT1RBTFwiOiBcIkthYnVvaGFuXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJXYWxhbmcgYnVrYXMgbmEgb3JkZXJcIixcblx0XCJEQVRFXCI6IFwiUGV0c2FcIixcblx0XCJCVVlcIjogXCJCaWxpXCIsXG5cdFwiU0VMTFwiOiBcIkJlbnRhXCIsXG5cdFwiT1BFTlwiOiBcIkJ1a2FzXCIsXG5cdFwiSElTVE9SWVwiOiBcIkthc2F5c2F5YW5cIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlN1bmRhbl9wYWJhbGlrXCIsXG5cdFwiRk9MTE9XRURcIjogXCJzaW51bmRhblwiLFxuXHRcIlVORk9MTE9XXCI6IFwiV2FnIHN1bmRhblwiLFxuXHRcIkZPTExPV0lOR1wiOiBcInNpbnVzdW5kYW5cIixcblx0XCJGT0xMT1dFUlNcIjogXCJzdW11c3Vub2RcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiaGFuYXBpbiBhbmcgbWdhIHN1bXVzdW5vZFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJoYW5hcGluIGFuZyBtZ2Egc2ludXN1bmRhblwiLFxuXHRcIkJZXCI6IFwibmlcIixcblx0XCJJTlwiOiBcInNhXCIsXG5cdFwiTUVOVVwiOiBcInBhZ3BpcGlsaWFuXCIsXG5cdFwiQk9PS01BUktcIjogXCJCb29rbWFya1wiLFxuXHRcIlJFQkxPR1wiOiBcIlVsaXRpbmcgaS1ibG9nXCIsXG5cdFwiVVBWT1RFXCI6IFwiUGFnYm90byBuZyBtYXRhYXNcIixcblx0XCJET1dOVk9URVwiOiBcIlBhZ2JvdG8gbmcgbWFiYWJhXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlRhbmdnYWxpbiBhbmcgUGFnYm90byBuZyBtYWJhYmFcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlRhbmdnYWxpbiBhbmcgUGFnYm90byBuZyBtYXRhYXNcIixcblx0XCJSRVBMWVwiOiBcInNhZ290XCIsXG5cdFwiRURJVFwiOiBcIkJhZ3VoaW5cIixcblx0XCJQT1NUXzFcIjogXCJwYWR1bGFzaW4gcGFrYWxpd2Egc2Ega3VtZW50YXJ5byBwYXJhIG1ha2l0YSBhbmcgcGFncGlwaWxpYW5cIixcblx0XCJQT1NUXzJcIjogXCJJLXRhcCBhbmcgbWdhIGtvbWVudG8gcGFyYSBtYWtpdGEgYW5nIGliYSBwYW5nIGtvbWVudG9uZyBuYWthcGFsb29iXCIsXG5cdFwiT1BUSU9OU1wiOiBcInBhZ3BpcGlsaWFuXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiSW51bGl0IG5hIGktYmxvZyBuaVwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIndhbGEgcGEgZGl0b1wiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiQmFsYW5zZVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIG1nYSB0cmFkZWFibGUgbmEgdG9rZW4gbmEgcHV3ZWRlbmcgaWxpcGF0IGthaGl0IGFudW1hbmcgb3Jhcy57e3BsYXRmb3JtbmFtZX19IHB1d2VkZW5nIGktY29udmVydCBzYSB7e3BsYXRmb3JtcG93ZXJ9fSBuYSBpc2FuZyBwcm9zZXNvbmcgdGluYXRhd2FnIG5hIHBvd2VyaW5nIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBpbXBsdXdlbnN5YSBuZyBtZ2EgdG9rZW4gbmEga3VtaXRhIG5nIGhpZ2l0IHBhbmcgcG93ZXIgc2EgcGFnaGFoYXdhayBuZyBtYXRhZ2FsIGF0IHBhZ2JvdG8gc2EgbWdhIGlwaW5vc3QuIEthcGFnIG1hcmFtaSBhbmcgaGluYXdha2FuIG1hcyBtYWxha2kgYW5nIHB1d2VkZW5nIG1haWJpZ2F5IG5hIHJld2FyZHMuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiS2FoYWxhZ2FoYW4gbmcgbWdhIHRva2VuIHR1bmdrb2wgc2F7e3BsYXRmb3Jtc3VuaXR9fSBuZyB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcImVuaXN0aW1hbmcgaGFsYWdhXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiQW5nIHRpbmF0YXlhbmcgaGFsYWdhIGF5IG5ha2FiYXNlIHNhIGlzYW5nIDctYXJhdyBuYSBrYXJhbml3YW5nIGhhbGFnYSBuZyB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJLYXNheXNheWFuIG5nIG1nYSBUcmFuc2Frc3lvblwiLFxuXHRcIlBPU1RJTkdcIjogXCJQYWctcG9zdFwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkFuZyBzdXNpIHNhIHBhZ3Bvc3QgYXkgZ2luYWdhbWl0IHNhIHBhZy1wb3Bvc3QgYXQgcGFnYm90by4gRGFwYXQgaWJhIGl0byBzYSBha3RpYiBuYSBzdXNpIGF0IHN1c2kgbmcgbWF5LWFyaS5cIixcblx0XCJPV05FUlwiOiBcIm1heSBhcmlcIixcblx0XCJQUk9GSUxFXzZcIjogXCJBbmcgc3VzaSBuZyBtYXktYXJpIGF5IGFuZyBtYXN0ZXIga2V5IHBhcmEgc2EgYWNjb3VudCBhdCBrYWlsYW5nYW4gaXRvIHBhcmEgc2EgcGFnLWliYSBuZyBpYmFuZyBrZXlzLiBBbmcgcHJpYmFkb25nIGtleSBvIGFuZyBwYXNzd29yZCBuZyBzdXNpIG5nIG1heS1hcmkgYXkgZGFwYXQgaXRhZ28gb2ZmbGluZS5cIixcblx0XCJBQ1RJVkVcIjogXCJha3RpYm9cIixcblx0XCJQUk9GSUxFXzdcIjogXCJBbmcgYWt0aWIgbmEgc3VzaSBheSBnaW5hZ2FtaXQgc2EgcGFnbGlwYXQgYXQgcGFnbGFnYXkgbmcgb3JkZXIgc2EgaW50ZXJuYWwgbmEgbWVya2Fkby5cIixcblx0XCJNRU1PXCI6IFwiVGFsYVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkFuZyBzdXNpIG5nIHRhbGEgYXkgZ2luYWdhbWl0IHNhIHBhZ2dhd2EgYXQgcGFnYmFzYSBuZyBtZ2EgdGFsYS5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ1wiLFxuXHRcIlBPU1RTXCI6IFwiUG9zdHNcIixcblx0XCJSRVBMSUVTXCI6IFwibWdhIHNhZ290XCIsXG5cdFwiV0FMTEVUXCI6IFwicGl0YWthXCIsXG5cdFwiVEFHXCI6IFwiVGFnXCIsXG5cdFwiVVNFUlwiOiBcIkd1bWFnYW1pdFwiLFxuXHRcIkNMT1NFXCI6IFwic2FyYVwiLFxuXHRcIlRPXCI6IFwicGFyYSBrYXlcIixcblx0XCJBU1NFVFwiOiBcIkFzc2V0XCIsXG5cdFwiU0VORFwiOiBcInBpbmFkYWxhXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJzZWd1cmlkYWRcIixcblx0XCJBVkFJTEFCTEVcIjogXCJOYWdhZ2FtaXRcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIlB1Ymxpa29uZyBUYWxhXCIsXG5cdFwiVE9fREVTQ1wiOiBcIkd1bWFnYW1pdCBoYWxpbWJhd2EsIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbiBDb2RlXCIsXG5cdFwiUElOX1RFWFRcIjogXCJBbmcgUElOIGNvZGUgYXkgdHVtdXR1bG9uZyBzYSBwYWcgc2lndXJvIG5nIGFwcCBhdCBuZyBpeW9uZyBtZ2EgZGF0b3MuPGJyLz48YnIvPjxiPiBUYW5kYWFuOjwvYj4gS2FwYWcgbmFrYSBlbmFibGUsIG1heSBoaWdpdCA0IG5hIGJlc2VzIGthIG1hZyB1bmxvY2ssIGthcGFnIG5ha2FsaW11dGFuIG1vIGl0bywgYW5nIGRhdG9zIG5nIGd1bWFnYW1pdCBheSB0YXRhbmdnYWxpbiBuZyBhcHAuIE1hYWFyaSBrYW5nIG1hZyByZS1sb2dpbiBhdCBtYWdwYXR1bG95IHNhIHBhZ2dhbWl0IG5nIGFwcC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTWdhIEFiaXNvXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiTWFrYWtha3VoYSBrYSBuZyBhYmlzbyBrYXBhZyBtYXkgc2lubyBtYW5nIHRhbyBuYSBib2JvdG8gc2EgaXBpbm9zdCBtbyEgPGJyLz48Yj5UYW5kYWFuOjwvYj4gTmFrYXBhbG9vYiBkaW4gc2EgbWdhIGFiaXNvIGFuZyBiaWdhdCBuZyBpeW9uZyBwYWdib3RvIGF0IG1nYSBtZW5zYWhlbmcgbWF5IGFsZXJ0by5cIixcblx0XCJWT1RFXCI6IFwiYm90b1wiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIk1ha2FrYWt1aGEga2EgbmcgYWJpc28ga2FwYWcgbWF5IHNpbm8gbWFuZyB0YW8gbmEgbWFna3VrdW1lbnRvIHNhIG1nYSBwaW5vc3QgYXQgbWdhIGtvbWVudG8gbW8hPGJyLz48Yj5UYW5kYWFuOjwvYj5OYWthcGFsb29iIGRpbiBzYSBtZ2EgYWJpc28ga3VuZyBtYXkgc2lubyBtYW5nIHRhbyA8Yj5hbmcgbWFnIGJhZ288L2I+IHNhIGthbmlsYW5nIG1nYSBrb21lbnRvLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJrdW1lbnRhcnlvXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJNYWtha2FrdWhhIGthIG5nIGFiaXNvIGthcGFnIG1heSBzaW5vIG1hbmcgdGFvIGFuZyBzdXN1bm9kIGF0IGRpIHN1c3Vub2Qgc2EgaXlvIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwic2luYWJpXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIk1ha2FrYWt1aGEga2EgbmcgYWJpc28ga2FwYWcgbWF5IHNpbm8gbWFuZyB0YW8gYW5nIGJhYmFuZ2dpdCBzYSBwYW5nYWxhbiBtbyBzYSBwb3N0cy9rb21lbnRvIG5pbGEhXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlVsaXRpbmcgaS1ibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiTWFrYWtha3VoYSBrYSBuZyBhYmlzbyBrYXBhZyBtYXkgc2lubyBtYW5nIHRhbyBhbmcgbWFnIHV1bGl0IHNhIHBhZ2Jsb2cgbmcgaXlvbmcgaXBpbm9zdCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYXRpb25zXCIsXG5cdFwiVk9USU5HXCI6IFwiYmlub2JvdG9cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIkFuZyBiaWdhdCBuZyBwYWdib3RvIGF5IG5ha2FrYWFwZWt0byBzYSBwb3dlciBuZyBwYWdib3RvLCBrYXlhIHB1d2VkZSBtb25nIG1hLWlyZWd1bGF0ZSBhbmcgcmV3YXJkIHNhIHBhZ2JvdG8uPGJyLz48YnIvPjxiPlRhbmRhYW46PC9iPk1ha2FrYWliYSBpdG8gc2EgYmlnYXQgbmcgcGFnYm90byBrYXBhZyBidW1vdG8ga2EgbmcgbWFiYWJhXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJOaXJlcmVrb21lbmRhXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiSS1zYXZlIGFuZyBtZ2EgUGFnYmFiYWdvXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbXBvcm1hc3lvbiBuZyBtZ2EgYm90YW50ZVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIm1hbGlnYXlhbmcgcGFnYmFiYWxpa1wiLFxuXHRcIkxPR0lOXzFcIjogXCJNYWctc2lnbiBpbiBnYW1pdCBhbmcgaXlvbmcgdXNlcm5hbWUgYXQgcGFzc3dvcmQgcGFyYSBtYWdwYXR1bG95LlwiLFxuXHRcIkxPR0lOXzJcIjogXCJBbmcgc3VzaSBuZyBwYWctcG9zdCBheSBnaW5hZ2FtaXQgc2EgcGFnLXBvc3QsIGtvbWVudG8sIHBhZ2JvdG8sIHBhZy1zdW5vZC5cIixcblx0XCJMT0dJTl8zXCI6IFwiQW5nIGFrdGliIG5hIHN1c2kgYXkgZ2luYWdhbWl0IHNhIHBhZ2xpcGF0IGF0IHBhZy11cGRhdGUgbmcgbGFyYXdhbiBuZyBtYXktYXJpLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJBbmcgbWdhIGtyZWRlbnN5YWwgbmcgZ3VtYWdhbWl0IGF5IGxva2FsIG5hIHRpbmF0YWdvIHNhIGRldmljZS4gS2FwYWcgbmFnLWxvZ291dCwgYW5nIG1nYSBrcmVkZW5zeWFsIGF5IHRpbmF0YW5nZ2FsIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIldhbGEgcGFuZyBhY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiTWFnLXNpZ24gdXBcIixcblx0XCJDQU5DRUxcIjogXCJLYXNlbGFoaW5cIixcblx0XCJBRFZBTkNFRFwiOiBcIkFkdmFuY2VkXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIlByaWJhZG9uZyBha3RpYiBuYSBzdXNpXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJQcmliYWRvbmcgc3VzaSBzYSBwYWctcG9zdFwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVyL21haW4gcGFzc3dvcmRcIixcblx0XCJVU0VSTkFNRVwiOiBcIlVzZXJuYW1lXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiVGFuYXdpbiBuZyBjYXJkXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVGFuYXdpbmcgY29tcGFjdFwiLFxuXHRcIlNFQVJDSFwiOiBcImhhbmFwaW5cIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIm1hZ3BhcGFzYSBuZyBzdG9yeWFcIixcblx0XCJSRVBMWVRPXCI6IFwic3VtYWdvdCBrYXlcIixcblx0XCJQT1NUXCI6IFwiUG9zdFwiLFxuXHRcIlBSRVZJRVdcIjogXCJQcmV2aWV3XCIsXG5cdFwiREVGQVVMVFwiOiBcIkRlZmF1bHQgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIFVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlRhbmdnaWhhbiBhbmcgUGF5b3V0XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJJLVNBVkUgUEFSQSBNQU1BWUFcIixcblx0XCJDTEVBUlwiOiBcIkJVUkFISU5cIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJQYWctcG9zdCBuZyBuaWxhbGFtYW5cIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJNYWdrdW1lbnRvIHNhIG5pbGFsYW1hblwiLFxuXHRcIlRJVExFXCI6IFwidGl0b2xvXCIsXG5cdFwiVEFHU1wiOiBcIlRhZ3NcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJISU5ESSBUVUdNQVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiS3VtcGlyaGFtaW4gYW5nIFBJTlwiLFxuXHRcIklOQ09SUkVDVFwiOiBcImhpbmRpIHRhbWFcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJhbmcgcG9zdCBheSBiaW51YnVrc2FuXCIsXG5cdFwiU0VUX1BJTlwiOiBcIk1hZy1zZXQgbmcgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiaXBhc29rIGFuZyBwaW5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJzaWd1cmFkbyBrYT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIkFuZyBwYWd1bGl0IHNhIHBhZ2Jsb2cgYXkgaGluZGkgbWF3YXdhbGFuIG5nIGJpc2EsIGd1c3RvIG1vIGJhbmcgbWFncGF0dWxveT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJFcnJvciBzYSBwYWctYnJvYWRjYXN0LCBzdWJ1a2FuZyBtdWxpIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJUYWd1bXBheVwiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiQW5nIHBvc3QgYXkgbmFpLWJsb2dnZWQgdWxpdCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiQmlnbyBzYSBwYWctbG9naW4hIE1hbmd5YXJpbmcgdGl5YWtpbiBhbmcgbWFzdGVyIHBhc3N3b3JkIG8gYW5nIHByaWJhZG9uZyBzdXNpIHNhIHBhZy1wb3N0IGt1bmcgcGluaWxpIG1vIGFuZyBBZHZhbmNlZCBtb2RlLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkJpZ28gc2EgcGFnLWxvZ2luISBNYW5neWFyaW5nIHRpeWFraW4gYW5nIG1hc3RlciBwYXNzd29yZCBvIGFuZyBwcmliYWRvbmcgYWt0aWIgbmEgc3VzaSBrdW5nIHBpbmlsaSBtbyBhbmcgQWR2YW5jZWQgbW9kZS5cIixcblx0XCJXQVJOSU5HXCI6IFwiYmFiYWxhXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcImliaW5vdG8gcGFyYSBtYWdpbmcgdGVzdGlnb1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiYmlub3RvIHBhcmEgbWFnaW5nIHRlc3RpZ29cIixcblx0XCJBR09cIjogXCJuYWthbGlwYXNcIixcblx0XCJGUk9NX05PV1wiOiBcIm11bGEgbmdheW9uXCIsXG5cdFwiU0VDU1wiOiBcInNlZ29uZG9cIixcblx0XCJBX01JTlwiOiBcImlzYW5nIG1pbnV0b1wiLFxuXHRcIk1JTlNcIjogXCJtZ2EgbWludXRvXCIsXG5cdFwiQU5fSE9VUlwiOiBcImlzYW5nIG9yYXNcIixcblx0XCJIT1VSU1wiOiBcIm1nYSBvcmFzXCIsXG5cdFwiQV9EQVlcIjogXCJpc2FuZyBhcmF3XCIsXG5cdFwiREFZU1wiOiBcIm1nYSBhcmF3XCIsXG5cdFwiQV9NT05USFwiOiBcImlzYW5nIGJ1d2FuXCIsXG5cdFwiTU9OVEhTXCI6IFwibWdhIGJ1d2FuXCIsXG5cdFwiQV9ZRUFSXCI6IFwiaXNhbmcgdGFvblwiLFxuXHRcIllFQVJTXCI6IFwibWdhIHRhb25cIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbnV0byBzYSBwYWdiYXNhXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIlBhZ2JvdG8gbmcgbWFiYWJhIG8gRmxhZ1wiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIkt1bmFuIG5nIExhcmF3YW5cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcInBpbGkgbmcgbGl0cmF0b1wiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiTWFnLXNldCBuZyBDdXN0b20gVVJMXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJNYWctaW5zZXJ0IG5nIExhcmF3YW5cIixcblx0XCJFUlJPUlwiOiBcIkVycm9yXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiRXJyb3Igc2EgUGFnLXVwbG9hZFwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJLaW5hbnNlbGEgYW5nIENhbWVyYVwiLFxuXHRcIlNFVF9VUkxcIjogXCJJLXNldCBhbmcgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkRpcmVrdGEgbmEgd2ViIGxpbmsgcGFyYSBzYSBsYXJhd2FuXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJrdW1lbnRvIGF5IG5hcGFzYSBuYVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiYnVyYSBhbmcga3VtZW50b1wiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIm5hYnVyYSBuYSBhbmcga3VtZW50b1wiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiQW5nIGxhcmF3YW4gYXkgaW5hLXVwbG9hZFwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJBbmcgcGFnLXVwbG9hZCBheSBuYWt1bXBsZXRvXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIkJpZ28gYW5nIHBhZy11cGxvYWRcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJBbmcgcGFzc3dvcmQgbyBhY2NvdW50IGF5IGhpbmRpIHRhbWFcIixcblx0XCJJTkZPXCI6IFwiSW1wb3JtYXN5b25cIixcblx0XCJRUl9URVhUXCI6IFwiSWxhZ2F5IGFuZyBRUiBjb2RlIHNhIGxvb2Igbmcgc2NhbiBhcmVhXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiU2lndXJhZHVoaW5nIG1heSBzYXBhdCBuYSBiYWxhbnNlIHBhcmEgc2EgdHJhbnNha3N5b24hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkFuZyBndW1hZ2FtaXQgbmEgZ3VzdG8gbW9uZyBsaXBhdGFuIG5nIHBvbmRvIGF5IGRpIG1hdGFncHVhbiFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwic2lndXJhZG8ga2EgbmEgZ3VzdG8gbW8gaWxpcGF0P1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIktvbXBpcm1hc3lvblwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiQW5nIHRyYW5zYWtzeW9uIGF5IG5haS1icm9hZGNhc3RcIixcblx0XCJGRUVEXCI6IFwiRmVlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRpbmdcIixcblx0XCJIT1RcIjogXCJtYWluaXRcIixcblx0XCJORVdcIjogXCJiYWdvXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3RlZFwiLFxuXHRcIlZPVEVTXCI6IFwibWdhIGJvdG9cIixcblx0XCJQQVlPVVRcIjogXCJiYXlhZFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwia3VtZW50b1wiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVHJlbmRpbmcgc2EgMzAgYXJhd1wiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlVyaWluIGFuZyBtZ2EgcG9zdCBuZzpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJQYXlvdXQgQ3ljbGVcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW5zeWFsIG5hIFBheW91dFwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwibmFrYXJhYW5nIGJheWFhZFwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJiYXlhZCBzYSBtYXkgYWtkYVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkN1cmF0aW9uIFBheW91dFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiQW5nIHBvc3QgYXkgbmFpLXN1Ym1pdCFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiUG9zdCBwYXJhIHNhIG1hbWF5YW5nIHBhZy1zdWJtaXQhXCIsXG5cdFwiU0FWRURcIjogXCJOYWktc2F2ZVwiLFxuXHRcIkNMRUFSRURcIjogXCJOYWktYnVyYVwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJTYSBwYWctZmxhZyBuZyBwb3N0IG5hIGl0byBheSBtYWFyaW5nIG1hdGFuZ2dhbCBhbmcgcmV3YXJkcyBhdCBhbmcgbWF0ZXJpYWwgYXkgZGkgbmEgbWFraWtpdGEuPGJyPjxicj5BbmcgcGFnLWZsYWcgYXkgcHV3ZWRlbmcgZ2FtaXRpbiBsYWJhbiBzYTogPHVsPjxsaT5LYXNpbnVuZ2FsaW5nYW4gbyBQYWdrb3B5YTwvbGk+PGxpPkhhdGUgU3BlZWNoIG8gSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5EaSBjYXRlZ29yYWRvIG5hIG5pbGFsYW1hbiBvIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiVW1hYm90IHNhIGxpbWl0YXN5b24gYW5nIGhpbmloaWxpbmcuIFRpZ25hbiBhbmcgaWJhbmcgdHJlbmRzL3RhZ3MhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiQW5nIHBvc3QgYXkgbmF0YW5nZ2FsIHNhIG1nYSBib29rbWFya3MhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIkFuZyBwb3N0IGF5IG5haWRhZ2RhZyBzYSBtZ2EgYm9va21hcmtzIVwiLFxuXHRcIlJFU0VUXCI6IFwiSS1yZXNldFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiQmFndWhpbiBhbmcgbGFyYXdhbiBuZyBtYXktYXJpXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJCYWd1aGluIGFuZyBDb3ZlciBuZyBMYXJhd2FuXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiTWFuZ3lhcmluZyBtYWdiaWdheSBuZyBwcmliYWRvbmcgYWt0aWIgbmEgc3VzaSBrdW5nIHBpbmlsaSBtbyBhbmcgQWR2YW5jZWQgbG9naW4gbW9kZSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJJcmktcmVzZXQgbml0byBhbmcgbGFyYXdhbiBuZyBndW1hZ2FtaXRcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJJcmktcmVzZXQgbml0byBhbmcgY292ZXIgbmEgbGFyYXdhbiBuZyBndW1hZ2FtaXRcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkthaWxhbmdhbiBpLXJlc3RhcnQgcGFyYSBzYSBzZXJ2ZXIgdXBkYXRlIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJOYS11cGRhdGUgYW5nIG1nYSBzZXR0aW5ncyFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJsZW5ndWFnZVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiRGl0byBtbyBwdXdlZGVuZyBpYmFoaW4gYW5nIGxpbmdndXdhaGUgbmcgYXBwLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJNYWluIHBhc3N3b3JkIGFuZyBrYWlsYW5nYW4gc2Egb3BlcmFzeW9uIG5hIGl0by4gTWFuZ3lhcmluZyBtYWctbG9naW4gYXQgc3VidWthbmcgbXVsaS5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyeVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIk1nYSBuYWctYW1iYWcgbmcgcGFnc2FzYWxpblwiLFxuXHRcIlNIQVJFXCI6IFwiSWJhaGFnaVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiTHVnYXIgbmcgTWVya2Fkb1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwibWFncGFsaXRcIixcblx0XCJEUkFGVFNcIjogXCJNZ2EgQm9yYWRvclwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIkFuZyBwb3N0IGF5IHRpbmFuZ2dhbCBzYSBtZ2EgYm9yYWRvciFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiQW5nIHBvc3QgYXkgbmFpZGFnZGFnIHNhIG1nYSBib3JhZG9yIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJwYWR1bGFzaW4gcGFrYWxpd2EgcGFyYSBtYWtpdGEgYW5nIHBhZ3BpcGlsaWFuXCIsXG5cdFwiTUFOQUdFXCI6IFwiUGFtYWhhbGFhblwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJuYXRhbmdhbCBuYSBhbmcgaW1haGVcIixcblx0XCJDT1BZXCI6IFwiY29weWFcIixcblx0XCJOT19JTUFHRVwiOiBcIndhbGFuZyBsYXJhd2FuXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJIaWxhaGluIHBhcmEgbWFpLXJlZnJlc2hcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiUGFubGFiYXMgbmEgbWdhIEFwcFwiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnaW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIk1hZ211bmdrYWhpXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJNYWxhcGl0IG5hXCIsXG5cdFwiQ0hBSU5cIjogXCJLYWRlbmFcIixcblx0XCJDSEFJTl9URVhUXCI6IFwiRGl0byBtaSBwdXdlZGVuZyBiYWd1aGluIGFuZyBibG9ja2NoYWluIG8gZGVmYXVsdCBuYSBwbGF0Zm9ybS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlBlcmFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiRGl0byBtbyBwdXdlZGVuZyBiYWd1aGluIGFuZyBpeW9uZyBkZWZhdWx0IG5hIHBlcmEuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+VGFtcG9rIG5hIGxpc3RhaGFuPC9iPiA8YnI+LUFrc2VzIHNhIGtha2FpYmFuZyBhcnRpa3VsbyBzYSBhbnVtYW5nIHBha3NhIG1vIGF5IGludGVyZXNhZG8gc2EgcGFnYmFiYXNhLiA8YnI+IC1NYWtpc2FsaSBzYSBtYXktYWtkYSBzYSBwYW1hbWFnaXRhbiBuZyBwYWdrdW1lbnRvLCBwYWd0YWxha2F5IG5nIG1nYSBwYWtzYS4gPGJyPi1QYWdib3RvIHBhcmEgc2EgcG9zdCBuYSBtYXkgcmV3YXJkcyBzYSBtZ2EgYXd0b3IgcGF0aSByZXdhcmRzIHNhIGN1cmF0aW9uLiA8YnI+LVBhZ2xhdGhhbGEgbmcgbWdhIGFydGlrdWxvLCBibG9nIHBvc3QgYXQgbWFnLWhvc3Qgc2Ega2FuaWxhIG5hbmcgbGlicmUgYXQga3VtaXRhIG5nIHByZW15byBzYSBwYWdzYWxpIGF0IG1hZ2thcm9vbiBuZyB0YWdhc3Vub2QuIDxicj4tU3VtdWxhdCBuZyBhcnRpa3VsbyB0dW5na29sIHNhIG1nYSBiYWdheSwgbWFsaWJhbiBzYSBtYXJhbWluZyBib3JhZG9yIG5nIGFuZyBwb3N0IG5hIGl0byBwYXJhIHNhIG1nYSBtYW1heWEgcHVibGlrYXN5b24uIDxicj4tQm9va21hcmsgcGFib3JpdG8gbmlueW9uZyBtZ2EgYXJ0aWt1bG8gcGFyYSBiYXNhaGluIHNhIGliYW5nIHBhZ2tha2F0YW9uLiA8YnI+LUV4Y2hhbmdlIG8gY2FzaCBvdXQgc2EgaXlvbmcga2l0YS4gPGJyPi1QYWRhbGEgbW9uZyBwZXJhIHBhcmEgc2EgYW51bWFuZyBtZ2EgbWF5LWFrZGEgbyBtZ2EgZ3VtYWdhbWl0LCBtZ2Ega2FpYmlnYW4sIG1nYSB0YWdhc3Vub2QsIGF0IGt1bmcgYW51LWFubyBwYSA8YnI+Rm9sbG93IGthd2lsaS13aWxpbmcgbWdhIG1heS1ha2RhLCBibG9nZ2VyLiA8YnI+IC1TYWxpa3Npa2luIGFuZyBpbnlvbmcgbWdhIHRhZ2FzdW5vZCBhdCBzaW51c3Vub2QgbW8gYW5nIG1nYSBtYXktYWtkYS4gS3VtdWhhIG5nIG1nYSA8YnI+bm90aWZpY2F0aW9uIG5hIG1hbmF0aWxpbmcgbWF5IHVnbmF5YW4gc2EgaXlvbmcgbWdhIHRhZ2FzdW5vZCBhdCB0YWxha2F5YW4ga2F5byBheSBrYXNhbmdrb3QuIHBhIDxicj4tU2VhcmNoIHBhcmEgc2Ega2F3aWxpLXdpbGluZyB0YWdzL2thdGVnb3J5YSBuZyBhcnRpa3VsbywgbWF5LWFrZGEuIDxicj4gLUktcGVyc29uYWxpemUgYW5nIGl5b25nIHByb2ZpbGUuIDxicj5TYSBtYXJhbWluZyBrYXJhZ2RhZ2FuZyB0YW1wb2sgbmEgZGFyYXRpbmcuIDxicj48YnI+PGI+U2VjdXJpdHk8L2I+IDxicj4xIEktYWNjZXNzIGFuZyBhcHAga2FpbGFubWFuIG8gaHVtYXdhayBuZyBtZ2EgZ3VtYWdhbWl0IG5nIG1nYSBwb25kby4gPGJyPjIuIGFwcCBheSBuYWctYWFsb2sgbmcgaXNhbmcgbW9kZWxvIG5nIHNlZ3VyaWRhZCBzYSBjbGllbnQgc2lkZSwgbWF5IHByaWJhZG9uZyBzdXNpIG5hIG5ha2EtaG9zdCBzYSBrYW5pbGFuZyBsdWdhciBhdCBoaW5kaSBuYWdwYWRhbGEgc2EgYW51bWFuZyBtZ2Egc2VydmVyLCBpa2F3IGF5IHJlc3BvbnNhYmxlIHBhcmEgc2EgcGFnLWJhY2sgdXAgbmcgaXlvbmcgcGFzc3dvcmQuIDxicj4zLiBhcHAgYXkgbmFnLWFhbG9rIG5nIG1nYSBndW1hZ2FtaXQgbmcgc2ltcGxlIGF0IGthYWtpdC1ha2l0IG5hIGludGVyZmFjZXMgYXQgPGJyPjQgbWdhIGthcmFuYXNhbi4gQXBwIGF5IG5hZy1hYWxvayBuZyBkYWdkYWcgbmEgcGF0b25nIG5nIHNlZ3VyaWRhZCBzYSBLb2RpZ28gbmcgcGluIDxicj48YnI+cGFncGFwYWhhbGFnYSBheSBzdW11c3Vwb3J0YSBzYSBTdGVlbSBhdCBHb2xvcyBuYSBwbGF0Zm9ybS4gPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJUYWdhcGFndGF0YWcgYXQgTmFuZ3VuZ3VuYW5nIERldmVsb3BlclwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiTWFnZGFnZGFnIG5nIGFjY291bnRcIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtXCIsXG5cdFwiRVNDUk9XXCI6IFwiRXNjcm93XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93IGFnZW50XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiRGVhZGxpbmUgc2EgcGFncGFwYXRpYmF5XCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgZXhwaXJhdGlvblwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJCYXlhZCBzYSBFc2Nyb3dcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJNZ2EgdHVudHVuaW4gc2EgRXNjcm93XCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIlBhbmctZ2FiaSBuYSBtb2RlXCIsXG5cdFwiREFZX01PREVcIjogXCJQYW5nLXVtYWdhbmcgbW9kZVwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIlRpZ25hbiBhbmcgYnVvbmcga29udGVrc3RvXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIkhpbmRpIG1haGFuYXAgYW5nIGd1bWFnYW1pdFwiLFxuXHRcIkFQUFJPVkVcIjogXCJBcHJ1YmFoYW5cIixcblx0XCJESVNQVVRFXCI6IFwiUGFndGF0YWxvXCIsXG5cdFwiUkVMRUFTRVwiOiBcIlJlbGVhc2VcIixcblx0XCJGUk9NXCI6IFwiTXVsYSBzYVwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJJc3VtaXRlXCIsXG5cdFwiUkVDRUlWRVJcIjogXCJUYWdhdGFuZ2dhcFwiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9rYXN5b25cIixcblx0XCJXRUJTSVRFXCI6IFwiV2Vic2l0ZVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIlBhbmdhbGFuIG5hIG5ha2FkaXNwbGF5XCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkFjY3VlaWxcIixcblx0XCJMT0dJTlwiOiBcIkNvbm5leGlvblwiLFxuXHRcIkxPR09VVFwiOiBcIkTDqWNvbm5leGlvblwiLFxuXHRcIlBST0ZJTEVcIjogXCJQcm9maWxcIixcblx0XCJGT0xMT1dcIjogXCJTdWl2cmVcIixcblx0XCJCT09LTUFSS1NcIjogXCJTaWduZXRzXCIsXG5cdFwiVFJBTlNGRVJcIjogXCJUcmFuc2ZlcnRcIixcblx0XCJNQVJLRVRcIjogXCJNYXJjaMOpXCIsXG5cdFwiU0VUVElOR1NcIjogXCJQYXJhbcOodHJlc1wiLFxuXHRcIkFCT1VUXCI6IFwiQSBwcm9wb3NcIixcblx0XCJBQk9VVF8xXCI6IFwib8O5IG4naW1wb3J0ZSBxdWkgcGV1dCBnYWduZXIgZGVzIHLDqWNvbXBlbnNlcyBwb3VyIHNvbiBjb250ZW51IVwiLFxuXHRcIkFCT1VUXzJcIjogXCJlc3Qgc3VwcG9ydMOpIHBhciBsYSBwbGF0ZS1mb3JtZSB7e3BsYXRmb3JtbmFtZX19LiBBcHBsaWNhdGlvbiBjcsOpw6llIHBhclwiLFxuXHRcIkFCT1VUXzNcIjogXCJJbCBzJ2FnaXQgZCd1biBwcm9qZXQgcG91ciBsYSBjb21tdW5hdXTDqSBtb2JpbGUgZXQgaWwgZXN0IG9wZW4tc291cmNlLiBJbCBvZmZyZSB1biBhY2PDqHMgcG91ciBsaXJlLCBjb21tZW50ZXIsIHZvdGVyLCBwb3N0ZXIsIGFmZmljaGVyIGxlIHRyYW5zZmVydCBkZSByw6ljb21wZW5zZSwgZXRjLiBUb3V0ZXMgbGVzIGZvbmN0aW9ubmFsaXTDqXMgb2ZmZXJ0ZXMgcGFyIHt7c2l0ZW5hbWV9fSBldCBsYSBibG9ja2NoYWluIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIEwnYXBwbGljYXRpb24gbidhIGphbWFpcyBhY2PDqHMgYXV4IGZvbmRzIGRlIGwndXRpbGlzYXRldXIuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEwnYXBwbGljYXRpb24gb2ZmcmUgdW4gbW9kw6hsZSBkZSBzw6ljdXJpdMOpIMOgIHNlcyBjbGllbnQsIGF2ZWMgZGVzIGNsw6lzIHByaXbDqWVzIGjDqWJlcmfDqWVzIGxvY2FsZW1lbnQgZXQgamFtYWlzIGVudm95w6llcyDDoCBhdWN1biBzZXJ2ZXVycy5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gTCdhcHBsaWNhdGlvbiBvZmZyZSB1bmUgaW50ZXJmYWNlIHNpbXBsZSBldCBkZXMgZXhww6lyaWVuY2VzIGF0dHJheWFudGVzIGF1eCB1dGlsaXNhdGV1cnMuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIEwnYXBwbGljYXRpb24gbmUgZGVtYW5kZSBqYW1haXMgw6AgY2UgcXVlIGxlcyB1dGlsaXNhdGV1cnMgc2Fpc2lzc2VudCBkZXMgaW5mb3JtYXRpb25zIHBlcnNvbm5lbGxlcy5cIixcblx0XCJBQk9VVF84XCI6IFwiVm90ZXogcG91ciBnb29kLWthcm1hIGNvbW1lIHTDqW1vaW5cIixcblx0XCJBQk9VVF85XCI6IFwiQ29udGFjdC9Sw6lhY3Rpb246XCIsXG5cdFwiQUJPVVRfMTBcIjogXCJQbHVzIGQnaW5mb3M6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiU3VwcHJpbWVyXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJWdWUgZHUgbWFyY2jDqVwiLFxuXHRcIlBSSUNFXCI6IFwiUHJpeFwiLFxuXHRcIkFNT1VOVFwiOiBcIk1vbnRhbnRcIixcblx0XCJOT09SREVSU1wiOiBcIlBhcyBkJ29yZHJlcyBvdXZlcnRzIHBvdXJcIixcblx0XCJCVVlcIjogXCJBY2hhdFwiLFxuXHRcIlNFTExcIjogXCJWZW50ZVwiLFxuXHRcIk9QRU5cIjogXCJPdXZlcnRcIixcblx0XCJISVNUT1JZXCI6IFwiSGlzdG9yaXF1ZVwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiU3VpdnJlXCIsXG5cdFwiRk9MTE9XRURcIjogXCJBYm9ubsOpXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJEw6lzYWJvbm5lclwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJDaGVyY2hlciBmb2xsb3dlcnNcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiQ2hlcmNoZXIgZm9sbG93aW5nXCIsXG5cdFwiQllcIjogXCJwYXJcIixcblx0XCJJTlwiOiBcImRhbnNcIixcblx0XCJCT09LTUFSS1wiOiBcIlNpZ25ldFwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJSZXRpcmVyIERvd252b3RlXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJSZXRpcmVyIFVwdm90ZVwiLFxuXHRcIlJFUExZXCI6IFwiUsOpcG9uZHJlXCIsXG5cdFwiRURJVFwiOiBcIkVkaXRlclwiLFxuXHRcIlBPU1RfMVwiOiBcIkdsaXNzZXIgdmVycyBsYSBnYXVjaGUgc3VyIGxlcyBjb21tZW50YWlyZXMgcG91ciB2b2lyIGxlcyBvcHRpb25zXCIsXG5cdFwiUE9TVF8yXCI6IFwiQXBwdXlleiBzdXIgbGVzIGNvbW1lbnRhaXJlcyBwb3VyIHZvaXIgbGVzIHNvdXMtY29tbWVudGFpcmVzXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVzdGVlbSBwYXJcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJSaWVuIGljaSBlbmNvcmUuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlNvbGRlc1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcIkxlcyB7e3BsYXRmb3JtbmFtZX19LCBqZXRvbnMgbsOpZ29jaWFibGVzIHF1aSBwZXV2ZW50IMOqdHJlIHRyYW5zZsOpcsOpcyDDoCB0b3V0IG1vbWVudC4gTGUge3twbGF0Zm9ybW5hbWV9fSBwZXV0IMOqdHJlIGNvbnZlcnRpIGVuIHt7cGxhdGZvcm1wb3dlcn19IGRhbnMgdW4gcHJvY2Vzc3VzIGFwcGVsw6kgcG93ZXItdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIGpldG9ucyBkJ2luZmx1ZW5jZSwgdm91cyBnYWduZXogcGx1cyBkZSBTdGVlbSBQb3dlciBlbiBsZSBjb25jZXJ2YW50IMOgIGxvbmcgdGVybWUgZXQgZW4gdm90YW50IHN1ciBsZXMgcG9zdGVzLiBQbHVzIG9uIGxlIGNvbnNlcnZlLCBwbHVzIG9uIGEgZCdpbmZsdWVuY2Ugc3VyIGxlcyByw6ljb21wZW5zZXMgZGVzIGF1dHJlcyBldCBkYW5zIGwnb2J0ZW50aW9uIGRlIHLDqWNvbXBlbnNlIHBvdXIgdW4gdm90ZSBlbiBwYXJ0aWN1bGllci5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJKZXRvbnMgZCd1bmUgdmFsZXVyIGQnZW52aXJvbiB7e3BsYXRmb3Jtc3VuaXR9fSBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlZhbGV1ciBlc3RpbcOpZVwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIkxhIHZhbGV1ciBlc3RpbcOpZSBlc3QgY2FsY3Vsw6llIHN1ciB1bmUgbW95ZW5uZSBkZSAzLjUgam91cnMgZGUgbGEgdmFsZXVyIGR1IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIkhpc3RvcmlxdWUgZGVzIFRyYW5zYWN0aW9uc1wiLFxuXHRcIlBPU1RJTkdcIjogXCJQb3N0ZVwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkxhIGNsw6kgZGUgcG9zdCBlc3QgdXRpbGlzw6llIHBvdXIgcG9zdGVyIGV0IHZvdGVyLiBFbGxlIGRvaXQgw6p0cmUgZGlmZsOpcmVudGUgZGVzIGNsw6lzIGFjdGl2ZXMgZXQgcHJvcHJpw6l0YWlyZXMuXCIsXG5cdFwiT1dORVJcIjogXCJQcm9wcmnDqXRhaXJlXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiTGEgY2zDqSBwcm9wcmnDqXRhaXJlIGVzdCBsYSBjbMOpIHByaW5jaXBhbGUgZHUgY29tcHRlIGV0IGVzdCByZXF1aXNlIHBvdXIgY2hhbmdlciBsZXMgYXV0cmVzIGNsw6lzLiBMYSBjbMOpIHByaXbDqWUgb3UgbGUgbW90IGRlIHBhc3NlIGRlIGxhIGNsw6kgcHJvcHJpw6l0YWlyZSBkb2l2ZW50IMOqdHJlIG1pcyBob3JzIGxpZ25lIGF1dGFudCBxdWUgcG9zc2libGUuXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiTGEgY2zDqSBhY3RpdmUgZXN0IHV0aWxpc8OpZSBwb3VyIGVmZmVjdHVlciBkZXMgdHJhbnNmZXJ0cyBldCBwYXNzZXIgZGVzIG9yZHJlcyBkYW5zIGxlIG1hcmNow6kgaW50w6lyaWV1ci5cIixcblx0XCJNRU1PXCI6IFwiTcOpbW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJMYSBjbMOpIG3DqW1vIHBlcm1ldCBkZSBjcsOpZXIgZXQgZGUgbGlyZSBkZXMgbcOpbW9zLlwiLFxuXHRcIlJFUExJRVNcIjogXCJSw6lwb25zZXNcIixcblx0XCJXQUxMRVRcIjogXCJQb3J0ZWZldWlsbGVcIixcblx0XCJVU0VSXCI6IFwiVXRpbGlzYXRldXJcIixcblx0XCJDTE9TRVwiOiBcIkZlcm1lclwiLFxuXHRcIlRPXCI6IFwiw6BcIixcblx0XCJBU1NFVFwiOiBcIlR5cGVcIixcblx0XCJTRU5EXCI6IFwiRW52b3llclwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU8OpY3VyaXTDqVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRpc3BvbmlibGVcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk3DqW1vIHB1YmxpcXVlXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlV0aWxpc2F0ZXVyIHBhciBleC4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiQ29kZSBQSU5cIixcblx0XCJQSU5fVEVYVFwiOiBcIkxlIGNvZGUgUElOIHZvdXMgYWlkZSDDoCBzw6ljdXJpc2VyIGwnYXBwbGljYXRpb24gZXQgdm9zIGRvbm7DqWVzLiA8YnIvPjxici8+PGI+Tm90ZTo8L2I+IFVuZSBmb2lzIGFjdGl2w6ksIHZvdXMgYXZleiA0IHRlbnRhdGl2ZXMgbWF4aW11bSBwb3VyIGTDqXZlcnJvdWlsbGVyLCBzaSB2b3VzIGF2ZXogb3VibGnDqSBsZSBwaW4gb3Ugc2kgdm91cyDDqWNob3VleiwgbCdhcHBsaWNhdGlvbiBzdXBwcmltZXJhIGxlcyBkb25uw6llcyB1dGlsaXNhdGV1ciBlbnJlZ2lzdHLDqWVzLiBWb3VzIHBvdXZleiB2b3VzIHJlY29ubmVjdGVyIGV0IGNvbnRpbnVlciDDoCB1dGlsaXNlciBsJ2FwcGxpY2F0aW9uLlwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gdm90ZXJhIHBvdXIgdW4gZGVzIHZvcyBjb250ZW51cyEgPGJyLz4gPGI+Tm90ZTo8L2I+IExlcyBub3RpZmljYXRpb25zIGluY2x1ZW50IGxlIHBvaWRzIGR1IHZvdGUgZGFucyBsZSBtZXNzYWdlIGQnYWxlcnRlLiAoUXUnaWwgcydhZ2lzc2UgZCd1biB1cHZvdGUsIGQnIHVuIGRvd252b3RlIG91IGQndW4gdm90ZSByZXRpcsOpKS5cIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJWb3VzIHJlY2V2cmV6IHVuZSBub3RpZmljYXRpb24gcXVhbmQgcXVlbHF1J3VuIGNvbW1lbnRlcmEgdW4gZGVzIHZvcyBwb3N0cyBvdSB1biBkZSB2b3MgY29tbWVudGFpcmVzITxici8+IDxiPk5vdGU6PC9iPiBMZXMgbm90aWZpY2F0aW9ucyBpbmNsdWVudCBxdWFuZCBxdWVscXUndW4gPGI+w6lkaXRlPC9iPiBzZXMgcHJvcHJlcyBjb21tZW50YWlyZXMgYXVzc2kuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkNvbW1lbnRhaXJlXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJWb3VzIHJlY2V2cmV6IHVuZSBub3RpZmljYXRpb24gcXVhbmQgcXVlbHF1J3VuIHMnYWJvbm5lcmEgb3Ugc2UgZMOpc2Fib25uZXJhIGRlIHZvdXMhXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlZvdXMgcmVjZXZyZXogdW5lIG5vdGlmaWNhdGlvbiBxdWFuZCBxdWVscXUndW4gdm91cyBtZW50aW9ubmVyYSBkYW5zIHVuIHBvc3QvY29tbWVudGFpcmUhXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90ZVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiTGUgcG9pZHMgb3UgbGUgcG91cmNlbnRhZ2UgZHUgdm90ZSBhZmZlY3RlIGxlIHBvdXZvaXIgZGUgdm90ZSBkYW5zIGwnYXBwbGljYXRpb24sIGRlIHRlbGxlIG1hbmnDqHJlIHZvdXMgcG91dmV6IHLDqWdsZXIgdm90cmUgcsOpY29tcGVuc2UgZGUgdm90ZS4gPGJyLz48YnIvPjxiPk5vdGU6PC9iPiBDZWxhIGNoYW5nZXJhIGxlIHBvaWRzL3BvdXJjZW50YWdlIGR1IHZvdGUgcG91ciBsZSBkb3dudm90ZSBwYXJ0b3V0IGRhbnMgbCdhcHBsaWNhdGlvblwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZldXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJlY29tbWFuZMOpXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2F1dmVnYXJkZXIgbGVzIGNoYW5nZW1lbnRzXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvIHZvdGVcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJCaWVudmVudWUgw6Agbm91dmVhdSFcIixcblx0XCJMT0dJTl8xXCI6IFwiQ29ubmVjdGV6LXZvdXMgYXZlYyB2b3RyZSBub20gZCd1dGlsaXNhdGV1ciBldCB2b3RyZSBtb3QgZGUgcGFzc2UgcG91ciBjb250aW51ZXIuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkxhIGNsw6kgZGUgcG9zdHMgZXN0IHV0aWxpc8OpZSBwb3VyIHBvc3RlciwgY29tbWVudGVyLCB2b3Rlciwgc3VpdnJlLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJMYSBjbMOpIGFjdGl2ZSBlc3QgdXRpbGlzw6llIHBvdXIgbGVzIHRyYW5zZmVydHMgZXQgbGEgbWlzZSDDoCBqb3VyIGRlIGwnaW1hZ2UgZGUgcHJvZmlsLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJMZXMgaW5mb3JtYXRpb25zIGQnaWRlbnRpZmljYXRpb24gZGUgbCd1dGlsaXNhdGV1ciBzb250IGNvbnNlcnbDqWVzIGxvY2FsZW1lbnQgc3VyIHZvdHJlIGFwcGFyZWlsLiBMb3JzIGRlIGxhIGTDqWNvbm5leGlvbiBlbGxlcyBzb250IHN1cHByaW3DqWVzIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIlBhcyBlbmNvcmUgZGUgY29tcHRlP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiRW5yZWdpc3RyZXotdm91cyBtYWludGVuYW50XCIsXG5cdFwiQ0FOQ0VMXCI6IFwiU3VwcHJpbWVyXCIsXG5cdFwiQURWQU5DRURcIjogXCJBdmFuY8OpXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkNsw6kgcHJpdsOpZSBhY3RpdmVcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIkNsw6kgcHJpdsOpZSBkZSBwb3N0c1wiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTW90IGRlIHBhc3NlIHByaW5jaXBhbFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiTm9tIGQndXRpbGlzYXRldXJcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJWdWUgdGh1aWxlXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVnVlIGNvbXBhY3RlXCIsXG5cdFwiU0VBUkNIXCI6IFwiUmVjaGVyY2hlclwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiUHJvcG9zZXIgdW4gcG9zdFwiLFxuXHRcIlJFUExZVE9cIjogXCJSw6lwb25kcmUgw6BcIixcblx0XCJQUkVWSUVXXCI6IFwiQXBlcsOndVwiLFxuXHRcIkRFRkFVTFRcIjogXCJQYXIgZMOpZmF1dCA1MCUgLyA1MCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlJlZnVzZXIgbGUgcGF5ZW1lbnRcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNhdXZlZ2FyZGVyIHBvdXIgcGx1cyB0YXJkXCIsXG5cdFwiQ0xFQVJcIjogXCJFZmZhY2VyXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiUG9zdGVyIGxlIGNvbnRlbnVcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJDb21tZW50ZXJcIixcblx0XCJUSVRMRVwiOiBcIlRpdHJlXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiUGFzIGRlIGNvbmNvcmRhbmNlXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJDb25maXJtZXIgUElOXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiT3V2ZXJ0dXJlIGR1IHBvc3RcIixcblx0XCJTRVRfUElOXCI6IFwiQ29uZmlndXJlciBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJFbnRyZXIgUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiVm91cyDDqnRlcyBzdXI/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiRXJyZXVyIGRlIGRpZmZ1c2lvbiwgZXNzYXllciDDoCBub3V2ZWF1IVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJSw6l1c3NpdGVcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlBvc3QgcmVibG9nw6khXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkVjaGVjIGRlIGxhIGNvbm5leGlvbiEgVmV1aWxsZXogdm91cyBhc3N1cmVyIGQnYXZvaXIgb3V2ZXJ0IHVuZSBzZXNzaW9uIGF2ZWMgbGUgbW90IGRlIHBhc3NlIHByaW5jaXBhbCBvdSB2b3RyZSBjbMOpIHByaXbDqWUgZGUgcG9zdCBzaSB2b3VzIGF2ZXogY2hvaXNpIGxlIG1vZGUgYXZhbmPDqS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLDiWNoZWMgZGUgbGEgY29ubmV4aW9uISBWZXVpbGxleiB2b3VzIGFzc3VyZXIgZCdhdm9pciBvdXZlcnQgdW5lIHNlc3Npb24gYXZlYyBsZSBtb3QgZGUgcGFzc2UgcHJpbmNpcGFsIG91IGF2b2lyIGZvdXJuaSB1bmUgY2zDqSBwcml2w6llIGFjdGl2ZSBsb3JzIGRlIGxhIGNvbm5leGlvbiBzaSB2b3VzIGF2ZXogY2hvaXNpIGxlIG1vZGUgQXZhbmPDqS5cIixcblx0XCJXQVJOSU5HXCI6IFwiQXR0ZW50aW9uXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIlZvdGUgcG91ciB0w6ltb2luXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJhIHZvdMOpIHBvdXIgdMOpbW9pblwiLFxuXHRcIkFHT1wiOiBcImRlcHVpc1wiLFxuXHRcIkZST01fTk9XXCI6IFwiw6AgcGFydGlyIGRlIG1haW50ZW5hbnRcIixcblx0XCJTRUNTXCI6IFwiU2Vjb25kZXNcIixcblx0XCJBX01JTlwiOiBcInVuZSBtaW5cIixcblx0XCJBTl9IT1VSXCI6IFwidW5lIGhldXJlXCIsXG5cdFwiSE9VUlNcIjogXCJoXCIsXG5cdFwiQV9EQVlcIjogXCJ1biBqb3VyXCIsXG5cdFwiREFZU1wiOiBcImpvdXJzXCIsXG5cdFwiQV9NT05USFwiOiBcInVuIG1vaXNcIixcblx0XCJNT05USFNcIjogXCJtb2lzXCIsXG5cdFwiQV9ZRUFSXCI6IFwidW5lIGFubsOpZVwiLFxuXHRcIllFQVJTXCI6IFwiYW5uw6llc1wiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluIHRlbXBzIGxlY3R1cmVcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiRG93bnZvdGVcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJDYXB0dXJlciBJbWFnZVwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiU8OpbGVjdGlvbm5lciBJbWFnZVwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiQ29uZmlndXJlciBVUkwgcGVyc29ubmFsaXPDqWVcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluc8OpcmVyIEltYWdlXCIsXG5cdFwiRVJST1JcIjogXCJFcnJldXJcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJFcnJldXIgdMOpbMOpY2hhcmdlbWVudFwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJDYW3DqXJhIHN1cHByaW3DqWVcIixcblx0XCJTRVRfVVJMXCI6IFwiQ29uZmlndXJlciBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiTGllbiBkaXJlY3QgcG91ciBsJ2ltYWdlXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21tZW50YWlyZSBlbnZvecOpIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiTGEgc3VwcHJlc3Npb24gZGVzIGNvbW1lbnRhaXJlcyBlc3QgaXJyw6l2ZXJzaWJsZS5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJDb21tZW50YWlyZSBzdXBwcmltw6lcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIlTDqWzDqWNoYXJnZW1lbnQgZGUgbCdpbWFnZVwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJUw6lsw6ljaGFyZ2VtZW50IHRlcm1pbsOpXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIlTDqWzDqWNoYXJnZW1lbnQgw6ljaG91w6lcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJNb3QgZGUgcGFzc2Ugb3Ugbm9tIGQndXRpbGlzYXRldXIgaW5jb3JyZWN0XCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBsYWNlciBsZSBRUiBjb2RlIGRhbnMgbGEgem9uZSBkZSBzY2FuXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiU295ZXogc3VyIGQnYXZvaXIgdW4gc29sZGUgc3VmZmlzYW50IHBvdXIgbGEgdHJhbnNhY3Rpb24hXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIkwndXRpbGlzYXRldXIgYXVxdWVsIHZvdXMgZXNzYXlleiBkJ2Vudm95ZXIgZGVzIGZvbmRzIG4nZXhpc3RlIHBhcyFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiRXRlcy12b3VzIHN1ciBkZSB2b3Vsb2lyIHRyYW5zZsOpcmVyP1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiTGEgdHJhbnNhY3Rpb24gZXN0IGRpZmZ1c8OpZVwiLFxuXHRcIkZFRURcIjogXCJTdWl2aXNcIixcblx0XCJUUkVORElOR1wiOiBcIlRlbmRhbmNlXCIsXG5cdFwiTkVXXCI6IFwiTm91dmVhdVwiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvbXVcIixcblx0XCJQQVlPVVRcIjogXCJQYWllbWVudFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwiQ29tbWVudGFpcmVzXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUZW5kYW5jZSBkZXB1aXMgMzAgam91cnNcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJDbGFzc2VyIHBvc3RzIHBhcjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDeWNsZSBkZSBQYWllbWVudFwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQYWllbWVudCBwb3RlbnRpZWxcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlBhaWVtZW50IHBhc3PDqVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJQYWllbWVudCBhdXRldXJcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJQYWllbWVudCB2b3Rlc1wiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUG9zdCBlbnZvecOpIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJTb3VtZXR0cmUgbGUgcG9zdCBwbHVzIHRhcmQhXCIsXG5cdFwiU0FWRURcIjogXCJTYXV2ZWdhcmTDqVwiLFxuXHRcIkNMRUFSRURcIjogXCJTdXBwcmltw6lcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiRG93bnZvdGUgdW4gcG9zdCBwZXV0IGVubGV2ZXIgbGVzIHLDqWNvbXBlbnNlcyBldCByZW5kcmUgY2VsdWktY2kgbW9pbnMgdmlzaWJsZS48YnI+PGJyPkxlIERvd252b3RlIGRldnJhaXQgw6p0cmUgdXRpbGlzw6kgcG91ciBjZWNpOiA8dWw+PGxpPkZyYXVkZSBvdSBQbGFnaWFyaXNtZTwvbGk+PGxpPlRyb2xscyBvdSBkaXNjb3VycyBkZSBoYWluZTwvbGk+PGxpPkNvbnRlbnUgaW5hcHByb3ByacOpIGludGVudGlvbm5lbCBvdSBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWl0ZSBhdHRlaW50ZS4gRMOpY291dnJleiBkJ2F1dHJlcyB0YWdzL3RlbmRhbmNlcyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0IGVubGV2w6kgZGVzIHNpZ25ldHMhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3QgYWpvdXTDqSBhdSBzaWduZXRzIVwiLFxuXHRcIlJFU0VUXCI6IFwiUsOpaW5pdGlhbGlzZXJcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmaWVyIGwnaW1hZ2UgZHUgcHJvZmlsXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZmllciBsJ2ltYWdlIGRlIGNvdXZlcnR1cmVcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJTVlAsIHZldWlsbGV6IGluZGlxdWVyIGxhIGNsw6kgcHJpdsOpZSBhY3RpdmUgc2kgdm91cyBhdmV6IGNob2lzaSBsZSBtb2RlIGRlIGNvbm5leGlvbiBhdmFuY8OpLlwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIkNlY2kgdmEgcsOpaW5pdGlhbGlzZXIgbCdpbWFnZSBwcm9maWwgZGUgbCd1dGlsaXNhdGV1clwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIkNlY2kgdmEgcsOpaW5pdGlhbGlzZXIgbCdpbWFnZSBkZSBjb3V2ZXJ0dXJlIGRlIGwndXRpbGlzYXRldXJcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIkxhIG1pc2Ugw6Agam91ciBkdSBzZXJ2ZXVyIG7DqWNlc3NpdGUgdW4gcmVkw6ltYXJyYWdlIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJQYXJhbcOodHJlcyBtaXMgw6Agam91ciFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJMYW5ndWVzXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJWb3VzIHBvdXZleiBjaGFuZ2VyIGljaSBsYSBsYW5ndWUgZGUgbCdhcHBsaWNhdGlvblwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJDZXR0ZSBvcMOpcmF0aW9uIHJlcXVpZXJ0IHF1ZSBsJ3V0aWxpc2F0ZXVyIHNvaXQgY29ubmVjdMOpIGF2ZWMgbGUgbW90IGRlIHBhc3NlIHByaW5jaXBhbCwgbGEgY2zDqSBkZSBwb3N0L2Nsw6kgYWN0aXZlLiBWZXVpbGxleiB2b3VzIGNvbm5lY3RlciBldCByw6llc3NheWVyLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxsZXJpZVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIkNvbnRyaWJ1dGV1cnMgZGUgdHJhZHVjdGlvblwiLFxuXHRcIlNIQVJFXCI6IFwiUGFydGFnZVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiTWFyY2jDqVwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiRWNoYW5nZVwiLFxuXHRcIkRSQUZUU1wiOiBcIkJyb3VpbGxvbnNcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQb3N0IHN1cHByaW3DqSBkZXMgYnJvdWlsbG9ucyFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiUG9zdCBham91dMOpIGF1eCBicm91aWxsb25zIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJHbGlzc2VyIHZlcnMgbGEgZ2F1Y2hlIHBvdXIgdm9pciBsZXMgb3B0aW9uc1wiLFxuXHRcIk1BTkFHRVwiOiBcIkfDqXJlclwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJJbWFnZSBlbmxldsOpZVwiLFxuXHRcIkNPUFlcIjogXCJjb3Bpw6lcIixcblx0XCJOT19JTUFHRVwiOiBcIlZvdXMgbidhdmV6IHBhcyBlbmNvcmUgdMOpbMOpY2hhcmdlciBkJ2ltYWdlcyBwb3VyIGxlIG1vbWVudCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlRpcmV6IHZlcnMgbGUgYmFzIHBvdXIgcmFmcmHDrmNoaXJcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBwcyBleHRlcm5lXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2dlc3Rpb25cIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkJpZW50w7R0XCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkljaSB2b3VzIHBvdXZleiBjaGFuZ2VyIHBvdXIgbGEgYmxvY2tjaGFpbiBvdSBsYSBwbGF0ZS1mb3JtZSBwYXIgZMOpZmF1dC5cIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi16LXnteV15Mg15TXkdeZ16pcIixcblx0XCJMT0dJTlwiOiBcIteb16DXmdeh15RcIixcblx0XCJMT0dPVVRcIjogXCLXmdem15nXkNeUXCIsXG5cdFwiUFJPRklMRVwiOiBcItek16jXldek15nXnFwiLFxuXHRcIkZPTExPV1wiOiBcItec16LXp9eV15FcIixcblx0XCJCT09LTUFSS1NcIjogXCLXodeZ157XoNeZ15XXqlwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi15TXoteR16jXlFwiLFxuXHRcIk1BUktFVFwiOiBcItep15XXp1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwi15DXpNep16jXldeZ15XXqlwiLFxuXHRcIkFCT1VUXCI6IFwi157XmdeT16JcIixcblx0XCJBQk9VVF8xXCI6IFwi157Xp9eV150g16nXkdeVINeb15wg15DXl9eTINeZ15vXldecINec15TXqNeV15XXmdeXINeR15bXm9eV16og15TXqteb16DXmdedINep15zXlSFcIixcblx0XCJBQk9VVF8yXCI6IFwi157Xldek16LXnCDXotecINeZ15PXmSB7e3BsYXRmb3JtbmFtZX19LiDXlNeQ16TXmdec16fXpteZ15Qg16DXm9eq15HXlCDXotecINeZ15PXmVwiLFxuXHRcIkFCT1VUXzNcIjogXCLXldeU15XXkCDXpNeq15XXlywg15XXnteV16DXoiDXotecINeZ15PXmSDXlNen15TXmdec15QuINeU15XXkCDXntem15nXoiDXkteZ16nXlCDXnNen16jXmdeQ15QsINec15vXqteZ15HXqiDXqteS15XXkdeV16osINec15zXmdeZ16fXmdedLCDXnNeU16LXkdeo16og15vXodek15nXnSDXldeb15UnLiDXlNek16LXldec15XXqiDXnteV16bXoteV16og16LXnCDXmdeT15kg15TXkdec15XXp9emJ9eZ15nXnyDXqdecIHt7cGxhdGZvcm1uYW1lfX0g15XXotecINeZ15PXmSB7e3NpdGVuYW1lfX1cIixcblx0XCJBQk9VVF80XCI6IFwiMS4g15zXkNek15zXmden16bXmdeUINeQ15nXnyDXkteZ16nXlCDXnNeb16HXpNeZ150g16nXnCDXlNee16nXqtee16kuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuINeU15DXpNec15nXp9em15nXlCDXlNeZ15Ag15HXmNeV15fXlCwg15vXqdeU16fXldeTINeU16TXqNeY15kg16nXnteV16gg157Xp9eV157XmdeqINeV15zXkCDXoNep15zXlyDXnNep16jXqteZ150g15fXmdem15XXoNeZ15nXnS5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4g15TXkNek15zXmden16bXmdeUINee16bXmdei15Qg15LXmdep15Qg16TXqdeV15jXlCDXldeg15XXl9eUINec157Xqdeq157XqS5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4g15TXkNek15zXmden16bXmdeUINec15Ag157Xkden16nXqiDXntee16nXqtee16nXmdedINee15nXk9eiINek16jXmNeZLlwiLFxuXHRcIkFCT1VUXzhcIjogXCLXlNem15HXmdei15Ug15wtZ29vZC1rYXJtYSDXkdeq15XXqCDXoteTXCIsXG5cdFwiQUJPVVRfOVwiOiBcItem15XXqCDXp9ep16hcIixcblx0XCJBQk9VVF8xMFwiOiBcItee15nXk9eiINeg15XXodejOlwiLFxuXHRcIlJFTU9WRVwiOiBcIteU16HXqNeUXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLXptek15Qg15HXqdeV16dcIixcblx0XCJQUklDRVwiOiBcItee15fXmdeoXCIsXG5cdFwiQU1PVU5UXCI6IFwi15vXnteV16pcIixcblx0XCJUT1RBTFwiOiBcIteh15og15TXm9ecXCIsXG5cdFwiTk9PUkRFUlNcIjogXCLXkNeZ158g15TXltee16DXldeqINek16rXldeX15XXqiDXoteR15XXqFwiLFxuXHRcIkRBVEVcIjogXCLXqteQ16jXmdeaXCIsXG5cdFwiQlVZXCI6IFwi16fXoNeZ15nXlFwiLFxuXHRcIlNFTExcIjogXCLXnteb15nXqNeUXCIsXG5cdFwiT1BFTlwiOiBcItek16rXmdeX15RcIixcblx0XCJISVNUT1JZXCI6IFwi15TXmdeh15jXldeo15nXlFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwi15zXoten15XXkVwiLFxuXHRcIkZPTExPV0VEXCI6IFwi16LXlden15FcIixcblx0XCJVTkZPTExPV1wiOiBcItec15TXpNeh15nXpyDXnNei16fXldeRXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwi16LXlden15FcIixcblx0XCJGT0xMT1dFUlNcIjogXCLXoteV16fXkdeZ151cIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwi15fXmdek15XXqSDXkdei15XXp9eR15nXnSDXkNeX16jXmdeZXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIteX15nXpNeV16kg15HXnteZINep15DXoNeZINei15XXp9eRINeQ15fXqNeZ15VcIixcblx0XCJCWVwiOiBcItei15wg15nXk9eZXCIsXG5cdFwiSU5cIjogXCLXkdeq15XXmlwiLFxuXHRcIk1FTlVcIjogXCLXqtek16jXmdeYXCIsXG5cdFwiQk9PS01BUktcIjogXCLXodeZ157XoNeZ15RcIixcblx0XCJSRUJMT0dcIjogXCLXotep15Ug16jXmdeR15zXldeSXCIsXG5cdFwiVVBWT1RFXCI6IFwi15zXmdeZ16dcIixcblx0XCJET1dOVk9URVwiOiBcIteQ16DXnNeZ15nXp1wiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLXkdeZ15jXldecINeQ16DXnNeZ15nXp1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi15HXmdeY15XXnCDXnNeZ15nXp1wiLFxuXHRcIlJFUExZXCI6IFwi15zXlNep15nXkVwiLFxuXHRcIkVESVRcIjogXCLXoteo15nXm9eUXCIsXG5cdFwiUE9TVF8xXCI6IFwi15TXl9ec16cg15DXqiDXlNeq15LXldeUINep157XkNec15Qg15zXptek15nXmdeUINeR15DXpNep16jXldeZ15XXqlwiLFxuXHRcIlBPU1RfMlwiOiBcItec15fXpSDXotecINeq15LXldeR15Qg15vXk9eZINec16jXkNeV16og16rXqteZLdeq15LXldeR15XXqlwiLFxuXHRcIk9QVElPTlNcIjogXCLXkNek16nXqNeV15nXldeqXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi16LXqdeVINeo15nXodeY15nXnVwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIteQ15nXnyDXpNeUINeb15zXldedINei15PXmdeZ158uLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIteb16HXpNeZ151cIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCDXnteY15HXoteV16og16nXoNeZ16rXoNeZ150g15zXlNei15HXqNeUINeR15vXnCDXoteqLiDXoNeZ16rXnyDXnNeU157XmdeoIHt7cGxhdGZvcm1uYW1lfX0g15wte3twbGF0Zm9ybXBvd2VyfX0g15HXoteW16jXqiDXqteU15zXmdeaINep16DXp9eo15Ag16TXkNeV15XXqC3XkNekLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCDXnteY15HXoteV16og15TXqdek16LXlCDXqdee15XXodeZ16TXmdedINec15vXnSDXm9eV15cg15HXlNem15HXoteULiDXm9eb15wg16nXmdepINec15vXnSDXmdeV16rXqCwg16rXldeb15zXmSDXnNeU16nXpNeZ16Ig15nXldeq16gg16LXnCDXlNeq16nXnNeV150g16nXnCDXpNeV16HXmNeZ150g15XXqteV15vXnNeVINec15TXqNeV15XXmdeXINeo15XXldeX15nXnSDXkteT15XXnNeZ150g15nXldeq16gg15HXlNem15HXoteULlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcItee15jXkdei15XXqiDXqdep15XXmdeZ150ge3twbGF0Zm9ybXN1bml0fX0g16nXnCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcItei16jXmiDXnteV16LXqNeaXCIsXG5cdFwiUFJPRklMRV80XCI6IFwi15TXoteo15og15fXldep15Eg16LXnCDXmdeT15kg157XnteV16bXoiDXnteX15nXqNeZ150g15EtNyDXlNeZ157XmdedINeU15DXl9eo15XXoNeZ150g16nXnCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCLXlNeZ16HXmNeV16jXmdeZ16og16TXoteV15zXldeqXCIsXG5cdFwiUE9TVElOR1wiOiBcIteU16LXnNeQ16og16TXldeh15hcIixcblx0XCJQUk9GSUxFXzVcIjogXCLXntek16rXlyDXlNek15XXodeY15nXnSDXoNeV16LXkyDXnNeb16rXmdeR16og16TXldeh15jXmdedINeV15zXnNeZ15nXp9eZ150uINei15zXmdeVINec15TXmdeV16og16nXldeg15Qg157XlNee16TXqteXINeU16TXoteZ15wg15XXntee16TXqteXINeU157Xqdeq157XqS5cIixcblx0XCJPV05FUlwiOiBcIteR16LXnNeZ151cIixcblx0XCJQUk9GSUxFXzZcIjogXCLXntek16rXlyDXlNee16nXqtee16kg15TXldeQINeU157XpNeq15cg15TXqNeQ16nXmSDXnNeX16nXkdeV158g15XXlNeV15Ag16DXl9eV16Ug16LXnCDXnteg16og15zXqdeg15XXqiDXntek16rXl9eV16og15DXl9eo15nXnS4g15TXntek16rXlyDXlNek16jXmNeZINeQ15Ug15TXodeZ16HXnteQINec16fXkdec16og157XpNeq15cg15TXntep16rXntepINeX15nXmdeR15nXnSDXnNeU15nXldeqINep157Xldeo15nXnSDXnteX15XXpSDXnNeQ16rXqC5cIixcblx0XCJBQ1RJVkVcIjogXCLXpNei15nXnFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIteU157XpNeq15cg15TXpNei15nXnCDXoNeV16LXkyDXnNeR15nXpteV16Ig15TXkdeo15XXqiDXm9eh16TXmdedINeV15zXkdeZ16bXldeiINeU15bXnteg15XXqiDXkdep15XXpyDXlNek16DXmdee15kuXCIsXG5cdFwiTUVNT1wiOiBcIteU16LXqNeUXCIsXG5cdFwiUFJPRklMRV84XCI6IFwi157XpNeq15cg15TXqteW15nXm9eZ16jXnSDXoNeV16LXkyDXnNeb16rXmdeR16og15XXp9eo15nXkNeqINeq15bXm9eZ16jXmdedLlwiLFxuXHRcIkJMT0dcIjogXCLXkdec15XXklwiLFxuXHRcIlBPU1RTXCI6IFwi16TXldeh15jXmdedXCIsXG5cdFwiUkVQTElFU1wiOiBcIteq15LXldeR15XXqlwiLFxuXHRcIldBTExFVFwiOiBcIteQ16jXoNenXCIsXG5cdFwiVEFHXCI6IFwi15jXkNeS15nXnVwiLFxuXHRcIlVTRVJcIjogXCLXntep16rXntepXCIsXG5cdFwiQ0xPU0VcIjogXCLXodeS15XXqFwiLFxuXHRcIlRPXCI6IFwi15DXnFwiLFxuXHRcIkFTU0VUXCI6IFwi16DXm9ehXCIsXG5cdFwiU0VORFwiOiBcItec16nXnNeV15dcIixcblx0XCJTRUNVUklUWVwiOiBcIteR15jXmdeX15XXqlwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcItek16DXldeZXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLXlNei16jXlCDXpNeV157XkdeZ16pcIixcblx0XCJUT19ERVNDXCI6IFwi157Xqdeq157XqSwg15zXk9eV15LXnteQIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIten15XXk1wiLFxuXHRcIlBJTl9URVhUXCI6IFwi16fXldeTINei15XXlteoINec15vXnSDXnNeQ15HXmNeXINeQ16og15TXkNek15nXnNen16bXmdeUINeV15DXqiDXlNee15nXk9eiINep15zXm9edLiDXlNei16jXlDog15HXqNeS16Ig16nXlNeV16TXotecLCDXkNek16nXqCDXnNeg16HXldeqINec16TXqteV15cg16LXkyA0INek16LXnteZ150uINeQ150g16nXm9eX16rXnSDXkNeqINeU16fXldeTLCDXlNeQ16TXnNeZ16fXpteZ15Qg16rXnteX16cg15DXqiDXlNee15nXk9eiINep15wg15TXntep16rXntepLiDXqteV15vXnCDXnNeU15nXm9eg16Eg157Xl9eT16kg15XXnNeU16nXqtee16kg15HXkNek15zXmden16bXmdeULlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLXlNeV15PXoteV16pcIixcblx0XCJWT1RFX1RFWFRcIjogXCLXqten15HXldecINeU15XXk9ei15Qg15vXqdee15nXqdeU15Ug15nXotep15Qg15zXm9edINec15nXmdenISDXlNei16jXlDog15TXlNeV15PXoteV16og15nXm9ec15zXlSDXktedINeQ16og157Xqden15wg15TXnNeZ15nXpyAo15HXmdefINeQ150g15zXmdeZ16csINeQ16DXnNeZ15nXpywg15DXlSDXkdeZ15jXldecINec15nXmdenKS5cIixcblx0XCJWT1RFXCI6IFwi15zXlNem15HXmdeiXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwi16rXp9eR15zXlSDXlNeV15PXoteUINeb16nXnteZ16nXlNeVINeZ15LXmdeRINec16TXldeh15jXmdedINeQ15Ug15zXqteS15XXkdeV16og16nXnNeb150hINeU16LXqNeUOiDXqten15HXnNeVINeU15XXk9ei15Qg15LXnSDXm9ep157Xmdep15TXlSDXmdei16jXldeaINeQ16og15TXqteS15XXkdeUINep15zXlS5cIixcblx0XCJDT01NRU5UXCI6IFwi16rXkteV15HXlFwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwi16rXp9eR15wg15TXldeT16LXlCDXm9ep157Xmdep15TXlSDXmdei16fXldeRINeQ15Ug15nXpNeh15nXpyDXnNei16fXldeRINeQ15fXqNeZ15ohXCIsXG5cdFwiTUVOVElPTlNcIjogXCLXqteW15vXldeo15nXnVwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLXqten15HXnCDXlNeV15PXoteUINeb16nXnteZ16nXlNeVINeZ15bXm9eZ16gg15DXldeq15og15HXpNeV16HXmCDXkNeVINeR16rXkteV15HXlCFcIixcblx0XCJSRVNURUVNXCI6IFwi16LXqdeVINeo15nXkdec15XXklwiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIteq16fXkdec15Ug15TXldeT16LXlCDXm9ep157Xmdep15TXlSDXmdei16nXlCDXqNeZ16HXmNeZ150g15zXpNeV16HXmCDXqdec15vXnSFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIten15XXoNek15nXkteV16jXpteZ15XXqlwiLFxuXHRcIlZPVElOR1wiOiBcIteU16bXkdei15XXqlwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi157Xqden15wg15TXnNeZ15nXpyDXoNeV16rXnyDXnNeb150g15zXqdec15XXmCDXkdeS15XXk9ecINeU15LXnteV15wg16nXqten15HXnNeVLiDXlNei16jXlDog16TXoteV15zXlCDXlteVINeq16nXoNeUINeS150g15DXqiDXlNee16nXp9ecINei15HXldeoINeQ16DXnNeZ15nXp1wiLFxuXHRcIlNFUlZFUlwiOiBcItep16jXqlwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwi157Xldee15zXpVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcItec16nXnteV16gg16nXmdeg15XXmdeZ151cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItee15nXk9eiINei15wg157XpteR15nXoteZ151cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCLXkdeo15XXm9eZ150g15TXqdeR15nXnSFcIixcblx0XCJMT0dJTl8xXCI6IFwi15TXmdeb16DXodeVINeR16LXlteo16og16nXnSDXlNee16nXqtee16kg15XXlNeh15nXodee15Ag16LXnCDXnteg16og15zXlNee16nXmdeaLlwiLFxuXHRcIkxPR0lOXzJcIjogXCLXntek16rXlyDXlNek15XXodeY15nXnSDXoNeV16LXkyDXnNeb16rXmdeR16og16TXldeh15jXmdedINeV16rXkteV15HXldeqLCDXldec15zXmdeZ16fXmdedLlwiLFxuXHRcIkxPR0lOXzNcIjogXCLXlNee16TXqteXINeU16TXoteZ15wg16DXldei15Mg15zXlNei15HXqNeV16og15XXnNei15PXm9eV158g16rXnteV16DXqiDXlNek16jXldek15nXnC5cIixcblx0XCJMT0dJTl80XCI6IFwi15TXnteZ15PXoiDXotecINeU157Xqdeq157XqSDXqdee15XXqCDXnten15XXnteZ16og16LXnCDXlNee15vXqdeZ16guINeb16nXnteq16DXqten15nXnSDXlNee15nXk9eiINeg157Xl9enIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIteQ15nXnyDXnNeb150g15fXqdeR15XXnyDXntep16rXntepP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwi15TXqNep157XlSDXoteb16nXmdeVXCIsXG5cdFwiQ0FOQ0VMXCI6IFwi15HXmdeY15XXnFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwi157Xqten15PXnVwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLXntek16rXlyDXpNei15nXnFwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi157XpNeq15cg16TXldeh15jXmdedXCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCLXntek16rXlyDXqNeQ16nXmVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwi16nXnSDXntep16rXntepXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi16rXpteV15LXqiDXm9eo15jXmdeh15nXnVwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIteq16bXldeS15Qg16fXldee16TXp9eY15nXqlwiLFxuXHRcIlNFQVJDSFwiOiBcIteX15nXpNeV16lcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIteb16rXkdeVINek15XXodeYXCIsXG5cdFwiUkVQTFlUT1wiOiBcIteU16nXmdeR15Ug15wtXCIsXG5cdFwiUE9TVFwiOiBcItek15XXodeYXCIsXG5cdFwiUFJFVklFV1wiOiBcIteq16bXldeS15Qg157Xp9eT15nXnteUXCIsXG5cdFwiREVGQVVMVFwiOiBcIteR16jXmdeo16og157Xl9eT15ogNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcItek15DXldeV16gt15DXpCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLXodeo15HXlSDXnNeq16nXnNeV151cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcItep157XqNeVINec157XkNeV15fXqCDXmdeV16rXqFwiLFxuXHRcIkNMRUFSXCI6IFwi16DXmden15XXmVwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIteq15XXm9efINeU16TXldeh15hcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCLXqteV15vXnyDXlNeq15LXldeR15RcIixcblx0XCJUSVRMRVwiOiBcIteb15XXqteo16pcIixcblx0XCJUQUdTXCI6IFwi15jXkNeS15nXnVwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcItec15Ag157XqteQ15nXnVwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi15DXqdeoINen15XXk1wiLFxuXHRcIklOQ09SUkVDVFwiOiBcItep15LXldeZXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi16TXldeq15cg16TXldeh15hcIixcblx0XCJTRVRfUElOXCI6IFwi16fXkdei15Ug16fXldeTXCIsXG5cdFwiRU5URVJfUElOXCI6IFwi15TXlteZ16DXlSDXp9eV15NcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLXkdeY15XXl9eZ150/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLXkNeZINeQ16TXqdeoINec15HXmNecINeo15nXodeY15nXnSwg16rXqNem15Ug15zXlNee16nXmdeaP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIteR16LXmdeZ16og16rXp9ep15XXqNeqLCDXoNeh15Qg16nXldeRIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLXlNem15zXl9eUXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLXotep15nXqtedINec16TXldeh15gg16jXmdeR15zXldeSIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLXlNeb16DXmdeh15Qg16DXm9ep15zXlCEg15DXoNeQINeV15PXkNeVINep16DXm9eg16HXqtedINei150g15TXodeZ16HXnteQINeU16jXkNep15nXqiDXkNeVINep15TXlteg16rXnSDXkNeqINee16TXqteXINeU16TXldeh15jXmdedINeQ150g16DXmdeh15nXqtedINec15TXmdeb16DXoSDXkdee16bXkSDXnteq16fXk9ee16ouXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwi15TXm9eg15nXodeUINeg15vXqdec15QhINeQ16DXkCDXldeT15DXlSDXqdeg15vXoNeh16rXnSDXotedINeU16HXmdeh157XkCDXlNeo15DXqdeZ16og15DXlSDXqdeU15bXoNeq150g15DXqiDXlNee16TXqteXINeU16TXoteZ15wg15DXnSDXoNeZ16HXmdeq150g15zXlNeZ15vXoNehINeR157XpteRINee16rXp9eT157Xqi5cIixcblx0XCJXQVJOSU5HXCI6IFwi15DXlteU16jXlFwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLXlNem15HXoteUINec16LXk1wiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwi15TXpteR16LXlCDXnNei15Mg15HXldem16LXlFwiLFxuXHRcIkFHT1wiOiBcItec16TXoNeZXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLXntei15vXqdeZ15VcIixcblx0XCJTRUNTXCI6IFwi16nXoNeZ15XXqlwiLFxuXHRcIkFfTUlOXCI6IFwi15PXp9eUXCIsXG5cdFwiTUlOU1wiOiBcIteT16fXldeqXCIsXG5cdFwiQU5fSE9VUlwiOiBcItep16LXlFwiLFxuXHRcIkhPVVJTXCI6IFwi16nXoteV16pcIixcblx0XCJBX0RBWVwiOiBcIteZ15XXnVwiLFxuXHRcIkRBWVNcIjogXCLXmdee15nXnVwiLFxuXHRcIkFfTU9OVEhcIjogXCLXl9eV15PXqVwiLFxuXHRcIk1PTlRIU1wiOiBcIteX15XXk9ep15nXnVwiLFxuXHRcIkFfWUVBUlwiOiBcItep16DXlFwiLFxuXHRcIllFQVJTXCI6IFwi16nXoNeZ151cIixcblx0XCJNSU5fUkVBRFwiOiBcIteT16fXldeqINen16jXmdeQ15RcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwi16LXqdeVINeQ16DXnNeZ15nXp1wiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcItem15zXnteVINeq157Xldeg15RcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIteR15fXqCDXqtee15XXoNeUXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLXp9eR16LXlSDXm9eq15XXkdeqINeQ15nXqdeZ16pcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIteU15vXoNeh15Qg16rXnteV16DXlFwiLFxuXHRcIkVSUk9SXCI6IFwi16nXkteZ15DXlFwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcItep15LXmdeQ15Qg15HXlNei15zXkNeUXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcItee16bXnNee15Qg15HXldeY15zXlFwiLFxuXHRcIlNFVF9VUkxcIjogXCLXp9eR16LXlSDXp9eZ16nXldeoXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIten15nXqdeV16gg15zXqtee15XXoNeUXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCLXlNeq15LXldeR15Qg16DXqdec15fXlCFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIteQ15kg15DXpNep16gg15zXqdeX15bXqCDXqteS15XXkdeUINep16DXnteX16fXlC4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIteq15LXldeR15Qg16DXnteX16fXlFwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi157Xotec15Qg16rXnteV16DXlFwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLXqtee15XXoNeUINeU15XXotec16rXlFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLXlNei15zXkNeUINeg15vXqdec15RcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLXlNeh15nXodee15Qg15DXlSDXqdedINeU157Xqtep157XqSDXqdeS15XXmdeZ151cIixcblx0XCJJTkZPXCI6IFwi157XmdeT16JcIixcblx0XCJRUl9URVhUXCI6IFwi16nXmdee15Ug16fXldeTIFFSINeR16rXldeaINeQ15bXldeoINeU16fXqNeZ15DXlFwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIteR15PXp9eVINep15nXqSDXnNeb150g157Xodek15nXpyDXm9eh16TXmdedINec15TXoteR16jXlCFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi15TXntep16rXntepINep15DXnNeZ15Ug16DXmdeh15nXqtedINec15TXoteR15nXqCDXm9eh16TXmdedINec15Ag16fXmdeZ150hXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIteR15jXldeXINep16rXqNem15Ug15zXlNei15HXmdeoINeQ16og15TXm9eh16TXmdedP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIteQ15nXqdeV16hcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIteU16TXoteV15zXlCDXoNep15zXl9eUXCIsXG5cdFwiRkVFRFwiOiBcItek15nXk1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwi157Xptec15nXl1wiLFxuXHRcIkhPVFwiOiBcIteX151cIixcblx0XCJORVdcIjogXCLXl9eT16lcIixcblx0XCJQUk9NT1RFRFwiOiBcItee16fXldeT157XmdedXCIsXG5cdFwiVk9URVNcIjogXCLXnNeZ15nXp9eZ151cIixcblx0XCJQQVlPVVRcIjogXCLXqtep15zXldedXCIsXG5cdFwiQ09NTUVOVFNcIjogXCLXqteS15XXkdeV16pcIixcblx0XCJUUkVORElOR18zMFwiOiBcIteX157XmdedINeRLTMwINeU15nXnteZ150g15TXkNeX16jXldeg15nXnVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItee15nXmdeg15Ug15zXpNeZOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIteW157XnyDXqtep15zXldedXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIteq16nXnNeV150g16LXqteZ15PXmVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwi16rXqdec15XXnSDXoteR16hcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwi16rXqdec15XXnSDXnNeb15XXqteRXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwi16rXqdec15XXnSDXnNee16nXkteZ15fXmdedXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCLXlNek15XXodeYINeg16nXnNeXIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLXnNep15zXldeXINee15DXldeX16gg15nXldeq16hcIixcblx0XCJTQVZFRFwiOiBcIteg16nXnteoXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIteg15XXp9eUXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIteQ16DXnNeZ15nXpyDXnNek15XXodeYINee15fXodeZ16gg157XlNeq16nXnNeV150g15XXlNeV16TXmiDXkNeV16rXlSDXnNek15fXldeqINeg16jXkNeULiDXkNeg15zXmdeZ16cg157XmdeV16LXkyDXnNee16fXqNeZ150g15TXkdeQ15nXnTog15TXoteq16fXlCwg15LXltei16DXldeqLCDXk9eR16jXmSDXqdeg15DXlCwg15jXqNeV15zXmdeg15IsINeh16TXkNedXCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi15TXktei16rXnSDXnNeS15HXldecINee16HXpNeoINeU15HXp9ep15XXqi4g15HXk9en15Ug15jXkNeS15nXnSDXkNeX16jXmdedIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIteU16TXldeh15gg15TXldeh16gg157XlNeh15nXnteg15nXldeqIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLXlNek15XXodeYINeg16nXnteoINeR16HXmdee16DXmdeV16ohXCIsXG5cdFwiUkVTRVRcIjogXCLXkNeZ16rXl9eV15xcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcItec16nXoNeV16og16rXnteV16DXqiDXpNeo15XXpNeZ15xcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItec16nXoNeV16og16rXnteV16DXqiDXm9eV16rXqNeqXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi15DXoNeQINeU15XXodeZ16TXlSDXntek16rXlyDXpNei15nXnCDXkNedINeq16jXpteVINec15TXmdeb16DXoSDXnNee16bXkSDXnteq16fXk9edIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIteq157Xldeg16og15TXpNeo15XXpNeZ15wg16rXkNeV16rXl9ecXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwi16rXnteV16DXqiDXlNeb15XXqteo16og16rXkNeV16rXl9ecXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLXoteT15vXldefINeU16nXqNeqINeT15XXqNepINeQ16rXl9eV15whXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIteU15TXkteT16jXldeqINei15XXk9eb16DXlSFcIixcblx0XCJMQU5HVUFHRVNcIjogXCLXqdek15XXqlwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi15vXkNefINeg15nXqtefINec16nXoNeV16og15DXqiDXlNep16TXlC5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwi16TXoteV15zXlCDXlteVINeT15XXqNep16og157XlNee16nXqtee16kg15zXlNeZ15XXqiDXqNep15XXnSDXotedINeU16HXmdeh157XkCDXlNeo15DXqdeZ16og15XXlNee16TXqteXINeU16TXoteZ15wg15DXlSDXntek16rXlyDXlNek16HXldeYLiDXkNeg15Ag15vXoNeh15Ug15XXoNeh15Ug16nXoNeZ16ouXCIsXG5cdFwiR0FMTEVSWVwiOiBcIteS15zXqNeZ15RcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCLXnteq16jXktee15nXnVwiLFxuXHRcIlNIQVJFXCI6IFwi16nXqtejXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLXlNep15XXp1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwi157XodeX16hcIixcblx0XCJEUkFGVFNcIjogXCLXmNeZ15XXmNeV16pcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCLXlNek15XXodeYINeU15XXodeoINee15TXmNeZ15XXmNeV16ohXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIteU16TXldeh15gg15TXqteV15XXodejINec15jXmdeV15jXldeqIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLXlNeX15zXmden15Ug16nXnteQ15zXlCDXkdep15HXmdecINeQ16TXqdeo15XXmdeV16pcIixcblx0XCJNQU5BR0VcIjogXCLXoNeZ15TXldecXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIteU16rXnteV16DXlCDXlNeV16HXqNeUXCIsXG5cdFwiQ09QWVwiOiBcIteU16LXqtenXCIsXG5cdFwiTk9fSU1BR0VcIjogXCLXoteV15Mg15zXkCDXlNei15zXmdeqINeq157Xldeg15QhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLXntep15vXlSDXnNee15jXlCDXm9eT15kg15zXqNei16DXn1wiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCLXmdeZ16nXldee15nXnSDXl9eZ16bXldeg15nXmdedXCIsXG5cdFwiUExVR0lOU1wiOiBcIteq15XXodek15XXqlwiLFxuXHRcIlNVR0dFU1RcIjogXCLXlNem16Ig15zXp9eo15nXkNeUXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCLXkden16jXldeRXCIsXG5cdFwiQ0hBSU5cIjogXCLXqdeo16nXqNeqXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIteb15DXnyDXqteV15vXnNeVINec16nXoNeV16og15HXnNeV16fXpifXmdeZ158g15DXlSDXkNeqINeR16jXmdeo16og15TXnteX15PXnFwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi157XmNeR16JcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwi15vXkNefINeq15XXm9ec15Ug15zXqdeg15XXqiDXkNeqINee15jXkdeiINeR16jXmdeo16og15TXnteX15PXnCDXqdec15vXnS4g15TXqdeV15XXmSDXqdecINek15XXodeYXFxcXNeq15LXldeR15Qg15nXldek15nXoiDXkdee15jXkdeiINeW15QuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+16jXqdeZ157XqiDXqdeZ157Xldep15nXnSDXkdek15zXmNek15XXqNee15Q8L2I+IDxicj4t15LXmdep15Qg15zXnteQ157XqNeZ150g15nXl9eV15PXmdeZ150g15HXm9ecINeg15XXqdeQINep16rXlNeZ15Ug157XoteV16DXmdeZ16DXmdedINec16fXqNeV15AuIDxicj4gLdeU16rXl9eR16jXlSDXnNeb15XXqteR15nXnSDXk9eo15og16rXkteV15HXldeqINeV15PXmdeV16DXmdedLiA8YnI+LdeU16bXkdei15Qg16LXkdeV16gg16TXldeh15jXmdedINec15TXoteg16fXqiDXktee15XXnCwg15XXlNeo15XXldeX16og15LXnteV15wg16LXkdeV16gg15TXpteR16LXldeqLiA8YnI+Ldek16jXodee15Ug157XkNee16jXmdedINeV16TXldeh15jXmdedLCDXlNeo15XXldeZ15fXlSDXqteS157Xldec15nXnSDXldee16bXkNeVINeQ16DXqdeZ150g16nXmdei16fXkdeVINeQ15fXqNeZINeU15HXnNeV15Ig16nXnNeb150uIDxicj4t15vXqteZ15HXqiDXnteQ157XqNeZ150g15PXmdeg157XmdeqLCDXqdee15nXqNeqINen15HXldeqINep15wg15TXpNeV16HXmCDXnNek16jXodeV150g157XkNeV15fXqCDXmdeV16rXqC4gPGJyPi0g16nXnteo15Ug157XkNee16jXmdedINec16fXqNeZ15DXlCDXkdee15XXoteTINee15DXldeX16gg15nXldeq16guIDxicj4tINek15PXlSDXkNeqINeU16jXldeV15fXmdedINep15zXm9edLiA8YnI+Ldep15zXl9eVINeb16HXpNeZ150g15zXl9eR16jXmdedINeQ15Ug15zXntep16rXntep15nXnSDXkNeX16jXmdedIDxicj4tINei16fXkdeVINeQ15fXqNeZINeh15XXpNeo15nXnSDXldeR15zXldeS16jXmdedINee16LXoNeZ15nXoNeZ150uIDxicj4gLdeX15nXpNeV16kg15HXoteV16fXkdeZ150g16nXnNeb150g15XXkdee15kg16nXoteV16fXkSDXkNeX16jXmdeb150uIDxicj4t16fXkdec15Ug15TXldeT16LXldeqINei15wg157XoNeqINec15TXmdep15DXqCDXkdei16DXmdeZ16DXmdedINei150g16LXlden15HXmdedINeV16LXnSDXldeT15nXldeg15nXnSDXqdeQ16rXnSDXntei16jXldeR15nXnSDXkdeU150uIDxicj4t15fXmdek15XXqSDXqteS15nXldeqL9en15jXkteV16jXmdeV16og157Xoteg15nXmdeg15XXqiDXqdecINee15DXnteo15nXnSDXldeb15XXqteR15nXnS4gPGJyPiAt15TXqteQ157XlCDXkNeZ16nXmdeqINep15wg15TXpNeo15XXpNeZ15wg16nXnNeaLiA8YnI+Ldei15XXkyDXlNeo15HXlCDXpNeV16DXp9em15nXldeqINeR15PXqNeaLiA8YnI+PGJyPjxiPteQ15HXmNeX15Q8L2I+IDxicj4xLiDXnNeQ16TXnNeZ16fXpteZ15Qg15DXmdefINeS15nXqdeUINec15vXodek15kg15TXntep16rXntepLiA8YnI+Mi4g15TXkNek15zXmden16bXmdeUINee16bXmdei15Qg157XldeT15wg15DXkdeY15fXlCDXkdem15Mg15TXnNen15XXlywg16LXnSDXntek16rXl9eV16og16TXqNeY15nXmdedINeU16nXnteV16jXmdedINeR15DXldek158g157Xp9eV157XmSDXldep15DXmdeg150g16DXqdec15fXmdedINec16nXqNeq15nXnSwg15DXqtedINeQ15fXqNeQ15nXnSDXnNeS15nXkdeV15kg15TXodeZ16HXnteQ15XXqiDXqdec15vXnS4gPGJyPjMuINeU15DXpNec15nXp9em15nXlCDXntem15nXoteUINee157XqdenINeV15fXldeV15nXlCDXkNeY16jXp9eY15nXkdeZ16og15zXntep16rXntepIDxicj40LiDXlNeQ16TXnNeZ16fXpteZ15Qg157XpteZ16LXlCDXqdeb15HXlCDXoNeV16HXpNeqINep15wg15HXmdeY15fXldefINei150g16fXldeTIDxicj48YnI+IGVTdGVlbSDXqteV157XmiDXkdek15zXmNek15XXqNee15XXqiBTdGVlbSDXlS1Hb2xvcy4gPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLXnteZ15nXodeTINeV157XpNeq15cg16jXkNep15lcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIteU15XXodejINee16nXqtee16lcIixcblx0XCJQTEFURk9STVwiOiBcItek15zXmNek15XXqNee15RcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiUG/EjWV0bmEgc3RyYW5pY2FcIixcblx0XCJMT0dJTlwiOiBcIlByaWphdmFcIixcblx0XCJMT0dPVVRcIjogXCJPZGphdmFcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiUHJhdGlcIixcblx0XCJCT09LTUFSS1NcIjogXCJPem5ha2VcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlByaWplbm9zXCIsXG5cdFwiTUFSS0VUXCI6IFwiVHJnb3ZpbmFcIixcblx0XCJTRVRUSU5HU1wiOiBcIlBvc3RhdmtlXCIsXG5cdFwiQUJPVVRcIjogXCJPIGFwbGlrYWNpamlcIixcblx0XCJBQk9VVF8xXCI6IFwiZ2RqZSBzdmF0a28gbW/FvmUgemFyYWRpdGkgbmFncmFkZSB6YSBzdm9qIHNhZHLFvmFqIVwiLFxuXHRcIkFCT1VUXzJcIjogXCJqZSBkcnXFoXR2ZW5hIGFwbGlrYWNpamEgZ2RqZSBzaSBwbGHEh2VuIHphIGJsb2dhbmplLCBrb21lbnRpcmFuamUgaSBrdXJhY2lqZS5cIixcblx0XCJBQk9VVF8zXCI6IFwiaSBvbmEgamUgb3R2b3Jlbm9nLWl6dm9yYSwgemFqZWRuaWNhIHBva3JlxIdlIG1vYmlsbmkgcHJvamVrdC4gTnVkaSBzYWRyxb5haiBrb2ppIGplIGRvc3R1cGFuIHphIMSNaXRhbmplLCBrb21lbnRpcmFuamUsIGdsYXNhbmplLCBvYmphdmxqaXZhbmplLCBwcmlqZW5vcyB6YXJhZGUgaSBkcnVnZSBwb2dvZG5vc3RpIGtvamUgbmFtIG51ZGkge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGkge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCJBcGxpa2FjaWphIG5pa2FkIG5lIHByaXN0dXBhIGlsaSB6YWRyxb5hdmEga29yaXNuacSNa2Egc3JlZHN0dmEuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEFwbGlrYWNpamEgbnVkaSBzaWd1cm5vc25pIG1vZGVsIG5hIHN0cmFuaSBrbGlqZW50YS4gUHJpdmF0bmkga2xqdcSNZXZpIHN1IHNwcmVtZWxqYW5pIGxva2Fsbm8gaSBuaWthZCBzZSBuZSDFoWFsanUgbmEgc2VydmVyZS5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gQXBsaWthY2lqYSBudWRpIGplZG5vc3Rhdm5vLCBhdHJha3Rpdm5vIGtvcmlzbmnEjWtvIHN1xI1lbGplIGkgZG/Fvml2bGphai5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXBsaWthY2lqYSBuaWthZCBuZSB6YWh0amV2YSBvZCBrb3Jpc25pa2EgZGEgdW5vc2kgcHJpdmF0bmUgaW5mb3JtYWNpamUuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIkdsYXNhaiB6YSBnb29kLWthcm1hIGthbyBzdmplZG9rYVwiLFxuXHRcIkFCT1VUXzlcIjogXCJLb250YWt0L2ZlZWRiYWNrOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiVmnFoWUgaW5mb3JtYWNpamE6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiVWtsb25pXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJQcmVnbGVkIHRyxb5pxaF0YVwiLFxuXHRcIlBSSUNFXCI6IFwiQ2lqZW5hXCIsXG5cdFwiQU1PVU5UXCI6IFwiSXpub3NcIixcblx0XCJUT1RBTFwiOiBcIlVrdXBub1wiLFxuXHRcIk5PT1JERVJTXCI6IFwiTmVtYSBvdHZvcmVuaWggbmFydWTFvmJpIHphXCIsXG5cdFwiREFURVwiOiBcIkRhdHVtXCIsXG5cdFwiQlVZXCI6IFwiS3VwaVwiLFxuXHRcIlNFTExcIjogXCJQcm9kYWpcIixcblx0XCJPUEVOXCI6IFwiT3R2b3JpXCIsXG5cdFwiSElTVE9SWVwiOiBcIlBvdmlqZXN0XCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJVenZyYXRpIHByYcSHZW5qZVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiUHJhdGltXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJQcmVzdGFuaSBwcmF0aXRpXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiUHJhxIdlbmplXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiUHJhdGl0ZWxqaVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJQcmV0cmHFvmkgcHJhdGl0ZWxqZVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJQcmV0cmHFvmkgb25lIGtvamUgcHJhdGl0ZVwiLFxuXHRcIkJZXCI6IFwib2RcIixcblx0XCJJTlwiOiBcInVcIixcblx0XCJNRU5VXCI6IFwiSXpib3JuaWtcIixcblx0XCJCT09LTUFSS1wiOiBcIk96bmFrYVwiLFxuXHRcIlJFQkxPR1wiOiBcIlBvZGlqZWxpXCIsXG5cdFwiVVBWT1RFXCI6IFwiU3ZpxJFhIG1pIHNlXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJOZSBzdmnEkWEgbWkgc2VcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiUG9uacWhdGkgZ2xhc1wiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiUG9uacWhdGkgZ2xhc1wiLFxuXHRcIlJFUExZXCI6IFwiT2Rnb3ZvclwiLFxuXHRcIkVESVRcIjogXCJVcmVkaVwiLFxuXHRcIlBPU1RfMVwiOiBcIlBvdnVjaXRlIHUgbGlqZXZvIGtvbWVudGFyZSBkYSBiaSBzdGUgdmlkamVsaSBvcGNpamVcIixcblx0XCJQT1NUXzJcIjogXCJEb2Rpcm5pdGUga29tZW50YXJlIGRhIGJpIHN0ZSB2aWRqZWxpIHBvZC1rb21lbnRhcmVcIixcblx0XCJPUFRJT05TXCI6IFwiT3BjaWplXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUG9kamVsamVubyBvZFwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIkpvxaEgdXZpamVrIG5lbWF0ZSBuacWhdGEgb3ZkamUuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlN0YW5qZVwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sIFRyZ292aW5za2kgdG9rZW5pIGtvamkgc2UgbW9ndSBwcmViYWNpdGkgdSBiaWxvIGtvamUgdnJpamVtZS57e3BsYXRmb3JtbmFtZX19IG1vxb5lIGJpdGkgcHJlYmHEjWVuIHUge3twbGF0Zm9ybXBvd2VyfX0gdSBwcm9jZXN1IGtvamkgc2Ugem92ZSBKYcSNYW5qZSBwcm9maWxhLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCB0b2tlbmkga29qaSBwcmV6ZW50aXJhanUgamHEjWludSB2YcWhZWcgcHJvZmlsYS4gxaB0byBpaCB2acWhZSBuZXRrbyBpbWEgdG8gaW1hIHZlxIdpIHV0amVjYWogbmEgbmFncmFkdSBvYmphdmUgemEga29qdSBnbGFzdWplIGkgemFyYcSRdWplIHZlxIdlIG5hZ3JhZGUgemEgZ2xhc292YW5qZS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbmkgdnJpamVkZSBvdHByaWxpa2Uge3twbGF0Zm9ybXN1bml0fX0gb2Qge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJQcm9jaWplbmplbmEgdnJpamVkbm9zdFwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIlByb2NpamVuamVuYSB2cmlqZWRub3N0IGJhemlyYW5hIG5hIDcgZG5ldm5vaiBwcm9zamXEjW5vaiB2cmlqZWRub3N0aSBvZCB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJQb3ZpamVzdCB0cmFuc2FrY2lqYVwiLFxuXHRcIlBPU1RJTkdcIjogXCJPYmphdmxqaXZhbmplXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiS2xqdcSNIHphIG9iamF2bGppdmFuamUgc2Uga29yaXN0aSB6YSBvYmphdmUgaSBnbGFzYW5qZS4gVHJlYmFvIGJpIGJpdGkgZHJ1Z2HEjWlqaSBvZCBha3Rpdm5vZyBpIHZsYXNuacSNa29nIGtsanXEjWEuXCIsXG5cdFwiT1dORVJcIjogXCJWbGFzbmlrXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiVmxhc25pxI1raSBrbGp1xI0gamUgbWFzdGVyIGtsanXEjSB6YSByYcSNdW4gaSBwb3RyZWJhbiBqZSB6YSBwcm9tamVudSBkcnVnaWgga2xqdcSNZXZhLiBQcml2YXRuaSBrbGp1xI0gaWxpIGxvemlua2EgemEgdmxhc25pxI1raSBrbGp1xI0gdHJlYmFsYSBiaSBiaXRpIHZhbiBtcmXFvmUgxaF0byBqZSB2acWhZSBtb2d1xIdlLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFrdGl2bm9zdGlcIixcblx0XCJQUk9GSUxFXzdcIjogXCJBa3Rpdm5pIGtsanXEjSBzZSBrb3Jpc3RpIHphIHRyYW5zYWtjaWplIGkgemFkYXZhbmplIG5hcnVkxb5iaSB1IHVncmHEkWVub20gdHLFvmnFoXR1LlwiLFxuXHRcIk1FTU9cIjogXCJCaWxqZcWha2FcIixcblx0XCJQUk9GSUxFXzhcIjogXCJLbGp1xI0gemEgYmlsamXFoWt1IHNlIGtvcmlzdGkgemEgaXpyYWR1IGkgxI1pdGFuamUgYmlsamXFoWtpLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJPYmphdmVcIixcblx0XCJSRVBMSUVTXCI6IFwiT2Rnb3ZvcmlcIixcblx0XCJXQUxMRVRcIjogXCJOb3bEjWFuaWtcIixcblx0XCJUQUdcIjogXCJUYWdvdmlcIixcblx0XCJVU0VSXCI6IFwiS29yaXNuaWtcIixcblx0XCJDTE9TRVwiOiBcIlphdHZvcmlcIixcblx0XCJUT1wiOiBcIlphXCIsXG5cdFwiQVNTRVRcIjogXCJJbW92aW5hXCIsXG5cdFwiU0VORFwiOiBcIlBvxaFhbGppXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTaWd1cm5vc3RcIixcblx0XCJBVkFJTEFCTEVcIjogXCJEb3N0dXBub1wiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiSmF2bmEgYmlsamXFoWthXCIsXG5cdFwiVE9fREVTQ1wiOiBcIktvcmlzbmlrIG5wci4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUGluIGtvZFwiLFxuXHRcIlBJTl9URVhUXCI6IFwiUElOIGtvZCB2YW0gcG9tYcW+ZSB6YcWhdGl0aXRpIGFwbGlrYWNpanUgaSB2YcWhZSBwb2RhdGtlLjxici8+PGJyLz48Yj5OYXBvbWVuYTo8L2I+S2FkIHNlIGplZG5vbSB1a2xqdcSNaSwgaW1hdGUgbWFrc2ltYWxubyA0IHBva3XFoWFqYSB6YSBvdGtsanXEjWF0aSwgYWtvIHphYm9yYXZpdGUgcGluIGlsaSBwb2dyaWplxaFpdGUsIGFwbGlrYWNpamEgxIdlIG1ha251dGkgcG9kYXRrZSBsb2dpcmFuamEuIE1vxb5ldGUgc2UgcG9ub3ZvIGxvZ2lyYXRpIGkgbmFzdGF2aXRpIGtvcmlzdGl0aSBhcGxpa2FjaWp1LlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCJPYmF2aWplc3RpXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiRG9iaXQgxIdldGUgb2JhdmlqZXN0IGthZGEgbmV0a28gZ2xhc3VqZSB6YSB2YcWhIHNhZHLFvmFqISA8YnIvPjxiPk5hcG9tZW5hOjwvYj4gT2JhdmlqZXN0aSB0YWtvxJFlciBzYWRyxb5lIHBvc3RvdGFrIGdsYXNhIGkgb3BpcyBnbGFzYS4gKFN2acSRYSBtaSBzZSwgTmUgc3ZpxJFhIG1pIHNlLCBQb25pxaF0YXZhbmplIGdsYXNhKS5cIixcblx0XCJWT1RFXCI6IFwiR2xhc1wiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIkRvYml0IMSHZXRlIG9iYXZpamVzdCBrYWQgbmV0a28ga29tZW50aXJhIHZhxaF1IG9iamF2dSBpbGkga29tZW50YXIhPGJyLz48Yj5OYXBvbWVuYTo8L2I+T2JhdmlqZXN0aSDEh2UgdGFrb8SRZXIgc2FkcsW+YXZhdGkgaSA8Yj5wcm9tamVuZTwvYj4gbmppaG92aWgga29tZW50YXJhLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJLb21lbnRhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiRG9iaXQgxIdldGUgb2JhdmlqZXN0IGthZCB2YXMgbmV0a28gcG/EjW5lIGlsaSBwcmVzdGFuZSBwcmF0aXRpIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiU3BvbWluamFuamFcIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwiRG9iaXQgxIdldGUgb2JhdmlqZXN0IGthZCB2YXMgbmV0a28gc3BvbWVuZSB1IG9iamF2aSBpbGkga29tZW50YXJ1IVwiLFxuXHRcIlJFU1RFRU1cIjogXCJQb2RpamVsaVwiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIkRvYml0IMSHZXRlIG9iYXZpamVzdCBrYWRhIG5ldGtvIHBvZGlqZWxpIHR2b2p1IG9iamF2dSFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3VyYWNpamFcIixcblx0XCJWT1RJTkdcIjogXCJHbGFzb3ZhbmplXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJQb3N0b3RhayBnbGFzYSB1dGplxI1lIG5hIGdsYXNhbmphIHUgYXBsaWthY2lqaSwgem5hxI1pIG1vxb5ldGUgcmVndWxpcmF0aSBuYWdyYWR1IGtvanUgcHJlZGFqZXRlIG9iamF2aS48YnIvPjxici8+PGI+TmFwb21lbmE6PC9iPiBPdm8gxIdlIHRha2/EkWVyIHByb21pamVuaXRpIHBvc3RvdGFrIGkgXFxcIk5lc3ZpxJFhbmphXFxcIiBpIHRvIHN2dWdkamUgdSBhcGxpa2FjaWppXCIsXG5cdFwiU0VSVkVSXCI6IFwiU2VydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJQcmVwb3J1xI1lbm9cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTcHJlbWkgcHJvbWplbmVcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZm9ybWFjaWplIGdsYXNhxI1hXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiRG9icm8gZG/FoWxpIG5hdHJhZyFcIixcblx0XCJMT0dJTl8xXCI6IFwiUHJpamF2aXRlIHNlIHNhIHN2b2ppbSBrb3Jpc25pxI1raW0gaW1lbm9uIGkgbG96aW5rb20gemEgbmFzdGF2YWsuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIktsanXEjSB6YSBvYmphdmUgc2Uga29yaXN0aSB6YSBvYmphdmUsIGtvbWVudGFyZSwgZ2xhc292YW5qZSwgcHJhxIdlbmplLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBa3Rpdm5pIGtsanXEjSBzZSBrb3Jpc3RpIHphIHByaWplbm9zIHNyZWRzdGF2YSBpIHByb21qZW51IHByb2ZpbG5lIHNsaWtlLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJLb3Jpc25pxI1raSBwb2RhdGNpIHByaWphdmUgxI11dmFqdSBzZSBsb2thbG5vIG5hIHVyZcSRYWp1LiBOYWtvbiBvZGphdmUgcG9kYXRjaSB6YSBwcmlqYXZ1IG5lc3RhanUhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTmVtYXRlIGtvcmlzbmnEjWtpIHJhxI11bj9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlJlZ2lzdHJpcmFqdGUgc2Ugb2RtYWhcIixcblx0XCJDQU5DRUxcIjogXCJPZHVzdGFuaVwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiTmFwcmVkbm9cIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQWt0aXZuaSBwcml2YXRuaSBrbGp1xI1cIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIlByaXZhdG5pIGtsanXEjSB6YSBvYmphdmVcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIk1hc3Rlci9nbGF2bmEgbG96aW5rYVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiS29yaXNuacSNa28gaW1lXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiS2FydGnEjW5pIHByZWdsZWRcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJLb21wYWt0bmkgcHJlZ2xlZFwiLFxuXHRcIlNFQVJDSFwiOiBcIlByZXRyYcW+aVwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiT2JqYXZpIG5vdnUgcHJpxI11XCIsXG5cdFwiUkVQTFlUT1wiOiBcIk9kZ292b3IgbmFcIixcblx0XCJQT1NUXCI6IFwiT2JqYXZhXCIsXG5cdFwiUFJFVklFV1wiOiBcIlByZWRwcmVnbGVkXCIsXG5cdFwiREVGQVVMVFwiOiBcIlphZGFubyA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiSmHEjWFuamUgcHJvZmlsYSAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJPdGthxb5pIGlzcGxhdHVcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNQUkVNSSBaQSBLQVNOSUpFXCIsXG5cdFwiQ0xFQVJcIjogXCJPxIxJU1RJXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiU2FkcsW+YWogb2JqYXZlXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiS29tZW50aXJhanRlIHNhZHLFvmFqXCIsXG5cdFwiVElUTEVcIjogXCJOYXNsb3ZcIixcblx0XCJUQUdTXCI6IFwiVGFnb3ZpXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTkUgT0RHT1ZBUkFcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlBvdHZyZGl0ZSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJORUlTUFJBVk5PXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwib3R2YXJhbmplIG9iamF2ZVwiLFxuXHRcIlNFVF9QSU5cIjogXCJQb3N0YXZpIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIlVuZXNpdGUgUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiSmVzdGUgbGkgc2lndXJuaT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIkRpamVsamVuamUgcG9zdGEgamUgbmVwb3ZyYXRubywgxb5lbGl0ZSBsaSBuYXN0YXZpdGk/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiUG9ncmXFoWthIHByaWxpa29tIGVtaXRpcmFuamEsIHBva3XFoWFqdGUgcG9ub3ZvIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJVc3BqZcWhbm9cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIk9iamF2YSBqZSBwb2RpamVsamVuYSFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiUHJpamF2YSBuaWplIHVzcGplbGEuIE1vbGltbyBwcm92amVyaXRlIGplc3RlIGxpIHByaWphdmxqZW5pIHNhIG1hc3RlciBsb3ppbmtvbSBpbGkga2xqdcSNZW0gemEgb2JqYXZlIGFrbyBzdGUgb2RhYnJhbGkgbmFwcmVkbmkgbmHEjWluIHJhZGEuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiUHJpamF2YSBuaWplIHVzcGplbGEhIE1vbGltbyB2YXMgcHJvdmplcml0ZSBqZXN0ZSBsaSBwcmlqYXZsamVuaSBzYSBtYXN0ZXIgbG96aW5rb20gaWxpIGFrdGl2bmltIHByaXZhdG5pbSBrbGp1xI1lbSBha28gc3RlIG9kYWJyYWxpIG5hcHJlZG5pIG5hxI1pbi5cIixcblx0XCJXQVJOSU5HXCI6IFwiVXBvem9yZW5qZVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJHbGFzb3ZhbmplIHphIHN2amVkb2thXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJHbGFzYWxpIHN0ZSB6YSBzdmplZG9rYVwiLFxuXHRcIkFHT1wiOiBcInByaWplXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJvZCBzYWRhXCIsXG5cdFwiU0VDU1wiOiBcInNla3VuZGlcIixcblx0XCJBX01JTlwiOiBcIjEgbWluXCIsXG5cdFwiTUlOU1wiOiBcIm1pblwiLFxuXHRcIkFOX0hPVVJcIjogXCIxIHNhdFwiLFxuXHRcIkhPVVJTXCI6IFwic2F0aVwiLFxuXHRcIkFfREFZXCI6IFwiMSBkYW5cIixcblx0XCJEQVlTXCI6IFwiZGFuYVwiLFxuXHRcIkFfTU9OVEhcIjogXCJtamVzZWMgZGFuYVwiLFxuXHRcIk1PTlRIU1wiOiBcIm1qZXNlY2lcIixcblx0XCJBX1lFQVJcIjogXCJnb2RpbnUgZGFuYVwiLFxuXHRcIllFQVJTXCI6IFwiZ29kaW5lXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gxI1pdGFuamFcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiTmVzdmnEkWFuamUgaWxpIHByaWphdmFcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJTbmltaSBzbGlrdVwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiT2RhYmVyaXRlIHNsaWt1XCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJQb3N0YXZsamFuamUgcHJpbGFnb8SRZW5vZyBVUkwtYVwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiVW1ldG5pIHNsaWt1XCIsXG5cdFwiRVJST1JcIjogXCJHcmXFoWthXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiUG9ncmXFoWthIHByaSBwcmlqZW5vc3VcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiS2FtZXJhIG90a2F6YW5hXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlBvc3RhdmkgVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkRpcmVrdG5pIHdlYiBsaW5rIG5hIHNsaWt1XCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJLb21lbnRhciBqZSBwb3NsYW4hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJCcmlzYW5qZSBrb21lbnRhcmEgamUgbmVwb3ZyYXRuby4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIkl6YnJpc2FuaSBrb21lbnRhclwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiVcSNaXRhdmFuamUgc2xpa2VcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiVcSNaXRhdmFuamUgemF2csWhZW5vXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIk5ldXNwamXFoWFuIHByaWplbm9zXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiUG9ncmXFoW5vIGtvcmlzbmnEjWtvIGltZSBpbGkgbG96aW5rYVwiLFxuXHRcIklORk9cIjogXCJJbmZvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBvc3RhdmkgUVIga29kIHVudXRhciBwb2RydcSNamEgc2tlbmlyYW5qYVwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIlByb3ZqZXJpdGUgaW1hdGUgbGkgZG92b2xqbm8gc3JlZHN0YXZhIHphIHRyYW5zYWtjaWp1IVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJLb3Jpc25payBrb2plbSDFvmVsaXRlIHBvc2xhdGkgc3JlZHN0dmEgbmUgcG9zdG9qaSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiSmVzdGUgbGkgc2lndXJuaSBkYSDFvmVsaXRlIG9iYXZpdGkgdHJhbnNha2NpanU/XCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwiUG90dnJkYVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbmtzYWNpamEgamUgcHJvdmVkZW5hXCIsXG5cdFwiRkVFRFwiOiBcIk5vdm9zdGlcIixcblx0XCJUUkVORElOR1wiOiBcIlBvcHVsYXJub1wiLFxuXHRcIkhPVFwiOiBcIkFrdHVhbG5vXCIsXG5cdFwiTkVXXCI6IFwiTm92b1wiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvbW92aXJhbm9cIixcblx0XCJWT1RFU1wiOiBcIkdsYXNvdmlcIixcblx0XCJQQVlPVVRcIjogXCJJc3BsYXRhXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJLb21lbnRhcmlcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlBvcHVsYXJubyB6YWRuamloIDMwIGRhbmFcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJSYXNwb3JlZGkgcG9zdG92ZSBwbzpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJJc3BsYXRuaSBjaWtsdXNcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiTW9ndcSHYSBpc3BsYXRhXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJQcm/FoWxhIGlzcGxhdGFcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiQXV0b3Jza2EgaXNwbGF0YVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkt1cmFjaWpza2EgaXNwbGF0YVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiT2JqYXZhIGplIG9iamF2bGplbmEhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIk9iamF2YSB6YSBvYmphdmxqaXZhbmplIGthc25pamUhXCIsXG5cdFwiU0FWRURcIjogXCJTcHJlbWxqZW5vXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkl6YnJpc2Fub1wiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJQcmlqYXZhIG9iamF2ZSBtb8W+ZSBtYWtudXRpIG5hZ3JhZGUgaSB1xI1pbml0aSBuamVuIHNhZHLFvmFqIG1hbmplIHZpZGxqaXYuPGJyPjxicj5QcmlqYXZhIGJpIHNlIHRyZWJhbGEga29yaXN0aXRpIHphOjx1bD48bGk+UHJldmFyZSBpIHBsYWdpamF0ZTwvbGk+PGxpPkdvdm9yIG1yxb5uamUgaWxpIHByb3ZvY2lyYW5qZTwvbGk+PGxpPnBvZ3JlxaFuPC91bD48L3VsPm8ga2F0ZWdvcml6aXJhbmkgc2FkcsW+YWogaWxpIHNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTmVtYSBzYWRyxb5hamEuIFBvZ2xlZGFqdGUgZHJ1Z2Ugc3RyYW5pY2UvdGFnb3ZlIVwiLFxuXHRcIlBPU1RfSVNfVU5CT09LTUFSS1wiOiBcIk9iamF2YSBqZSBpemJyaXNhbmEgaXogb3puYWthIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJPYmphdmEgamUgZG9kYW5hIHUgb3puYWtlIVwiLFxuXHRcIlJFU0VUXCI6IFwiUmVzZXRpcmFqXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJQcm9taWplbmkgc2xpa3UgcHJvZmlsYVwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiUHJvbWlqZW5pIG5hc2xvdm51IHNsaWt1XCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiTW9saW1vIHVuZXNpdGUgYWt0aXZuaSBrbGp1xI0gYWtvIHN0ZSBvZGFicmFsaSBuYXByZWRuaSBuYcSNaW4gbG9naXJhbmphIVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIk92byDEh2UgcmVzZXRpcmF0aSBrb3Jpc25pxI1rdSBwcm9maWxudSBzbGlrdVwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIk92byDEh2UgcmVzZXRpcmF0aSBrb3Jpc25pxI1rdSBuYXNsb3ZudSBzbGlrdVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiQcW+dXJpcmFuamUgc2VydmVyYSB6YWh0amV2YSBSZXN0YXJ0IVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJQb3N0YXZrZSBzdSBhxb51cmlyYW5lIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkplemljaVwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiT3ZkamUgbW/FvmV0ZSBwcm9taWplbml0aSBqZXppayBhcGxpa2FjaWplLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJPdmFqIHBvc3R1cGFrIHphaHRqZXZhIGRhIGtvcmlzbmlrIGJ1ZGUgcHJpamF2bGplbiBzYSBnbGF2bm9tIGxvemlua29tLCBha3Rpdm5pbS9rbGp1xI1lbSB6YSBvYmphdmUuIE1vbGltbyBwcmlqYXZpdGUgc2UgaSBwb2t1xaFhanRlIHBvbm92by5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXJpamFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJQcmV2ZWxpIGkgcHJpbGFnb2RpbGk6XCIsXG5cdFwiU0hBUkVcIjogXCJQb2RpamVsaVwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiVHJnb3ZpbmFcIixcblx0XCJFWENIQU5HRVwiOiBcIkJ1cnphXCIsXG5cdFwiRFJBRlRTXCI6IFwiU2tpY2VcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJPYmphdmEgamUgbWFrbnV0YSBpeiBza2ljYSFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiT2JqYXZhIGplIGRvZGFuYSB1IHNraWNlIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJQb3Z1Y2kgdSBsaWpldm8gemEgdmlkamV0aSBvcGNpamVcIixcblx0XCJNQU5BR0VcIjogXCJVcHJhdmxqYW5qZVwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJTbGlrYSBqZSB1a2xvbmplbmFcIixcblx0XCJDT1BZXCI6IFwiS29waXJhalwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiSm/FoSBuaXN0ZSBwb3N0YXZpbGkgbmlqZWRudSBzbGlrdSFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlBvdnVjaXRlIGRvbGplIHphIG9zdmplxb5hdmFuamVcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiVmFuanNrZSBhcGxpa2FjaWplXCIsXG5cdFwiUExVR0lOU1wiOiBcIkRvZGF0Y2lcIixcblx0XCJTVUdHRVNUXCI6IFwiUHJlZGxvxb5pXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJVc2tvcm8gZG9sYXppXCIsXG5cdFwiQ0hBSU5cIjogXCJMYW5hY1wiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJPdmRqZSBtb8W+ZXRlIHByb21pamVuaXRpIGJsb2NrY2hhaW4gaWxpIHphZGFudSBwbGF0Zm9ybXUuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJWYWx1dGFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiT3ZkamUgbW/FvmV6ZSBwcm9taWplbml0aSB2YcWhdSB6YWRhbnUgdmFsdXR1LiBOYWdyYWRlIG5hIG9iamF2YW1hIGkga29tZW50YXJpbWEgxIdlIHZhbSBiaXRpIHByaWthemFuZSB1IG92b2ogdmFsdXRpLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIG1vZ3XEh25vc3RpPC9iPjxicj4tUHJpc3R1cGl0ZSBiaWxvIGtvam9qIG9iamF2aSB1IGJpbG8ga29qb2ogdGVtaSBrb2phIHZhcyB6YW5pbWEuPGJyPlVrbGp1xI1pdGUgc2Ugc2EgYXV0b3JpbWEgcyBrb21lbnRpcmFuamVtIGkgcmFzcHJhdmxqYW5qZW0gbyB0ZW1hbWEuPGJyPi1HbGFzdWp0ZSB6YSBvYmphdmUgdGFrbyBkYSBuYWdyYWRpdGUgYXV0b3JhIGkgZGEgemFyYWRpdGUgbmEga3VyYWNpamFtYS48YnI+LU9iamF2aXRlIHZhxaFlIMSNbGFua2Usb2JqYXZlIGJlc3BsYXRubyBpIHphcmFkaXRlIG5hZ3JhZGUgcyBwcml2bGHEjWVuamVtIGkgZG9iaXZhbmplbSBwcmF0aXRlbGphLjxicj4tUGnFoWl0ZSDEjWxhbmtlIHphIHB1dHUsIHNwcmVtaXRlIHZpxaFlIHNraWNhIHphIGthc25panUgb2JqYXZ1Ljxicj4tT3puYcSNaSBuYWpkcmHFvmUgxI1sYW5rZSB6YSBwcm/EjWl0YXRpIGthc25pamUuPGJyPi1SYXptamVuaSBpbGkgaXNwbGF0aSBzdm9qdSB6YXJhZHUuPGJyPi1Qb8WhYWxqaXRlIHZhxaFhIHNyZWRzdHZhIGJpbG8ga29qZW0gYXV0b3J1IGlsaSBrb3Jpc25pa3UsIHByaWphdGVsanUsIHByYXRpdGVsanUsIGl0ZC48YnI+LVByYXRpIHphbmltbGppdmUgYXV0b3JlLCBibG9nZXJlLjxicj4tUHJldHJhxb5pIHN2b2plIHByYXRpdGVsamUgaSBhdXRvcmUga29qZSBwcmF0aXRlLjxicj4tRG9iaXZhanRlIG9iYXZpamVzdGkgZGEgYmkgc3RlIG9zdGFsaSB1IGtvbnRha3R1IHNhIHN2b2ppbSBwcmF0aXRlbGppbWEgaSByYXNwcmF2YW1hIHUga29qaW1hIHN0ZSB1a2xqdcSNZW5pLjxicj4tUHJldHJhxb5pdGUgemFuaW1saml2ZSB0YWdvdmUva2F0ZWdvcmlqZSDEjWxhbmFrYSwgYXV0b3JhLjxicj5QZXJzb25hbGl6aXJhanRlIHZhxaEgcHJvZmlsLjxicj4tSm/FoSBwdW5vIG5vdm9zdGkgc3Rpxb5lLjxicj48YnI+PGI+U2lndXJub3N0PC9iPjxicj4xLkFwbGlrYWNpamEgbmlrYWQgbmUgcHJpc3R1cGEgaWxpIHphZHLFvmF2YSBuYSBrb3Jpc25pxI1raW0gc3JlZHN0dmltYS48YnI+Mi5BcGxpa2FjaWphIG51ZGkgc2lndXJub3NuaSBtb2RlbCBuYSBzdHJhbmkga2xpamVudGEsIHMgcHJpdmF0bmltIGtsanXEjWV2aW1hIHBvaHJhbmplbmltYSBsb2thbG5vIGkgbmlrYWQgc2UgbmUgxaFhbGp1IG5hIHNlcnZlciwgdmkgc3RlIG9kZ292b3JuaSB6YSDEjXV2YW5qZSB2YcWhaWggbG96aW5raS48YnI+My4gQXBsaWthY2lqYSBudWRpIGplZG5vc3RhdmFubywgYXRyYWt0aXZhbm8ga29yaXNuacSNa28gc3XEjWVsamUgaSBkb8W+aXZsamFqPGJyPjQuQXBsaWthY2lqYSBudWRpIGRvZGF0YW4gc2xvaiB6YcWhdGl0ZSBzYSBQSU4ga29kb208YnI+PGJyPmVTdGVlbSBwb2Ryxb5hdmEgU3RlZW0gaSBHb2xvcyBwbGF0Zm9ybWUuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJPc25pdmHEjSBpIGdsYXZuaSBwcm9ncmFtZXJcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIkRvZGFqIHJhxI11blwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1hXCIsXG5cdFwiRVNDUk9XXCI6IFwiRXNjcm93XCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93IGFnZW50XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUm9rIHBvdHZyxJFpdmFuamFcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyBpc3Rla1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgaG9ub3JhclwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIkVzY3JvdyB1dmpldGlcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTm/Eh25pIG5hxI1pblwiLFxuXHRcIkRBWV9NT0RFXCI6IFwiRG5ldm5pIG5hxI1pblwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIlBvZ2xlZGFqIGNpamVsaSBzYWRyxb5halwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJLb3Jpc25payBuaWplIHByb25hxJFlblwiLFxuXHRcIkFQUFJPVkVcIjogXCJEb3p2b2xpXCIsXG5cdFwiRElTUFVURVwiOiBcIlJhc3ByYXZpXCIsXG5cdFwiUkVMRUFTRVwiOiBcIkl6ZGFuamVcIixcblx0XCJGUk9NXCI6IFwiT2RcIixcblx0XCJJRFwiOiBcImlkXCIsXG5cdFwiU1VCTUlUXCI6IFwiT2JqYXZpXCIsXG5cdFwiUkVDRUlWRVJcIjogXCJQcmltYXRlbGpcIixcblx0XCJMT0NBVElPTlwiOiBcIkxva2FjaWphXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYiBzdHJhbmljYVwiLFxuXHRcIkRJU1BMQVlfTkFNRVwiOiBcIlByaWthemFuaSBuYXppdlwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJLZXpkxZFsYXBcIixcblx0XCJMT0dJTlwiOiBcIkJlamVsZW50a2V6w6lzXCIsXG5cdFwiTE9HT1VUXCI6IFwiS2lqZWxlbnRrZXrDqXNcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiS8O2dmV0w6lzXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiS8O2bnl2amVsesWRa1wiLFxuXHRcIlRSQU5TRkVSXCI6IFwiw4F0dXRhbMOhc1wiLFxuXHRcIk1BUktFVFwiOiBcIlBpYWNcIixcblx0XCJTRVRUSU5HU1wiOiBcIkJlw6FsbMOtdMOhc29rXCIsXG5cdFwiQUJPVVRcIjogXCJSw7NsdW5rXCIsXG5cdFwiQUJPVVRfMVwiOiBcImFob2wgYsOhcmtpIGthcGhhdCBqdXRhbG1ha2F0IGEgdGFydGFsbWFpw6lydCFcIixcblx0XCJBQk9VVF8yXCI6IFwiYSB7e3BsYXRmb3JtbmFtZX19IHBsYXRmb3JtIMO8emVtZWx0ZXRpLiBBeiBhbGthbG1hesOhcyBrw6lzesOtdMWRamVcIixcblx0XCJBQk9VVF8zXCI6IFwiw6lzIG55w61sdCBmb3Jyw6Fza8OzZMO6LCBrw7Z6w7Zzc8OpZyDDoWx0YWwgbcWxa8O2ZHRldGV0dCBwcm9qZWt0LiBUw6Ftb2dhdGphIGEgdGFydGFsb21ob3p6w6Fmw6lyw6lzdCBvbHZhc8Ohc8OpcnQsIGEgaG96esOhc3rDs2zDoXN0LCBzemF2YXrDoXN0LCBwb3N6dG9sw6FzdCwgZml6ZXRzw6lnIMOhdHV0YWzDoXPDoXQsIHN0Yi4gZnVua2Npw7NrYXQsIGFtaWtldCBhIHt7cGxhdGZvcm1uYW1lfX0gYmxva2tsw6FuYyDDqXMgYSB7e3NpdGVuYW1lfX0ga8OtbsOhbG5hay5cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gQXogYWxrYWxtYXrDoXMgc29oYSBuZW0gZsOpciBob3p6w6EgdmFneSB0w6Fyb2xqYSBhIGZlbGhhc3puw6Fsw7NrIHDDqW56w6l0LlwiLFxuXHRcIkFCT1VUXzVcIjogXCIyLiBBeiBhbGthbG1hesOhcyBrbGllbnMgb2xkYWxpIGJpenRvbnPDoWdpIG1vZGVsbHQga8OtbsOhbCwgYSBwcml2w6F0IGt1bGNzb2sgaGVseWJlbmkgdMOhcm9sw6Fzw6F2YWwsIGFtaWsgc29oYSBuZW0ga2Vyw7xsbmVrIGVsa8O8bGTDqXNyZSBzZW1taWx5ZW4gc3plcnZlcnJlLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBeiBhbGthbG1hesOhcyBlZ3lzemVyxbEsIHRldHN6ZXTFkXMgZmVsaGFzem7DoWzDs2kgZmVsw7xsZXRldCDDqXMgLcOpbG3DqW55dCBuecO6anQuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIEF6IGFsa2FsbWF6w6FzIHNvaGEgbmVtIGvDqXJpIGEgZmVsaGFzem7DoWzDs2thdCBhIHN6ZW3DqWx5ZXMgYWRhdGFpayBtZWdhZMOhc8OhcmEuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlN6YXZhenogZ29vZC1rYXJtYSAtcmEgbWludCB0YW7DulwiLFxuXHRcIkFCT1VUXzlcIjogXCJLYXBjc29sYXQvVmlzc3phamVsesOpczpcIixcblx0XCJBQk9VVF8xMFwiOiBcIlTDtmJiIGluZsOzOlwiLFxuXHRcIlJFTU9WRVwiOiBcIkVsdMOhdm9sw610w6FzXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJQaWFjIE7DqXpldFwiLFxuXHRcIlBSSUNFXCI6IFwiw4FyXCIsXG5cdFwiQU1PVU5UXCI6IFwiw5Zzc3plZ1wiLFxuXHRcIlRPVEFMXCI6IFwiw5Zzc3plc2VuXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJOaW5jcyBueWl0b3R0IG1lZ2LDrXrDoXNcIixcblx0XCJEQVRFXCI6IFwiRMOhdHVtXCIsXG5cdFwiQlVZXCI6IFwiVsOpdGVsXCIsXG5cdFwiU0VMTFwiOiBcIkVsYWTDoXNcIixcblx0XCJPUEVOXCI6IFwiTnlpdMOhc1wiLFxuXHRcIkhJU1RPUllcIjogXCJUw7ZydMOpbmV0XCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJWaXNzemFrw7Z2ZXTDqXNcIixcblx0XCJGT0xMT1dFRFwiOiBcIkvDtnZldHZlXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJLw7Z2ZXTDqXMgbWVnc3rDvG50ZXTDqXNlXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiS8O2dmV0ZXR0ZWtcIixcblx0XCJGT0xMT1dFUlNcIjogXCJLw7Z2ZXTFkWtcIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwiS8O2dmV0xZFrIGtlcmVzw6lzZVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJLw7Z2ZXRldHRlayBrZXJlc8Opc2VcIixcblx0XCJCWVwiOiBcIsOhbHRhbFwiLFxuXHRcIklOXCI6IFwiaXR0OlwiLFxuXHRcIk1FTlVcIjogXCJNZW7DvFwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiS8O2bnl2amVsesWRa1wiLFxuXHRcIlJFQkxPR1wiOiBcIsOaanJhYmxvZ29sw6FzXCIsXG5cdFwiVVBWT1RFXCI6IFwiRmVsc3phdmF6w6FzXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJMZXN6YXZhesOhc1wiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJMZXN6YXZhesOhcyBlbHTDoXZvbMOtdMOhc2FcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIkZlbHN6YXZhesOhcyBlbHTDoXZvbMOtdMOhc2FcIixcblx0XCJSRVBMWVwiOiBcIlbDoWxhc3pcIixcblx0XCJFRElUXCI6IFwiU3plcmtlc3p0w6lzXCIsXG5cdFwiUE9TVF8xXCI6IFwiQ3PDunN6dGFzcyBiYWxyYSBhIGhvenrDoXN6w7Nsw6Fzb2tvbiwgaG9neSBsw6FzZCBheiBvcGNpw7NrYXRcIixcblx0XCJQT1NUXzJcIjogXCJLb3BwaW50cyBhIGhvenrDoXN6w7Nsw6Fzb2tvbiwgaG9neSBsw6FzZCBheiBhbC1ob3p6w6FzesOzbMOhc29rYXRcIixcblx0XCJPUFRJT05TXCI6IFwiT3BjacOza1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIsOaanJhb3N6dHZhIMOhbHRhbGE6XCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiU2VtbWkgc2luY3MgaXR0IG3DqWcuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIkVneWVubGVnZWtcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBlbGFkaGF0w7MgdG9rZW5laywgYW1lbHlla2V0IMOhdCBsZWhldCB1dGFsbmkgYsOhcm1pa29yLlxcbnt7cGxhdGZvcm1uYW1lfX0ga29udmVydMOhbGhhdMOzIHt7cGxhdGZvcm1wb3dlcn19IC3DqSBlZ3kgZm9seWFtYXRiYW4sIGFtaXQgZmVsdMO2bHTDqXNuZWsgbmV2ZXrDvG5rLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBiZWZvbHnDoXNvbMOzIHRva2VuZWssIGFtaWsgdMO2YmIgZXLFkXQga2FwbmFrIGEgaG9zc3rDuiB0w6F2w7ogYmlydG9rbMOhc3Vrw6lydCDDqXMgYSBwb3N6dG9rIGZlbHN6YXZhesOhc8Ohw6lydC4gTWluw6lsIHTDtmJiZXQgYmlydG9rb2wgYmVsxZFsZSB2YWxha2ksIGFubsOhbCBqb2JiYW4gdHVkamEgYmVmb2x5w6Fzb2xuaSBtw6Fzb2sganV0YWxtYWl0IMOpcyBrYXAgdMO2YmIganV0YWxtYXQgYXogYWxhcG9zIHN6YXZhesOhc8OpcnQuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW5laywgYW1payBrw7Zyw7xsYmVsw7xsIHt7cGxhdGZvcm1zdW5pdH19IC1ueWkge3twbGF0Zm9ybW5hbWV9fSAtZXQgw6lybmVrLlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkJlY3PDvGx0IMOJcnTDqWtcIixcblx0XCJQUk9GSUxFXzRcIjogXCJBIGJlY3PDvGx0IMOpcnTDqWsgYSB7e3BsYXRmb3JtbmFtZX19IDcgbmFwb3Mgw6F0bGFnb3Mgw6lydMOpa8OpbiBhbGFwc3ppay5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiw4F0dXRhbMOhcyBUw7ZydMOpbmV0XCIsXG5cdFwiUE9TVElOR1wiOiBcIlBvc3p0b2zDoXNcIixcblx0XCJQUk9GSUxFXzVcIjogXCJBIHBvc3p0b2zDsyBrdWxjcyBwb3N6dG9sw6FzcmEgw6lzIHN6YXZhesOhc3JhIGhhc3puw6FsYXRvcy4gS8O8bMO2bmLDtnrFkW5layBrZWxsIGxlbm5pZSBheiBha3TDrXYgw6lzIGEgdHVsYWpkb25vc2kga3VsY3Nva3TDs2wuXCIsXG5cdFwiT1dORVJcIjogXCJUdWxhamRvbm9zXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiQSB0dWxhamRvbm9zIGt1bGNzIGVneSBtZXN0ZXJrdWxjcyBhIHN6w6FtbMOhaG96IMOpcyBrw7Z0ZWxlesWRIGEgdMO2YmJpIGt1bGNzIG1lZ3bDoWx0b3p0YXTDoXPDoWhvei4gQSB0dWxhamRvbm9zaSBrdWxjcyBwcml2w6F0IGt1bGNzw6F0IHZhZ3kgamVsc3phdsOhdCB0aXRva2JhbiDDqXMgb2ZmbGluZSBrZWxsIHRhcnRhbmksIGFtZW5ueWlyZSBjc2FrIGxlaGV0c8OpZ2VzLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFrdMOtdlwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkF6IGFrdMOtdiBrdWxjcyBoYXN6bsOhbGF0b3MgYXogw6F0dXRhbMOhc29rIGluZMOtdMOhc8OhaG96IMOpcyBhIG1lZ2LDrXrDoXNvayBiZWplZ3l6w6lzw6loZXogYSBiZWxzxZEgcGlhY29uLlwiLFxuXHRcIk1FTU9cIjogXCJGZWxqZWd5esOpc1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkEgZmVsamVneXrDqXMga3VsY3MgaGFzem7DoWxhdG9zIGZlbGplZ3l6w6lzZWsga8Opc3rDrXTDqXPDqXJlIMOpcyBvbHZhc8Ohc8OhcmEuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIlBvc3p0b2tcIixcblx0XCJSRVBMSUVTXCI6IFwiVsOhbGFzem9rXCIsXG5cdFwiV0FMTEVUXCI6IFwiVMOhcmNhXCIsXG5cdFwiVEFHXCI6IFwiQ8OtbWtlXCIsXG5cdFwiVVNFUlwiOiBcIkZlbGhhc3puw6Fsw7NcIixcblx0XCJDTE9TRVwiOiBcIkJlesOhclwiLFxuXHRcIlRPXCI6IFwiTmVraVwiLFxuXHRcIkFTU0VUXCI6IFwiVmFneW9udMOhcmd5XCIsXG5cdFwiU0VORFwiOiBcIkvDvGxkXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJCaXp0b25zw6FnXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiUmVuZGVsa2V6w6lzcmUgw6FsbFwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTnlpbHbDoW5vcyBmZWxqZWd5esOpc1wiLFxuXHRcIlRPX0RFU0NcIjogXCJGZWxoYXN6bsOhbMOzLCBwbC4gZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiUElOLWvDs2RcIixcblx0XCJQSU5fVEVYVFwiOiBcIkEgUElOLWvDs2Qgc2Vnw610IGhvZ3kgbWVnw7N2ZCBheiBhbGthbG1hesOhc29kIMOpcyBheiBhZGF0YWlkLiA8YnIvPjxici8+PGI+TWVnamVneXrDqXM6PC9iPiBNaXV0w6FuIGFsa2FsbWF6dmEgdmFuLCBtYXguIDQgcHLDs2LDoWxrb3rDoXNpIGxlaGV0xZFzw6lnZWQgdmFuIGhvZ3kgZmVsbnlpc2Q7IGhhIGVsZmVsZWp0ZWQgYSBQSU4tdCB2YWd5IGhpYsOhem9sLCBheiBhbGthbG1hesOhcyBlbCBmb2dqYSB0w6F2b2zDrXRhbmkgbWluZGVuIGJlamVsZW50a2V6ZXR0IGZlbGhhc3puw6Fsw7NpIGFkYXRvdC4gVmlzc3phIHR1ZHN6IGplbGVudGtlem5pIMOpcyBmb2x5dGF0aGF0b2QgYXogYWxrYWxtYXrDoXMgaGFzem7DoWxhdMOhdC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiw4lydGVzw610w6lzZWtcIixcblx0XCJWT1RFX1RFWFRcIjogXCLDiXJ0ZXPDrXTDqXNla2V0IGthcHN6LCBhbWlrb3IgdmFsYWtpIHN6YXZheiBhIGJlamVneXrDqXNlZHJlISBici8+IDxiPk1lZ2plZ3l6w6lzOjwvYj4gQXogw6lydGVzw610w6lzZWsgdGFydGFsbWF6esOhayBhIHN6YXZhesOhcyBzw7pseW96w6Fzw6F0IGEgZmlneWVsbWV6dGV0xZEgw7x6ZW5ldGJlbiBpcyAoTGVneWVuIGF6IGZlbHN6YXZhesOhcywgbGVzemF2YXrDoXMgdmFneSBzemF2YXphdCB2aXNzemF2b27DoXNhKS5cIixcblx0XCJWT1RFXCI6IFwiU3phdmF6w6FzXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiw4lydGVzw610w6lzdCBrYXBzeiBoYSB2YWxha2kgaG96esOhc3rDs2wgYSBwb3N6dG9kaG96IHZhZ3kgYSBob3p6w6FzesOzbMOhc29kaG96ISA8YnIvPiA8Yj5NZWdqZWd5esOpczo8L2I+IEF6IMOpcnRlc8OtdMOpc2VrIHRhcnRhbG1henrDoWsgYXp0IGlzLCBhbWlrb3IgdmFsYWtpIDxiPnN6ZXJrZXN6dGk8L2I+IGEgaG96esOhc3rDs2zDoXNhaXQuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIkhvenrDoXN6w7Nsw6FzXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLDiXJ0ZXPDrXTDqXN0IGthcHN6LCBhbWlrb3IgdmFsYWtpIEvDtnZldCB0w6lnZWQgdmFneSBWaXNzemF2b25qYSBhIGvDtnZldMOpc3QhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJFbWzDrXTDqXNla1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLDiXJ0ZXPDrXTDqXNla2V0IGthcHN6LCBhbWlrb3IgdmFsYWtpIG1lZ2VtbMOtdCB0w6lnZWQgZWd5IHBvc3p0YmFuL2hvenrDoXN6w7Nsw6FzYmFuIVwiLFxuXHRcIlJFU1RFRU1cIjogXCLDmmpyYWJsb2dvbMOhc1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIsOJcnRlc8OtdMOpc3Qga2Fwc3osIGFtaWtvciB2YWxha2kgcmVzdGVlbWVsaSBhIHBvc3p0b2RhdCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIktvbmZpZ3Vyw6FjacOzXCIsXG5cdFwiVk9USU5HXCI6IFwiU3phdmF6w6FzXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJBIHN6YXZhemF0IHPDumx5b3rDoXNhIHZhZ3kgc3rDoXphbMOpa2EgYSBzemF2YXphdGkgZXLFkXJlIHZhbiBraWhhdMOhc3NhbCBheiBhbGthbG1hesOhc2Jhbiwgw61neSBzemFiw6FseW96bmkgdHVkb2QgYSBzemF2YXrDoXNpIGp1dGFsbWFpZC4gPGJyLz48YnIvPjxiPk1lZ2plZ3l6w6lzOjwvYj4gRXogYSBsZXN6YXZhesOhcyBzemF2YXphdGkgZXJlasOpdC9zesOhemFsw6lrw6F0IGlzIG1lZyBmb2dqYSB2w6FsdG96dGF0bmkgw6lzIG1pbmRlbsO8dHQgw6lydsOpbnllcyBheiBhbGthbG1hesOhc29uIGJlbMO8bC5cIixcblx0XCJTRVJWRVJcIjogXCJTemVydmVyXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCJBasOhbmxvdHRcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJWw6FsdG96dGF0w6Fzb2sgTWVudMOpc2VcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkluZsOzIGEgc3phdmF6w7NrcsOzbFwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIsOcZHYgw7pqcmEhXCIsXG5cdFwiTE9HSU5fMVwiOiBcIkEgZm9seXRhdMOhc2hveiBqZWxlbnRrZXp6IGJlIGEgZmVsaGFzem7DoWzDs25ldmVkZGVsIMOpcyBqZWxzemF2YWRkYWwuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkEgcG9zenRvbMOzIGt1bGNzIGEgcG9zenRva2hveiwgaG96esOhc3rDs2zDoXNva2hveiwgc3phdmF6w6FzaG96IMOpcyBrw7Z2ZXTDqXNoZXogaGFzem7DoWxhdG9zLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBeiBha3TDrXYga3VsY3MgYXogdXRhbMOhc29raG96IMOpcyBhIHByb2ZpbGvDqXAgZnJpc3PDrXTDqXPDqWhleiBoYXN6bsOhbGF0b3MuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkEgZmVsaGFzem7DoWzDsyBiZWplbGVudGtlesOpc2kgYWRhdGFpIGhlbHlpbGVnIHZhbm5hayB0w6Fyb2x2YSBhIGvDqXN6w7xsw6lrZW4uIEtpamVsZW50a2V6w6lza29yIGEgYmVqZWxlbnRrZXrDqXNpIGFkYXRvayBlbHTDoXZvbMOtdMOzZG5hayFcIixcblx0XCJET05UX0hBVkVcIjogXCJOaW5jcyBtw6lnIGZpw7Nrb2Q/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJSZWdpc3p0csOhbGogbW9zdFwiLFxuXHRcIkNBTkNFTFwiOiBcIk3DqWdzZVwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiSGFsYWTDs1wiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJBa3TDrXYgcHJpdsOhdCBrdWxjc1wiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUG9zenRvbMOzIHByaXbDoXQga3VsY3NcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIk1lc3Rlci9mxZEgamVsc3rDs1wiLFxuXHRcIlVTRVJOQU1FXCI6IFwiRmVsaGFzem7DoWzDs27DqXZcIixcblx0XCJDQVJEX1ZJRVdcIjogXCJLw6FydHlhIG7DqXpldFwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIktvbXBha3QgbsOpemV0XCIsXG5cdFwiU0VBUkNIXCI6IFwiS2VyZXPDqXNcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIkNpa2sgYmVrw7xsZMOpc2VcIixcblx0XCJSRVBMWVRPXCI6IFwiVsOhbGFzeiBuZWtpXCIsXG5cdFwiUE9TVFwiOiBcIlBvc3p0XCIsXG5cdFwiUFJFVklFV1wiOiBcIkVsxZFuw6l6ZXRcIixcblx0XCJERUZBVUxUXCI6IFwiQWxhcMOpcnRlbG1lemV0dCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiRmVsdMO2bHTDqXMgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiS2lmaXpldMOpcyBFbHV0YXPDrXTDoXNhXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJNRU5Uw4lTIEvDiVPFkEJCUkVcIixcblx0XCJDTEVBUlwiOiBcIlTDllJMw4lTXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiVGFydGFsb20gcG9zenRvbMOhc2FcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJIb3p6w6FzesOzbMOhcyB0YXJ0YWxvbWhvelwiLFxuXHRcIlRJVExFXCI6IFwiQ8OtbVwiLFxuXHRcIlRBR1NcIjogXCJDw61ta8Opa1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk5FTSBJTExJSyDDllNTWkVcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIlBJTiBtZWdlcsWRc8OtdMOpc2VcIixcblx0XCJJTkNPUlJFQ1RcIjogXCJORU0gTUVHRkVMRUzFkFwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIm55aXTDsyBwb3N6dFwiLFxuXHRcIlNFVF9QSU5cIjogXCJQSU4gYmXDoWxsw610w6FzYVwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIlBJTiBtZWdhZMOhc2FcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJCaXp0b3MgdmFneSBiZW5uZT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIkEgcmVzdGVlbSB2aXNzemF2b25oYXRhdGxhbiwgYml6dG9zIHZhZ3kgYmVubmU/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiVGVyamVzenTDqXNpIGhpYmEsIHByw7Niw6FsZCDDumpyYS5cIixcblx0XCJTVUNDRVNTXCI6IFwiU2lrZXJcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIsOaanJhYmxvZ29sdCBwb3N6dCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwiQSBiZWzDqXDDqXMgbmVtIHNpa2Vyw7xsdCEgS8OpcmxlayBnecWResWRZGogbWVnIHLDs2xhLCBob2d5IGEgbWVzdGVyamVsc3phdmFkZGFsIGzDqXB0w6lsIGJlIHZhZ3kgbWVnYWR0YWQgYSBQb3N6dG9sw7MgcHJpdsOhdCBrdWxjc290LCBoYSBhIEhhbGFkw7MgbcOzZG90IHbDoWxhc3p0b3R0YWQgQmVqZWxlbnRrZXrDqXNrb3IuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiQSBiZWzDqXDDqXMgbmVtIHNpa2Vyw7xsdCEgS8OpcmxlayBnecWResWRZGogbWVnIHLDs2xhLCBob2d5IGEgbWVzdGVyamVsc3phdmFkZGFsIGzDqXB0w6lsIGJlIHZhZ3kgbWVnYWR0YWQgYXogQWt0w612IHByaXbDoXQga3VsY3NvdCwgaGEgYSBIYWxhZMOzIG3Ds2RvdCB2w6FsYXN6dG90dGFkIEJlamVsZW50a2V6w6lza29yLlwiLFxuXHRcIldBUk5JTkdcIjogXCJGaWd5ZWxtZXp0ZXTDqXNcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiU3phdmF6w6FzIHRhbsO6cmFcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlN6YXZhenTDoWwgdGFuw7pyYVwiLFxuXHRcIkFHT1wiOiBcIsOzdGFcIixcblx0XCJGUk9NX05PV1wiOiBcIm1vc3RhbnTDs2xcIixcblx0XCJTRUNTXCI6IFwibcOhc29kcGVyY1wiLFxuXHRcIkFfTUlOXCI6IFwiZWd5IHBlcmNcIixcblx0XCJNSU5TXCI6IFwicGVyY2VrXCIsXG5cdFwiQU5fSE9VUlwiOiBcImVneSDDs3JhXCIsXG5cdFwiSE9VUlNcIjogXCLDs3JhXCIsXG5cdFwiQV9EQVlcIjogXCJlZ3kgbmFwXCIsXG5cdFwiREFZU1wiOiBcIm5hcG9rXCIsXG5cdFwiQV9NT05USFwiOiBcImVneSBow7NuYXBcIixcblx0XCJNT05USFNcIjogXCJow7NuYXBva1wiLFxuXHRcIkFfWUVBUlwiOiBcImVneSDDqXZcIixcblx0XCJZRUFSU1wiOiBcIsOpdmVrXCIsXG5cdFwiTUlOX1JFQURcIjogXCJwZXJjIG9sdmFzw6FzXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIkxlc3phdmF6w6FzIHZhZ3kgSmVsZW50w6lzXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiS8OpcCBLw6lzesOtdMOpc1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiS8OpcCBLaXbDoWxhc3p0w6FzXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJFZ3llZGkgVVJMIEJlw6FsbMOtdMOhc1wiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiS8OpcCBCZWlsbGVzenTDqXNcIixcblx0XCJFUlJPUlwiOiBcIkhpYmFcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJGZWx0w7ZsdMOpc2kgSGliYVwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJLYW1lcmEgVMO2csO2bHZlXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlVSTCBiZcOhbGzDrXTDoXNcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWt0IHdlYiBsaW5rIGEga8OpcGhlelwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiQSBob3rDoXN6w7Nsw6FzIGVsa8O8bGR2ZSFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkEgaG96esOhc3rDs2zDoXNvayB0w7ZybMOpc2Ugdmlzc3phdm9uaGF0YXRsYW4uLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJUw7Zyw7ZsdCBob3p6w6FzesOzbMOhc1wiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiS8OpcCBmZWx0w7ZsdMOpc2VcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiRmVsdMO2bHTDqXMgS8Opc3pcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiRmVsdMO2bHTDqXMgTWVnaGnDunN1bHRcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJBIGplbHN6w7MgdmFneSBmZWxoYXN6bsOhbMOzbsOpdiBoaWLDoXMgdm9sdFwiLFxuXHRcIklORk9cIjogXCJJbmbDs1wiLFxuXHRcIlFSX1RFWFRcIjogXCJIZWx5ZXp6IGVneSBRUi1rw7Nkb3QgYSBsZW9sdmFzw6FzaSB0ZXLDvGxldGJlXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiR3nFkXrFkWRqIG1lZyByw7NsYSwgaG9neSBlbGVnZW5kxZEgZWd5ZW5sZWdlZCB2YW4gYXogdXRhbMOhc2hveiFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiQSBmZWxoYXN6bsOhbMOzLCBha2luZWsgdXRhbG5pIHByw7Niw6Fsc3osIG5lbSBsw6l0ZXppayFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiQml6dG9zIHZhZ3kgYmVubmUsIGhvZ3kgdXRhbG5pIGFrYXJzej9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJNZWdlcsWRc8OtdMOpc1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiQSB0cmFuemFrY2nDsyBrw7Z6dmV0w610dmVcIixcblx0XCJGRUVEXCI6IFwiSMOtcmZvbHlhbVwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiTsOpcHN6ZXLFsVwiLFxuXHRcIkhPVFwiOiBcIkZvcnLDs1wiLFxuXHRcIk5FV1wiOiBcIsOaalwiLFxuXHRcIlBST01PVEVEXCI6IFwiVMOhbW9nYXRvdHRcIixcblx0XCJWT1RFU1wiOiBcIlN6YXZhemF0b2tcIixcblx0XCJQQVlPVVRcIjogXCJLaWZpemV0w6lzXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJIb3p6w6FzesOzbMOhc29rXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJOw6lwc3plcsWxIDMwIG5hcHJhXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiUG9zenRvayByZW5kZXrDqXNlOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIktpZml6ZXTDqXNpIENpa2x1c1wiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJMZWhldHPDqWdlcyBLaWZpemV0w6lzXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJSw6lnaSBLaWZpemV0w6lzXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlN6ZXJ6xZFpIEtpZml6ZXTDqXNcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJLdXLDoXRvcmkgS2lmaXpldMOpc1wiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiQSBwb3N6dCBiZWvDvGxkdmUhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlBvc3p0IGvDqXPFkWJiaSBiZWvDvGxkw6lzcmUhXCIsXG5cdFwiU0FWRURcIjogXCJNZW50dmVcIixcblx0XCJDTEVBUkVEXCI6IFwiVMO2csO2bHZlXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkVneSBwb3N6dCBqZWxlbnTDqXNlIGVsIHR1ZGphIHTDoXZvbMOtdGFuaSBhIGp1dGFsbWFrYXQgw6lzIGtldsOpc2LDqSBsw6F0aGF0w7N2w6EgdGVzemkgZXp0IGF6IGFueWFnb3QuPGJyPjxicj5BIGplbGVudMOpc3QgYSBrw7Z2ZXRrZXrFkWtyZSBrZWxsZW5lIGhhc3puw6Fsbmk6IDx1bD48bGk+Q3NhbMOhcyB2YWd5IFBsYWdpesOhbMOhczwvbGk+PGxpPkd5xbFsw7ZsZXQgYmVzesOpZCB2YWd5IEludGVybmV0IFRyb2xsa29kw6FzPC9saT48bGk+VHVkYXRvc2FuIGbDqWxyZWthdGVnb3JpesOhbHQgdGFydGFsb20gdmFneSBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkvDqXLDqXNpIGxpbWl0IGVsw6lydmUuIE7DqXp6IG1lZyBtw6FzIHRyZW5kZXQvY8OtbWvDqXQhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiQSBwb3N6dCBlbHTDoXZvbMOtdHZhIGEga8O2bnl2amVsesWRayBrw7Z6w7xsIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJBIHBvc3p0IGhvenrDoWFkdmEgYSBrw7ZueXZqZWx6xZFraMO2eiFcIixcblx0XCJSRVNFVFwiOiBcIlZpc3N6YcOhbGzDrXTDoXNcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIlByb2ZpbGvDqXAgTcOzZG9zw610w6FzYVwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiQm9yw610w7Nrw6lwIE3Ds2Rvc8OtdMOhc2FcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJLw6lybGVrIGFkZCBtZWcgYXogQWt0w612IHByaXbDoXQga3VsY3NvdCwgaGEgYSBIYWxhZMOzIGJlbMOpcMOpc2kgbcOzZG90IHbDoWxhc3p0b3R0YWQhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiRXogdmlzc3phIGZvZ2phIMOhbGzDrXRhbmkgYSBwcm9maWxrw6lwZXRcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJFeiB2aXNzemEgZm9namEgw6FsbMOtdGFuaSBhIGJvcsOtdMOza8OpcGV0XCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBIHN6ZXJ2ZXIgZnJpc3PDrXTDqXNlIG1lZ2vDtnZldGVsaSBheiDDmmpyYWluZMOtdMOhc3QuXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkJlw6FsbMOtdMOhc29rIGZyaXNzw610dmUhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiTnllbHZla1wiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiSXR0IHR1ZG9kIG1lZ3bDoWx0b3p0YXRuaSBheiBhbGthbG1hesOhcyBueWVsdsOpdC5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiRXogYSBtxbF2ZWxldCBtZWdrw7Z2ZXRlbGksIGhvZ3kgYSBmZWxoYXN6bsOhbMOzIGEgZsWRIGplbHN6YXbDoXZhbCwgYWt0w612L3Bvc3p0b2zDsyBrdWxjc8OhdmFsIGxlZ3llbiBiZWplbGVudGtlenZlLiBLw6lybGVrIGzDqXBqIGJlIMOpcyBwcsOzYsOhbGQgw7pqcmEuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbMOpcmlhXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiQSBmb3Jkw610w6FzIGvDtnpyZW3FsWvDtmTFkWlcIixcblx0XCJTSEFSRVwiOiBcIk1lZ29zenTDoXNcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIlBpYWN0w6lyXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJWw6FsdMOzXCIsXG5cdFwiRFJBRlRTXCI6IFwiUGlzemtvemF0XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiQSBiZWplZ3l6w6lzIGVsdMOhdm9sw610dmEgYSBwaXN6a296YXRva2LDs2whXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIkEgYmVqZWd5esOpcyBob3p6w6FhZHZhIGEgcGlzemtvemF0b2tob3ohXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkNzw7pzenRhc3MgYmFscmEgYXogb3BjacOza8OpcnRcIixcblx0XCJNQU5BR0VcIjogXCJLZXplbMOpc1wiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJLw6lwIHTDtnLDtmx2ZVwiLFxuXHRcIkNPUFlcIjogXCJNw6Fzb2zDoXNcIixcblx0XCJOT19JTUFHRVwiOiBcIk3DqWcgbmVtIHTDtmx0w7Z0dMOpbCBmZWwgc2VtbWlseWVuIGvDqXBldCFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIkjDunpkIGxlIGEgZnJpc3PDrXTDqXNoZXpcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiS8O8bHPFkSBBbGthbG1hesOhc29rXCIsXG5cdFwiUExVR0lOU1wiOiBcIkJlw6lww7xsxZFrXCIsXG5cdFwiU1VHR0VTVFwiOiBcIkphdmFzb2xcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkhhbWFyb3NhbiBtZWdqZWxlbmlrXCIsXG5cdFwiQ0hBSU5cIjogXCJMw6FuY1wiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJJdHQgdHVkc3ogYmxva2tsw6FuY290IHZhZ3kgYWxhcMOpcnRlbG1lemV0dCBmZWzDvGxldGV0IGNzZXLDqWxuaS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIlDDqW56bmVtXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIkl0dCB0dWRvZCBtZWd2w6FsdG96dGF0bmkgYXogYWxhcMOpcnRlbG1lemV0dCBww6luem5lbWV0LiBFYmJlbiBhIHDDqW56bmVtYmVuIGZvZ29kIGzDoXRuaSBhIGJlamVneXrDqXNlaWQganV0YWxtYWl0LlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkZ1bmtjacOzIGxpc3RhPC9iPjxicj4tIEbDqXJqIGhvenrDoSBlZ3llZGkgY2lra2VraGV6IGLDoXJtaWx5ZW4gdMOpbcOhYmFuLCBhbWkgY3NhayDDqXJkZWtlbC48YnI+LSBLZXLDvGxqIGvDtnplbGViYiBhIHN6ZXJ6xZFraMO2eiBob3p6w6FzesOzbMOhc29ra2FsLCBiZXN6w6lsZ2V0w6lzZWtrZWwuPGJyPi0gU3phdmF6eiBiZWplZ3l6w6lzZWtyZSwgaG9neSBtZWdqdXRhbG1hemQgYSBzemVyesWRa2V0IMOpcyBla8O2emJlbiBrdXLDoXRvcmkganV0YWxtYXQga2Fwai48YnI+LSBQdWJsaWvDoWxkIGEgY2lra2VpZCDDqXMgYmxvZyBwb3N6dGphaWQsIHTDoXJvbGQgxZFrZXQgaW5neWVuIMOpcyDDqXJqIGVsIGp1dGFsbWFrYXQgYXp6YWwsIGhvZ3kga8O2dmV0xZFrZXQgc3plcnplbCDDqXMgZm9nbGFsa296b2wgdmVsw7xrLjxicj4tIMONcmogY2lra2VrZXQgbWVuZXQga8O2emJlbiwgbWVudHMgZWwgdMO2YmIgcGlzemtvemF0b3QgYSBrw6lzxZFiYmkgcHVibGlrw6FjacOzaG96Ljxicj4tIEvDtm55dmplbHrFkXpkIGEga2VkdmVuYyBjaWtrZWlkIGEga8Opc8WRYmJpIG9sdmFzw6FzaG96Ljxicj4tIFbDoWx0c2Qgw6F0IHZhZ3kgdmVkZCBraSBhIGZpemV0c8OpZ2VkLjxicj4tIEvDvGxkaiBww6luenQgYsOhcm1lbHkgc3plcnrFkW5laywgZmVsaGFzem7DoWzDs25haywgYmFyw6F0bmFrLCBrw7Z2ZXTFkW5laywgc3RiLjxicj4tIEvDtnZlc3Mgw6lyZGVrZXMgc3plcnrFkWtldCwgYmxvZ2dlcmVrZXQuPGJyPi0gS2VyZXNzIHLDoSBhIGvDtnZldMWRaWRyZSDDqXMgYXogw6FsdGFsYWQga8O2dmV0ZXR0ZWtyZS48YnI+LSBLYXBqIMOpcnRlc8OtdMOpc2VrZXQsIGhvZ3kga2FwY3NvbGF0YmFuIG1hcmFkaGFzcyBhIGvDtnZldMWRaWRkZWwgw6lzIGEgYmVzesOpbGdldMOpc2Vra2VsLCBhbWlrYmVuIHLDqXN6dCB2ZXN6ZWwuPGJyPi0gS2VyZXNzIGNpa2tla2V0IMOpcyBzemVyesWRa2V0IMOpcmRla2VzIGPDrW1rw6lrL2thdGVnw7NyacOhayBhbGF0dC48YnI+LSBTemFiZCBzemVtw6lseXJlIGEgcHJvZmlsb2RhdC48YnI+LSDDiXMgbcOpZyBzb2sgw7pqIGZ1bmtjacOzIHbDoXJoYXTDsy48YnI+PGJyPjxiPkJpenRvbnPDoWc8L2I+PGJyPjEuIEF6IGFsa2FsbWF6w6FzIHNvaGEgbmVtIGbDqXIgaG96esOhIGEgZmVsaGFzem7DoWzDsyBww6luesOpaGV6Ljxicj4yLiBBeiBhbGthbG1hesOhcyBrbGllbnMtb2xkYWxpIGhpdGVsZXPDrXTDqXN0IGhhc3puw6FsLCBhIHByaXbDoXQga3VsY3NvayBoZWx5YmVuIHZhbm5hayB0w6Fyb2x2YSDDqXMgc29oYSBuZW0ga2Vyw7xsbmVrIGVsa8O8bGTDqXNyZSBzZW1taWx5ZW4gc3plcnZlcnJlOyB0ZSB2YWd5IGEgZmVsZWzFkXMgYSBqZWxzemF2YWlkIGJpenRvbnPDoWdpIG1lbnTDqXNlacOpcnQuPGJyPjMuIEF6IGFsa2FsbWF6w6FzIGVneXN6ZXLFsSwgdGV0c3pldMWRcyBmZWxoYXN6bsOhbMOzaSBmZWzDvGxldGV0IMOpcyDDqWxtw6lueXQgbnnDump0PGJyPjQuIEF6IGFsa2FsbWF6w6FzIGV4dHJhIGJpenRvbnPDoWdpIHLDqXRlZ2V0IGvDrW7DoWwgYSBQSU4ta8OzZGRhbDxicj48YnI+QXogZVN0ZWVtIHTDoW1vZ2F0amEgYSBTdGVlbSDDqXMgYSBHb2xvcyBwbGF0Zm9ybW9rYXQuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJBbGFww610w7Mgw6lzIFZlemV0xZEgZmVqbGVzenTFkVwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiRmnDs2sgaG96esOhYWTDoXNhXCIsXG5cdFwiUExBVEZPUk1cIjogXCJQbGF0Zm9ybVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkxldMOpdFwiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkxldMOpdGkgw7xneW7DtmtcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJNZWdlcsWRc8OtdMOpc2kgaGF0w6FyaWTFkVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiTGV0w6l0IGxlasOhcnRhXCIsXG5cdFwiRVNDUk9XX0ZFRVwiOiBcIkxldMOpdGkgZMOtalwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcIkxldMOpdGkgZmVsdMOpdGVsZWtcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiw4lqc3pha2FpIG3Ds2RcIixcblx0XCJEQVlfTU9ERVwiOiBcIk5hcHBhbGkgbcOzZFwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIk11dGFzZCBzesO2dmVna8O2cm55ZXpldGJlblwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJBIEZlbGhhc3puw6Fsw7MgTmVtIFRhbMOhbGhhdMOzXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkrDs3bDoWhhZ3lcIixcblx0XCJESVNQVVRFXCI6IFwiVml0YVwiLFxuXHRcIlJFTEVBU0VcIjogXCJLaWFkw6FzXCIsXG5cdFwiRlJPTVwiOiBcIkZlbGFkw7NcIixcblx0XCJJRFwiOiBcImlkXCIsXG5cdFwiU1VCTUlUXCI6IFwiS8O8bGRcIixcblx0XCJSRUNFSVZFUlwiOiBcIkZvZ2Fkw7NcIixcblx0XCJMT0NBVElPTlwiOiBcIkhlbHlcIixcblx0XCJXRUJTSVRFXCI6IFwiV2Vib2xkYWxcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJNZWdqZWxlbsOtdGVuZMWRIG7DqXZcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwiQmVyYW5kYVwiLFxuXHRcIkxPR0lOXCI6IFwiTWFzdWtcIixcblx0XCJMT0dPVVRcIjogXCJLZWx1YXJcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiSWt1dGlcIixcblx0XCJCT09LTUFSS1NcIjogXCJUYW5kYWlcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVyXCIsXG5cdFwiTUFSS0VUXCI6IFwiUGFzYXJcIixcblx0XCJTRVRUSU5HU1wiOiBcIlNldGVsYW5cIixcblx0XCJBQk9VVFwiOiBcIlRlbnRhbmdcIixcblx0XCJBQk9VVF8xXCI6IFwiU2lhcGFwdW4gYmlzYSBtZW5kYXBhdGthbiBrZXVudHVuZ2FuIGRhcmkga29udGVuXCIsXG5cdFwiQUJPVVRfMlwiOiBcIkFwcGxpa2FzaSBkaWJ1YXQgb2xlaFwiLFxuXHRcIkFCT1VUXzNcIjogXCJkYW4gaW5pIGFkYWxhaCBvcGVuIHNvdXJjZSwgcHJveWVrIG1vYmlsZSBiZXJiYXNpcyBtYXN5YXJha2F0LiBJbmkgbWVuYXdhcmthbiBha3NlcyBrb250ZW4gdW50dWsgbWVtYmFjYSwgYmVya29tZW50YXIsIHZvdGluZywgcG9zdGluZywgbWVudHJhbnNmZXIgcGVuZGFwYXRhbiwgZGxsIGZpdHVyIHlhbmcgZGl0YXdhcmthbiBvbGVoIHt7cGxhdGZvcm1uYW1lfX0gYmxvY2tjaGFpbiBkYW4ge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBBcGxpa2FzaSB0aWRhayBwZXJuYWggbWVuZ2Frc2VzIGF0YXUgbWVtZWdhbmcgZGFuYSBwZW5nZ3VuYS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQXBsaWthc2kgbWVuYXdhcmthbiBtb2RlbCBrZWFtYW5hbiBjbGllbnQtc2lkZSwgZGVuZ2FuIGt1bmNpIHByaWJhZGkgaG9zdCBzZWNhcmEgbG9rYWwgZGFuIHRpZGFrIHBlcm5haCBkaWtpcmltIGtlIHNlcnZlci5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4gQXBsaWthc2kgbWVuYXdhcmthbiBzZWRlcmhhbmEsIHVzZXIgaW50ZXJmYWNlIHlhbmcgbWVuYXJpayBkYW4gcGVuZ2FsYW1hbi5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXBsaWthc2kgdGlkYWsgcGVybmFoIG1lbmdoYXJ1c2thbiBwZW5nZ3VuYSB1bnR1ayBtZW1hc3Vra2FuIGluZm9ybWFzaSBwcmliYWRpIGFwYXB1bi5cIixcblx0XCJBQk9VVF84XCI6IFwiUGlsaWggZ29vZC1rYXJtYSBzZWJhZ2FpIHdpdG5lc3NcIixcblx0XCJBQk9VVF85XCI6IFwiS29udGFrL1NhcmFuOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiSW5mbyBsZWJpaCBsYW5qdXQ6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiTWVuZ2hhcHVzXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJQYXNhclwiLFxuXHRcIlBSSUNFXCI6IFwiSGFyZ2FcIixcblx0XCJBTU9VTlRcIjogXCJKdW1sYWhcIixcblx0XCJUT1RBTFwiOiBcIkp1bWxhaFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiTm8gb3BlbiBvcmRlciB1bnR1a1wiLFxuXHRcIkRBVEVcIjogXCJUYW5nZ2FsXCIsXG5cdFwiQlVZXCI6IFwiQmVsaVwiLFxuXHRcIlNFTExcIjogXCJKdWFsXCIsXG5cdFwiT1BFTlwiOiBcIkJ1a2FcIixcblx0XCJISVNUT1JZXCI6IFwiUml3YXlhdFwiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiTWVuZ2lrdXRpIGtlbWJhbGlcIixcblx0XCJGT0xMT1dFRFwiOiBcIkRpaWt1dGlcIixcblx0XCJVTkZPTExPV1wiOiBcIkJlcmhlbnRpIG1lbmdpa3V0aVwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIk1lbmdpa3V0aVwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIlBlbmdpa3V0XCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIk1lbmNhcmkgUGVuZ2lrdXRcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiTWVuY2FyaSBNZW5naWt1dGlcIixcblx0XCJCWVwiOiBcIm9sZWhcIixcblx0XCJJTlwiOiBcImRhbGFtXCIsXG5cdFwiTUVOVVwiOiBcIk1lbnVcIixcblx0XCJCT09LTUFSS1wiOiBcIkJvb2ttYXJrXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVibG9nXCIsXG5cdFwiVVBWT1RFXCI6IFwiVXB2b3RlXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJEb3dudm90ZVwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJCYXRhbGthbiBEb3dudm90ZVxcblwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiQmF0YWxrYW4gVXB2b3RlZFxcblwiLFxuXHRcIlJFUExZXCI6IFwiQmFsYXNcIixcblx0XCJFRElUXCI6IFwiRWRpdFwiLFxuXHRcIlBPU1RfMVwiOiBcIkdlc2VyIGtlIGtpcmkgcGFkYSBrb21lbnRhciB1bnR1ayBtZWxpaGF0IG9wc2lcIixcblx0XCJQT1NUXzJcIjogXCJLZXR1ayBwYWRhIGtvbWVudGFyIHVudHVrIG1lbGloYXQgc3ViLWtvbWVudGFyXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wc2lcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZXN0ZWVtZWQgT2xlaFwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIlRpZGFrIGFkYSBkaSBzaW5pLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJTYWxkb1wiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7UGxhdGZvcm1uYW1lfX0sIHRva2VuIHRyYWRlYWJsZSB5YW5nIGRhcGF0IGRpdHJhbnNmZXIga2FwYW4gc2FqYS4ge3tQbGF0Zm9ybW5hbWV9fSBkYXBhdCBkaWtvbnZlcnNpIGtlIHt7a2VrdWF0YW4gcGxhdGZvcm0geWFuZ319IGRhbGFtIHByb3NlcyB5YW5nIGRpc2VidXQgcG93ZXJpbmcgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3tQbGF0Zm9ybXBvd2VyfX0sIG1lbXBlbmdhcnVoaSB0b2tlbiB5YW5nIG1lbmRhcGF0a2FuIGxlYmloIGJhbnlhayBrZWt1YXRhbiB1bnR1ayBtZW1lZ2FuZyBqYW5na2EgcGFuamFuZyBkYW4gc3VhcmEgcGFkYSBwb3N0aW5nLiBTZW1ha2luIHNhdHUgbWVtZWdhbmcgbGViaWggc2F0dSBkYXBhdCBtZW1wZW5nYXJ1aGkgaW1iYWxhbiBsYWluIGRhbiBtZW5kYXBhdGthbiBpbWJhbGFuIHVudHVrIHZvdGluZyBha3VyYXQuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW4gYmVybmlsYWkgc2VraXRhciB7e3BsYXRmb3Jtc3VuaXR9fSBkYXJpIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiUGVya2lyYWFuIE5pbGFpXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiTmlsYWkgZXN0aW1hc2kgaW5pIGRpZGFzYXJrYW4gcGFkYSBuaWxhaSByYXRhLXJhdGEgNyBoYXJpIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlNlamFyYWggVHJhbnNha3NpXCIsXG5cdFwiUE9TVElOR1wiOiBcIlBvc3RpbmdhblwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkt1bmNpIHBvc3RpbmdhbiBkaWd1bmFrYW4gdW50dWsgcG9zdGluZyBkYW4gdm90aW5nLiBJbmkgaGFydXMgYmVyYmVkYSBkYXJpIHRvbWJvbCBha3RpZiBkYW4gcGVtaWxpay5cIixcblx0XCJPV05FUlwiOiBcIlBlbWlsaWtcIixcblx0XCJQUk9GSUxFXzZcIjogXCJLdW5jaSBwZW1pbGlrIGFkYWxhaCBrdW5jaSBtYXN0ZXIgdW50dWsgYWNjb3VudCBkYW4gZGlwZXJsdWthbiB1bnR1ayBtZW5ndWJhaCBrdW5jaSBsYWlubnlhLiBLdW5jaSBwcmliYWRpIGF0YXUgcGFzc3dvcmQgdW50dWsga3VuY2kgcGVtaWxpayBoYXJ1cyBkaXNpbXBhbiBzZWNhcmEgb2ZmbGluZSBzZWJhbnlhayBtdW5na2luLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFrdGlmXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiS3VuY2kgYWt0aWYgZGlndW5ha2FuIHVudHVrIG1lbGFrdWthbiB0cmFuc2ZlciBkYW4gdGVtcGF0IG9yZGVyIGRpIHBhc2FyIGludGVybmFsLlwiLFxuXHRcIk1FTU9cIjogXCJNZW1vXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiS3VuY2kgbWVtbyBkaWd1bmFrYW4gdW50dWsgbWVtYnVhdCBkYW4gbWVtYmFjYSBtZW1vLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJQb3N0XCIsXG5cdFwiUkVQTElFU1wiOiBcIkJhbGFzYW5cIixcblx0XCJXQUxMRVRcIjogXCJEb21wZXRcIixcblx0XCJUQUdcIjogXCJUYWdcIixcblx0XCJVU0VSXCI6IFwiUGVuZ2d1bmFcIixcblx0XCJDTE9TRVwiOiBcIlR1dHVwXCIsXG5cdFwiVE9cIjogXCJLZXBhZGFcIixcblx0XCJBU1NFVFwiOiBcIkFzZXRcIixcblx0XCJTRU5EXCI6IFwiS2lyaW1cIixcblx0XCJTRUNVUklUWVwiOiBcIktlYW1hbmFuXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiVGVyc2VkaWFcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk1lbW8gcHVibGlrXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlBlbmdndW5hIG1pc2FsbnlhIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIktvZGUgUGluXCIsXG5cdFwiUElOX1RFWFRcIjogXCJLb2RlIFBJTiBtZW1iYW50dSBBbmRhIHVudHVrIG1lbmdhbWFua2FuIGFwbGlrYXNpIGRhbiBkYXRhIEFuZGEuIDxici8+PGJyLz4gPGI+Q2F0YXRhbjo8L2I+IFNldGVsYWggZGlha3RpZmthbiwgQW5kYSBtZW1pbGlraSBtYXggNCBtZW5jb2JhIHVudHVrIG1lbWJ1a2EsIGppa2EgQW5kYSBsdXBhIHBpbiBhdGF1IGdhZ2FsLCBhcGxpa2FzaSBha2FuIGhhcHVzIGxvZ2luIGRhdGEgcGVuZ2d1bmEuIEFuZGEgZGFwYXQgbG9naW4ga2VtYmFsaSBkYW4gdGVydXMgbWVuZ2d1bmFrYW4gYXBsaWthc2kuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWthc2lcIixcblx0XCJWT1RFX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gbm90aWZpa2FzaSBrZXRpa2Egc2VzZW9yYW5nIG1lbWJlcmlrYW4gc3VhcmEga29udGVuIEFuZGEhIDxici8+IDxiPkNhdGF0YW46PC9iPiBQZW1iZXJpdGFodWFuIHRlcm1hc3VrIHN1YXJhIGJlcmF0IHNlcnRhIGRhbGFtIHBlc2FuIHBlcmluZ2F0YW4uIChCYWlrIGl0dSB1cC12b3RlLCBkb3duLXZvdGUsIHVuLXZvdGUpLlwiLFxuXHRcIlZPVEVcIjogXCJWb3RpbmdcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gbm90aWZpa2FzaSBrZXRpa2Egc2VzZW9yYW5nIGtvbWVudGFyIHBhZGEgcG9zdGluZyBhdGF1IGtvbWVudGFyITxici8+IDxiPkNhdGF0YW46PC9iPiBQZW1iZXJpdGFodWFuIHRlcm1hc3VrIGtldGlrYSBzZXNlb3JhbmcgPGI+U3VudGluZzwvYj4ga29tZW50YXIgbWVyZWthIGp1Z2EuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIktvbWVudGFyXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gbm90aWZpa2FzaSBrZXRpa2Egc2VzZW9yYW5nIEZvbGxvdyBhdGF1IFVuZm9sbG93IEFuZGEhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW55ZWJ1dGthblwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gcGVtYmVyaXRhaHVhbiBiaWxhIHNlc2VvcmFuZyBtZW55ZWJ1dGthbiBBbmRhIGRhbGFtIHBvc3RpbmdhbiBtZXJla2Eva29tZW50YXIhXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlJlYmxvZ1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdGthbiBub3RpZmlrYXNpIGtldGlrYSBzZXNlb3JhbmcgcmVibG9ncyBwb3N0aW5nIEFuZGEhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJLb25maWd1cmFzaVwiLFxuXHRcIlZPVElOR1wiOiBcIlZvdGluZ1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiS2VrdWF0YW4gVm90aW5nIGF0YXUgcGVyc2VudGFzZSBtZW1wZW5nYXJ1aGkgaGFrIHN1YXJhIHBhZGEgYXBsaWthc2ksIHNlaGluZ2dhIEFuZGEgZGFwYXQgbWVuZ2F0dXIgcmV3YXJkIFZvdGluZyBBbmRhLiA8YnIvPjxici8+PGI+Q2F0YXRhbjo8L2I+IGluaSBha2FuIG1lbmd1YmFoIGtla3VhdGFuIHZvdGluZy9wZXJzZW50YXNlIHVudHVrIGRvd252b3RpbmcganVnYSBkYW4gaXR1IGFkYWxhaCBkaSBtYW5hLW1hbmEgcGFkYSBhcGxpa2FzaVwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiRGlyZWtvbWVuZGFzaWthblwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNpbXBhbiBwZXJ1YmFoYW5cIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIlZvdGVycyBpbmZvXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiU2VsYW1hdCBEYXRhbmcga2VtYmFsaSFcIixcblx0XCJMT0dJTl8xXCI6IFwiTWFzdWsgZGVuZ2FuIG5hbWEgcGVuZ2d1bmEgZGFuIHBhc3N3b3JkIHVudHVrIG1lbGFuanV0a2FuLlwiLFxuXHRcIkxPR0lOXzJcIjogXCJQb3N0aW5nIGt1bmNpIGRpZ3VuYWthbiB1bnR1ayBwb3N0aW5nLCBrb21lbnRhciwgdm90aW5nLCBmb2xsb3cuXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFjdGl2ZSBrdW5jaSBkaWd1bmFrYW4gdW50dWsgdHJhbnNmZXIgZGFuIG1lbXBlcmJhcnVpIGdhbWJhciBwcm9maWwuXCIsXG5cdFwiTE9HSU5fNFwiOiBcImtyZWRlbnNpYWwgcGVuZ2d1bmEgZGlzaW1wYW4gc2VjYXJhIGxva2FsIHBhZGEgcGVyYW5na2F0LiBTZXRlbGFoIEtlbHVhciBrcmVkZW5zaWFsIGRpaGFwdXMhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiVGlkYWsgbWVtaWxpa2kgYWt1bj9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIkRhZnRhciBTZWthcmFuZ1wiLFxuXHRcIkNBTkNFTFwiOiBcIkJhdGFsXCIsXG5cdFwiQURWQU5DRURcIjogXCJMYW5qdXRhblwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJLdW5jaSBha3RpZiBwcmliYWRpXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJLdW5jaSBQb3N0aW5nIFByaWJhZGlcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIk1hc3Rlci9wYXNzd29yZCB1dGFtYVwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiTmFtYSBQZW5nZ3VuYVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIkxpaGF0IGthcnR1XCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiQ29tcGFjdCBWaWV3XCIsXG5cdFwiU0VBUkNIXCI6IFwiQ2FyaVwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiTWFzdWtrYW4gY2VyaXRhXCIsXG5cdFwiUkVQTFlUT1wiOiBcIkJhbGFzIGtlXCIsXG5cdFwiUE9TVFwiOiBcInBvc3RpbmdcIixcblx0XCJQUkVWSUVXXCI6IFwiVGluamF1YW5cIixcblx0XCJERUZBVUxUXCI6IFwiRGVmYXVsdCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiUG93ZXIgVXAgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiTWVub2xhayBwZW1iYXlhcmFuXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJTSU1QQU4gVU5UVUsgTkFOVElcIixcblx0XCJDTEVBUlwiOiBcIkJFUlNJSEtBTlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBvc3Rpbmcga29udGVuXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiS29udGVuIGtvbWVudGFyXCIsXG5cdFwiVElUTEVcIjogXCJKdWR1bFwiLFxuXHRcIlRBR1NcIjogXCJUYWdzXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiVElEQUsgQ09DT0tcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIktvbmZpcm1hc2kgUGluXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiU0FMQUhcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJQb3N0IHBlbWJ1a2FhblwiLFxuXHRcIlNFVF9QSU5cIjogXCJBdHVyIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIk1hc3VrYW4gUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiQXBha2FoIGFuZGEgeWFraW4/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCJSZWJsb2cgaXJldmVyc2liZWwsIGFwYWthaCBBbmRhIGluZ2luIG1lbGFuanV0a2FuP1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIlNpYXJhbiBlcnJvciwgY29iYSBsYWdpIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTdWtzZXNcIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlJlYmxvZ2dlZCBwb3N0IVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJHYWdhbCBtYXN1ayEgUGFzdGlrYW4gQW5kYSB0ZWxhaCBsb2dpbiBkZW5nYW4gcGFzc3dvcmQgbWFzdGVyIGF0YXUgdGVyc2VkaWEgUG9zdGluZyBrdW5jaSBwcmliYWRpIHBhZGEgTG9naW4gamlrYSBBbmRhIHRlbGFoIGNob29zZWQgbW9kZSBBZHZhbmNlZC5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJHYWdhbCBtYXN1ayEgUGFzdGlrYW4gQW5kYSB0ZWxhaCBsb2dpbiBkZW5nYW4gcGFzc3dvcmQgbWFzdGVyIGF0YXUgZGlzZWRpYWthbiBrdW5jaSBwcmliYWRpIEFrdGlmIGRpIExvZ2luIGppa2EgQW5kYSB0ZWxhaCBtZW1pbGloIG1vZGUgQWR2YW5jZWQuXCIsXG5cdFwiV0FSTklOR1wiOiBcIlBlcmluZ2F0YW5cIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiVm90aW5nIHVudHVrIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdGVkIHVudHVrIHdpdG5lc3NcIixcblx0XCJBR09cIjogXCJsYWx1XCIsXG5cdFwiRlJPTV9OT1dcIjogXCJkYXJpIHNla2FyYW5nXCIsXG5cdFwiU0VDU1wiOiBcImRldGlrXCIsXG5cdFwiQV9NSU5cIjogXCJzZW1lbml0XCIsXG5cdFwiTUlOU1wiOiBcIm1lbml0XCIsXG5cdFwiQU5fSE9VUlwiOiBcInNlamFtXCIsXG5cdFwiSE9VUlNcIjogXCJqYW1cIixcblx0XCJBX0RBWVwiOiBcInNlaGFyaVwiLFxuXHRcIkRBWVNcIjogXCJoYXJpXCIsXG5cdFwiQV9NT05USFwiOiBcInNlYnVsYW5cIixcblx0XCJNT05USFNcIjogXCJidWxhblwiLFxuXHRcIkFfWUVBUlwiOiBcInNldGFodW5cIixcblx0XCJZRUFSU1wiOiBcInRhaHVuXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW4gYmFjYVwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJEb3dudm90ZSBhdGF1IGJlbmRlcmFcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJBbWJpbCBHYW1iYXJcIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlBpbGloIEdhbWJhclwiLFxuXHRcIlNFVF9DVVNUT01fVVJMXCI6IFwiTWVuZXRhcGthbiBVUkwga3VzdG9tXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJNYXN1a2FuIEdhbWJhclwiLFxuXHRcIkVSUk9SXCI6IFwia2VzYWxhaGFuXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwia2VzYWxhaGFuIE1lbmd1cGxvYWQgXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkthbWVyYSBEaWJhdGFsa2FuXCIsXG5cdFwiU0VUX1VSTFwiOiBcIk1lbmV0YXBrYW4gVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkRpcmVjdCB3ZWIgbGluayB1dHVrIEdhbWJhclwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiS29tZW50YXIgZGlzYW1wYWlrYW4hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJNZW5naGFwdXMga29tZW50YXIgYWRhbGFoIGlyZXZlcnNpYmVsLi4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiTWVuZ2hhcHVzIGtvbWVudGFyXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJVcGxvYWQgR2FtYmFyXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlVwbG9hZCBTZWxlc2FpXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIlVwbG9hZCBHYWdhbFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIlBhc3N3b3JkIGF0YXUgbmFtYSBha3VuIHRpZGFrIGJlbmFyXCIsXG5cdFwiSU5GT1wiOiBcIkluZm9cIixcblx0XCJRUl9URVhUXCI6IFwiVGVtcGF0a2FuIGtvZGUgUVIgZGkgZGFsYW0gYXJlYSBwaW5kYWlcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJQYXN0aWthbiBBbmRhIG1lbWlsaWtpIHNhbGRvIHlhbmcgY3VrdXAgdW50dWsgdHJhbnNha3NpIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJQZW5nZ3VuYSB5YW5nIEFuZGEgY2NvYmEgdW50dWsgbWVudHJhbnNmZXIgZGFuYSwgdGlkYWsgYWRhIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJBcGFrYWggQW5kYSB5YWtpbiBBbmRhIGluZ2luIG1lbnRyYW5zZmVyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIktvbmZpcm1hc2lcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYWtzaSBkaXNpYXJrYW5cIixcblx0XCJGRUVEXCI6IFwiVW1wYW5cIixcblx0XCJUUkVORElOR1wiOiBcIlRyZW5kaW5nXCIsXG5cdFwiSE9UXCI6IFwiSG90XCIsXG5cdFwiTkVXXCI6IFwiQmFydVwiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvbW9zaVwiLFxuXHRcIlZPVEVTXCI6IFwiVm90ZVwiLFxuXHRcIlBBWU9VVFwiOiBcIkRpYmF5YXJcIixcblx0XCJDT01NRU5UU1wiOiBcIktvbWVudGFyXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuZGluZyAzMCBIYXJpXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiVXJ1dGthbiBQb3N0aW5nYW46XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiU2lrbHVzIHBlbWJheWFyYW5cIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW5zaSBQZW1iYXlhcmFuXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJQZW1iYXlhcmFuIHRlcmFraGlyXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlBlbWJheWFyYW4gUGVudWxpc1wiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlBlbWJheWFyYW4gS3VyYXNpXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJQb3N0IGRpdGF5YW5na2FuIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQb3N0aW5nIHVudHVrIGRpYWp1a2FuIG5hbnRpIVwiLFxuXHRcIlNBVkVEXCI6IFwiRGlzaW1wYW5cIixcblx0XCJDTEVBUkVEXCI6IFwiRGliZXJzaWhrYW5cIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiRmxhZ2dpbmcgcG9zdGluZ2FuIGRhcGF0IG1lbmdoYXB1cyBpbWJhbGFuIGRhbiBtZW1idWF0IGJhaGFuIGluaSBrdXJhbmcgdGVybGloYXQgPGJyPiBiZW5kZXJhIGhhcnVzIGRpZ3VuYWthbiB1bnR1ayBiZXJpa3V0OiA8dWw+PGxpPlBlbmlwdWFuIGF0YXUgUGxhZ2lhcmlzbWU8L2xpPjxsaT5LYXRhIGthc2FyIGF0YXUgSW50ZXJuZXQgVHJvbGxpbmcgPC9saT48bGk+S29udGVuIERpc2VuZ2FqYSBkaWthdGVnb3Jpa2FuIGF0YXUgU3BhbTwvbGk+IDwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiQmF0YXMgcGVybWludGFhbiB0ZXJjYXBhaS4gTGloYXQgdHJlbi90YWcgbGFpbm55YSFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0aW5nIGRpaGlsYW5na2FuIGRhcmkgYm9va21hcmshXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlBvc3RpbmcgZGl0YW1iYWhrYW4ga2UgYm9va21hcmshXCIsXG5cdFwiUkVTRVRcIjogXCJTZXRlbCBVbGFuZ1wiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpa2FzaSBnYW1iYXIgUHJvZmlsXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNZW1vZGlmaWthc2kgU2FtcHVsIGdhbWJhclwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIkhhcmFwIG1lbWJlcmlrYW4ga3VuY2kgcHJpYmFkaSBBY3RpdmUgamlrYSBBbmRhIHRlbGFoIG1lbWlsaWggbW9kdXMgbWFzdWsgTGFuanV0YW4hXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiSW5pIGFrYW4gbWVueWV0ZWwgdWxhbmcgZ2FtYmFyIHByb2ZpbFwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIkluaSBha2FuIG1lcmVzZXQgZ2FtYmFyIHNhbXB1bFwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiVXBkYXRlIHNlcnZlciBtZW1lcmx1a2FuIFJlc3RhcnQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIlBlbmdhdHVyYW4gZGlwZXJiYXJ1aSFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJCYWhhc2FcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkRpIHNpbmkgQW5kYSBkYXBhdCBtZW5ndWJhaCBiYWhhc2EgYXBsaWthc2kuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIk9wZXJhc2kgaW5pIG1lbmdoYXJ1c2thbiBwZW5nZ3VuYSB1bnR1ayBsb2dpbiBkZW5nYW4gcGFzc3dvcmQgdXRhbWEsIGFrdGlmL3Bvc3RpbmdhbiBrdW5jaS4gU2lsYWhrYW4gbG9naW4gZGFuIGNvYmEgbGFnaS5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXJpXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiS29udHJpYnV0b3IgdGVyamVtYWhhblwiLFxuXHRcIlNIQVJFXCI6IFwiQmFnaWthblxcblwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiUGFzYXJcIixcblx0XCJFWENIQU5HRVwiOiBcIlBlcnR1a2FyYW5cIixcblx0XCJEUkFGVFNcIjogXCJkcmFmdFwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIlBvc3RpbmcgYWthbiBkaWhhcHVzIGRhcmkgZHJhZnQhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIlBvc3RpbmcgZGl0YW1iYWhrYW4ga2UgZHJhZnQhXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIkdlc2VyIGtlIGtpcmkgdW50dWsgbWVsaWhhdCBvcHNpXCIsXG5cdFwiTUFOQUdFXCI6IFwiTWVuZ2Vsb2xhXFxuXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkdhbWJhciBkaWhhcHVzXCIsXG5cdFwiQ09QWVwiOiBcImNvcHlcIixcblx0XCJOT19JTUFHRVwiOiBcIkFuZGEgYmVsdW0gbWVuZ3VuZ2dhaCBnYW1iYXIgYXBhcHVuLCBiZWx1bSFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlRhcmlrIGtlIGJhd2FoIHVudHVrIG1lbnllZ2Fya2FuXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIlxcbiBFeHRlcm5hbCBBcHBzXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpbnNcIixcblx0XCJTVUdHRVNUXCI6IFwiU2FyYW5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcIlNlZ2VyYSBoYWRpclwiLFxuXHRcIkNIQUlOXCI6IFwiQ2hhaW5cXG5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiRGkgc2luaSBBbmRhIGRhcGF0IG1lbmd1YmFoIGJsb2NrY2hhaW4gYXRhdSBwbGF0Zm9ybSBkZWZhdWx0LlxcbkNoYWluX1RleHRcIixcblx0XCJDVVJSRU5DWVwiOiBcIk1hdGEgdWFuZ1wiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJEaSBzaW5pIEFuZGEgZGFwYXQgbWVuZ3ViYWggbWF0YSB1YW5nIGRlZmF1bHQgQW5kYS4gQW5kYSBha2FuIG1lbGloYXQgbmlsYWkgaGFkaWFoIHBvc3Rpbmcva29tZW50YXIgcGFkYSBtYXRhIHVhbmcgaW5pLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkRhZnRhciBmaXR1cjwvYj4gPGJyPi1ha3NlcyB1bmlrIGFydGlrZWwgZGFsYW0gc3ViamVrIEFuZGEgdGVydGFyaWsgbWVtYmFjYS4gPGJyPiAtVGVybGliYXQgZGVuZ2FuIHBlbnVsaXMgZGVuZ2FuIGtvbWVudGFyLCBtZW1iYWhhcyB0b3Bpay4gPGJyPi1Wb3RpbmcgdW50dWsgcG9zdGluZyBrZSBwZW51bGlzIGhhZGlhaCBzZXJ0YSBtZW5kYXBhdGthbiBwYWhhbGEgcGVuZ2t1cmFzaWFuLiA8YnI+LVB1Ymxpc2ggYXJ0aWtlbCwgcG9zdGluZyBibG9nIGRhbiBob3N0IG1lcmVrYSBzZWNhcmEgZ3JhdGlzIGRhbiBtZW5kYXBhdGthbiBpbWJhbGFuIGRlbmdhbiBtZWxpYmF0a2FuIGRhbiBtZW5kYXBhdGthbiBwZW5naWt1dC4gPGJyPi1NZW51bGlzIGFydGlrZWwgdGVudGFuZyBwZXJnaSwgbWVueWltcGFuIGRyYWYgYmViZXJhcGEgcG9zdGluZyB1bnR1ayBrZW11ZGlhbiBwdWJsaWthc2kuIDxicj4tQm9va21hcmsgZmF2b3JpdCBhcnRpa2VsIHVudHVrIGRpYmFjYSBuYW50aS4gPGJyPi1FeGNoYW5nZSBhdGF1IHVhbmcgdHVuYWkgcGVuZ2hhc2lsYW4gQW5kYS4gPGJyPi1NZW5naXJpbSBkYW5hIGtlcGFkYSBwZW51bGlzIGF0YXUgcGVuZ2d1bmEsIHRlbWFubXUsIHBlbmdpa3V0bXUsIGRsbCA8YnI+LWlrdXRpIG1lbmFyaWsgcGVudWxpcywgYmxvZ2dlci4gPGJyPiAtQ2FyaSBwZW5naWt1dG55YSBkYW4gcGVudWxpcyBBbmRhIG1lbmdpa3V0aSBBbmRhLiA8YnI+LUdldCBwZW1iZXJpdGFodWFuIHVudHVrIHRldGFwIGJlcmh1YnVuZ2FuIGRlbmdhbiBwZW5naWt1dCBBbmRhIGRhbiBkaXNrdXNpIEFuZGEgeWFuZyB0ZXJsaWJhdCBpbi4gPGJyPi1wZW5jYXJpYW4gdW50dWsgbWVuYXJpayB0YWdzL0thdGVnb3JpIGFydGlrZWwsIHBlbnVsaXMuIDxicj4gLU1lbXBlcnNvbmFsaXNhc2lrYW4gcHJvZmlsIEFuZGEuIDxicj4tQmFueWFrIGxlYmloIGJhbnlhayBmaXR1ciB1bnR1ayBkYXRhbmcuIDxicj48YnI+PGI+S2VhbWFuYW48L2I+IDxicj4xLiBBcHAgdGlkYWsgcGVybmFoIG1lbmdha3NlcyBhdGF1IG1lbWVnYW5nIHBlbmdndW5hIGRhbmEuIDxicj4yLiBhcHAgbWVuYXdhcmthbiBtb2RlbCBrZWFtYW5hbiBzaXNpIGtsaWVuIGRlbmdhbiBwcml2YXRlIGtleSBob3N0IHNlY2FyYSBsb2thbCBkYW4gdGlkYWsgcGVybmFoIGRpa2lyaW1rYW4ga2Ugc2VydmVyIGFwYXB1biwgQW5kYSBiZXJ0YW5nZ3VuZyBqYXdhYiB1bnR1ayBtZW1idWF0IGNhZGFuZ2FuIHBhc3N3b3JkIEFuZGEuIDxicj4zLiBhcHAgbWVuYXdhcmthbiBhbnRhcm11a2EgcGVuZ2d1bmEgeWFuZyBzZWRlcmhhbmEsIG1lbmFyaWsgZGFuIHBlbmdhbGFtYW4gPGJyPjQuIEFwcCBtZW5hd2Fya2FuIGxhcGlzYW4gdGFtYmFoYW4ga2VhbWFuYW4gZGVuZ2FuIGtvZGUgcGluIDxicj48YnI+aGFyZ2EgbWVuZHVrdW5nIHBsYXRmb3JtIFN0ZWVtIGRhbiBHb2xvcy4gPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJQZW5kaXJpIGRhbiBwZW5nZW1iYW5nXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJUYW1iYWggYWt1blwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJBZ2VuIGVzY3Jvd1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlJhdGlmaWthc2kgdGVuZ2dhdCB3YWt0dVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiRXNjcm93IGthZGFsdWFyc2FcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiRXNjcm93IGJpYXlhXCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IHBlcnN5YXJhdGFuXCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIk1vZGUgbWFsYW1cIixcblx0XCJEQVlfTU9ERVwiOiBcIk1vZGUgU2lhbmdcIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJMaWhhdCBrb250ZWtzIGxlbmdrYXBcIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiUGVuZ2d1bmEgdGlkYWsgZGl0ZW11a2FuXCIsXG5cdFwiQVBQUk9WRVwiOiBcIkRpc2V0dWp1aVwiLFxuXHRcIkRJU1BVVEVcIjogXCJTZW5na2V0YVwiLFxuXHRcIlJFTEVBU0VcIjogXCJSaWxpc1wiLFxuXHRcIkZST01cIjogXCJEYXJpXCIsXG5cdFwiSURcIjogXCJpZFwiLFxuXHRcIlNVQk1JVFwiOiBcIlN1Ym1pdFwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwiUGVuZXJpbWFcIixcblx0XCJMT0NBVElPTlwiOiBcIkxva2FzaVwiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJzaXRlXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiTmFtYSB0YW1waWxhblwiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJQYWdpbmEgSW5pemlhbGVcIixcblx0XCJMT0dJTlwiOiBcIkFjY2VkaVwiLFxuXHRcIkxPR09VVFwiOiBcIkVzY2lcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsb1wiLFxuXHRcIkZPTExPV1wiOiBcIkNoaSBTZWd1aVwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIlByZWZlcml0aVwiLFxuXHRcIlRSQU5TRkVSXCI6IFwiVHJhc2ZlcmltZW50aVwiLFxuXHRcIk1BUktFVFwiOiBcIk1lcmNhdG9cIixcblx0XCJTRVRUSU5HU1wiOiBcIkltcG9zdGF6aW9uaVwiLFxuXHRcIkFCT1VUXCI6IFwiSW5mb1wiLFxuXHRcIkFCT1VUXzFcIjogXCJkb3ZlIGNoaXVucXVlIHB1w7IgZ3VhZGFnbmFyZSByaWNvbXBlbnNlIHBlciBpIHByb3ByaSBjb250ZW51dGkhXCIsXG5cdFwiQUJPVVRfMlwiOiBcIsOoIG9mZmVydG8gZGFsbGEgcGlhdHRhZm9ybWEge3twbGF0Zm9ybW5hbWV9fS4gTCdhcHAgw6ggY3JlYXRhIGRhXCIsXG5cdFwiQUJPVVRfM1wiOiBcImVkIMOoIHVuIHByb2dldHRvIHBlciBkaXNwb3NpdGl2aSBtb2JpbGksIG9wZW4tc291cmNlIGUgcG9ydGF0byBhdmFudGkgZGFsbGEgY29tbXVuaXR5LiBPZmZyZSBsJ2FjY2Vzc28gcGVyIGxhIGxldHR1cmEsIGlsIGNvbW1lbnRvLCBpbCB2b3RvLCBlIGxhIHB1YmJsaWNhemlvbmUgZGkgY29udGVudXRpLiBDYXJhdHRlcmlzdGljaGUgb2ZmZXJ0ZSBkYWxsYSB7e3BsYXRmb3JtbmFtZX19IGJsb2NrY2hhaW4gZSBkYSB7e3NpdGVuYW1lfX1cIixcblx0XCJBQk9VVF80XCI6IFwiMS4gTCdhcHAgbm9uIGhhIG1haSBsJ2FjY2Vzc28gbsOoIGlsIGNvbnRyb2xsbyBzdWkgZm9uZGkgZGVsbCd1dGVudGUuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEwnYXBwIG9mZnJlIHVuIG1vZGVsbG8gZGkgc2ljdXJlenphIFxcXCJsYXRvIGNsaWVudGVcXFwiLCBncmF6aWUgYWxsZSBjaGlhdmkgcHJpdmF0ZSBtZW1vcml6emF0ZSBsb2NhbG1lbnRlIGUgbWFpIHRyYXNtZXNzZSBhZCBhbGN1biBzZXJ2ZXIuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIEwnYXBwIG9mZnJlIHVuJ2VzcGVyaWVuemEgZSB1bidpbmZlcmZhY2NpYSBncmFmaWNhIHNlbXBsaWNlIGUgYXR0cmFlbnRlLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBMJ2FwcCBub24gcmljaGllZGUgbWFpIGwnaW5zZXJpbWVudG8gZGkgaW5mb3JtYXppb25pIHBlcnNvbmFsaSBkYSBwYXJ0ZSBkZWxsJ3V0ZW50ZVwiLFxuXHRcIkFCT1VUXzhcIjogXCJWb3RhIGdvb2Qta2FybWEgY29tZSB0ZXN0aW1vbmlhbFwiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YXR0aS9GZWVkYmFjazpcIixcblx0XCJBQk9VVF8xMFwiOiBcIk1hZ2dpb3JpIGluZm9ybWF6aW9uaTpcIixcblx0XCJSRU1PVkVcIjogXCJFbGltaW5hXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJNZXJjYXRvXCIsXG5cdFwiUFJJQ0VcIjogXCJQcmV6em9cIixcblx0XCJBTU9VTlRcIjogXCJJbXBvcnRvXCIsXG5cdFwiVE9UQUxcIjogXCJUb3RhbGVcIixcblx0XCJOT09SREVSU1wiOiBcIk5lc3N1biBvcmRpbmUgYXBlcnRvXCIsXG5cdFwiREFURVwiOiBcIkRhdGFcIixcblx0XCJCVVlcIjogXCJDb21wcmFcIixcblx0XCJTRUxMXCI6IFwiVmVuZGlcIixcblx0XCJPUEVOXCI6IFwiQXByaVwiLFxuXHRcIkhJU1RPUllcIjogXCJDcm9ub2xvZ2lhXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJTZWd1aVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiU2VndWl0b1wiLFxuXHRcIlVORk9MTE9XXCI6IFwiU21ldHRpIGRpIHNlZ3VpcmVcIixcblx0XCJGT0xMT1dJTkdcIjogXCJTZWd1aXRvXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiRm9sbG93ZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIkNlcmNhIHRyYSBpIHR1b2kgZm9sbG93ZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIkNlcmNhIHRyYSBjaGkgc2VndWlcIixcblx0XCJCWVwiOiBcImRhXCIsXG5cdFwiSU5cIjogXCJpblwiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJBZ2dpdW5naSBhaSBwcmVmZXJpdGlcIixcblx0XCJSRUJMT0dcIjogXCJDb25kaXZpZGlcIixcblx0XCJVUFZPVEVcIjogXCJWb3RhXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJEaXNhcHByb3ZhXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIlJpbXVvdmkgRG93bnZvdGVcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlJpbXVvdmkgVXB2b3RlXCIsXG5cdFwiUkVQTFlcIjogXCJSaXNwb25kaVwiLFxuXHRcIkVESVRcIjogXCJNb2RpZmljYVwiLFxuXHRcIlBPU1RfMVwiOiBcIlN3aXBlIGEgc2luaXN0cmEgc3VpIGNvbW1lbnRpIHBlciB2aXN1YWxpenphcmUgbGUgb3B6aW9uaVwiLFxuXHRcIlBPU1RfMlwiOiBcIkNsaWNjYSBzdWkgY29tbWVudGkgcGVyIHZpc3VhbGl6emFyZSBpIHNvdHRvLWNvbW1lbnRpXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wemlvbmlcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJDb250ZGl2aXNvIGRhXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiTm9uIGMnw6ggYW5jb3JhIG5pZW50ZSBxdWkuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlNhbGRpXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgc29ubyB0b2tlbnMgY2hlIHBvc3Nvbm8gZXNzZXJlIHNjYW1iaWF0aS4ge3twbGF0Zm9ybW5hbWV9fSBwb3Nzb25vIGVzc2VyZSBjb252ZXJ0aXRpIGluIHt7cGxhdGZvcm1wb3dlcn19IGF0dHJhdmVyc28gdW4gcHJvY2Vzc28gY2hpYW1hdG8gcG93ZXJpbmcgdXAuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwiIFxcblwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIkkgdG9rZW5zIHZhbGdvbm8gY2lyY2Ege3twbGF0Zm9ybXN1bml0fX0gZGkge3twbGF0Zm9ybW5hbWV9fS4gXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwiVmFsb3JlIFN0aW1hdG9cIixcblx0XCJQUk9GSUxFXzRcIjogXCJJbCB2YWxvcmUgc3RpbWF0byBzaSBiYXNhIHN1bGxhIG1lZGlhIGRlZ2xpIHVsdGltaSA3IGdpb3JuaSBkaSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJDcm9ub2xvZ2lhIGRlbGxlIHRyYW5zYXppb25pXCIsXG5cdFwiUE9TVElOR1wiOiBcIlB1YmJsaWNhemlvbmVcIixcblx0XCJQUk9GSUxFXzVcIjogXCJMYSBcXFwicG9zdGluZyBrZXlcXFwiIMOoIHV0aWxpenphdGEgcGVyIGxhIHB1YmJsaWNhemlvbmUgZSBsYSB2b3RhemlvbmUgZGkgY29udGVudXRpLiBFc3NhIGRvdnJlYmJlIGVzc2VyZSBkaXZlcnNhIGRhbGwnYWN0aXZlIGUgZGFsbCdvd25lciBrZXkuXCIsXG5cdFwiT1dORVJcIjogXCJQcm9wcmlldGFyaW9cIixcblx0XCJQUk9GSUxFXzZcIjogXCJMYSBcXFwib3duZXIga2V5XFxcIiDDqCBsYSBjaGlhdmUgbWFlc3RyYSBkZWxsJ2FjY291bnQgZWQgw6ggcmljaGllc3RhIHBlciBtb2RpZmljYXJlIGxlIGFsdHJlIGNoaWF2aS4gVGFsZSBjaGlhdmUgcHJpdmF0YSwgY29zw6wgY29tZSBsYSBwYXNzd29yZCBwcmluY2lwYWxlLCBkb3ZyZWJiZXJvIGVzc2VyZSB0ZW51dGUgb2ZmbGluZSBpbCBwacO5IHBvc3NpYmlsZS5cIixcblx0XCJBQ1RJVkVcIjogXCJBdHRpdml0w6BcIixcblx0XCJQUk9GSUxFXzdcIjogXCJMYSBcXFwiYWN0aXZlIGtleVxcXCIgw6ggdXRpbGl6emF0YSBwZXIgZWZmZXR0dWFyZSB0cmFzZmVyaW1lbnRpIGUgcGlhenphcmUgb3JkaW5pIG5lbCBtZXJjYXRvIGludGVybm8uXCIsXG5cdFwiTUVNT1wiOiBcIk1lbW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJMYSBcXFwibWVtbyBrZXlcXFwiIMOoIHV0aWxpenphdGEgcGVyIGxhIGNyZWF6aW9uZSBlIGxldHR1cmEgZGVpIG1lbW8uXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIkNvbW1lbnRpXCIsXG5cdFwiUkVQTElFU1wiOiBcIlJpc3Bvc3RlXCIsXG5cdFwiV0FMTEVUXCI6IFwiUG9ydGFmb2dsaW9cIixcblx0XCJUQUdcIjogXCJUYWdcIixcblx0XCJVU0VSXCI6IFwiVXRlbnRlXCIsXG5cdFwiQ0xPU0VcIjogXCJDaGl1ZGlcIixcblx0XCJUT1wiOiBcIkFcIixcblx0XCJBU1NFVFwiOiBcIkFzc2V0XCIsXG5cdFwiU0VORFwiOiBcIkludmlhXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTaWN1cmV6emFcIixcblx0XCJBVkFJTEFCTEVcIjogXCJEaXNwb25pYmlsZVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTWVtbyBwdWJibGljYVwiLFxuXHRcIlRPX0RFU0NcIjogXCJVdGVudGUgYWQgZXNlbXBpbyBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJDb2RpY2UgUElOXCIsXG5cdFwiUElOX1RFWFRcIjogXCJJbCBjb2RpY2UgUElOIHRpIGFpdXRhIGEgcmVuZGVyZSBzaWN1cmkgbCdhcHBsaWNhemlvbmUgZSBpIHR1b2kgZGF0aS4gPGJyLz48YnIvPjxiPkF0dGVuemlvbmU6PC9iPiB1bmEgdm9sdGEgYXR0aXZhdG8sIGhhaSBhbCBtYXNzaW1vIDQgdGVudGF0aXZpIHBlciBzYmxvY2NhcmUgbCdhcHAsIHNlIHRpIGRpbWVudGljaGkgaWwgUElOIG8gZmFsbGlzY2kgaSB0ZW50YXRpdmksIGwnYXBwbGljYXppb25lIHJpbXVvdmVyw6AgaSBkYXRpIHV0ZW50ZS4gUG90cmFpIGZhcmUgbnVvdmFtZW50ZSBpbCBsb2dpbiBlIGNvbnRpbnVhcmUgYWQgdXNhcmUgbCdhcHBsaWNhemlvbmUuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWNoZVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIlJpY2V2ZXJhaSB1bmEgbm90aWZpY2EgcXVhbmRvIHF1YWxjdW5vIHZvdGEgaSB0dW9pIGNvbnRlbnV0aSE8YnIvPjxicj5Ob3RhOjwvYj4gTGEgbm90aWZpY2EgaW5jbHVkZXLDoCBpbCB0aXBvIGRpIHZvdG8uICh1cC12b3RlLCBkb3duLXZvdGUsIHVuLXZvdGUpLlwiLFxuXHRcIlZPVEVcIjogXCJWb3RvXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiUmljZXZlcmFpIHVuYSBub3RpZmljYSBxdWFuZG8gcXVhbGN1bm8gY29tbWVudGEgdW4gdHVvIHBvc3QgbyByaXNwb25kZSBhZCB1biB0dW8gY29tbWVudG8hPGJyLz48YnI+Tm90YTo8L2I+IFJpY2V2ZXJhaSB1bmEgbm90aWZpY2EgYW5jaGUgcXVhbmRvIHF1YWxjdW5vIG1vZGlmaWNhIGlsIHN1byBjb21tZW50byFcIixcblx0XCJDT01NRU5UXCI6IFwiQ29tbWVudG9cIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIlJpY2V2ZXJhaSB1bmEgbm90aWZpY2EgcXVhbmRvIHF1YWxjdW5vIGluaXppYSBvIHNtZXR0ZSBkaSBzZWd1aXJ0aSFcIixcblx0XCJNRU5USU9OU1wiOiBcIk1lbnppb25lXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlJpY2V2ZXJhaSB1bmEgbm90aWZpY2EgcXVhbmRvIHF1YWxjdW5vIHRpIG1lbnppb25hIGluIHVuIHN1byBwb3N0IG8gY29tbWVudG8hXCIsXG5cdFwiUkVTVEVFTVwiOiBcIkNvbmRpdmlkaVwiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIlJpY2V2ZXJhaSB1bmEgbm90aWZpY2EgcXVhbmRvIHF1YWxjdW5vIGNvbmRpdmlkZSBpbCB0dW8gcG9zdCFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYXppb25pXCIsXG5cdFwiVk9USU5HXCI6IFwiVm90b1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiSWwgcGVzbyBkZWwgdm90byBvIGxhIHBlcmNlbnR1YWxlIGluZmx1ZW56YW5vIGlsIHBvdGVyZSBkaSB2b3RvIG5lbGwnYXBwLCBjb3PDrCBwdW9pIHJlZ29sYXJlIGlsIHByZW1pbyBkZWwgdHVvIHZvdG8uIDxici8+PGJyLz48Yj5Ob3RhOjwvYj4gcXVlc3RvIGNhbWJpZXLDoCBhbmNoZSBwZXNvL3BlcmNlbnR1YWxlIGRlbCBkb3dudm90ZS5cIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJhY2NvbWFuZGF0aVwiLFxuXHRcIlNBVkVfQ0hBTkdFU1wiOiBcIlNhbHZhIGxlIG1vZGlmaWNoZVwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiSW5mbyBWb3RhbnRpXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiQmVudG9ybmF0byFcIixcblx0XCJMT0dJTl8xXCI6IFwiQWNjZWRpIGZvcm5lbmRvIGlsIHR1byBOb21lIFV0ZW50ZSBlIGxhIHR1YSBQYXNzd29yZCBwZXIgY29udGludWFyZS5cIixcblx0XCJMT0dJTl8yXCI6IFwiTGEgXFxcInBvc3Rpbmcga2V5XFxcIiB2aWVuZSB1c2F0YSBwZXIgcHViYmxpY2FyZSBudW92aSBwb3N0IGUgY29tbWVudGksIHBlciB2b3RhcmUsIGUgcGVyIGdlc3RpcmUgY2hpIHNlZ3VpXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkxhIFxcXCJhY3RpdmUga2V5XFxcIiDDqCB1dGlsaXp6YXRhIHBlciBpIHRyYXNmZXJpbWVudGkgZSBwZXIgYWdnaW9ybmFyZSBsYSBmb3RvIGRlbCBwcm9maWxvLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJMZSB0dWUgY3JlZGVuemlhbGkgc29ubyBtZW1vcml6emF0ZSBsb2NhbG1lbnRlIHN1bCBkaXNwb3NpdGl2by4gU2UgZmFpIGlsIExvZ291dCBsZSBjcmVkZW56aWFsaSB2ZXJyYW5ubyByaW1vc3NlIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIk5vbiBoYWkgdW4gYWNjb3VudD9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcIlJlZ2lzdHJhdGkgb3JhXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQ2FuY2VsbGFcIixcblx0XCJBRFZBTkNFRFwiOiBcIkF2YW56YXRlXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkNoaWF2ZSBwcml2YXRhIGF0dGl2YVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiQ2hpYXZlIFByaXZhdGEgcGVyIHB1YmJsaWNhemlvbmVcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIlBhc3N3b3JkIHByaW5jaXBhbGVcIixcblx0XCJVU0VSTkFNRVwiOiBcIk5vbWUgVXRlbnRlXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiVmlzdGEgZXN0ZXNhXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVmlzdGEgY29tcGF0dGFcIixcblx0XCJTRUFSQ0hcIjogXCJDZXJjYVwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiSW5zZXJpc2NpIHVuIGFydGljb2xvXCIsXG5cdFwiUkVQTFlUT1wiOiBcIlJpc3BvbmRpIGFcIixcblx0XCJQT1NUXCI6IFwiUHViYmxpY2FcIixcblx0XCJQUkVWSUVXXCI6IFwiQW50ZXByaW1hXCIsXG5cdFwiREVGQVVMVFwiOiBcIlByZWRlZmluaXRvIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJQb3dlciBVcCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJSaWZpdXRhIHJpY29tcGVuc2FcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNBTFZBIFBFUiBET1BPXCIsXG5cdFwiQ0xFQVJcIjogXCJDQU5DRUxMQVwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlRlc3RvIGRlbCBwb3N0XCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiVGVzdG8gZGVsIGNvbW1lbnRvXCIsXG5cdFwiVElUTEVcIjogXCJUaXRvbG9cIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk5PTiBUUk9WQVRPXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJDb25mZXJtYSBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJTkNPUlJFVFRPXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiYXBlcnR1cmEgcG9zdFwiLFxuXHRcIlNFVF9QSU5cIjogXCJJbXBvc3RhIFBJTlwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIkluc2VyaXNjaSBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJTZWkgc2ljdXJvP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiSWwgcmVibG9nIMOoIGlycmV2ZXJzaWJpbGUsIHZ1b2kgY29udGludWFyZT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJFcnJvcmUgZGkgdHJhc21pc3Npb25lLCByaXByb3ZhIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJTdWNjZXNzb1wiLFxuXHRcIlJFQkxPR0dFRF9QT1NUXCI6IFwiUG9zdCBjb25kaXZpc28hXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIkFjY2Vzc28gZmFsbGl0byEgUGVyIGZhdm9yZSwgYXNzaWN1cmF0aSBkaSBhdmVyIHJpY2hpZXN0byBsJ2FjY2Vzc28gdHJhbWl0ZSBsYSB0dWEgcGFzc3dvcmQgcHJpbmNpcGFsZSBvIGF2ZW5kbyBpbnNlcml0byBsYSBcXFwiUG9zdGluZyBwcml2YXRlIGtleVxcXCIgc2UgaGFpIHNjZWx0byBsYSBtb2RhbGl0w6AgQXZhbnphdGEuXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiQWNjZXNzbyBmYWxsaXRvISBQZXIgZmF2b3JlLCBhc3NpY3VyYXRpIGRpIGF2ZXIgcmljaGllc3RvIGwnYWNjZXNzbyB0cmFtaXRlIGxhIHR1YSBwYXNzd29yZCBwcmluY2lwYWxlIG8gYXZlbmRvIGluc2VyaXRvIGxhIHR1YSBcXFwiQWN0aXZlIHByaXZhdGUga2V5XFxcIiBzZSBoYWkgc2NlbHRvIGxhIG1vZGFsaXTDoCBBdmFuemF0YS5cIixcblx0XCJXQVJOSU5HXCI6IFwiQXR0ZW56aW9uZVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RhemlvbmUgcGVyIGlsIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdGF0byBwZXIgaWwgdGVzdGltb25pYWxcIixcblx0XCJBR09cIjogXCJmYVwiLFxuXHRcIkZST01fTk9XXCI6IFwiZGEgb3JhXCIsXG5cdFwiU0VDU1wiOiBcInNlY29uZGlcIixcblx0XCJBX01JTlwiOiBcInVuIG1pbnV0b1wiLFxuXHRcIk1JTlNcIjogXCJtaW51dGlcIixcblx0XCJBTl9IT1VSXCI6IFwidW4nb3JhXCIsXG5cdFwiSE9VUlNcIjogXCJvcmVcIixcblx0XCJBX0RBWVwiOiBcInVuIGdpb3Jub1wiLFxuXHRcIkRBWVNcIjogXCJnaW9ybmlcIixcblx0XCJBX01PTlRIXCI6IFwidW4gbWVzZVwiLFxuXHRcIk1PTlRIU1wiOiBcIm1lc2lcIixcblx0XCJBX1lFQVJcIjogXCJ1biBhbm5vXCIsXG5cdFwiWUVBUlNcIjogXCJhbm5pXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW51dGkgZGkgbGV0dHVyYS5cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiRG93bnZvdGUgbyBzZWduYWxhXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiU2NhdHRhIEZvdG9cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIlNlbGV6aW9uYSBmb3RvXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJJbXBvc3RhIFVSTCBwZXJzb25hbGl6emF0YVwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiSW5zZXJpc2NpIEltbWFnaW5lXCIsXG5cdFwiRVJST1JcIjogXCJFcnJvcmVcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJFcnJvcmUgZHVyYW50ZSBpbCBjYXJpY2FtZW50b1wiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJDYW1lcmEgY2FuY2VsbGF0YVwiLFxuXHRcIlNFVF9VUkxcIjogXCJJbXBvc3RhIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJMaW5rIHdlYiBkaXJldHRvIHBlciBsJ2ltbWFnaW5lXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21tZW50byBpbnNlcml0byFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkxhIGNhbmNlbGxhemlvbmUgZGVpIGNvbW1lbnRpIMOoIGlycmV2ZXJzaWJpbGUuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJDb21tZW50byByaW1vc3NvXCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCJTdG8gY2FyaWNhbmRvIGwnaW1tYWdpbmVcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiQ2FyaWNhbWVudG8gY29tcGxldGF0b1wiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJDYXJpY2FtZW50byBmYWxsaXRvXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiTm9tZSBVdGVudGUgbyBQYXNzd29yZCBlcnJhdGlcIixcblx0XCJJTkZPXCI6IFwiSW5mb1wiLFxuXHRcIlFSX1RFWFRcIjogXCJQb3NpemlvbmEgdW4gY29kaWNlIFFSIGFsbCdpbnRlcm5vIGRlbGwnYXJlYSBkaSBzY2Fuc2lvbmVcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJBc3NpY3VyYXRpIGNoZSBpbCB0dW8gYmlsYW5jaW8gc2lhIHN1ZmZpY2llbnRlIHBlciBsYSB0cmFuc2F6aW9uZVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJMJ3V0ZW50ZSBhIGN1aSBzdGFpIGNlcmNhbmRvIGRpIHRyYXNmZXJpcmUgZGVpIGZvbmRpIG5vbiBlc2lzdGUhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIlNlaSBzaWN1cm8gZGkgdm9sZXIgcHJvY2VkZXJlIGNvbiBpbCB0cmFzZmVyaW1lbnRvP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZlcm1hXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJMYSB0cmFuc2F6aW9uZSDDqCBzdGF0YSB0cmFzbWVzc2FcIixcblx0XCJGRUVEXCI6IFwiRmVlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiRGkgdGVuZGVuemFcIixcblx0XCJIT1RcIjogXCJQb3BvbGFyaVwiLFxuXHRcIk5FV1wiOiBcIk51b3ZvXCIsXG5cdFwiUFJPTU9URURcIjogXCJTcG9uc29yaXp6YXRpXCIsXG5cdFwiVk9URVNcIjogXCJWb3RpXCIsXG5cdFwiUEFZT1VUXCI6IFwiUGFnYW1lbnRvXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJDb21tZW50aVwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVHJlbmRpbmcgcGVyIDMwIGdpb3JuaVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIk9yZGluYSBwZXI6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiQ2ljbG8gZGVpIHBhZ2FtZW50aVwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQYXlvdXQgcG90ZW56aWFsZVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiUGF5b3V0IHBhc3NhdG9cIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiUmljb21wZW5zYSBkZWxsJ2F1dG9yZVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlJpY29tcGVuc2EgZGVpIGN1cmF0b3JpXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJMJ2FydGljb2xvIMOoIHN0YXRvIGluc2VyaXRvIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJJbnNlcmlzY2kgUG9ydCBwacO5IHRhcmRpIVwiLFxuXHRcIlNBVkVEXCI6IFwiU2FsdmF0b1wiLFxuXHRcIkNMRUFSRURcIjogXCJDYW5jZWxsYXRvXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIlNlZ25hbGFyZSB1biBwb3N0IHB1w7IgYW5udWxsYXJlIGxlIHJpY29tcGVuc2UgZSByZW5kZXJlIHF1ZXN0byBtYXRlcmlhbGUgbWVubyB2aXNpYmlsZS4gPGJyPjxicj4gTGEgc2VnbmFsYXppb25lIGRvdnJlYmJlIGVzc2VyZSB1c2F0YSBwZXIgaSBzZWd1ZW50aSBtb3Rpdmk6IDx1bD4gdHJ1ZmZhIG8gUGxhZ2lvIDwvbGk+PGxpPiBpbmNpdGF6aW9uZSBhbGwnb2RpbyBvIFRyb2xsaW5nIDwvbGk+PGxpPiBwb3N0IGluc2VyaXRpIGludGVuemlvbmFsbWVudGUgaW4gY2F0ZWdvcmllIGVycmF0ZSBvIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiTGltaXRlIHJhZ2dpdW50by4gVmVyaWZpY2EgYWx0cmkgdHJlbmQvdGFncyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJJbCBwb3N0IMOoIHN0YXRvIHJpbW9zc28gZGFpIHNlZ25hbGlicmkhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIklsIHBvc3Qgw6ggc3RhdG8gYWdnaXVudG8gYWkgc2VnbmFsaWJyaSFcIixcblx0XCJSRVNFVFwiOiBcIlJlaW1wb3N0YVwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiTW9kaWZpY2EgbGEgRm90byBkZWwgUHJvZmlsb1wiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiTW9kaWZpY2EgbCdpbW1hZ2luZSBkaSBjb3BlcnRpbmFcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJQZXIgZmF2b3JlLCBpbnNlcmlzY2kgbGEgdHVhIFxcXCJBY3RpdmUgcHJpdmF0ZSBrZXlcXFwiIHNlIGhhaSBzY2VsdG8gbCdhY2Nlc3NvIGluIG1vZGFsaXTDoCBBdmFuemF0YSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJRdWVzdGEgYXppb25lIHJlc2V0dGVyw6AgbCdpbW1hZ2luZSBkZWwgcHJvZmlsb1wiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIlF1ZXN0YSBhemlvbmUgcmVzZXR0ZXLDoCBsJ2ltbWFnaW5lIGRpIGNvcGVydGluYVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiVW4gYWdnaW9ybmFtZW50byBsYXRvIHNlcnZlciByaWNoaWVkZSBpbCBSaWF2dmlvIGRlbGwnYXBwbGljYXppb25lIVwiLFxuXHRcIlNFVFRJTkdTX1VQREFURURcIjogXCJJbXBvc3RhemlvbmkgYWdnaW9ybmF0ZSFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJMaW5ndWFcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIlF1aSBwdW9pIGNhbWJpYXJlIGxhIGxpbmd1YSBkZWxsJ2FwcFwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJRdWVzdGEgb3BlcmF6aW9uaSByaWNoaWVkZSBjaGUgbCd1dGVudGUgYWJiaWEgZWZmZXR0dWF0byBsJ2FjY2Vzc28uIFBlciBmYXZvcmUsIGFjY2VkaSBlIHJpcHJvdmEuXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGxlcmlhIEltbWFnaW5pXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiVHJhZHV0dG9yaVwiLFxuXHRcIlNIQVJFXCI6IFwiQ29uZGl2aWRpXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJBbHRyZSBhcHBsaWNhemlvbmlcIixcblx0XCJFWENIQU5HRVwiOiBcIlNjYW1iaW9cIixcblx0XCJEUkFGVFNcIjogXCJCb3p6ZVwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIklsIHBvc3Qgw6ggc3RhdG8gcmltb3NzbyBkYWxsZSBib3p6ZSFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiSWwgcG9zdCDDqCBzdGF0byBhZ2dpdW50byBhbGxlIGJvenplIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJUcmFzY2luYSBhIHNpbmlzdHJhIHBlciB2ZWRlcmUgbGUgb3B6aW9uaVwiLFxuXHRcIk1BTkFHRVwiOiBcIkdlc3Rpc2NpXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltbWFnaW5lIHJpbW9zc2FcIixcblx0XCJDT1BZXCI6IFwiQ29waWFcIixcblx0XCJOT19JTUFHRVwiOiBcIk5vbiBoYWkgYW5jb3JhIGNhcmljYXRvIHVuJ2ltbWFnaW5lIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiVHJhc2NpbmEgaW4gYmFzc28gcGVyIGFnZ2lvcm5hcmVcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBwbGljYXppb25pIGVzdGVybmVcIixcblx0XCJQTFVHSU5TXCI6IFwiUGx1Z0luc1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTdWdnZXJpc2NpXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJQcm9zc2ltYW1lbnRlXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJRdWkgcHVvaSBjYW1iaWFyZSBsYSBibG9ja2NoYWluIG8gbGEgcGlhdHRhZm9ybWEgcHJlZGVmaW5pdGEuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJWYWx1dGFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiUXVpIHB1b2kgbW9kaWZpY2FyZSBsYSB0dWEgdmFsdXRhIHByZWRlZmluaXRhLiBWZWRyYWkgaWwgdmFsb3JlIGRpIHJpY29tcGVuc2EgcG9zdC9jb21tZW50byBpbiBxdWVzdGEgdmFsdXRhLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIGRlbGxlIGZ1bnppb25hbGl0w6A8L2I+PGJyPi0gQWNjZXNzbyBhZ2xpIGFydGljb2xpIHN1bGxlIHRlbWF0aWNoZSBkaSB2b3N0cm8gaW50ZXJlc3NlLiA8YnI+LSBJbnRlcmF6aW9uZSBjb24gZ2xpIGF1dG9yaSBkZWdsaSBhcnRpY29saSBjb21tZW50YW5kbyBlIGRpc2N1dGVuZG8gc3VnbGkgYXJnb21lbnRpLjxicj4tIFBvc3NpYmlsaXTDoCBkaSB2b3RhcmUgaSBwb3N0IHBlciByaWNvbXBlbnNhcmUgZ2xpIGF1dG9yaSBlLCBhbGxvIHN0ZXNzbyB0ZW1wbywgZ3VhZGFnbmFyZSByaWNvbXBlbnNlIGRhaSB2b3RpIGRhdGkuPGJyPi0gUG9zc2liaWxpdMOgIGRpIHB1YmJsaWNhcmUgaSB2b3N0cmkgYXJ0aWNvbGksIHBvc3RhcmxpIHN1bCBibG9nIGdyYXR1aXRhbWVudGUgZSBndWFkYWduYXJlIHJpY29tcGVuc2UgaW50ZXJhZ2VuZG8gZSBpbmNyZW1lbnRhbmRvIGlsIG51bWVybyBkZWkgZm9sbG93ZXJzLiA8YnI+LSBQb3NzaWJpbGl0w6AgZGkgc2NyaXZlcmUgYXJ0aWNvbGkgZGEgcHViYmxpY2FyZSwgc2FsdmFuZG8gbGUgYm96emUgcGVyIHB1YmJsaWNhcmxpIGluIHNlZ3VpdG8uPGJyPi0gVXRpbGl6em8gZGkgdW4gXFxcInNlZ25hbGlicm9cXFwiIHBlciBnbGkgYXJ0aWNvbGkgcHJlZmVyaXRpLCBpbiBtb2RvIGRhIHBvdGVybGkgbGVnZ2VyZSBzdWNjZXNzaXZhbWVudGUuPGJyPi0gUG9zc2liaWxpdMOgIGRpIHNjYW1iaWFyZSBvIGluY2Fzc2FyZSBpIHZvc3RyaSBndWFkYWduaS48YnI+LSBQb3NzaWJpbGl0w6AgZGkgaW52aWFyZSBpIHZvc3RyaSBmb25kaSBhZCBhbHRyaSBhdXRvcmkgbyB1dGVudGksIGFtaWNpLCBmb2xsb3dlcnMsIGV0Yy4gPGJyPi0gUmljZXJjYSBkZWkgdm9zdHJpIGZvbGxvd2VycyBlIGRlZ2xpIGF1dG9yaSBjaGUgc2VndWl0ZS48YnI+LSBSaWNlemlvbmUgZGkgbm90aWZpY2hlIHBlciByaW1hbmVyZSBhZ2dpb3JuYXRpIHN1aSB2b3N0cmkgZm9sbG93ZXJzIGUgc3VsbGUgZGlzY3Vzc2lvbmkgaW4gY3VpIHNpZXRlIGNvaW52b2x0aS4gPGJyPi0gUmljZXJjYSBkaSBhcnRpY29saSBwZXIgdGFncy9jYXRlZ29yaWUgZGkgdm9zdHJvIGludGVyZXNzZSBlIGF1dG9yaS48YnI+LSBQb3NzaWJpbGl0w6AgZGkgcGVyc29uYWxpenphcmUgaWwgcHJvcHJpbyBwcm9maWxvLjxicj4tIE1vbHRlIGFsdHJlIGZ1bnppb25hbGl0w6Agc29ubyBpbiBmYXNlIGRpIHN2aWx1cHBvLjxicj48YnI+PGI+U2ljdXJlenphPC9iPjxicj4xLiBMJ0FwcGxpY2F6aW9uZSBub24gYXZyw6AgbWFpIGFjY2Vzc28gYWkgZm9uZGkgZGVnbGkgdXRlbnRpIG7DqCBsaSBwb3Ryw6AgZGV0ZW5lcmUuIDxicj4yLiBMJ0FwcGxpY2F6aW9uZSBvZmZyZSB1biBtb2RlbGxvIGRpIHNpY3VyZXp6YSBDbGllbnQtc2lkZSwgY29uIENoaWF2aSBwcml2YXRlIGRldGVudXRlIGxvY2FsbWVudGUgZSBtYWkgaW52aWF0ZSBhZCBhbGN1biBzZXJ2ZXIuIFR1IHN0ZXNzbyBzYXJhaSByZXNwb25zYWJpbGUgZGkgZmFyZSBpbCBiYWNrdXAgZGVsbGUgdHVlIENoaWF2aSBQcml2YXRlL1Bhc3N3b3Jkcy4gPGJyPjMuIEwnQXBwbGljYXppb25lIG9mZnJlIGludGVyZmFjY2lhIGVkIGVzcGVyaWVuemUgc2VtcGxpY2UgZSBhdHRyYWVudGkgcGVyIGwndXRlbnRlLiA8YnI+NC4gTCdBcHBsaWNhemlvbmUgb2ZmcmUgdW4gdWx0ZXJpb3JlIGxpdmVsbG8gZGkgc2ljdXJlenphIHRyYW1pdGUgbCd1c28gZGkgY29kaWNlIFBpbi4gPGJyPjxicj5lU3RlZW0gc3VwcG9ydGEgbGUgcGlhdHRhZm9ybWUgZGkgU3RlZW0gZSBkaSBHb2xvcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkZvbmRhdG9yZSBlIHJlc3BvbnNhYmlsZSBkZWxsbyBzdmlsdXBwb1wiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiQWdnaXVuZ2kgYWNjb3VudFwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGlhdHRhZm9ybWFcIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJEZXBvc2l0YXJpb1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlNjYWRlbnphIGRlbGxhIHJhdGlmaWNhemlvbmVcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIlNjYWRlbnphIGRlbCBkZXBvc2l0b1wiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJUYXNzYSBkZWwgZGVwb3NpdG9cIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJDb25kaXppb25pIGUgdGVybWluaSBkZWwgRGVwb3NpdG9cIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTW9kYWxpdMOgIG5vdHR1cm5hXCIsXG5cdFwiREFZX01PREVcIjogXCJNb2RhbGl0w6AgZGl1cm5hXCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwiTW9zdHJhIGlsIHRlc3RvIGNvbXBsZXRvXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcIlV0ZW50ZSBub24gdHJvdmF0b1wiLFxuXHRcIkFQUFJPVkVcIjogXCJBcHByb3ZhXCIsXG5cdFwiRElTUFVURVwiOiBcIkNvbnRyb3ZlcnNpYVwiLFxuXHRcIlJFTEVBU0VcIjogXCJSaWxhc2NpYVwiLFxuXHRcIkZST01cIjogXCJEYVwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJJbnNlcmlzY2lcIixcblx0XCJSRUNFSVZFUlwiOiBcIkRlc3RpbmF0YXJpb1wiLFxuXHRcIkxPQ0FUSU9OXCI6IFwiTG9jYWxpdMOgXCIsXG5cdFwiV0VCU0lURVwiOiBcIlNpdG8gV2ViXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiVmlzdWFsaXp6YSBub21lXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIktlZGlhbWFuXCIsXG5cdFwiTE9HSU5cIjogXCJMb2cgTWFzdWtcIixcblx0XCJMT0dPVVRcIjogXCJMb2cgS2VsdWFyXCIsXG5cdFwiUFJPRklMRVwiOiBcIlByb2ZpbFwiLFxuXHRcIkZPTExPV1wiOiBcIklrdXRcIixcblx0XCJCT09LTUFSS1NcIjogXCJQZW5hbmRhIGJ1a3VcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlBpbmRhaFwiLFxuXHRcIk1BUktFVFwiOiBcIlBhc2FyXCIsXG5cdFwiU0VUVElOR1NcIjogXCJUZXRhcGFuXCIsXG5cdFwiQUJPVVRcIjogXCJNZW5nZW5haVwiLFxuXHRcIkFCT1VUXzFcIjogXCJkaSBtYW5hIGFuZGEgdGVyaW1hIGdhbmphcmFuIHVudHVrIGlzaSBrYW5kdW5kYW4gYW5kYSFcIixcblx0XCJBQk9VVF8yXCI6IFwiZGlrdWFzYWkgb2xlaCBwbGF0Zm9ybSB7e3BsYXRmb3JtbmFtZX19LCBhcGxpa2FzaSBkaWNpcHRhIG9sZWguXCIsXG5cdFwiQUJPVVRfM1wiOiBcImRhbiBpYW55YSBzdW1iZXIgdGVyYnVrYSwga29tdW5pdGkgeWFuZyBkaWRvcm9uZyBvbGVoIHByb2playBtdWRhaCBhbGloLiBJYSBtZW5hd2Fya2FuIGFrc2VzIGthbmR1bmdhbiB1bnR1ayBtZW1iYWNhLCBtZW5ndWxhcywgbWVuZ3VuZGksIHBvc3RpbmcsIHBlbWluZGFoYW4gcGVuZGFwYXRhbiwgZGFuIGxhaW4tbGFpbiBjaXJpLWNpcmkgeWFuZyBkaXRhd2Fya2FuIG9sZWgge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGRhbiB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIEFwbGlrYXNpIGluaSB0aWRhayBtZW1weW55YWkgYWtzZXMga2UgYWthdW4gYW5kYS5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQXBsaWthc2kgbWVuYXdhcmthbiBrZXNlbGFtYXRhbi1rbGllbiwgZGVuZ2FuIGt1bmNpIHBlcmliYWRpIHlhbmcgZGlob3NrYW4gZGFsYW0gdGVtcGF0YW4gZGFuIHRpZGFrIGFrYW4gZGloYW50YXIga2UgbWFuYS1tYW5hIHNlcnZlciBsYWluLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBBcGxpa2FzaSBtZW5hd2Fya2FuIGFudGFyYW11a2EgcGVuZ2d1bmEgeWFuZyBtdWRhaCBkYW4gbWVuYXJpay5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gQXBsaWthc2kgdGlkYWsgYWthbiBtZW1lcmx1a2FuIHBlbmdndW5hIHVudHVrIG1lbWFzdWtrYW4gbWFrbHVtYXQgcGVyaWJhZGkuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlVuZGkgZ29vZC1rYXJtYSBzZWJhZ2FpIHNha3NpXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkh1YnVuZ2kvTWFrbHVtIGJhbGFzOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiSW5mbyBsYW5qdXQ6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiTWVtYnVhbmdcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIkdhbWJhcmFuIFBhc2FyYW5cIixcblx0XCJQUklDRVwiOiBcIkhhcmdhXCIsXG5cdFwiQU1PVU5UXCI6IFwiSnVtbGFoXCIsXG5cdFwiVE9UQUxcIjogXCJKdW1sYWhcIixcblx0XCJOT09SREVSU1wiOiBcIlBlc2FuYW4gdGlkYWsgdGVyYnVrYSB1bnR1a1wiLFxuXHRcIkRBVEVcIjogXCJUYXJpa2hcIixcblx0XCJCVVlcIjogXCJCZWxpXCIsXG5cdFwiU0VMTFwiOiBcIk1lbmp1YWxcIixcblx0XCJPUEVOXCI6IFwiRGlidWthXCIsXG5cdFwiSElTVE9SWVwiOiBcIlNlamFyYWhcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIklrdXQga2VtYmFsaVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiRGlpa3V0aVwiLFxuXHRcIlVORk9MTE9XXCI6IFwiQmVyaGVudGlcIixcblx0XCJGT0xMT1dJTkdcIjogXCJCZXJpa3V0XCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiRm9sbG93ZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIkNhcmkgcGVuZ2lrdXRcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiQ2FyaSBwZW5naWt1dFwiLFxuXHRcIkJZXCI6IFwib2xlaFwiLFxuXHRcIklOXCI6IFwiZGFsYW1cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiUGVuYW5kYSBidWt1XCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVibG9nXCIsXG5cdFwiVVBWT1RFXCI6IFwiVW5kaSBuYWlrXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJVbmRpIChuZWdhdGlmKVwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCJCYXRhbGthbiB1bmRpIChuZWdhdGlmKVwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiQmF0YWxrYW4gdW5kaVwiLFxuXHRcIlJFUExZXCI6IFwiSmF3YXBhblwiLFxuXHRcIkVESVRcIjogXCJFZGl0XCIsXG5cdFwiUE9TVF8xXCI6IFwiU2FwdSBrZSBraXJpIGF0YXMga29tZW4gdW50dWsgbWVsaWhhdCBvcHN5ZW5cIixcblx0XCJQT1NUXzJcIjogXCJLZXR1ayBhdGFzIGtvbWVuIHVudHVrIG1lbGloYXQgc3ViLWtvbWVuXCIsXG5cdFwiT1BUSU9OU1wiOiBcIlBpbGloYW5cIixcblx0XCJSRVNURUVNRURfQllcIjogXCJSZWJsb2dnZWQgb2xlaFwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIlRJQURBIEFQQSBESSBTSU5JXCIsXG5cdFwiQkFMQU5DRVNcIjogXCJCYWtpXCIsXG5cdFwiUFJPRklMRV8xXCI6IFwie3twbGF0Zm9ybW5hbWV9fSwgdG9rZW4gY2FpciB5YW5nIGJvbGVoIGRpcGluZGFoa2FuIHBhZGEgYmlsYS1iaWxhIG1hc2EuIHt7cGxhdGZvcm1uYW1lfX0gYm9sZWggZGl0dWthciBrZXBhZGEge3twbGF0Zm9ybXBvd2VyfX0gZGkgZGFsYW0gcHJvc2VzIHlhbmcgZGlwYW5nZ2lsIG1lbmphbmFrYW4uXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sIHBlbmdhcnVoIHRva2VuIHlhbmcgbWVuZGFwYXQga3Vhc2EgeWFuZyBsZWJpaCB1bnR1ayBwZWdhbmdhbiBqYW5na2EgcGFuamFuZyBkYW4gcGVuZ3VuZGlhbiBrZSBhdGFzIHBvc3RpbmcuIExlYmloIGJhbnlhayBzZXNlb3JhbmcgbWVtZWdhbmcgbGViaWggYmFueWFrIHlhbmcgYm9sZWggbWVtcGVuZ2FydWhpIGdhbmphcmFuIGxhaW4gZGFuIG1lbmRhcGF0IGdhbmphcmFuIHVudHVrIHVuZGlhbiB5YW5nIHRlcGF0LlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlRva2VuIGJlcm5pbGFpIGtpcmEta2lyYSB7e3BsYXRmb3Jtc3VuaXR9fSBkYXJpcGFkYSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIkFuZ2dhcmFuIG5pbGFpXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiTmlsYWkgYW5nZ2FyYW4gaW5pIGFkYWxhaCBiZXJkYXNhcmthbiBuaWxhaSBwdXJhdGEgNyBoYXJpIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlVydXMgbmlhZ2FcIixcblx0XCJQT1NUSU5HXCI6IFwiUEVORU1QQVRBTlwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIktla3VuY2kgcG9zdGluZyBkaWd1bmFrYW4gdW50dWsgcG9zdGluZyBkYW4gbWVuZ3VuZGkuIElhIGhhcnVzIGJlcmJlemEgZGFyaXBhZGEga2VrdW5jaSBha3RpZiBkYW4gcGVtaWxpay5cIixcblx0XCJPV05FUlwiOiBcIlBlbWlsaWtcIixcblx0XCJQUk9GSUxFXzZcIjogXCJLZWt1bmNpIHBlbWlsaWsgYWRhbGFoIGt1bmNpIHV0YW1hIHVudHVrIGFrYXVuIGRhbiBkaWtlaGVuZGFraSBtZW51a2FyIGtla3VuY2kgeWFuZyBsYWluLiBLdW5jaSBwZXJpYmFkaSBkYW4ga2F0YSBsYWx1YW4gdW50dWsgcGVtaWxpayBrdW5jaSBwZXJsdSBkaXNpbXBhbiBkaSBsdWFyIHRhbGlhbiBzZWJhbnlhayBtdW5na2luLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFrdGlmXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiS2VrdW5jaSB5YW5nIGFrdGlmIGRpZ3VuYWthbiB1bnR1ayBtZW1idWF0IHBlbWluZGFoYW4gZGFuIG1lbWJ1YXQgcGVzYW5hbiBkYWxhbSBwYXNhcmFuIGRhbGFtYW4uXCIsXG5cdFwiTUVNT1wiOiBcIk1lbW9cIixcblx0XCJQUk9GSUxFXzhcIjogXCJLZWt1bmNpIG1lbW8gZGlndW5ha2FuIHVudHVrIG1lbmNpcHRhIGRhbiBtZW1iYWNhIG1lbW8uXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIkphd2F0YW5cIixcblx0XCJSRVBMSUVTXCI6IFwiQmFsYXNhblwiLFxuXHRcIldBTExFVFwiOiBcIldhbGxldFwiLFxuXHRcIlRBR1wiOiBcIlRhZ1wiLFxuXHRcIlVTRVJcIjogXCJQZW5nZ3VuYVwiLFxuXHRcIkNMT1NFXCI6IFwiVHV0dXBcIixcblx0XCJUT1wiOiBcIlRvXCIsXG5cdFwiQVNTRVRcIjogXCJBc2V0XCIsXG5cdFwiU0VORFwiOiBcIkhhbnRhclwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiS2VzZWxhbWF0YW5cIixcblx0XCJBVkFJTEFCTEVcIjogXCJUZXJzZWRpYVwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwiTWVtbyBhd2FtXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlBlbmdndW5hIGNvbnRvaG55YSBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJLb2QgUGluXCIsXG5cdFwiUElOX1RFWFRcIjogXCJLb2QgUElOIG1lbWJhbnR1IGFuZGEgdW50dWsgbWVuZGFwYXRrYW4gYXBsaWthc2kgZGFuIGRhdGEgYW5kYS4gPGJyLz4gPGJyLz4gPGI+Tm90YTo8L2I+IFNlYmFpayBzYWhhamEgZGlib2xlaGthbiwgYW5kYSBtZW1wdW55YWkgbWFrc2ltdW0gNCBjdWJhIHVudHVrIG1lbWJ1a2EsIGppa2EgYW5kYSB0ZXJsdXBhIHBpbiBhdGF1IGdhZ2FsLCBhcGxpa2FzaSBha2FuIG1lbWFkYW0gbG9nIG1hc3VrIGRhdGEgcGVuZ2d1bmEuIEFuZGEgYm9sZWggbG9naW4gc2VtdWxhIGRhbiB0ZXJ1cyBtZW5nZ3VuYWthbiBhcGxpa2FzaS5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiV2FydGFcIixcblx0XCJWT1RFX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXQgcGVtYmVyaXRhaHVhbiBhcGFiaWxhIHNlc2VvcmFuZyB1bmRpIGthbmR1bmdhbiBhbmRhISA8YnIvPiA8Yj5Ob3RhOjwvYj4gcGVtYmVyaXRhaHVhbiB0ZXJtYXN1ayBtZW5ndW5kaSBiZXJhdCBzZXJ0YSBtZXNlaiBhbWFyYW4uIChzYW1hIGFkYSB1bmRpIChwb3NpdGlmKSwgdW5kaSAobmVnYXRpZiksIG1lbWJhdGFsa2FuIHVuZGkpLlwiLFxuXHRcIlZPVEVcIjogXCJWb3RlXCIsXG5cdFwiQ09NTUVOVF9URVhUXCI6IFwiQW5kYSBha2FuIG1lbmRhcGF0IHBlbWJlcml0YWh1YW4gYXBhYmlsYSBzZXNlb3JhbmcgYXRhdSBtZW1iZXJpIGtvbWVuIHBhZGEgcG9zdGluZyBhdGF1IGtvbWVuIGFuZGEhIDxici8+IDxiPk5vdGE6PC9iPiBQZW1iZXJpdGFodWFuIHRlcm1hc3VrIGFwYWJpbGEgc2VzZW9yYW5nIDxiPnN1bnRpbmdhbjwvYj4ga29tZW4gbWVyZWthIGp1Z2EuXCIsXG5cdFwiQ09NTUVOVFwiOiBcIktvbWVuXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXRrYW4gcGVtYmVyaXRhaHVhbiBhcGFiaWxhIHNlc2VvcmFuZyBtZW5naWt1dGkgYXRhdSBpa3V0IGFuZGEhXCIsXG5cdFwiTUVOVElPTlNcIjogXCJNZW55ZWJ1dFwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJBbmRhIGFrYW4gbWVuZGFwYXQgcGVtYmVyaXRhaHVhbiBhcGFiaWxhIHNlc2VvcmFuZyBtZW55ZWJ1dCBhbmRhIGRpIHBvc3Qva29tZW4hXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlJlYmxvZ1wiLFxuXHRcIlJFU1RFRU1fVEVYVFwiOiBcIkFuZGEgYWthbiBtZW5kYXBhdCBwZW1iZXJpdGFodWFuIGFwYWJpbGEgc2VzZW9yYW5nIHJlYmxvZyBwb3N0IGFuZGEhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJLb25maWd1cmFzaVwiLFxuXHRcIlZPVElOR1wiOiBcIk1lbmd1bmRpXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJCZXJhdCB1bmRpIGF0YXUgcGVyYXR1cyBtZW5qZWphc2thbiBrdWFzYSBtZW5ndW5kaSBwYWRhIGFwbGlrYXNpLCBzdXBheWEgYW5kYSBib2xlaCBtZW5nYXdhbCBnYW5qYXJhbiBtZW5ndW5kaS4gPGJyLz4gPGJyLz4gPGI+Tm90YTo8L2I+IEluaSBha2FuIG1lbmd1YmFoIGJlcmF0L3BlcmF0dXNhbiB1bmRpYW4gdW50dWsgdW5kaSAobmVnYXRpZikganVnYSBkYW4gaWEgYWRhbGFoIGRpIG1hbmEtbWFuYSBhcGxpa2FzaVwiLFxuXHRcIlNFUlZFUlwiOiBcIlNlcnZlclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiRGlzeW9ya2FuXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwiU2ltcGFuIHBlcnViYWhhblwiLFxuXHRcIlZPVEVSU19JTkZPXCI6IFwiSW5mbyBwZW5ndW5kaVwiLFxuXHRcIldFTENPTUVfQkFDS1wiOiBcIlNlbGFtYXQga2VtYmFsaSFcIixcblx0XCJMT0dJTl8xXCI6IFwiRGFmdGFyIE1hc3VrIGRlbmdhbiB1c2VybmFtZSBkYW4gcGFzc3dvcmQgYW5kYSB1bnR1ayB0ZXJ1c2thbi5cIixcblx0XCJMT0dJTl8yXCI6IFwiS3VuY2kgcG9zdGluZyBkaWd1bmFrYW4gdW50dWsgcG9zIGtvbWVuLCB1bmRpLCBpa3V0LlwiLFxuXHRcIkxPR0lOXzNcIjogXCJLdW5jaSBha3RpZiBkaWd1bmFrYW4gdW50dWsgcGVtaW5kYWhhbiBkYW4ga2VtYXNraW5pIGdhbWJhciBwcm9maWwuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIktlbGF5YWthbiBwZW5nZ3VuYSBkaXNpbXBhbiBzZWNhcmEgdGVtcGF0YW4gcGFkYSBwZXJhbnRpLiBBcGFiaWxhIGxvZyBrZWx1YXIga2VsYXlha2FuIGFrYW4gZGlrZWx1YXJrYW4hXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiVGlkYWsgYWRhIGFrYXVuP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiRGFmdGFybGFoIHNla2FyYW5nXCIsXG5cdFwiQ0FOQ0VMXCI6IFwiQmF0YWxcIixcblx0XCJBRFZBTkNFRFwiOiBcIkFkdmFuY2VkXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkt1bmNpIGFrdGlmIHBlcnNlbmRpcmlhblwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiS3VuY2kgcG9zdGluZyBwZXJzZW5kaXJpYW5cIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIkthdGEgbGFsdWFuIGluZHVrL3V0YW1hXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJOYW1hIFBlbmdndW5hXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiS2FkIHBhcGFyYW5cIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJQYXBhcmFuIHlhbmcgcGFkYXRcIixcblx0XCJTRUFSQ0hcIjogXCJDYXJpYW5cIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIkhhbnRhciBjZXJpdGFcIixcblx0XCJSRVBMWVRPXCI6IFwiQmFsYXMga2VwYWRhXCIsXG5cdFwiUE9TVFwiOiBcIkhhbnRhclwiLFxuXHRcIlBSRVZJRVdcIjogXCJQcmV2aWV3XCIsXG5cdFwiREVGQVVMVFwiOiBcIkxhbGFpIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJNZW5nZWt1YXNhaSAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJNZW5vbGFrIGJheWFyYW5cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIlNJTVBBTiBVTlRVSyBLRU1VRElBTlwiLFxuXHRcIkNMRUFSXCI6IFwiSkVMQVNcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJQb3N0IGthbmR1bmdhblwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIktvbWVuIGthbmR1bmdhblwiLFxuXHRcIlRJVExFXCI6IFwiVGFqdWtcIixcblx0XCJUQUdTXCI6IFwiVGFnc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIlRJREFLIFBBREFOXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJTYWhrYW4gUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiQkVUVUxcIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJwZW1idWthYW4gcG9zdFwiLFxuXHRcIlNFVF9QSU5cIjogXCJUZXRhcGthbiBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJNYXN1a2thbiBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJBZGFrYWggYW5kYSBwYXN0aT9cIixcblx0XCJSRUJMT0dfVEVYVFwiOiBcIlJlYmxvZyB0aWRhayBib2xlaCBkaWJhbGlra2FuLCBhZGFrYWggYW5kYSBwYXN0aSBoZW5kYWsgbWVuZXJ1c2thbj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJEaXNpYXJrYW4gcmFsYXQsIGN1YmEgbGFnaSFcIixcblx0XCJTVUNDRVNTXCI6IFwiS2VqYXlhYW5cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlJlYmxvZ2dlZCBwb3N0IVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJMb2cgbWFzdWsgZ2FnYWwhIFNpbGEgcGFzdGlrYW4gYW5kYSB0ZWxhaCBsb2cgbWFzdWsgZGVuZ2FuIGthdGEgbGFsdWFuIGluZHVrIGF0YXUga3VuY2kgcGVyaWJhZGkgcG9zdGluZyBhbmRhIGtlIGF0YXMgbG9nIG1hc3VrIGppa2EgYW5kYSB0ZWxhaCBtZW1pbGloIG1vZCBBZHZhbmNlZC5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJMb2cgbWFzdWsgZ2FnYWwhIFNpbGEgcGFzdGlrYW4gYW5kYSB0ZWxhaCBsb2cgbWFzdWsgZGVuZ2FuIGthdGEgbGFsdWFuIGluZHVrIGF0YXUga3VuY2kgcGVyaWJhZGkgcG9zdGluZyBhbmRhIGtlIGF0YXMgbG9nIG1hc3VrIGppa2EgYW5kYSB0ZWxhaCBtZW1pbGloIG1vZCBBZHZhbmNlZC5cIixcblx0XCJXQVJOSU5HXCI6IFwiQW1hcmFuXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIk1lbmd1bmRpIHVudHVrIHNha3NpXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJNZW5ndW5kaSB1bnR1ayBzYWtzaVwiLFxuXHRcIkFHT1wiOiBcIkxhbHVcIixcblx0XCJGUk9NX05PV1wiOiBcImRhcmkgc2VrYXJhbmdcIixcblx0XCJTRUNTXCI6IFwic2FhdFwiLFxuXHRcIkFfTUlOXCI6IFwibWluaXRcIixcblx0XCJNSU5TXCI6IFwibWluaXRcIixcblx0XCJBTl9IT1VSXCI6IFwic2VqYW1cIixcblx0XCJIT1VSU1wiOiBcImphbVwiLFxuXHRcIkFfREFZXCI6IFwic2F0dSBoYXJpXCIsXG5cdFwiREFZU1wiOiBcImhhcmlcIixcblx0XCJBX01PTlRIXCI6IFwic2VidWxhblwiLFxuXHRcIk1PTlRIU1wiOiBcImJ1bGFuXCIsXG5cdFwiQV9ZRUFSXCI6IFwic2V0YWh1blwiLFxuXHRcIllFQVJTXCI6IFwidGFodW5cIixcblx0XCJNSU5fUkVBRFwiOiBcIm1pbml0IG1lbWJhY2FcIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiVm90ZSAobmVnYXRpZikgYXRhdSBNZW5hbmRhaVwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIlRhbmdrYXAgZ2FtYmFyXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJQaWxpaCBnYW1iYXJcIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIlRldGFwa2FuIFVSTCBib2xlaC11YmFoXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJNYXN1a2thbiBnYW1iYXJcIixcblx0XCJFUlJPUlwiOiBcIlJhbGF0XCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiUmFsYXQgbXVhdCBuYWlrXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkthbWVyYSBUZWxhaCBEaWJhdGFsa2FuXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlRldGFwa2FuIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJQYXV0YW4gd2ViIGxhbmdzdW5nIGdhbWJhclwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiS29tZW4gZGloYW50YXIhXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJNZW5naGFwdXNrYW4ga29tZW4gdGlkYWsgYm9sZWggZGliYWxpa2thbi4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIktvbWVuIGRpaGFwdXNrYW5cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIk11YXQgTmFpayBHYW1iYXJcIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiTXVhdCBOYWlrIFNlbGVzYWlcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiTXVhdCBOYWlrIEdhZ2FsXCIsXG5cdFwiUEFTU1dPUkRfSU5DT1JSRUNUXCI6IFwiTmFtYSBha2F1biBhdGF1IGthdGEgbGFsdWFuIHRpZGFrIGJldHVsXCIsXG5cdFwiSU5GT1wiOiBcIk1ha2x1bWF0XCIsXG5cdFwiUVJfVEVYVFwiOiBcIkxldGFra2FuIEtvZCBRUiBkaSBkYWxhbSBrYXdhc2FuIGltYmFzYW5cIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJQYXN0aWthbiBhbmRhIG1lbXB1bnlhaSBiYWtpIHlhbmcgbWVuY3VrdXBpIHVudHVrIHRyYW5zYWtzaSFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiUGVuZ2d1bmEgeWFuZyBhbmRhIGN1YmEgdW50dWsgbWVtaW5kYWhrYW4gZGFuYSwgdGlkYWsgd3VqdWQhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIkFkYWthaCBhbmRhIHBhc3RpIGFuZGEgbWFodSBtZW1pbmRhaGthbj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJQZW5nZXNhaGFuXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJVcnVzIG5pYWdhIGRpc2lhcmthblwiLFxuXHRcIkZFRURcIjogXCJTdWFwYW5cIixcblx0XCJUUkVORElOR1wiOiBcIlRyZW5cIixcblx0XCJIT1RcIjogXCJQYW5hc1wiLFxuXHRcIk5FV1wiOiBcIkJhcnVcIixcblx0XCJQUk9NT1RFRFwiOiBcIkRpZ2FsYWtrYW5cIixcblx0XCJWT1RFU1wiOiBcIlVuZGlcIixcblx0XCJQQVlPVVRcIjogXCJQZW1iYXlhcmFuXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJLT01FTlRBUlwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwiVHJlbiB1bnR1ayAzMCBoYXJpXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiUG9zdGluZyBzdXN1biBvbGVoOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIktpdGFyYW4gcGVtYmF5YXJhblwiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQb3RlbnNpIFBlbWJheWFyYW5cIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlBlbWJheWFyYW4gTWFzYSBMYWx1XCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIkJheWFyYW4gUGVudWxpc1wiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlBlbWJheWFyYW4gQ3VyYXRpb25cIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIlBvcyBkaWhhbnRhciFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiUG9zIHVudHVrIHBlbmdoYW50YXJhbiBsZXdhdCFcIixcblx0XCJTQVZFRFwiOiBcInRlcnNpbXBhblwiLFxuXHRcIkNMRUFSRURcIjogXCJESVBBREFNS0FOXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIk1lbmFuZGEgYXRhdSB1bmRpYW4gKG5lZ2F0aWYpIHBvcyBib2xlaCBrZWx1YXJrYW4gZ2FuamFyYW4gZGFuIGphZGlrYW4gYmFoYW4gaW5pIGt1cmFuZyBrZWxpaGF0YW4uIDxicj48YnI+QmVuZGVyYSBoZW5kYWtsYWggZGlndW5ha2FuIHVudHVrIHBlcmthcmEtcGVya2FyYSBiZXJpa3V0OiA8dWw+PGxpPnBlbmlwdWFuIGF0YXUgcGxhZ2lhdDwvbGk+IDxsaT51Y2FwYW4gYmVuY2kgYXRhdSBJbnRlcm5ldCBUcm9sbGluZzwvbGk+IDxsaT5LYXRlZ29yaSB5YW5nIG1lbmdlbGlydWthbiBhdGF1IFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiSGFkIHBlbWludGFhbiBkaWNhcGFpLiBNZW55ZW1hayBhbGlyYW4gdGFnIGxhaW4hXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiUG9zIGRpYWxpaCBrZWx1YXIgZGFyaXBhZGEgcGVuYW5kYSFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwiUG9zdCBkaXRhbWJhaCBrZSBwZW5hbmRhIVwiLFxuXHRcIlJFU0VUXCI6IFwiVGV0YXBrYW4gc2VtdWxhXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJUdWthciBHYW1iYXIgUHJvZmlsXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJUdWthciBHYW1iYXIgQ292ZXJcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCJTaWxhIGJlcmlrYW4ga3VuY2kgcGVyaWJhZGkgeWFuZyBha3RpZiBqaWthIGFuZGEgdGVsYWggbWVtaWxpaCBtb2QgbG9naW4gbWFqdSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJJbmkgYWthbiBtZW5ldGFwa2FuIHNlbXVsYSBnYW1iYXIgcHJvZmlsIHBlbmdndW5hXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiSW5pIGFrYW4gbWVuZXRhcGthbiBzZW11bGEgZ2FtYmFyIHByb2ZpbCBwZW5nZ3VuYVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiS2VtYXNraW5pIHBlbGF5YW4gbWVtZXJsdWthbiByZXNldCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiVGV0YXBhbiBkaWtlbWFza2luaSFcIixcblx0XCJMQU5HVUFHRVNcIjogXCJCQUhBU0FcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkRpIHNpbmkgYW5kYSBib2xlaCBtZW51a2FyIGJhaGFzYSBkYXJpcGFkYSBhcGxpa2FzaSBpbmkuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIk9wZXJhc2kgaW5pIG1lbWVybHVrYW4gcGVuZ2d1bmEgbG9nIG1hc3VrIGRlbmdhbiBrYXRhIGxhbHVhbiB1dGFtYSwga2VrdW5jaSBha3RpZi9wb3N0aW5nLiBTaWxhIGxvZyBtYXN1ayBkYW4gY3ViYSBsYWdpLlwiLFxuXHRcIkdBTExFUllcIjogXCJHQUxFUklcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJURVJKRU1BSEFOXCIsXG5cdFwiU0hBUkVcIjogXCJLb25nc2lcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIlBhc2FyYW5cIixcblx0XCJFWENIQU5HRVwiOiBcIlBlcnR1a2FyYW5cIixcblx0XCJEUkFGVFNcIjogXCJEcmFmXCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwiUG9zIGRpYWxpaCBrZWx1YXIgZGFyaXBhZGEgZHJhZiFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiUG9zdCBkaXRhbWJhaCBrZXBhZGEgZHJhZiFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiU2FwdSBraXJpIHVudHVrIG1lbGloYXQgb3BzeWVuXCIsXG5cdFwiTUFOQUdFXCI6IFwiVXJ1c1wiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJJbWVqIGRpa2VsdWFya2FuXCIsXG5cdFwiQ09QWVwiOiBcIlNhbGluXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJBbmRhIHRpZGFrIHVwbG9hZCBnYW1iYXIgYXBhLWFwYSwgbGFnaSFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIlRhcmlrIGtlIGJhd2FoIHVudHVrIG1lbXVhdCBzZW11bGFcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiQXBsaWthc2kgbHVhcmFuXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpblwiLFxuXHRcIlNVR0dFU1RcIjogXCJDYWRhbmdrYW5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkFrYW4gZGF0YW5nXCIsXG5cdFwiQ0hBSU5cIjogXCJDaGFpblwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJEaSBzaW5pIGFuZGEgYm9sZWggbWVudWthciBwbGF0Zm9ybSBibG9ja2NoYWluIGF0YXUgbGFsYWkuXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJNYXRhd2FuZ1wiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJEaSBzaW5pIGFuZGEgYm9sZWggbWVudWthciBNYXRhIFdhbmcgbGFsYWkgYW5kYS4gQW5kYSBha2FuIG1lbGloYXQgcG9zdC9rb21lbiBnYW5qYXJhbiBuaWxhaSBNYXRhIFdhbmcgaW5pLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPlNlbmFyYWkgY2lyaS1jaXJpPC9iPiA8YnI+YWtzZXMgdW5payBhcnRpa2VsIGRhbGFtIG1hbmEtbWFuYSBzdWJqZWsgYW5kYSBiZXJtaW5hdCBtZW1iYWNhLiA8YnI+IC1NZWxpYmF0a2FuIGRpcmkgZGVuZ2FuIHBlbnVsaXMgb2xlaCBtZW5ndWxhcywgbWVtYmluY2FuZ2thbiB0b3Bpay4gPGJyPi1QZW5ndW5kaWFuIGJhZ2kgamF3YXRhbiBrZXBhZGEgcGVuZ2FyYW5nIGdhbmphcmFuIHNlcnRhIG1lbmRhcGF0IGdhbmphcmFuIGN1cmF0aW9uLiA8YnI+LVNpYXJrYW4gYXJ0aWtlbCwgcG9zdGluZyBibG9nIGFuZGEgZGFuIGhvc3QgbWVyZWthIHNlY2FyYSBwZXJjdW1hIGRhbiBtZW5kYXBhdCBnYW5qYXJhbiBkZW5nYW4gbWVsaWJhdGthbiBkYW4gbWVuZGFwYXQgcGVuZ2lrdXQuIDxicj5UdWxpcyBhcnRpa2VsIG1lbmdlbmFpIHBlcmdpLCBzaW1wYW4gYmViZXJhcGEgRHJhZiBqYXdhdGFuIHVudHVrIHBlbmVyYml0YW4ga2VtdWRpYW4uIDxicj4tQm9va21hcmsgYXJ0aWtlbCBrZWdlbWFyYW4gbWVtYmFjYSBrZW11ZGlhbi4gPGJyPi1QZXJ0dWthcmFuIGF0YXUgV2FuZyBUdW5haSBkYXJpcGFkYSBwZW5kYXBhdGFuIGFuZGEuIDxicj5NZW5naGFudGFyIGRhbmEgYW5kYSBrZXBhZGEgbWFuYS1tYW5hIHBlbmdhcmFuZyBhdGF1IHBlbmdndW5hLCByYWthbi1yYWthbiwgcGVuZ2lrdXQsIGRhbiBsYWluLWxhaW4gPGJyPi1pa3V0IHBlbnVsaXMgbWVuYXJpaywgQmxvZ2dlci4gPGJyPiAtQ2FyaSBwZW5naWt1dCBkYW4gcGVudWxpcyBhbmRhIG1lbmdpa3V0aSBhbmRhLiA8YnI+LURhcGF0a2FuIHBlbWJlcml0YWh1YW4gdW50dWsga2VrYWwgYmVyaHVidW5nIGRlbmdhbiBwZW5naWt1dCBkYW4gcGVyYmluY2FuZ2FuIGFuZGEgYW5kYSBha2FuIHRlcmxpYmF0IGluLiA8YnI+LUNhcmkgbGFiZWwva2F0ZWdvcmkgbWVuYXJpayBhcnRpa2VsLCBwZW5nYXJhbmcuIDxicj4gLU1lbXBlcmliYWRpa2FuIHByb2ZpbCBhbmRhLiA8YnI+LUJhbnlhayBsZWJpaCBiYW55YWsgY2lyaSB1bnR1ayBkYXRhbmcuIDxicj48YnI+PGI+S2VzZWxhbWF0YW48L2I+IDxicj4xLiBBcGxpa2FzaSB0aWRhayBwZXJuYWggbWVuY2FwYWkgYXRhdSBtZW1lZ2FuZyB3YW5nIHBlbmdndW5hLiA8YnI+Mi4gYXBsaWthc2kgbWVuYXdhcmthbiBtb2RlbCBLZXNlbGFtYXRhbi1rbGllbiwgZGVuZ2FuIGt1bmNpIHBlcmliYWRpIHlhbmcgZGlob3NrYW4gZGFsYW0gbmVnYXJhIGRhbiB0aWRhayBwZXJuYWggZGloYW50YXIga2UgbWFuYS1tYW5hIHBlbGF5YW4sIGFuZGEgYmVydGFuZ2d1bmdqYXdhYiB1bnR1ayBtZW55YW5kYXJrYW4ga2F0YSBsYWx1YW4gYW5kYS4gPGJyPjMuIGFwbGlrYXNpIG1lbmF3YXJrYW4gYW50YXJhIG11a2EgcGVuZ2d1bmEgeWFuZyBtdWRhaCwgbWVuYXJpayBkYW4gcGVuZ2FsYW1hbiA8YnI+NC4gQXBsaWthc2kgbWVuYXdhcmthbiB0YW1iYWhhbiBsYXBpc2FuIEtlc2VsYW1hdGFuIGRlbmdhbiBoYXJnYSA8YnI+PGJyPmtvZCBwaW4gbWVueW9rb25nIHBsYXRmb3JtIFN0ZWVtIGRhbiBHb2xvcy4gPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJQZW5nYXNhcyBkYW4gcGVtYWp1IHV0YW1hXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJUYW1iYWggYWthdW5cIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRWplbiBlc2Nyb3dcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJUYXJpa2ggYWtoaXIga2VsdWx1c2FuXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgdGFtYXRcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiWXVyYW4gZXNjcm93XCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiVGVybWEtdGVybWEgZXNjcm93XCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIkhvbWVcIixcblx0XCJMT0dJTlwiOiBcIkxvZyBpblwiLFxuXHRcIkxPR09VVFwiOiBcIkxvZyB1aXRcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmllbFwiLFxuXHRcIkZPTExPV1wiOiBcIlZvbGdlblwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIkJsYWR3aWp6ZXJzXCIsXG5cdFwiVFJBTlNGRVJcIjogXCJPdmVyc2NocmlqdmVuXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWFya3RcIixcblx0XCJTRVRUSU5HU1wiOiBcIkluc3RlbGxpbmdlblwiLFxuXHRcIkFCT1VUXCI6IFwiT3ZlclwiLFxuXHRcIkFCT1VUXzFcIjogXCJ3YWFyIGllZGVyZWVuIGVlbiBiZWxvbmluZyBrYW4gdmVyZGllbmVuIVwiLFxuXHRcIkFCT1VUXzJcIjogXCJpcyBzb2NpYWwgbWVkaWEgZGllbnN0IHdhYXIgamUgYmV0YWFsZCB3b3JkdCB2b29yIGhldCBibG9nZ2VuLCBhbnR3b29yZGVuIGVuIGN1cmVyZW4uXCIsXG5cdFwiQUJPVVRfM1wiOiBcImVuIGhldCBpcyBlZW4gb3Blbi1zb3VyY2UsIGNvbW11bml0aWUgZ2VkcmV2ZW4gcHJvamVjdC4gSGV0IGJpZWR0IG1vZ2VsaWpraGVkZW4gdG90IGxlemVuLCByZWFnZXJlbiwgc3RlbW1lbiwgcGxhYXRzZW4gdmFuIGJlcmljaHRlbiwgb3ZlcnNjaHJpanZlbiB2YW4gaW5rb21zdGVuLCBldGMuIGZ1bmN0aWVzIHdvcmRlbiBhYW5nZWJvZGVuIGRvb3Ige3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGFuZCB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIERlIGFwcCBoZWVmdCBnZWVuIHRvZWdhbmcgdG90IHRlZ29lZGVuIHZhbiBkZSBnZWJydWlrZXIuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIERlIGFwcCBiaWVkdCBlZW4gY2xpZW50IGJldmVpbGlnaW5nc21vZGVsLCBtZXQgcHJpdsOpIHNsZXV0ZWxzIGRpZSBsb2thYWwgd29yZGVuIG9wZ2VzbGFnZW4gZW4gbm9vaXQgbmFhciBzZXJ2ZXJzIHdvcmRlbiB2ZXJ6b25kZW4uXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIERlIGFwcCBiaWVkdCBzaW1wZWxlLCBhYW50cmVra2VsaWprZSBnZWJydWlrZXJzb21nZXZpbmdlbiBlbiBlcnZhcmluZ2VuLlwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LiBEZSBhcHAgdnJhYWd0IHUgbm9vaXQgb20gcGVyc29vbmxpamtlIGluZm9ybWF0aWUuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlN0ZW0gb3AgZ29vZC1rYXJtYSBhbHMgd2l0bmVzc1wiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YWN0L1RlcnVna29wcGVsaW5nOlwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTWVlciBpbmZvcm1hdGllOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlZlcndpamRlcmVuXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJNYXJrdCBXZWVyZ2F2ZVwiLFxuXHRcIlBSSUNFXCI6IFwiUHJpanNcIixcblx0XCJBTU9VTlRcIjogXCJCZWRyYWdcIixcblx0XCJUT1RBTFwiOiBcIlRvdGFhbFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiR2VlbiB1aXRzdGFhbmRlIGJlc3RlbGxpbmdlbiB2b29yXCIsXG5cdFwiREFURVwiOiBcIkRhdHVtXCIsXG5cdFwiQlVZXCI6IFwiS29wZW5cIixcblx0XCJTRUxMXCI6IFwiVmVya29wZW5cIixcblx0XCJPUEVOXCI6IFwiT3BlblwiLFxuXHRcIkhJU1RPUllcIjogXCJHZXNjaGllZGVuaXNcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlRlcnVndm9sZ2VuXCIsXG5cdFwiRk9MTE9XRURcIjogXCJHZXZvbGdkXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJPbnR2b2xnZW5cIixcblx0XCJGT0xMT1dJTkdcIjogXCJWb2xnZW5cIixcblx0XCJGT0xMT1dFUlNcIjogXCJWb2xnZXJzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlpvZWsgdm9sZ2Vyc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJab2VrIHZvbGdlblwiLFxuXHRcIkJZXCI6IFwiZG9vclwiLFxuXHRcIklOXCI6IFwiaW5cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiQmxhZHdpanplclwiLFxuXHRcIlJFQkxPR1wiOiBcIkhlcmJsb2dcIixcblx0XCJVUFZPVEVcIjogXCJTdGVtIE9taG9vZ1wiLFxuXHRcIkRPV05WT1RFXCI6IFwiU3RlbSBPbWxhYWdcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwiRG93bnZvdGUgd2VnaGFsZW5cIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIlN0ZW0gT21oYWFnIHdlZ2hhbGVuXCIsXG5cdFwiUkVQTFlcIjogXCJSZWFnZWVyXCIsXG5cdFwiRURJVFwiOiBcIldpanppZ2VuXCIsXG5cdFwiUE9TVF8xXCI6IFwiU3dpcGUgbmFhciBsaW5rcyBvcCBlZW4gcmVhY3RpZSBvbSBvcHRpZXMgdGUgemllblwiLFxuXHRcIlBPU1RfMlwiOiBcIlRpayBvcCByZWFjdGllcyBvbSBzdWItcmVhY3RpZXMgdGUgemllblwiLFxuXHRcIk9QVElPTlNcIjogXCJPcHRpZXNcIixcblx0XCJSRVNURUVNRURfQllcIjogXCJIZXJibG9nZCBkb29yXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiTm9nIG5pZXRzIHRlIHppZW4gaGllci4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiVGVnb2VkZW5cIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCB2ZXJoYW5kZWxiYXJlIHRva2VucyBkaWUgYWx0aWpkIG92ZXJnZW1hYWt0IGthbiB3b3JkZW4uIHt7cGxhdGZvcm1uYW1lfX0ga2FuIHdvcmRlbiBvbWdlemV0IG5hYXIge3twbGF0Zm9ybXBvd2VyfX0gaW4gZWVuIHByb2NlcyBnZW5hYW1kIHBvd2VyaW5nIHVwLlwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19LCBpbnZsb2VkIHRva2VucyBkaWUgbWVlciBrcmFjaHQga3JpamdlbiBkb29yIGhldCBvcCBsYW5nZSB0ZXJtaWpuIHRlIGJld2FyZW4gZW4gZG9vciBoZXQgc3RlbW1lbiBvcCBiZXJjaWh0ZW4uIEhvZSBtZWVyIHRva2VucyB1IHZhc3Rob3VkdCwgaG9lIG1lZXIgaW52bG9lZCB1IGhlZWZ0IG9wIGFuZGVybWFucyBvcGJyZW5nc3RlbiBlbiBob2UgaG9nZXIgZGUgb3BicmVuZ3N0ZW4gYmlqIGN1cmVyZW4uXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwiVG9rZW5zIHppam4gb25nZXZlZXIge3twbGF0Zm9ybXN1bml0fX0ge3twbGF0Zm9ybW5hbWV9fSB3YWFyZC5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJHZXNjaGF0dGUgd2FhcmRlXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiRGUgZ2VzY2hhdHRlIHdhYXJkZSBpcyBnZWJhc2VlcmQgb3AgZWVuIDctZGFhZ3MgZ2VtaWRkZWxkZSB3YWFyZGUgdmFuIHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlRyYW5zYWN0aWUgZ2VzY2hpZWRlbmlzXCIsXG5cdFwiUE9TVElOR1wiOiBcIlBsYWF0c2VuXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiRGUgYmVyaWNodGVuIHNsZXV0ZWwgd29yZHQgZ2VicnVpa3Qgdm9vciBoZXQgcGxhYXRzZW4gdmFuIGVuIHZvb3IgaGV0IHN0ZW1tZW4gb3AgYmVyaWNodGVuLiBEZXplIHpvdSBhbmRlcnMgbW9ldGVuIHppam4gZGFuIGRlIGFjdGlldmUtIGVuIGVpZ2VuYWFyIHNsZXV0ZWxzLlwiLFxuXHRcIk9XTkVSXCI6IFwiRWlnZW5hYXJcIixcblx0XCJQUk9GSUxFXzZcIjogXCJEZSBlaWdlbmFhcnMgc2xldXRlbCBpcyBkZSBob29mZHNsZXV0ZWwgdm9vciBoZXQgYWNjb3VudCBlbiBpcyBub2RpZyBvbSBhbmRlcmUgc2xldXRlbHMgYWFuIHRlIHBhc3Nlbi4gRGUgcHJpdsOpIHNsZXV0ZWwgb2Ygd2FjaHR3b29yZCB2b29yIGRlIGVpZ2VuYWFycyBzbGV1dGVsIHpvdSB6byB2ZWVsIG1vZ2VsaWprIG9mZmxpbmUgb3BnZXNsYWdlbiBtb2V0ZW4gd29yZGVuLlwiLFxuXHRcIkFDVElWRVwiOiBcIkFjdGllZlwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkRlIGFjdGlldmUgc2xldXRlbCB3b3JkdCBnZWJydWlrdCBvbSB0cmFuc2FjdGllcyBlbiBiZXN0ZWxsaW5nZW4gdGUgcGxhYXRzZW4gaW4gZGUgaW50ZXJuZSBtYXJrdC5cIixcblx0XCJNRU1PXCI6IFwiTWVtb1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkRlIG1lbW8gc2xldXRlbCB3b3JkdCBnZWJydWlrdCB2b29yIGhldCBtYWtlbiBlbiBsZXplbiB2YW4gbWVtbydzLlwiLFxuXHRcIkJMT0dcIjogXCJCbG9nXCIsXG5cdFwiUE9TVFNcIjogXCJCZXJpY2h0ZW5cIixcblx0XCJSRVBMSUVTXCI6IFwiUmVhY3RpZXNcIixcblx0XCJXQUxMRVRcIjogXCJQb3J0ZW1vbm5lZVwiLFxuXHRcIlRBR1wiOiBcIkxhYmVsXCIsXG5cdFwiVVNFUlwiOiBcIkdlYnJ1aWtlclwiLFxuXHRcIkNMT1NFXCI6IFwiQWZzbHVpdGVuXCIsXG5cdFwiVE9cIjogXCJOYWFyXCIsXG5cdFwiQVNTRVRcIjogXCJCZXppdHRpbmdcIixcblx0XCJTRU5EXCI6IFwiVmVyemVuZGVuXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJCZXZlaWxpZ2luZ1wiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkJlc2NoaWtiYWFyXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJQdWJsaWVrZWxpamtlIG1lbW9cIixcblx0XCJUT19ERVNDXCI6IFwiR2VicnVpa2VyIGJpanYuIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbmNvZGVcIixcblx0XCJQSU5fVEVYVFwiOiBcIlBJTiBjb2RlIGhlbHB0IHUgdXcgYXBwIGVuIGdlZ2V2ZW5zIHRlIGJlc2NoZXJtZW4uIDxici8+PGJyLz48Yj5PcG1lcmtpbmc6PC9iPiBFZW5tYWFsIGluZ2VzdGVsZCBoZWVmdCB1IG1heGltYWFsIDQga2Fuc2VuLCB3YW5uZWVyIHUgZGUgUElOIGJlbnQgdmVyZ2V0ZW4gb2YgdSBoZXQgNCBrZWVyIHZlcmtlZXJkIGhlZWZ0IGluZ2V2b2VyZCB6YWwgZGUgYXBwIHV3IGdlYnJ1aWtlcnNnZWdldmVucyB2ZXJ3aWpkZXJlbi4gVSBrdW50IGRhbiBvcG5pZXV3IGlubG9nZ2VuIG9tIGRlIGFwcCB3ZWVyIHRlIGt1bm5lbiBnZWJydWlrZW4uXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWNhdGllc1wiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIlUga3Jpamd0IGVlbiBub3RpZmljYXRpZSB3YW5uZWVyIGllbWFuZCB2b29yIHV3IGJlcmljaHQgc3RlbXQuPGJyLz4gPGI+T3BtZXJraW5nOjwvYj4gTm90aWZpY2F0aWVzIGdlZWZ0IHN0ZW1nZXdpY2h0IGFhbiBhbHNvb2sgaW4gaGV0IG1lbGRpbmdzYmVyaWNodC4gKHpvd2VsIHZvb3Igc3RlbSBvbWhvb2csIHN0ZW0gb21sYWFnLCB2ZXJ3aWpkZXIgc3RlbSkuXCIsXG5cdFwiVk9URVwiOiBcIlN0ZW1cIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgcmVhZ2VlcnQgb3AgdXcgYmVyaWNodGVuIG9mIHJlYWN0aWVzLiA8YnIvPiA8Yj5PcG1lcmtpbmc6PC9iPiBOb3RpZmljYXRpZXMgb29rIHdhbm5lZXIgaWVtYW5kIHppam4vaGFhciByZWFjdGllcyA8Yj5hYW5wYXN0PC9iPi5cIixcblx0XCJDT01NRU5UXCI6IFwiQ29tbWVudGFhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiVSBrcmlqZ3QgZWVuIG5vdGlmaWNhdGllIHdhbm5lZXIgaWVtYW5kIHUgdm9sZ3Qgb2Ygc3RvcHQgbWV0IHZvbGdlbiFcIixcblx0XCJNRU5USU9OU1wiOiBcIlZlcm1lbGRpbmdlblwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJVIGtyaWpndCBlZW4gbm90aWZpY2F0aWUgd2FubmVlciBpZW1hbmQgdSBub2VtdCBpbiB6aWpuIG9mIGhhYXIgYmVyaWNodC9yZWFjdGllIVwiLFxuXHRcIlJFU1RFRU1cIjogXCJIZXJibG9nXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiVSBrcmlqZ3QgZWVuIG5vdGlmaWNhdGllIHdhbm5lZXIgaWVtYW5kIHV3IGJlcmljaHQgaGVyYmxvZ2QhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJDb25maWd1cmF0aWVzXCIsXG5cdFwiVk9USU5HXCI6IFwiU3RlbW1lblwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiU3RlbWdld2ljaHQgb2YgcGVyY2VudGFnZSBoZWJiZW4gaW52bG9lZCBvcCBTdGVta3JhY2h0IGluIGRlIGFwcCwgem9kYXQgdSB1dyBzdGVtb3BicmVuZ3N0ZW4ga3VudCByZWd1bGVyZW4uIDxici8+PGJyLz48Yj5PcG1lcmtpbmc6PC9iPiBEaXQgemFsIHV3IHN0ZW1nZXdpY2h0L3BlcmNlbnRhZ2Ugdm9vciBoZXQgb21sYWFnIHN0ZW1tZW4gb29rIGFhbnRhc3RlbiBlbiBnZWxkdCB2b29yIGRlIGdlaGVsZSBhcHBcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIkFhbmJldm9sZW5cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJXaWp6aWdpbmdlbiBvcHNsYWFuXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJTdGVtbWVycyBpbmZvcm1hdGllXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiV2Vsa29tIHRlcnVnIVwiLFxuXHRcIkxPR0lOXzFcIjogXCJMb2cgaW4gbWV0IHV3IGdlYnJ1aWtlcnNuYWFtIGVuIHdhY2h0d29vcmQgb20gdmVyZGVyIHRlIGdhYW4uXCIsXG5cdFwiTE9HSU5fMlwiOiBcIlBvc3Rpbmcgc2xldXRlbCB3b3JkdCBnZWJydWlrdCB2b29yIGhldCBwbGFhdHNlbiB2YW4gYmVyaWNodGVuLCByZWFjdGllcywgc3RlbW1lbiBlbiBoZXQgdm9sZ2VuIHZhbiBnZWJydWlrZXJzLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBY3RpZXZlIHNsZXV0ZWwgd29yZHQgZ2VicnVpa3Qgdm9vciBvdmVybWFrZW4gZW4gYWFucGFzc2luZ2VuIHZhbiBkZSBwcm9maWVsIGZvdG8uXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkdlYnJ1aWtlcnNnZWdldmVucyB3b3JkZW4gbG9rYWFsIG9wIHV3IGFwcGFyYWF0IG9wZ2VzbGFnZW4uIEJpaiBoZXQgdWl0bG9nZ2VuIHdvcmRlbiBkZSBnZWdldmVucyB2ZXJ3aWpkZXJkIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIkhlZWZ0IHUgZ2VlbiBhY2NvdW50P1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiTWVsZCBqZSBudSBhYW5cIixcblx0XCJDQU5DRUxcIjogXCJBbm51bGVyZW5cIixcblx0XCJBRFZBTkNFRFwiOiBcIlVpdGdlYnJlaWRcIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQWN0aWV2ZSBwcml2w6kgc2xldXRlbFwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiUG9zdGluZyBwcml2w6kgc2xldXRlbFwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiSG9vZmR3YWNodHdvb3JkXCIsXG5cdFwiVVNFUk5BTUVcIjogXCJHZWJydWlrZXJzbmFhbVwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIkthYXJ0IHdlZXJnYXZlXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiQ29tcGFjdGUgd2VlcmdhdmVcIixcblx0XCJTRUFSQ0hcIjogXCJab2VrZW5cIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIlBsYWF0cyBlZW4gYmVyaWNodFwiLFxuXHRcIlJFUExZVE9cIjogXCJSZWFnZWVyIG9wXCIsXG5cdFwiUE9TVFwiOiBcIkJlcmljaHRcIixcblx0XCJQUkVWSUVXXCI6IFwiUHJldmlld1wiLFxuXHRcIkRFRkFVTFRcIjogXCJTdGFuZGFhcmQgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIlBvd2VyIFVwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIlVpdGJldGFsaW5nIEFmd2lqemVuXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJPUFNMQUFOIFZPT1IgTEFURVJcIixcblx0XCJDTEVBUlwiOiBcIkxFRUdNQUtFTlwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlBsYWF0cyBiZXJpY2h0XCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiUmVhZ2VlciBvcCBiZXJpY2h0XCIsXG5cdFwiVElUTEVcIjogXCJUaXRlbFwiLFxuXHRcIlRBR1NcIjogXCJMYWJlbHNcIixcblx0XCJOT1RfTUFUQ0hcIjogXCJLT01UIE5JRVQgT1ZFUkVFTlwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwiQmV2ZXN0aWcgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiT05KVUlTVFwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIkJlcmljaHQgb3BlbmVuXCIsXG5cdFwiU0VUX1BJTlwiOiBcIkluc3RlbGxlbiBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJJbnZvZXJlbiBQSU5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJXZWV0IHUgaGV0IHpla2VyP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiSGVyYmxvZ2dlbiBpcyBkZWZpbml0aWVmLCB3aWx0IHUgZG9vcmdhYW4/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiVmVyemVuZGZvdXQsIHByb2JlZXIgb3BuaWV1dyFcIixcblx0XCJTVUNDRVNTXCI6IFwiU3VjY2Vzdm9sXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJCZXJpY2h0IGhlcmJsb2dkIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJJbmxvZ2dlbiBtaXNsdWt0ISBDb250cm9sZWVyIG9mIHUgZ2Vwcm9iZWVyZCBoZWVmdCBpbiB0ZSBsb2dnZW4gbWV0IHV3IGhvb2Zkd2FjaHR3b29yZCBvZiBQb3N0aW5nIHByaXbDqSBzbGV1dGVsIGFscyB1IHZvb3IgZ2VhdmFuY2VlcmRlIG1vZHVzIGhlZWZ0IGdla296ZW4uXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiSW5sb2dnZW4gbWlzbHVrdCEgQ29udHJvbGVlciBvZiB1IGdlcHJvYmVlcmQgaGVlZnQgaW4gdGUgbG9nZ2VuIG1ldCB1dyBob29mZHdhY2h0d29vcmQgb2YgQWN0aWV2ZSBwcml2w6kgc2xldXRlbCBhbHMgdSB2b29yIGdlYXZhbmNlZXJkZSBtb2R1cyBoZWVmdCBnZWtvemVuLlwiLFxuXHRcIldBUk5JTkdcIjogXCJXYWFyc2NodXdpbmdcIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiU3RlbW1lbiB2b29yIHdpdG5lc3NcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIkdlc3RlbWQgdm9vciB3aXRuZXNzXCIsXG5cdFwiQUdPXCI6IFwiZ2VsZWRlblwiLFxuXHRcIkZST01fTk9XXCI6IFwidmFuYWYgbnVcIixcblx0XCJTRUNTXCI6IFwic2Vjc1wiLFxuXHRcIkFfTUlOXCI6IFwiZWVuIG1pbnV1dFwiLFxuXHRcIk1JTlNcIjogXCJtaW51dGVuXCIsXG5cdFwiQU5fSE9VUlwiOiBcImVlbiB1dXJcIixcblx0XCJIT1VSU1wiOiBcInVyZW5cIixcblx0XCJBX0RBWVwiOiBcImVlbiBkYWdcIixcblx0XCJEQVlTXCI6IFwiZGFnZW5cIixcblx0XCJBX01PTlRIXCI6IFwiZWVuIG1hYW5kXCIsXG5cdFwiTU9OVEhTXCI6IFwibWFhbmRlblwiLFxuXHRcIkFfWUVBUlwiOiBcImVlbiBqYWFyXCIsXG5cdFwiWUVBUlNcIjogXCJqYXJlblwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluLiBsZWVzdGlqZFwiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCJTdGVtIE9tbGFhZyBvZiBWbGFnXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiTmVlbSBCZWVsZFwiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwiU2VsZWN0ZWVyIEZvdG9cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIlN0ZWwgRWlnZW4gVVJMIGluXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJGb3RvIEludm9lZ2VuXCIsXG5cdFwiRVJST1JcIjogXCJGb3V0XCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwiVXBsb2FkIEZvdXRcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiQ2FtZXJhIEdlYW5udWxlZXJkXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlN0ZWwgVVJMIGluXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcIkRpcmVjdGUgd2ViIGxpbmsgdm9vciBkZSBmb3RvXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCJDb21tZW50YWFyIGlzIHZlcnN0dXVyZCFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIkhldCB2ZXJ3aWpkZXJlbiB2YW4gcmVhY3RpZXMgaXMgZGVmaW5pdGllZi4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIlZlcndpamRlcmRlIHJlYWN0aWVcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIkZvdG8gaXMgYWFuIGhldCB1cGxvYWRlblwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCJVcGxvYWQgR2VzbGFhZ2RcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiVXBsb2FkIE1pc2x1a3RcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJIZXQgd2FjaHR3b29yZCBvZiBnZWJydWlrZXJzbmFhbSBpcyBmb3V0XCIsXG5cdFwiSU5GT1wiOiBcIkluZm9cIixcblx0XCJRUl9URVhUXCI6IFwiUGxhYXRzIGVlbiBRUiBjb2RlIGluIGhldCBzY2FuZ2ViaWVkXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiQ29udHJvbGVlciBvZiB1IGdlbm9lZyB0ZWdvZWQgaGVlZnQgdm9vciBkZSB0cmFuc2FjdGllIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJEZSBnZWJydWlrZXIgbmFhciB3aWUgdSBwcm9iZWVydCBvdmVyIHRlIG1ha2VuLCBiZXN0YWF0IG5pZXQhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIldlZXQgdSB6ZWtlciBkYXQgdSB3aWx0IG92ZXJtYWtlbj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJCZXZlc3RpZ2luZ1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwiVHJhbnNhY3RpZSBpcyB2ZXJzdHV1cmRcIixcblx0XCJGRUVEXCI6IFwiRmVlZFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRpbmdcIixcblx0XCJIT1RcIjogXCJQb3B1bGFpclwiLFxuXHRcIk5FV1wiOiBcIk5pZXV3XCIsXG5cdFwiUFJPTU9URURcIjogXCJHZXNwb25zb3JkXCIsXG5cdFwiVk9URVNcIjogXCJTdGVtbWVuXCIsXG5cdFwiUEFZT1VUXCI6IFwiVWl0YmV0YWxpbmdcIixcblx0XCJDT01NRU5UU1wiOiBcIlJlYWN0aWVzXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUcmVuZGluZyBsYWF0c3RlIDMwIGRhZ2VuXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiU29ydGVlciBiZXJpY2h0ZW4gb3A6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiVWl0YmV0YWxpbmdzY3ljbHVzXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBvdGVudGnDq2xlIFVpdGJldGFsaW5nXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJWZXJsZWRlbiBVaXRiZXRhbGluZ1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJBdXRldXIgVWl0YmV0YWxpbmdcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJDdXJhdGllIFVpdGJldGFsaW5nXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJCZXJpY2h0IGlzIHZlcnpvbmRlbiFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiVGUgdmVyc3R1cmVuIGJlcmljaHRlbiFcIixcblx0XCJTQVZFRFwiOiBcIk9wZ2VzbGFnZW5cIixcblx0XCJDTEVBUkVEXCI6IFwiR2V3aXN0XCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIkVlbiBiZXJpY2h0IHZsYWdnZW4gb2Ygb21sYWFnIHN0ZW1tZW4ga2FuIGRlIG9wYnJlbmdzdGVuIHdlZ2hhbGVuIGVuIG1pbmRlciB6aWNodGJhYXIgbWFrZW4uPGJyPjxicj5EZSB2bGFnIG1hZyBhbGxlZW4gaW4gZGUgdm9sZ2VuZGUgZ2V2YWxsZW4gZ2VicnVpa3Qgd29yZGVuOiA8dWw+PGxpPkZyYXVkZSBvZiBQbGFnaWFhdDwvbGk+PGxpPkhhYXRzcHJhYWsgb2YgSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5NZXQgaW50ZW50aWUgaW4gdmVya2VlcmRlIGNhdGVnb3JpZSBnZXBsYWF0c3Qgb2YgU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJMaW1pZXQgdmVyem9layBiZXJlaWt0LiBCZWtpamsgb29rIGFuZGVyZSB0cmVuZHMvdGFncyFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJCZXJpY2h0IGlzIHZhbiBibGFkd2lqemVycyB2ZXJ3aWpkZXJkIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJCZXJpY2h0IGlzIGFhbiBibGFkd2lqemVycyB0b2VnZXZvZWdkIVwiLFxuXHRcIlJFU0VUXCI6IFwiSGVyc3RlbGxlblwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwiUGFzIHByb2ZpZWxmb3RvIGFhblwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiUGFzIG9tc2xhZ2ZvdG8gYWFuXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiR2VsaWV2ZSBlZW4gYWN0aWV2ZSBzbGV1dGVsIHRlIGdiZXJ1aWtlbiB3YW5uZWVyIHUga2llc3Qgdm9vciBnZWF2YW5jZWVyZGUgaW5sb2cgbW9kdXMhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiRGl0IHphbCBkZSBwcm9maWVsZm90byB2YW4gZGUgZ2VicnVpa2VyIGhlcnN0ZWxsZW5cIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCJEaXQgemFsIGRlIG9tc2xhZ2ZvdG8gdmFuIGRlIGdlYnJ1aWtlciBoZXJzdGVsbGVuXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJTZXJ2ZXIgdXBkYXRlIHZlcmVpc3QgaGVyc3RhcnQhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkluc3RlbGxpbmdlbiB6aWpuIGJpamdld2Vya3QhXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwiVGFsZW5cIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkhpZXIga3VudCB1IGRlIHRhYWwgdmFuIGRlIGFwcCB2ZXJhbmRlcmVuLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJPbSBkaXQgdGUgZG9lbiBkaWVudCB1IGluIHRlIGxvZ2dlbiBtZXQgdXcgaG9vZmR3YWNodHdvb3JkLCBhY3RpZXZlL3Bvc3Rpbmcgc2xldXRlbC4gTG9nIGFsc3R1YmxpZWZ0IGluIGVuIHByb2JlZXIgb3BuaWV1dy5cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsbGVyaWpcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJWZXJ0YWxlcnNcIixcblx0XCJTSEFSRVwiOiBcIkRlbGVuXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNYXJrdHBsYWF0c1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiQmV1cnNcIixcblx0XCJEUkFGVFNcIjogXCJDb25jZXB0ZW5cIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJCZXJpY2h0IGlzIHVpdCBjb25jZXB0ZW4gdmVyd2lqZGVyZCFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwiQmVyaWNodCB0b2VnZXZvZWdkIGFhbiBjb25jZXB0ZW4hXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcIlZlZWcgbmFhciBsaW5rcyB2b29yIG9wdGllc1wiLFxuXHRcIk1BTkFHRVwiOiBcIkJlaGVlclwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCJBZmJlZWxkaW5nIGlzIHZlcndpamRlcmRcIixcblx0XCJDT1BZXCI6IFwiS29wacOrcmVuXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJKZSBoZWJ0IG5vZyBnZWVuIGFmYmVlbGRpbmcgZ2V1cGxvYWQhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJUcmVrIG9tbGFhZyBvbSB0ZSB2ZXJ2ZXJzZW5cIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwiRXh0ZXJuZSBhcHBsaWNhdGllc1wiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnaW5zXCIsXG5cdFwiU1VHR0VTVFwiOiBcIlN1Z2dlcmVlclwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiQmlubmVua29ydFwiLFxuXHRcIkNIQUlOXCI6IFwiS2V0ZW5cIixcblx0XCJDSEFJTl9URVhUXCI6IFwiSGllciBrdW50IHUgdmVyYW5kZXJlbiB2YW4gYmxvY2tjaGFpbiBvZiBzdGFuZGFhcmQgcGxhdGZvcm0uXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJWYWx1dGFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiVmVyYW5kZXIgaGllciB1dyBzdGFuZGFhcmQgdmFsdXRhLiBCZWxvbmluZ2VuIHZvb3IgYmVyaWNodGVuL3JlYWN0aWVzIGluIGRlemUgdmFsdXRhLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkZ1bmN0aWVzPC9iPjxicj4tIFRvZWdhbmcgdG90IHVuaWVrZSBhcnRpa2VsZW4gbWV0IHVpdGVlbmxvcGVuZGUgb25kZXJ3ZXJwZW4uPGJyPi0gQ29udmVyc2VlciBtZXQgYXV0ZXVycyBkb29yIHRlIHJlYWdlcmVuIGVuIHRlIGRpc2N1c3Npw6tyZW4uPGJyPi0gU3RlbW1lbiB2b29yIGJlcmljaHRlbiBvbSB6byBkZSBhdXRldXIgdGUgYmVsb25lbiBhbHNvb2sgYmVsb25pbmcgdGUgb250dmFuZ2VuIHZvb3IgY3VyZXJlbi48YnI+LSBQdWJsaWNlcmVuIHZhbiB1dyBhcnRpa2VsZW4gZW4gYmVyaWNodGVuIGVuIHZlcmRpZW4gYmVsb25pbmdlbiBkb29yIGludGVyYWN0aWUgZW4gZ3JvZWkgdmFuIHZvbGdlcnMuPGJyPi0gU2NocmlqZiBhcnRpa2VsZW4sIHNsYSBtZWVyZGVyZSBjb25jZXB0ZW4gb3AgZWVuIGxhdGVyIHRpamRzdGlwIHRlIHB1YmxpY2VyZW4uPGJyPi0gU2xhIGZhdm9yaWV0ZSBhcnRpa2VsZW4gb3Agb25kZXIgYmxhZHdpanplcnMgb20gZGV6ZSBsYXRlciB0ZSBsZXplbi48YnI+LSBXaXNzZWwgb2YgdmVyemlsdmVyIGplIGlua29tc3Rlbi48YnI+LSBNYWFrIHRlZ29lZGVuIG92ZXIgYWFuIGFuZGVyZSBhdXRldXJzIG9mIGdlYnJ1aWtlcnMsIHZyaWVuZGVuLCB2b2xnZXJzLCBldGMuPGJyPi0gVm9sZyBpbnRlcmVzc2FudGUgYXV0ZXVycywgYmxvZ2dlcnMuPGJyPi0gWm9layBqZSB2b2xnZXJzIGVuIGF1dGV1cnMgZGllIGplIHZvbGd0Ljxicj4tIE9udHZhbmcgbm90aWZpY2F0aWVzIG9tIGluIGNvbnRhY3QgdGUgYmxpanZlbiBtZXQgamUgdm9sZ2VycyBlbiBkaXNjdXNzaWVzIHdhYXJpbiBqZSBiZXRyb2trZW4gYmVudC48YnI+LSBab2VrIG9wIGludGVyZXN0YW50ZSBsYWJlbHMvY2F0ZWdvcmllw6tuIHZhbiBhcnRpa2VsZW4sIGF1dGV1cnMuPGJyPi0gUGVyc29uYWxpc2VlciBqZSBwcm9maWVsLjxicj4tIFZlbGUgYW5kZXJlIGZ1bmN0aWVzIGRpZSBub2cgenVsbGVuIHdvcmRlbiB0b2VnZXZvZWdkLjxicj48YnI+PGI+VmVpbGlnaGVpZDwvYj48YnI+MS4gQXBwIHphbCBub29pdCB0ZWdvZWRlbiB2YW4gZGUgZ2VicnVpa2VyIGFhbnJha2VuIG9mIG9wc2xhYW4uPGJyPjIuIEFwcCBoZWVmdCBlZW4gY2xpZW50LXNpZGUgYmV2ZWlsaWdpbmdzbW9kZWwsIG1ldCBwcml2w6kgc2xldXRlbHMgZGllIGxva2FhbCBvcGdlc2xhZ2VuIHdvcmRlbiBlbiBub29pdCBuYWFyIGFuZGVyZSBzZXJ2ZXJzIHRvZWdlc3R1dXJkIHdvcmRlbiwgdSBiZW50IHplbGYgdmVyYW50d29vcmRlbGlqayBvbSBoZXQgd2FjaHR3b29yZCBvcCB0ZSBzbGFhbi48YnI+My4gQXBwIGJpZWR0IGVlbiBzaW1wZWxlIGVuIGFhbnNwcmVrZW5kZSBnZWJydWlrZXJzdG9lZ2FuZy48YnI+NC4gQXBwIGJpZWR0IGVlbiBleHRyYSBiZXZlaWxpZ2luZyBkb29yIG1pZGRlbCB2YW4gZWVuIHBpbmNvZGU8YnI+PGJyPmVTdGVlbSBvbmRlcnN0ZXVuZCBTdGVlbSBlbiBHb2xvcyBwbGF0Zm9ybWVuLjxicj5cIixcblx0XCJGT1VOREVSXCI6IFwiT3ByaWNodGVyIGVuIEhvb2Zkb250d2lra2VsYWFyXCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCJBY2NvdW50IHRvZXZvZWdlblwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGZvcm1cIixcblx0XCJFU0NST1dcIjogXCJFc2Nyb3dcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCJFc2Nyb3ctYWdlbnRcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCJSYXRpZmljYXRpZSB0ZXJtaWpuXCIsXG5cdFwiRVNDUk9XX0VYUElSQVRJT05cIjogXCJFc2Nyb3cgdmVybG9wZW5cIixcblx0XCJFU0NST1dfRkVFXCI6IFwiRXNjcm93IHZlcmdvZWRpbmdcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJFc2Nyb3cgdm9vcndhYXJkZW5cIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTmFjaHQgbW9kdXNcIixcblx0XCJEQVlfTU9ERVwiOiBcIkRhZyBtb2R1c1wiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIkJla2lqayBkZSB2b2xsZWRpZ2UgY29udGV4dFwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJHZWJydWlrZXIgbmlldCBnZXZvbmRlblwiLFxuXHRcIkFQUFJPVkVcIjogXCJHb2Vka2V1cmVuXCIsXG5cdFwiRElTUFVURVwiOiBcIkdlc2NoaWxcIixcblx0XCJSRUxFQVNFXCI6IFwiVmVyc2llXCIsXG5cdFwiRlJPTVwiOiBcIlZhblwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJWZXJ6ZW5kXCIsXG5cdFwiUkVDRUlWRVJcIjogXCJPbnR2YW5nZXJcIixcblx0XCJMT0NBVElPTlwiOiBcIlBsYWF0c1wiLFxuXHRcIldFQlNJVEVcIjogXCJXZWJzaXRlXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiVG9vbiBuYWFtXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIlN0cm9uYSBnxYLDs3duYVwiLFxuXHRcIkxPR0lOXCI6IFwiWmFsb2d1alwiLFxuXHRcIkxPR09VVFwiOiBcIld5bG9ndWpcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiT2JzZXJ3dWpcIixcblx0XCJCT09LTUFSS1NcIjogXCJaYWvFgmFka2lcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlByemVsZXdcIixcblx0XCJNQVJLRVRcIjogXCJHaWXFgmRhXCIsXG5cdFwiU0VUVElOR1NcIjogXCJVc3Rhd2llbmlhXCIsXG5cdFwiQUJPVVRcIjogXCJPIE5hc1wiLFxuXHRcIkFCT1VUXzFcIjogXCJnZHppZSBrYcW8ZHkgbW/FvGUgemRvYnl3YcSHIHd5bmFncm9kemVuaWUgemEgc3dvamUgd3Bpc3khXCIsXG5cdFwiQUJPVVRfMlwiOiBcImZ1bmtjam9udWplIHcgb3BhcmNpdSBvIHBhdGZvcm3EmSB7e3BsYXRmb3JtbmFtZX19LiBBcGxpa2FjamEgamVzdCBzdHdvcnpvbmEgcHJ6ZXpcIixcblx0XCJBQk9VVF8zXCI6IFwiaSBqZXN0IG9uYSBvdHdhcnR5bSBpIHByb3dhZHpvbnltIHByemV6IHNwb8WCZWN6bm/Fm8SHIHByb2pla3RlbS4gT2ZlcnVqZSBkb3N0xJlwIGRvIGN6eXRhbmlhLCBrb21lbnRvd2FuaWEsIG9kZGF3YW5pYSBnxYJvc3UgbmEgdHJlxZtjaSBvcmF6IHVkb3N0xJlwbmlhbmlhIHdwaXPDs3csIGEgdGFrxbxlIG5hIHphcnrEhWR6YW5pZSB6YXJvYmthbWkgb3JheiBpbm55bWkgZG9zdMSZcG55bWkgb3BjamFtaSBvZmVyb3dhbnltaSBwcnpleiDFgmHFhGN1Y2ggYmxva8OzdyB7e3BsYXRmb3JtbmFtZX19IGkge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCJBcGxpa2FjamEgbmlnZHkgbmllIG1hIGRvc3TEmXB1IGkgbmllIHByemV0cnp5bXVqZSDFm3JvZGvDs3cgZmluYW5zb3d5Y2ggdcW8eXRrb3duaWthLlwiLFxuXHRcIkFCT1VUXzVcIjogXCJBcGxpa2FjamEgb2ZlcnVqZSBtb2RlbCBiZXpwaWVjemXFhHN0d2EgcG8gc3Ryb25pZSBrbGllbnRhLCBnZHppZSBrbHVjemUgcHJ5d2F0bmUgc8SFIHByemVjaG93eXdhbmUgbG9rYWxuaWUgaSBuaWdkeSBuaWUgc8SFIHByemVzecWCYW5lIG5hIGpha2lla29sd2llayBzZXJ3ZXJ5LlwiLFxuXHRcIkFCT1VUXzZcIjogXCJBcGxpa2FjamEgb2ZlcnVqZSDFgmF0d3kgaSBwcnp5amVtbnkgdyBvYnPFgnVkemUgaW50ZXJmZWpzLlwiLFxuXHRcIkFCT1VUXzdcIjogXCJBcGxpa2FjamEgbmlnZHkgbmllIHd5bWFnYSBwb2RhbmlhIGRhbnljaCBvc29ib3d5Y2ggb2Qgc3dvaWNoIHXFvHl0a293bmlrw7N3LlwiLFxuXHRcIkFCT1VUXzhcIjogXCJaYWfFgm9zdWogbmEgZ29vZC1rYXJtYSBuYSDFm3dpYWRrYVwiLFxuXHRcIkFCT1VUXzlcIjogXCJLb250YWt0L09waW5pZVwiLFxuXHRcIkFCT1VUXzEwXCI6IFwiV2nEmWNlaiBpbmZvcm1hY2ppOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlVzdcWEXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCJXaWRvayBuYSBnaWXFgmTEmVwiLFxuXHRcIlBSSUNFXCI6IFwiQ2VuYVwiLFxuXHRcIkFNT1VOVFwiOiBcIklsb8WbxIdcIixcblx0XCJUT1RBTFwiOiBcIlN1bWFcIixcblx0XCJOT09SREVSU1wiOiBcIkJyYWsgb3R3YXJ0eWNoIHpsZWNlxYQgZGxhXCIsXG5cdFwiREFURVwiOiBcIkRhdGFcIixcblx0XCJCVVlcIjogXCJLdXBcIixcblx0XCJTRUxMXCI6IFwiU3ByemVkYWpcIixcblx0XCJPUEVOXCI6IFwiVyB0b2t1XCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcmlhXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJPYnNlcnd1aiByw7N3bmllxbxcIixcblx0XCJGT0xMT1dFRFwiOiBcIk9ic2Vyd293YW55XCIsXG5cdFwiVU5GT0xMT1dcIjogXCJQcnplc3RhxYQgb2JzZXJ3b3dhxIdcIixcblx0XCJGT0xMT1dJTkdcIjogXCJPYnNlcnd1amVzelwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIk9ic2Vyd3VqxIUgY2nEmVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJTenVrYWogd8WbcsOzZCBvYnNlcnd1asSFY3ljaFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCJTenVrYWogd8WbcsOzZCBvYnNlcndvd2FueWNoXCIsXG5cdFwiQllcIjogXCJwcnplelwiLFxuXHRcIklOXCI6IFwid1wiLFxuXHRcIk1FTlVcIjogXCJNZW51XCIsXG5cdFwiQk9PS01BUktcIjogXCJaYWvFgmFka2lcIixcblx0XCJSRUJMT0dcIjogXCJSZWJsb2d1alwiLFxuXHRcIlVQVk9URVwiOiBcIkfFgm9zIHphXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJHxYJvcyBwcnplY2l3XCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkFudWx1aiBnxYJvcyBwcnplY2l3XCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJBbnVsdWogZ8WCb3MgemFcIixcblx0XCJSRVBMWVwiOiBcIk9kcG93aWVkxbpcIixcblx0XCJFRElUXCI6IFwiRWR5dHVqXCIsXG5cdFwiUE9TVF8xXCI6IFwiUHJ6ZWNpxIVnbmlqIGtvbWVudGFyeiB3IGxld28sIGFieSB6b2JhY3p5xIcgZG9zdMSZcG5lIG9wY2plXCIsXG5cdFwiUE9TVF8yXCI6IFwiTmFjacWbbmlqIG5hIGtvbWVudGFyemUsIGFieSByb3p3aW7EhcSHXCIsXG5cdFwiT1BUSU9OU1wiOiBcIk9wY2plXCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwiUmVzdGVlbW93YW55IHByemV6XCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwiTmEgcmF6aWUgbmljIHR1IG5pZSBtYS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiU2FsZGFcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19IHd5bWllbmlhbG5lIHRva2VueSwga3TDs3JlIG1vZ8SFIGJ5xIcgcHJ6ZXRyYW5zZmVyb3dhbmUgdyBkb3dvbG55bSBtb21lbmNpZS4ge3twbGF0Zm9ybW5hbWV9fSBtb2fEhSBiecSHIHd5bWllbmlvbmUgbmEge3twbGF0Zm9ybXBvd2VyfX0gdyBwcm9jZXNpZSB6d2FueW0gUG93ZXItdXAuXFxuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0gdG9rZW55IHdwxYJ5d3UsIGt0w7NyZSB1bW/FvGxpd2lhasSFIG5hIHpkb2J5d2FuaWUgd2nEmWtzemVqIGlsb8WbY2kgbW9jeSB6YSB0cnp5bWFuaWUgaWNoIGTFgnVvdGVybWlub3dvIG9yYXogemEgZ8WCb3Nvd2FuaWUgbmEgd3Bpc3kuIEltIHdpxJljZWogc2nEmSBpY2ggcG9zaWFkYSwgdHltIGJhcmR6aWVqIHdwxYJ5d2Egc2nEmSBuYSB3eW5hZ3JvZHplbmllIGlubnljaCB3cGlzw7N3IGkgbmEgemRvYnl3YW5pZSBuYWdyw7NkIHp3acSFemFuZSB6IG9kZGFuaWVtIGfFgm9zdS5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJUb2tlbnkgd2FydGUgb2tvxYJvIHt7cGxhdGZvcm1zdW5pdH19IHBsYXRmb3JteSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlN6YWNvd2FuYSB3YXJ0b8WbxIdcIixcblx0XCJQUk9GSUxFXzRcIjogXCJXYXJ0b8WbxIcgamVzdCBzemFjb3dhbmEgbmEgcG9kc3Rhd2llIMWbcmVkbmllaiB3YXJ0b8WbY2kgeiA3LW1pdSBkbmkuXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIkhpc3RvcmlhIHRyYW5zYWtjamlcIixcblx0XCJQT1NUSU5HXCI6IFwiVWRvc3TEmXBuaWFuaWVcIixcblx0XCJQUk9GSUxFXzVcIjogXCJLbHVjeiB1ZG9zdMSZcG5pZW5pYSBqZXN0IHXFvHl3YW55IHByenkgdWRvc3TEmXBuaWFuaXUgd3Bpc8OzdyBpIG9kZGF3YW5pdSBnxYJvc8Ozdy4gUG93aW5pZW4gYnnEhyBpbm55IG5pxbwga2x1Y3ogYWt0eXdueSBpIGtsdWN6IHfFgmFzbm/Fm2NpLlwiLFxuXHRcIk9XTkVSXCI6IFwiV8WCYcWbY2ljaWVsXCIsXG5cdFwiUFJPRklMRV82XCI6IFwiS2x1Y3ogd8WCYXNub8WbY2kgamVzdCBrbHVjemVtIGfFgsOzd255bSBrb250YSBpIGplc3Qgd3ltYWdhbnkgZG8gem1pYW55IHBvem9zdGHFgnljaCBrbHVjenkuIEtsdWN6IHByeXdhdG55IGx1YiBoYXPFgm8gZG8ga2x1Y3phIHfFgmFzbm/Fm2NpIHBvd2lubm8gYnnEhyB0cnp5bWFuZSBvZmZsaW5lLCBnZHkgamVzdCB0byB0eWxrbyBtb8W8bGl3ZS5cIixcblx0XCJBQ1RJVkVcIjogXCJBa3R5d255XCIsXG5cdFwiUFJPRklMRV83XCI6IFwiS2x1Y3ogYWt0eXdueSBqZXN0IHXFvHl3YW55IGRvIHd5a29ueXdhbmlhIHByemVsZXfDs3cgaSBza8WCYWRhbmlhIHphbcOzd2llxYQgbmEgd2V3bsSZdHJ6bmVqIGdpZcWCZHppZS5cIixcblx0XCJNRU1PXCI6IFwiTm90YXRrYVwiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIktsdWN6IG5vdGF0a2kgamVzdCB1xbx5dHksIGFieSBzcG9yesSFZHphxIcgaSBjenl0YcSHIG5vdGF0a2kuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dcIixcblx0XCJQT1NUU1wiOiBcIldwaXN5XCIsXG5cdFwiUkVQTElFU1wiOiBcIk9kcG93aWVkemlcIixcblx0XCJXQUxMRVRcIjogXCJQb3J0ZmVsXCIsXG5cdFwiVEFHXCI6IFwiRXR5a2lldGFcIixcblx0XCJVU0VSXCI6IFwiVcW8eXRrb3duaWtcIixcblx0XCJDTE9TRVwiOiBcIlphbWtuaWpcIixcblx0XCJUT1wiOiBcIkRvXCIsXG5cdFwiQVNTRVRcIjogXCJLYXBpdGHFglwiLFxuXHRcIlNFTkRcIjogXCJXecWbbGlqXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJCZXpwaWVjemXFhHN0d29cIixcblx0XCJBVkFJTEFCTEVcIjogXCJEb3N0xJlwbnlcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk5vdGF0a2EgcHVibGljem5hXCIsXG5cdFwiVE9fREVTQ1wiOiBcIlXFvHl0a293bmlrIG5wLiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJLb2QgUElOXCIsXG5cdFwiUElOX1RFWFRcIjogXCJLb2QgUElOIHBvendhbGEgQ2kgemFiZXpwaWVjennEhyBhcGxpa2FjasSZIG9yYXogdHdvamUgZGFuZS4gPGJyLz48YnIvPiA8Yj5Vd2FnYTo8Lz4gTWFzeiBtYWtzeW1hbG5pZSA0IHByw7NieSBhYnkgd3Bpc2HEhyBwb3ByYXduZSBoYXPFgm8gaSBvZGJsb2tvd2HEhyBrb250bywgamXFvGVsaSB6YXBvbW5pYcWCZcWbIGtvZHUgUElOIGx1YiB3cGlzYcWCZcWbIHrFgmUgaGFzxYJvIHdpxJljZWogcmF6eSwgYXBsaWthY2phIHVzdW5pZSB3c3p5c3RraWUgZGFuZSB1xbx5dGtvd25pa2EuIE1vxbxlc3ogc2nEmSB3dGVkeSB6YWxvZ293YcSHIHBvbm93bmllIGkga29udHludW93YcSHIHXFvHl0a293YW5pZSBhcGxpa2FjamkuXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIlBvd2lhZG9taWVuaWFcIixcblx0XCJWT1RFX1RFWFRcIjogXCJPdHJ6eW1hc3ogcG93aWFkb21pZW5pZSwgZ2R5IGt0b8WbIG9kZGEgZ8WCb3MgbmEgdHfDs2ogd3BpcyEgPGJyLz48Yj5Vd2FnYTo8L2I+UG93aWFkb21pZW5pYSB6YXdpZXJhasSFIHRha8W8ZSB0eXAgZ8WCb3N1ICh0em4uIGfFgm9zIHphLCBnxYJvcyBwcnplY2l3LCBhbnVsdWogZ8WCb3MpLlwiLFxuXHRcIlZPVEVcIjogXCJaYWfFgm9zdWpcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJPdHJ6eW1hc3ogcG93YWRvbWllbmllLCBnZHkga3RvxZsgc2tvbWVudHVqZSB0d8OzaiB3cGlzIGx1YiBrb21lbnRhcnohPGJyLz4gPGI+VXdhZ2E6PC9iPlpvc3Rhbmllc3ogcsOzd25pZcW8IHBvd2lhZG9taW9ueSwgZ2R5IGt0b8WbIDxiPmVkeXR1amU8L2I+IHN3w7NqIGtvbWVudGFyei5cIixcblx0XCJDT01NRU5UXCI6IFwiS29tZW50YXJ6XCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCJPdHJ6eW1hc3ogcG93aWFkb21pZW5pZSwgZ2R5IGt0b8WbIHphY3puaWUgbHViIHByemVzdGFuaWUgY2nEmSBvYnNlcndvd2HEhyFcIixcblx0XCJNRU5USU9OU1wiOiBcIld6bWlhbmtpXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlpvc3Rhbmllc3ogcG93aWFkb21pb255LCBnZHkga3RvxZsgd3Nwb21uaSBjacSZIHcgc3dvaW0gd3Bpc2llL2tvbWVudGFyenUhXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlJlYmxvZ3VqXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiT3RyenltYXN6IHBvd2lhZG9taWVuaWUsIGdkeSBrdG/FmyByZXN0ZWVtdWplIHR3w7NqIHdwaXMhXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJLb25maWd1cmFjamVcIixcblx0XCJWT1RJTkdcIjogXCJPZGRhbmllIGfFgm9zdVwiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiTW9jIGx1YiBwcm9jZW50IGfFgm9zdSB3cMWCeXdhIG5hIG1vYyBvZGRhbmVnbyBnxYJvc3UgaSB1bW/FvGxpd2lhIGNpIG5hIHJlZ3Vsb3dhbmllIHN3b2plZ28gd3luYWdyb2R6ZW5pYSB6YSBvZGRhbmUgZ8WCb3N5LiA8YnIvPjxici8+PGI+VXdhZ2E6PC9iPiBabWlhbmEgd3DFgnluaWUgbmEgbW9jL3Byb2NlbnQgZ8WCb3N1IGNhxYJlaiBhcGxpa2FjamksIGRvdHljenkgdG8gcsOzd25pZcW8IGfFgm9zw7N3IG9kZGFueWNoIHByemVjaXdcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ3ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJla29tZW5kb3dhbmVcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJaYWNob3dhaiB6bWlhbnlcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcIkfFgm9zb3dhbGlcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJXaXRhaiBwb25vd25pZSFcIixcblx0XCJMT0dJTl8xXCI6IFwiQWJ5IGtvbnR5bnVvd2HEhywgemFsb2d1aiBzacSZIHByenkgdcW8eWNpdSBsb2dpbnUgaSBoYXPFgmEuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIktsdWN6IHVkb3N0xJlwbmlhasSFY3kgamVzdCB1xbx5d2FueSBkbyB1ZG9zdMSZcG5pYW5pYSB3cGlzw7N3LCBrb21lbnRvd2FuaWEsIGfFgm9zb3dhbmlhIGkgxZtsZWR6ZW5pYS5cIixcblx0XCJMT0dJTl8zXCI6IFwiS2x1Y3ogYWt0eXdueSB1xbx5d2FueSBqZXN0IGRvIHd5a29ueXdhbmlhIHByemVsZXfDs3cgaSB6bWlhbiB6ZGrEmWNpYSBwcm9maWxvd2Vnby5cIixcblx0XCJMT0dJTl80XCI6IFwiRGFuZSB1xbx5dGtvd25pa2Egc8SFIHRyenltYW5lIGxva2FsbmllIHByenkgdcW8eWNpYSB0d29qZWdvIHVyesSFZHplbmlhLiBQbyB3eWxvZ293YW5pdSBkYW5lIHpvc3RhasSFIHVzdW5pxJl0ZSFcIixcblx0XCJET05UX0hBVkVcIjogXCJOaWUgbWFzeiBqZXN6Y3plIGtvbnRhP1wiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiWmHFgsOzxbwga29udG9cIixcblx0XCJDQU5DRUxcIjogXCJBbnVsdWpcIixcblx0XCJBRFZBTkNFRFwiOiBcIlphYXdhbnNvd2FuZVwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCJLbHVjeiBha3R5d255IHByeXdhdG55XCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJLbHVjeiB1ZG9zdMSZcG5pYWrEhWN5IHByeXdhdG55XCIsXG5cdFwiTUFTVEVSX1BBU1NcIjogXCJIYXPFgm8gZ8WCw7N3bmVcIixcblx0XCJVU0VSTkFNRVwiOiBcIkxvZ2luXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwiV2lkb2sga2FydHlcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCJXaWRvayBrb21wYWt0b3d5XCIsXG5cdFwiU0VBUkNIXCI6IFwiU3p1a2FqXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJPcHVibGlrdWogdHJlxZvEh1wiLFxuXHRcIlJFUExZVE9cIjogXCJPZHBvd2llZHpcIixcblx0XCJQT1NUXCI6IFwiT3B1Ymxpa3VqXCIsXG5cdFwiUFJFVklFV1wiOiBcIlBvZGdsxIVkXCIsXG5cdFwiREVGQVVMVFwiOiBcIlN0YW5kYXJkb3dlIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJQb3dlciBVcCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJPZG3Ds3cgd3luYWdyb2R6ZW5pYVwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiWkFDSE9XQUogTkEgUMOTxblOSUVKXCIsXG5cdFwiQ0xFQVJcIjogXCJXWUNaWcWaxIZcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCJPcHVibGlrdWogd3Bpc1wiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIlNrb21lbnR1alwiLFxuXHRcIlRJVExFXCI6IFwiVHl0dcWCXCIsXG5cdFwiVEFHU1wiOiBcIkV0eWtpZXR5XCIsXG5cdFwiTk9UX01BVENIXCI6IFwiQlJBSyBaR09ETk/FmkNJXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJQb3d0w7NyeiBQSU5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJOSUVQT1BSQVdOWVwiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIm90d2llcmFuaWUgd3Bpc3VcIixcblx0XCJTRVRfUElOXCI6IFwiVXN0YXcgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiUG9kYWogUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwiQ3p5IGplc3RlxZsgcGV3aWVuP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVibG9nIGplc3Qgbmllb2R3cmFjYWxuZSwgY3p5IGNoY2VzeiBrb250eW51b3dhxIc/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwiQsWCxIVkIHBvxYLEhWN6ZW5pYSwgc3Byw7NidWogcG9ub3duaWUhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlpha2/FhGN6b25vIHBvd29kemVuaWVtXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCJSZWJsb2d1aiB3cGlzIVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJCxYLEhWQgbG9nb3dhbmlhISBVcGV3bmlqIHNpxJkgY3p5IHphbG9nb3dhxYJlxZsgc2nEmSBwcnp5IHXFvHljaXUga2x1Y3phIGfFgsOzd25lZ28gbHViIGN6eSB1xbx5xYJlxZsgYWt0eXduZWdvIGtsdWN6YSBwcnl3YXRuZWdvIHByenkgbG9nb3dhbml1IHcgdHJ5YmllIHphYXdhbnNvd2FueW0uXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwiQsWCxIVkIGxvZ293YW5pYSEgVXBld25paiBzacSZIGN6eSB6YWxvZ293YcWCZcWbIHNpxJkgcHJ6eSB1xbx5Y2l1IGtsdWN6YSBnxYLDs3duZWdvIGx1YiBjenkgdcW8ecWCZcWbIHByeXdhdG5lZ28ga2x1Y3phIHVkb3N0xJlwbmlhasSFY2VnbyBwcnp5IGxvZ293YW5pdSB3IHRyeWJpZSB6YWF3YW5zb3dhbnltLlwiLFxuXHRcIldBUk5JTkdcIjogXCJVd2FnYVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJHxYJvc3VqZXN6IG5hIMWbd2lhZGthXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJaYWfFgm9zb3dhxYJlxZsgbmEgxZt3aWFka2FcIixcblx0XCJBR09cIjogXCJ0ZW11XCIsXG5cdFwiRlJPTV9OT1dcIjogXCJvZCB0ZXJhelwiLFxuXHRcIlNFQ1NcIjogXCJzZWt1bmQoeSlcIixcblx0XCJBX01JTlwiOiBcIm1pbnV0xJlcIixcblx0XCJNSU5TXCI6IFwibWludXQoeSlcIixcblx0XCJBTl9IT1VSXCI6IFwiZ29kemluxJlcIixcblx0XCJIT1VSU1wiOiBcImdvZHppbih5KVwiLFxuXHRcIkFfREFZXCI6IFwiZHppZcWEXCIsXG5cdFwiREFZU1wiOiBcImRuaVwiLFxuXHRcIkFfTU9OVEhcIjogXCJtaWVzacSFY1wiLFxuXHRcIk1PTlRIU1wiOiBcIm1pZXNpxJljeVwiLFxuXHRcIkFfWUVBUlwiOiBcInJva1wiLFxuXHRcIllFQVJTXCI6IFwibGF0KGEpXCIsXG5cdFwiTUlOX1JFQURcIjogXCJtaW51dCB0ZW11IHpvc3RhxYJvIHByemVjenl0YW5lXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIkfFgm9zdWogcHJ6ZWNpdyBsdWIgb2ZsYWd1alwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIlpyw7NiIHpkasSZY2llXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJXeWJpZXJ6IG9icmF6XCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJVc3RhdyB3eWJyYW55IFVSTFwiLFxuXHRcIklOU0VSVF9QSUNUVVJFXCI6IFwiV3N0YXcgb2JyYXpcIixcblx0XCJFUlJPUlwiOiBcIkLFgsSFZFwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkLFgsSFZCBwcnp5IHdyenVjYW5pdSBwbGlrdVwiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJBcGFyYXQgbmllYWt0eXduYVwiLFxuXHRcIlNFVF9VUkxcIjogXCJVc3RhdyBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiQmV6cG/Fm3JlZG5pIGxpbmsgbmEgc3Ryb27EmSB6ZSB6ZGrEmWNpZW1cIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIktvbWVudGFyeiB6b3N0YcWCIG9wdWJsaWtvd2FueSFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIlVzdW5pxJljaWUga29tZW50YXJ6eSBqZXN0IG5pZW9kd3JhY2FsbmUuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJVc3XFhCBrb21lbnRhcnpcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIldzdGF3IHpkasSZY2llXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIldzdGF3aWVuaWUgemFrb8WEY3pvbmVcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiV3J6dWNlbmllIG5pZSBwb3dpb2TFgm8gc2nEmVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIk5pZXByYXdpZMWCb3d5IGxvZ2luIGx1YiBoYXPFgm9cIixcblx0XCJJTkZPXCI6IFwiSW5mb3JtYWNqYVwiLFxuXHRcIlFSX1RFWFRcIjogXCJVbWllxZvEhyBrb2QgUVIgdyBvYnLEmWJpZSBwb2xhIHNrYW5vd2FuaWFcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCJVcGV3bmlqIHNpxJksIGN6eSBtYXN6IHd5c3RhcmN6YWrEhWPEhSBpbG/Fm8SHIMWbcm9ka8OzdyBhYnkgd3lrb25hxIcgdHJhbnNha2NqxJkhXCIsXG5cdFwiTk9ORVhJU1RfVVNFUlwiOiBcIlXFvHl0a293bmlrIGRvIGt0w7NyZWdvIHByw7NidWplc3ogcHJ6ZXPFgmHEhyDFm3JvZGtpLCBuaWUgaXN0bmllamUhXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIkN6eSBuYSBwZXdubyBjaGNlc3ogd3lzxYJhxIcgxZtyb2RraT9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJQb3R3aWVyZHplbmllXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJUcmFuc2FrY2phIHcgdG9rdVwiLFxuXHRcIkZFRURcIjogXCJBa3R1YWxub8WbY2lcIixcblx0XCJUUkVORElOR1wiOiBcIlRyZW5keVwiLFxuXHRcIkhPVFwiOiBcIk5hIHRvcGllXCIsXG5cdFwiTkVXXCI6IFwiTm93ZVwiLFxuXHRcIlBST01PVEVEXCI6IFwiUHJvbW93YW5lXCIsXG5cdFwiVk9URVNcIjogXCJJbG/Fm8SHIGfFgm9zw7N3XCIsXG5cdFwiUEFZT1VUXCI6IFwiUHJ6eWNow7NkXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJJbG/Fm8SHIEtvbWVudGFyenlcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5keSB6IDMwIGRuaVwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIlVwb3J6xIVka3VqIHdlZMWCdWc6XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiQ3lrbCBwcnp5Y2hvZHVcIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUG90ZW5jamFsbnkgcHJ6eWNow7NkXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCJXY3plxZtuaWVqIHd5cMWCYWNvbm9cIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiUHJ6eWNow7NkIGF1dG9yYVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIlByenljaMOzZCB6YSBtZWNlbmF0XCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJXcGlzIHpvc3RhxYIgb3B1Ymxpa293YW55IVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJPcHVibGlrdWogd3BpcyBww7PFum5pZWohXCIsXG5cdFwiU0FWRURcIjogXCJaYXBhbWnEmXRhalwiLFxuXHRcIkNMRUFSRURcIjogXCJXeWN6ecWbxIdcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwiT2ZsYWdvd2FuaWUgd3Bpc3UgbW/FvGUgc3Bvd29kb3dhxIcgdXN1bmnEmWNpZSB3eW5hZ3JvZHplbmlhIGkgem1uaWVqc3plbmllIGplZ28gd2lkb2N6bm/Fm2NpLjxicj48YnI+RmxhZ2EgcG93aW5uYSBiecSHIHXFvHl0YSB3IHN5dHVhY2phY2ggdGFraWNoIGphazogPHVsPjxsaT5Pc3p1c3R3byBsdWIgUGxhZ2lhdDwvbGk+PGxpPk1vd8SZIG5pZW5hd2nFm2NpIGx1YiBJbnRlcm5ldG93eSB0cm9sbGluZzwvbGk+PGxpPldwaXMgY2Vsb3dvIMW6bGUgc2thdGFnb3J5em93YW55IGx1YiBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWl0IHpvc3RhxYIgb3NpxIVnbmnEmXR5LiBTcHJhd2TFuiBpbm5lIGV0eWtpZXR5L3RyZW5keSFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJXcGlzIHpvc3RhxYIgdXN1bmnEmXR5IHogemFrxYJhZGVrIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJXcGlzIHpvc3RhxYIgZG9kYW55IGRvIHpha8WCYWRlayFcIixcblx0XCJSRVNFVFwiOiBcIlpyZXNldHVqXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCJabW9keWZpa3VqIHpkasSZY2llIHByb2ZpbG93ZVwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiWm1pZcWEIHpkasSZY2llIHcgdGxlXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiUG9kYWogYWt0eXdueSBrbHVjeiBwcnl3YXRueSBqZcWbbGkgd3licmHFgmXFmyB0cnliIHphYXdhbnNvd2FuZWdvIGxvZ293YW5pYSFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCJTcG93b2R1amUgenJlc2V0b3dhbmllIHpkasSZY2lhIHByb2ZpbG93ZWdvXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiU3Bvd29kdWplIHpyZXNldG93YW5pZSB6ZGrEmWNpYSB3IHRsZVwiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwiQWt0dWFsaXphY2phIHNlcndlcmEgd3ltYWdhIHpyZXNldG93YW5pYSFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiVXN0YXdpZW5pYSB6b3N0YcWCeSB6YWt0dWFsaXpvd2FuZVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkrEmXp5a1wiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiVHUgbW/FvGVzeiB6bWllbmnEhyBqxJl6eWsgYXBsaWthY2ppLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJUYSBvcGVyYWNqYSB3eW1hZ2EgemFsb2dvd2FuaWEgaGFzxYJlbSBnxYLDs3dueW0sIGtsdWN6ZW0gYWt5dHdueW0vdWRvc3TEmXBuaWFqxIVjeW0uIFphbG9ndWogc2nEmSBpIHNwcsOzYnVqIHBvbm93bmllLlwiLFxuXHRcIkdBTExFUllcIjogXCJHYWxlcmlhXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwiUHJ6ZXTFgnVtYWN6eWxpXCIsXG5cdFwiU0hBUkVcIjogXCJQb2xlxIdcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIlNrbGVwXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJXeW1pYW5hXCIsXG5cdFwiRFJBRlRTXCI6IFwiV2Vyc2plIHJvYm9jemVcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJXcGlzIHpvc3RhxYIgdXN1bmnEmXR5IHogcm9ib2N6eWNoIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJXcGlzIHpvc3RhxYIgemFwaXNhbnkgamFrbyB3ZXJzamEgcm9ib2N6YSFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiUHJ6ZWNpxIVnbmlqIHcgbGV3bywgYWJ5IHpvYmFjennEhyBvcGNqZVwiLFxuXHRcIk1BTkFHRVwiOiBcIlphcnrEhWR6YWpcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiT2JyYXogem9zdGHFgiB1c3VuacSZdHlcIixcblx0XCJDT1BZXCI6IFwiS29waXVqXCIsXG5cdFwiTk9fSU1BR0VcIjogXCJOaWUgb3B1Ymxpa293YcWCZcWbIGplc3pjemUgxbxhZG5lZ28gb2JyYXp1IVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwiUHJ6ZWNpxIVnbmlqIHcgZMOzxYIsIGFieSBvZMWbd2llxbx5xIcuXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkFwbGlrYWNqZSB6ZXduxJl0cnpuZVwiLFxuXHRcIlBMVUdJTlNcIjogXCJQbHVnaW55XCIsXG5cdFwiU1VHR0VTVFwiOiBcIlphc3VnZXJ1alwiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiSnXFvCB3a3LDs3RjZVwiLFxuXHRcIkNIQUlOXCI6IFwixYFhxYRjdWNoXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIlR1dGFqIG1vxbxlc3ogem1pZW5pxIcgxYJhxYRjdWNoIGJsb2vDs3cgbHViIGRvbXnFm2xuxIUgcGxhdGZvcm3EmS5cIixcblx0XCJDVVJSRU5DWVwiOiBcIldhbHV0YVwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCJUdXRhaiBtb8W8bmEgem1pZW5pxIcgZG9tecWbbG7EhSB3YWx1dMSZLiBXYXJ0b8WbxIcgbmFncm9keSB6YSBwb3N0L2tvbWVudGFyeiB6b3N0YW5pZSB3ecWbd2lldGxvbmEgdyB0ZWogd2FsdWNpZS5cIixcblx0XCJBQk9VVF8xMVwiOiBcIjxicj48Yj5MaXN0YSBmdW5rY2ppPC9iPjxicj4tIERvc3TEmXAgZG8gdW5pa2FsbnljaCB0cmXFm2NpIHoga3LEmWfDs3cgVHdvaWNoIHphaW50ZXJlc293YcWELjxicj4tIFphYW5nYcW8dWogc2nEmSB3IGR5c2t1c2plIHogYXV0b3JhbWkuPGJyPiAtIEfFgm9zdWogbmEgcG9zdHkgYnkgbmFncm9kemnEhyBhdXRvcsOzdywgemRvYnl3YWogd3luYWdyb2R6ZW5pZSB6YSB6bmFqZG93YW5pZSB3YXJ0b8WbY2lvd3ljaCB0cmXFm2NpLjxicj4gLSBQdWJsaWt1aiBhcnR5a3XFgnkgaSB6YXJhYmlhaiBuYSBuaWNoIHpkb2J5d2FqxIVjIHp3b2xlbm5pa8Ozdzxicj4gLSBQaXN6IHBvZGN6YXMgcG9kcsOzxbx5LCB6YXBpc3VqIHdpZWxlIGtvcGlpIHJvYm9jenljaCBkbyBww7PFum5pZWpzemVqIHB1Ymxpa2FjamkuPGJyPiAtIERvZGFqIHVsdWJpb25lIGFydHlrdcWCeSBkbyB6YWvFgmFkZWsgYnkgcHJ6ZWN6eXRhxIcgamUgcMOzxbpuaWVqLjxicj4gLSBXeW1pZcWEIGx1YiB3eXDFgmHEhyBzd29qZSB6YXJvYmtpLiA8YnI+IC0gV3nFm2xpaiBzd29qZSDFm3JvZGtpIGRvIGF1dG9yw7N3LCB1xbx5dGtvd25pa8OzdywgcHJ6eWphY2nDs8WCLCB6d29sZW5uaWvDs3csIGV0Yy48YnI+IC3FmmxlZMW6IGNpZWthd3ljaCBhdXRvcsOzdy48YnI+IC0gV3lzenVraXdhbmllIHfFm3LDs2QgcG9zdMOzdyBzd29pY2ggendvbGVubmlrw7N3IG9yYXogxZtsZWR6b255Y2ggYXV0b3LDs3cuLjxicj4gLSBPdHJ6eW11aiBwb3dpYWRvbWllbmlhIGJ5IG5pZSBwcnplZ2FwacSHIGR5c2t1c2ppIHcga3TDs3JlIGplc3RlxZsgemFhbmdhxbxvd2FueS48YnI+IC0gU3p1a2FqIGNpZWthd3ljaCB0YWfDs3cgLyBrYXRlZ29yaWkuIDxicj4gLVNwZXJzb25hbGl6dWogc3fDs2ogcHJvZmlsLiA8YnI+IEplc3pjemUgd2nEmWNlaiBmdW5rY2ppIHdrcsOzdGNlLi4gPGJyPjxicj48Yj5CZXpwaWVjemXFhHN0d288L2I+IDxicj4xLiBBcGxpa2FjamEgbmlnZHkgbmllIHNpxJlnYSBkbyBUd29pY2ggxZtyb2Rrw7N3Li4gPGJyPjIuIEFwbGlrYWNqYSBvZmVydWplIG1vZGVsIHphYmV6cGllY3plxYQgcG8gc3Ryb25pZSBrbGllbnRhLCB6IGtsdWN6YW1pIHByeXdhdG55bWkgdHJ6eW1hbnltaSBsb2thbG5pZSBpIG5pZ2R5IG5pZSB3eXN5xYJhIGljaCBkbyDFvGFkbmVnbyBzZXJ3ZXJhLiBKZXN0ZcWbIG9kcG93aWVkemlhbG55IHphIHd5a29ueXdhbmllIGtvcGlpIHphcGFzb3d5Y2ggc3dvaWNoIGhhc2XFgi4gPGJyPjMuIEFwbGlrYWNqYSBvZmVydWplIHByb3N0eSwgYXRyYWtjeWpueSBpbnRlcmZlanMgdcW8eXRrb3duaWthLiA8YnI+NC4gRG9kYXRrb3dhIHdhcnN0d2EgemFiZXpwaWVjemXFhCB3IHBvc3RhY2kga29kdSBQaW4gPGJyPjxicj5lU3RlZW0gb2JzxYJ1Z3VqZSBwbGF0Zm9ybXkgU3RlZW0gb3JheiBHb2xvcy4gPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCJaYcWCb8W8eWNpZWwgaSBnxYLDs3dueSBwcm9ncmFtaXN0YVwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiRG9kYWoga29udG9cIixcblx0XCJQTEFURk9STVwiOiBcIlBsYXRmb3JtYVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcIkFnZW50IEVzY3Jvd1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlRlcm1pbiByYXR5ZmlrYWNqaVwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwiV3lnYcWbbmnEmWNpZSBFc2Nyb3dcIixcblx0XCJFU0NST1dfRkVFXCI6IFwiT3DFgmF0YSB6YSB1c8WCdWfEmSBFc2Nyb3dcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJXYXJ1bmtpIHVzxYJ1Z2kgRXNjcm93XCIsXG5cdFwiTklHSFRfTU9ERVwiOiBcIlRyeWIgTm9jbnlcIixcblx0XCJEQVlfTU9ERVwiOiBcIlRyeWIgZHppZW5ueVwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcIlpvYmFjeiBwZcWCbnkga29udGVrc3RcIixcblx0XCJVU0VSX05PVEZPVU5EXCI6IFwiTmllIHpuYWxlemlvbm8gdcW8eXRrb3duaWthXCIsXG5cdFwiQVBQUk9WRVwiOiBcIlphdHdpZXJkxbpcIixcblx0XCJESVNQVVRFXCI6IFwiU3DDs3JcIixcblx0XCJSRUxFQVNFXCI6IFwiVXdvbG5palwiLFxuXHRcIkZST01cIjogXCJPZFwiLFxuXHRcIklEXCI6IFwiaWRcIixcblx0XCJTVUJNSVRcIjogXCJQcnplxZtsaWpcIixcblx0XCJSRUNFSVZFUlwiOiBcIk9kYmlvcmNhXCIsXG5cdFwiTE9DQVRJT05cIjogXCJMb2thbGl6YWNqYVwiLFxuXHRcIldFQlNJVEVcIjogXCJXaXRyeW5hIGludGVybmV0b3dhXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwiTmF6d2Egd3nFm3dpZXRsYW5hXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIlDDoWdpbmEgSW5pY2lhbFwiLFxuXHRcIkxPR0lOXCI6IFwiRW50cmFyXCIsXG5cdFwiTE9HT1VUXCI6IFwiU2FpclwiLFxuXHRcIlBST0ZJTEVcIjogXCJQZXJmaWxcIixcblx0XCJGT0xMT1dcIjogXCJTZWd1aXJcIixcblx0XCJCT09LTUFSS1NcIjogXCJGYXZvcml0b3NcIixcblx0XCJUUkFOU0ZFUlwiOiBcIlRyYW5zZmVyaXJcIixcblx0XCJNQVJLRVRcIjogXCJNZXJjYWRvXCIsXG5cdFwiU0VUVElOR1NcIjogXCJDb25maWd1cmHDp8O1ZXNcIixcblx0XCJBQk9VVFwiOiBcIlNvYnJlXCIsXG5cdFwiQUJPVVRfMVwiOiBcIm9uZGUgcXVhbHF1ZXIgdW0gcG9kZSBnYW5oYXIgcmVjb21wZW5zYXMgcGVsbyBzZXUgY29udGXDumRvXCIsXG5cdFwiQUJPVVRfMlwiOiBcIsOpIHBhdHJvY2luYWRvIHBlbGEgcGxhdGFmb3JtYSB7e3BsYXRmb3JtbmFtZX19LiBBcGxpY2F0aXZvIGNyaWFkbyBwb3JcIixcblx0XCJBQk9VVF8zXCI6IFwiZSDDqSBjw7NkaWdvLWFiZXJ0bywgcHJvamVjdG8gb3JpZW50YWRvIHBhcmEgYSBjb211bmlkYWRlIG3Ds3ZlbC4gT2ZlcmVjZSBhY2Vzc28gYW8gY29udGXDumRvIHBhcmEgbGVpdHVyYSwgY29tZW50w6FyaW9zLCB2b3RvcywgcHVibGljYXIsIHRyYW5mZXJpciBnYW5ob3MgZXRjLiBDYXJhdGVyw61zdGljYXMgb2ZlcmVjaWRhcyBwZWwge3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGUge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiBPIGFwbGljYXRpdm8gbnVuY2EgYWNlc3NhIG91IGd1YXJkYSBvIGRpbmhlaXJvIGRvcyB1c3XDoXJpb3MuXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIEEgQXBwIG9mZXJlw6dlIHVtIG1vZGVsbyBzZWd1cm8gZG8gbGFkby1jbGllbnRlLCBjb20gY2hhdmVzIHByaXZhZGFzLCBndWFyZGFkYXMgbG9jYWxtZW50ZSBlIG51bmNhIGVudmlkYSBhIG91dHJvcyBzZXJ2aWRvcmVzLlwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLiBPIEFwbGljYXRpdm8gb2ZlcmVjZSBzaW1wbGljaWRhZGUsIGludGVyZmFjZXMgZGUgdXN1w6FyaW8gZSBleHBlcmnDqm5jaWFzIGF0cmF0aXZhcy5cIixcblx0XCJBQk9VVF83XCI6IFwiNC4gTyBBcGxpY2F0aXZvIHJlcXVlciBxdWUgb3MgdXN1w6FyaW9zIGluc2lyYW0gaW5mb3JtYcOnw7VlcyBwZXNzb2Fpcy5cIixcblx0XCJBQk9VVF84XCI6IFwiVm90ZSBib20ta2FybWEgY29tbyB0ZXN0ZW11bmhhXCIsXG5cdFwiQUJPVVRfOVwiOiBcIkNvbnRhdG8vQ29tZW50w6FyaW9zXCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNYWlzIGluZm9ybWHDp8O1ZXM6XCIsXG5cdFwiUkVNT1ZFXCI6IFwiUmVtb3ZlclwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwiVmlzw6NvIGRvIE1lcmNhZG9cIixcblx0XCJQUklDRVwiOiBcIlByZcOnb1wiLFxuXHRcIkFNT1VOVFwiOiBcIlF1YW50aWRhZGVcIixcblx0XCJOT09SREVSU1wiOiBcIlNlbSBvcmRlbnMgYWJlcnRhcyBwYXJhXCIsXG5cdFwiREFURVwiOiBcIkRhdGFcIixcblx0XCJCVVlcIjogXCJDb21wcmFyXCIsXG5cdFwiU0VMTFwiOiBcIlZlbmRlclwiLFxuXHRcIk9QRU5cIjogXCJBYnJpclwiLFxuXHRcIkhJU1RPUllcIjogXCJIaXTDs3JpY29cIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIlNlZ3VpciBkZSB2b2x0YVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiU2VndWlkb1wiLFxuXHRcIlVORk9MTE9XXCI6IFwiRGVpeGFyIGRlIHNlZ3VpclwiLFxuXHRcIkZPTExPV0lOR1wiOiBcIlNlZ3VpbmRvXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwiU2VndWlkb3Jlc1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCJQcm9jdXJhciBzZWd1aWRvcmVzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIlByb2N1cmFyIHF1ZW0gZXN0b3Ugc2VndWluZG9cIixcblx0XCJCWVwiOiBcInBvclwiLFxuXHRcIklOXCI6IFwibm9cIixcblx0XCJCT09LTUFSS1wiOiBcIkZhdm9yaXRvc1wiLFxuXHRcIlJFQkxPR1wiOiBcIlJlcG9zdGFyXCIsXG5cdFwiVVBWT1RFXCI6IFwiVXB2b3RlXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkNhbmNlbGFyIERvd252b3RlXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCJDYW5jZWxhciBVcHZvdGVcIixcblx0XCJSRVBMWVwiOiBcIlJlc3BvbmRlclwiLFxuXHRcIkVESVRcIjogXCJFZGl0YXJcIixcblx0XCJQT1NUXzFcIjogXCJEZXNsaXplIHBhcmEgZXNxdWVyZGEgbm9zIGNvbWVudMOhcmlvcyBwYXJhIHZlciBhcyBvcMOnw7Vlc1wiLFxuXHRcIlBPU1RfMlwiOiBcIlRvcXVlIG5vcyBjb21lbnTDoXJpb3MgcGFyYSB2ZXIgb3Mgc3ViLWNvbWVudMOhcmlvc1wiLFxuXHRcIk9QVElPTlNcIjogXCJPcMOnw7Vlc1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlcG9zdGFkbyBwb3JcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOYWRhIHBvciBhcXVpLCBhaW5kYS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiQmFsYW7Dp29cIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBwcm92YXMgdHJhbnNhY2lvbsOhdmVpcyBxdWUgcG9kZW0gc2VyIHRyYW5zZmVyaWRhcyBlbSBxdWFscXVlciBhbHR1cmEuIHt7cGxhdGZvcm1uYW1lfX0gcG9kZW0gc2VyIGNvbnZlcnRpZGFzIHt7cGxhdGZvcm1wb3dlcn19IG51bSBwcm9jZXNzbyBjaGFtYWRvIHBvZGVyIGFiYWl4by5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgcHJvdmFzIGRlIGluZmx1ZW5jaWEgcGFyIGdhbmhhciBtYWlzIHBvZGVyIHBvciBndWFyZGFyIGEgbG9uZ28gcHJhem8gZSB2b3RhciBuYXMgcHVibGljYcOnw7Vlcy4gUXVhbnRvIG1haXMgc2UgcG9zc3VpIG1haXMgc2UgcG9kZSBpbmZsdWVuY2lhciBhcyByZWNvbXBlbnNhcyBhIG91dHJvcyBlIGdhbmhhciBtYWlzIHJlY29tcGVuc2FzIHBvciB2b3Rhci5cIixcblx0XCJQUk9GSUxFXzNcIjogXCJQcm92YXMgdmFsZW5kbyBjZXJjYSBkZSB7e3BsYXRmb3Jtc3VuaXR9fSBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlZhbG9yIGVzdGltYWRvXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiTyB2YWxvciBlc3RpbWFkbyDDqSBiYXNlYWRvIG51bWEgbcOpZGlhIGRvIHZhbG9yIGRlIDcgZGlhcyBkZSB7e3BsYXRmb3JtbmFtZX19LlwiLFxuXHRcIlRSQU5TQUNUSU9OX0hJU1RPUllcIjogXCJIaXN0w7NyaWNvIGRlIFRyYW5zYcOnw7Vlc1wiLFxuXHRcIlBPU1RJTkdcIjogXCJQb3N0YW5kb1wiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIkEgY2hhdmUgZGUgcG9zdGFnZW0gw6kgdXNhZGEgcGFyYSBwb3N0YXIgZSB2b3Rhci4gRWxhIGRldmVyw6Egc2VyIGRpZmVyZW50ZSBkYSBjaGF2ZSBkZSBhdGl2YcOnw6NvIGUgZGEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpby5cIixcblx0XCJPV05FUlwiOiBcIlByb3ByaWV0w6FyaW9cIixcblx0XCJQUk9GSUxFXzZcIjogXCJBIGNoYXZlIGRlIHByb3ByaWV0w6FyaW8gw6kgYSBjaGF2ZSBtZXN0cmEgcGFyYSBjb250YSBlIMOpIGV4aWdpZGEgcGFyYSBtdWRhciBhcyBvdXRyYXMgY2hhdmVzLiBVbWEgY2hhdmUgcHJpdmFkYSBvdSBzZW5oYSBwYXJhIGEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpbyBkZXZlcsOhIHNlciBtYW50aWRhIG9mZmxpbmUgYXNzaW0gcXVlIHBvc3PDrXZlbC5cIixcblx0XCJBQ1RJVkVcIjogXCJBdGl2b1wiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIkEgY2hhdmUgZGUgYXRpdmHDp8OjbyDDqSB1c2FkYSBwYXJhIGZhemVyIHRyYW5zZmVyw6puY2lhcyBlIGNvbG9jYXIgb3JkZW5zIG5vIG1lcmNhZG8gaW50ZXJuby5cIixcblx0XCJNRU1PXCI6IFwiQW5vdGHDp8O1ZXNcIixcblx0XCJQUk9GSUxFXzhcIjogXCJBIGNoYXZlIGRlIGFub3Rhw6fDtWVzIMOpIHVzYWRhIHBhcmEgY3JpYXIgZSBsZXIgYW5vdGHDp8O1ZXMuXCIsXG5cdFwiUE9TVFNcIjogXCJQb3N0YWdlbnNcIixcblx0XCJSRVBMSUVTXCI6IFwiUmVzcG9zdGFzXCIsXG5cdFwiV0FMTEVUXCI6IFwiQ2FydGVpcmFcIixcblx0XCJVU0VSXCI6IFwiVXN1w6FyaW9cIixcblx0XCJDTE9TRVwiOiBcIkZlY2hhZG9cIixcblx0XCJUT1wiOiBcIlBhcmFcIixcblx0XCJBU1NFVFwiOiBcIkF0aXZvXCIsXG5cdFwiU0VORFwiOiBcIkVudmlhclwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU2VndXJhbsOnYVwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIkRpc3BvbsOtdmVsXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJNZW1vcmFuZG8gUMO6YmxpY29cIixcblx0XCJUT19ERVNDXCI6IFwiVXRpbGl6YWRvciBleDogZ29vZC1rYXJtYVwiLFxuXHRcIlBJTl9DT0RFXCI6IFwiQ8OzZGlnbyBQaW5cIixcblx0XCJQSU5fVEVYVFwiOiBcIkPDs2RpZ28gUGluIGFqdWRhIHZvY8OqIGEgYXNzZWd1cmFyIG8gYXBsaWNhdGl2byBlIHN1YXMgaW5mb3JtYcOnw7Vlcy4gPGJyLz48YnIvPiBVbWEgdmV6IGF0aXZhZG8sIHZvY8OqIHRlcsOhIG5vIG3DoXhpbW8gNCB0ZW50YXRpdmFzIHBhcmEgZGVzdHJhdmFyLCBzZSB2b2NlIGVzcXVlY2VybyBwaW4gb3UgZXJyYXIsIG8gYXBsaWNhdGl2byBpcsOhIHJlbW92ZXIgc3VhcyBpbmZvcm1hw6fDtWVzIGRlIHVzdcOhcmlvLiBWb2PDqiBwb2RlIGVudHJhciBkZSBub3ZvIGUgY29udGludWFyIGEgdXNhciBvIGFwbGljYXRpdm8uXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWNhw6fDtWVzXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiVm9jw6ogcmVjZWJlcsOhIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIHZvdGVyIG5vIHNldSBjb250ZcO6ZG8hIE5vdGlmaWNhw6fDtWVzIHRhbWLDqW0gaW5jbHVlbSBwZXNvIGRlIHZvdG8gbm8gYWxlcnRhIGRhIG1lbnNhZ2VtLikgc2VqYSB2b3RvIHBvc2l0aXZvLCB2b3RvIG5lZ2F0aXZvLCB2b3RvIG51bG8pLlwiLFxuXHRcIlZPVEVcIjogXCJWb3RhclwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlZvY8OqIHJlY2ViZXLDoSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIGNvbWVudGFyIG5hcyBzdWFzIHBvc3RhZ2VucyBvdSBjb21lbnTDoXJpb3MuPGJyLz4gTm90aWZpY2HDp8O1ZXMgaW5jbHVlbSBxdWFuZG8gYWxndcOpbSBlZGl0YSBvcyBjb21lbnTDoXJpb3MgdGFtYsOpbS5cIixcblx0XCJDT01NRU5UXCI6IFwiQ29tZW50YXJcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIlZvY8OqIHJlY2ViZXLDoSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBTZWd1aXIgb3UgRGVpeGFyIGRlIHNlZ3VpciB2b2PDqiFcIixcblx0XCJNRU5USU9OU1wiOiBcIk1lbsOnw7Vlc1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCJWb2PDqiByZWNlYmVyw6EgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gbWVuY2lvbmFyIHZvY8OqIGVtIGFsZ3VtYSBwb3N0YWdlbSBvdSBjb21lbnTDoXJpbyFcIixcblx0XCJDT05GSUdVUkFUSU9OU1wiOiBcIkNvbmZpZ3VyYcOnw7Vlc1wiLFxuXHRcIlZPVElOR1wiOiBcIlZvdGFuZG9cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIk8gcGVzbyBkZSB2b3RvIG91IHBlcmNlbnRhZ2VtIGFmZXRhIG8gcG9kZXIgZGUgdm90byBuYSBhcHAsIHBvciBpc3NvIHBvZGUgcmVndWxhciBvIHNldSByZWNvbXBlbnNhIGRlIHZvdG8gPGJyLz48YnIvPjxiPk5vdGE6PC9iPiBJc3RvIGlyw6EgbW9kaWZpY2FyIG8gcHNlc28vcGVyY2VudGFnZW0gcGFyYSB2b3RhciBwYXJhIGJhaXhvIHRhbWLDqW0gZSBlbSB0b2RvIG8gbGFkbyBuYSBBcHBcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2aWRvclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVjb21lbmRhZG9cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTYWx2YXIgbXVkYW7Dp2FzXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvcm1hw6fDtWVzIGRvcyBlbGVpdG9yZXNcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJCZW0gdmluZG8gZGUgVm9sdGEhXCIsXG5cdFwiTE9HSU5fMVwiOiBcIkNvbmVjdGUtc2UgY29tIHNldSBub21lIGRlIHVzdcOhcmlvIGUgc2VuaGEgcGFyYSBjb250aW51YXIuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIkNoYXZlIGRlIHBvc3RhZ2VtIMOpIHVzYWRhIHBhcmEgcG9zdGFyLCBjb21lbnRhciwgdm90YXIsIHNlZ3Vpci5cIixcblx0XCJMT0dJTl8zXCI6IFwiQ2hhdmUgZGUgYXRpdmHDp8OjbyDDqSB1c2FkYSBwYXJhIHRyYW5mZXLDqm5jaWFzIGUgYXR1YWxpemHDp8OjbyBkZSBmb3RvcyBkZSBwZXJmaWwuXCIsXG5cdFwiTE9HSU5fNFwiOiBcIkFzIGNyZWRlbmNpYWlzIGRvIHV0aWxpemFkb3Igc8OjbyBndWFyZGFkYXMgbG9jYWxtZW50ZSBubyBzZXUgYXBhcmVsaG8uIERlcGlzIGRlIGRlc2xpZ2FyIGFzIHN1YXMgY2VyZGVuY2lhaXMgc8OjbyByZW1vdmlkYXMhXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwiTsOjbyBwb3NzdWkgdW1hIGNvbnRhP1xcblwiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiQ2FkYXN0cmUtc2UgYWdvcmFcIixcblx0XCJDQU5DRUxcIjogXCJDYW5jZWxhclwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiQXZhbsOnYWRvXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIkNoYXZlIGRlIGF0aXZhw6fDo28gcHJpdmFkYVwiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwiQ2hhdmUgZGUgcG9zdGFnZW0gcHJpdmFkYVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiU2VuaGEgTWVzdHJhL1ByaW5jaXBhbFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiVXN1w6FyaW9cIixcblx0XCJDQVJEX1ZJRVdcIjogXCJWaXPDo28gZGUgQ2FydMOjb1wiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIlZpc3RhIGNvbXBhY3RhXCIsXG5cdFwiU0VBUkNIXCI6IFwiUHJvY3VyYXJcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIlBvc3RhciB1bWEgaGlzdMOzcmlhXCIsXG5cdFwiUkVQTFlUT1wiOiBcIlJlc3BvbmRlciBwYXJhXCIsXG5cdFwiUE9TVFwiOiBcIlBvc3RhZ2VtXCIsXG5cdFwiUFJFVklFV1wiOiBcIlZpenVhbGl6YcOnw6NvXCIsXG5cdFwiREVGQVVMVFwiOiBcIlBhZHLDo28gNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIkZvcsOnYSBUb3RhbCAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCJSZWN1c2FyIFBhZ2FtZW50b1wiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwiR3VhcmRhciBwcmEgbWFpcyB0YXJkZVwiLFxuXHRcIkNMRUFSXCI6IFwiVGVybWluYWRvXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwiQ29udGXDumRvIGRhIHBvc3RhZ2VtXCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwiQ29udGXDumRvIGRvIGNvbWVudMOhcmlvXCIsXG5cdFwiVElUTEVcIjogXCJUw610dWxvXCIsXG5cdFwiTk9UX01BVENIXCI6IFwiTsOjbyBjb25kaXpcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkNvbmZpcm1hciBQaW5cIixcblx0XCJJTkNPUlJFQ1RcIjogXCJJbmNvcnJldG9cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCJBYnJpbmRvIHBvc3RhZ2VtXCIsXG5cdFwiU0VUX1BJTlwiOiBcIkNvbmZpZ3VyZSBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCJFbnRyYXIgY29tIFBpblwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIlZvY8OqIHRlbSBjZXJ0ZXphP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVwdWJsaWNhciDDqSBpcnJldmVyc8OtdmVsLCBxdWVyIG1lc21vIGNvbnRpbnVhcj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJFcnJvIGRlIGRpZnVzw6NvLCB0ZW50ZSBub3ZhbWVudGUhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlN1Y2Vzc29cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlB1Ymx1Y2HDp8OjbyByZXB1YmxpY2FkYVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJMb2dpbiBmYWxob3UhIHBvciBmYXZvciBjZXJ0aWZpcXVlLXNlIHF1ZSBlc3TDoSBjb25ldGFkbyBjb20gYSBzZW5oYSBtYXN0ZXIgb3UgYSBjaGF2ZSBwdWJsaWNhw6fDo28gcHJpdmFkYSBubyBMb2dpbiBzZSBlc2NvbGhldSBvIG1vZG8gYXZhbsOnYWRvLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIkxvZ2luIGZhbGhvdSEgcG9yIGZhdm9yIGNlcnRpZmlxdWUtc2UgcXVlIGVzdMOhIGNvbmV0YWRvIGNvbSBhIHNlbmhhIG1hc3RlciBvdSBhIGNoYXZlIGF0aXZhIHByaXZhZGEgbm8gTG9naW4gc2UgZXNjb2xoZXUgbyBtb2RvIGF2YW7Dp2Fkby5cIixcblx0XCJXQVJOSU5HXCI6IFwiQ3VpZGFkb1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCJWb3RhbmRvIHBvciB1bWEgVGVzdGVtdW5oYVwiLFxuXHRcIlZPVEVEX0ZPUl9XSVRORVNTXCI6IFwiVm90b3UgcG9yIHVtYSBUZXN0ZW11bmhhXCIsXG5cdFwiQUdPXCI6IFwiYXRyw6FzXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJkZSBhZ29yYVwiLFxuXHRcIlNFQ1NcIjogXCJzZWdzXCIsXG5cdFwiQV9NSU5cIjogXCJ1bSBtaW51dG9cIixcblx0XCJBTl9IT1VSXCI6IFwidW1hIGhvcmFcIixcblx0XCJIT1VSU1wiOiBcImhvcmFzXCIsXG5cdFwiQV9EQVlcIjogXCJ1bSBkaWFcIixcblx0XCJEQVlTXCI6IFwiZGlhc1wiLFxuXHRcIkFfTU9OVEhcIjogXCJ1bSBtw6pzXCIsXG5cdFwiTU9OVEhTXCI6IFwibWVzZXNcIixcblx0XCJBX1lFQVJcIjogXCJ1bSBhbm9cIixcblx0XCJZRUFSU1wiOiBcImFub3NcIixcblx0XCJNSU5fUkVBRFwiOiBcImxlciBtaW5cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiVm90ZSBhYmFpeG8gb3UgYmFuZGVpcmVcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJDYXB0dXJhciBpbWFnZW1cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcIkVzY29saGVyIHVtYSBpbWFnZW1cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcIkNvbmZpZ3VyZSBVUkwgY29zdHVtaXphZGFcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluc2VyaXIgdW1hIGltYWdlbVwiLFxuXHRcIkVSUk9SXCI6IFwiRXJyb1wiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcIkVycm8gbm8gY2FycmVnYW1lbnRvXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIkNhbWVyYSBjYW5jZWxhZGFcIixcblx0XCJTRVRfVVJMXCI6IFwiQ29uZmlndXJhbCBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiTGluayB3ZWIgZGlyZXRvIHBhcmEgYSBpbWFnZW1cIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIkNvbWVudMOhcmlvIHBvc3RhZG8hXCIsXG5cdFwiREVMRVRFX0NPTU1FTlRcIjogXCJEZWxldGFyIGNvbWVudMOhcmlvcyDDqSBpcnJldmVyc8OtdmVsXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiQ29tZW50w6FyaW8gZGVsZXRhZG9cIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcIkNhcnJlZ2FiZG8gaW1hZ2VtXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIkNhcnJlZ2FtZW50byBjb21wZWxldG9cIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwiQ2FycmVnYW1lbnRvIGZhbGhvdVwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcIkEgc2VuaGEgb3Ugbm9tZSBkYSBjb250YSBlc3TDo28gaW5jb3JyZXRvc1wiLFxuXHRcIklORk9cIjogXCJJbmZvcm1hw6fDtWVzXCIsXG5cdFwiUVJfVEVYVFwiOiBcIlBvbmhhIG8gY8OzZGlnbyBRUiBkZW50cm8gZGEgw6FyZWEgZGUgc2NhblwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIkNlcnRpZmlxdWUtc2UgcXVlIHBvc3N1aSBzYWxkbyBzdWZpY2llbnRlIHBhcmEgYSB0cmFuc2HDp8OjbyFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwiTyB1dGlsaXphZG9yIHBhcmEgcXVlbSBlc3TDoSBhIHRlbnRhciB0cmFuc2ZlcmlyIGZ1bmRvcywgbsOjbyBleGlzdGVcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiVGVtIGNlcnRlemEgcXVlIHF1ZXIgdHJhbnNmZXJpcj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJDb25maXJtYcOnw6NvXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCJUcmFuc2HDp8OjbyBmb2kgZGlmdW5kaWRhXCIsXG5cdFwiVFJFTkRJTkdcIjogXCJUZW5kZW5jaWFcIixcblx0XCJIT1RcIjogXCJRdWVudGVcIixcblx0XCJORVdcIjogXCJOb3ZpZGFkZXNcIixcblx0XCJQUk9NT1RFRFwiOiBcIlByb21vdmlkb3NcIixcblx0XCJWT1RFU1wiOiBcIlZvdG9zXCIsXG5cdFwiUEFZT1VUXCI6IFwiUGFnYW1lbnRvXCIsXG5cdFwiQ09NTUVOVFNcIjogXCJDb21lbnTDoXJpb3NcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRlbmRlbmNpYSBhIDMwIGRpYXNcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCJPcmRlbmFyIHB1YmxpY2HDp8O1ZXMgcG9yOlwiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIkNpY2xvIGRlIFBhZ2FtZW50b1wiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCJQYWdhbWVudG8gZW0gcG90ZW5jaWFsXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLDmmx0aW1vIFBhZ2FtZW50b1wiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCJQYWdhbWVudG8gZG8gQXV0b3JcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCJQYWdhbWVudG8gZGUgY3VyYWRvcmlhXCIsXG5cdFwiUE9TVF9TVUJNSVRURURcIjogXCJQb3N0YWdlbSBlbnZpYWRhIVwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCJQdWJsaXF1ZSBwYXJhIGZ1dHVyYSBzdWJtaXNzw6NvXCIsXG5cdFwiU0FWRURcIjogXCJTYWx2b1wiLFxuXHRcIkNMRUFSRURcIjogXCJMaW1wb1wiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJQb3IgQmFuZGVpcmEgbnVtYSBwdWJsaWNhw6fDo28gcG9kZSByZW1vdmVyIHJlY29tcGVuc2FzIGUgdG9ybmFyIG8gbWF0ZXJpYWwgbWVub3MgdmlzaXZlbC48YnI+PGJyPkEgYmFuZGVpcmEgZGV2IHNlciB1c2FkYSBwYXJhIDogPHVsPjxsaT5GcmF1ZGUgb3UgUGxhZ2lhcmlzbW88L2xpPjxsaT5EaXNjdXJzbyBkZSDDs2RpbyBvdSBJbnRlcm5ldCBUcm9sbGluZzwvbGk+PGxpPkNhdGVnb3JpemHDp8OjbyBtYWwgZmVpdGEgaW50ZW5jaW9uYWxtZW50ZSBvdSBTcGFtPC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcIkxpbWl0ZSBkZSBwZWRpZG9zIGF0aW5naWRvLiB2ZXJpZmlxdWUgb3V0cm8gYXNzdW50by9ldGlxdWV0YSFcIixcblx0XCJQT1NUX0lTX1VOQk9PS01BUktcIjogXCJQb3N0YWdlbSByZW1vdmlkYSBkb3MgZmF2b3JpdG9zIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJQb3N0YWdlbSBhZGljaW9uYWRhIGFvcyBmYXZvcml0b3MhXCIsXG5cdFwiUkVTRVRcIjogXCJSZWluaWNpYXJcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmaWNhciBmb3RvIGRlIHBlcmZpbFwiLFxuXHRcIk1PRElGWV9DT1ZFUl9QSUNUVVJFXCI6IFwiTW9kaWZpY2FyIGZvdG8gZGUgY2FwYVwiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIlBvciBmYXZvciBmb3JuYcOnYSBhIGNoYXZlIGRlIGFjdGl2YcOnw6NvIHByaXZhZGEgcXVlIGVzY29saGV1LCBNb2RvIGRlIExvZ2luIEF2YW7Dp2Fkb1wiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gcGVyZmlsIHVsdGl6YWRvclwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gdWx0aXphZG9yXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBdHVhbGl6YcOnw6NvIGRvIHNlcnZlciBvYnJpZ2EgYSBSZWluaWNpYXIhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkNvbmZpZ3VyYcOnw7VlcyBmb3JhbSBhdHVhbGl6YWRhc1wiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkzDrW5ndWFzXCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCJBcXVpIHBvZGUgbXVkYXIgYSBsw61uZ3VhIGRhIEFwcFwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCJFc3Qgb3BlcmHDp8OjbyBvYnJpZ2EgcXVlIG8gdXRpbGl6YWRvciBlc3RhamEgbGlnYWRvIGNvbSBhIHNlbmhhIHByaW5pcGFsLCBjaGF2ZSBhY3RpdmHDp8Ojby9wdWJsaWNhw6fDo29cIixcblx0XCJHQUxMRVJZXCI6IFwiR2FsZXJpYVwiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcIlRyYWR1dG9yZXMgcXVlIGNvbnRyaWJ1aXJhbVwiLFxuXHRcIlNIQVJFXCI6IFwiUGFydGlsaGFyXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCJNZXJjYWRvXCIsXG5cdFwiRVhDSEFOR0VcIjogXCJDYW1iaW9cIixcblx0XCJEUkFGVFNcIjogXCJSYXNjdW5ob3NcIixcblx0XCJQT1NUX0lTX1VORFJBRlRcIjogXCJQb3N0YWdlbSByZW1vdmlkYSBkb3MgUmFzY3VuaG9zIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQb3N0YWdlbSBhZGljaW9uYWRhIGEgUmFzY3VuaG9zIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJSb2xlIHBhcmEgYSBlc3F1ZXJkYSBwYXJhIG9ww6fDtWVzXCIsXG5cdFwiTUFOQUdFXCI6IFwiR2VyaXJcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwiSW1hZ2UuIHJlbW92aWRhXCIsXG5cdFwiQ09QWVwiOiBcIkNvcGlhclwiLFxuXHRcIk5PX0lNQUdFXCI6IFwiTsOjbyBjYXJyZWdvdSBuZW5odW1hIGltYWdlbSwgYWluZGFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcIkNhcnJlZ3VlIHBhcmEgcmVmcmVzY2FyXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcIkFwcHMgRXh0ZXJuYXNcIixcblx0XCJTVUdHRVNUXCI6IFwiU3VnaXJhXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCJCcmV2ZW1lbnRlXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkFxdWkgcG9kZSBlc2NvbGhlciBibG9ja2NoYWluIG91IGEgcGxhdGFmb3JtYSBwb3IgZGVmZWl0b1wiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJQw6FnaW5hIEluaWNpYWxcIixcblx0XCJMT0dJTlwiOiBcIkVudHJhclwiLFxuXHRcIkxPR09VVFwiOiBcIlNhaXJcIixcblx0XCJQUk9GSUxFXCI6IFwiUGVyZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiU2VndWlyXCIsXG5cdFwiQk9PS01BUktTXCI6IFwiRmF2b3JpdG9zXCIsXG5cdFwiVFJBTlNGRVJcIjogXCJUcmFuc2ZlcmlyXCIsXG5cdFwiTUFSS0VUXCI6IFwiTWVyY2Fkb1wiLFxuXHRcIlNFVFRJTkdTXCI6IFwiQ29uZmlndXJhw6fDtWVzXCIsXG5cdFwiQUJPVVRcIjogXCJTb2JyZVwiLFxuXHRcIkFCT1VUXzFcIjogXCJPbmRlIHF1YWxxdWVyIHVtIHBvZGUgZ2FuaGFyIHJlY29tcGVuc2FzIHBlbG8gc2V1IGNvbnRlw7pkb1wiLFxuXHRcIkFCT1VUXzJcIjogXCLDqSB1bWEgYXBsaWNhw6fDo28gc29jaWFsIG9uZGUgdm9jw6ogw6kgcGFnbyBwb3IgcHVibGljYXIsIGNvbWVudGFyIGUgY3VyYXIuXCIsXG5cdFwiQUJPVVRfM1wiOiBcImUgw6kgY8OzZGlnby1hYmVydG8sIHByb2plY3RvIG9yaWVudGFkbyBwYXJhIGEgY29tdW5pZGFkZSBtw7N2ZWwuIE9mZXJlY2UgYWNlc3NvIGFvIGNvbnRlw7pkbyBwYXJhIGxlaXR1cmEsIGNvbWVudMOhcmlvcywgdm90b3MsIHB1YmxpY2FyLCB0cmFuZmVyaXIgZ2FuaG9zIGV0Yy4gQ2FyYXRlcmlzdGljYXMgb2ZlcmVjaWRhcyBwb3Ige3twbGF0Zm9ybW5hbWV9fSBibG9ja2NoYWluIGFuZCB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEuIE8gYXBsaWNhdGl2byBudW5jYSBhY2Vzc2Egb3UgZ3VhcmRhIG8gZGluaGVpcm8gZG9zIHV0aWxpemFkb3Jlcy5cIixcblx0XCJBQk9VVF81XCI6IFwiMi4gQSBBcHAgb2ZlcmVjZSB1bSBtb2RlbG8gc2VndXJvIGRvIGxhZG8tY2xpZW50ZSwgY29tIGNoYXZlcyBwcml2YWRhcywgZ3VhcmRhZGFzIGxvY2FsbWVudGUgZSBudW5jYSBlbnZpYWRhIHBhcmEgb3V0cm9zIHNlcnZpZG9yZXMuXCIsXG5cdFwiQUJPVVRfNlwiOiBcIjMuIE8gQXBsaWNhdGl2byBvZmVyZWNlIHNpbXBsaWNpZGFkZSwgaW50ZXJmYWNlcyBkZSB1dGlsaXphZG9yIGUgZXhwZXJpw6puY2lhcyBhdHJhdGl2YXMuXCIsXG5cdFwiQUJPVVRfN1wiOiBcIjQuIE8gQXBsaWNhdGl2byByZXF1ZXIgcXVlIG9zIHV0aWxpemFkb3JlcyBpbnNpcmFtIGluZm9ybWHDp8O1ZXMgcGVzc29haXMuXCIsXG5cdFwiQUJPVVRfOFwiOiBcIlZvdGUgYm9tLWthcm1hIGNvbW8gdGVzdGVtdW5oYVwiLFxuXHRcIkFCT1VUXzlcIjogXCJDb250YXRvL0NvbWVudMOhcmlvc1wiLFxuXHRcIkFCT1VUXzEwXCI6IFwiTWFpcyBpbmZvcm1hw6fDtWVzOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlJlbW92ZXJcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIlZpc8OjbyBkbyBNZXJjYWRvXCIsXG5cdFwiUFJJQ0VcIjogXCJQcmXDp29cIixcblx0XCJBTU9VTlRcIjogXCJRdWFudGlkYWRlXCIsXG5cdFwiVE9UQUxcIjogXCJUb3RhbFwiLFxuXHRcIk5PT1JERVJTXCI6IFwiU2VtIG9yZGVucyBhYmVydGFzIHBhcmFcIixcblx0XCJEQVRFXCI6IFwiRGF0YVwiLFxuXHRcIkJVWVwiOiBcIkNvbXByYXJcIixcblx0XCJTRUxMXCI6IFwiVmVuZGVyXCIsXG5cdFwiT1BFTlwiOiBcIkFicmlyXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpdMOzcmljb1wiLFxuXHRcIkZPTExPV19CQUNLXCI6IFwiVm9sdGFyIGEgc2VndWlyXCIsXG5cdFwiRk9MTE9XRURcIjogXCJTZWd1aWRvXCIsXG5cdFwiVU5GT0xMT1dcIjogXCJEZWl4YXIgZGUgc2VndWlyXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiU2VndWluZG9cIixcblx0XCJGT0xMT1dFUlNcIjogXCJTZWd1aWRvcmVzXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlByb2N1cmFyIHNlZ3VpZG9yZXNcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiUHJvY3VyYXIgcG9yIHF1ZW0gZXN0b3UgYSBzZWd1aXJcIixcblx0XCJCWVwiOiBcInBvclwiLFxuXHRcIklOXCI6IFwibm9cIixcblx0XCJNRU5VXCI6IFwiTWVudVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwiRmF2b3JpdG9zXCIsXG5cdFwiUkVCTE9HXCI6IFwiUmVwb3N0YXJcIixcblx0XCJVUFZPVEVcIjogXCJWb3RvIHBvc2l0aXZvXCIsXG5cdFwiRE9XTlZPVEVcIjogXCJWb3RvIG5lZ2F0aXZvXCIsXG5cdFwiVU5WT1RFX0RPV05WT1RFRFwiOiBcIkNhbmNlbGFyIHZvdG8gbmVnYXRpdm9cIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIkNhbmNlbGFyIHZvdG8gcG9zaXRpdm9cIixcblx0XCJSRVBMWVwiOiBcIlJlc3BvbmRlclwiLFxuXHRcIkVESVRcIjogXCJFZGl0YXJcIixcblx0XCJQT1NUXzFcIjogXCJEZXNsaXplIHBhcmEgZXNxdWVyZGEgbm9zIGNvbWVudMOhcmlvcyBwYXJhIHZlciBhcyBvcMOnw7Vlc1wiLFxuXHRcIlBPU1RfMlwiOiBcIlRvcXVlIG5vcyBjb21lbnTDoXJpb3MgcGFyYSB2ZXIgb3Mgc3ViLWNvbWVudMOhcmlvc1wiLFxuXHRcIk9QVElPTlNcIjogXCJPcMOnw7Vlc1wiLFxuXHRcIlJFU1RFRU1FRF9CWVwiOiBcIlJlcG9zdGFkbyBwb3JcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCJOYWRhIHBvciBhcXVpLCBhaW5kYS4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwiQmFsYW7Dp29cIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCBwcm92YXMgdHJhbnNhY2lvbsOhdmVpcyBxdWUgcG9kZW0gc2VyIHRyYW5zZmVyaWRhcyBlbSBxdWFscXVlciBhbHR1cmEuIHt7cGxhdGZvcm1uYW1lfX0gcG9kZW0gc2VyIGNvbnZlcnRpZGFzIHt7cGxhdGZvcm1wb3dlcn19IG51bSBwcm9jZXNzbyBjaGFtYWRvIHBvZGVyIGFiYWl4by5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwgdG9rZW5zIGRlIGluZmx1ZW5jaWEgcGFyYSBnYW5oYXIgbWFpcyBwb2RlciBwYXJhIGd1YXJkYXIgYSBsb25nbyBwcmF6byBlIHZvdGFyIG5hcyBwdWJsaWNhw6fDtWVzLiBRdWFudG8gbWFpcyBzZSBwb3NzdWkgbWFpcyBzZSBwb2RlIGluZmx1ZW5jaWFyIGFzIHJlY29tcGVuc2FzIHBhcmEgb3V0cm9zIGUgZ2FuaGFyIG1haXMgcmVjb21wZW5zYXMgcG9yIHZvdGFyLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlByb3ZhcyBxdWUgdmFsZW0gY2VyY2EgZGUge3twbGF0Zm9ybXN1bml0fX0gZGUge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCJWYWxvciBlc3RpbWFkb1wiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIk8gdmFsb3IgZXN0aW1hZG8gw6kgYmFzZWFkbyBudW1hIG3DqWRpYSBkbyB2YWxvciBkZSA3IGRpYXMgZGUge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwiSGlzdMOzcmljbyBkZSBUcmFuc2HDp8Ojb1wiLFxuXHRcIlBPU1RJTkdcIjogXCJQdWJsaWNhbmRvXCIsXG5cdFwiUFJPRklMRV81XCI6IFwiQSBjaGF2ZSBkZSBwdWJsaWNhw6fDo28gw6kgdXNhZGEgcGFyYSBwdWJsaWNhciBlIHZvdGFyLiBFbGEgZGV2ZSBzZXIgZGlmZXJlbnRlIGRhIGNoYXZlIGRlIGF0aXZhw6fDo28gZSBkYSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvLlwiLFxuXHRcIk9XTkVSXCI6IFwiUHJvcHJpZXTDoXJpb1wiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIkEgY2hhdmUgZGUgcHJvcHJpZXTDoXJpbyDDqSBhIGNoYXZlIG1lc3RyYSBwYXJhIGNvbnRhIGUgw6kgZXhpZ2lkYSBwYXJhIG11ZGFyIGFzIG91dHJhcyBjaGF2ZXMuIFVtYSBjaGF2ZSBwcml2YWRhIG91IHNlbmhhIHBhcmEgYSBjaGF2ZSBkZSBwcm9wcmlldMOhcmlvIGRldmVyw6Egc2VyIG1hbnRpZGEgb2ZmbGluZSBhc3NpbSBxdWUgcG9zc8OtdmVsLlwiLFxuXHRcIkFDVElWRVwiOiBcIkF0aXZvXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiQSBjaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgZmF6ZXIgdHJhbnNmZXLDqm5jaWFzIGUgY29sb2NhciBvcmRlbnMgbm8gbWVyY2FkbyBpbnRlcm5vLlwiLFxuXHRcIk1FTU9cIjogXCJBbm90YcOnw7Vlc1wiLFxuXHRcIlBST0ZJTEVfOFwiOiBcIkEgY2hhdmUgZGUgYW5vdGHDp8O1ZXMgw6kgdXNhZGEgcGFyYSBjcmlhciBlIGxlciBhbm90YcOnw7Vlcy5cIixcblx0XCJCTE9HXCI6IFwiQmxvZ3VlXCIsXG5cdFwiUE9TVFNcIjogXCJQdWJsaWNhw6fDtWVzXCIsXG5cdFwiUkVQTElFU1wiOiBcIlJlc3Bvc3Rhc1wiLFxuXHRcIldBTExFVFwiOiBcIkNhcnRlaXJhXCIsXG5cdFwiVEFHXCI6IFwiRXRpcXVldGFcIixcblx0XCJVU0VSXCI6IFwiVXRpbGl6YWRvclwiLFxuXHRcIkNMT1NFXCI6IFwiRmVjaGFkb1wiLFxuXHRcIlRPXCI6IFwiUGFyYVwiLFxuXHRcIkFTU0VUXCI6IFwiQXRpdm9cIixcblx0XCJTRU5EXCI6IFwiRW52aWFyXCIsXG5cdFwiU0VDVVJJVFlcIjogXCJTZWd1cmFuw6dhXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiRGlzcG9uw612ZWxcIixcblx0XCJQVUJMSUNfTUVNT1wiOiBcIk1lbW9yYW5kbyBQw7pibGljb1wiLFxuXHRcIlRPX0RFU0NcIjogXCJVdGlsaXphZG9yIGV4OiBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJDw7NkaWdvIFBpblwiLFxuXHRcIlBJTl9URVhUXCI6IFwiQ8OzZGlnbyBQaW4gYWp1ZGEgYSBhc3NlZ3VyYXIgbyBhcGxpY2F0aXZvIGUgc3VhcyBpbmZvcm1hw6fDtWVzLiA8YnIvPjxici8+IFVtYSB2ZXogYXRpdmFkbywgdGVyw6Egbm8gbcOheGltbyA0IHRlbnRhdGl2YXMgcGFyYSBkZXN0cmF2YXIsIHNlIGVzcXVlY2VyIG8gcGluIG91IGVycmFyLCBvIGFwbGljYXRpdm8gaXLDoSByZW1vdmVyIHN1YXMgaW5mb3JtYcOnw7VlcyBkZSB1dGlsaXphZG9yLiBQb2RlIGVudHJhciBkZSBub3ZvIGUgY29udGludWFyIGEgdXNhciBvIGFwbGljYXRpdm8uXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIk5vdGlmaWNhw6fDtWVzXCIsXG5cdFwiVk9URV9URVhUXCI6IFwiVm9jw6ogcmVjZWJlcsOhIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIHZvdGFyIG5vIHNldSBjb250ZcO6ZG8hIE5vdGlmaWNhw6fDtWVzIHRhbWLDqW0gaW5jbHVlbSBwZXNvIGRlIHZvdG8gbm8gYWxlcnRhIGRhIG1lbnNhZ2VtLikgc2VqYSB2b3RvIHBvc2l0aXZvLCB2b3RvIG5lZ2F0aXZvLCB2b3RvIG51bG8pLlwiLFxuXHRcIlZPVEVcIjogXCJWb3RhclwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIlJlY2ViZSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBjb21lbnRhciBuYXMgc3VhcyBwdWJsaWNhw6fDtWVzIG91IGNvbWVudMOhcmlvcy48YnIvPiBOb3RpZmljYcOnw7VlcyBpbmNsdWVtIHF1YW5kbyBhbGd1w6ltIGVkaXRhIG9zIGNvbWVudMOhcmlvcyB0YW1iw6ltLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJDb21lbnRhclwiLFxuXHRcIkZPTExPV19URVhUXCI6IFwiUmVjZWJlIHNlbXByZSB1bWEgbm90aWZpY2HDp8OjbyBxdWFuZG8gYWxndcOpbSBTZWd1aXIgb3UgRGVpeGFyIGRlIHNlZ3VpLWxvIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwiTWVuw6fDtWVzXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIlJlY2ViZSBzZW1wcmUgdW1hIG5vdGlmaWNhw6fDo28gcXVhbmRvIGFsZ3XDqW0gbyBtZW5jaW9uYXIgbmFsZ3VtYSBwdWJsaWNhw6fDo28gb3UgY29tZW50w6FyaW8hXCIsXG5cdFwiUkVTVEVFTVwiOiBcIlJlcG9zdGFyXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwiSXLDoSByZWNlYmVyIHVtYSBub3RpZmljYcOnw6NvIHF1YW5kbyBhbGd1w6ltIHBhcnRpbGhhciBhIHN1YSBwdWJsaWNhw6fDo28hXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJDb25maWd1cmHDp8O1ZXNcIixcblx0XCJWT1RJTkdcIjogXCJWb3RhbmRvXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCJPIHBlc28gZGUgdm90byBvdSBwZXJjZW50YWdlbSBhZmV0YSBvIHBvZGVyIGRlIHZvdG8gbmEgYXBwLCBwb3IgaXNzbyBwb2RlIHJlZ3VsYXIgbyBzZXUgcmVjb21wZW5zYSBkZSB2b3RvIDxici8+PGJyLz48Yj5Ob3RhOjwvYj4gSXN0byBpcsOhIG1vZGlmaWNhciBvIHBlc28vcGVyY2VudGFnZW0gcGFyYSB2b3RhciBwYXJhIGJhaXhvIHRhbWLDqW0gZSBlbSB0b2RvIG8gbGFkbyBuYSBBcHBcIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2aWRvclwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwiUmVjb21lbmRhZG9cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTYWx2YXIgbXVkYW7Dp2FzXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJJbmZvcm1hw6fDtWVzIGRvcyBlbGVpdG9yZXNcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCJCZW0gdmluZG8gZGUgVm9sdGEhXCIsXG5cdFwiTE9HSU5fMVwiOiBcIkNvbmVjdGUtc2UgY29tIHNldSBub21lIGRlIHV0aWxpemFkb3IgZSBzZW5oYSBwYXJhIGNvbnRpbnVhci5cIixcblx0XCJMT0dJTl8yXCI6IFwiQ2hhdmUgZGUgcHVibGljYcOnw6NvIMOpIHVzYWRhIHBhcmEgcHVibGljYXIsIGNvbWVudGFyLCB2b3Rhciwgc2VndWlyLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJDaGF2ZSBkZSBhdGl2YcOnw6NvIMOpIHVzYWRhIHBhcmEgdHJhbmZlcsOqbmNpYXMgZSBhdHVhbGl6YcOnw6NvIGRlIGZvdG9zIGRlIHBlcmZpbC5cIixcblx0XCJMT0dJTl80XCI6IFwiQXMgY3JlZGVuY2lhaXMgZG8gdXRpbGl6YWRvciBzw6NvIGd1YXJkYWRhcyBsb2NhbG1lbnRlIG5vIHNldSBhcGFyZWxoby4gRGVwaXMgZGUgZGVzbGlnYXIgYXMgc3VhcyBjcmVkZW5jaWFpcyBzw6NvIHJlbW92aWRhc1wiLFxuXHRcIkRPTlRfSEFWRVwiOiBcIk7Do28gcG9zc3VpIGNvbnRhP1xcblwiLFxuXHRcIlNJR05fVVBfTk9XXCI6IFwiUmVnaXN0ZS1zZSBhZ29yYVwiLFxuXHRcIkNBTkNFTFwiOiBcIkNhbmNlbGFyXCIsXG5cdFwiQURWQU5DRURcIjogXCJBdmFuw6dhZG9cIixcblx0XCJBQ1RJVkVfUFJJS0VZXCI6IFwiQ2hhdmUgZGUgYXRpdmHDp8OjbyBwcml2YWRhXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJDaGF2ZSBkZSBwdWJsaWNhw6fDo28gcHJpdmFkYVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiU2VuaGEgTWVzdHJhL1ByaW5jaXBhbFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiVXRpbGl6YWRvclwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIlZpc8OjbyBkZSBDYXJ0w6NvXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwiVmlzdGEgY29tcGFjdGFcIixcblx0XCJTRUFSQ0hcIjogXCJQcm9jdXJhclwiLFxuXHRcIlNVQk1JVF9BX1NUT1JZXCI6IFwiUHVibGljYXIgdW1hIGhpc3TDs3JpYVwiLFxuXHRcIlJFUExZVE9cIjogXCJSZXNwb25kZXIgcGFyYVwiLFxuXHRcIlBPU1RcIjogXCJQdWJsaWNhw6fDo29cIixcblx0XCJQUkVWSUVXXCI6IFwiVml6dWFsaXphclwiLFxuXHRcIkRFRkFVTFRcIjogXCJQYWRyw6NvIDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCJGb3LDp2EgVG90YWwgMTAwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwiUmVjdXNhciBQYWdhbWVudG9cIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIkd1YXJkYXIgcHJhIG1haXMgdGFyZGVcIixcblx0XCJDTEVBUlwiOiBcIlRlcm1pbmFkb1wiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIkNvbnRlw7pkbyBkYSBwdWJsaWNhw6fDo29cIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJDb250ZcO6ZG8gZG8gY29tZW50w6FyaW9cIixcblx0XCJUSVRMRVwiOiBcIlTDrXR1bG9cIixcblx0XCJUQUdTXCI6IFwiRXRpcXVldGFzXFxuTWFyY2Fkb3Jlc1wiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIk7Do28gY29uZGl6XCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCJDb25maXJtYXIgUGluXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwiSW5jb3JyZXRvXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwiQWJyaW5kbyBwb3N0YWdlbVwiLFxuXHRcIlNFVF9QSU5cIjogXCJDb25maWd1cmUgUElOXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiRW50cmFyIGNvbSBQaW5cIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCJUZW0gYSBjZXJ0ZXphP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiUmVwdWJsaWNhciDDqSBpcnJldmVyc8OtdmVsLCBxdWVyIG1lc21vIGNvbnRpbnVhcj9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJFcnJvIGRlIGRpZnVzw6NvLCB0ZW50ZSBub3ZhbWVudGUhXCIsXG5cdFwiU1VDQ0VTU1wiOiBcIlN1Y2Vzc29cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIlB1YmxpY2HDp8OjbyByZXB1YmxpY2FkYVwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCJMb2dpbiBmYWxob3UhIHBvciBmYXZvciBjZXJ0aWZpcXVlLXNlIHF1ZSBlc3TDoSBsaWdhZG8gY29tIGEgc2VuaGEgbWFzdGVyIG91IGEgY2hhdmUgcHVibGljYcOnw6NvIHByaXZhZGEgbm8gTG9naW4gc2UgZXNjb2xoZXUgbyBtb2RvIGF2YW7Dp2Fkby5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCJMb2dpbiBmYWxob3UhIHBvciBmYXZvciBjZXJ0aWZpcXVlLXNlIHF1ZSBlc3TDoSBjb25ldGFkbyBjb20gYSBzZW5oYSBtYXN0ZXIgb3UgYSBjaGF2ZSBhdGl2YSBwcml2YWRhIG5vIExvZ2luIHNlIGVzY29saGV1IG8gbW9kbyBhdmFuw6dhZG8uXCIsXG5cdFwiV0FSTklOR1wiOiBcIkN1aWRhZG9cIixcblx0XCJWT1RFX0ZPUl9XSVRORVNTXCI6IFwiVm90YW5kbyBwb3IgdW1hIFRlc3RlbXVuaGFcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIlZvdG91IHBvciB1bWEgVGVzdGVtdW5oYVwiLFxuXHRcIkFHT1wiOiBcImF0csOhc1wiLFxuXHRcIkZST01fTk9XXCI6IFwiZGUgYWdvcmFcIixcblx0XCJTRUNTXCI6IFwic2Vnc1wiLFxuXHRcIkFfTUlOXCI6IFwidW0gbWludXRvXCIsXG5cdFwiTUlOU1wiOiBcIm1pbnV0b3NcIixcblx0XCJBTl9IT1VSXCI6IFwidW1hIGhvcmFcIixcblx0XCJIT1VSU1wiOiBcImhvcmFzXCIsXG5cdFwiQV9EQVlcIjogXCJ1bSBkaWFcIixcblx0XCJEQVlTXCI6IFwiZGlhc1wiLFxuXHRcIkFfTU9OVEhcIjogXCJ1bSBtw6pzXCIsXG5cdFwiTU9OVEhTXCI6IFwibWVzZXNcIixcblx0XCJBX1lFQVJcIjogXCJ1bSBhbm9cIixcblx0XCJZRUFSU1wiOiBcImFub3NcIixcblx0XCJNSU5fUkVBRFwiOiBcImxlciBtaW5cIixcblx0XCJET1dOVk9URV9GTEFHXCI6IFwiVm90ZSBwYXJhIGJhaXhvIG91IGJhbmRlaXJhXCIsXG5cdFwiQ0FQVFVSRV9QSUNUVVJFXCI6IFwiQ2FwdHVyYXIgaW1hZ2VtXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJFc2NvbGhlciB1bWEgaW1hZ2VtXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJDb25maWd1cmUgVVJMIGNvc3R1bWl6YWRhXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCJJbnNlcmlyIHVtYSBpbWFnZW1cIixcblx0XCJFUlJPUlwiOiBcIkVycm9cIixcblx0XCJVUExPQURfRVJST1JcIjogXCJFcnJvIG5vIGNhcnJlZ2FtZW50b1wiLFxuXHRcIkNBTUVSQV9DQU5DRUxMRURcIjogXCJDYW1lcmEgY2FuY2VsYWRhXCIsXG5cdFwiU0VUX1VSTFwiOiBcIkNvbmZpZ3VyYXJsIFVSTFwiLFxuXHRcIkRJUkVDVF9MSU5LX1BJQ1RVUkVcIjogXCJMaW5rIHdlYiBkaXJldG8gcGFyYSBhIGltYWdlbVwiLFxuXHRcIkNPTU1FTlRfU1VCTUlUVEVEXCI6IFwiQ29tZW50w6FyaW8gcHVibGljYWRvIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiQXBhZ2FyIGNvbWVudMOhcmlvcyDDqSBpcnJldmVyc8OtdmVsXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwiQ29tZW50w6FyaW8gYXBhZ2Fkb1wiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiQ2FycmVnYW5kbyBpbWFnZW1cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwiQ2FycmVnYW1lbnRvIGNvbXBsZXRvXCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcIkNhcnJlZ2FtZW50byBmYWxob3VcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJBIHNlbmhhIG91IG5vbWUgZGEgY29udGEgc8OjbyBpbmNvcnJldG9zXCIsXG5cdFwiSU5GT1wiOiBcIkluZm9ybWHDp8O1ZXNcIixcblx0XCJRUl9URVhUXCI6IFwiUG9uaGEgbyBjw7NkaWdvIFFSIGRlbnRybyBkYSDDoXJlYSBkZSBzY2FuXCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiQ2VydGlmaXF1ZS1zZSBxdWUgcG9zc3VpIHNhbGRvIHN1ZmljaWVudGUgcGFyYSBhIHRyYW5zYcOnw6NvIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJPIHV0aWxpemFkb3IgcGFyYSBxdWVtIGVzdMOhIGEgdGVudGFyIHRyYW5zZmVyaXIgZnVuZG9zLCBuw6NvIGV4aXN0ZVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCJUZW0gY2VydGV6YSBxdWUgcXVlciB0cmFuc2ZlcmlyP1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIkNvbmZpcm1hw6fDo29cIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIlRyYW5zYcOnw6NvIGZvaSBkaWZ1bmRpZGFcIixcblx0XCJGRUVEXCI6IFwiQ29udGXDumRvIGRlIG5vdMOtY2lhc1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVGVuZGVuY2lhXCIsXG5cdFwiSE9UXCI6IFwiUXVlbnRlXCIsXG5cdFwiTkVXXCI6IFwiTm92aWRhZGVzXCIsXG5cdFwiUFJPTU9URURcIjogXCJQcm9tb3ZpZG9zXCIsXG5cdFwiVk9URVNcIjogXCJWb3Rvc1wiLFxuXHRcIlBBWU9VVFwiOiBcIlBhZ2FtZW50b1wiLFxuXHRcIkNPTU1FTlRTXCI6IFwiQ29tZW50w6FyaW9zXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCJUZW5kZW5jaWEgYSAzMCBkaWFzXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiT3JkZW5hciBwdWJsaWNhw6fDtWVzIHBvcjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCJDaWNsbyBkZSBQYWdhbWVudG9cIixcblx0XCJQT1RFTlRJQUxfUEFZT1VUXCI6IFwiUGFnYW1lbnRvIGVtIHBvdGVuY2lhbFwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwiw5psdGltbyBQYWdhbWVudG9cIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwiUGFnYW1lbnRvIGRvIEF1dG9yXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwiUGFnYW1lbnRvIGRlIGN1cmFkb3JpYVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwiUHVibGljYcOnw6NvIGVudmlhZGEhXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIlB1YmxpcXVlIHBhcmEgZnV0dXJhIHN1Ym1pc3PDo29cIixcblx0XCJTQVZFRFwiOiBcIlNhbHZvXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIkxpbXBvXCIsXG5cdFwiRkxBR0dJTkdfVEVYVFwiOiBcIlBvciB1bWEgYmFuZGVpcmEgbnVtYSBwdWJsaWNhw6fDo28gcG9kZSByZW1vdmVyIHJlY29tcGVuc2FzIGUgdG9ybmFyIG8gbWF0ZXJpYWwgbWVub3MgdmlzaXZlbC48YnI+PGJyPkEgYmFuZGVpcmEgZGV2ZSBzZXIgdXNhZGEgcGFyYSA6IDx1bD48bGk+RnJhdWRlIG91IFBsYWdpYXJpc21vPC9saT48bGk+RGlzY3Vyc28gZGUgw7NkaW8gb3UgSW50ZXJuZXQgVHJvbGxpbmc8L2xpPjxsaT5DYXRlZ29yaXphw6fDo28gbWFsIGZlaXRhIGludGVuY2lvbmFsbWVudGUgb3UgU3BhbTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCJMaW1pdGUgZGUgcGVkaWRvcyBhdGluZ2lkby4gdmVyaWZpcXVlIG91dHJvIGFzc3VudG8vZXRpcXVldGEhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiUHVibGljYcOnw6NvIHJlbW92aWRhIGRvcyBmYXZvcml0b3MhXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIlB1YmxpY2HDp8OjbyBhZGljaW9uYWRhIGFvcyBmYXZvcml0b3MhXCIsXG5cdFwiUkVTRVRcIjogXCJSZWluaWNpYXJcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmaWNhciBhIGZvdG9ncmFmaWEgZGUgcGVyZmlsXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZmljYXIgZm90b2dyYWZpYSBkYSBjYXBhXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiUG9yIGZhdm9yIGluc2lyYSBhIGNoYXZlIGRlIGFjdGl2YcOnw6NvIHByaXZhZGEgcXVlIGVzY29saGV1LCBNb2RvIGRlIExvZ2luIEF2YW7Dp2Fkb1wiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gcGVyZmlsIHVsdGl6YWRvclwiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIklzdG8gcmVjb25maWd1cmEgYSBpbWFnZW0gZG8gdWx0aXphZG9yXCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCJBdHVhbGl6YcOnw6NvIGRvIHNlcnZlciBvYnJpZ2EgYSBSZWluaWNpYXIhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIkNvbmZpZ3VyYcOnw7VlcyBmb3JhbSBhdHVhbGl6YWRhc1wiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIkzDrW5ndWFcIixcblx0XCJMQU5HVUFHRVNfVEVYVFwiOiBcIkFxdWkgcG9kZSBtdWRhciBhIGzDrW5ndWEgZGEgQXBwXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIkVzdGEgb3BlcmHDp8OjbyBvYnJpZ2EgcXVlIG8gdXRpbGl6YWRvciBlc3RhamEgbGlnYWRvIGNvbSBhIHNlbmhhIHByaW5jaXBhbCwgY2hhdmUgYWN0aXZhw6fDo28vcHVibGljYcOnw6NvXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGVyaWFcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJUcmFkdXRvcmVzIHF1ZSBjb250cmlidWlyYW1cIixcblx0XCJTSEFSRVwiOiBcIlBhcnRpbGhhclwiLFxuXHRcIk1BUktFVFBMQUNFXCI6IFwiTWVyY2Fkb1wiLFxuXHRcIkVYQ0hBTkdFXCI6IFwiQ8OibWJpb1wiLFxuXHRcIkRSQUZUU1wiOiBcIlJhc2N1bmhvc1wiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIlB1YmxpY2HDp8OjbyByZW1vdmlkYSBkb3MgUmFzY3VuaG9zIVwiLFxuXHRcIlBPU1RfSVNfRFJBRlRcIjogXCJQdXBsaWNhw6fDo28gYWRpY2lvbmFkYSBhIFJhc2N1bmhvcyFcIixcblx0XCJTV0lQRV9MRUZUXCI6IFwiUm9sZSBwYXJhIGEgZXNxdWVyZGEgcGFyYSBvcMOnw7Vlc1wiLFxuXHRcIk1BTkFHRVwiOiBcIkdlcmlyXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkltYWdlbSByZW1vdmlkYVwiLFxuXHRcIkNPUFlcIjogXCJDb3BpYXJcIixcblx0XCJOT19JTUFHRVwiOiBcIk7Do28gY2FycmVnb3UgbmVuaHVtYSBpbWFnZW0sIGFpbmRhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJDYXJyZWd1ZSBwYXJhIHJlZnJlc2NhclwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJBcHBzIEV4dGVybmFzXCIsXG5cdFwiUExVR0lOU1wiOiBcIk3Ds2R1bG9zIGRlIGV4dGVuc8Ojb1wiLFxuXHRcIlNVR0dFU1RcIjogXCJTdWdpcmFcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIkJyZXZlbWVudGVcIixcblx0XCJDSEFJTlwiOiBcIkNvcnJlbnRlXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIkFxdWkgcG9kZSBlc2NvbGhlciBibG9ja2NoYWluIG91IGEgcGxhdGFmb3JtYSBwb3IgZGVmZWl0b1wiLFxuXHRcIkNVUlJFTkNZXCI6IFwiTW9lZGFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiQXF1aSBwb2RlIGFsdGVyYXIgYSBzdWEgdW5pZGFkZSBtb25ldMOhcmlhIHBhZHLDo28uIFZlcsOhIG8gdmFsb3IgZGEgcmVjb21wZW5zYSBkbyBwb3N0L2NvbWVudMOhcmlvIG5lc3NhIG1vZWRhLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIGRlIGZ1bmNpb25hbGlkYWRlczwvYj48YnI+LSBUZW5oYSBhY2Vzc28gYSBhcnRpZ29zIGV4Y2x1c2l2b3Mgc29icmUgcXVhbHF1ZXIgYXNzdW50byBxdWUgZXN0ZWphIGludGVyZXNzYWRvIGVtIGxlci48YnI+LSBFbnZvbHZhLXNlIGNvbSBvcyBhdXRvcmVzLCBjb21lbnRhbmRvIGUgZGlzY3V0aW5kbyBvcyB0w7NwaWNvcy48YnI+LSBWb3RlIGVtIHBvc3RzIHBhcmEgcmVjb21wZW5zYXIgbyBhdXRvciwgYmVtIGNvbW8gcGFyYSBnYW5oYXIgdW1hIHJlY29tcGVuc2EgZGUgY3VyYWRvci48YnI+LSBQdWJsaXF1ZSBvcyBzZXVzIGFydGlnb3MgZSBwb3N0cyBob3NwZWRhbmRvLW9zIGdyYXR1aXRhbWVudGUgZSBnYW5oZSByZWNvbXBlbnNhcyBwb3IgY2F0aXZhciBlIGdhbmhhciBzZWd1aWRvcmVzLjxicj4tIEVzY3JldmEgYXJ0aWdvcyBlbSBtb3ZpbWVudG8sIHNhbHZlIG3Dumx0aXBsb3MgcmFzY3VuaG9zIGRvIHBvc3QgcGFyYSBwdWJsaWNhw6fDo28gcG9zdGVyaW9yLjxicj4tIEFkaWNpb25lIGFydGlnb3MgYW9zIHNldXMgZmF2b3JpdG9zIHBhcmEgbGVyIG1haXMgdGFyZGUuPGJyPi0gQ2FtYmllIG91IHJlY29saGEgb3Mgc2V1cyBnYW5ob3MuPGJyPi0gRW52aWUgb3Mgc2V1cyBmdW5kb3MgcGFyYSBxdWFpc3F1ZXIgYXV0b3JlcyBvdSB1c3XDoXJpb3MsIGFtaWdvcywgc2VndWlkb3JlcywgZXRjLjxicj4tIFNpZ2EgYXV0b3JlcyBpbnRlcmVzc2FudGVzLCBibG9nZ2Vyczxicj4tLiBQcm9jdXJlIG9zIHNlZ3VpZG9yZXMgZSBhdXRvcmVzIHF1ZSBzZWd1ZS48YnI+LSBSZWNlYmEgbm90aWZpY2HDp8O1ZXMgcGFyYSBzZSBtYW50ZXIgZW0gY29udGFjdG8gY29tIG9zIHNldXMgc2VndWlkb3JlcyBlIGRpc2N1c3PDtWVzIGVtIHF1ZSBzZSBlbmNvbnRyZSBlbnZvbHZpZG8uPGJyPi0gUHJvY3VyZSBwb3IgbWFyY2Fkb3Jlcy9jYXRlZ29yaWFzIGludGVyZXNzYW50ZXMgZGUgYXJ0aWdvcywgYXV0b3Jlcy48YnI+LSBQZXJzb25hbGl6ZSBvIHNldSBwZXJmaWwuPGJyPi0gTXVpdGFzIG1haXMgZnVuY2lvbmFsaWRhZGVzIGEgY2FtaW5oby48YnI+PGJyPjxicj5TZWd1cmFuw6dhPC9iPjxicj4xLiBBIGFwbGljYcOnw6NvIG51bmNhIGFjZWRlIG91IHJldMOpbSBmdW5kb3MgZG8gdXN1w6FyaW8uPGJyPjIuIEEgYXBsaWNhw6fDo28gb2ZlcmVjZSB1bSBtb2RlbG8gZGUgc2VndXJhbsOnYSBxdWUgcHJpdmlsZWdpYSBvIGNsaWVudGUsIGNvbSBjaGF2ZXMgcHJpdmFkYXMgaG9zcGVkYWRhcyBsb2NhbG1lbnRlIGUgbnVuY2EgZW52aWFkYXMgcGFyYSBxdWFscXVlciBzZXJ2aWRvciwgdm9jw6ogw6kgcmVzcG9uc8OhdmVsIHBvciBmYXplciB1bWEgY8OzcGlhIGRlIHNlZ3VyYW7Dp2EgZGFzIHN1YXMgc2VuaGFzLjxicj4zLiBBIGFwbGljYcOnw6NvIG9mZXJlY2UgZXhwZXJpw6puY2lhcyBlIGludGVyZmFjZXMgZGUgdXN1w6FyaW8sIHNpbXBsZXMgZSBhdHJhZW50ZXMuPGJyPjQuIEEgYXBsaWNhw6fDo28gb2ZlcmVjZSB1bSBuw612ZWwgZXh0cmEgZGUgc2VndXJhbsOnYSBhdHJhdsOpcyBkbyBjw7NkaWdvIFBpbjxicj48YnI+TyBlU3RlZW0gYXBvaWEgYXMgcGxhdGFmb3JtYXMgU3RlZW0gZSBHb2xvcy48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkZ1bmRhZG9yIGUgZGVzZW52b2x2ZWRvciBwcmluY2lwYWxcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIkFkaWNpb25hciBjb250YVwiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdGFmb3JtYVwiLFxuXHRcIkVTQ1JPV1wiOiBcIkNvbXByb21pc3NvXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiQWdlbnRlIGRlcG9zaXTDoXJpb1wiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcIlByYXpvIGRlIHJhdGlmaWNhw6fDo29cIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIlZlbmNpbWVudG8gZG8gY29tcHJvbWlzc29cIixcblx0XCJFU0NST1dfRkVFXCI6IFwiVGF4YSBkZSBkZXDDs3NpdG9cIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCJUZXJtb3MgZG8gY29tcHJvbWlzc29cIixcblx0XCJOSUdIVF9NT0RFXCI6IFwiTW9kbyBub2N0dXJub1wiLFxuXHRcIkRBWV9NT0RFXCI6IFwiTW9kbyBkaXVybm9cIixcblx0XCJWSUVXX0NPTlRFWFRcIjogXCJWZXIgbyBjb250ZXh0byBjb21wbGV0b1wiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCJVdGlsaXphZG9yIG7Do28gZW5jb250cmFkb1wiLFxuXHRcIkFQUFJPVkVcIjogXCJBcHJvdmFyXCIsXG5cdFwiRElTUFVURVwiOiBcIkRpc3B1dGFcIixcblx0XCJSRUxFQVNFXCI6IFwiTGFuw6dhbWVudG9cIixcblx0XCJGUk9NXCI6IFwiRGVcIixcblx0XCJJRFwiOiBcImlkZW50aWZpY2HDp8Ojb1wiLFxuXHRcIlNVQk1JVFwiOiBcIlN1Ym1ldGVyXCIsXG5cdFwiUkVDRUlWRVJcIjogXCJEZXN0aW5hdMOhcmlvXCIsXG5cdFwiTE9DQVRJT05cIjogXCJMb2NhbGl6YcOnw6NvXCIsXG5cdFwiV0VCU0lURVwiOiBcIldlYnNpdGVcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCJOb21lIGEgZXhpYmlyXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcItCU0L7QvNC+0LlcIixcblx0XCJMT0dJTlwiOiBcItCS0L7QudGC0LhcIixcblx0XCJMT0dPVVRcIjogXCLQktGL0LnRgtC4XCIsXG5cdFwiUFJPRklMRVwiOiBcItCf0YDQvtGE0LjQu9GMXCIsXG5cdFwiRk9MTE9XXCI6IFwi0J/QvtC00L/QuNGB0LDRgtGM0YHRj1wiLFxuXHRcIkJPT0tNQVJLU1wiOiBcItCX0LDQutC70LDQtNC60LhcIixcblx0XCJUUkFOU0ZFUlwiOiBcItCf0LXRgNC10LLQtdGB0YLQuCDRgdGA0LXQtNGB0YLQstCwXCIsXG5cdFwiTUFSS0VUXCI6IFwi0KDRi9C90L7QulwiLFxuXHRcIlNFVFRJTkdTXCI6IFwi0J3QsNGB0YLRgNC+0LnQutC4XCIsXG5cdFwiQUJPVVRcIjogXCLQniDQv9GA0L7Qs9GA0LDQvNC80LVcIixcblx0XCJBQk9VVF8xXCI6IFwi0LPQtNC1INC60LDQttC00YvQuSDQvNC+0LbQtdGCINC/0L7Qu9GD0YfQsNGC0Ywg0LLQvtC30L3QsNCz0YDQsNC20LTQtdC90LjQtSDQt9CwINGB0LLQvtC4INC60L7QvdGC0LXQvdGCIVwiLFxuXHRcIkFCT1VUXzJcIjogXCLQvtGB0L3QvtCy0LDQvdC+INC90LAg0L/Qu9Cw0YLRhNC+0YDQvNC1IHt7cGxhdGZvcm1uYW1lfX0uINCf0YDQuNC70L7QttC10L3QuNC1INGB0L7Qt9C00LDQvdC+XCIsXG5cdFwiQUJPVVRfM1wiOiBcItC4INGP0LLQu9GP0LXRgtGB0Y8g0LzQvtCx0LjQu9GM0L3Ri9C8INC/0YDQvtC10LrRgtC+0Lwg0YEg0L7RgtC60YDRi9GC0YvQvCDQuNGB0YXQvtC00L3Ri9C8INC60L7QtNC+0Lwg0YPQv9GA0LDQstC70Y/QtdC80YvQvCDRgdC+0L7QsdGJ0LXRgdGC0LLQvtC8LiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQtNC+0YHRgtGD0L8g0Log0LrQvtC90YLQtdC90YLRgyDQtNC70Y8g0YfRgtC10L3QuNGPLCDQutC+0LzQvNC10L3RgtC40YDQvtCy0LDQvdC40Y8sINCz0L7Qu9C+0YHQvtCy0LDQvdC40Y8g0Lgg0YDQsNC30LzQtdGJ0LXQvdC40Y8sINC/0YDQtdC00L7RgdGC0LDQstC70Y/QtdGCINCy0L7Qt9C80L7QttC90L7RgdGC0Ywg0L/QtdGA0LXQstC+0LTQsCDRgdGA0LXQtNGB0YLQsiDQuCDQtNGA0YPQs9C40LUg0YTRg9C90LrRhtC40LgsINC/0YDQtdC00LvQsNCz0LDQtdC80YvQtSDQsdC70L7QutGH0LXQudC90L7QvCB7e3BsYXRmb3JtbmFtZX19INC4INGB0LXRgNCy0LjRgdC+0Lwge3tzaXRlbmFtZX19LlwiLFxuXHRcIkFCT1VUXzRcIjogXCIxLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvdC1INC40LzQtdC10YIg0LTQvtGB0YLRg9C/0LAg0Log0LTQtdC90LXQttC90YvQvCDRgdGA0LXQtNGB0YLQstCw0Lwg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINC4INC90LUg0YPQtNC10YDQttC40LLQsNC10YIg0LjRhTtcIixcblx0XCJBQk9VVF81XCI6IFwiMi4g0J/RgNC40LvQvtC20LXQvdC40LUg0LjRgdC/0L7Qu9GM0LfRg9C10YIg0LzQvtC00LXQu9GMINCx0LXQt9C+0L/QsNGB0L3QvtGB0YLQuCDQvdCwINGB0YLQvtGA0L7QvdC1INC60LvQuNC10L3RgtCwLCDQt9Cw0LrRgNGL0YLRi9C1INC60LvRjtGH0Lgg0YXRgNCw0L3Rj9GC0YHRjyDQu9C+0LrQsNC70YzQvdC+INC4INC90LjQutC+0LPQtNCwINC90LUg0L/QtdGA0LXQtNCw0Y7RgtGB0Y8g0L3QsCDRgdC10YDQstC10YDQsDtcIixcblx0XCJBQk9VVF82XCI6IFwiMy4g0J/RgNC40LvQvtC20LXQvdC40LUg0L/RgNC10LTQvtGB0YLQsNCy0LvRj9C10YIg0L/RgNC+0YHRgtC+0Lkg0Lgg0L/RgNC40LLQu9C10LrQsNGC0LXQu9GM0L3Ri9C5INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC5INC40L3RgtC10YDRhNC10LnRgTtcIixcblx0XCJBQk9VVF83XCI6IFwiNC4g0J/RgNC40LvQvtC20LXQvdC40LUg0L3QuNC60L7Qs9C00LAg0L3QtSDRgtGA0LXQsdGD0LXRgiDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0LLQstC10YHRgtC4INC60LDQutC40LUt0LvQuNCx0L4g0L/QtdGA0YHQvtC90LDQu9GM0L3Ri9C1INC00LDQvdC90YvQtS5cIixcblx0XCJBQk9VVF84XCI6IFwi0J/RgNC+0LPQvtC70L7RgdC+0LLQsNGC0Ywg0LfQsCDQtNC10LvQtdCz0LDRgtCwIGdvb2Qta2FybWFcIixcblx0XCJBQk9VVF85XCI6IFwi0JrQvtC90YLQsNC60YLRiy/QntCx0YDQsNGC0L3QsNGPINGB0LLRj9C30Yw6XCIsXG5cdFwiQUJPVVRfMTBcIjogXCLQlNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QsNGPINC40L3RhNC+0YDQvNCw0YbQuNGPOlwiLFxuXHRcIlJFTU9WRVwiOiBcItCj0LTQsNC70LjRgtGMXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLQntCx0LfQvtGAINGA0YvQvdC60LBcIixcblx0XCJQUklDRVwiOiBcItCm0LXQvdCwXCIsXG5cdFwiQU1PVU5UXCI6IFwi0KHRg9C80LzQsFwiLFxuXHRcIlRPVEFMXCI6IFwi0JLRgdC10LPQvlwiLFxuXHRcIk5PT1JERVJTXCI6IFwi0J3QtdGCINC+0YLQutGA0YvRgtGL0YUg0L7RgNC00LXRgNC+0LIg0YNcIixcblx0XCJEQVRFXCI6IFwi0JTQsNGC0LBcIixcblx0XCJCVVlcIjogXCLQmtGD0L/QuNGC0YxcIixcblx0XCJTRUxMXCI6IFwi0J/RgNC+0LTQsNGC0YxcIixcblx0XCJPUEVOXCI6IFwi0J7RgtC60YDRi9GC0YxcIixcblx0XCJISVNUT1JZXCI6IFwi0JjRgdGC0L7RgNC40Y9cIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcItCf0L7QtNC/0LjRgdCw0YLRjNGB0Y8g0LLQt9Cw0LjQvNC90L5cIixcblx0XCJGT0xMT1dFRFwiOiBcItCf0L7QtNC/0LjRgdC60LhcIixcblx0XCJVTkZPTExPV1wiOiBcItCe0YLQv9C40YHQsNGC0YzRgdGPXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwi0J/QvtC00L/QuNGB0LrQsFwiLFxuXHRcIkZPTExPV0VSU1wiOiBcItCf0L7QtNC/0LjRgdCw0L3Ri1wiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLQn9C+0LjRgdC6INC/0L7QtNC/0LjRgdGH0LjQutC+0LJcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwi0J/QvtC40YHQuiDQv9C+0LTQv9C40YHQsNC90L3Ri9GFXCIsXG5cdFwiQllcIjogXCLQvtGCXCIsXG5cdFwiSU5cIjogXCLQslwiLFxuXHRcIk1FTlVcIjogXCLQnNC10L3RjlwiLFxuXHRcIkJPT0tNQVJLXCI6IFwi0JfQsNC60LvQsNC00LrQsFwiLFxuXHRcIlJFQkxPR1wiOiBcItCg0LXQv9C+0YHRglwiLFxuXHRcIlVQVk9URVwiOiBcItCT0L7Qu9C+0YEg0JfQsFwiLFxuXHRcIkRPV05WT1RFXCI6IFwi0JPQvtC70L7RgSDQn9GA0L7RgtC40LJcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwi0KHQvdGP0YLRjCDQk9C+0LvQvtGBINCf0YDQvtGC0LjQslwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi0KHQvdGP0YLRjCDQk9C+0LvQvtGBINCX0LBcIixcblx0XCJSRVBMWVwiOiBcItCe0YLQstC10YLQuNGC0YxcIixcblx0XCJFRElUXCI6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0YxcIixcblx0XCJQT1NUXzFcIjogXCLQn9GA0L7QstC10LTQuNGC0LUg0L/QsNC70YzRhtC10Lwg0LLQu9C10LLQviDQvdCwINC60L7QvNC80LXQvdGC0LDRgNC40LgsINGH0YLQvtCx0Ysg0YPQstC40LTQtdGC0Ywg0LLQsNGA0LjQsNC90YLRi1wiLFxuXHRcIlBPU1RfMlwiOiBcItCd0LDQttC80LjRgtC1INC90LAg0LrQvtC80LzQtdC90YLQsNGA0LjQuCwg0YfRgtC+0LHRiyDRg9Cy0LjQtNC10YLRjCDQstC70L7QttC10L3QvdGL0LUg0LrQvtC80LzQtdC90YLQsNGA0LjQuFwiLFxuXHRcIk9QVElPTlNcIjogXCLQn9Cw0YDQsNC80LXRgtGA0YtcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLQoNC10L/QvtGB0YLQvdGD0YLQvlwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcItCX0LTQtdGB0Ywg0L/QvtC60LAg0L3QuNGH0LXQs9C+INC90LXRgi4uLlwiLFxuXHRcIkJBTEFOQ0VTXCI6IFwi0JHQsNC70LDQvdGB0YtcIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCDQv9C10YDQtdC80LXRidCw0LXQvNGL0LUg0YbQuNGE0YDQvtCy0YvQtSDRgtC+0LrQtdC90YssINC60L7RgtC+0YDRi9C1INC80L7Qs9GD0YIg0LHRi9GC0Ywg0L/QtdGA0LXQtNCw0L3RiyDQsiDQu9GO0LHQvtC1INCy0YDQtdC80Y8uIHt7cGxhdGZvcm1uYW1lfX0g0LzQvtC20LXRgiDQsdGL0YLRjCDQutC+0L3QstC10YDRgtC40YDQvtCy0LDQvSDQsiB7e3BsYXRmb3JtcG93ZXJ9fSwg0Y3RgtC+0YIg0L/RgNC+0YbQtdGB0YEg0L3QsNC30YvQstCw0LXRgtGB0Y8gwqvRg9GB0LjQu9C10L3QuNC1IHt7cGxhdGZvcm1uYW1lfX0t0LDCuy5cIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwg0L3QtdC/0LXRgNC10LzQtdGJ0LDQtdC80YvQtSDRhtC40YTRgNC+0LLRi9C1INGC0L7QutC10L3Riywg0LjRhSDQutC+0LvQuNGH0LXRgdGC0LLQviDRg9Cy0LXQu9C40YfQuNCy0LDQtdGC0YHRjyDQv9GA0Lgg0LTQvtC70LPQvtGB0YDQvtGH0L3QvtC8INGF0YDQsNC90LXQvdC40Lgg0Lgg0LPQvtC70L7RgdC+0LLQsNC90LjQuCDQt9CwINC/0L7RgdGC0YsuINCn0LXQvCDQuNGFINGDINCS0LDRgSDQsdC+0LvRjNGI0LUsINGC0LXQvCDRgdC40LvRjNC90LXQuSDQktGLINCy0LvQuNGP0LXRgtC1INC90LAg0LLQvtC30L3QsNCz0YDQsNC20LTQtdC90LjQtSDQt9CwINC/0L7RgdGC0Ysg0LTRgNGD0LPQuNGFINC4INGC0LXQvCDQsdC+0LvRjNGI0LUg0JLRiyDQv9C+0LvRg9GH0LDQtdGC0LUg0LLQvtC30L3QsNCz0YDQsNC20LTQtdC90LjQtSDQt9CwINGB0LLQvtC1INCz0L7Qu9C+0YHQvtCy0LDQvdC40LUuXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwi0KLQvtC60LXQvdGLINGB0YLQvtGP0YIg0L/RgNC40LzQtdGA0L3QviB7e3BsYXRmb3Jtc3VuaXR9fSDQsiB7e3BsYXRmb3JtbmFtZX19INGN0LrQstC40LLQsNC70LXQvdGC0LUuXCIsXG5cdFwiRVNUSU1BVEVEX1ZBTFVFXCI6IFwi0J7RgNC40LXQvdGC0LjRgNC+0LLQvtGH0L3QsNGPINGB0YLQvtC40LzQvtGB0YLRjFwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcItCe0YDQuNC10L3RgtC40YDQvtCy0L7Rh9C90LDRjyDRgdGC0L7QuNC80L7RgdGC0Ywg0L7RgdC90L7QstCw0L3QsCDQvdCwIDct0LTQvdC10LLQvdC+0Lkg0YHRgNC10LTQvdC10Lkg0YHRgtC+0LjQvNC+0YHRgtC4IHt7cGxhdGZvcm1uYW1lfX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcItCY0YHRgtC+0YDQuNGPINGC0YDQsNC90LfQsNC60YbQuNC5XCIsXG5cdFwiUE9TVElOR1wiOiBcItCf0L7RgdGC0LjQvdCzXCIsXG5cdFwiUFJPRklMRV81XCI6IFwi0J/QvtGB0YLQuNC90LMg0LrQu9GO0Ycg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQv9C+0YHRgtC40L3Qs9CwINC4INCz0L7Qu9C+0YHQvtCy0LDQvdC40Y8uINCe0L0g0LTQvtC70LbQtdC9INC+0YLQu9C40YfQsNGC0YzRgdGPINC+0YIg0LDQutGC0LjQstC90L7Qs9C+INC60LvRjtGH0LAg0Lgg0LrQu9GO0YfQsCDQstC70LDQtNC10LvRjNGG0LAuXCIsXG5cdFwiT1dORVJcIjogXCLQktC70LDQtNC10LvQtdGGXCIsXG5cdFwiUFJPRklMRV82XCI6IFwi0JrQu9GO0Ycg0LLQu9Cw0LTQtdC70YzRhtCwINGP0LLQu9GP0LXRgtGB0Y8g0LzQsNGB0YLQtdGAINC60LvRjtGH0L7QvCDQtNC70Y8g0LDQutC60LDRg9C90YLQsCDQuCDRgtGA0LXQsdGD0LXRgtGB0Y8g0LTQu9GPINC40LfQvNC10L3QtdC90LjRjyDQtNGA0YPQs9C40YUg0LrQu9GO0YfQtdC5LiDQl9Cw0LrRgNGL0YLRi9C5INC60LvRjtGHINC40LvQuCDQv9Cw0YDQvtC70Ywg0L7RgiDQutC70Y7Rh9CwINCy0LvQsNC00LXQu9GM0YbQsCDQtNC+0LvQttC10L0g0YXRgNCw0L3QuNGC0YzRgdGPINC+0YTQu9Cw0LnQvSwg0L3QsNGB0LrQvtC70YzQutC+INGN0YLQviDQstC+0LfQvNC+0LbQvdC+LlwiLFxuXHRcIkFDVElWRVwiOiBcItCQ0LrRgtC40LLQvdGL0LlcIixcblx0XCJQUk9GSUxFXzdcIjogXCLQkNC60YLQuNCy0L3Ri9C5INC60LvRjtGHINC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQtNC70Y8g0L/QtdGA0LXQstC+0LTQsCDRgdGA0LXQtNGB0YLQsiDQuCDRgNCw0LfQvNC10YnQtdC90LjRjyDQvtGA0LTQtdGA0L7QsiDQvdCwINCy0L3Rg9GC0YDQtdC90L3QtdC8INGA0YvQvdC60LUuXCIsXG5cdFwiTUVNT1wiOiBcItCf0YDQuNC80LXRh9Cw0L3QuNC1XCIsXG5cdFwiUFJPRklMRV84XCI6IFwi0JrQu9GO0Ycg0LTQu9GPINC/0YDQuNC80LXRh9Cw0L3QuNC5INC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQtNC70Y8g0YHQvtC30LTQsNC90LjRjyDQuCDRh9GC0LXQvdC40Y8g0L/RgNC40LzQtdGH0LDQvdC40LkuXCIsXG5cdFwiQkxPR1wiOiBcItCR0LvQvtCzXCIsXG5cdFwiUE9TVFNcIjogXCLQn9C+0YHRgtGLXCIsXG5cdFwiUkVQTElFU1wiOiBcItCe0YLQstC10YLRi1wiLFxuXHRcIldBTExFVFwiOiBcItCa0L7RiNC10LvQtdC6XCIsXG5cdFwiVEFHXCI6IFwi0KLQtdCzXCIsXG5cdFwiVVNFUlwiOiBcItCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjFwiLFxuXHRcIkNMT1NFXCI6IFwi0JfQsNC60YDRi9GC0YxcIixcblx0XCJUT1wiOiBcItCa0L7QvNGDXCIsXG5cdFwiQVNTRVRcIjogXCLQkNC60YLQuNCyXCIsXG5cdFwiU0VORFwiOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi0JHQtdC30L7Qv9Cw0YHQvdC+0YHRgtGMXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi0JTQvtGB0YLRg9C/0L3QvlwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwi0J7QsdGJ0LXQtNC+0YHRgtGD0L/QvdC+0LUg0L/RgNC40LzQtdGH0LDQvdC40LVcIixcblx0XCJUT19ERVNDXCI6IFwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMLCDQvdCw0L/RgNC40LzQtdGAIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBJTi3QutC+0LRcIixcblx0XCJQSU5fVEVYVFwiOiBcIlBJTi3QutC+0LQg0L/QvtC80L7QttC10YIg0JLQsNC8INC30LDRidC40YLQuNGC0Ywg0L/RgNC40LvQvtC20LXQvdC40LUg0Lgg0JLQsNGI0Lgg0LTQsNC90L3Ri9C1LiA8YnIvPjxici8+PGI+0J/RgNC40LzQtdGH0LDQvdC40LU6PC9iPiDQn9C+0YHQu9C1INCy0LrQu9GO0YfQtdC90LjRjywg0YMg0JLQsNGBINC10YHRgtGMINC80LDQutGB0LjQvNGD0LwgNCDQv9C+0L/Ri9GC0LrQuCDRgNCw0LfQsdC70L7QutC40YDQvtCy0LDRgtGMINC/0YDQuNC70L7QttC10L3QuNC1LCDQtdGB0LvQuCDQktGLINC30LDQsdGL0LvQuCBQSU4t0LrQvtC0INC40LvQuCDQvtGI0LjQsdC70LjRgdGMINCyINC10LPQviDQvdCw0LHQvtGA0LUsINC/0YDQuNC70L7QttC10L3QuNC1INGD0LTQsNC70LjRgiDQtNCw0L3QvdGL0LUg0LLQvtGI0LXQtNGI0LXQs9C+INCyINGB0LjRgdGC0LXQvNGDINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy4g0JLRiyDQvNC+0LbQtdGC0LUg0L/QvtCy0YLQvtGA0L3QviDQstGL0L/QvtC70L3QuNGC0Ywg0LLRhdC+0LQg0Lgg0L/RgNC+0LTQvtC70LbQuNGC0Ywg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINC/0YDQuNC70L7QttC10L3QuNC1LlwiLFxuXHRcIk5PVElGSUNBVElPTlNcIjogXCLQo9Cy0LXQtNC+0LzQu9C10L3QuNGPXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi0JLRiyDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC60L7Qs9C00LAg0LrRgtC+INGC0L4g0LPQvtC70L7RgdGD0LXRgiDQt9CwINCS0LDRiCDQutC+0L3RgtC10L3RgiEgPGJyLz48Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCj0LLQtdC00L7QvNC70LXQvdC40Y8g0L7RgtC+0LHRgNCw0LbQsNGO0YIg0LLQtdGBINCz0L7Qu9C+0YHQsCDQsiDRgdC+0L7QsdGJ0LXQvdC40LggKNCx0YPQtNGMINGC0L4g0JPQvtC70L7RgSDQl9CwLCDQk9C+0LvQvtGBINCf0YDQvtGC0LjQsiwg0YHQvdGP0YLQuNC1INCT0L7Qu9C+0YHQsCkuXCIsXG5cdFwiVk9URVwiOiBcItCT0L7Qu9C+0YHQvtCy0LDQvdC40LVcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDQv9GA0L7QutC+0LzQvNC10L3RgtC40YDRg9C10YIg0JLQsNGI0Lgg0L/QvtGB0YLRiyDQuNC70Lgg0LrQvtC80LzQtdC90YLQsNGA0LjQuCE8YnIvPiA8Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCS0Ysg0YLQsNC60LbQtSDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC10YHQu9C4INC60YLQvi3RgtC+IDxiPtC+0YLRgNC10LTQsNC60YLQuNGA0YPQtdGCPC9iPiDRgdCy0L7QuSDQutC+0LzQvNC10L3RgtCw0YDQuNC5LlwiLFxuXHRcIkNPTU1FTlRcIjogXCLQmtC+0LzQvNC10L3RgtCw0YDQuNC5XCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLQktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSwg0LrQvtCz0LTQsCDQutGC0L4t0YLQviDQv9C+0LTQv9C40YjQtdGC0YHRjyDQuNC70Lgg0L7RgtC/0LjRiNC10YLRgdGPINC+0YIg0JLQsNGBIVwiLFxuXHRcIk1FTlRJT05TXCI6IFwi0KPQv9C+0LzQuNC90LDQvdC40Y9cIixcblx0XCJNRU5USU9OU19URVhUXCI6IFwi0JLRiyDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC60L7Qs9C00LAg0LrRgtC+LdGC0L4g0YPQv9C+0LzRj9C90LXRgiDQktCw0YEg0LIg0YHQstC+0LXQvCDQv9C+0YHRgtC1L9C60L7QvNC80LXQvdGC0LDRgNC40LkhXCIsXG5cdFwiUkVTVEVFTVwiOiBcItCg0LXQv9C+0YHRgtGLXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwi0JLRiyDQv9C+0LvRg9GH0LjRgtC1INGD0LLQtdC00L7QvNC70LXQvdC40LUsINC60L7Qs9C00LAg0LrRgtC+LdGC0L4g0YHQtNC10LvQsNC10YIg0YDQtdC/0L7RgdGCINCS0LDRiNC10LPQviDQv9C+0YHRgtCwIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi0JrQvtC90YTQuNCz0YPRgNCw0YbQuNGPXCIsXG5cdFwiVk9USU5HXCI6IFwi0JPQvtC70L7RgdC+0LLQsNGC0YxcIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcItCS0LXRgSDQs9C+0LvQvtGB0LAg0LIg0L/RgNC+0YbQtdC90YLQsNGFINCy0LvQuNGP0LXRgiDQvdCwINGB0LjQu9GDINCz0L7Qu9C+0YHQsCDQsiDQv9GA0LjQu9C+0LbQtdC90LjQuCwg0YLQsNC6INGH0YLQviDQktGLINC80L7QttC10YLQtSDRgNC10LPRg9C70LjRgNC+0LLQsNGC0Ywg0L3QsNCz0YDQsNC00YMg0L/RgNC4INCz0L7Qu9C+0YHQvtCy0LDQvdC40LguIDxici8+PGJyLz48Yj7Qn9GA0LjQvNC10YfQsNC90LjQtTo8L2I+INCt0YLQviDRgtCw0LrQttC1INC40LfQvNC10L3QuNGCINCy0LXRgSDQk9C+0LvQvtGB0LAg0J/RgNC+0YLQuNCyXCIsXG5cdFwiU0VSVkVSXCI6IFwi0KHQtdGA0LLQtdGAXCIsXG5cdFwiU0VSVkVSX1RFWFRcIjogXCLQoNC10LrQvtC80LXQvdC00L7QstCw0L3QvdGL0LlcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLQodC+0YXRgNCw0L3QuNGC0Ywg0LjQt9C80LXQvdC10L3QuNGPXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCLQmNC90YTQvtGA0LzQsNGG0LjRjyDQviDQv9GA0L7Qs9C+0LvQvtGB0L7QstCw0LLRiNC40YVcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCLQlNC+0LHRgNC+INC/0L7QttCw0LvQvtCy0LDRgtGMIVwiLFxuXHRcIkxPR0lOXzFcIjogXCLQp9GC0L7QsdGLINC/0YDQvtC00L7Qu9C20LjRgtGMLCDQstC+0LnQtNC40YLQtSDRgSDQktCw0YjQuNC8INC40LzQtdC90LXQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0Lgg0L/QsNGA0L7Qu9C10LwuXCIsXG5cdFwiTE9HSU5fMlwiOiBcItCf0L7RgdGC0LjQvdCzINC60LvRjtGHINC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQtNC70Y8g0L3QsNC/0LjRgdCw0L3QuNGPINC/0L7RgdGC0L7Qsiwg0LrQvtC80LzQtdC90YLQsNGA0LjQtdCyLCDQs9C+0LvQvtGB0L7QstCw0L3QuNGPINC4INC/0L7QtNC/0LjRgdC+0LouXCIsXG5cdFwiTE9HSU5fM1wiOiBcItCQ0LrRgtC40LLQvdGL0Lkg0LrQu9GO0Ycg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPINC00LvRjyDQv9C10YDQtdCy0L7QtNCwINGB0YDQtdC00YHRgtCyINC4INC+0LHQvdC+0LLQu9C10L3QuNGPINC40LfQvtCx0YDQsNC20LXQvdC40Y8g0LIg0L/RgNC+0YTQuNC70LUuXCIsXG5cdFwiTE9HSU5fNFwiOiBcItCj0YfQtdGC0L3Ri9C1INC00LDQvdC90YvQtSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0YXRgNCw0L3Rj9GC0YHRjyDQu9C+0LrQsNC70YzQvdC+INC90LAg0YPRgdGC0YDQvtC50YHRgtCy0LUuINCf0YDQuCDQktGL0YXQvtC00LUg0YPRh9C10YLQvdGL0LUg0LTQsNC90L3Ri9C1INCx0YPQtNGD0YIg0YPQtNCw0LvQtdC90YshXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi0J3QtSDQt9Cw0YDQtdCz0LjRgdGC0YDQuNGA0L7QstCw0L3Riz9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcItCX0LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDRgtGM0YHRjyDRgdC10LnRh9Cw0YFcIixcblx0XCJDQU5DRUxcIjogXCLQntGC0LzQtdC90LBcIixcblx0XCJBRFZBTkNFRFwiOiBcItCg0LDRgdGI0LjRgNC10L3QvdGL0Lkg0YDQtdC20LjQvFwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLQkNC60YLQuNCy0L3Ri9C5INC30LDQutGA0YvRgtGL0Lkg0LrQu9GO0YdcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcItCf0L7RgdGC0LjQvdCzINC30LDQutGA0YvRgtGL0Lkg0LrQu9GO0YdcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcItCc0LDRgdGC0LXRgC/QvtGB0L3QvtCy0L3QvtC5INC/0LDRgNC+0LvRjFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwi0JjQvNGPINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1wiLFxuXHRcIkNBUkRfVklFV1wiOiBcItCa0LDRgNGC0L7Rh9C60LhcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLQmtC+0LzQv9Cw0LrRgtC90YvQuVwiLFxuXHRcIlNFQVJDSFwiOiBcItCf0L7QuNGB0LpcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcItCU0L7QsdCw0LLQuNGC0Ywg0YHRgtCw0YLRjNGOXCIsXG5cdFwiUkVQTFlUT1wiOiBcItCe0YLQstC10YLQuNGC0Ywg0L3QsFwiLFxuXHRcIlBPU1RcIjogXCLQn9C+0YHRglwiLFxuXHRcIlBSRVZJRVdcIjogXCLQn9GA0LXQtNCy0LDRgNC40YLQtdC70YzQvdGL0Lkg0L/RgNC+0YHQvNC+0YLRgFwiLFxuXHRcIkRFRkFVTFRcIjogXCLQn9C+INGD0LzQvtC70YfQsNC90LjRjiA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwi0JfQsNC/0LvQsNGC0LjRgtGMIDEwMCUg0LIge3twbGF0Zm9ybXBvd2VyfX1cIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcItCe0YLQutCw0LfQsNGC0YzRgdGPINC+0YIg0LLRi9C/0LvQsNGC0YtcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcItCh0J7QpdCg0JDQndCY0KLQrCDQlNCb0K8g0J/QntCh0JvQldCU0KPQrtCp0JXQk9CeINCY0KHQn9Ce0JvQrNCX0J7QktCQ0J3QmNCvXCIsXG5cdFwiQ0xFQVJcIjogXCLQntCn0JjQodCi0JjQotCsXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi0KHQvtC00LXRgNC20LDQvdC40LUg0L/QvtGB0YLQsFwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcItCh0L7QtNC10YDQttCw0L3QuNC1INC60L7QvNC80LXQvdGC0LDRgNC40Y9cIixcblx0XCJUSVRMRVwiOiBcItCX0LDQs9C+0LvQvtCy0L7QulwiLFxuXHRcIlRBR1NcIjogXCLQotC10LPQuFwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcItCd0JUg0KHQntCS0J/QkNCU0JXQndCY0JlcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcItCf0L7QtNGC0LLQtdGA0LTQuNGC0LUgUElOLdC60L7QtFwiLFxuXHRcIklOQ09SUkVDVFwiOiBcItCd0JXQn9Cg0JDQktCY0JvQrNCd0J5cIixcblx0XCJPUEVOSU5HX1BPU1RcIjogXCLQvtGC0LrRgNGL0YLQuNC1INC/0L7RgdGC0LBcIixcblx0XCJTRVRfUElOXCI6IFwi0KPRgdGC0LDQvdC+0LLQuNGC0LUgUElOLdC60L7QtFwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcItCS0LLQtdC00LjRgtC1IFBJTi3QutC+0LRcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLQktGLINGD0LLQtdGA0LXQvdGLP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwi0KDQtdC/0L7RgdGCINGP0LLQu9GP0LXRgtGB0Y8g0L3QtdC+0LHRgNCw0YLQuNC80YvQvCwg0JLRiyDRhdC+0YLQuNGC0LUg0L/RgNC+0LTQvtC70LbQuNGC0Yw/XCIsXG5cdFwiQlJPQURDQVNUX0VSUk9SXCI6IFwi0J3QtSDRg9C00LDQu9C+0YHRjCDRgtGA0LDQvdGB0LvQuNGA0L7QstCw0YLRjCwg0L/QvtC/0YDQvtCx0YPQudGC0LUg0LXRidC1INGA0LDQtyFcIixcblx0XCJTVUNDRVNTXCI6IFwi0KPRgdC/0LXRiNC90L5cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcItCg0LXQv9C+0YHRgtC90YPRgtGL0Lkg0L/QvtGB0YIhXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcItCe0YjQuNCx0LrQsCDQstGF0L7QtNCwISDQn9C+0LbQsNC70YPQudGB0YLQsCwg0YPQsdC10LTQuNGC0LXRgdGMLCDRh9GC0L4g0LLRiyDQstC+0YjQu9C4INCyINGB0LjRgdGC0LXQvNGDINGBINC80LDRgdGC0LXRgCDQv9Cw0YDQvtC70LXQvCDQuNC70Lgg0YPQutCw0LfQsNC70Lgg0LfQsNC60YDRi9GC0YvQuSDQn9C+0YHRgtC40L3QsyDQutC70Y7RhyDQv9GA0Lgg0LLRhdC+0LTQtSDQsiDRgdC40YHRgtC10LzRgyDQsiDRgNCw0YHRiNC40YDQtdC90L3QvtC8INGA0LXQttC40LzQtS5cIixcblx0XCJMT0dJTl9GQUlMX0FcIjogXCLQntGI0LjQsdC60LAg0LLRhdC+0LTQsCEg0J/QvtC20LDQu9GD0LnRgdGC0LAsINGD0LHQtdC00LjRgtC10YHRjCwg0YfRgtC+INCy0Ysg0LLQvtGI0LvQuCDQsiDRgdC40YHRgtC10LzRgyDRgSDQvNCw0YHRgtC10YAg0L/QsNGA0L7Qu9C10Lwg0LjQu9C4INGD0LrQsNC30LDQu9C4INC30LDQutGA0YvRgtGL0Lkg0JDQutGC0LjQstC90YvQuSDQutC70Y7RhyDQv9GA0Lgg0LLRhdC+0LTQtSDQsiDRgdC40YHRgtC10LzRgyDQsiDRgNCw0YHRiNC40YDQtdC90L3QvtC8INGA0LXQttC40LzQtS5cIixcblx0XCJXQVJOSU5HXCI6IFwi0J/RgNC10LTRg9C/0YDQtdC20LTQtdC90LjQtVwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLQk9C+0LvQvtGB0L7QstCw0YLRjCDQt9CwINC00LXQu9C10LPQsNGC0LBcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcItCf0YDQvtCz0L7Qu9C+0YHQvtCy0LDQu9C4INC30LAg0LTQtdC70LXQs9Cw0YLQsFwiLFxuXHRcIkFHT1wiOiBcItC90LDQt9Cw0LRcIixcblx0XCJGUk9NX05PV1wiOiBcItGBINGN0YLQvtCz0L4g0LzQvtC80LXQvdGC0LBcIixcblx0XCJTRUNTXCI6IFwi0YHQtdC60YPQvdC0XCIsXG5cdFwiQV9NSU5cIjogXCLQvNC40L3Rg9GC0LBcIixcblx0XCJNSU5TXCI6IFwi0LzQuNC90YPRgijRiylcIixcblx0XCJBTl9IT1VSXCI6IFwi0YfQsNGBXCIsXG5cdFwiSE9VUlNcIjogXCLRh9Cw0YHQsCjQvtCyKVwiLFxuXHRcIkFfREFZXCI6IFwi0LTQtdC90YxcIixcblx0XCJEQVlTXCI6IFwi0LTQvdGPKNC10LkpXCIsXG5cdFwiQV9NT05USFwiOiBcItC80LXRgdGP0YZcIixcblx0XCJNT05USFNcIjogXCLQvNC10YHRj9GG0LAo0LXQsilcIixcblx0XCJBX1lFQVJcIjogXCLQs9C+0LRcIixcblx0XCJZRUFSU1wiOiBcItCz0L7QtNCwXCIsXG5cdFwiTUlOX1JFQURcIjogXCLQvNC40L0g0YfRgtC10L3QuNGPXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcItCT0L7Qu9C+0YEg0J/RgNC+0YLQuNCyINC40LvQuCDRhNC70LDQs1wiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcItCX0LDRhdCy0LDRgiDQuNC30L7QsdGA0LDQttC10L3QuNGPXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCLQktGL0LHQvtGAINC40LfQvtCx0YDQsNC20LXQvdC40Y9cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcItCX0LDQtNCw0YLRjCDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQuSBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcItCS0YHRgtCw0LLQuNGC0Ywg0LjQt9C+0LHRgNCw0LbQtdC90LjQtVwiLFxuXHRcIkVSUk9SXCI6IFwi0J7RiNC40LHQutCwXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi0J7RiNC40LHQutCwINC/0YDQuCDQt9Cw0LPRgNGD0LfQutC1XCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcItCX0LDRhdCy0LDRgiDQuNC30L7QsdGA0LDQttC10L3QuNGPINC+0YLQvNC10L3QtdC9XCIsXG5cdFwiU0VUX1VSTFwiOiBcItCS0YHRgtCw0LLQuNGC0Ywg0YHRgdGL0LvQutGDXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcItCf0YDRj9C80LDRjyDRgdGB0YvQu9C60LAg0L3QsCDQuNC30L7QsdGA0LDQttC10L3QuNC1XCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCLQmtC+0LzQvNC10L3RgtCw0YDQuNC5INC+0YLQv9GA0LDQstC70LXQvSFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcItCj0LTQsNC70LXQvdC40LUg0LrQvtC80LzQtdC90YLQsNGA0LjQtdCyINGP0LLQu9GP0LXRgtGB0Y8g0L3QtdC+0LHRgNCw0YLQuNC80YvQvFwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcItCj0LTQsNC70LXQvdC90YvQuSDQutC+0LzQvNC10L3RgtCw0YDQuNC5XCIsXG5cdFwiVVBMT0FESU5HX1BJQ1RVUkVcIjogXCLQl9Cw0LPRgNGD0LfQutCwINC40LfQvtCx0YDQsNC20LXQvdC40Y9cIixcblx0XCJVUExPQURfQ09NUExFVEVEXCI6IFwi0JfQsNCz0YDRg9C30LrQsCDQt9Cw0LLQtdGA0YjQtdC90LBcIixcblx0XCJVUExPQURfRkFJTEVEXCI6IFwi0J3QtSDRg9C00LDQu9C+0YHRjCDQt9Cw0LPRgNGD0LfQuNGC0YxcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLQndC10L/RgNCw0LLQuNC70YzQvdGL0Lkg0L/QsNGA0L7Qu9GMINC40LvQuCDQuNC80Y8g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXCIsXG5cdFwiSU5GT1wiOiBcItCY0L3RhNC+0YDQvNCw0YbQuNGPXCIsXG5cdFwiUVJfVEVYVFwiOiBcItCg0LDQt9C80LXRgdGC0LjRgtC1IFFSINC60L7QtCDQstC90YPRgtGA0Lgg0YHQutCw0L3QuNGA0YPRjtGJ0LXQuSDQvtCx0LvQsNGB0YLQuFwiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcItCj0LHQtdC00LjRgtC10YHRjCDRh9GC0L4g0YMg0JLQsNGBINC00L7RgdGC0LDRgtC+0YfQvdC+INGB0YDQtdC00YHRgtCyINC00LvRjyDRgtGA0LDQvdC30LDQutGG0LjQuCFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GMLCDQutC+0YLQvtGA0L7QvNGDINCS0Ysg0L/Ri9GC0LDQtdGC0LXRgdGMINC/0LXRgNC10LLQtdGB0YLQuCDRgdGA0LXQtNGB0YLQstCwLCDQvdC1INGB0YPRidC10YHRgtCy0YPQtdGCIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLQktGLINGD0LLQtdGA0LXQvdGLINGH0YLQviDRhdC+0YLQuNGC0LUg0L7RgdGD0YnQtdGB0YLQstC40YLRjCDQv9C10YDQtdCy0L7QtCDRgdGA0LXQtNGB0YLQsj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLQn9C+0LTRgtCy0LXRgNC20LTQtdC90LjQtVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi0KLRgNCw0L3Qt9Cw0LrRhtC40Y8g0LHRi9C70LAg0YLRgNCw0L3RgdC70LjRgNC+0LLQsNC90LBcIixcblx0XCJGRUVEXCI6IFwi0JvQtdC90YLQsFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwi0JvRg9GH0YjQtdC1XCIsXG5cdFwiSE9UXCI6IFwi0JDQutGC0YPQsNC70YzQvdC+0LVcIixcblx0XCJORVdcIjogXCLQndC+0LLQvtC1XCIsXG5cdFwiUFJPTU9URURcIjogXCLQn9GA0L7QtNCy0LjQs9Cw0LXQvNC+0LVcIixcblx0XCJWT1RFU1wiOiBcItCT0L7Qu9C+0YHQvtCyXCIsXG5cdFwiUEFZT1VUXCI6IFwi0JLRi9C/0LvQsNGC0LBcIixcblx0XCJDT01NRU5UU1wiOiBcItCa0L7QvNC80LXQvdGC0LDRgNC40LXQslwiLFxuXHRcIlRSRU5ESU5HXzMwXCI6IFwi0JvRg9GH0YjQtdC1INC30LAgMzAg0LTQvdC10LlcIixcblx0XCJTT1JUX1BPU1RfQllcIjogXCLQodC+0YDRgtC40YDQvtCy0LDRgtGMINC/0L7RgdGC0Ysg0L/QvjpcIixcblx0XCJQQVlPVVRfQ1lDTEVcIjogXCLQn9C10YDQuNC+0LQg0LLRi9C/0LvQsNGCXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcItCf0L7RgtC10L3RhtC40LDQu9GM0L3QsNGPINCy0YvQv9C70LDRgtCwXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLQn9C+0YHQu9C10LTQvdGP0Y8g0LLRi9C/0LvQsNGC0LBcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwi0JDQstGC0L7RgNGB0LrQsNGPINCy0YvQv9C70LDRgtCwXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwi0JrRg9GA0LDRgtC+0YDRgdC60LDRjyDQstGL0L/Qu9Cw0YLQsFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi0J/QvtGB0YIg0L7Qv9GD0LHQu9C40LrQvtCy0LDQvSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwi0J/QvtGB0YIg0LTQu9GPINC+0YLRgdGA0L7Rh9C10L3QvdC+0Lkg0L/Rg9Cx0LvQuNC60LDRhtC40LghXCIsXG5cdFwiU0FWRURcIjogXCLQodC+0YXRgNCw0L3QtdC9XCIsXG5cdFwiQ0xFQVJFRFwiOiBcItCe0YfQuNGJ0LXQvVwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCLQodGC0LDQstGPINGE0LvQsNCzINC/0L7RgdGC0YMsINCS0Ysg0LzQvtC20LXRgtC1INGD0LzQtdC90YzRiNC40YLRjCDQvdCw0LPRgNCw0LTRgyDQuCDRgdC00LXQu9Cw0YLRjCDRjdGC0L7RgiDQvNCw0YLQtdGA0LjQsNC7INC80LXQvdC10LUg0LfQsNC80LXRgtC90YvQvC48YnI+PGJyPtCk0LvQsNCzINC00L7Qu9C20LXQvSDQsdGL0YLRjCDQuNGB0L/QvtC70YzQt9C+0LLQsNC9INCyINGB0LvQtdC00YPRjtGJ0LjRhSDRgdC70YPRh9Cw0Y/RhTogPHVsPjxsaT7QnNC+0YjQtdC90L3QuNGH0LXRgdGC0LLQviDQuNC70Lgg0J/Qu9Cw0LPQuNCw0YI8L2xpPjxsaT7QkdGA0LDQvdGMINC40LvQuCDQmNC90YLQtdGA0L3QtdGCINCi0YDQvtC70LvQuNC90LM8L2xpPjxsaT7Qn9GA0LXQtNC90LDQvNC10YDQtdC90L3QvtC1INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC1INC90LXRgdC+0L7RgtCy0LXRgNGB0YLQstGD0Y7RidC10Lkg0LrQsNGC0LXQs9C+0YDQuNC4INC40LvQuCDQodC/0LDQvDwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCLQn9GA0LXQstGL0YjQtdC90L4g0LrQvtC70LjRh9C10YHRgtCy0L4g0LfQsNC/0YDQvtGB0L7Qsi4g0J/RgNC+0LLQtdGA0YzRgtC1INC00YDRg9Cz0LjQtSDRgtGA0LXQvdC00Ysv0YLQtdCz0LghXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi0J/QvtGB0YIg0YPQtNCw0LvQtdC9INC40Lcg0LfQsNC60LvQsNC00L7QuiFcIixcblx0XCJQT1NUX0lTX0JPT0tNQVJLXCI6IFwi0J/QvtGB0YIg0LTQvtCx0LDQstC70LXQvSDQsiDQt9Cw0LrQu9Cw0LTQutC4IVwiLFxuXHRcIlJFU0VUXCI6IFwi0KHQsdGA0L7RgdC40YLRjFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi0JjQt9C80LXQvdC40YLRjCDQuNC30L7QsdGA0LDQttC10L3QuNC1INC/0YDQvtGE0LjQu9GPXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCLQmNC30LzQtdC90LjRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LUg0L7QsdC70L7QttC60LhcIixcblx0XCJBQ1RJVkVfS0VZX1JFUVVJUkVEX1RFWFRcIjogXCLQn9C+0LbQsNC70YPQudGB0YLQsCwg0L/RgNC10LTQvtGB0YLQsNCy0YzRgtC1INCQ0LrRgtC40LLQvdGL0Lkg0LfQsNC60YDRi9GC0YvQuSDQutC70Y7Rhywg0LXRgdC70Lgg0JLRiyDQstGL0LHRgNCw0LvQuCDRgNCw0YHRiNC40YDQtdC90L3Ri9C5INGA0LXQttC40Lwg0LDQstGC0L7RgNC40LfQsNGG0LjQuCFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCLQrdGC0L4g0L/RgNC40LLQtdC00LXRgiDQuiDRgdCx0YDQvtGB0YMg0LjQt9C+0LHRgNCw0LbQtdC90LjRjyDQktCw0YjQtdCz0L4g0L/RgNC+0YTQuNC70Y9cIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCLQrdGC0L4g0L/RgNC40LLQtdC00LXRgiDQuiDRgdCx0YDQvtGB0YMg0LjQt9C+0LHRgNCw0LbQtdC90LjRjyDQktCw0YjQtdC5INC+0LHQu9C+0LbQutC4XCIsXG5cdFwiVVBEQVRFX1JFUVVJUkVTX1JFU1RBUlRcIjogXCLQntCx0L3QvtCy0LvQtdC90LjQtSDRgdC10YDQstC10YDQsCDRgtGA0LXQsdGD0LXRgiDQv9C10YDQtdC30LDQs9GA0YPQt9C60LghXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcItCd0LDRgdGC0YDQvtC50LrQuCDQvtCx0L3QvtCy0LvQtdC90YshXCIsXG5cdFwiTEFOR1VBR0VTXCI6IFwi0K/Qt9GL0LrQuFwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi0JfQtNC10YHRjCDQstGLINC80L7QttC10YLQtSDQuNC30LzQtdC90LjRgtGMINGP0LfRi9C6INC/0YDQuNC70L7QttC10L3QuNGPLlwiLFxuXHRcIkxPR0lOX1RPX1hcIjogXCLQrdGC0LAg0L7Qv9C10YDQsNGG0LjRjyDRgtGA0LXQsdGD0LXRgiDQsNCy0YLQvtGA0LjQt9Cw0YbQuNC4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQsiDRgdC40YHRgtC10LzQtSDRgSDQv9Cw0YDQvtC70LXQvCwg0LDQutGC0LjQstC90YvQvC/Qv9C+0YHRgtC40L3QsyDQutC70Y7Rh9C+0LwuINCf0L7QttCw0LvRg9C50YHRgtCwLCDQsNCy0YLQvtGA0LjQt9GD0LnRgtC10YHRjCDQuCDQv9C+0LLRgtC+0YDQuNGC0LUg0L/QvtC/0YvRgtC60YMuXCIsXG5cdFwiR0FMTEVSWVwiOiBcItCT0LDQu9C10YDQtdGPXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi0JDQstGC0L7RgNGLINC/0LXRgNC10LLQvtC00LBcIixcblx0XCJTSEFSRVwiOiBcItCf0L7QtNC10LvQuNGC0YzRgdGPXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLQoNGL0L3QvtC6XCIsXG5cdFwiRVhDSEFOR0VcIjogXCLQkdC40YDQttCwXCIsXG5cdFwiRFJBRlRTXCI6IFwi0KfQtdGA0L3QvtCy0LjQutC4XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi0J/QvtGB0YIg0YPQtNCw0LvQtdC9INC40Lcg0YfQtdGA0L3QvtCy0LjQutC+0LIhXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcItCf0L7RgdGCINC00L7QsdCw0LLQu9C10L0g0LIg0YfQtdGA0L3QvtCy0LjQutC4IVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLQn9GA0L7QstC10LTQuNGC0LUg0L/QsNC70YzRhtC10Lwg0LLQu9C10LLQviDRh9GC0L7QsdGLINGD0LLQuNC00LXRgtGMINCy0LDRgNC40LDQvdGC0YtcIixcblx0XCJNQU5BR0VcIjogXCLQo9C/0YDQsNCy0LvQtdC90LjQtVwiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLQmNC30L7QsdGA0LDQttC10L3QuNC1INGD0LTQsNC70LXQvdC+XCIsXG5cdFwiQ09QWVwiOiBcItCa0L7Qv9C40YDQvtCy0LDRgtGMXCIsXG5cdFwiTk9fSU1BR0VcIjogXCLQktGLINC10YnQtSDQvdC1INC30LDQs9GA0YPQt9C40LvQuCDQvdC4INC+0LTQvdC+0LPQviDQuNC30L7QsdGA0LDQttC10L3QuNGPIVwiLFxuXHRcIlBVTExfRE9XTl9UT19SRUZSRVNIXCI6IFwi0J/QvtGC0Y/QvdC40YLQtSDQstC90LjQtywg0YfRgtC+0LHRiyDQvtCx0L3QvtCy0LjRgtGMXCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcItCS0L3QtdGI0L3QuNC1INC/0YDQuNC70L7QttC10L3QuNGPXCIsXG5cdFwiUExVR0lOU1wiOiBcItCf0LvQsNCz0LjQvdGLXCIsXG5cdFwiU1VHR0VTVFwiOiBcItCf0YDQtdC00LvQvtC20LjRgtGMXCIsXG5cdFwiQ09NSU5HX1NPT05cIjogXCLQodC60L7RgNC+XCIsXG5cdFwiQ0hBSU5cIjogXCLQkdC70L7QutGH0LXQudC9XCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcItCX0LTQtdGB0Ywg0LLRiyDQvNC+0LbQtdGC0LUg0LjQt9C80LXQvdC40YLRjCDQv9C70LDRgtGE0L7RgNC80YMg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4gKNCx0LvQvtC60YfQtdC50L0pLlwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi0JLQsNC70Y7RgtCwXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcItCX0LTQtdGB0Ywg0JLRiyDQvNC+0LbQtdGC0LUg0LjQt9C80LXQvdC40YLRjCDQstCw0LvRjtGC0YMg0L/QviDRg9C80L7Qu9GH0LDQvdC40Y4uINCd0LDQs9GA0LDQtNCwINC30LAg0L/QvtGB0YIv0LrQvtC80LzQtdC90YLQsNGA0LjQuSDQsdGD0LTQtdGCINC+0YLQvtCx0YDQsNC20LDRgtGM0YHRjyDQsiDRjdGC0L7QuSDQstCw0LvRjtGC0LUuXCIsXG5cdFwiQUJPVVRfMTFcIjogXCI8YnI+PGI+0J/QtdGA0LXRh9C10L3RjCDQstC+0LfQvNC+0LbQvdC+0YHRgtC10Lk8L2I+PGJyPi0g0J/QvtC70YPRh9C40YLQtSDQtNC+0YHRgtGD0L8g0Log0YPQvdC40LrQsNC70YzQvdGL0Lwg0YHRgtCw0YLRjNGP0Lwg0L3QsCDQu9GO0LHRg9GOINC40L3RgtC10YDQtdGB0L3Rg9GOINCS0LDQvCDRgtC10LzRgzs8YnI+LSDQktC30LDQuNC80L7QtNC10LnRgdGC0LLRg9C50YLQtSDRgSDQsNCy0YLQvtGA0LDQvNC4LCDQutC+0LzQvNC10L3RgtC40YDRg9GPINC4INGD0YfQsNGB0YLQstGD0Y8g0LIg0LTQuNGB0LrRg9GB0YHQuNGP0YU7PGJyPi0g0JPQvtC70L7RgdGD0LnRgtC1INC30LAg0L/QvtGB0YLRiywg0YfRgtC+0LHRiyDQstC+0LfQvdCw0LPRgNCw0LTQuNGC0Ywg0LDQstGC0L7RgNCwLCDQsCDRgtCw0LrQttC1INC/0L7Qu9GD0YfQuNGC0Ywg0LrRg9GA0LDRgtC+0YDRgdC60L7QtSDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNC1Ozxicj4tINCf0YPQsdC70LjQutGD0LnRgtC1INGB0LLQvtC4INC/0L7RgdGC0Ysg0Lgg0LHQtdGB0L/Qu9Cw0YLQvdC+INGA0LDQt9C80LXRidCw0LnRgtC1INC40YUsINGH0YLQvtCx0Ysg0L/RgNC40LLQu9C10YfRjCDRhNC+0LvQu9C+0LLQtdGA0L7QsiDQuCDQv9C+0LvRg9GH0LjRgtGMINCy0L7Qt9C90LDQs9GA0LDQttC00LXQvdC40Y87PGJyPi0g0J/QuNGI0LjRgtC1INGB0YLQsNGC0YzQuCDQsiDQv9GD0YLQuCwg0YHQvtGF0YDQsNC90Y/QudGC0LUg0L3QtdGB0LrQvtC70YzQutC+INGH0LXRgNC90L7QstC40LrQvtCyINC/0L7RgdGC0LAg0Lgg0L/Rg9Cx0LvQuNC60YPQudGC0LUg0LjRhSwg0LrQvtCz0LTQsCDQktCw0Lwg0YPQtNC+0LHQvdC+Ozxicj4tINCU0L7QsdCw0LLQu9GP0LnRgtC1INC/0L7QvdGA0LDQstC40LLRiNC40LXRgdGPINGB0YLQsNGC0YzQuCDQsiDQt9Cw0LrQu9Cw0LTQutC4LCDRh9GC0L7QsdGLINCy0LXRgNC90YPRgtGM0YHRjyDQuiDQvdC40Lwg0L/QvtC30LbQtTs8YnI+LSDQntCx0LzQtdC90LjQstCw0LnRgtC1INC40LvQuCDQvtCx0L3QsNC70LjRh9C40LLQsNC50YLQtSDQktCw0YjQuCDQstC+0LfQvdCw0LPRgNCw0LbQtNC10L3QuNGPOzxicj4tINCf0L7RgdGL0LvQsNC50YLQtSDRgdGA0LXQtNGB0YLQstCwINC70Y7QsdGL0Lwg0LDQstGC0L7RgNCw0LwsINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C8LCDQtNGA0YPQt9GM0Y/QvCwg0YTQvtC70LvQvtCy0LXRgNCw0Lwg0Lgg0YIu0LQuOzxicj4tINCf0L7QtNC/0LjRgdGL0LLQsNC50YLQtdGB0Ywg0L3QsCDQuNC90YLQtdGA0LXRgdC90YvRhSDQsNCy0YLQvtGA0L7QsiDQuCDQsdC70L7Qs9Cz0LXRgNC+0LI7PGJyPi0g0J/QvtC70YzQt9GD0LnRgtC10YHRjCDRg9C00L7QsdC90YvQvCDQv9C+0LjRgdC60L7QvCDQv9C+INGE0L7Qu9C70L7QstC10YDQsNC8INC40LvQuCDQsNCy0YLQvtGA0LDQvCwg0L3QsCDQutC+0YLQvtGA0YvRhSDQktGLINC/0L7QtNC/0LjRgdCw0L3Rizs8YnI+LSDQn9C+0LvRg9GH0LDQudGC0LUg0YPQstC10LTQvtC80LvQtdC90LjRjyAtINC+0YHRgtCw0LLQsNC50YLQtdGB0Ywg0L3QsCDRgdCy0Y/Qt9C4INGBINCS0LDRiNC40LzQuCDRhNC+0LvQu9C+0LLQtdGA0LDQvNC4INC4INC90LDQsdC70Y7QtNCw0LnRgtC1INC30LAg0YDQsNC30LLQuNGC0LjQtdC8INC00LjRgdC60YPRgdGB0LjQuSwg0LIg0LrQvtGC0L7RgNGL0YUg0YPRh9Cw0YHRgtCy0YPQtdGC0LU7PGJyPi0g0J3QsNGF0L7QtNC40YLQtSDQvdC+0LLRi9GFINC40L3RgtC10YDQtdGB0L3Ri9GFINCw0LLRgtC+0YDQvtCyINC4INGB0YLQsNGC0YzQuCwg0LjRgdC/0L7Qu9GM0LfRg9GPINC/0L7QuNGB0Log0L/QviDRgtC10LPQsNC8L9C60LDRgtC10LPQvtGA0LjRj9C8Ozxicj4tINCf0LXRgNGB0L7QvdCw0LvQuNC30LjRgNGD0LnRgtC1INGB0YLRgNCw0L3QuNGG0YMg0YHQstC+0LXQs9C+INC/0YDQvtGE0LjQu9GPOzxicj4tINCd0LUg0L/RgNC+0L/Rg9GB0LrQsNC50YLQtSDQvtCx0L3QvtCy0LvQtdC90LjRjyAtINCyINC90LjRhSDQktGLINC90LDQudC00LXRgtC1INC10YnQtSDQsdC+0LvRjNGI0LUg0L3QvtCy0YvRhSDRhNGD0L3QutGG0LjQuSE8YnI+PGJyPjxiPtCR0LXQt9C+0L/QsNGB0L3QvtGB0YLRjDwvYj48YnI+MS4g0J/RgNC40LvQvtC20LXQvdC40LUg0L3QtSDQuNC80LXQtdGCINC00L7RgdGC0YPQv9CwINC40LvQuCDQv9GA0LDQstCwINGA0LDRgdC/0L7RgNGP0LbQsNGC0YzRgdGPINGB0YDQtdC00YHRgtCy0LDQvNC4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjzs8YnI+Mi4g0J/RgNC40LvQvtC20LXQvdC40LUg0L/RgNC10LTQu9Cw0LPQsNC10YIg0LzQvtC00LXQu9GMINCx0LXQt9C+0L/QsNGB0L3QvtGB0YLQuCDQvdCwINGB0YLQvtGA0L7QvdC1INC60LvQuNC10L3RgtCwLCDQs9C00LUg0L/RgNC40LLQsNGC0L3Ri9C1INC60LvRjtGH0Lgg0YXRgNCw0L3Rj9GC0YHRjyDQu9C+0LrQsNC70YzQvdC+INC4INC90LjQutC+0LPQtNCwINC90LUg0L7RgtC/0YDQsNCy0LvRj9GO0YLRgdGPINC90Lgg0L3QsCDQutCw0LrQuNC1INGB0LXRgNCy0LXRgNCwIC0g0YLQvtC70YzQutC+INCS0Ysg0L7RgtCy0LXRgtGB0YLQstC10L3QvdGLINC30LAg0YXRgNCw0L3QtdC90LjQtSDRgdCy0L7QuNGFINC/0LDRgNC+0LvQtdC5Ozxicj4zLiDQn9GA0LjQu9C+0LbQtdC90LjQtSDQvtCx0LvQsNC00LDQtdGCINC/0YDQvtGB0YLRi9C8INC/0YDQuNCy0LvQtdC60LDRgtC10LvRjNC90YvQvCDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQvCDQuNC90YLQtdGA0YTQtdC50YHQvtC8LCDRh9GC0L4g0L/QvtC00LDRgNC40YIg0JLQsNC8INC/0L7Qu9C+0LbQuNGC0LXQu9GM0L3Ri9C5INC+0L/Ri9GCINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNGPOzxicj40LiDQkiDQv9GA0LjQu9C+0LbQtdC90LjQuCDQv9GA0LXQtNGD0YHQvNC+0YLRgNC10L0g0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90YvQuSDRg9GA0L7QstC10L3RjCDQsdC10LfQvtC/0LDRgdC90L7RgdGC0Lgg0LIg0LLQuNC00LUg0L/QuNC9LdC60L7QtNCwLjxicj48YnI+ZVN0ZWVtINC/0L7QtNC00LXRgNC20LjQstCw0LXRgiDQv9C70LDRgtGE0L7RgNC80YsgU3RlZW0g0LggR29sb3MuPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLQntGB0L3QvtCy0LDRgtC10LvRjCDQuCDQstC10LTRg9GJ0LjQuSDRgNCw0LfRgNCw0LHQvtGC0YfQuNC6XCIsXG5cdFwiQUREX0FDQ09VTlRcIjogXCLQlNC+0LHQsNCy0LjRgtGMINCw0LrQutCw0YPQvdGCXCIsXG5cdFwiUExBVEZPUk1cIjogXCLQn9C70LDRgtGE0L7RgNC80LBcIixcblx0XCJFU0NST1dcIjogXCLQk9Cw0YDQsNC90YJcIixcblx0XCJFU0NST1dfQUdFTlRcIjogXCLQk9Cw0YDQsNC90YJcIixcblx0XCJSQVRJRklDQVRJT05fREVBRExJTkVcIjogXCLQodGA0L7QuiDRgNCw0YLQuNGE0LjQutCw0YbQuNC4INGB0LTQtdC70LrQuFwiLFxuXHRcIkVTQ1JPV19FWFBJUkFUSU9OXCI6IFwi0KHRgNC+0Log0LTQtdC50YHRgtCy0LjRjyDRgdC00LXQu9C60LhcIixcblx0XCJFU0NST1dfRkVFXCI6IFwi0JrQvtC80LjRgdGB0LjRjyDQs9Cw0YDQsNC90YLQsFwiLFxuXHRcIkVTQ1JPV19URVJNU1wiOiBcItCj0YHQu9C+0LLQuNGPINGB0LTQtdC70LrQuFwiLFxuXHRcIk5JR0hUX01PREVcIjogXCLQndC+0YfQvdC+0Lkg0YDQtdC20LjQvFwiLFxuXHRcIkRBWV9NT0RFXCI6IFwi0JTQvdC10LLQvdC+0Lkg0YDQtdC20LjQvFwiLFxuXHRcIlZJRVdfQ09OVEVYVFwiOiBcItCf0YDQvtGB0LzQvtGC0YAg0L/QvtC70L3QvtCz0L4g0LrQvtC90YLQtdC60YHRgtCwXCIsXG5cdFwiVVNFUl9OT1RGT1VORFwiOiBcItCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCDQvdC1INC90LDQudC00LXQvVwiLFxuXHRcIkFQUFJPVkVcIjogXCLQntC00L7QsdGA0LjRgtGMXCIsXG5cdFwiRElTUFVURVwiOiBcItCe0YHQv9C+0YDQuNGC0YxcIixcblx0XCJSRUxFQVNFXCI6IFwi0J7RgdCy0L7QsdC+0LTQuNGC0YxcIixcblx0XCJGUk9NXCI6IFwi0J7RglwiLFxuXHRcIklEXCI6IFwi0LjQtFwiLFxuXHRcIlNVQk1JVFwiOiBcItCe0YLQv9GA0LDQstC40YLRjFwiLFxuXHRcIlJFQ0VJVkVSXCI6IFwi0J/QvtC70YPRh9Cw0YLQtdC70YxcIixcblx0XCJMT0NBVElPTlwiOiBcItCc0LXRgdGC0L7Qv9C+0LvQvtC20LXQvdC40LVcIixcblx0XCJXRUJTSVRFXCI6IFwi0JLQtdCxLdGB0LDQudGCXCIsXG5cdFwiRElTUExBWV9OQU1FXCI6IFwi0J7RgtC+0LHRgNCw0LbQsNC10LzQvtC1INC40LzRj1wiXG59IiwibW9kdWxlLmV4cG9ydHM9e1xuXHRcIkhPTUVcIjogXCJIZW1cIixcblx0XCJMT0dJTlwiOiBcIkxvZ2dhIGluXCIsXG5cdFwiTE9HT1VUXCI6IFwiTG9nZ2EgdXRcIixcblx0XCJQUk9GSUxFXCI6IFwiUHJvZmlsXCIsXG5cdFwiRk9MTE9XXCI6IFwiRsO2bGpcIixcblx0XCJCT09LTUFSS1NcIjogXCJCb2ttw6Rya2VuXCIsXG5cdFwiVFJBTlNGRVJcIjogXCLDlnZlcmbDtnJpbmdcIixcblx0XCJNQVJLRVRcIjogXCJNYXJrbmFkXCIsXG5cdFwiU0VUVElOR1NcIjogXCJJbnN0w6RsbG5pbmdhclwiLFxuXHRcIkFCT1VUXCI6IFwiT21cIixcblx0XCJBQk9VVF8xXCI6IFwiZMOkciB2ZW0gc29tIGhlbHN0IGthbiBiZWzDtm5hcyBmw7ZyIHNpdHQgbWF0ZXJpYWwhXCIsXG5cdFwiQUJPVVRfMlwiOiBcIsOkciBlbiBzb2NpYWwgbWVkaWFwbGF0Zm9ybSBkw6RyIGR1IGJldGFsYXMgZsO2ciBhdHQgYmxvZ2dhLCBrb21tZW50ZXJhIG9jaCBrdXJyZXJhIGlubMOkZ2cuXCIsXG5cdFwiQUJPVVRfM1wiOiBcIm9jaCDDpHIgZXR0IGNvbW11bml0eS1kcml2ZXQgcHJvamVrdCBmw7ZyIG1vYmlsZW4gc29tIGJhc2VyYXMgcMOlIMO2cHBlbiBrw6RsbGtvZC4gRGVuIGdlciBnZXIgZGlnIHRpbGxnw6VuZyBzw6UgYXR0IGR1IGthbiBsw6RzYSBpbm5laMOlbGwsIGtvbW1lbnRlcmEsIHLDtnN0YSwgc2thcGEgaW5sw6RnZyBvY2ggZsO2cmEgw7Z2ZXIgYmVsw7ZuaW5nYXIsIG9jaCBkaXZlcnNlIGFuZHJhIGZ1bmt0aW9uZXIgc29tIGfDtnJzIG3DtmpsaWdhIGF2IHt7cGxhdGZvcm1uYW1lfX0gYmxvY2sta2VkamEgb2NoIHt7c2l0ZW5hbWV9fS5cIixcblx0XCJBQk9VVF80XCI6IFwiQXBwZW4gaGFyIGFsZHJpZyB0aWxsZ8OlbmcgdGlsbCBhbnbDpG5kYXJlbnMgcGVuZ2FyLlwiLFxuXHRcIkFCT1VUXzVcIjogXCJBcHBlbiBlcmJqdWRlciBlbiBrbGllbnRjZW50cmVyYWQgc8Oka2VyaGV0c21vZGVsbCwgZHZzLiBkaW5hIHByaXZhdGEgbnlja2xhciBzdGFubmFyIGxva2FsdCBvY2ggc2tpY2thcyBpbnRlIHRpbGwgYW5kcmEgc2VydnJhci5cIixcblx0XCJBQk9VVF82XCI6IFwiQXBwZW4gZXJianVkZXIgZXR0IGVua2VsdCBvY2ggYXR0cmFrdGl2dCBhbnbDpG5kZXJncsOkbnNzbml0dCwgdmlsa2V0IGdlciBlbiBnb2QgYW52w6RuZGFydXBwbGV2ZWxzZS5cIixcblx0XCJBQk9VVF83XCI6IFwiQXBwZW4ga3LDpHZlciBhbGRyaWcgYXR0IGFudsOkbmRhcmVuIG1hdGFyIGluIHBlcnNvbmxpZyBpbmZvcm1hdGlvbi5cIixcblx0XCJBQk9VVF84XCI6IFwiUsO2c3RhIHDDpSBnb29kLWthcm1hIHNvbSB2aXR0bmVcIixcblx0XCJBQk9VVF85XCI6IFwiS29udGFrdC/DhXRlcmtvcHBsaW5nXCIsXG5cdFwiQUJPVVRfMTBcIjogXCJNZXJhIGluZm9ybWF0aW9uOlwiLFxuXHRcIlJFTU9WRVwiOiBcIlRhIGJvcnRcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIk1hcmtuYWRzdnlcIixcblx0XCJQUklDRVwiOiBcIlByaXNcIixcblx0XCJBTU9VTlRcIjogXCJNw6RuZ2RcIixcblx0XCJUT1RBTFwiOiBcIlN1bW1hXCIsXG5cdFwiTk9PUkRFUlNcIjogXCJJbmdhIGFrdGl2YSBvcmRyYXIgZsO2clwiLFxuXHRcIkRBVEVcIjogXCJEYXR1bVwiLFxuXHRcIkJVWVwiOiBcIkvDtnBcIixcblx0XCJTRUxMXCI6IFwiU8OkbGpcIixcblx0XCJPUEVOXCI6IFwiw5ZwcGVuXCIsXG5cdFwiSElTVE9SWVwiOiBcIkhpc3RvcmlrXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCJGw7ZsaiB0aWxsYmFrYVwiLFxuXHRcIkZPTExPV0VEXCI6IFwiRsO2bGplclwiLFxuXHRcIlVORk9MTE9XXCI6IFwiU2x1dGEgZsO2bGphXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwiRsO2bGplclwiLFxuXHRcIkZPTExPV0VSU1wiOiBcIkbDtmxqYXJlXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIlPDtmsgYmxhbmQgZsO2bGphcmVcIixcblx0XCJTRUFSQ0hfRk9MTE9XSU5HXCI6IFwiU8O2ayBibGFuZCBkZSBkdSBmw7ZsamVyXCIsXG5cdFwiQllcIjogXCJhdlwiLFxuXHRcIklOXCI6IFwiaVwiLFxuXHRcIk1FTlVcIjogXCJNZW55XCIsXG5cdFwiQk9PS01BUktcIjogXCJCb2ttw6Rya1wiLFxuXHRcIlJFQkxPR1wiOiBcIsOFdGVyYmxvZ2dhXCIsXG5cdFwiVVBWT1RFXCI6IFwiUsO2c3RhIHVwcFwiLFxuXHRcIkRPV05WT1RFXCI6IFwiUsO2c3RhIG5lclwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLDhW5ncmEgcsO2c3RhIG5lclwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwiw4VuZ3JhIHLDtnN0YSB1cHBcIixcblx0XCJSRVBMWVwiOiBcIlN2YXJhXCIsXG5cdFwiRURJVFwiOiBcIlJlZGlnZXJhXCIsXG5cdFwiUE9TVF8xXCI6IFwiU3ZlcCDDpXQgdsOkbnN0ZXIgw7Z2ZXIga29tbWVudGFyZXIgZsO2ciBhdHQgc2UgYWx0ZXJuYXRpdlwiLFxuXHRcIlBPU1RfMlwiOiBcIkR1dHRhIHDDpSBrb21tZW50YXJlciBmw7ZyIGF0dCBzZSB1bmRlcmtvbW1lbnRhcmVyXCIsXG5cdFwiT1BUSU9OU1wiOiBcIkFsdGVybmF0aXZcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLDhXRlcnN0ZWVtYWRlcyBhdlwiLFxuXHRcIk5PVEhJTkdfSEVSRVwiOiBcIlRvbXQgw6RuIHPDpSBsw6RuZ2UuLi5cIixcblx0XCJCQUxBTkNFU1wiOiBcIlNhbGRvblwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcIlN0ZWVtLCB1dGJ5dHNiYXJhIHBvbGxldHRlciBzb20gZ8OlciBhdHQgw7Z2ZXJmw7ZyYSBuw6RyIHNvbSBoZWxzdC4gU3RlZW0ga2FuIG9tdmFuZGxhcyB0aWxsIFN0ZWVtUG93ZXIgaSBlbiBwcm9jZXNzIHNvbSBrYWxsYXMgYXR0IMO2a2EgcsO2c3RlZmZla3QgZWxsZXIgXFxcIsOlbmdhIHVwcFxcXCIuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwiU3RlZW1Qb3dlciwgaW5mbHl0YW5kZXBvbGxldHRlciBzb20gZ2VyIGjDtmdyZSByw7ZzdGVmZmVrdCBmw7ZyIGF0dCBkdSBzcGFyYXIgZGVtIGzDpW5nc2lrdGlndCBvY2ggcsO2c3RhciBww6UgaW5sw6RnZy4gSnUgbWVyIGR1IGhhciwgZGVzdG8gbWVyIGthbiBkdSBww6V2ZXJrYSBhbmRyYXMgYmVsw7ZuaW5nYXIgb2NoIGJlbMO2bmFzIGbDtnIgc21hcnQgcsO2c3RuaW5nLlwiLFxuXHRcIlBST0ZJTEVfM1wiOiBcIlBvbGxldHRlciB2w6RyZGEgdW5nZWbDpHIge3twbGF0Zm9ybXN1bml0fX0gYXYge3twbGF0Zm9ybW5hbWV9LlwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIlVwcHNrYXR0YXQgdsOkcmRlXCIsXG5cdFwiUFJPRklMRV80XCI6IFwiRGV0IHVwcHNrYXR0YWRlIHbDpHJkZXQgw6RyIGJhc2VyYXQgcMOlIGV0dCA3IGRhZ2FycyBnZW5vbXNuaXR0bGlnIHbDpHJkZSBhdiB7e3BsYXRmb3JtbmFtZX0uXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIlRyYW5zYWt0aW9uc2hpc3RvcmlrXCIsXG5cdFwiUE9TVElOR1wiOiBcIklubMOkZ2dcIixcblx0XCJQUk9GSUxFXzVcIjogXCJJbmzDpGdnc255Y2tlbG4gYW52w6RuZHMgZsO2ciBhdHQgc2tyaXZhIGlubMOkZ2cgb2NoIHLDtnN0YS4gRGVuIGLDtnIgdmFyYSBvbGlrIGFsbG3DpG5ueWNrZWxuIG9jaCBodXZ1ZG55Y2tlbG4uXCIsXG5cdFwiT1dORVJcIjogXCLDhGdhcmVcIixcblx0XCJQUk9GSUxFXzZcIjogXCLDhGdhcm55Y2tlbG4gw6RyIGh1dnVkbnlja2VsbiBmw7ZyIGtvbnRvdCBvY2ggYmVow7Z2cyBmw7ZyIGF0dCBrdW5uYSBieXRhIGRlIGFuZHJhIG55Y2tsYXJuYS4gRsO2ciBhdHQgw7ZrYSBzw6RrZXJoZXRlbiBiw7ZyIGRlbiBcXFwicHJpdmF0YSBueWNrZWxuXFxcIiBlbGxlciBsw7ZzZW5vcmRldCB0aWxsIGh1dnVkbnlja2VsbiBhbnbDpG5kYXMgc8OlIGxpdGUgc29tIG3DtmpsaWd0LlwiLFxuXHRcIkFDVElWRVwiOiBcIlLDtnJlbHNlXCIsXG5cdFwiUFJPRklMRV83XCI6IFwiQWxsbcOkbm55Y2tlbG4gYW52w6RuZHMgZsO2ciBhdHQgZ8O2cmEgw7Z2ZXJmw7ZyaW5nYXIgb2NoIGF0dCBsw6RnZ2Egb3JkcmFyIGkgZGVuIGludGVybmEgbWFya25hZGVuLlwiLFxuXHRcIk1FTU9cIjogXCJBbnRlY2tuaW5nXCIsXG5cdFwiUFJPRklMRV84XCI6IFwiQW50ZWNrbmluZ3NueWNrZWxuIGFudsOkbmRzIGbDtnIgYXR0IHNrYXBhIG9jaCBsw6RzYSBhbnRlY2tuaW5nYXIuXCIsXG5cdFwiQkxPR1wiOiBcIkJsb2dnXCIsXG5cdFwiUE9TVFNcIjogXCJJbmzDpGdnXCIsXG5cdFwiUkVQTElFU1wiOiBcIlN2YXJcIixcblx0XCJXQUxMRVRcIjogXCJQbMOlbmJva1wiLFxuXHRcIlRBR1wiOiBcIsOEbW5lXCIsXG5cdFwiVVNFUlwiOiBcIkFudsOkbmRhcmVcIixcblx0XCJDTE9TRVwiOiBcIlN0w6RuZ1wiLFxuXHRcIlRPXCI6IFwiVGlsbFwiLFxuXHRcIkFTU0VUXCI6IFwiVGlsbGfDpW5nXCIsXG5cdFwiU0VORFwiOiBcIlNraWNrYVwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwiU8Oka2VyaGV0XCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwiVGlsbGfDpG5nbGlnXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCJPZmZlbnRsaWcgYW50ZWNrbmluZ1wiLFxuXHRcIlRPX0RFU0NcIjogXCJBbnbDpG5kYXJlIHQuZXguIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIlBpbmtvZFwiLFxuXHRcIlBJTl9URVhUXCI6IFwiUGlua29kZW4gaGrDpGxwZXIgZGlnIGF0dCBzw6RrcmEgYXBwZW4gb2NoIGRpbiBkYXRhLiBOw6RyIGRlbiBha3RpdmVyYXMgaGFyIGR1IG1heCA0IGbDtnJzw7ZrIGF0dCBsw6VzYSB1cHAgYXBwZW4uIE9tIGR1IGhhciBnbMO2bXQgZGVuIGVsbGVyIG1pc3NseWNrYXMga29tbWVyIGFwcGVuIGF0dCB0YSBib3J0IGlubG9nZ2FkIGFudsOkbmRhcmRhdGEuIER1IG3DpXN0ZSBkw6UgbG9nZ2EgaW4gcMOlIG55dHQgZsO2ciBhdHQgZm9ydHPDpHR0YSBhbnbDpG5kYSBhcHBlbi5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwiTWVkZGVsYW5kZW5cIixcblx0XCJWT1RFX1RFWFRcIjogXCJEdSBrb21tZXIgZsOlIGV0dCBtZWRkZWxhbmRlIG7DpHIgbsOlZ29uIHLDtnN0YXIgdXBwIGRpdHQgaW5sw6RnZy4gTWVkZGVsYW5kZW4gdGFsYXIgw6R2ZW4gb20gZGVuIHZhbGRhIHLDtnN0dmlrdGVuLiAob2F2c2V0dCB1cHByw7ZzdG5pbmcsIG5lZHLDtnN0bmluZywgYXYvb21yw7ZzdG5pbmcpLlwiLFxuXHRcIlZPVEVcIjogXCJSw7ZzdGFcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCJEdSBrb21tZXIgZsOlIGV0dCBtZWRkZWxhbmRlIG7DpHIgbsOlZ29uIGtvbW1lbnRlcmFyIHDDpSBkaXR0IGlubMOkZ2cgZWxsZXIga29tbWVudGFyLiBNZWRkZWxhbmRlbiBpbmtsdWRlcmFyIMOkdmVuIG7DpHIgbsOlZ29uIHJlZGlnZXJhciBzaW4ga29tbWVudGFyLlwiLFxuXHRcIkNPTU1FTlRcIjogXCJLb21tZW50YXJcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gZsO2bGplciBlbGxlciBzbHV0YXIgZsO2bGphIGRpZy5cIixcblx0XCJNRU5USU9OU1wiOiBcIk9tbsOkbW5hbmRlXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIkR1IGtvbW1lciBmw6UgZXR0IG1lZGRlbGFuZGUgbsOkciBuw6Vnb24gbsOkbW5hciBkaXR0IG5hbW4gaSBkZXJhcyBpbmzDpGdnL2tvbW1lbnRhciFcIixcblx0XCJSRVNURUVNXCI6IFwiw4V0ZXJibG9nZ2FcIixcblx0XCJSRVNURUVNX1RFWFRcIjogXCJEdSBrb21tZXIgZsOlIGV0dCBtZWRkZWxhbmRlIG7DpHIgbsOlZ29uIMOldGVyYmxvZ2dhciBkaXR0IGlubMOkZ2chXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCJJbnN0w6RsbG5pbmdhclwiLFxuXHRcIlZPVElOR1wiOiBcIlLDtnN0bmluZ1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwiUsO2c3RuaW5nc3Zpa3QgZWxsZXIgcHJvY2VudCBww6V2ZXJrYXIgcsO2c3RuaW5nc2tyYWZ0ZW4gcMOlIGFwcGVuIHPDpSBhdHQgZHUga2FuIHJlZ2xlcmEgaHVyIG15Y2tldCBkdSB2aWxsIGJlbMO2bmEgaW5sw6RnZy4gRGV0dGEgw6RuZHJhciBvY2tzw6UgcMOlIHLDtnN0bmluZ3N2aWt0ZW4vcHJvY2VudGVuIGbDtnIgbmVkcsO2c3RuaW5nYXIgb2NoIGfDpGxsZXIgw7Z2ZXJhbGx0IHDDpSBhcHBlbi5cIixcblx0XCJTRVJWRVJcIjogXCJTZXJ2ZXJcIixcblx0XCJTRVJWRVJfVEVYVFwiOiBcIlJla29tbWVuZGVyYXNcIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCJTcGFyYSDDpG5kcmluZ2FyXCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCJSw7ZzdGFyZW5zIGluZm9ybWF0aW9uXCIsXG5cdFwiV0VMQ09NRV9CQUNLXCI6IFwiVsOkbGtvbW1lbiB0aWxsYmFrYSFcIixcblx0XCJMT0dJTl8xXCI6IFwiTG9nZ2EgaW4gbWVkIGRpdHQgYW52w6RuZGFybmFtbiBvY2ggbMO2c2Vub3JkIGbDtnIgYXR0IGZvcnRzw6R0dGEuXCIsXG5cdFwiTE9HSU5fMlwiOiBcIklubMOkZ2dzbnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBnw7ZyYSBpbmzDpGdnLCBrb21tZW50ZXJhLCByw7ZzdCwgZsO2bGphLlwiLFxuXHRcIkxPR0lOXzNcIjogXCJBbGxtw6Rubnlja2VsbiBhbnbDpG5kcyBmw7ZyIGF0dCBnw7ZyYSDDtnZlcmbDtnJpbmdhciBvY2ggYXR0IHVwcGRhdGVyYSBwcm9maWxiaWxkLlwiLFxuXHRcIkxPR0lOXzRcIjogXCJBbnbDpG5kYXJ1cHBnaWZ0ZXIgbGFncmFzIGxva2FsdCBww6UgZW5oZXRlbi4gVmlkIHV0bG9nZ25pbmcgYXZsw6Rnc25hcyB1cHBnaWZ0ZXJuYSFcIixcblx0XCJET05UX0hBVkVcIjogXCJIYXIgZHUgaW5nZXQga29udG8/XCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCJSZWdpc3RyZXJhIGRpZyBudVwiLFxuXHRcIkNBTkNFTFwiOiBcIkF2YnJ5dFwiLFxuXHRcIkFEVkFOQ0VEXCI6IFwiQXZhbmNlcmF0IGzDpGdlXCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcIlByaXZhdCBhbGxtw6Rubnlja2VsXCIsXG5cdFwiUE9TVElOR19QUklLRVlcIjogXCJQcml2YXQgaW5sw6RnZ3NueWNrZWxcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcIsOEZ2FyZS9odXZ1ZGzDtnNlbm9yZFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwiQW52w6RuZGFybmFtblwiLFxuXHRcIkNBUkRfVklFV1wiOiBcIktvcnR2eVwiLFxuXHRcIkNPTVBBQ1RfVklFV1wiOiBcIktvbXBha3QgdnlcIixcblx0XCJTRUFSQ0hcIjogXCJTw7ZrXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCJHw7ZyIGV0dCBpbmzDpGdnXCIsXG5cdFwiUkVQTFlUT1wiOiBcIlN2YXJhXCIsXG5cdFwiUE9TVFwiOiBcIlNraWNrYVwiLFxuXHRcIlBSRVZJRVdcIjogXCJGw7ZyaGFuZHNncmFuc2thXCIsXG5cdFwiREVGQVVMVFwiOiBcIk5vcm1hbCA1MCUgLyA1MCVcIixcblx0XCJQT1dFUlVQXCI6IFwiw4VuZ2EgdXBwIDEwMCVcIixcblx0XCJERUNMSU5FX1BBWU9VVFwiOiBcIkF2c8OkZyBkaWcgYmVsw7ZuaW5nXCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCJTUEFSQSBUSUxMIFNFTkFSRVwiLFxuXHRcIkNMRUFSXCI6IFwiVMOWTVwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIlNrcml2IGlubMOkZ2dcIixcblx0XCJDT01NRU5UX0NPTlRFTlRcIjogXCJLb21tZW50ZXJhIG1hdGVyaWFsXCIsXG5cdFwiVElUTEVcIjogXCJUaXRlbFwiLFxuXHRcIlRBR1NcIjogXCLDhG1uZW5cIixcblx0XCJOT1RfTUFUQ0hcIjogXCJNQVRDSEFSIElOVEVcIixcblx0XCJDT05GSVJNX1BJTlwiOiBcIkJla3LDpGZ0YSBwaW5rb2RcIixcblx0XCJJTkNPUlJFQ1RcIjogXCJGRUxBS1RJR1wiLFxuXHRcIk9QRU5JTkdfUE9TVFwiOiBcIsO2cHBuYXIgaW5sw6RnZ1wiLFxuXHRcIlNFVF9QSU5cIjogXCJTdMOkbGwgaW4gcGlua29kXCIsXG5cdFwiRU5URVJfUElOXCI6IFwiQW5nZSBwaW5rb2RcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLDhHIgZHUgc8Oka2VyP1wiLFxuXHRcIlJFQkxPR19URVhUXCI6IFwiw4V0ZXJibG9nZ2FkZSBpbmzDpGdnIGthbiBpbnRlIMOlbmdyYXMsIHZpbGwgZHUgZm9ydHPDpHR0YT9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCJTw6RuZG5pbmdzZmVsLCBmw7Zyc8O2ayBpZ2VuIVwiLFxuXHRcIlNVQ0NFU1NcIjogXCJVdGbDtnJ0XCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLDhXRlcmJsb2dnYWRlIGlubMOkZ2chXCIsXG5cdFwiTE9HSU5fRkFJTFwiOiBcIklubG9nZ25pbmcgbWlzc2x5Y2thZGVzISBWYXIgZ29kIHPDpGtlcnN0w6RsbCBhdHQgZHUgbG9nZ2FyIGluIG1lZCBodXZ1ZGzDtnNlbm9yZCBlbGxlciBkaW4gcHJpdmF0YSBpbmzDpGdnc255Y2tlbCBvbSBkdSB2YWx0IFxcXCJBdmFuY2VyYXQgbMOkZ2VcXFwiLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcIklubG9nZ25pbmcgbWlzc2x5Y2thZGVzISBWYXIgZ29kIHPDpGtlcnN0w6RsbCBhdHQgZHUgbG9nZ2FyIGluIG1lZCBodXZ1ZGzDtnNlbm9yZCBlbGxlciBkaW4gcHJpdmF0YSByw7ZyZWxzZW55Y2tlbCBvbSBkdSB2YWx0IFxcXCJBdmFuY2VyYXQgbMOkZ2VcXFwiLlwiLFxuXHRcIldBUk5JTkdcIjogXCJWYXJuaW5nXCIsXG5cdFwiVk9URV9GT1JfV0lUTkVTU1wiOiBcIlLDtnN0YSBww6Ugdml0dG5lXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCJSw7ZzdGFkZSBww6Ugdml0dG5ldFwiLFxuXHRcIkFHT1wiOiBcInNlZGFuXCIsXG5cdFwiRlJPTV9OT1dcIjogXCJmcsOlbiBvY2ggbWVkIG51XCIsXG5cdFwiU0VDU1wiOiBcInNla1wiLFxuXHRcIkFfTUlOXCI6IFwiZW4gbWludXRcIixcblx0XCJNSU5TXCI6IFwibWluXCIsXG5cdFwiQU5fSE9VUlwiOiBcImVuIHRpbW1lXCIsXG5cdFwiSE9VUlNcIjogXCJ0aW1tYXJcIixcblx0XCJBX0RBWVwiOiBcImVuIGRhZ1wiLFxuXHRcIkRBWVNcIjogXCJkYWdhclwiLFxuXHRcIkFfTU9OVEhcIjogXCJlbiBtw6VuYWRcIixcblx0XCJNT05USFNcIjogXCJtw6VuYWRlclwiLFxuXHRcIkFfWUVBUlwiOiBcImV0dCDDpXJcIixcblx0XCJZRUFSU1wiOiBcIsOlclwiLFxuXHRcIk1JTl9SRUFEXCI6IFwibWluIGzDpHNuaW5nXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIlLDtnN0YSBOZXJcIixcblx0XCJDQVBUVVJFX1BJQ1RVUkVcIjogXCJUYSBGb3RvXCIsXG5cdFwiU0VMRUNUX1BJQ1RVUkVcIjogXCJWw6RsaiBCaWxkXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCJTdMOkbGwgaW4gZWdlbiBVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIkluZm9nYSBCaWxkXCIsXG5cdFwiRVJST1JcIjogXCJGZWxcIixcblx0XCJVUExPQURfRVJST1JcIjogXCJVcHBsYWRkbmluZ3NmZWxcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwiS2FtZXJhIEF2YnJ1dGVuXCIsXG5cdFwiU0VUX1VSTFwiOiBcIlN0w6RsbCBpbiBVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwiRGlyZWt0IHdlYmJsw6RuayBmw7ZyIGJpbGRcIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcIktvbW1lbnRhcmVuIMOkciBza2lja2FkIVwiLFxuXHRcIkRFTEVURV9DT01NRU5UXCI6IFwiQm9ydHRhZ25pbmcgYXYga29tbWVudGFyZXIgZ8OlciBpbnRlIGF0dCDDpW5ncmEuLi5cIixcblx0XCJERUxFVEVEX0NPTU1FTlRcIjogXCJUb2cgYm9ydCBrb21tZW50YXJlblwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwiTGFkZGFyIHVwcCBiaWxkXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIlVwcGxhZGRuaW5nIFNsdXRmw7ZyZFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCJVcHBsYWRkbmluZyBNaXNzbHlja2FkZXNcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCJMw7ZzZW5vcmRldCBlbGxlciBrb250b25hbW5ldCB2YXIgZmVsYWt0aWd0XCIsXG5cdFwiSU5GT1wiOiBcIkluZm9cIixcblx0XCJRUl9URVhUXCI6IFwiUGxhY2VyYSBRUi1rb2QgaW5uYW5mw7ZyIHNrYW5uaW5nc29tcsOlZGV0XCIsXG5cdFwiQkFMQU5DRV9URVhUXCI6IFwiU2UgdGlsbCBhdHQgZHUgaGFyIHRpbGxyw6Rja2xpZ3Qgc2FsZG8gZsO2ciB0cmFuc2FrdGlvbmVuIVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCJBbnbDpG5kYXJlbiBkdSBmw7Zyc8O2a2VyIMO2dmVyZsO2cmEgdGlsbCBleGlzdGVyYXIgaW50ZSFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwiw4RyIGR1IHPDpGtlciBhdHQgZHUgdmlsbCBmw7ZyYSDDtnZlcj9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCJCZWtyw6RmdGVsc2VcIixcblx0XCJUWF9CUk9BRENBU1RFRFwiOiBcIsOWdmVyZsO2cmluZyBzw6RuZGVzXCIsXG5cdFwiRkVFRFwiOiBcIkZsw7ZkZVwiLFxuXHRcIlRSRU5ESU5HXCI6IFwiVHJlbmRhbmRlXCIsXG5cdFwiSE9UXCI6IFwiSGV0dFwiLFxuXHRcIk5FV1wiOiBcIk55dHRcIixcblx0XCJQUk9NT1RFRFwiOiBcIk1hcmtuYWRzZsO2cnRcIixcblx0XCJWT1RFU1wiOiBcIlLDtnN0ZXJcIixcblx0XCJQQVlPVVRcIjogXCJVdGJldGFsbmluZ1wiLFxuXHRcIkNPTU1FTlRTXCI6IFwiS29tbWVudGFyZXJcIixcblx0XCJUUkVORElOR18zMFwiOiBcIlRyZW5kYW5kZSBmw7ZyIDMwIGRhZ2FyXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwiU29ydGVyYSBpbmzDpGdnIGVmdGVyXCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwiVXRiZXRhbG5pbmdzcGVyaW9kXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIlBvdGVudGllbGwgVXRiZXRhbG5pbmdcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIlRpZGlnYXJlIFV0YmV0YWxuaW5nXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIlNrcmliZW50cyBVdGJldGFsbmluZ1wiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIkt1cmF0b3JlcnMgVXRiZXRhbG5pbmdcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIklubMOkZ2dldCDDpHIgcHVibGljZXJhdCFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwiSW5sw6RnZyBmw7ZyIHNlbmFyZSBwdWJsaWNlcmluZyFcIixcblx0XCJTQVZFRFwiOiBcIlNwYXJhdFwiLFxuXHRcIkNMRUFSRURcIjogXCJUw7ZtdFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCJBdHQgcsO2c3RhIG5lciBldHQgaW5sw6RnZyBrYW4gdGEgYm9ydCBiZWzDtm5pbmcgb2NoIGfDtnJhIGlubMOkZ2dldCBtaW5kcmUgc3lubGlndC48YnI+PGJyPiBOZWRyw7ZzdGVuIGLDtnIgYW52w6RuZGFzIGbDtnIgZsO2bGphbmRlOiA8dWw+PGxpPkJlZHLDpGdlciBlbGxlciBQbGFnaWF0PC9saT48bGk+SGV0cyBlbGxlciBUcm9sbGluZzwvbGk+PGxpPk1lZHZldGV0IGZlbGthdGVnb3Jpc2VyYXQgaW5uZWjDpWxsIGVsbGVyIFNwYW08L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwiU2x1dCBww6UgZmzDtmRldCBuw6V0dC4gS29sbGEgaW4gYW5kcmEgdHJlbmRlci/DpG1uZXN0YWdnYXIhXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwiSW5sw6RnZ2V0IGhhciB0YWdpdHMgYm9ydCBmcsOlbiBib2ttw6Rya2VuIVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCJJbmzDpGdnZXQgaGFyIGxhZ3RzIHRpbGwgaSBib2ttw6Rya2VuIVwiLFxuXHRcIlJFU0VUXCI6IFwiw4V0ZXJzdMOkbGxcIixcblx0XCJNT0RJRllfUElDVFVSRVwiOiBcIk1vZGlmaWVyYSBwcm9maWxiaWxkXCIsXG5cdFwiTU9ESUZZX0NPVkVSX1BJQ1RVUkVcIjogXCJNb2RpZmllcmEgdXBwc2xhZ3NiaWxkXCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwiVmFyIGdvZCBhbmdlIGRlbiBwcml2YXRhIHLDtnJlbHNlbnlja2VsbiBvbSBkdSBoYXIgdmFsdCBBdmFuY2VyYXQgbMOkZ2UhXCIsXG5cdFwiUkVTRVRfUElDVFVSRV9URVhUXCI6IFwiRGV0IGjDpHIgw6V0ZXJzdMOkbGxlciBwcm9maWxiaWxkXCIsXG5cdFwiUkVTRVRfQ09WRVJfUElDVFVSRV9URVhUXCI6IFwiRGV0IGjDpHIgw6V0ZXJzdMOkbGxlciB1cHBzbGFnc2JpbGRcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcIlNlcnZlcnVwcGRhdGVyaW5nIGtyw6R2ZXIgb21zdGFydCFcIixcblx0XCJTRVRUSU5HU19VUERBVEVEXCI6IFwiSW5zdMOkbGxuaW5nYXIgaGFyIHVwcGRhdGVyYXRzIVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIlNwcsOla1wiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwiSMOkciBrYW4gZHUgdsOkbGphIGRldCBzcHLDpWsgc29tIGFwcGVuIGFudsOkbmRlci5cIixcblx0XCJMT0dJTl9UT19YXCI6IFwiRGVuIGjDpHIgb3BlcmF0aW9uZW4ga3LDpHZlciBhdHQgYW52w6RuZGFyZW4gw6RyIGlubG9nZ2FkIG1lZCBsw7ZzZW5vcmQsIGFsbG3DpG5ueWNrZWwvaW5sw6RnZ3NueWNrZWwuIFZhciBnb2QgbG9nZ2EgaW4gb2NoIGbDtnJzw7ZrIGlnZW4uXCIsXG5cdFwiR0FMTEVSWVwiOiBcIkdhbGxlcmlcIixcblx0XCJUUkFOU0xBVElPTlNcIjogXCJCaWRyYWdhbmRlIMO2dmVyc8OkdHRhcmVcIixcblx0XCJTSEFSRVwiOiBcIkRlbGFcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIk1hcmtuYWRzcGxhdHNcIixcblx0XCJFWENIQU5HRVwiOiBcIkLDtnJzXCIsXG5cdFwiRFJBRlRTXCI6IFwiVXRza2lja1wiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcIklubMOkZ2cgaGFyIHRhZ2l0cyBib3J0IGZyw6VuIHV0c2tpY2shXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIklubMOkZ2cgaGFyIGxhZ3RzIHRpbGwgaSB1dHNraWNrIVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCJEcmEgw6V0IHbDpG5zdGVyIGbDtnIgYXR0IHNlIGFsdGVybmF0aXZcIixcblx0XCJNQU5BR0VcIjogXCJIYW50ZXJhXCIsXG5cdFwiSU1BR0VfUkVNT1ZFRFwiOiBcIkJpbGRlbiDDpHIgYm9ydHRhZ2VuXCIsXG5cdFwiQ09QWVwiOiBcIktvcGllcmFcIixcblx0XCJOT19JTUFHRVwiOiBcIkR1IGhhciBpbnRlIGxhZGRhdCB1cHAgbsOlZ29uIGJpbGQgw6RubnUhXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCJEcmEgbmVyIGbDtnIgYXR0IHVwcGRhdGVyYVwiLFxuXHRcIkVYVEVSTkFMX0FQUFNcIjogXCJFeHRlcm5hIGFwcGFyXCIsXG5cdFwiUExVR0lOU1wiOiBcIlBsdWdpblwiLFxuXHRcIlNVR0dFU1RcIjogXCJGw7Zyc2xhZ1wiLFxuXHRcIkNPTUlOR19TT09OXCI6IFwiS29tbWVyIHNuYXJ0XCIsXG5cdFwiQ0hBSU5cIjogXCJLZWRqYVwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCJIw6RyIGthbiBkdSDDpG5kcmEgYmxvY2trZWRqYSBlbGxlciBmw7ZydmFsZCBwbGF0dGZvcm0uXCIsXG5cdFwiQ1VSUkVOQ1lcIjogXCJWYWx1dGFcIixcblx0XCJDVVJSRU5DWV9URVhUXCI6IFwiSMOkciBrYW4gZHUgw6RuZHJhIGRpbiBzdGFuZGFyZHZhbHV0YS4gRGV0IMOkciBkZW4gdmFsdXRhIHNvbSBiZWzDtm5pbmdhciBmw7ZyIGlubMOkZ2cva29tbWVudGFyZXIga29tbWVyIGF0dCB2aXNhcyBpLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPkxpc3RhIMO2dmVyIGZ1bmt0aW9uZXI8L2I+PGJyPi0gVGlsbGfDpW5nIHRpbGwgYXJ0aWtsYXIgaSDDpG1uZW4gc29tIGludHJlc3NlcmFyIGRpZy48YnI+LSBJbnRlcmFnZXJhIG1lZCBza3JpYmVudGVyIGdlbm9tIGF0dCBrb21tZW50ZXJhLCBkaXNrdXRlcmEgw6RtbmVuLjxicj4tIFLDtnN0YSBww6UgaW5sw6RnZyBmw7ZyIGF0IGJlbMO2bmEgc2tyaWJlbnRlciBvY2ggdGrDpG5hIGt1cmVyaW5nc2JlbMO2bmluZ2FyLjxicj4tIFB1YmxpY2VyYSBkaW5hIGFydGlrbGFyLCBibG9nZ2lubMOkZ2cgb2NoIGfDtnIgZGVtIHRpbGxnw6RubGlnYSBmw7ZyIGFuZHJhIGhlbHQgZ3JhdGlzLCBzYW10IHRqw6RuYSBiZWzDtm5pbmdhciBnZW5vbSBhdHQgZW5nYWdlcmEgb2NoIGbDpSBmw7ZsamFyZS48YnI+LSBTa3JpdiBhcnRpa2xhciBww6Ugc3TDpWVuZGUgZsOldCwgc3BhcmEgZmxlcmEgdXRrYXN0IGF2IGRpbmEgaW5sw6RnZyBmw7ZyIHNlbmFyZSBwdWJsaWNlcmluZy48YnI+LSBCb2ttw6RyayBmYXZvcnRpbmzDpGdnIGbDtnIgYXR0IGzDpHNhIHNlbmFyZS48YnI+LSBIYW5kbGEgbWVkIGVsbGVyIHRhIHV0IGRpbmEgYmVsw7ZuaW5nYXIuPGJyPi0gR8O2ciB0cmFuc2FrdGlvbmVyIHRpbGwgdmFsZnJpIGFudsOkbmRhcmUsIHbDpG4sIGbDtmxqYXJlLCBldGMuPGJyPi0gRsO2bGogaW50cmVzc2FudGEgc2tyaWJlbnRlciwgYmxvZ2dhcmUuPGJyPi0gU8O2ayBibGFuZCBkaW5hIGbDtmxqYXJlIG9jaCBza3JpYmVudGVyIGR1IGbDtmxqZXIuPGJyPi0gRsOlIG1lZGRlbGFuZGUgc8OlIGF0dCBkdSBrYW4gaMOlbGxhIGtvbnRha3RlbiBtZWQgZGluYSBmw7ZsamFyZSBvY2ggaGEga29sbCBww6UgZGUgZGlza3Vzc2lvbmVyIGR1IGRlbHRhciBpLjxicj4tIFPDtmsgZWZ0ZXIgaW50cmVzc2FudGEgw6RtbmVuL2FydGlrZWxrYXRlZ29yaWVyLCBza3JpYmVudGVyLjxicj4tIEfDtnIgZGluIHByb2ZpbCBtZXIgcGVyc29ubGlnLjxicj4tIE3DpW5nYSBmbGVyIGZ1bmt0aW9uZXIgcMOlIHbDpGc8YnI+PGJyPjxiPlPDpGtlcmhldDwvYj48YnI+MS4gQXBwZW4gaGFyIGbDpXIgYWxkcmlnIHRpbGxnw6VuZyB0aWxsIGVsbGVyIGtvbnRyb2xsIMO2dmVyIGRpbmEgcGVuZ2FyLjxicj4yLiBBcHBlbnMgc8Oka2VyaGV0c21vZGVsbCDDpHIga2xpZW50Y2VudHJlcmFkLCBtZWQgcHJpdmF0YSBueWNrbGFyIHNwYXJhZGUgbG9rYWx0IG9jaCBhbGRyaWcgc2tpY2thZGUgdGlsbCBuw6VncmEgYW5kcmEgc2VydnJhciwgZHUgw6RyIHNqw6RsdiBhbnN2YXJpZyBmw7ZyIGF0dCBzw6RrZXJoZXRza29waWVyYSBkaW5hIGzDtnNlbm9yZC48YnI+My4gQXBwZW4gZXJianVkZXIgZXR0IGVua2VsdCwgYXR0cmFrdGl2dCBhbnbDpG5kYXJncsOkbnNzbml0dCBvY2ggYW52w6RuZGFydXBwbGV2ZWxzZS48YnI+NC4gQXBwZW4gZXJianVkZXIgZXh0cmEgc8Oka2VyaGV0IG1lZCBwaW4ta29kPGJyPjxicj5lU3RlZW0gc3TDtmRqZXIgU3RlZW0tIG9jaCBHb2xvcy0gcGxhdHRmb3JtYXJuYS48YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcIkdydW5kYXJlIG9jaCBMZWFkIERldmVsb3BlclwiLFxuXHRcIkFERF9BQ0NPVU5UXCI6IFwiTMOkZ2cgdGlsbCBrb250b1wiLFxuXHRcIlBMQVRGT1JNXCI6IFwiUGxhdHRmb3JtXCIsXG5cdFwiRVNDUk9XX0FHRU5UXCI6IFwiRXNjcm93IGFnZW50XCIsXG5cdFwiUkFUSUZJQ0FUSU9OX0RFQURMSU5FXCI6IFwiUmF0aWZpY2VyaW5nZW4gdGlkc2ZyaXN0ZW5cIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcIkVzY3JvdyBmw7ZyZmFsbG9kYXR1bVwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCJFc2Nyb3cgYXZnaWZ0XCIsXG5cdFwiRVNDUk9XX1RFUk1TXCI6IFwiRXNjcm93IHZpbGxrb3JcIlxufSIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJIT01FXCI6IFwi0J3QsCDQs9C+0LvQvtCy0L3Rg1wiLFxuXHRcIkxPR0lOXCI6IFwi0KPQstGW0LnRgtC4XCIsXG5cdFwiTE9HT1VUXCI6IFwi0JLQuNC50YLQuFwiLFxuXHRcIlBST0ZJTEVcIjogXCLQn9GA0L7RhNGW0LvRjFwiLFxuXHRcIkZPTExPV1wiOiBcItCf0ZbQtNC/0LjRgdCw0YLQuNGB0Y9cIixcblx0XCJCT09LTUFSS1NcIjogXCLQl9Cw0LrQu9Cw0LTQutC4XCIsXG5cdFwiVFJBTlNGRVJcIjogXCLQn9C10YDQtdC60LDQtyDQutC+0YjRgtGW0LJcIixcblx0XCJNQVJLRVRcIjogXCLQoNC40L3QvtC6XCIsXG5cdFwiU0VUVElOR1NcIjogXCLQndCw0LvQsNGI0YLRg9Cy0LDQvdC90Y9cIixcblx0XCJBQk9VVFwiOiBcItCG0L3RhNC+0YDQvNCw0YbRltGPINC/0YDQvi4uLlwiLFxuXHRcIkFCT1VUXzFcIjogXCLQtNC1INC60L7QttC10L0g0LfQvNC+0LbQtSDQvtGC0YDQuNC80LDRgtC4INCy0LjQvdCw0LPQvtGA0L7QtNGDINC30LAg0YHQstGW0Lkg0LrQvtC90YLQtdC90YIhXCIsXG5cdFwiQUJPVVRfMlwiOiBcItGUINGB0L7RhtGW0LDQu9GM0L3QuNC8INC00L7QtNCw0YLQutC+0LwsINC00LUg0LLQuCDQvtGC0YDQuNC80YPRlNGC0LUg0L7Qv9C70LDRgtGDINC30LAg0L/Rg9Cx0LvRltC60LDRhtGW0ZcsINC60L7QvNC10L3RgtCw0YDRliDRgtCwINC60YPRgNCw0YLQvtGA0YHRgtCy0L4uXCIsXG5cdFwiQUJPVVRfM1wiOiBcItGWINGUINC80L7QsdGW0LvRjNC90LjQvCDQv9GA0L7QtdC60YLQvtC8INC3INCy0ZbQtNC60YDQuNGC0LjQvCDQstC40YXRltC00L3QuNC8INC60L7QtNC+0LwuINCS0L7QvdC+INC90LDQtNCw0ZQg0LTQvtGB0YLRg9C/INC00L4g0LrQvtC90YLQtdC90YLRgyDQtNC70Y8g0YfQuNGC0LDQvdC90Y8sINC60L7QvNC10L3RgtGD0LLQsNC90L3Rjywg0LPQvtC70L7RgdGD0LLQsNC90L3Rjywg0L/QvtGB0YLQuNC90LPRgywg0LTQsNGUINC80L7QttC70LjQstGW0YHRgtGMINC/0LXRgNC10LTQsNGH0ZYg0LrQvtGI0YLRltCyINGC0LAg0ZbQvdGI0ZYg0YTRg9C90LrRhtGW0ZYsINGJ0L4g0L/RgNC+0L/QvtC90YPRjtGC0YzRgdGPIHt7cGxhdGZvcm1uYW1lfX0g0LHQu9C+0LrRh9C10LnQvdC+0Lwg0YLQsCB7e3NpdGVuYW1lfX0uXCIsXG5cdFwiQUJPVVRfNFwiOiBcItCU0L7QtNCw0YLQvtC6INC90LUg0LHRg9C00LUg0LzQsNGC0Lgg0LTQvtGB0YLRg9C/0YMg0LTQviDQutC+0YjRgtGW0LIg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDRh9C4INGD0YLRgNC40LzRg9Cy0LDRgtC4INGX0YUuXCIsXG5cdFwiQUJPVVRfNVwiOiBcItCU0L7QtNCw0YLQvtC6INC80LDRlCDQutC70ZbQtdC90YIt0L7RgNGW0ZTQvdGC0L7QstCw0L3RgyDQvNC+0LTQtdC70Ywg0LHQtdC30L/QtdC60LguINCf0YDQuNCy0LDRgtC90ZYg0LrQu9GO0YfRliDQt9Cx0LXRgNGW0LPQsNGO0YLRjNGB0Y8g0LvQvtC60LDQu9GM0L3QviDQvdCwINC/0YDQuNGB0YLRgNC+0Zcg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDRliDQvdGW0LrQvtC70Lgg0L3QtSDQvdCw0LTRgdC40LvQsNGO0YLRjNGB0Y8g0L3QsCDRltC90YjRliDRgdC10YDQstC10YDQuC5cIixcblx0XCJBQk9VVF82XCI6IFwiMy4g0JTQvtC00LDRgtC+0Log0L/RgNC+0L/QvtC90YPRlCDQv9GA0L7RgdGC0LjQuSwg0L/RgNC40LLQsNCx0LvQuNCy0LjQuSDQutC+0YDQuNGB0YLRg9Cy0LDRhtGM0LrQuNC5INGW0L3RgtC10YDRhNC10LnRgSDRgtCwINC00L7RgdCy0ZbQtC5cIixcblx0XCJBQk9VVF83XCI6IFwi0JTQvtC00LDRgtC+0Log0L3RltC60L7Qu9C4INC90LUg0LLQuNC80LDQs9Cw0ZQg0LLRltC0INC60L7RgNC40YHRgtGD0LLQsNGH0ZbQsiDQttC+0LTQvdC40YUg0L7RgdC+0LHQuNGB0YLQuNGFINC00LDQvdC40YUuXCIsXG5cdFwiQUJPVVRfOFwiOiBcItCf0YDQvtCz0L7Qu9C+0YHRg9Cy0LDRgtC4INC30LAgZ29vZC1rYXJtYSDRj9C6INC30LAg0LTQtdC70LXQs9Cw0YLQsFwiLFxuXHRcIkFCT1VUXzlcIjogXCLQmtC+0L3RgtCw0LrRgi/Ql9Cy0L7RgNC+0YLQvdGW0Lkg0LfQsifRj9C30L7QulwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi0JHRltC70YzRiNC1INGW0L3RhNC+0YDQvNCw0YbRltGXXCIsXG5cdFwiUkVNT1ZFXCI6IFwi0JLQuNC00LDQu9C40YLQuFwiLFxuXHRcIk1BUktFVF9WSUVXXCI6IFwi0J7Qs9C70Y/QtCDRgNC40L3QutGDXCIsXG5cdFwiUFJJQ0VcIjogXCLQptGW0L3QsFwiLFxuXHRcIkFNT1VOVFwiOiBcItCa0ZbQu9GM0LrRltGB0YLRjFwiLFxuXHRcIlRPVEFMXCI6IFwi0JfQsNCz0LDQu9C+0LxcIixcblx0XCJOT09SREVSU1wiOiBcItCd0LXQvNCw0ZQg0LLRltC00LrRgNC40YLQuNGFINC+0YDQtNC10YDRltCyINC00LvRj1wiLFxuXHRcIkRBVEVcIjogXCLQlNCw0YLQsFwiLFxuXHRcIkJVWVwiOiBcItCa0YPQv9C40YLQuFwiLFxuXHRcIlNFTExcIjogXCLQn9GA0L7QtNCw0YLQuFwiLFxuXHRcIk9QRU5cIjogXCLQktGW0LTQutGA0LjRgtC4XCIsXG5cdFwiSElTVE9SWVwiOiBcItCG0YHRgtC+0YDRltGPXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLQktGW0LTQv9C40YHQsNGC0LjRgdGPXCIsXG5cdFwiRk9MTE9XRURcIjogXCLQn9GW0LTQv9C40YHQutC4INC90LAg0JLQsNGBXCIsXG5cdFwiVU5GT0xMT1dcIjogXCLQndC1INGB0LvRltC00LrRg9Cy0LDRgtC4XCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwi0JLQsNGI0ZYg0L/RltC00L/QuNGB0LrQuFwiLFxuXHRcIkZPTExPV0VSU1wiOiBcItCf0L7RgdC70ZbQtNC+0LLQvdC40LrQuFwiLFxuXHRcIlNFQVJDSF9GT0xMT1dFUlNcIjogXCLQn9C+0YjRg9C6INC/0L7RgdC70ZbQtNC+0LLQvdC40LrRltCyXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcItCf0L7RiNGD0Log0LLRltC00YHRgtC10LbRg9Cy0LDQvdC+0LPQvlwiLFxuXHRcIkJZXCI6IFwi0LfQsFwiLFxuXHRcIklOXCI6IFwi0JJcIixcblx0XCJNRU5VXCI6IFwi0JzQtdC90Y5cIixcblx0XCJCT09LTUFSS1wiOiBcItCX0LDQutC70LDQtNC60LBcIixcblx0XCJSRUJMT0dcIjogXCLQoNC10L/QvtGB0YJcIixcblx0XCJVUFZPVEVcIjogXCLQk9C+0LvQvtGBINCX0LBcIixcblx0XCJET1dOVk9URVwiOiBcItCT0L7Qu9C+0YEg0J/RgNC+0YLQuFwiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLQl9C90Y/RgtC4INCz0L7Qu9C+0YEg0J/RgNC+0YLQuFwiLFxuXHRcIlVOVk9URV9VUFZPVEVEXCI6IFwi0JfQvdGP0YLQuCDQs9C+0LvQvtGBINCX0LBcIixcblx0XCJSRVBMWVwiOiBcItCf0L7QstGC0L7RgNC40YLQuFwiLFxuXHRcIkVESVRcIjogXCLQoNC10LTQsNCz0YPQstCw0YLQuFwiLFxuXHRcIlBPU1RfMVwiOiBcItCf0YDQvtCy0LXQtNGW0YLRjCDQv9Cw0LvRjNGG0LXQvCDQstC70ZbQstC+INC90LAg0LrQvtC80LXQvdGC0LDRgNGWLCDRidC+0LEg0L/QvtCx0LDRh9C40YLQuCDQstCw0YDRltCw0L3RgtC4XCIsXG5cdFwiUE9TVF8yXCI6IFwi0J3QsNGC0LjRgdC90ZbRgtGMINC90LAg0LrQvtC80LXQvdGC0LDRgNGWLCDRidC+0LEg0L/QvtCx0LDRh9C40YLQuCDQstC60LvQsNC00LXQvdGWINC60L7QvNC10L3RgtCw0YDRllwiLFxuXHRcIk9QVElPTlNcIjogXCLQktCw0YDRltCw0L3RgtC4XCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi0KDQtdC/0L7RgdGC0L3Rg9GC0L5cIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLQotGD0YIg0L3RltGH0L7Qs9C+LCDQv9C+0LrQuCDRidC+Li4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCLQkdCw0LvQsNC90YHQuFwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0sINGC0L7RgNCz0L7QstGWINC80LDRgNC60LXRgNC4LCDRj9C60ZYg0LzQvtC20YPRgtGMINC/0LXRgNC10LTQsNCy0LDRgtC40YHRjyDQsiDQsdGD0LTRjC3Rj9C60LjQuSDRh9Cw0YEuIHt7cGxhdGZvcm1uYW1lfX0g0LzQvtC20L3QsCDQutC+0L3QstC10YDRgtGD0LLQsNGC0Lgg0LIge3twbGF0Zm9ybXBvd2VyfX0g0LIg0L/RgNC+0YbQtdGB0ZYsINGJ0L4g0LzQsNGUINC90LDQt9Cy0YMgXFxcItC/0L7RgdC40LvQtdC90L3Rj1xcXCIuXCIsXG5cdFwiUFJPRklMRV8yXCI6IFwie3twbGF0Zm9ybXBvd2VyfX0sINC80LDRgNC60LXRgNC4INCy0L/Qu9C40LLRgywg0Y/QutGWINC90LDQtNCw0Y7RgtGMINCx0ZbQu9GM0YjQtSDRgdC40LvQuCDQv9GA0Lgg0ZfRhSDQtNC+0LLQs9C+0YHRgtGA0L7QutC+0LLQvtC80YMg0LfQsdC10YDQtdC20LXQvdC90ZYg0YLQsCDQs9C+0LvQvtGB0YPQstCw0L3QvdGWINC30LAg0L/QvtGB0YLQuC4g0KfQuNC8INCx0ZbQu9GM0YjQtSDQktC4INGX0YUg0LzQsNGU0YLQtSwg0YLQuNC8INCx0ZbQu9GM0YjQuNC5INCS0LDRiCDQstC/0LvQuNCyINC90LAg0LLQuNC90LDQs9C+0YDQvtC00YMg0LfQsCDQv9C+0YHRgiwg0ZYg0LHRltC70YzRiNCwINCS0LDRiNCwINCy0LjQvdCw0LPQvtGA0L7QtNCwINC30LAg0LPQvtC70L7RgdGD0LLQsNC90L3Rjy5cIixcblx0XCJQUk9GSUxFXzNcIjogXCLQotC+0LrQtdC90Lgg0LrQvtGI0YLRg9GO0YLRjCDQv9GA0LjQsdC70LjQt9C90L4ge3twbGF0Zm9ybXN1bml0fX0ge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLQodC10YDQtdC00L3RjyDQstCw0YDRgtGW0YHRgtGMXCIsXG5cdFwiUFJPRklMRV80XCI6IFwi0J7RgNGW0ZTQvdGC0L7QstC90LAg0LLQsNGA0YLRltGB0YLRjCDQsdCw0LfRg9GU0YLRjNGB0Y8g0L3QsCA3LdC00LXQvdC90ZbQuSDRgdC10YDQtdC00L3RltC5INCy0LDRgNGC0L7RgdGC0ZYge3twbGF0Zm9ybW5hbWV9fS5cIixcblx0XCJUUkFOU0FDVElPTl9ISVNUT1JZXCI6IFwi0IbRgdGC0L7RgNGW0Y8g0YLRgNCw0L3Qt9Cw0LrRhtGW0LlcIixcblx0XCJQT1NUSU5HXCI6IFwi0J/Rg9Cx0LvRltC60LDRhtGW0Y9cIixcblx0XCJQUk9GSUxFXzVcIjogXCLQn9C+0YHRgtC40L3Qsy3QutC70Y7RhyDQstC40LrQvtGA0LjRgdGC0L7QstGD0ZTRgtGM0YHRjyDQtNC70Y8g0L/QvtGB0YLQuNC90LPRgyDRgtCwINCz0L7Qu9C+0YHRg9Cy0LDQvdC90Y8uINCS0ZbQvSDQv9C+0LLQuNC90LXQvSDQstGW0LTRgNGW0LfQvdGP0YLQuNGB0Y8g0LLRltC0INCQ0LrRgtC40LLQvdC+0LPQviDQutC70Y7Rh9CwINGWINC60LvRjtGH0LAg0LrQvtGA0LjRgdGC0YPQstCw0YfQsC5cIixcblx0XCJPV05FUlwiOiBcItCS0LvQsNGB0L3QuNC6XCIsXG5cdFwiUFJPRklMRV82XCI6IFwi0JrQu9GO0Ycg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDRlCDQnNCw0LnRgdGC0LXRgC3QutC70Y7Rh9C10Lwg0LTQu9GPINC+0LHQu9GW0LrQvtCy0L7Qs9C+INC30LDQv9C40YHRgyDRliDQvdC10L7QsdGF0ZbQtNC90LjQuSDQtNC70Y8g0LfQvNGW0L3QuCDRltC90YjQuNGFINC60LvRjtGH0ZbQsi4g0JfQsNC60YDQuNGC0LjQuSDQutC70Y7RhyDQsNCx0L4g0L/QsNGA0L7Qu9GMINC00L4g0JrQu9GO0YfQsCDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINC/0L7QstC40L3QvdGWINC30LHQtdGA0ZbQs9Cw0YLQuNGB0Y8g0L/QviDQvNC+0LbQu9C40LLQvtGB0YLRliDQvtGE0YTQu9Cw0LnQvS5cIixcblx0XCJBQ1RJVkVcIjogXCLQkNC60YLQuNCy0L3RllwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcItCQ0LrRgtC40LLQvdC40Lkg0LrQu9GO0Ycg0LLQuNC60L7RgNC40YHRgtC+0LLRg9GU0YLRjNGB0Y8g0LTQu9GPINGC0L7Qs9C+LCDRidC+0LEg0LfQtNGW0LnRgdC90Y7QstCw0YLQuCDQv9C10YDQtdC60LDQt9C4INGC0LAg0YDQvtC30LzRltGJ0YPQstCw0YLQuCDQt9Cw0LzQvtCy0LvQtdC90L3RjyDQvdCwINCy0L3Rg9GC0YDRltGI0L3RjNC+0LzRgyDRgNC40L3QutGDLlwiLFxuXHRcIk1FTU9cIjogXCLQn9Cw0Lwn0Y/RgtC60LBcIixcblx0XCJQUk9GSUxFXzhcIjogXCLQn9Cw0Lwn0Y/RgtC60LAg0LrQu9GO0Ycg0LLQuNC60L7RgNC40YHRgtC+0LLRg9GU0YLRjNGB0Y8g0LTQu9GPINGB0YLQstC+0YDQtdC90L3RjyDRliDRh9C40YLQsNC90L3RjyDQv9Cw0Lwn0Y/RgtC+0LouXCIsXG5cdFwiQkxPR1wiOiBcItCR0LvQvtCzXCIsXG5cdFwiUE9TVFNcIjogXCLQn9C+0YHRgtC4XCIsXG5cdFwiUkVQTElFU1wiOiBcItCS0ZbQtNC/0L7QstGW0LTRllwiLFxuXHRcIldBTExFVFwiOiBcItCT0LDQvNCw0L3QtdGG0YxcIixcblx0XCJUQUdcIjogXCLQotC10LNcIixcblx0XCJVU0VSXCI6IFwi0JrQvtGA0LjRgdGC0YPQstCw0YdcIixcblx0XCJDTE9TRVwiOiBcItCX0LDQutGA0LjRgtC4XCIsXG5cdFwiVE9cIjogXCLQmtC+0LzRg1wiLFxuXHRcIkFTU0VUXCI6IFwi0JDQutGC0LjQslwiLFxuXHRcIlNFTkRcIjogXCLQktGW0LTQv9GA0LDQstC40YLQuFwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi0JHQtdC30L/QtdC60LBcIixcblx0XCJBVkFJTEFCTEVcIjogXCLQlNC+0YHRgtGD0L/QvdC+XCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLQl9Cw0LPQsNC70YzQvdC+0LTQvtGB0YLRg9C/0L3QsCDQv9Cw0Lwn0Y/RgtC60LBcIixcblx0XCJUT19ERVNDXCI6IFwi0JrQvtGA0LjRgdGC0YPQstCw0YcsINC90LDQv9GA0LjQutC70LDQtCBnb29kLWthcm1hXCIsXG5cdFwiUElOX0NPREVcIjogXCJQSU4t0LrQvtC0XCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU4t0LrQvtC0INC00L7Qv9C+0LzQsNCz0LDRlCDQstCw0Lwg0LfQsNGF0LjRgdGC0LjRgtC4INC00L7QtNCw0YLQvtC6INGWINCy0LDRiNGWINC00LDQvdGWLiA8YnIvPiA8YnIvPiA8Yj7Qn9GA0LjQvNGW0YLQutCwOjwvYj4g0J/RltGB0LvRjyDQstC60LvRjtGH0LXQvdC90Y8g0YMg0JLQsNGBINGUINC80LDQutGB0LjQvNGD0LwgNCDRgdC/0YDQvtCx0LgsINGJ0L7QsSDRgNC+0LfQsdC70L7QutGD0LLQsNGC0LguINCv0LrRidC+INCy0Lgg0LfQsNCx0YPQu9C4INCf0IbQnS3QutC+0LQg0LDQsdC+INC/0L7QvNC40LvQuNC70LjRgdGPINC/0YDQuCDQstCy0LXQtNC10L3QvdGWINC00LDQvdC40YUsINC00L7QtNCw0YLQvtC6INCy0LjQtNCw0LvQuNGC0Ywg0LTQsNC90ZYg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCwg0YnQviDQt9Cw0LnRiNC+0LIg0YMg0YHQuNGB0YLQtdC80YMuINCS0Lgg0LzQvtC20LXRgtC1INCw0LLRgtC+0YDQuNC30YPQstCw0YLQuNGB0Y8g0L/QvtCy0YLQvtGA0L3QviDRliDQv9GA0L7QtNC+0LLQttC40YLQuCDQutC+0YDQuNGB0YLRg9Cy0LDQvdC90Y8g0LTQvtC00LDRgtC60L7QvC5cIixcblx0XCJOT1RJRklDQVRJT05TXCI6IFwi0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPXCIsXG5cdFwiVk9URV9URVhUXCI6IFwi0JLQuCDQvtGC0YDQuNC80LDRlNGC0LUg0L/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPLCDQutC+0LvQuCDRhdGC0L7RgdGMINCz0L7Qu9C+0YHRg9GUINC30LAg0JLQsNGIINC60L7QvdGC0LXQvdGCISA8YnIvPiA8Yj7Qn9GA0LjQvNGW0YLQutCwOjwvYj4g0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPINCy0LrQu9GO0YfQsNGO0YLRjCDQstCw0LPRgyDQs9C+0LvQvtGB0YMg0LAg0YLQsNC60L7QtiDRgyDQv9C+0L/QtdGA0LXQtNC20LXQvdC90Y8gKNCx0YPQtNGMINGC0L4g0LPQvtC70L7RgdGD0LLQsNC90L3RjyDQl9CwLCDQs9C+0LvQvtGB0YPQstCw0L3QvdGPINCf0YDQvtGC0LgsINCX0L3Rj9GC0YLRjyDQs9C+0LvQvtGB0YMpLlwiLFxuXHRcIlZPVEVcIjogXCLQk9C+0LvQvtGB0YPQstCw0YLQuFwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcItCS0Lgg0L7RgtGA0LjQvNCw0ZTRgtC1INC/0L7QstGW0LTQvtC80LvQtdC90L3Rjywg0LrQvtC70Lgg0YXRgtC+0YHRjCDQv9GA0L7QutC+0LzQtdC90YLRg9GUINCS0LDRiNGWINC/0YPQsdC70ZbQutCw0YbRltGXINGH0Lgg0LrQvtC80LXQvdGC0LDRgNGWISA8YnIvPiA8Yj7Qn9GA0LjQvNGW0YLQutCwOjwvYj4g0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPINGC0LDQutC+0LYg0L/RgNC40LnQtNC1INGDINCy0LjQv9Cw0LTQutGDLCDQutC+0LvQuCDRhdGC0L7RgdGMIDxiPtCy0ZbQtNGA0LXQtNCw0LPRg9GUPC9iPiDRgdCy0L7RlyDQstC70LDRgdC90ZYg0LrQvtC80LXQvdGC0LDRgNGWLlwiLFxuXHRcIkNPTU1FTlRcIjogXCLQmtC+0LzQtdC90YLQsNGAXCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLQktC4INC+0YLRgNC40LzQsNGU0YLQtSDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8sINC60L7Qu9C4INGF0YLQvtGB0Ywg0L/RltC00L/QuNGI0LXRgtGM0YHRjyDQvdCwINCS0LDRiNGWINC/0YPQsdC70ZbQutCw0YbRltGXINCw0LHQviDQstGW0LTQv9C40YjQtdGC0YzRgdGPINCy0ZbQtCDQvdC40YUhXCIsXG5cdFwiTUVOVElPTlNcIjogXCLQl9Cz0LDQtNGD0LLQsNC90L3Rj1wiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLQktC4INC+0YLRgNC40LzQsNGU0YLQtSDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8sINC60L7Qu9C4INGF0YLQvtGB0Ywg0LfQs9Cw0LTQsNGUINCS0LDRgSDRgyDRgdCy0L7Rl9C5INC/0YPQsdC70ZbQutCw0YbRltGXL9C60L7QvNC10L3RgtCw0YDRliFcIixcblx0XCJSRVNURUVNXCI6IFwi0KDQtdC/0L7RgdGCXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwi0JLQuCDQvtGC0YDQuNC80LDRlNGC0LUg0L/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPLCDQutC+0LvQuCDRhdGC0L7RgdGMINC30YDQvtCx0LjRgtGMINGA0LXQv9C+0YHRgiDQstCw0YjQvtGXINC/0YPQsdC70ZbQutCw0YbRltGXIVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi0JrQvtC90YTRltCz0YPRgNCw0YbRltGXXCIsXG5cdFwiVk9USU5HXCI6IFwi0JPQvtC70L7RgdGD0LLQsNC90L3Rj1wiLFxuXHRcIlZPVElOR19URVhUXCI6IFwi0JLQsNCz0LAg0LPQvtC70L7RgdGDINGDINCy0ZbQtNGB0L7RgtC60LDRhSDQstC/0LvQuNCy0LDRlCDQvdCwINCy0LDQs9GDINCz0L7Qu9C+0YHRgyDQsiDQtNC+0LTQsNGC0LrRgywg0YLQsNC60LjQvCDRh9C40L3QvtC8INCy0Lgg0LzQvtC20LXRgtC1INGA0LXQs9GD0LvRjtCy0LDRgtC4INCy0LjQvdCw0LPQvtGA0L7QtNGDINC/0YDQuCDQs9C+0LvQvtGB0YPQstCw0L3QvdGWLiA8YnIvPiA8YnIvPiA8Yj7Qn9GA0LjQvNGW0YLQutCwOjwvYj4g0KbQtSDRgtCw0LrQvtC2INC30LzRltC90LjRgtGMINCy0LDQs9GDINCz0L7Qu9C+0YHRgy/QstGW0LTRgdC+0YLQvtC6INC/0YDQuCDQs9C+0LvQvtGB0YPQstCw0L3QvdGWINCf0YDQvtGC0LgsINGWINGB0LrRgNGW0LfRjCDRgyDQtNC+0LTQsNGC0LrRg1wiLFxuXHRcIlNFUlZFUlwiOiBcItCh0LXRgNCy0LXRgFwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwi0KDQtdC60L7QvNC10L3QtNC+0LLQsNC90L5cIixcblx0XCJTQVZFX0NIQU5HRVNcIjogXCLQl9Cx0LXRgNC10LPRgtC4INC30LzRltC90LhcIixcblx0XCJWT1RFUlNfSU5GT1wiOiBcItCG0L3RhNC+0YDQvNCw0YbRltGPINC/0YDQviDRgtC40YUsINGF0YLQviDQs9C+0LvQvtGB0YPQstCw0LJcIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCLQlyDQv9C+0LLQtdGA0L3QtdC90L3Rj9C8IVwiLFxuXHRcIkxPR0lOXzFcIjogXCLQqdC+0LEg0L/RgNC+0LTQvtCy0LbQuNGC0LgsINGD0LLRltC50LTRltGC0Ywg0LfQsCDQtNC+0L/QvtC80L7Qs9C+0Y4g0JLQsNGI0L7Qs9C+INCG0LzQtdC90ZYg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDRgtCwINC/0LDRgNC+0LvRji5cIixcblx0XCJMT0dJTl8yXCI6IFwi0J/QvtGB0YLQuNC90LMt0LrQu9GO0Ycg0LrQu9GO0Ycg0LLQuNC60L7RgNC40YHRgtC+0LLRg9GU0YLRjNGB0Y8g0LTQu9GPINGA0L7Qt9C80ZbRidC10L3QvdGPINC/0L7RgdGC0ZbQsiwg0LrQvtC80LXQvdGC0LDRgNGW0LIsINCz0L7Qu9C+0YHRg9Cy0LDQvdC90Y8sINC/0ZbQtNC/0LjRgdC+0LouXCIsXG5cdFwiTE9HSU5fM1wiOiBcItCQ0LrRgtC40LLQvdC40Lkg0LrQu9GO0Ycg0LLQuNC60L7RgNC40YHRgtC+0LLRg9GU0YLRjNGB0Y8g0LTQu9GPINC/0LXRgNC10LrQsNC30ZbQsiDRgtCwINC+0L3QvtCy0LvQtdC90L3RjyDQt9C+0LHRgNCw0LbQtdC90L3RjyDQv9GA0L7RhNGW0LvRji5cIixcblx0XCJMT0dJTl80XCI6IFwi0J7QsdC70ZbQutC+0LLRliDQtNCw0L3RliDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwINC30LHQtdGA0ZbQs9Cw0Y7RgtGM0YHRjyDQu9C+0LrQsNC70YzQvdC+INC90LAg0L/RgNC40YHRgtGA0L7Rly4g0J/RgNC4INCy0LjRhdC+0LTRliDQvtCx0LvRltC60L7QstGWINC00LDQvdGWINCx0YPQtNGD0YLRjCDQstC40LTQsNC70LXQvdGWIVwiLFxuXHRcIkRPTlRfSEFWRVwiOiBcItCp0LUg0L3QtSDQt9Cw0YDQtdGU0YHRgtGA0L7QstCw0L3Rlj9cIixcblx0XCJTSUdOX1VQX05PV1wiOiBcItCX0LDRgNC10ZTRgdGC0YDRg9Cy0LDRgtC40YHRjyDQt9Cw0YDQsNC3XCIsXG5cdFwiQ0FOQ0VMXCI6IFwi0JLRltC00LzRltC90LBcIixcblx0XCJBRFZBTkNFRFwiOiBcItCg0L7Qt9GI0LjRgNC10L3QuNC5XCIsXG5cdFwiQUNUSVZFX1BSSUtFWVwiOiBcItCQ0LrRgtC40LLQvdC40Lkg0LfQsNC60YDQuNGC0LjQuSDQutC70Y7Rh1wiLFxuXHRcIlBPU1RJTkdfUFJJS0VZXCI6IFwi0J/QvtGB0YLQuNC90LMt0LrQu9GO0YdcIixcblx0XCJNQVNURVJfUEFTU1wiOiBcItCc0LDQudGB0YLQtdGAL9C+0YHQvdC+0LLQvdC40Lkg0L/QsNGA0L7Qu9GMXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLQhtC8J9GPINC60L7RgNC40YHRgtGD0LLQsNGH0LBcIixcblx0XCJDQVJEX1ZJRVdcIjogXCLQoyDQstC40LPQu9GP0LTRliDQutCw0YDRgtC+0LpcIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLQmtC+0LzQv9Cw0LrRgtC90LjQuSDQstC40LPQu9GP0LRcIixcblx0XCJTRUFSQ0hcIjogXCLQn9C+0YjRg9C6XCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCLQn9GD0LHQu9GW0LrQsNGG0ZbRjyDRgdGC0LDRgtGC0ZZcIixcblx0XCJSRVBMWVRPXCI6IFwi0JLRltC00L/QvtCy0ZbRgdGC0LhcIixcblx0XCJQT1NUXCI6IFwi0J/QvtGB0YJcIixcblx0XCJQUkVWSUVXXCI6IFwi0J/QtdGA0LXQs9C70Y/QtFwiLFxuXHRcIkRFRkFVTFRcIjogXCLQl9CwINC30LDQvNC+0LLRh9GD0LLQsNC90L3Rj9C8IDUwJSAvIDUwJVwiLFxuXHRcIlBPV0VSVVBcIjogXCLQl9Cx0ZbQu9GM0YjQuNGC0Lgg0YHQuNC70YMg0LTQviAxMDAlXCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLQktGW0LTQvNC+0LLQuNGC0LjRgdGPINCy0ZbQtCDQstC40L/Qu9Cw0YLQuFwiLFxuXHRcIlNBVkVfRk9SX0xBVEVSXCI6IFwi0JfQkdCV0KDQldCT0KLQmCDQndCQINCc0JDQmdCR0KPQotCd0IRcIixcblx0XCJDTEVBUlwiOiBcItCe0YfQuNGB0YLQuNGC0LhcIixcblx0XCJQT1NUX0NPTlRFTlRcIjogXCLQktC80ZbRgdGCINC/0L7QstGW0LTQvtC80LvQtdC90L3Rj1wiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcItCS0LzRltGB0YIg0LrQvtC80LXQvdGC0LDRgNGOXCIsXG5cdFwiVElUTEVcIjogXCLQl9Cw0LPQvtC70L7QstC+0LpcIixcblx0XCJUQUdTXCI6IFwi0KLQtdCz0LhcIixcblx0XCJOT1RfTUFUQ0hcIjogXCLQndCVINCh0J/QhtCS0J/QkNCU0JDQhFwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi0J/RltC00YLQstC10YDQtNGW0YLRjCBQSU4t0LrQvtC0XCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi0J3QlSDQktCG0KDQndCeXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi0LLRltC00LrRgNC40YLRgtGPINC/0L7RgdGC0LBcIixcblx0XCJTRVRfUElOXCI6IFwi0JLRgdGC0LDQvdC+0LLQuNGC0LggUElOLdC60L7QtFwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcItCS0LLQtdC00ZbRgtGMIFBJTi3QutC+0LRcIixcblx0XCJBUkVfWU9VX1NVUkVcIjogXCLQktC4INCy0L/QtdCy0L3QtdC90ZY/XCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLQoNC10L/QvtGB0YIg0ZQg0L3QtdC30LLQvtGA0L7RgtC90ZbQvCwg0LLQuCDQsdCw0LbQsNGU0YLQtSDQv9GA0L7QtNC+0LLQttC40YLQuD9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLQn9C+0LzQuNC70LrQsCDRgtGA0LDQvdGB0LvRj9GG0ZbRlywg0YHQv9GA0L7QsdGD0LnRgtC1INGJ0LUg0YDQsNC3IVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLQo9GB0L/RltGFXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLQoNC10LHQu9C+0LMg0L/QvtGB0YLQsCFcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwi0KPQstGW0LnRgtC4INC90LUg0LLQtNCw0LvQvtGB0Y8hINCR0YPQtNGMINC70LDRgdC60LAsINC/0LXRgNC10LrQvtC90LDQudGC0LXRgdGPLCDRidC+INCw0LLRgtC+0YDQuNC30YPRlNGC0LXRgdGMINC30LAg0LTQvtC/0L7QvNC+0LPQvtGOINC80LDQudGB0YLQtdGALdC/0LDRgNC+0LvRjiDQsNCx0L4g0LLQutCw0LfQsNC70Lgg0LfQsNC60YDQuNGC0LjQuSDQn9C+0YHRgtC40L3Qsy3QutC70Y7RhyDQv9GA0Lgg0LLRhdC+0LTRliDQtNC+INGB0LjRgdGC0LXQvNC4INGDINGA0L7Qt9GI0LjRgNC10L3QvtC80YMg0YDQtdC20LjQvNGWLlwiLFxuXHRcIkxPR0lOX0ZBSUxfQVwiOiBcItCj0LLRltC50YLQuCDQvdC1INCy0LTQsNC70L7RgdGPISDQkdGD0LTRjCDQu9Cw0YHQutCwLCDQv9C10YDQtdC60L7QvdCw0LnRgtC10YHRjywg0YnQviDQsNCy0YLQvtGA0LjQt9GD0ZTRgtC10YHRjCDQt9CwINC00L7Qv9C+0LzQvtCz0L7RjiDQvNCw0LnRgdGC0LXRgC3Qv9Cw0YDQvtC70Y4g0LDQsdC+INCy0LrQsNC30LDQu9C4INCQ0LrRgtC40LLQvdC40Lkg0L/QtdGA0YHQvtC90LDQu9GM0L3QuNC5INC60LvRjtGHINC/0YDQuCDQstGF0L7QtNGWINC00L4g0YHQuNGB0YLQtdC80Lgg0YMg0YDQvtC30YjQuNGA0LXQvdC+0LzRgyDRgNC10LbQuNC80ZYuXCIsXG5cdFwiV0FSTklOR1wiOiBcItCf0L7Qv9C10YDQtdC00LbQtdC90L3Rj1wiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLQk9C+0LvQvtGB0YPQstCw0L3QvdGPINC30LAg0YHQstGW0LTQutCwXCIsXG5cdFwiVk9URURfRk9SX1dJVE5FU1NcIjogXCLQn9GA0L7Qs9C+0LvQvtGB0YPQstCw0LvQuCDQt9CwINGB0LLRltC00LrQsFwiLFxuXHRcIkFHT1wiOiBcItGC0L7QvNGDXCIsXG5cdFwiRlJPTV9OT1dcIjogXCLQtyDRhtGM0L7Qs9C+INC80L7QvNC10L3RgtGDXCIsXG5cdFwiU0VDU1wiOiBcItGB0LXQulwiLFxuXHRcIkFfTUlOXCI6IFwi0LzRltC9XCIsXG5cdFwiTUlOU1wiOiBcItGF0LIuXCIsXG5cdFwiQU5fSE9VUlwiOiBcItCz0L7QtC5cIixcblx0XCJIT1VSU1wiOiBcItCz0L7QtC5cIixcblx0XCJBX0RBWVwiOiBcItC00LXQvdGMXCIsXG5cdFwiREFZU1wiOiBcItC00L3RlijRltCyKVwiLFxuXHRcIkFfTU9OVEhcIjogXCLQvNGW0YHRj9GG0YxcIixcblx0XCJNT05USFNcIjogXCLQvNGW0YHRj9GG0ZYo0ZbQsilcIixcblx0XCJBX1lFQVJcIjogXCLRgNGW0LpcIixcblx0XCJZRUFSU1wiOiBcItGA0L7QutC4XCIsXG5cdFwiTUlOX1JFQURcIjogXCLRhdCyLiDRh9C40YLQsNC90L3Rj1wiLFxuXHRcIkRPV05WT1RFX0ZMQUdcIjogXCLQk9C+0LvQvtGBINCf0YDQvtGC0Lgg0LDQsdC+INC/0YDQsNC/0L7RgFwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcItCX0LDRhdC+0L/QuNGC0Lgg0LfQvtCx0YDQsNC20LXQvdC90Y9cIixcblx0XCJTRUxFQ1RfUElDVFVSRVwiOiBcItCS0LjQsdC10YDRltGC0Ywg0LfQvtCx0YDQsNC20LXQvdC90Y9cIixcblx0XCJTRVRfQ1VTVE9NX1VSTFwiOiBcItCS0YHRgtCw0L3QvtCy0LjRgtC4IFVSTCDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwXCIsXG5cdFwiSU5TRVJUX1BJQ1RVUkVcIjogXCLQktGB0YLQsNCy0LjRgtC4INC30L7QsdGA0LDQttC10L3QvdGPXCIsXG5cdFwiRVJST1JcIjogXCLQn9C+0LzQuNC70LrQsFwiLFxuXHRcIlVQTE9BRF9FUlJPUlwiOiBcItCf0L7QvNC40LvQutCwINC/0YDQuCDQt9Cw0LLQsNC90YLQsNC20LXQvdC90ZZcIixcblx0XCJDQU1FUkFfQ0FOQ0VMTEVEXCI6IFwi0JrQsNC80LXRgNCwINC90LXQtNC+0YHRgtGD0L/QvdCwXCIsXG5cdFwiU0VUX1VSTFwiOiBcItCS0YHRgtCw0LLQuNGC0LggVVJMXCIsXG5cdFwiRElSRUNUX0xJTktfUElDVFVSRVwiOiBcItCf0YDRj9C80LUg0L/QvtGB0LjQu9Cw0L3QvdGPINC90LAg0LfQvtCx0YDQsNC20LXQvdC90Y9cIixcblx0XCJDT01NRU5UX1NVQk1JVFRFRFwiOiBcItCa0L7QvNC10L3RgtCw0YAg0L/RgNC40LnQvdGP0YLQviFcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcItCS0LjQtNCw0LvQtdC90L3RjyDQutC+0LzQtdC90YLQsNGA0ZbQsiDRlCDQvdC10LfQstC+0YDQvtGC0L3RltC8Li4uXCIsXG5cdFwiREVMRVRFRF9DT01NRU5UXCI6IFwi0JLQuNC00LDQu9C10L3RliDQutC+0LzQtdC90YLQsNGA0ZZcIixcblx0XCJVUExPQURJTkdfUElDVFVSRVwiOiBcItCX0LDQstCw0L3RgtCw0LbQtdC90L3RjyDQvNCw0LvRjtC90LrQsFwiLFxuXHRcIlVQTE9BRF9DT01QTEVURURcIjogXCLQl9Cw0LLQsNC90YLQsNC20LXQvdC90Y8g0LfQsNCy0LXRgNGI0LXQvdC+XCIsXG5cdFwiVVBMT0FEX0ZBSUxFRFwiOiBcItCd0LUg0LLQtNCw0LvQvtGB0Y8g0LfQsNCy0LDQvdGC0LDQttC40YLQuFwiLFxuXHRcIlBBU1NXT1JEX0lOQ09SUkVDVFwiOiBcItCd0LXQstGW0YDQvdC40Lkg0L/QsNGA0L7Qu9GMINCw0LHQviDRltC8J9GPINC60L7RgNC40YHRgtGD0LLQsNGH0LBcIixcblx0XCJJTkZPXCI6IFwi0IbQvdGE0L7RgNC80LDRhtGW0Y9cIixcblx0XCJRUl9URVhUXCI6IFwi0KDQvtC30LzRltGB0YLQuNGC0LggUVIt0LrQvtC0INCy0YHQtdGA0LXQtNC40L3RliDQvtCx0LvQsNGB0YLRliDRgdC60LDQvdGD0LLQsNC90L3Rj1wiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcItCf0LXRgNC10LrQvtC90LDQudGC0LXRgdGPLCDRidC+INGDINCy0LDRgSDQtNC+0YHRgtCw0YLQvdGM0L4g0LrQvtGI0YLRltCyINC00LvRjyDRgtGA0LDQvdC30LDQutGG0ZbRlyFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi0JrQvtGA0LjRgdGC0YPQstCw0YfQsCwg0Y/QutC+0LzRgyDQstC4INC90LDQvNCw0LPQsNGU0YLQtdGB0Y8g0L/QtdGA0LXQutCw0LfQsNGC0Lgg0LrQvtGI0YLQuCwg0L3QtSDRltGB0L3Rg9GUIVwiLFxuXHRcIlRSQU5TRkVSX1RFWFRcIjogXCLQktC4INGB0L/RgNCw0LLQtNGWINCx0LDQttCw0ZTRgtC1INC30LTRltC50YHQvdC40YLQuCDQv9C10YDQtdC60LDQtz9cIixcblx0XCJDT05GSVJNQVRJT05cIjogXCLQn9GW0LTRgtCy0LXRgNC00LbQtdC90L3Rj1wiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi0KLRgNCw0L3Qt9Cw0LrRhtGW0Y8g0L/QtdGA0LXQtNCw0L3QsFwiLFxuXHRcIkZFRURcIjogXCLQodGC0YDRltGH0LrQsFwiLFxuXHRcIlRSRU5ESU5HXCI6IFwi0J/QvtC/0YPQu9GP0YDQvdC1XCIsXG5cdFwiSE9UXCI6IFwi0JDQutGC0YPQsNC70YzQvdC1XCIsXG5cdFwiTkVXXCI6IFwi0J3QvtCy0LVcIixcblx0XCJQUk9NT1RFRFwiOiBcItCf0ZbQtNGC0YDQuNC80LDQvdC1XCIsXG5cdFwiVk9URVNcIjogXCLQk9C+0LvQvtGB0LhcIixcblx0XCJQQVlPVVRcIjogXCLQktC40L/Qu9Cw0YLQsFwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi0JrQvtC80LXQvdGC0LDRgNGWXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCLQn9C+0L/Rg9C70Y/RgNC90LUg0LfQsCAzMCDQtNC90ZbQslwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcItCh0L7RgNGC0YPQstCw0YLQuCDQv9C+0LLRltC00L7QvNC70LXQvdC90Y86XCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi0J/QtdGA0ZbQvtC0INCy0LjQv9C70LDRgtC4XCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcItCf0L7RgtC10L3RhtGW0LnQvdCwINCy0LjQv9C70LDRgtCwXCIsXG5cdFwiUEFTVF9QQVlPVVRcIjogXCLQnNC40L3Rg9C70ZYg0LLQuNC/0LvQsNGC0LhcIixcblx0XCJBVVRIT1JfUEFZT1VUXCI6IFwi0JDQstGC0L7RgNGB0YzQutCwINCy0LjQvdCw0LPQvtGA0L7QtNCwXCIsXG5cdFwiQ1VSQVRJT05fUEFZT1VUXCI6IFwi0JrRg9GA0LDRgtC+0YDRgdGM0LrQsCDQstC40L3QsNCz0L7RgNC+0LTQsFwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi0JrQvtC80LXQvdGC0LDRgCDQvtC/0YPQsdC70ZbQutC+0LLQsNC90LjQuSFcIixcblx0XCJQT1NUX0xBVEVSXCI6IFwi0J/QvtGB0YIg0LTQu9GPINC/0L7QtNCw0LvRjNGI0L7RlyDQv9GD0LHQu9GW0LrQsNGG0ZbRlyFcIixcblx0XCJTQVZFRFwiOiBcItCX0LHQtdGA0LXQttC10L3QvlwiLFxuXHRcIkNMRUFSRURcIjogXCLQntGH0LjRidC10L3QvlwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCLQn9C+0LfQvdCw0YfQtdC90L3RjyDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8g0L/RgNCw0L/QvtGA0L7QvCDQvNC+0LbQtSDQstGW0LTQvNGW0L3QuNGC0Lgg0LLQuNC90LDQs9C+0YDQvtC00YMg0YLQsCDQt9GA0L7QsdC40YLQuCDRhtC10Lkg0LzQsNGC0LXRgNGW0LDQuyDQvNC10L3RiCDQv9C+0LzRltGC0L3QuNC80LguIDxicj48YnI+0J/RgNCw0L/QvtGAINGB0LvRltC0INCy0LjQutC+0YDQuNGB0YLQvtCy0YPQstCw0YLQuCDQtNC70Y8g0L3QsNGB0YLRg9C/0L3QuNGFINCy0LjQv9Cw0LTQutGW0LI6IDx1bD48bGk+0KjQsNGF0YDQsNC50YHRgtCy0L4g0LDQsdC+INCf0LvQsNCz0ZbQsNGCPC9saT4gPGxpPtCb0LDQudC60LAg0LDQsdC+INCG0L3RgtC10YDQvdC10YIg0KLRgNC+0LvRltC90LM8L2xpPiA8bGk+0KPQvNC40YHQvdC1INGA0L7Qt9C80ZbRidC10L3QvdGPINC90LUg0LIg0YLRgyDQutCw0YLQtdCz0L7RgNGW0Y4g0LDQsdC+INCh0L/QsNC8PC9saT48L3VsPlwiLFxuXHRcIlJFUVVFU1RfTElNSVRfVEVYVFwiOiBcItCf0LXRgNC10LLQuNGJ0LXQvdC+INC70ZbQvNGW0YIg0LfQsNC/0LjRgtGW0LIuINCf0LXRgNC10LLRltGA0YLQtSDRltC90YjRliDRgtGA0LXQvdC00Lgv0YLQtdCz0LghXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPINCy0LjQtNCw0LvQtdC90L4g0ZbQtyDQt9Cw0LrQu9Cw0LTQvtC6IVwiLFxuXHRcIlBPU1RfSVNfQk9PS01BUktcIjogXCLQn9C+0LLRltC00L7QvNC70LXQvdC90Y8g0LTQvtC00LDQvdC+INCyINC30LDQutC70LDQtNC60LghXCIsXG5cdFwiUkVTRVRcIjogXCLQodC60LjQvdGD0YLQuFwiLFxuXHRcIk1PRElGWV9QSUNUVVJFXCI6IFwi0JfQvNGW0L3QuNGC0Lgg0LfQvtCx0YDQsNC20LXQvdC90Y8g0L/RgNC+0YTRltC70Y5cIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcItCX0LzRltC90LjRgtC4INC80LDQu9GO0L3QvtC6INC+0LHQutC70LDQtNC40L3QutC4XCIsXG5cdFwiQUNUSVZFX0tFWV9SRVFVSVJFRF9URVhUXCI6IFwi0JHRg9C00Ywg0LvQsNGB0LrQsCwg0L3QsNC00LDQudGC0LUg0LDQutGC0LjQstC90LjRhSDQt9Cw0LrRgNC40YLQuNC5INC60LvRjtGHLCDRj9C60YnQviDQstC4INC+0LHRgNCw0LvQuCDRgNC+0LfQs9C+0YDQvdGD0YLQuNC5INGA0LXQttC40Lwg0LDQstGC0L7RgNC40LfQsNGG0ZbRlyFcIixcblx0XCJSRVNFVF9QSUNUVVJFX1RFWFRcIjogXCLQptC1INC/0YDQuNC30LLQtdC00LUg0LTQviDRgdC60LjQtNCw0L3QvdGPINC30L7QsdGA0LDQttC10L3QvdGPINC/0YDQvtGE0ZbQu9GOINC60L7RgNC40YHRgtGD0LLQsNGH0LBcIixcblx0XCJSRVNFVF9DT1ZFUl9QSUNUVVJFX1RFWFRcIjogXCLQptC1INC/0YDQuNC30LLQtdC00LUg0LTQviDRgdC60LjQtNCw0L3QvdGPINC30L7QsdGA0LDQttC10L3QvdGPINC+0LHQutC70LDQtNC40L3QutC4INC60L7RgNC40YHRgtGD0LLQsNGH0LBcIixcblx0XCJVUERBVEVfUkVRVUlSRVNfUkVTVEFSVFwiOiBcItCe0L3QvtCy0LvQtdC90L3RjyDRgdC10YDQstC10YDRgyDQv9C+0YLRgNC10LHRg9GUINC/0LXRgNC10LfQsNC/0YPRgdC60YMhXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcItCd0LDQu9Cw0YjRgtGD0LLQsNC90L3RjyDQvtC90L7QstC70LXQvdC+IVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcItCc0L7QstC4XCIsXG5cdFwiTEFOR1VBR0VTX1RFWFRcIjogXCLQotGD0YIg0LLQuCDQvNC+0LbQtdGC0LUg0LfQvNGW0L3QuNGC0Lgg0LzQvtCy0YMg0LTQvtC00LDRgtC60YMuXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcItCm0Y8g0L7Qv9C10YDQsNGG0ZbRjyDQv9C+0YLRgNC10LHRg9GUINCw0LLRgtC+0YDQuNC30LDRhtGW0Zcg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDQt9CwINC00L7Qv9C+0LzQvtCz0L7RjiDQvtGB0L3QvtCy0L3QvtCz0L4g0L/QsNGA0L7Qu9GOLCDQsNC60YLQuNCy0L3QvtCz0L4v0L/QvtGB0YLQuNC90LMg0LrQu9GO0YfQsC4g0JHRg9C00Ywg0LvQsNGB0LrQsCwg0LDQstGC0L7RgNC40LfRg9C50YLQtdGB0Ywg0YLQsCDQv9C+0LLRgtC+0YDRltGC0Ywg0YHQv9GA0L7QsdGDINGJ0LUg0YDQsNC3LlwiLFxuXHRcIkdBTExFUllcIjogXCLQk9Cw0LvQtdGA0LXRj1wiLFxuXHRcIlRSQU5TTEFUSU9OU1wiOiBcItCQ0LLRgtC+0YDQuCDQv9C10YDQtdC60LvQsNC00YNcIixcblx0XCJTSEFSRVwiOiBcItCf0L7QtNGW0LvQuNGC0LjRgdGPXCIsXG5cdFwiTUFSS0VUUExBQ0VcIjogXCLQoNC40L3QvtC6XCIsXG5cdFwiRVhDSEFOR0VcIjogXCLQntCx0LzRltC9XCIsXG5cdFwiRFJBRlRTXCI6IFwi0KfQtdGA0L3QtdGC0LrQuFwiLFxuXHRcIlBPU1RfSVNfVU5EUkFGVFwiOiBcItCf0L7QstGW0LTQvtC80LvQtdC90L3RjyDQstC40LTQsNC70LXQvdC+INGW0Lcg0YfQtdGA0L3QtdGC0L7QuiFcIixcblx0XCJQT1NUX0lTX0RSQUZUXCI6IFwi0J/QvtCy0ZbQtNC+0LzQu9C10L3QvdGPINC00L7QtNCw0L3QviDQtNC+INGH0LXRgNC90LXRgtC+0LohXCIsXG5cdFwiU1dJUEVfTEVGVFwiOiBcItCT0L7RgNGC0LDQudGC0LUg0LvRltCy0L7RgNGD0YcsINGJ0L7QsSDQv9C10YDQtdCz0LvRj9C90YPRgtC4INC+0L/RhtGW0ZdcIixcblx0XCJNQU5BR0VcIjogXCLQo9C/0YDQsNCy0LvRltC90L3Rj1wiLFxuXHRcIklNQUdFX1JFTU9WRURcIjogXCLQl9C+0LHRgNCw0LbQtdC90L3RjyDQstC40LTQsNC70LXQvdC+XCIsXG5cdFwiQ09QWVwiOiBcItCa0L7Qv9GW0Y7QstCw0YLQuFwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi0JLQuCDRidC1INC90LUg0LfQsNCy0LDQvdGC0LDQttC40LvQuCDQttC+0LTQvdC+0LPQviDQt9C+0LHRgNCw0LbQtdC90L3RjyFcIixcblx0XCJQVUxMX0RPV05fVE9fUkVGUkVTSFwiOiBcItCp0L7QsSDQvtC90L7QstC40YLQuCwg0L/QvtGC0Y/Qs9C90ZbRgtGMINCy0L3QuNC3XCIsXG5cdFwiRVhURVJOQUxfQVBQU1wiOiBcItCX0L7QstC90ZbRiNC90ZYg0LTQvtC00LDRgtC60LhcIixcblx0XCJQTFVHSU5TXCI6IFwi0J/Qu9Cw0LPRltC90LhcIixcblx0XCJTVUdHRVNUXCI6IFwi0J/RgNC+0L/QvtC90YPRlNC80L5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcItCd0LXQt9Cw0LHQsNGA0L7QvFwiLFxuXHRcIkNIQUlOXCI6IFwi0JHQu9C+0LrRh9C10LnQvVwiLFxuXHRcIkNIQUlOX1RFWFRcIjogXCLQotGD0YIg0LLQuCDQvNC+0LbQtdGC0LUg0LfQvNGW0L3QuNGC0Lgg0LHQu9C+0LrRh9C10LnQvSDQsNCx0L4g0LHQsNC30L7QstGDINC/0LvQsNGC0YTQvtGA0LzRgy5cIixcblx0XCJDVVJSRU5DWVwiOiBcItCS0LDQu9GO0YLQsFwiLFxuXHRcIkNVUlJFTkNZX1RFWFRcIjogXCLQotGD0YIg0LLQuCDQvNC+0LbQtdGC0LUg0LfQvNGW0L3QuNGC0Lgg0LLQsNC70Y7RgtGDINC30LAg0LfQsNC80L7QstGH0YPQstCw0L3QvdGP0LwuINCS0LjQvdCw0LPQvtGA0L7QtNCwINC30LAg0L/QvtGB0YIv0LrQvtC80LXQvdGC0LDRgCDQsdGD0LTQtSDQstGW0LTQvtCx0YDQsNC20LDRgtC40YHRjyDQsiDRhtGW0Lkg0LLQsNC70Y7RgtGWLlwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPtCc0L7QttC70LjQstC+0YHRgtGWPC9iPiA8YnI+LdCe0YLRgNC40LzQsNC50YLQtSDQtNC+0YHRgtGD0L8g0LTQviDRg9C90ZbQutCw0LvRjNC90LjRhSDRgdGC0LDRgtC10Lkg0L3QsCDQsdGD0LTRjC3Rj9C60YMg0YbRltC60LDQstGDINC00LvRjyDQktCw0YEg0YLQtdC80YMuIDxicj4gLdCh0L/RltCy0L/RgNCw0YbRjtC50YLQtSDQtyDQsNCy0YLQvtGA0LDQvNC4LCDQutC+0LzQtdC90YLRg9GO0YfQuCDRgtCwINC+0LHQs9C+0LLQvtGA0Y7RjtGH0Lgg0YLQtdC80LguIDxicj7Qk9C+0LvQvtGB0YPQudGC0LUg0LfQsCDQv9GD0LHQu9GW0LrQsNGG0ZbRlywg0YnQvtCxINCy0LjQvdCw0LPQvtGA0L7QtNC40YLQuCDQsNCy0YLQvtGA0LAsINCwINGC0LDQutC+0LYg0LfQsNGA0L7QsdC40YLQuCDQutGD0YDQsNGC0L7RgNGB0YzQutGDINCy0LjQvdCw0LPQvtGA0L7QtNGDLiA8YnI+0J/Rg9Cx0LvRltC60YPQudGC0LUg0LLQsNGI0ZYg0YHRgtCw0YLRgtGWLCDQv9C+0LLRltC00L7QvNC70LXQvdC90Y8g0LIg0LHQu9C+0LfRliDRliDRgNC+0LfQvNGW0YnRg9C50YLQtSDRl9GFINCx0LXQt9C60L7RiNGC0L7QstC90L4sINGJ0L7QsSDQt9Cw0LvRg9GH0LjRgtC4INC/0L7RgdC70ZbQtNC+0LLQvdC40LrRltCyINGC0LAg0L7RgtGA0LjQvNCw0YLQuCDQstC40L3QsNCz0L7RgNC+0LTRgy4gPGJyPtCX0LDQv9C40YHRg9C50YLQtSDRgdGC0LDRgtGC0ZYg0L3QsCDRhdC+0LTRgywg0LfQsdC10YDRltCz0LDQudGC0LUg0LTQtdC60ZbQu9GM0LrQsCDRh9C10YDQvdC10YLQvtC6INC/0L7RgdGC0YMg0LTQu9GPINC/0L7QtNCw0LvRjNGI0L7RlyDQv9GD0LHQu9GW0LrQsNGG0ZbRlyDRgyDQt9GA0YPRh9C90LjQuSDQtNC70Y8g0JLQsNGBINGH0LDRgS4gPGJyPtCU0L7QtNCw0LLQsNC50YLQtSDQtNC+INC30LDQutC70LDQtNC+0Log0YPQu9GO0LHQu9C10L3QuNC5INGB0YLQsNGC0YLRliDRidC+0LEg0L/RgNC+0YfQuNGC0LDRgtC4INGX0YUg0L/RltC30L3RltGI0LUuIDxicj7QntCx0LzRltC90Y7QudGC0LUg0LDQsdC+INC/0LXRgNC10LLQvtC00YzRgtC1INGDINCz0L7RgtGW0LLQutGDINCy0LDRiCDQt9Cw0YDQvtCx0ZbRgtC+0LouIDxicj7Qn9C10YDQtdGB0LjQu9Cw0LnRgtC1INC60L7RiNGC0Lgg0LHRg9C00Ywt0Y/QutC40Lwg0LDQstGC0L7RgNCw0Lwg0LDQsdC+INC60L7RgNC40YHRgtGD0LLQsNGH0LDQvCwg0LTRgNGD0LfRj9C8LCDQv9C+0YHQu9GW0LTQvtCy0L3QuNC60Lgg0YLQvtGJ0L4gPGJyPtCf0ZbQtNC/0LjRgdGD0LnRgtC10YHRjCDQvdCwINGG0ZbQutCw0LLQuNGFINCw0LLRgtC+0YDRltCyLCDQsdC70L7Qs9C10YDRltCyLiA8YnI+IC3QktC40LrQvtGA0LjRgdGC0L7QstGD0LnRgtC1INC30YDRg9GH0L3QuNC5INC/0L7RiNGD0Log0L/QvtGB0LvRltC00L7QstC90LjQutGW0LIg0ZYg0LDQstGC0L7RgNGW0LIsINC90LAg0Y/QutC40YUg0JLQuCDQv9GW0LTQv9C40YHQsNC90ZYuIDxicj7QntGC0YDQuNC80YPQudGC0LUg0YHQv9C+0LLRltGJ0LXQvdC90Y8sINGJ0L7QsSDQt9Cw0LvQuNGI0LDRgtC40YHRjyDQvdCwINC30LIn0Y/Qt9C60YMg0ZbQtyDQv9C+0YHQu9GW0LTQvtCy0L3QuNC60LDQvNC4INGWINGB0L/QvtGB0YLQtdGA0ZbQs9Cw0YLQuCDQt9CwINGA0L7Qt9Cy0LjRgtC60L7QvCDQtNC40YHQutGD0YHRltC5LCDQsiDRj9C60LjRhSDQktC4INC/0YDQuNC50LzQsNGU0YLQtSDRg9GH0LDRgdGC0YwgPGJyPtCS0LjQutC+0YDQuNGB0YLQvtCy0YPQudGC0LUg0L/QvtGI0YPQuiDQv9C+INGG0ZbQutCw0LLQuNC8INGC0LXQs9Cw0Lwv0LrQsNGC0LXQs9C+0YDRltGP0Lwg0YHRgtCw0YLQtdC5LCDQsNCy0YLQvtGA0LDQvC4gPGJyPiAt0J/QtdGA0YHQvtC90LDQu9GW0LfRg9C50YLQtSDQstCw0Ygg0L/RgNC+0YTRltC70YwuIDxicj7QkdCw0LPQsNGC0L4g0L3QvtCy0LjRhSDRhNGD0L3QutGG0ZbQuSDQvtGH0ZbQutGD0ZTRgtGM0YHRjyDQsiDQvNCw0LnQsdGD0YLQvdGM0L7QvNGDLiA8YnI+PGJyPjxiPtCR0LXQt9C/0LXQutCwPC9iPiA8YnI+MS4g0JTQvtC00LDRgtC+0Log0L3QtSDQvNCw0ZQg0LTQvtGB0YLRg9C/0YMg0LDQsdC+INC/0YDQsNCy0LAg0YDQvtC30L/QvtGA0Y/QtNC20LDRgtC40YHRjyDQutC+0YjRgtCw0LzQuCDQutC+0YDQuNGB0YLRg9Cy0LDRh9CwLiA8YnI+Mi4g0JTQvtC00LDRgtC+0Log0L/RgNC+0L/QvtC90YPRlCDQutC70ZbRlNC90YIt0LHQtdC30L/QtdGH0L3RgyDQvNC+0LTQtdC70YwsINC00LUg0LfQsNC60YDQuNGC0ZYg0LrQu9GO0YfRliDQt9Cx0LXRgNGW0LPQsNGO0YLRjNGB0Y8g0LvQvtC60LDQu9GM0L3QviDRliDQvdGW0LrQvtC70Lgg0L3QtSDQvdCw0LTRgdC40LvQsNGO0YLRjNGB0Y8g0LTQviDQsdGD0LTRjC3Rj9C60LjRhSDRgdC10YDQstC10YDRltCyLCDQstC4INGB0LDQvNGWINC90LXRgdC10YLQtSDQstGW0LTQv9C+0LLRltC00LDQu9GM0L3RltGB0YLRjCDQt9Cx0LXRgNC10LbQtdC90L3RjyDRgdCy0L7Rl9GFINC/0LDRgNC+0LvRltCyLiA8YnI+My4g0JTQvtC00LDRgtC+0Log0L/RgNC+0L/QvtC90YPRlCDQv9GA0L7RgdGC0LjQuSwg0L/RgNC40LLQsNCx0LvQuNCy0LjQuSDRltC90YLQtdGA0YTQtdC50YEg0LrQvtGA0LjRgdGC0YPQstCw0YfQsCDRliDQv9C+0LfQuNGC0LjQstC90LjQuSDQtNC+0YHQstGW0LQg0LLQuNC60L7RgNC40YHRgtCw0L3QvdGPLiA8YnI+NC4g0JIg0LTQvtC00LDRgtC60YMg0L/QtdGA0LXQtNCx0LDRh9C10L3QviDQtNC+0LTQsNGC0LrQvtCy0LjQuSDRgNGW0LLQtdC90Ywg0LHQtdC30L/QtdC60Lgg0Lcg0LLQuNC60L7RgNC40YHRgtCw0L3QvdGP0LwgcGluLdC60L7QtNGDLiA8YnI+PGJyPiBlU3RlZW0g0L/RltC00YLRgNC40LzRg9GUINC/0LvQsNGC0YTQvtGA0LzQuCBTdGVlbSDRgtCwIEdvbG9zLiA8YnI+XCIsXG5cdFwiRk9VTkRFUlwiOiBcItCX0LDRgdC90L7QstC90LjQuiDRgtCwINC/0YDQvtCy0ZbQtNC90LjQuSDRgNC+0LfRgNC+0LHQvdC40LpcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcItCU0L7QtNCw0YLQuCDQsNC60LDRg9C90YJcIixcblx0XCJQTEFURk9STVwiOiBcItCf0LvQsNGC0YTQvtGA0LzQsFwiLFxuXHRcIkVTQ1JPV1wiOiBcIkVzY3Jvd1wiLFxuXHRcIkVTQ1JPV19BR0VOVFwiOiBcItCQ0LPQtdC90YIg0YPQs9C+0LTQuFwiLFxuXHRcIlJBVElGSUNBVElPTl9ERUFETElORVwiOiBcItCa0ZbQvdGG0LXQstC40Lkg0YLQtdGA0LzRltC9INGA0LDRgtC40YTRltC60LDRhtGW0ZdcIixcblx0XCJFU0NST1dfRVhQSVJBVElPTlwiOiBcItCi0LXRgNC80ZbQvSDQtNGW0Zcg0YPQs9C+0LTQuFwiLFxuXHRcIkVTQ1JPV19GRUVcIjogXCLQmtC+0LzRltGB0ZbRjyDQt9CwINGD0LPQvtC00YNcIixcblx0XCJFU0NST1dfVEVSTVNcIjogXCLQo9C80L7QstC4INGD0LPQvtC00LhcIixcblx0XCJOSUdIVF9NT0RFXCI6IFwi0J3RltGH0L3QuNC5INGA0LXQttC40LxcIixcblx0XCJEQVlfTU9ERVwiOiBcItCU0LXQvdC90LjQuSDRgNC10LbQuNC8XCIsXG5cdFwiVklFV19DT05URVhUXCI6IFwi0J/QtdGA0LXQs9C70Y/QvdGD0YLQuCDQv9C+0LLQvdC40Lkg0LrQvtC90YLQtdC60YHRglwiLFxuXHRcIlVTRVJfTk9URk9VTkRcIjogXCLQmtC+0YDQuNGB0YLRg9Cy0LDRh9CwINC90LUg0LfQvdCw0LnQtNC10L3QvlwiLFxuXHRcIkFQUFJPVkVcIjogXCLQl9Cw0YLQstC10YDQtNC40YLQuFwiLFxuXHRcIkRJU1BVVEVcIjogXCLQodGD0L/QtdGA0LXRh9C60LBcIixcblx0XCJSRUxFQVNFXCI6IFwi0KDQtdC70ZbQt1wiLFxuXHRcIkZST01cIjogXCLQktGW0LRcIixcblx0XCJJRFwiOiBcIklEXCIsXG5cdFwiU1VCTUlUXCI6IFwi0JLRltC00L/RgNCw0LLQuNGC0LhcIixcblx0XCJSRUNFSVZFUlwiOiBcItCe0YLRgNC40LzRg9Cy0LDRh1wiLFxuXHRcIkxPQ0FUSU9OXCI6IFwi0JzRltGB0YbQtdC30L3QsNGF0L7QtNC20LXQvdC90Y9cIixcblx0XCJXRUJTSVRFXCI6IFwi0JLQtdCxLdGB0YLQvtGA0ZbQvdC60LBcIixcblx0XCJESVNQTEFZX05BTUVcIjogXCLQktGW0LTQvtCx0YDQsNC20YPQstCw0L3QtSDRltC8J9GPXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIummlumhtVwiLFxuXHRcIkxPR0lOXCI6IFwi55m75b2VXCIsXG5cdFwiTE9HT1VUXCI6IFwi6YCA5Ye6XCIsXG5cdFwiUFJPRklMRVwiOiBcIueugOS7i1wiLFxuXHRcIkZPTExPV1wiOiBcIuWFs+azqFwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIuS5puetvlwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi6L2s6LSmXCIsXG5cdFwiTUFSS0VUXCI6IFwi5biC5Zy6XCIsXG5cdFwiU0VUVElOR1NcIjogXCLorr7nva5cIixcblx0XCJBQk9VVFwiOiBcIuWFs+S6jlwiLFxuXHRcIkFCT1VUXzFcIjogXCLlnKjov5nph4zku7vkvZXkurrpg73lj6/ku6XpnaDotKHnjK7lhoXlrrnotZrpkrHvvIFcIixcblx0XCJBQk9VVF8yXCI6IFwi55Sxe3twbGF0Zm9ybW5hbWV9feW5s+WPsOaPkOS+m+OAguW6lOeUqOeoi+W6j+WIm+W7uueUsVwiLFxuXHRcIkFCT1VUXzNcIjogXCLlroPkvZzkuLrlvIDmupDjgIHnpL7ljLrpqbHliqjnp7vliqjnq6/pobnnm67vvIzmj5DkvpvlhoXlrrnorr/pl67nlKjkuo7pmIXor7vjgIHor4TorrrjgIHmipXnpajjgIHlj5HooajjgIHovazotKbmlLbnm4rnrYnlip/og73jgILnlLF7e3BsYXRmb3JtbmFtZX195Yy65Z2X6ZO+5ZKMe3tzaXRlbmFtZX195o+Q5L6b5Yqf6IO944CCXCIsXG5cdFwiQUJPVVRfNFwiOiBcIjEu5bqU55So56iL5bqP5rC45LiN6K6/6Zeu5oiW5oyB5pyJ55So5oi36YeR6ZKx44CCXCIsXG5cdFwiQUJPVVRfNVwiOiBcIjIuIOW6lOeUqOeoi+W6j+aPkOS+m+WuouaIt+err+WuieWFqOaooeWei++8jOengemSpeS/neWtmOWcqOacrOWcsO+8jOawuOS4jeWPkemAgee7meS7u+S9leacjeWKoeWZqFwiLFxuXHRcIkFCT1VUXzZcIjogXCIzLuW6lOeUqOeoi+W6j+aPkOS+m+eugOWNleWFt+acieWQuOW8leWKm+eahOeUqOaIt+aOpeWPo+S7peWPiuS9k+mqjOOAglwiLFxuXHRcIkFCT1VUXzdcIjogXCI0LuW6lOeUqOeoi+W6j+awuOS4jeimgeaxgueUqOaIt+i+k+WFpeS7u+S9leS4quS6uuS/oeaBr1wiLFxuXHRcIkFCT1VUXzhcIjogXCLmipXnpaggZ29vZC1rYXJtYSDkvZzkuLrop4Hor4HkurpcIixcblx0XCJBQk9VVF85XCI6IFwi6IGU57O7L+WPjemmiFwiLFxuXHRcIkFCT1VUXzEwXCI6IFwi5pu05aSa5L+h5oGvXCIsXG5cdFwiUkVNT1ZFXCI6IFwi56e76ZmkXCIsXG5cdFwiTUFSS0VUX1ZJRVdcIjogXCLluILlnLrop4Llr59cIixcblx0XCJQUklDRVwiOiBcIuS7t+agvFwiLFxuXHRcIkFNT1VOVFwiOiBcIuaVsOmHj1wiLFxuXHRcIlRPVEFMXCI6IFwi5oC75YWxXCIsXG5cdFwiTk9PUkRFUlNcIjogXCLmsqHmnInorqLljZVcIixcblx0XCJEQVRFXCI6IFwi5pel5pyfXCIsXG5cdFwiQlVZXCI6IFwi5LmwXCIsXG5cdFwiU0VMTFwiOiBcIuWNllwiLFxuXHRcIk9QRU5cIjogXCLlvIDmlL5cIixcblx0XCJISVNUT1JZXCI6IFwi5Y6G5Y+yXCIsXG5cdFwiRk9MTE9XX0JBQ0tcIjogXCLlhbPms6jlm55cIixcblx0XCJGT0xMT1dFRFwiOiBcIuW3suWFs+azqFwiLFxuXHRcIlVORk9MTE9XXCI6IFwi5Y+W5raI5YWz5rOoXCIsXG5cdFwiRk9MTE9XSU5HXCI6IFwi5YWz5rOoXCIsXG5cdFwiRk9MTE9XRVJTXCI6IFwi57KJ5LidXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0VSU1wiOiBcIuaQnOe0oueyieS4nVwiLFxuXHRcIlNFQVJDSF9GT0xMT1dJTkdcIjogXCLmkJzntKLlhbPms6hcIixcblx0XCJCWVwiOiBcIueUsVwiLFxuXHRcIklOXCI6IFwi5ZyoXCIsXG5cdFwiTUVOVVwiOiBcIuiPnOWNlVwiLFxuXHRcIkJPT0tNQVJLXCI6IFwi5Lmm562+XCIsXG5cdFwiUkVCTE9HXCI6IFwi6L2s5Y+RXCIsXG5cdFwiVVBWT1RFXCI6IFwi6LWe5oiQ56WoXCIsXG5cdFwiRE9XTlZPVEVcIjogXCLlj43lr7nnpahcIixcblx0XCJVTlZPVEVfRE9XTlZPVEVEXCI6IFwi5Y+W5raI5Y+N5a+556WoXCIsXG5cdFwiVU5WT1RFX1VQVk9URURcIjogXCLlj5bmtojotZ7miJDnpahcIixcblx0XCJSRVBMWVwiOiBcIuWbnuWkjVwiLFxuXHRcIkVESVRcIjogXCLnvJbovpFcIixcblx0XCJQT1NUXzFcIjogXCLlnKjor4TorrrkuIrlkJHlt6bmu5HliqjmnaXmn6XnnIvpgInpoblcIixcblx0XCJQT1NUXzJcIjogXCLlnKjor4TorrrkuIrngrnlh7vmnaXmn6XnnIvlrZDor4TorrpcIixcblx0XCJPUFRJT05TXCI6IFwi6YCJ6aG5XCIsXG5cdFwiUkVTVEVFTUVEX0JZXCI6IFwi6L2s5Y+R55SxXCIsXG5cdFwiTk9USElOR19IRVJFXCI6IFwi6L+Z6L+Y5LuA5LmI6YO95rKh5pyJLi4uXCIsXG5cdFwiQkFMQU5DRVNcIjogXCLkvZnpop1cIixcblx0XCJQUk9GSUxFXzFcIjogXCJ7e3BsYXRmb3JtbmFtZX19LCDlj6/kuqTmmJPku6PluIHlj6/ku6Xpmo/ml7bovaznp7suIHt7cGxhdGZvcm1uYW1lfX0g5Y+v5Lul6YCa6L+H5Y+r5YGa5YWF6IO955qE6L+H56iL6KKr6L2s5o2i5Li6e3twbGF0Zm9ybXBvd2VyfX3jgIJcIixcblx0XCJQUk9GSUxFXzJcIjogXCJ7e3BsYXRmb3JtcG93ZXJ9fSwg5b2x5ZON5Yqb5Luj5biB55So5LqO6ZW/5pyf5oyB5pyJ5Lul5Y+K57uZ5paH56ug5oqV56Wo44CC5oyB5pyJ55qE6LaK5aSa6LaK6IO95b2x5ZON5LuW5Lq655qE6LWP6YeR5Lul5Y+K6YCa6L+H5q2j56Gu5Zyw5oqV56Wo6I635b6X5aWW5Yqx44CCXCIsXG5cdFwiUFJPRklMRV8zXCI6IFwi5Luj5biB5aSn5qaC5YC8e3twbGF0Zm9ybXN1bml0fX0ge3twbGF0Zm9ybW5hbWV9fVwiLFxuXHRcIkVTVElNQVRFRF9WQUxVRVwiOiBcIuS8sOiuoeS7t+WAvFwiLFxuXHRcIlBST0ZJTEVfNFwiOiBcIuS8sOiuoeS7t+WAvOWfuuS6jnt7cGxhdGZvcm1uYW1lfX3nmoQ35pel5bmz5Z2H5YC8XCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIuS6pOaYk+WOhuWPslwiLFxuXHRcIlBPU1RJTkdcIjogXCLlj5HluINcIixcblx0XCJQUk9GSUxFXzVcIjogXCLlj5HluIPlr4bpkqXnlKjkuo7lj5Hooajmlofnq6Dku6Xlj4rmipXnpajvvIzlroPlupTor6XkuI3lkIzkuo7mtLvliqjlr4bpkqXku6Xlj4rmiYDmnInogIXlr4bpkqXjgIJcIixcblx0XCJPV05FUlwiOiBcIuaJgOacieiAhVwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIuaJgOacieiAheWvhumSpeaYr+W4kOaIt+S4u+WvhumSpe+8jOW9k+S/ruaUueWFtuWug+WvhumSpeaXtumcgOimgeaPkOS+m+OAguaJgOacieiAheWvhumSpeeahOengemSpeaIluWvhueggeW6lOWwveWPr+iDveWcsOemu+e6v+S/neeuoeOAglwiLFxuXHRcIkFDVElWRVwiOiBcIua0u+WKqFwiLFxuXHRcIlBST0ZJTEVfN1wiOiBcIua0u+WKqOWvhumSpeeUqOS6juWPkei1t+i9rOi0puS7peWPiuWcqOWGhemDqOW4guWcuuS4i+WNlVwiLFxuXHRcIk1FTU9cIjogXCLlpIfms6hcIixcblx0XCJQUk9GSUxFXzhcIjogXCLlpIfms6jlr4bpkqXnlKjkuo7liJvlu7rlkozpmIXor7vlpIfms6hcIixcblx0XCJCTE9HXCI6IFwi5Y2a5a6iXCIsXG5cdFwiUE9TVFNcIjogXCLmlofnq6BcIixcblx0XCJSRVBMSUVTXCI6IFwi5Zue5aSNXCIsXG5cdFwiV0FMTEVUXCI6IFwi6ZKx5YyFXCIsXG5cdFwiVEFHXCI6IFwi5qCH562+XCIsXG5cdFwiVVNFUlwiOiBcIueUqOaIt1wiLFxuXHRcIkNMT1NFXCI6IFwi5YWz6ZetXCIsXG5cdFwiVE9cIjogXCLliLBcIixcblx0XCJBU1NFVFwiOiBcIui1hOS6p1wiLFxuXHRcIlNFTkRcIjogXCLlj5HpgIFcIixcblx0XCJTRUNVUklUWVwiOiBcIuWuieWFqFwiLFxuXHRcIkFWQUlMQUJMRVwiOiBcIuWPr+eUqFwiLFxuXHRcIlBVQkxJQ19NRU1PXCI6IFwi5YWs5YWx5aSH5rOoXCIsXG5cdFwiVE9fREVTQ1wiOiBcIueUqOaItyAo5L6L5aaCOmdvb2Qta2FybWEpXCIsXG5cdFwiUElOX0NPREVcIjogXCJQaW4g56CBXCIsXG5cdFwiUElOX1RFWFRcIjogXCJQSU7noIHluK7liqnkvaDkv53miqTlupTnlKjlkozmlbDmja7lronlhajjgII8YnIvPjxici8+PGI+5rOo5oSPOjwvYj7kuIDml6blkK/nlKjvvIzkvaDmnIDlpJrlsJ3or5Xop6PplIE05qyh77yM5aaC5p6c5b+Y6K6w5oiW5aSx6LSl77yM5bqU55So56iL5bqP5bCG56e76Zmk5bey55m76ZmG55So5oi35pWw5o2u44CC5L2g5Y+v5Lul6YeN5paw55m76ZmG5bm257un57ut5L2/55So5bqU55So56iL5bqP44CCXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIumAmuefpVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIuW9k+acieS6uue7meS9oOeahOWGheWuueaKleelqOaXtu+8jOS9oOWwhuW+l+WIsOmAmuefpe+8gTxici8+IDxiPuazqOaEjzo8L2I+IOmAmuefpeWMheaLrOaKleelqOadg+mHjeS7peWPiuaPkOmGkuS/oeaBr+OAgiAo6LWe5oiQ56WoLCDlj43lr7nnpagsIOWPlua2iOaKleelqCkuIFwiLFxuXHRcIlZPVEVcIjogXCLmipXnpahcIixcblx0XCJDT01NRU5UX1RFWFRcIjogXCLlvZPmnInkurror4TorrrkvaDnmoTmlofnq6DmiJbor4Torrrml7bvvIzkvaDlsIblvpfliLDpgJrnn6XvvIE8Yj7ms6jmhI86PC9iPiDpgJrnn6XkuZ/ljIXmi6zliKvkuro8Yj7nvJbovpE8L2I+5LuW5Lus55qE6K+E6K66LiBcIixcblx0XCJDT01NRU5UXCI6IFwi6K+E6K66XCIsXG5cdFwiRk9MTE9XX1RFWFRcIjogXCLlvZPku5bkurrlhbPms6jkvaDmiJblj5bmtojlhbPms6jml7bkvaDlsIbojrflvpfpgJrnn6XvvIFcIixcblx0XCJNRU5USU9OU1wiOiBcIuaPkOWPilwiLFxuXHRcIk1FTlRJT05TX1RFWFRcIjogXCLlvZPku5bkurrlnKjmlofnq6DmiJbor4TorrrkuK3mj5Dlj4rkvaDvvIzkvaDlsIblvpfliLDpgJrnn6XvvIFcIixcblx0XCJSRVNURUVNXCI6IFwi6L2s5Y+RXCIsXG5cdFwiUkVTVEVFTV9URVhUXCI6IFwi5b2T5LuW5Lq66L2s5Y+R5L2g55qE5paH56ug5pe277yM5L2g5bCG5b6X5Yiw6YCa55+l77yBXCIsXG5cdFwiQ09ORklHVVJBVElPTlNcIjogXCLphY3nva5cIixcblx0XCJWT1RJTkdcIjogXCLmipXnpajkuK1cIixcblx0XCJWT1RJTkdfVEVYVFwiOiBcIuaKleelqOadg+mHjeaIlueZvuWIhuavlOW9seWTjUFQUOS4reaKleelqOWogeWKm++8jOS9oOWPr+S7peeUqOS6juiwg+iKguS9oOeahOaKleelqOaUtuebiuOAgjxici8+PGJyLz48Yj7ms6jmhI86PC9iPiDov5nkuZ/lsIbmm7TmlLnmipXlj43lr7nnpajnmoTmnYPph40v55m+5YiG5q+U5bm25LiU5pW05LiqQVBQ6IyD5Zu05YaF5pyJ5pWILlwiLFxuXHRcIlNFUlZFUlwiOiBcIuacjeWKoeWZqFwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwi5o6o6I2QXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwi5L+d5a2Y5L+u5pS5XCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCLmipXnpajogIXkv6Hmga9cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCLmrKLov47lvZLmnaXvvIFcIixcblx0XCJMT0dJTl8xXCI6IFwi5L2/55So55So5oi35ZCN5a+G56CB55m76ZmG5ZCO57un57utXCIsXG5cdFwiTE9HSU5fMlwiOiBcIuWPkeW4g+WvhumSpeeUqOS6juWPkeihqOaWh+eroOOAgeivhOiuuuOAgeaKleelqOOAgeS7peWPiuWFs+azqOS7luS6ulwiLFxuXHRcIkxPR0lOXzNcIjogXCLmtLvliqjlr4bpkqXnlKjkuo7ovazotKbku6Xlj4rmm7TmlrDotYTmlpnlm77niYfjgIJcIixcblx0XCJMT0dJTl80XCI6IFwi55So5oi35Yet6K+B5L+d5a2Y5Zyo6K6+5aSH5pys5Zyw77yM6YCA5Ye65ZCO5Yet6K+B5Lya6KKr56e76Zmk77yBXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi6L+Y5rKh5pyJ6LSm5oi377yfXCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCLnq4vljbPms6jlhoxcIixcblx0XCJDQU5DRUxcIjogXCLlj5bmtohcIixcblx0XCJBRFZBTkNFRFwiOiBcIumrmOe6p+eahFwiLFxuXHRcIkFDVElWRV9QUklLRVlcIjogXCLmtLvliqjnp4HpkqVcIixcblx0XCJQT1NUSU5HX1BSSUtFWVwiOiBcIuWPkeW4g+engemSpVwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwi5Li75a+G56CBXCIsXG5cdFwiVVNFUk5BTUVcIjogXCLnlKjmiLflkI1cIixcblx0XCJDQVJEX1ZJRVdcIjogXCLljaHniYfop4blm75cIixcblx0XCJDT01QQUNUX1ZJRVdcIjogXCLntKflh5Hop4blm75cIixcblx0XCJTRUFSQ0hcIjogXCLmkJzntKJcIixcblx0XCJTVUJNSVRfQV9TVE9SWVwiOiBcIuaPkOS6pOaVheS6i1wiLFxuXHRcIlJFUExZVE9cIjogXCLlm57lpI3nu5lcIixcblx0XCJQT1NUXCI6IFwi5Y+R5biDXCIsXG5cdFwiUFJFVklFV1wiOiBcIumihOiniFwiLFxuXHRcIkRFRkFVTFRcIjogXCLpu5jorqQgNTAlIC8gNTAlXCIsXG5cdFwiUE9XRVJVUFwiOiBcIjEwMCUg5YWF6IO9XCIsXG5cdFwiREVDTElORV9QQVlPVVRcIjogXCLmi5Lnu53lpZbph5FcIixcblx0XCJTQVZFX0ZPUl9MQVRFUlwiOiBcIueVmeW+heS7peWQjlwiLFxuXHRcIkNMRUFSXCI6IFwi5riF6ZmkXCIsXG5cdFwiUE9TVF9DT05URU5UXCI6IFwi5paH56ug5YaF5a65XCIsXG5cdFwiQ09NTUVOVF9DT05URU5UXCI6IFwi6K+E6K665YaF5a65XCIsXG5cdFwiVElUTEVcIjogXCLmoIfpophcIixcblx0XCJUQUdTXCI6IFwi5qCH562+XCIsXG5cdFwiTk9UX01BVENIXCI6IFwi5LiN5Yy56YWNXCIsXG5cdFwiQ09ORklSTV9QSU5cIjogXCLnoa7orqQgUElOXCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi6ZSZ6K+v55qEXCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi5q2j5Zyo5omT5byA5paH56ugXCIsXG5cdFwiU0VUX1BJTlwiOiBcIuiuvue9riBQSU5cIixcblx0XCJFTlRFUl9QSU5cIjogXCLovpPlhaUgUElOXCIsXG5cdFwiQVJFX1lPVV9TVVJFXCI6IFwi5L2g56Gu5a6a5ZCX77yfXCIsXG5cdFwiUkVCTE9HX1RFWFRcIjogXCLovazlj5HkuI3lj6/pgIbvvIzmmK/lkKbnu6fnu63vvJ9cIixcblx0XCJCUk9BRENBU1RfRVJST1JcIjogXCLlub/mkq3plJnor6/vvIzor7fph43or5XvvIFcIixcblx0XCJTVUNDRVNTXCI6IFwi5oiQ5YqfXCIsXG5cdFwiUkVCTE9HR0VEX1BPU1RcIjogXCLovazlj5HnmoTmlofnq6BcIixcblx0XCJMT0dJTl9GQUlMXCI6IFwi55m76ZmG5aSx6LSl77yB5aaC5p6c6YCJ5oup6auY57qn5qih5byP77yM6K+356Gu6K6k5L2/55So5Li75a+G56CB55m76ZmG5oiW5Zyo55m76ZmG5pe25o+Q5L6b5Y+R5biD56eB6ZKl44CCXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwi55m76ZmG5aSx6LSl77yB5aaC5p6c6YCJ5oup6auY57qn5qih5byP77yM6K+356Gu6K6k5L2/55So5Li75a+G56CB55m76ZmG5oiW5Zyo55m76ZmG5pe25o+Q5L6b5Y+R5biD56eB6ZKl44CCXCIsXG5cdFwiV0FSTklOR1wiOiBcIuitpuWRilwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLmipXnpajnu5nop4Hor4HkurpcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIuW3suaKleelqOe7meingeivgeS6ulwiLFxuXHRcIkFHT1wiOiBcIuS7peWJjVwiLFxuXHRcIkZST01fTk9XXCI6IFwi5LuO546w5Zyo5byA5aeLXCIsXG5cdFwiU0VDU1wiOiBcIuenklwiLFxuXHRcIkFfTUlOXCI6IFwi5LiA5YiG6ZKfXCIsXG5cdFwiTUlOU1wiOiBcIuWIhumSn1wiLFxuXHRcIkFOX0hPVVJcIjogXCLkuIDlsI/ml7ZcIixcblx0XCJIT1VSU1wiOiBcIuWwj+aXtlwiLFxuXHRcIkFfREFZXCI6IFwi5LiA5aSpXCIsXG5cdFwiREFZU1wiOiBcIuWkqVwiLFxuXHRcIkFfTU9OVEhcIjogXCLkuIDmnIhcIixcblx0XCJNT05USFNcIjogXCLmnIhcIixcblx0XCJBX1lFQVJcIjogXCLkuIDlubRcIixcblx0XCJZRUFSU1wiOiBcIuW5tFwiLFxuXHRcIk1JTl9SRUFEXCI6IFwi5YiG6ZKf6ZiF6K+7XCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIuWPjeWvueelqFwiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIuaNleiOt+WbvueJh1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwi6YCJ5oup5Zu+54mHXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLorr7nva7oh6rlrprkuYlVUkxcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIuaPkuWFpeWbvueJh1wiLFxuXHRcIkVSUk9SXCI6IFwi6ZSZ6K+vXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi5LiK5Lyg6ZSZ6K+vXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIuebuOacuuW3suWPlua2iFwiLFxuXHRcIlNFVF9VUkxcIjogXCLorr7nva5VUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi5Zu+54mH55qE55u05o6l572R57uc6ZO+5o6lXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCLor4Torrrlt7Lmj5DkuqRcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIuWIoOmZpOivhOiuuuaYr+S4jeWPr+mAhueahC4uLlwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIuivhOiuuuW3suWIoOmZpFwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi5Zu+54mH5LiK5Lyg5LitXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIuS4iuS8oOWujOaIkFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLkuIrkvKDlpLHotKVcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLnlKjmiLflkI3miJblr4bnoIHkuI3lr7lcIixcblx0XCJJTkZPXCI6IFwi5L+h5oGvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIuivt+WwhuS6jOe7tOeggeahhuWFpeaJq+aPj+WMuuWfn1wiLFxuXHRcIkJBTEFOQ0VfVEVYVFwiOiBcIuivt+ehruiupOS9oOaciei2s+Wkn+eahOS9memineeUqOS6jui9rOi0pu+8gVwiLFxuXHRcIk5PTkVYSVNUX1VTRVJcIjogXCLkvaDovazotKbnmoTnm67moIfnlKjmiLfkuI3lrZjlnKjvvIFcIixcblx0XCJUUkFOU0ZFUl9URVhUXCI6IFwi5piv5ZCm56Gu6K6k6L2s6LSm77yfXCIsXG5cdFwiQ09ORklSTUFUSU9OXCI6IFwi56Gu6K6kXCIsXG5cdFwiVFhfQlJPQURDQVNURURcIjogXCLkuqTmmJPlt7Llub/mkq1cIixcblx0XCJGRUVEXCI6IFwi6K+d6aKYXCIsXG5cdFwiVFJFTkRJTkdcIjogXCLotovlkJFcIixcblx0XCJIT1RcIjogXCLng63ngrlcIixcblx0XCJORVdcIjogXCLmlrDnmoRcIixcblx0XCJQUk9NT1RFRFwiOiBcIuaOqOmUgFwiLFxuXHRcIlZPVEVTXCI6IFwi56WoXCIsXG5cdFwiUEFZT1VUXCI6IFwi5aWW6YeRXCIsXG5cdFwiQ09NTUVOVFNcIjogXCLor4TorrpcIixcblx0XCJUUkVORElOR18zMFwiOiBcIjMw5pel6LaL5ZCRXCIsXG5cdFwiU09SVF9QT1NUX0JZXCI6IFwi5o6S5bqP5oyJ77yaXCIsXG5cdFwiUEFZT1VUX0NZQ0xFXCI6IFwi5pSv5LuY5ZGo5pyfXCIsXG5cdFwiUE9URU5USUFMX1BBWU9VVFwiOiBcIua9nOWcqOWllumHkVwiLFxuXHRcIlBBU1RfUEFZT1VUXCI6IFwi6L+H5Y6755qE5aWW6YeRXCIsXG5cdFwiQVVUSE9SX1BBWU9VVFwiOiBcIuS9nOiAheWllumHkVwiLFxuXHRcIkNVUkFUSU9OX1BBWU9VVFwiOiBcIuebkeaKpOS6uuWllumHkVwiLFxuXHRcIlBPU1RfU1VCTUlUVEVEXCI6IFwi5paH56ug5bey5o+Q5Lqk77yBXCIsXG5cdFwiUE9TVF9MQVRFUlwiOiBcIuaWh+eroOeVmeW+heS7peWQjuaPkOS6pO+8gVwiLFxuXHRcIlNBVkVEXCI6IFwi5bey5L+d5a2YXCIsXG5cdFwiQ0xFQVJFRFwiOiBcIuW3sua4hemZpFwiLFxuXHRcIkZMQUdHSU5HX1RFWFRcIjogXCLnu5nmlofnq6DmipXlj43lr7nnpajkvJrnp7vpmaTmlLbnm4rlubbpmY3kvY7mnZDmlpnnmoTlj6/op4HmgKfjgII8YnI+PGJyPuWPjeWvueelqOeUqOS6juS7peS4i+WcuuaZr++8mjx1bD48bGk+5byE6Jma5L2c5YGH5oiW5Ym956qDPC9saT48bGk+5LuH5oGo6KiA6K665oiW572R57uc6ZKT6bG8PC9saT48bGk+5pWF5oSP5pS+6ZSZ57G755uu5YaF5a655oiW6ICFU1BBTTwvbGk+PC91bD5cIixcblx0XCJSRVFVRVNUX0xJTUlUX1RFWFRcIjogXCLovr7liLDor7fmsYLpmZDliLbjgILmo4Dmn6Xlhbbku5botovlir8v5qCH562+77yBXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi5paH56ug5bey5LuO5Lmm562+5YaF56e76Zmk77yBXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIuaWh+eroOW3sue7j+WKoOWFpeS5puetvu+8gVwiLFxuXHRcIlJFU0VUXCI6IFwi6YeN572uXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLnvJbovpHotYTmlpnlm77niYdcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIuS/ruaUueWwgemdouWbvueJh1wiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIuWmguaenOS9oOmAieS4remrmOe6p+eZu+mZhuaooeW8j++8jOivt+aPkOS+m+a0u+WKqOengemSpe+8gVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIui/meWwhumHjee9rueUqOaIt+i1hOaWmeWbvueJh1wiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIui/meWwhumHjee9rueUqOaIt+WwgemdouWbvueJh1wiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwi5pyN5Yqh5Zmo5pu05paw6ZyA6KaB6YeN5ZCvXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIuiuvue9ruW3suabtOaWsFwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIuivreiogFwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi5L2g5Y+v5Lul5Zyo6L+Z5L+u5pS55q2k5bqU55So6K+t6KiA44CCXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIuatpOmhueaTjeS9nOimgeaxgueUqOaIt+S9v+eUqOS4u+Wvhuegge+8jOa0u+WKqC/lj5HluIPlr4bpkqXjgILor7fnmbvpmYblubbph43or5XjgIJcIixcblx0XCJHQUxMRVJZXCI6IFwi5Zu+5bqTXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi57+76K+R6LSh54yu6ICFXCIsXG5cdFwiU0hBUkVcIjogXCLliIbkuqtcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIuW4guWculwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwi5Lqk5piT5omAXCIsXG5cdFwiRFJBRlRTXCI6IFwi6I2J56i/XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi5paH56ug5bey5LuO6I2J56i/5YaF56e76Zmk77yBXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIuaWh+eroOW3sue7j+WKoOWFpeiNieeov++8gVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLlkJHlt6bmu5Hliqjmn6XnnIvpgInpoblcIixcblx0XCJNQU5BR0VcIjogXCLnrqHnkIZcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwi5Zu+5YOP5bey5Yig6ZmkXCIsXG5cdFwiQ09QWVwiOiBcIuWkjeWItlwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi5L2g6L+Y5rKh5pyJ5LiK5Lyg5Lu75L2V5Zu+54mH77yBXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLkuIvmi4nliLfmlrBcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi5aSW6YOo5bqU55SoXCIsXG5cdFwiUExVR0lOU1wiOiBcIuaPkuS7tlwiLFxuXHRcIlNVR0dFU1RcIjogXCLlu7rorq5cIixcblx0XCJDT01JTkdfU09PTlwiOiBcIuWNs+WwhuWIsOadpVwiLFxuXHRcIkNIQUlOXCI6IFwi6ZO+XCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIuWcqOedgOS9oOWPr+S7peS/ruaUueWMuuWdl+mTvuaIlum7mOiupOW5s+WPsFwiLFxuXHRcIkNVUlJFTkNZXCI6IFwi6LSn5biBXCIsXG5cdFwiQ1VSUkVOQ1lfVEVYVFwiOiBcIuWcqOi/memHjO+8jOaCqOWPr+S7peabtOaUueaCqOeahOm7mOiupOW4geenjeOAguS9oOS8mueci+WIsOi/meenjei0p+W4geW4luWlluWKseWAvOOAglwiLFxuXHRcIkFCT1VUXzExXCI6IFwiPGJyPjxiPuWKn+iDveWIl+ihqDwvYj4gPGJyPuiuv+mXrueLrOeJueaWh+eroOS4reeahOS7u+S9leS4u+mimOS9oOacieWFtOi2o+ivu+OAgiA8YnI+LeWQjOS9nOiAheeahOivhOiuuu+8jOiuqOiuuueahOivnemimOOAgjxicj7mipXnpajkuLrlpZblirHkvZzogIXlkZjpop3vvIzku6Xlj4rojrflvpfnsr7pgInnmoTlpZblirHjgII8YnI+5Y+R5biD5L2g55qE5paH56ug77yM5Y2a5a6i5ZKM5YWN6LS55pS25a655LuW5Lus6LWa5Y+W5oql6YWs6L+b6KGM5ZKM6I635b6X55qE6L+96ZqP6ICF44CCPGJyPi3lhpnkuIvljrvvvIzkv53lrZjlpJrkuKrojYnnqL/lkZjpop3vvIzlhbblkI7lj5HooajnmoTmlofnq6DjgII8YnI+5Lmm562+5Zac5qyi55qE5paH56ug77yM5Lul5L6/5Lul5ZCO6ZiF6K+744CCPGJyPuS6pOaNouaIlueOsOmHkeaUr+S7mOS9oOeahOaUtuWFpeOAgjxicj4t5Y+R6YCB5oKo55qE6LWE6YeR5Yiw5Lu75L2V5L2c6ICF5oiW55So5oi344CBIOaci+WPi+OAgSDnsonkuJ3nrYkgPGJyPui3n+maj+aciei2o+eahOS9nOiAhe+8jOWNmuWuouOAgiA8YnI+LeaQnOe0ouaCqOeahOi/vemaj+iAheWSjOS9nOiAheS9oOWmguS4i+OAgjxicj7lvpfliLDpgJrnn6XvvIzkv53mjIHkvaDnmoTov73pmo/ogIXlkozorqjorrrkvaDmmK/mtonlj4rnmoToi7Hlr7ggPGJyPuaQnOe0ouS4uuexu+WIq+eahOeJqeWTge+8jOS9nOiAheaciei2o+agh+etvuOAgiA8YnI+LeS4quaAp+WMluaCqOeahOmFjee9ruaWh+S7tuOAgjxicj7lpJrmm7TlpJrnmoTlip/og73mnaXjgII8YnI+PGJyPjxiPuWuieWFqDwvYj4gPGJyPjHjgILlupTnlKjnqIvluo/msLjov5zkuI3kvJrorr/pl67miJbmipPkvY/nlKjmiLfnmoTotYTph5HjgII8YnI+Mi7lupTnlKjnqIvluo/mj5DkvpvkuoblrqLmiLfnq6/nmoTlronlhajmqKHlnovvvIzkuI7np4HmnInlr4bpkqXnmoTmnKzlnLDmiZjnrqHlkozmsLjov5zkuI3kvJrlj5HpgIHliLDku7vkvZXmnI3liqHlmajvvIzmgqjopoHotJ/otKPlr7nlpIfku73mgqjnmoTlr4bnoIHjgII8YnI+My7lupTnlKjnqIvluo/mj5DkvpvnroDljZXvvIzmnInlkLjlvJXlipvnmoTnlKjmiLfnlYzpnaLlkozkvZPpqowgPGJyPjTjgILlupTnlKjnqIvluo/mj5Dkvpvpop3lpJbnmoTlronlhajkuI4gcGluIOeggSA8YnI+PGJyPuiHquWwiuWxguaUr+aMgeiSuOaxveWSjCBHb2xvcyDlubPlj7DjgIIgPGJyPlwiLFxuXHRcIkZPVU5ERVJcIjogXCLliJvlp4vkurrlkozkuLvopoHlvIDlj5HkurrlkZhcIixcblx0XCJBRERfQUNDT1VOVFwiOiBcIua3u+WKoOW4kOWPt1wiLFxuXHRcIlBMQVRGT1JNXCI6IFwi5bmz5Y+wXCJcbn0iLCJtb2R1bGUuZXhwb3J0cz17XG5cdFwiSE9NRVwiOiBcIummlumggVwiLFxuXHRcIkxPR0lOXCI6IFwi55m75YWlXCIsXG5cdFwiTE9HT1VUXCI6IFwi55m75Ye6XCIsXG5cdFwiUFJPRklMRVwiOiBcIumXnOaWvFwiLFxuXHRcIkZPTExPV1wiOiBcIui/vei5pFwiLFxuXHRcIkJPT0tNQVJLU1wiOiBcIuabuOexpFwiLFxuXHRcIlRSQU5TRkVSXCI6IFwi6L2J5bizXCIsXG5cdFwiTUFSS0VUXCI6IFwi5biC5aC0XCIsXG5cdFwiU0VUVElOR1NcIjogXCLoqK3lrppcIixcblx0XCJBQk9VVFwiOiBcIumXnOaWvFwiLFxuXHRcIkFCT1VUXzFcIjogXCLmiYDmnInkurrnmoTlhaflrrnpg73lj6/ku6XlnKjpgJnoo6HnjbLlvpfnjY7li7VcIixcblx0XCJBQk9VVF8yXCI6IFwi5piv55Sxe3twbGF0Zm9ybW5hbWV9feW5s+WPsOaJgOaUr+aMgeOAguatpEFwcOS5i+mWi+eZvOiAheeCulwiLFxuXHRcIkFCT1VUXzNcIjogXCLmraTngrrplovmupDlvI/jgIHnpL7ljYDpqYXli5XkuYvooYzli5Xkvb/nlKjmlrnmoYjvvIzmj5Dkvpvkvb/nlKjogIXlhaflrrnplrHoroDjgIHoqZXoq5bjgIHmipXnpajjgIHmlofnq6DnmbzluIPoiIfmlLblhaXovYnluLPnrYnlip/og73jgILlkITpoIXlip/og73mmK/nlLF7e3BsYXRmb3JtbmFtZX195LmL5Y2A5aGK6Y+I5Lul5Y+Ke3tzaXRlbmFtZX1957ay56uZ5omA5o+Q5L6b44CCXCIsXG5cdFwiQUJPVVRfNFwiOiBcIuacrEFwcOS4jeacg+iZleeQhuaIlueuoeaOp+S9v+eUqOiAheS5i+izh+mHkeOAglwiLFxuXHRcIkFCT1VUXzVcIjogXCLmnKxBcHDmj5DkvpvlrqLmiLbnq6/lronlhajkvb/nlKjmqKHlvI/vvIzkvb/nlKjogIXnp4HpkbDlj6rlnKjmnKzmqZ/lhafpg6jkvb/nlKjvvIzntZXkuI3pgIHlh7rliLDku7vkvZXlpJbpg6jkvLrmnI3lmajjgIJcIixcblx0XCJBQk9VVF82XCI6IFwi5pysQXBw5o+Q5L6b57Ch5Zau5aW955So5LmL5L2/55So6ICF5LuL6Z2i6IiH57aT6amX44CCXCIsXG5cdFwiQUJPVVRfN1wiOiBcIuacrEFwcOe1leS4jeacg+WQkeS9v+eUqOiAheimgeaxguaPkOS+m+S7u+S9leWAi+S6uuizh+aWmeOAglwiLFxuXHRcIkFCT1VUXzhcIjogXCLmipXnpajmlK/mjIFnb29kLWthcm1h5oiQ54K6d2l0bmVzc1wiLFxuXHRcIkFCT1VUXzlcIjogXCLoga/ntaEv5oSP6KaL5Zue6aWLXCIsXG5cdFwiQUJPVVRfMTBcIjogXCLmm7TlpJroqIrmga9cIixcblx0XCJSRU1PVkVcIjogXCLnp7vpmaRcIixcblx0XCJNQVJLRVRfVklFV1wiOiBcIuS6pOaYk+W4guWgtFwiLFxuXHRcIlBSSUNFXCI6IFwi5YO55qC8XCIsXG5cdFwiQU1PVU5UXCI6IFwi5pW46YePXCIsXG5cdFwiVE9UQUxcIjogXCLnuL3oqIhcIixcblx0XCJOT09SREVSU1wiOiBcIueEoeaOm+WWrlwiLFxuXHRcIkRBVEVcIjogXCLml6XmnJ9cIixcblx0XCJCVVlcIjogXCLosrflhaVcIixcblx0XCJTRUxMXCI6IFwi6LOj5Ye6XCIsXG5cdFwiT1BFTlwiOiBcIuaOm+WWrlwiLFxuXHRcIkhJU1RPUllcIjogXCLmrbflj7LntIDpjIRcIixcblx0XCJGT0xMT1dfQkFDS1wiOiBcIue0jeWFpei/vei5pFwiLFxuXHRcIkZPTExPV0VEXCI6IFwi5q2j6KKr6L+96LmkXCIsXG5cdFwiVU5GT0xMT1dcIjogXCLlj5bmtojov73ouaRcIixcblx0XCJGT0xMT1dJTkdcIjogXCLov73ouaTkvaDnmoTlkI3llq5cIixcblx0XCJGT0xMT1dFUlNcIjogXCLkvaDov73ouaTnmoTlkI3llq5cIixcblx0XCJTRUFSQ0hfRk9MTE9XRVJTXCI6IFwi5pCc5bCL6L+96Lmk5L2g55qE5ZCN5ZauXCIsXG5cdFwiU0VBUkNIX0ZPTExPV0lOR1wiOiBcIuaQnOWwi+S9oOi/vei5pOeahOWQjeWWrlwiLFxuXHRcIkJZXCI6IFwi55SxXCIsXG5cdFwiSU5cIjogXCLlnKhcIixcblx0XCJNRU5VXCI6IFwi6YG45ZauXCIsXG5cdFwiQk9PS01BUktcIjogXCLmm7jnsaRcIixcblx0XCJSRUJMT0dcIjogXCLovYnosrxcIixcblx0XCJVUFZPVEVcIjogXCLorppcIixcblx0XCJET1dOVk9URVwiOiBcIuWZk1wiLFxuXHRcIlVOVk9URV9ET1dOVk9URURcIjogXCLlj5bmtojlmZNcIixcblx0XCJVTlZPVEVfVVBWT1RFRFwiOiBcIuWPlua2iOiumlwiLFxuXHRcIlJFUExZXCI6IFwi5Zue6KaGXCIsXG5cdFwiRURJVFwiOiBcIue3qOi8r1wiLFxuXHRcIlBPU1RfMVwiOiBcIuipleirluS4iuWQkeW3pua7keS7pemhr+ekuuWLleS9nOa4heWWrlwiLFxuXHRcIlBPU1RfMlwiOiBcIum7nuaTiuipleirluWPr+WxlemWi+S4i+S4gOWxpOipleirllwiLFxuXHRcIk9QVElPTlNcIjogXCLpgbjpoIVcIixcblx0XCJSRVNURUVNRURfQllcIjogXCLovYnosrxcIixcblx0XCJOT1RISU5HX0hFUkVcIjogXCLmlr3lt6XkuK1cIixcblx0XCJCQUxBTkNFU1wiOiBcIue1kOmkmFwiLFxuXHRcIlBST0ZJTEVfMVwiOiBcInt7cGxhdGZvcm1uYW1lfX0g5piv5Y+v5Lqk5piT55qE6LKo5bmj77yM6Zqo5pmC5Y+v5Lul6YCy6KGM56e76L2J44CCe3twbGF0Zm9ybW5hbWV9fSDlj6/ku6XooqvovYnmj5vmiJAge3twbGF0Zm9ybXBvd2VyfX3vvIzmraTkuIDli5XkvZznqLHngrpwb3dlcmluZyB1cOOAglwiLFxuXHRcIlBST0ZJTEVfMlwiOiBcInt7cGxhdGZvcm1wb3dlcn19IOWPr+imlueCuuWFt+acieW9semfv+WKm+eahOiCoeasiu+8jOaMgeacieWPr+mVt+acn+WinuWAvOS4puWwjeaWh+eroOaKleelqO+8jOaMgeacieaVuOmHj+i2iuWkmuWwjeaWvOWFtuS7luS6uueNjuWLteWkp+Wwj+eahOW9semfv+WKm+Wwsei2iuWkp++8jOS5n+abtOiDveW+nua6lueiuueahOaKleelqOihjOeCuuS4reeNsuW+l+eNjuWLteOAgiBcIixcblx0XCJQUk9GSUxFXzNcIjogXCLnm67liY3mjIHmnIl7e3BsYXRmb3Jtc3VuaXR9feeahHt7cGxhdGZvcm1uYW1lfX3jgIJcIixcblx0XCJFU1RJTUFURURfVkFMVUVcIjogXCLmpoLkvLDlg7nlgLxcIixcblx0XCJQUk9GSUxFXzRcIjogXCLmpoLkvLDlg7nlgLzmmK/ku6V7e3BsYXRmb3JtbmFtZX19My015aSp5LmL5bmz5Z2H5YO554K65Z+656SOXCIsXG5cdFwiVFJBTlNBQ1RJT05fSElTVE9SWVwiOiBcIuS6pOaYk+att+WPsue0gOmMhFwiLFxuXHRcIlBST0ZJTEVfNVwiOiBcIlBvc3Rpbmfnp4HpkbDkvb/nlKjmlrznmbzmlofoiIfmjInorprmtLvli5XkuIrvvIzlhbboiIdBY3RpdmXku6Xlj4pPd25lcuengemRsOWKn+iDveS4jeWQjOOAglwiLFxuXHRcIlBST0ZJTEVfNlwiOiBcIk93bmVy56eB6ZGw5piv5pys5biz6Jmf5LmL5Li76ZGw77yM5YW35pyJ5pu05pS55YW25LuW56eB6ZGw55qE5qyK5Yqb44CC5a6J5YWo6LW36KaL77yMT3duZXLnp4HpkbDlr4bnorzmh4noqbLlhJjlj6/og73lnLDpm6Lnt5rlhLLlrZjjgIJcIixcblx0XCJQUk9GSUxFXzdcIjogXCJBY3RpdmXnp4HpkbDnlKjmlrzluLPomZ/os4fph5HomZXnkIbmtLvli5Xku6Xlj4rmlrzlhafpg6jluILloLTkuIvllq7osrfos6PmlrnpnaLjgIJcIixcblx0XCJQUk9GSUxFXzhcIjogXCJNZW1v56eB6ZGw55So5pa85Ym16YCg6IiH6K6A5Y+WbWVtb+ioiuaBr+OAglwiLFxuXHRcIkJMT0dcIjogXCLpg6jokL3moLxcIixcblx0XCJQT1NUU1wiOiBcIuS9oOeahOipleirllwiLFxuXHRcIlJFUExJRVNcIjogXCLlm57mh4noqZXoq5ZcIixcblx0XCJXQUxMRVRcIjogXCLpjKLljIVcIixcblx0XCJUQUdcIjogXCLmqJnnsaRcIixcblx0XCJVU0VSXCI6IFwi5L2/55So6ICFXCIsXG5cdFwiQ0xPU0VcIjogXCLpl5zplolcIixcblx0XCJUT1wiOiBcIuWIsFwiLFxuXHRcIkFTU0VUXCI6IFwi6LOH55SiXCIsXG5cdFwiU0VORFwiOiBcIuWCs+mAgVwiLFxuXHRcIlNFQ1VSSVRZXCI6IFwi5a6J5YWo5oCnXCIsXG5cdFwiQVZBSUxBQkxFXCI6IFwi5Y+v5L2/55SoXCIsXG5cdFwiUFVCTElDX01FTU9cIjogXCLlhazplovoqIrmga9cIixcblx0XCJUT19ERVNDXCI6IFwi5L2/55So6ICF77yM5L6L5aaCIGdvb2Qta2FybWFcIixcblx0XCJQSU5fQ09ERVwiOiBcIuWvhueivFwiLFxuXHRcIlBJTl9URVhUXCI6IFwi6Kit572u5q2k5a+G56K85Lul5L+d6K23QXBw6IiH55So5oi26LOH5paZ44CCPGJyLz48YnIvPjxiPuazqOaEj++8mjwvYj7kuIDml6bllZ/nlKjvvIzkvaDlj6rog73mnIk05qyh6Kej6Y6W5qmf5pyD77yM5aaC5p6c5b+Y6KiY5a+G56K85oiW5piv5YWo5pW455m75YWl5aSx5pWX77yM5YmHQXBw5pyD56e76Zmk55m75YWl6LOH5paZ44CC5L2g5Y+v5Lul5YaN5qyh55m75YWl5Lim57m857qM5L2/55SoQXBw44CCXCIsXG5cdFwiTk9USUZJQ0FUSU9OU1wiOiBcIumAmuefpVwiLFxuXHRcIlZPVEVfVEVYVFwiOiBcIuS9oOeahOWFp+WuueeNsuW+l+WIpeS6uuaMieiumuaZguacg+mAmuefpeS9oO+8gTxici8+IDxiPuazqOaEj++8mjwvYj4g6YCa55+l5YWn5a655YyF5ous5oyJ6K6a5qyK6YeN6IiH5o+Q6YaS6KiK5oGv44CC77yI5oyJ6K6a44CB5oyJ5ZmT44CB5Y+W5raI6K6a77yJXCIsXG5cdFwiVk9URVwiOiBcIuaKleelqFwiLFxuXHRcIkNPTU1FTlRfVEVYVFwiOiBcIuS7luS6uuipleirluS9oOeahOaWh+eroOaIluipleirluaZgu+8jOS9oOacg+aUtuWIsOmAmuefpe+8gTxici8+IDxiPuazqOaEj++8mjwvYj4g5bCN5pa56IulPGI+6YeN5paw57eo6LyvPC9iPuipleirluWFp+Wuue+8jOS6puacg+mAmuefpeS9oOOAglwiLFxuXHRcIkNPTU1FTlRcIjogXCLoqZXoq5ZcIixcblx0XCJGT0xMT1dfVEVYVFwiOiBcIuS7luS6uui/vei5pOaIluWPlua2iOi/vei5pOS9oOaZgu+8jOS9oOacg+aUtuWIsOmAmuefpe+8gVwiLFxuXHRcIk1FTlRJT05TXCI6IFwi5o+Q5Y+KXCIsXG5cdFwiTUVOVElPTlNfVEVYVFwiOiBcIuS7luS6uuWcqOaWh+eroOaIluipleirluS4reaPkOWPiuS9oOaZgu+8jOS9oOacg+aUtuWIsOmAmuefpe+8gVwiLFxuXHRcIkNPTkZJR1VSQVRJT05TXCI6IFwi57WE5oWL6Kit5a6aXCIsXG5cdFwiVk9USU5HXCI6IFwi5oqV56WoXCIsXG5cdFwiVk9USU5HX1RFWFRcIjogXCLmipXnpajmrIrph43mnIPlvbHpn7/mipXnpajog73ph4/ku6Xlj4rmipXnpajnjY7li7XvvIzkvaDlj6/ku6Xkuojku6Xoqr/mlbTjgII8YnIvPiA8Yj7ms6jmhI/vvJo8L2I+IOWwjeasiumHjeS5i+iqv+aVtOWQjOaoo+mBqeeUqOaWvOaMieiumuiIh+aMieWZk++8jOS4puaMgee6jOS/neaMgeatpOS4gOasiumHjeOAglwiLFxuXHRcIlNFUlZFUlwiOiBcIuS8uuacjeWZqFwiLFxuXHRcIlNFUlZFUl9URVhUXCI6IFwi5o6o6JamXCIsXG5cdFwiU0FWRV9DSEFOR0VTXCI6IFwi5YSy5a2Y6K6K5pu0XCIsXG5cdFwiVk9URVJTX0lORk9cIjogXCLmipXnpajoqIrmga9cIixcblx0XCJXRUxDT01FX0JBQ0tcIjogXCLmraHov47lm57kvobvvIFcIixcblx0XCJMT0dJTl8xXCI6IFwi6KuL5Lul5oKo55qE5L2/55So6ICF5biz6Jmf6IiH5a+G56K855m75YWlXCIsXG5cdFwiTE9HSU5fMlwiOiBcIlBvc3Rpbmcga2V555So5pa855m85biD5paH56ug44CB5oqV56Wo6IiH6L+96Lmk44CCXCIsXG5cdFwiTE9HSU5fM1wiOiBcIkFjdGl2ZSBrZXnnlKjmlrzovYnluLPnm7jpl5zoiIfjgIzpl5zmlrzjgI3kuYvlnJbniYfmm7TmlrDjgIJcIixcblx0XCJMT0dJTl80XCI6IFwi5L2/55So6ICF55qE6KqN6K2J6LOH6KiK5Y+q5L+d5a2Y5Zyo6KOd572u5pys5Zyw56uv44CC55m75Ye65b6M6KqN6K2J6LOH6KiK5bCH6KKr56e76Zmk44CCXCIsXG5cdFwiRE9OVF9IQVZFXCI6IFwi6YKE5rKS5pyJ5biz6Jmf5ZeO77yfXCIsXG5cdFwiU0lHTl9VUF9OT1dcIjogXCLppqzkuIrljrvoqLvlhopcIixcblx0XCJDQU5DRUxcIjogXCLlj5bmtohcIixcblx0XCJBRFZBTkNFRFwiOiBcIumAsumajlwiLFxuXHRcIk1BU1RFUl9QQVNTXCI6IFwiTWFzdGVy5a+G56K8L+S4u+WvhueivFwiLFxuXHRcIlVTRVJOQU1FXCI6IFwi5L2/55So6ICF5ZCN56ixXCIsXG5cdFwiQ0FSRF9WSUVXXCI6IFwi5q2j5bi45qih5byPXCIsXG5cdFwiQ09NUEFDVF9WSUVXXCI6IFwi57K+57Ch5qih5byPXCIsXG5cdFwiU0VBUkNIXCI6IFwi5pCc5bCLXCIsXG5cdFwiU1VCTUlUX0FfU1RPUllcIjogXCLmj5DkuqTmlofnq6BcIixcblx0XCJSRVBMWVRPXCI6IFwi5Zue6KaGXCIsXG5cdFwiUE9TVFwiOiBcIuiyvOaWh1wiLFxuXHRcIlBSRVZJRVdcIjogXCLpoJDopr1cIixcblx0XCJERUZBVUxUXCI6IFwi6aCQ6KitIDUwJSAvIDUwJVwiLFxuXHRcIkRFQ0xJTkVfUEFZT1VUXCI6IFwi6Kyd57WVUGF5b3V0XCIsXG5cdFwiU0FWRV9GT1JfTEFURVJcIjogXCLpoJDlrZjojYnnqL9cIixcblx0XCJDTEVBUlwiOiBcIua4hemZpFwiLFxuXHRcIlBPU1RfQ09OVEVOVFwiOiBcIuiyvOaWh+WFp+WuuVwiLFxuXHRcIkNPTU1FTlRfQ09OVEVOVFwiOiBcIuipleirluWFp+WuuVwiLFxuXHRcIlRJVExFXCI6IFwi5qiZ6aGMXCIsXG5cdFwiVEFHU1wiOiBcIuaomeexpFwiLFxuXHRcIk5PVF9NQVRDSFwiOiBcIuS4jeesplwiLFxuXHRcIkNPTkZJUk1fUElOXCI6IFwi56K66KqN5a+G56K8XCIsXG5cdFwiSU5DT1JSRUNUXCI6IFwi5LiN5q2j56K6XCIsXG5cdFwiT1BFTklOR19QT1NUXCI6IFwi5omT6ZaL6LK85paHXCIsXG5cdFwiU0VUX1BJTlwiOiBcIumHjeioreWvhueivFwiLFxuXHRcIkVOVEVSX1BJTlwiOiBcIui8uOWFpeWvhueivFwiLFxuXHRcIkFSRV9ZT1VfU1VSRVwiOiBcIuaYr+WQpueiuuWumu+8n1wiLFxuXHRcIkJST0FEQ0FTVF9FUlJPUlwiOiBcIuW7o+aSremMr+iqpO+8jOiri+WGjeippuS4gOasoe+8gVwiLFxuXHRcIlNVQ0NFU1NcIjogXCLmiJDlip9cIixcblx0XCJSRUJMT0dHRURfUE9TVFwiOiBcIui9ieiyvOaWh+eroFwiLFxuXHRcIkxPR0lOX0ZBSUxcIjogXCLnmbvlhaXlpLHmlZfvvIHoq4vnorroqo3kvaDmmK/ku6VtYXN0ZXLlr4bnorznmbvlhaXvvIzmiJbmmK/lnKjpgLLpmo7mqKHlvI/kuIvku6Xmj5DkvpvkuYtQb3N0aW5n56eB6ZGw55m75YWl44CCXCIsXG5cdFwiTE9HSU5fRkFJTF9BXCI6IFwi55m75YWl5aSx5pWX77yB6KuL56K66KqN5L2g5piv5LulbWFzdGVy5a+G56K855m75YWl77yM5oiW5piv5Zyo6YCy6ZqO5qih5byP5LiL5Lul5o+Q5L6b5LmLQWN0aXZl56eB6ZGw55m75YWl44CCXCIsXG5cdFwiV0FSTklOR1wiOiBcIuitpuWRilwiLFxuXHRcIlZPVEVfRk9SX1dJVE5FU1NcIjogXCLmipXnpajmlK/mjIHopovorYnkurpcIixcblx0XCJWT1RFRF9GT1JfV0lUTkVTU1wiOiBcIuaKleelqOaUr+aMgeeCuuimi+itieS6ulwiLFxuXHRcIkFHT1wiOiBcIuWJjVwiLFxuXHRcIkZST01fTk9XXCI6IFwi6YKE5pyJXCIsXG5cdFwiU0VDU1wiOiBcIuenklwiLFxuXHRcIkFfTUlOXCI6IFwi5LiA5YiG6ZCYXCIsXG5cdFwiTUlOU1wiOiBcIuWIhumQmFwiLFxuXHRcIkFOX0hPVVJcIjogXCLkuIDlsI/mmYJcIixcblx0XCJIT1VSU1wiOiBcIuWwj+aZglwiLFxuXHRcIkFfREFZXCI6IFwi5LiA5aSpXCIsXG5cdFwiREFZU1wiOiBcIuWkqVwiLFxuXHRcIkFfTU9OVEhcIjogXCLkuIDlgIvmnIhcIixcblx0XCJNT05USFNcIjogXCLlgIvmnIhcIixcblx0XCJBX1lFQVJcIjogXCLkuIDlubRcIixcblx0XCJZRUFSU1wiOiBcIuWAi+W5tFwiLFxuXHRcIk1JTl9SRUFEXCI6IFwi5YiG6ZCY6Zax6K6A5pmC6ZaTXCIsXG5cdFwiRE9XTlZPVEVfRkxBR1wiOiBcIuaMieWZk1wiLFxuXHRcIkNBUFRVUkVfUElDVFVSRVwiOiBcIueNsuWPluWclueJh1wiLFxuXHRcIlNFTEVDVF9QSUNUVVJFXCI6IFwi6YG45pOH5ZyW54mHXCIsXG5cdFwiU0VUX0NVU1RPTV9VUkxcIjogXCLoqK3lrprlsIjnlKjpgKPntZBcIixcblx0XCJJTlNFUlRfUElDVFVSRVwiOiBcIuaPkuWFpeWclueJh1wiLFxuXHRcIkVSUk9SXCI6IFwi6Yyv6KqkXCIsXG5cdFwiVVBMT0FEX0VSUk9SXCI6IFwi5LiK5YKz6Yyv6KqkXCIsXG5cdFwiQ0FNRVJBX0NBTkNFTExFRFwiOiBcIuWPlua2iOebuOapn1wiLFxuXHRcIlNFVF9VUkxcIjogXCLoqK3lrppVUkxcIixcblx0XCJESVJFQ1RfTElOS19QSUNUVVJFXCI6IFwi5ZyW54mH5LmL57ay56uZ6YCj57WQXCIsXG5cdFwiQ09NTUVOVF9TVUJNSVRURURcIjogXCLoqZXoq5bpgIHlh7pcIixcblx0XCJERUxFVEVfQ09NTUVOVFwiOiBcIuWIqumZpOipleirluWLleS9nOaYr+S4jeWPr+aBouW+qeeahFwiLFxuXHRcIkRFTEVURURfQ09NTUVOVFwiOiBcIuW3suWIqumZpOS5i+ipleirllwiLFxuXHRcIlVQTE9BRElOR19QSUNUVVJFXCI6IFwi5LiK5YKz5ZyW54mHXCIsXG5cdFwiVVBMT0FEX0NPTVBMRVRFRFwiOiBcIuS4iuWCs+WujOaIkFwiLFxuXHRcIlVQTE9BRF9GQUlMRURcIjogXCLkuIrlgrPlpLHmlZdcIixcblx0XCJQQVNTV09SRF9JTkNPUlJFQ1RcIjogXCLlr4bnorzmiJbluLPomZ/lkI3nqLHpjK/oqqRcIixcblx0XCJJTkZPXCI6IFwi6KiK5oGvXCIsXG5cdFwiUVJfVEVYVFwiOiBcIuiri+Wwh1FSIGNvZGXnva7mlrzmjoPmj4/ljYDln5/lhadcIixcblx0XCJCQUxBTkNFX1RFWFRcIjogXCLoq4vnorroqo3mnInotrPlpKDppJjpoY3lj6/kvpvkuqTmmJPvvIFcIixcblx0XCJOT05FWElTVF9VU0VSXCI6IFwi6L2J5YWl5biz6Jmf5LiN5a2Y5ZyoXCIsXG5cdFwiVFJBTlNGRVJfVEVYVFwiOiBcIueiuuWumuimgemAsuihjOi9ieW4s++8n1wiLFxuXHRcIkNPTkZJUk1BVElPTlwiOiBcIueiuuiqjVwiLFxuXHRcIlRYX0JST0FEQ0FTVEVEXCI6IFwi5Lqk5piT5bey5buj5pKtXCIsXG5cdFwiRkVFRFwiOiBcIuWLleaFi+a2iOaBr1wiLFxuXHRcIlRSRU5ESU5HXCI6IFwi54Sm6bueXCIsXG5cdFwiSE9UXCI6IFwi54ax6ZaAXCIsXG5cdFwiTkVXXCI6IFwi5pyA5pawXCIsXG5cdFwiUFJPTU9URURcIjogXCLotIrliqlcIixcblx0XCJWT1RFU1wiOiBcIuelqOaVuFwiLFxuXHRcIlBBWU9VVFwiOiBcIuaUtuWFpVwiLFxuXHRcIkNPTU1FTlRTXCI6IFwi6KmV6KuWXCIsXG5cdFwiVFJFTkRJTkdfMzBcIjogXCIzMOWkqeeEpum7nlwiLFxuXHRcIlNPUlRfUE9TVF9CWVwiOiBcIuaWh+eroOaOkuW6j1wiLFxuXHRcIlBBWU9VVF9DWUNMRVwiOiBcIuaUtuWFpemAseacn1wiLFxuXHRcIlBPVEVOVElBTF9QQVlPVVRcIjogXCLmnKrlr6bnj77mlLblhaVcIixcblx0XCJQQVNUX1BBWU9VVFwiOiBcIuW3suaUr+S7mOaUtuWFpVwiLFxuXHRcIkFVVEhPUl9QQVlPVVRcIjogXCLkvZzogIXmlLblhaVcIixcblx0XCJDVVJBVElPTl9QQVlPVVRcIjogXCLmipXnpajmlLblhaVcIixcblx0XCJQT1NUX1NVQk1JVFRFRFwiOiBcIuaWh+eroOW3sumAgeWHulwiLFxuXHRcIlBPU1RfTEFURVJcIjogXCLlvoXnmbzmlofnq6BcIixcblx0XCJTQVZFRFwiOiBcIuW3suWEsuWtmFwiLFxuXHRcIkNMRUFSRURcIjogXCLlt7LmuIXpmaRcIixcblx0XCJGTEFHR0lOR19URVhUXCI6IFwi5bCN5paH56ug5oyJ5ZmT5pyD5b2x6Z+/5YW2542O5Yu177yM5Lim6ZmN5L2O5YW26IO96KaL5bqm44CCPGJyPjxicj4g5oeJ5Zyo5LiL5YiX5oOF5rOB5LiL5oyJ5ZmT77yaPHVsPjxsaT7oqZDmrLrmiJbmioTopbI8L2xpPjxsaT7ku4fmgajmgKfoqIDoq5bmiJbntrLot6/mv6vnlKg8L2xpPjxsaT7lhaflrrnmlYXmhI/liIbpoZ7pjK/oqqTmiJblpKfph4/mlaPluIPlnoPlnL7oqIrmga88L2xpPjwvdWw+XCIsXG5cdFwiUkVRVUVTVF9MSU1JVF9URVhUXCI6IFwi5bey6YGU6KaB5rGC6ZmQ5bqm77yM6KuL5p+l6Kmi5YW25LuW54Sm6bue5paH56ug5oiW5qiZ57Gk77yBXCIsXG5cdFwiUE9TVF9JU19VTkJPT0tNQVJLXCI6IFwi5paH56ug5bey6Ieq5pu457Gk5Lit56e76ZmkXCIsXG5cdFwiUE9TVF9JU19CT09LTUFSS1wiOiBcIuaWh+eroOW3suWKoOWFpeabuOexpFwiLFxuXHRcIlJFU0VUXCI6IFwi6YeN572uXCIsXG5cdFwiTU9ESUZZX1BJQ1RVUkVcIjogXCLkv67mlLnjgIzpl5zmlrzjgI3nmoTlnJbniYdcIixcblx0XCJNT0RJRllfQ09WRVJfUElDVFVSRVwiOiBcIuS/ruaUueWwgemdouWclueJh1wiLFxuXHRcIkFDVElWRV9LRVlfUkVRVUlSRURfVEVYVFwiOiBcIuiLpemBuOaTh+mAsumajuaooeW8j++8jOiri+aPkOS+m0FjdGl2ZeengemRsO+8gVwiLFxuXHRcIlJFU0VUX1BJQ1RVUkVfVEVYVFwiOiBcIuatpOWLleS9nOWwh+mHjeioreS9v+eUqOiAheOAjOmXnOaWvOOAjeeahOWclueJh1wiLFxuXHRcIlJFU0VUX0NPVkVSX1BJQ1RVUkVfVEVYVFwiOiBcIuatpOWLleS9nOWwh+mHjeioreS9v+eUqOiAheWwgemdouWclueJh1wiLFxuXHRcIlVQREFURV9SRVFVSVJFU19SRVNUQVJUXCI6IFwi55Sx5pa85Ly65pyN5Zmo5pu05paw6ZyA6KaB6YeN5paw5ZWf5YuV77yBXCIsXG5cdFwiU0VUVElOR1NfVVBEQVRFRFwiOiBcIuioreWumuW3suabtOaWsO+8gVwiLFxuXHRcIkxBTkdVQUdFU1wiOiBcIuiqnuiogFwiLFxuXHRcIkxBTkdVQUdFU19URVhUXCI6IFwi5L2g5Y+v5Lul5Zyo5q2k5pu05pS5QVBQ55qE5L2/55So6Kqe6KiAXCIsXG5cdFwiTE9HSU5fVE9fWFwiOiBcIuatpOS4gOWLleS9nOmcgOimgeS9v+eUqOiAheS7peS4u+WvhueivOOAgUFjdGl2ZeengemRsOaIllBvc3Rpbmfnp4HpkbDnmbvlhaXjgILoq4vnmbvlhaXlho3oqabkuIDkuIvjgIJcIixcblx0XCJHQUxMRVJZXCI6IFwi6Zmz5YiXXCIsXG5cdFwiVFJBTlNMQVRJT05TXCI6IFwi5aSa5ZyL6Kqe6KiA57+76K2v5bel5L2c5Y2U5Yqp6ICFXCIsXG5cdFwiU0hBUkVcIjogXCLliIbkuqtcIixcblx0XCJNQVJLRVRQTEFDRVwiOiBcIuW4guWgtFwiLFxuXHRcIkVYQ0hBTkdFXCI6IFwi5Lqk5piT5omAXCIsXG5cdFwiRFJBRlRTXCI6IFwi6I2J56i/XCIsXG5cdFwiUE9TVF9JU19VTkRSQUZUXCI6IFwi5paH56ug6Ieq6I2J56i/5Lit56e76Zmk77yBXCIsXG5cdFwiUE9TVF9JU19EUkFGVFwiOiBcIuaWh+eroOWKoOWFpeiNieeov++8gVwiLFxuXHRcIlNXSVBFX0xFRlRcIjogXCLlkJHlt6bmu5Hli5Xlj6/plovllZ/li5XkvZzpgbjpoIVcIixcblx0XCJNQU5BR0VcIjogXCLnrqHnkIZcIixcblx0XCJJTUFHRV9SRU1PVkVEXCI6IFwi5ZyW54mH56e76ZmkXCIsXG5cdFwiQ09QWVwiOiBcIuikh+ijvVwiLFxuXHRcIk5PX0lNQUdFXCI6IFwi5oKo5bCa5pyq5LiK5YKz5Lu75L2V5ZyW54mH77yBXCIsXG5cdFwiUFVMTF9ET1dOX1RPX1JFRlJFU0hcIjogXCLlkJHkuIvmi4nli5Xlj6/mm7TmlrBcIixcblx0XCJFWFRFUk5BTF9BUFBTXCI6IFwi5aSW6YOoQXBwXCIsXG5cdFwiUExVR0lOU1wiOiBcIuWkluaOm+eoi+W8j1wiLFxuXHRcIlNVR0dFU1RcIjogXCLlu7rorbBcIixcblx0XCJDT01JTkdfU09PTlwiOiBcIuWNs+Wwh+aOqOWHulwiLFxuXHRcIkNIQUlOXCI6IFwi6Y+IXCIsXG5cdFwiQ0hBSU5fVEVYVFwiOiBcIuaCqOWPr+S7peWcqOmAmeijoeiuiuabtOS9v+eUqOeahOWNgOWhiumPiOaIluaYr+mgkOioreeahOW5s+WPsOOAglwiLFxuXHRcIlJFTEVBU0VcIjogXCLph4vmlL5cIlxufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vYW5ndWxhci5tb2R1bGUoJ3N0ZWVtLnNlcnZpY2VzJywgW10pXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcblx0YXBwLnNlcnZpY2UoJ0FQSXMnLCBbJyRodHRwJywgJyRyb290U2NvcGUnLCAnQVBJX0VORF9QT0lOVCcsIGZ1bmN0aW9uICgkaHR0cCwgJHJvb3RTY29wZSwgQVBJX0VORF9QT0lOVCkge1xuXHRcdCd1c2Ugc3RyaWN0Jztcblx0XHRyZXR1cm4ge1xuICAgICAgZ2V0Q3VycmVuY3lSYXRlOiBmdW5jdGlvbihjb2RlX2Zyb20sIGNvZGVfdG8pe1xuICAgICAgICBjb25zb2xlLmxvZyhjb2RlX2Zyb20sY29kZV90byk7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoXCJodHRwczovL3F1ZXJ5LnlhaG9vYXBpcy5jb20vdjEvcHVibGljL3lxbD9xPXNlbGVjdCUyMColMjBmcm9tJTIweWFob28uZmluYW5jZS54Y2hhbmdlJTIwd2hlcmUlMjBwYWlyJTIwaW4lMjAoJTIyXCIrY29kZV9mcm9tK2NvZGVfdG8rXCIlMjIpJmZvcm1hdD1qc29uJmRpYWdub3N0aWNzPWZhbHNlJmVudj1zdG9yZSUzQSUyRiUyRmRhdGF0YWJsZXMub3JnJTJGYWxsdGFibGVzd2l0aGtleXNcIik7XG4gICAgICB9LFxuICAgICAgc2F2ZVN1YnNjcmlwdGlvbjogZnVuY3Rpb24oZGV2aWNlaWQsIHVzZXJuYW1lLCBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoQVBJX0VORF9QT0lOVCtcIi9hcGkvZGV2aWNlc1wiLCB7ZGV2aWNlaWQ6IGRldmljZWlkLCB1c2VybmFtZTogdXNlcm5hbWUsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbjogZnVuY3Rpb24oZGV2aWNlaWQsIHVzZXJuYW1lLCBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnB1dChBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzXCIsIHtkZXZpY2VpZDogZGV2aWNlaWQsIHVzZXJuYW1lOiB1c2VybmFtZSwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIGNoYWluOiAkcm9vdFNjb3BlLiRzdG9yYWdlLmNoYWlufSk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlVG9rZW46IGZ1bmN0aW9uKGRldmljZWlkLCBuZXdkZXYpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnB1dChBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2UvXCIrZGV2aWNlaWQsIHtuZXdkZXY6IG5ld2RldiwgY2hhaW46ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW59KTtcbiAgICAgIH0sXG4gICAgICBkZWxldGVTdWJzY3JpcHRpb246IGZ1bmN0aW9uKGRldmljZWlkKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5kZWxldGUoQVBJX0VORF9QT0lOVCtcIi9hcGkvZGV2aWNlcy9cIitkZXZpY2VpZCk7XG4gICAgICB9LFxuICAgICAgZ2V0U3Vic2NyaXB0aW9uczogZnVuY3Rpb24oZGV2aWNlaWQpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmdldChBUElfRU5EX1BPSU5UK1wiL2FwaS9kZXZpY2VzL1wiK2RldmljZWlkKTtcbiAgICAgIH0sXG5cdFx0XHRhZGRCb29rbWFyazogZnVuY3Rpb24odXNlciwgYm9va21hcmspIHtcbiAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoQVBJX0VORF9QT0lOVCtcIi9hcGkvYm9va21hcmtcIiwge3VzZXJuYW1lOiB1c2VyLCBhdXRob3I6IGJvb2ttYXJrLmF1dGhvciwgcGVybWxpbms6IGJvb2ttYXJrLnBlcm1saW5rLCBjaGFpbjogJHJvb3RTY29wZS4kc3RvcmFnZS5jaGFpbn0pO1xuICAgICAgfSxcblx0XHRcdGdldEJvb2ttYXJrczogZnVuY3Rpb24odXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2Jvb2ttYXJrcy9cIit1c2VyKTtcbiAgICAgIH0sXG5cdFx0XHRyZW1vdmVCb29rbWFyazogZnVuY3Rpb24oaWQsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmRlbGV0ZShBUElfRU5EX1BPSU5UK1wiL2FwaS9ib29rbWFya3MvXCIrdXNlcitcIi9cIitpZCk7XG4gICAgICB9LFxuXHRcdFx0YWRkRHJhZnQ6IGZ1bmN0aW9uKHVzZXIsIGRyYWZ0KSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5wb3N0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2RyYWZ0XCIsIHt1c2VybmFtZTogdXNlciwgdGl0bGU6IGRyYWZ0LnRpdGxlLCBib2R5OiBkcmFmdC5ib2R5LCB0YWdzOiBkcmFmdC50YWdzLCBwb3N0X3R5cGU6IGRyYWZ0LnBvc3RfdHlwZSwgY2hhaW46ICRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW59KTtcbiAgICAgIH0sXG5cdFx0XHRnZXREcmFmdHM6IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuICRodHRwLmdldChBUElfRU5EX1BPSU5UK1wiL2FwaS9kcmFmdHMvXCIrdXNlcik7XG4gICAgICB9LFxuXHRcdFx0cmVtb3ZlRHJhZnQ6IGZ1bmN0aW9uKGlkLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5kZWxldGUoQVBJX0VORF9QT0lOVCtcIi9hcGkvZHJhZnRzL1wiK3VzZXIrXCIvXCIraWQpO1xuICAgICAgfSxcblx0XHRcdHJlbW92ZUltYWdlOiBmdW5jdGlvbihpZCwgdXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZGVsZXRlKEFQSV9FTkRfUE9JTlQrXCIvYXBpL2ltYWdlcy9cIit1c2VyK1wiL1wiK2lkKTtcbiAgICAgIH0sXG5cdFx0XHRmZXRjaEltYWdlczogZnVuY3Rpb24odXNlcikge1xuICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KEFQSV9FTkRfUE9JTlQrXCIvYXBpL2ltYWdlcy9cIit1c2VyKTtcbiAgICAgIH0sXG4gICAgICBzZWFyY2hFc2Nyb3c6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiAkaHR0cC5nZXQoQVBJX0VORF9QT0lOVCtcIi9hcGkvZXNjcm93L1wiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW4rXCIvXCIraWQpO1xuICAgICAgfSxcblx0XHR9O1xuXHR9XSlcbiAgYXBwLmRpcmVjdGl2ZSgnYmFja0ltZycsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycyl7XG4gICAgICAgIHZhciB1cmwgPSBhdHRycy5iYWNrSW1nO1xuICAgICAgICBlbGVtZW50LmNzcyh7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoJyArIHVybCArJyknLFxuICAgICAgICAgICAgJ2JhY2tncm91bmQtc2l6ZScgOiAnY292ZXInXG4gICAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuICBhcHAuZGlyZWN0aXZlKCdzZWxlY3QnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBlbGVtZW50LmJpbmQoJ2ZvY3VzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkKSB7XG4gICAgICAgICAgICAvLyAkcm9vdFNjb3BlLmxvZyhcInNob3cgYmFyIChoaWRlID0gZmFsc2UpXCIpO1xuICAgICAgICAgICAgY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmhpZGVLZXlib2FyZEFjY2Vzc29yeUJhcihmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5iaW5kKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICh3aW5kb3cuY29yZG92YSAmJiB3aW5kb3cuY29yZG92YS5wbHVnaW5zLktleWJvYXJkKSB7XG4gICAgICAgICAgICAvLyAkcm9vdFNjb3BlLmxvZyhcImhpZGUgYmFyIChoaWRlID0gdHJ1ZSlcIik7XG4gICAgICAgICAgICBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQuaGlkZUtleWJvYXJkQWNjZXNzb3J5QmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIGFwcC5kaXJlY3RpdmUoJ25hdmlnYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBbJyRzY29wZScsICckcm9vdFNjb3BlJywgZnVuY3Rpb24gKCRzY29wZSwgJHJvb3RTY29wZSkge1xuICAgICAgJHNjb3BlLmFkZGFjdGl2ZWNsYXNzID0gZnVuY3Rpb24gKG1lbnVJdGVtKSB7XG4gICAgICAgICAgJHNjb3BlLmFjdGl2ZU1lbnUgPSBtZW51SXRlbS5uYW1lO1xuICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobWVudUl0ZW0pO1xuICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gbWVudUl0ZW0uaHJlZjtcbiAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAkc2NvcGUuY2VudGVyKG1lbnVJdGVtLm5hbWUpO1xuICAgICAgICAgICRzY29wZS5zb21lQ3RybEZuKHttZW51bGlua3M6IG1lbnVJdGVtfSk7XG4gICAgICB9O1xuXG4gICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCl7XG4gICAgICAgICRzY29wZS5jZW50ZXIoKTtcbiAgICAgIH0pO1xuICAgICAgJHNjb3BlLmNlbnRlciA9IGZ1bmN0aW9uKG1lbnVJdGVtKSB7XG4gICAgICAgIHZhciBuYXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5hdjFcIik7XG4gICAgICAgIHZhciBuYXZXaWR0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmF2MlwiKS5vZmZzZXRXaWR0aDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW25hbWU9XCInK21lbnVJdGVtKydcIl0nKTtcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSBtZW51SXRlbSA/IGN1cnJlbnRFbGVtZW50WzBdIDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWN0aXZlJylbMF07XG4gICAgICAgIGlmKGN1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdmFyIG1hcmdpbiA9IDA7XG4gICAgICAgICAgdmFyIGxlbm0gPSBuYXYuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIGZvcih2YXIgaSA9MDsgaTxsZW5tOyBpKyspe1xuXG4gICAgICAgICAgICBpZihjdXJyZW50RWxlbWVudCA9PSBuYXYuY2hpbGRyZW5baV0pe1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgbWFyZ2luICs9IG5hdi5jaGlsZHJlbltpXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbmF2LnN0eWxlLm1hcmdpbkxlZnQgPSAobmF2V2lkdGgvMiAtIG1hcmdpbiAtIGN1cnJlbnRFbGVtZW50Lm9mZnNldFdpZHRoLzIpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuYXYuc3R5bGUubWFyZ2luTGVmdCA9IChuYXZXaWR0aC8yIC0gJHNjb3BlLmFjdGl2ZU1lbnUubGVuZ3RoKSArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgX2xlbiA9ICRzY29wZS5tZW51bGlua3MubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAgICAgaWYgKCRzY29wZS5tZW51bGlua3NbaV0uaHJlZiA9PSAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlcikge1xuICAgICAgICAgICAgJHNjb3BlLmFjdGl2ZU1lbnUgPSAkc2NvcGUubWVudWxpbmtzW2ldLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzY29wZS5hY3RpdmVNZW51ID0gXCJUcmVuZGluZ1wiO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vJHNjb3BlLmNlbnRlcigpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmNlbnRlcigpO1xuICAgICAgfSwgNTApO1xuICAgIH1dO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiBcIkVcIixcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY29wZToge1xuICAgICAgICBtZW51bGlua3M6ICc9JyxcbiAgICAgICAgc29tZUN0cmxGbjogJyZjYWxsYmFja0ZuJ1xuICAgICAgfSxcbiAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gICAgICB0ZW1wbGF0ZTogXCI8dWwgaWQ9J25hdjEnPlwiK1xuICAgICAgICAgICAgICBcIjxsaSBuZy1yZXBlYXQ9J21lbnVsaW5rcyBpbiBtZW51bGlua3MnIG5hbWU9J3t7bWVudWxpbmsubmFtZX19JyBjbGFzcz0ndG9wIHt7bWVudWxpbmsucm9sZX19JyBuZy1jbGFzcz0ne2FjdGl2ZSA6IGFjdGl2ZU1lbnUgPT09IG1lbnVsaW5rLm5hbWV9Jz5cIitcbiAgICAgICAgICAgICAgICBcIjxhIG9uLXRhcD0nYWRkYWN0aXZlY2xhc3MobWVudWxpbmspJz5cIitcbiAgICAgICAgICAgICAgICAgIFwie3ttZW51bGluay5uYW1lfX1cIlxuICAgICAgICAgICAgICAgICtcIjwvYT5cIitcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J2Fycm93Jz48L2Rpdj5cIitcbiAgICAgICAgICAgICAgICBcIjwvbGk+XCJcbiAgICAgICAgICAgICtcIjwvdWw+XCJcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBTaW1wbGVQdWJTdWIoKSB7XG4gICAgICB2YXIgZXZlbnRzID0ge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG9uOiBmdW5jdGlvbihuYW1lcywgaGFuZGxlcikge1xuICAgICAgICAgICAgICBuYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBldmVudHNbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV2ZW50c1tuYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChldmVudHNbbmFtZV0sIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbChudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gIH07XG5cbiAgYXBwLmRpcmVjdGl2ZSgnb25GaW5pc2hSZW5kZXInLCBmdW5jdGlvbiAoJHRpbWVvdXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgICAgICAgICAgaWYgKHNjb3BlLiRsYXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2NvcGUuJGVtaXQoJ25nUmVwZWF0RmluaXNoZWQnKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9KVxuICBhcHAuZGlyZWN0aXZlKCdjbGlja0hhbmRsZXInLCBmdW5jdGlvbigkdGltZW91dCl7XG4gICAgICByZXR1cm57XG4gICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICBsaW5rOiBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCRhdHRyKXtcbiAgICAgICAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5vbigndGFwJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIHBlcmZvcm0gb24gdGFwXG4gICAgICAgIGFsZXJ0KFwiSnVzdCBiZWVuIENsaWNrZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gIH0pXG4gIGFwcC5kaXJlY3RpdmUoJ3RhYlNsaWRlQm94JywgWyAnJHRpbWVvdXQnLCAnJHdpbmRvdycsICckaW9uaWNTbGlkZUJveERlbGVnYXRlJywgJyRpb25pY1Njcm9sbERlbGVnYXRlJywgJyRyb290U2NvcGUnLFxuICAgIGZ1bmN0aW9uKCR0aW1lb3V0LCAkd2luZG93LCAkaW9uaWNTbGlkZUJveERlbGVnYXRlLCAkaW9uaWNTY3JvbGxEZWxlZ2F0ZSwgJHJvb3RTY29wZSkge1xuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdCA6ICdBLCBFLCBDJyxcbiAgICAgICAgbGluayA6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgbmdNb2RlbCkge1xuXG4gICAgICAgICAgdmFyIHRhID0gZWxlbWVudFswXSwgJHRhID0gZWxlbWVudDtcbiAgICAgICAgICAkdGEuYWRkQ2xhc3MoXCJ0YWJiZWQtc2xpZGVib3hcIik7XG4gICAgICAgICAgaWYoYXR0cnMudGFic1Bvc2l0aW9uID09PSBcImJvdHRvbVwiKXtcbiAgICAgICAgICAgICR0YS5hZGRDbGFzcyhcImJ0bVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL0hhbmRsZSBtdWx0aXBsZSBzbGlkZS9zY3JvbGwgYm94ZXNcbiAgICAgICAgICB2YXIgaGFuZGxlID0gdGEucXVlcnlTZWxlY3RvcignLnNsaWRlcicpLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUtaGFuZGxlJyk7XG5cbiAgICAgICAgICB2YXIgaW9uaWNTbGlkZUJveERlbGVnYXRlID0gJGlvbmljU2xpZGVCb3hEZWxlZ2F0ZTtcbiAgICAgICAgICBpZihoYW5kbGUpe1xuICAgICAgICAgICAgaW9uaWNTbGlkZUJveERlbGVnYXRlID0gaW9uaWNTbGlkZUJveERlbGVnYXRlLiRnZXRCeUhhbmRsZShoYW5kbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpb25pY1Njcm9sbERlbGVnYXRlID0gJGlvbmljU2Nyb2xsRGVsZWdhdGU7XG4gICAgICAgICAgaWYoaGFuZGxlKXtcbiAgICAgICAgICAgIGlvbmljU2Nyb2xsRGVsZWdhdGUgPSBpb25pY1Njcm9sbERlbGVnYXRlLiRnZXRCeUhhbmRsZShoYW5kbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlclNjcm9sbGFibGVUYWJzKCl7XG4gICAgICAgICAgICB2YXIgaWNvbnNEaXYgPSBhbmd1bGFyLmVsZW1lbnQodGEucXVlcnlTZWxlY3RvcihcIi50c2ItaWNvbnNcIikpLCBpY29ucyA9IGljb25zRGl2LmZpbmQoXCJhXCIpLCB3cmFwID0gaWNvbnNEaXZbMF0ucXVlcnlTZWxlY3RvcihcIi50c2ItaWMtd3JwXCIpLCB0b3RhbFRhYnMgPSBpY29ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsRGl2ID0gd3JhcC5xdWVyeVNlbGVjdG9yKFwiLnNjcm9sbFwiKTtcblxuICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGljb25zLCBmdW5jdGlvbih2YWx1ZSwga2V5KXtcbiAgICAgICAgICAgICAgICAgdmFyIGEgPSBhbmd1bGFyLmVsZW1lbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICBhLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgaW9uaWNTbGlkZUJveERlbGVnYXRlLnNsaWRlKGtleSk7XG4gICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmKGEuYXR0cignaWNvbi1vZmYnKSkge1xuICAgICAgICAgICAgICAgIGEuYXR0cihcImNsYXNzXCIsIGEuYXR0cignaWNvbi1vZmYnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgaW5pdGlhbEluZGV4ID0gYXR0cnMudGFiO1xuICAgICAgICAgICAgLy9Jbml0aWFsaXppbmcgdGhlIG1pZGRsZSB0YWJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBhdHRycy50YWIgPT09ICd1bmRlZmluZWQnIHx8ICh0b3RhbFRhYnMgPD0gaW5pdGlhbEluZGV4KSB8fCBpbml0aWFsSW5kZXggPCAwKXtcbiAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gTWF0aC5mbG9vcihpY29ucy5sZW5ndGgvMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vSWYgaW5pdGlhbCBlbGVtZW50IGlzIDAsIHNldCBwb3NpdGlvbiBvZiB0aGUgdGFiIHRvIDB0aCB0YWJcbiAgICAgICAgICAgIGlmKGluaXRpYWxJbmRleCA9PSAwKXtcbiAgICAgICAgICAgICAgc2V0UG9zaXRpb24oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyRyb290U2NvcGUubG9nKCdpbml0aWFsSW5kZXggJytpbml0aWFsSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdmZWVkJykge1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogMH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAwfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdob3QnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDF9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NyZWF0ZWQnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDJ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2FjdGl2ZScpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogM30pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAncHJvbW90ZWQnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDR9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ3RyZW5kaW5nMzAnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDV9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ3ZvdGVzJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA2fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjaGlsZHJlbicpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogN30pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY2FzaG91dCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogOH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gOTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAndHJlbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiAwfSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdob3QnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDF9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2NyZWF0ZWQnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDJ9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ2FjdGl2ZScpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogM30pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAncHJvbW90ZWQnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDR9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ3RyZW5kaW5nMzAnKXtcbiAgICAgICAgICAgICAgICAgIC8vJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IDV9KTtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxJbmRleCA9IDU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9PT0gJ3ZvdGVzJyl7XG4gICAgICAgICAgICAgICAgICAvLyRzY29wZS5ldmVudHMudHJpZ2dlcihcInNsaWRlQ2hhbmdlXCIsIHtcImluZGV4XCIgOiA2fSk7XG4gICAgICAgICAgICAgICAgICBpbml0aWFsSW5kZXggPSA2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPT09ICdjaGlsZHJlbicpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogN30pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID09PSAnY2FzaG91dCcpe1xuICAgICAgICAgICAgICAgICAgLy8kc2NvcGUuZXZlbnRzLnRyaWdnZXIoXCJzbGlkZUNoYW5nZVwiLCB7XCJpbmRleFwiIDogOH0pO1xuICAgICAgICAgICAgICAgICAgaW5pdGlhbEluZGV4ID0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpb25pY1NsaWRlQm94RGVsZWdhdGUuc2xpZGUoaW5pdGlhbEluZGV4KTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmdW5jdGlvbiBzZXRQb3NpdGlvbihpbmRleCl7XG4gICAgICAgICAgICB2YXIgaWNvbnNEaXYgPSBhbmd1bGFyLmVsZW1lbnQodGEucXVlcnlTZWxlY3RvcihcIi50c2ItaWNvbnNcIikpLCBpY29ucyA9IGljb25zRGl2LmZpbmQoXCJhXCIpLCB3cmFwID0gaWNvbnNEaXZbMF0ucXVlcnlTZWxlY3RvcihcIi50c2ItaWMtd3JwXCIpLCB0b3RhbFRhYnMgPSBpY29ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsRGl2ID0gd3JhcC5xdWVyeVNlbGVjdG9yKFwiLnNjcm9sbFwiKTtcblxuICAgICAgICAgICAgdmFyIG1pZGRsZSA9IGljb25zRGl2WzBdLm9mZnNldFdpZHRoLzI7XG4gICAgICAgICAgICB2YXIgY3VyRWwgPSBhbmd1bGFyLmVsZW1lbnQoaWNvbnNbaW5kZXhdKTtcbiAgICAgICAgICAgIHZhciBwcnZFbCA9IGFuZ3VsYXIuZWxlbWVudChpY29uc0RpdlswXS5xdWVyeVNlbGVjdG9yKFwiLmFjdGl2ZVwiKSk7XG4gICAgICAgICAgICBpZihjdXJFbCAmJiBjdXJFbC5sZW5ndGgpe1xuICAgICAgICAgICAgICB2YXIgY3VyRWxXaWR0aCA9IGN1ckVsWzBdLm9mZnNldFdpZHRoLCBjdXJFbExlZnQgPSBjdXJFbFswXS5vZmZzZXRMZWZ0O1xuXG4gICAgICAgICAgICAgIGlmKHBydkVsLmF0dHIoJ2ljb24tb2ZmJykpIHtcbiAgICAgICAgICAgICAgICBwcnZFbC5hdHRyKFwiY2xhc3NcIiwgcHJ2RWwuYXR0cignaWNvbi1vZmYnKSk7XG4gICAgICAgICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgICAgICBwcnZFbC5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihjdXJFbC5hdHRyKCdpY29uLW9uJykpIHtcbiAgICAgICAgICAgICAgICBjdXJFbC5hdHRyKFwiY2xhc3NcIiwgY3VyRWwuYXR0cignaWNvbi1vbicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJFbC5hZGRDbGFzcyhcImFjdGl2ZVwiKTtcblxuICAgICAgICAgICAgICB2YXIgbGVmdFN0ciA9IChtaWRkbGUgIC0gKGN1ckVsTGVmdCkgLSAgY3VyRWxXaWR0aC8yICsgNSk7XG4gICAgICAgICAgICAgIC8vSWYgdGFicyBhcmUgbm90IHNjcm9sbGFibGVcbiAgICAgICAgICAgICAgaWYoIXNjcm9sbERpdil7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRTdHIgPSAobWlkZGxlICAtIChjdXJFbExlZnQpIC0gIGN1ckVsV2lkdGgvMiArIDUpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHdyYXAuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gIFwidHJhbnNsYXRlM2QoXCIrbGVmdFN0citcIiwwLDApXCIgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vSWYgc2Nyb2xsYWJsZSB0YWJzXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBXaWR0aCA9IHdyYXAub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRYID0gTWF0aC5hYnMoZ2V0WChzY3JvbGxEaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSAxMDA7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPZmZzZXQgPSA1NDtcbiAgICAgICAgICAgICAgICAvL0lmIHRhYnMgYXJlIHJlYWNoaW5nIHJpZ2h0IGVuZCBvciBsZWZ0IGVuZFxuICAgICAgICAgICAgICAgIGlmKCgoY3VycmVudFggKyB3cmFwV2lkdGgpIDwgKGN1ckVsTGVmdCArIGN1ckVsV2lkdGggKyBlbGVtZW50T2Zmc2V0KSkgfHwgKGN1cnJlbnRYID4gKGN1ckVsTGVmdCAtIGxlZnRPZmZzZXQpKSl7XG4gICAgICAgICAgICAgICAgICBpZihsZWZ0U3RyID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRTdHIgPSAwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhpcyBzY3JvbGxUbywgc28gd2hlbiBzY3JvbGxpbmcgdGFiIG1hbnVhbGx5IHdpbGwgbm90IGZsaWNrZXJcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlvbmljU2Nyb2xsRGVsZWdhdGUuc2Nyb2xsVG8oTWF0aC5hYnMobGVmdFN0ciksIDAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmKGxlZnRTdHIgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgbGVmdFN0ciA9IDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpb25pY1Njcm9sbERlbGVnYXRlLnNjcm9sbFRvKE1hdGguYWJzKGxlZnRTdHIpLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGZ1bmN0aW9uIGdldFgobWF0cml4KSB7XG5cbiAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5yZXBsYWNlKFwidHJhbnNsYXRlM2QoXCIsXCJcIik7XG4gICAgICAgICAgICBtYXRyaXggPSBtYXRyaXgucmVwbGFjZShcInRyYW5zbGF0ZShcIixcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiAocGFyc2VJbnQobWF0cml4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBldmVudHMgPSBzY29wZS5ldmVudHM7XG4gICAgICAgICAgZXZlbnRzLm9uKCdzbGlkZUNoYW5nZScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2V0UG9zaXRpb24oZGF0YS5pbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRzLm9uKCduZ1JlcGVhdEZpbmlzaGVkJywgZnVuY3Rpb24obmdSZXBlYXRGaW5pc2hlZEV2ZW50KSB7XG4gICAgICAgICAgICByZW5kZXJTY3JvbGxhYmxlVGFicygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW5kZXJTY3JvbGxhYmxlVGFicygpO1xuICAgICAgICAgIH0sIDEwKTtcblxuICAgICAgICB9LFxuICAgICAgICBjb250cm9sbGVyIDogZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsICRlbGVtZW50LCAkcm9vdFNjb3BlKSB7XG4gICAgICAgICAgJHNjb3BlLmV2ZW50cyA9IG5ldyBTaW1wbGVQdWJTdWIoKTtcbiAgICAgICAgICAkc2NvcGUuc2xpZGVIYXNDaGFuZ2VkID0gZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coXCJTbGlkZUNoYW5nZWQgXCIraW5kZXgpO1xuICAgICAgICAgICAgJHNjb3BlLmN1cnJlbnRTbGlkZSA9IGluZGV4O1xuICAgICAgICAgICAgJHNjb3BlLmV2ZW50cy50cmlnZ2VyKFwic2xpZGVDaGFuZ2VcIiwge1wiaW5kZXhcIiA6IGluZGV4fSk7XG4gICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZigkc2NvcGUub25TbGlkZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAkc2NvcGUub25TbGlkZU1vdmUoe1wiaW5kZXhcIiA6IGV2YWwoaW5kZXgpfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdmZWVkJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3RyZW5kaW5nJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2hvdCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdjcmVhdGVkJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2FjdGl2ZSc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICdwcm9tb3RlZCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSA2KSB7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLmZpbHRlciA9ICd0cmVuZGluZzMwJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3ZvdGVzJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2NoaWxkcmVuJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2Nhc2hvdXQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndHJlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnaG90JztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ2NyZWF0ZWQnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnYWN0aXZlJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3Byb21vdGVkJztcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZmlsdGVyOmNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UuZmlsdGVyID0gJ3RyZW5kaW5nMzAnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNikge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAndm90ZXMnO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2hpbGRyZW4nO1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZS5maWx0ZXIgPSAnY2FzaG91dCc7XG4gICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgJHNjb3BlLiRvbignbmdSZXBlYXRGaW5pc2hlZCcsIGZ1bmN0aW9uKG5nUmVwZWF0RmluaXNoZWRFdmVudCkge1xuICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ25nUmVwZWF0RmluaXNoZWQnKTtcbiAgICAgICAgICAgICRzY29wZS5ldmVudHMudHJpZ2dlcihcIm5nUmVwZWF0RmluaXNoZWRcIiwge1wiZXZlbnRcIiA6IG5nUmVwZWF0RmluaXNoZWRFdmVudH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgfVxuICBdKTtcblxuXHRhcHAuZmlsdGVyKCd0aW1lYWdvJywgZnVuY3Rpb24oJGZpbHRlciwgJHRyYW5zbGF0ZSwgJHJvb3RTY29wZSkge1xuXG4gICAgICBmdW5jdGlvbiBUaW1lQWdvKGlucHV0LCBwX2FsbG93RnV0dXJlKSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRlID0gZnVuY3Rpb24gKHN0cmluZ09yRnVuY3Rpb24sIG51bWJlciwgc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBhbmd1bGFyLmlzRnVuY3Rpb24oc3RyaW5nT3JGdW5jdGlvbikgPyBzdHJpbmdPckZ1bmN0aW9uKG51bWJlciwgZGF0ZURpZmZlcmVuY2UpIDogc3RyaW5nT3JGdW5jdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAoc3RyaW5ncy5udW1iZXJzICYmIHN0cmluZ3MubnVtYmVyc1tudW1iZXJdKSB8fCBudW1iZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8lZC9pLCB2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm93VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgICAgICBkYXRlID0gKG5ldyBEYXRlKGlucHV0KSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgLy9yZWZyZXNoTWlsbGlzPSA2ZTQsIC8vQSBtaW51dGVcbiAgICAgICAgICAgIGFsbG93RnV0dXJlID0gcF9hbGxvd0Z1dHVyZSB8fCBmYWxzZSxcbiAgICAgICAgICAgIHN0cmluZ3M9IHtcbiAgICAgICAgICAgICAgICBwcmVmaXhBZ286ICcnLFxuICAgICAgICAgICAgICAgIHByZWZpeEZyb21Ob3c6ICcnLFxuICAgICAgICAgICAgICAgIHN1ZmZpeEFnbzogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FHTycpLFxuICAgICAgICAgICAgICAgIHN1ZmZpeEZyb21Ob3c6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdGUk9NX05PVycpLFxuICAgICAgICAgICAgICAgIHNlY29uZHM6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTRUNTJyksXG4gICAgICAgICAgICAgICAgbWludXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQV9NSU4nKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzOiBcIiVkIFwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdNSU5TJyksXG4gICAgICAgICAgICAgICAgaG91cjogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FOX0hPVVInKSxcbiAgICAgICAgICAgICAgICBob3VyczogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnSE9VUlMnKSxcbiAgICAgICAgICAgICAgICBkYXk6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBX0RBWScpLFxuICAgICAgICAgICAgICAgIGRheXM6IFwiJWQgXCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ0RBWVMnKSxcbiAgICAgICAgICAgICAgICBtb250aDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FfTU9OVEgnKSxcbiAgICAgICAgICAgICAgICBtb250aHM6IFwiJWQgXCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ01PTlRIUycpLFxuICAgICAgICAgICAgICAgIHllYXI6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdBX1lFQVInKSxcbiAgICAgICAgICAgICAgICB5ZWFyczogXCIlZCBcIiskZmlsdGVyKCd0cmFuc2xhdGUnKSgnWUVBUlMnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGVEaWZmZXJlbmNlID0gbm93VGltZSAtIGRhdGUsXG4gICAgICAgICAgICB3b3JkcyxcbiAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLmFicyhkYXRlRGlmZmVyZW5jZSkgLyAxMDAwLFxuICAgICAgICAgICAgbWludXRlcyA9IHNlY29uZHMgLyA2MCxcbiAgICAgICAgICAgIGhvdXJzID0gbWludXRlcyAvIDYwLFxuICAgICAgICAgICAgZGF5cyA9IGhvdXJzIC8gMjQsXG4gICAgICAgICAgICB5ZWFycyA9IGRheXMgLyAzNjUsXG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBzdHJpbmdzLndvcmRTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICBcIiBcIiA6IHN0cmluZ3Mud29yZFNlcGFyYXRvcixcblxuXG4gICAgICAgICAgICBwcmVmaXggPSBzdHJpbmdzLnByZWZpeEFnbyxcbiAgICAgICAgICAgIHN1ZmZpeCA9IHN0cmluZ3Muc3VmZml4QWdvO1xuXG4gICAgICAgIGlmIChhbGxvd0Z1dHVyZSkge1xuICAgICAgICAgICAgaWYgKGRhdGVEaWZmZXJlbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IHN0cmluZ3MucHJlZml4RnJvbU5vdztcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBzdHJpbmdzLnN1ZmZpeEZyb21Ob3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3b3JkcyA9IHNlY29uZHMgPCA0NSAmJiBzdWJzdGl0dXRlKHN0cmluZ3Muc2Vjb25kcywgTWF0aC5yb3VuZChzZWNvbmRzKSwgc3RyaW5ncykgfHxcbiAgICAgICAgc2Vjb25kcyA8IDkwICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5taW51dGUsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIG1pbnV0ZXMgPCA0NSAmJiBzdWJzdGl0dXRlKHN0cmluZ3MubWludXRlcywgTWF0aC5yb3VuZChtaW51dGVzKSwgc3RyaW5ncykgfHxcbiAgICAgICAgbWludXRlcyA8IDkwICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5ob3VyLCAxLCBzdHJpbmdzKSB8fFxuICAgICAgICBob3VycyA8IDI0ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5ob3VycywgTWF0aC5yb3VuZChob3VycyksIHN0cmluZ3MpIHx8XG4gICAgICAgIGhvdXJzIDwgNDIgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLmRheSwgMSwgc3RyaW5ncykgfHxcbiAgICAgICAgZGF5cyA8IDMwICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5kYXlzLCBNYXRoLnJvdW5kKGRheXMpLCBzdHJpbmdzKSB8fFxuICAgICAgICBkYXlzIDwgNDUgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLm1vbnRoLCAxLCBzdHJpbmdzKSB8fFxuICAgICAgICBkYXlzIDwgMzY1ICYmIHN1YnN0aXR1dGUoc3RyaW5ncy5tb250aHMsIE1hdGgucm91bmQoZGF5cyAvIDMwKSwgc3RyaW5ncykgfHxcbiAgICAgICAgeWVhcnMgPCAxLjUgJiYgc3Vic3RpdHV0ZShzdHJpbmdzLnllYXIsIDEsIHN0cmluZ3MpIHx8XG4gICAgICAgIHN1YnN0aXR1dGUoc3RyaW5ncy55ZWFycywgTWF0aC5yb3VuZCh5ZWFycyksIHN0cmluZ3MpO1xuICAgICAgICAvLyRyb290U2NvcGUubG9nKHByZWZpeCt3b3JkcytzdWZmaXgrc2VwYXJhdG9yKTtcbiAgICAgICAgcHJlZml4LnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgIHdvcmRzLnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgIHN1ZmZpeC5yZXBsYWNlKC8gL2csICcnKVxuICAgICAgICByZXR1cm4gKHByZWZpeCsnICcrd29yZHMrJyAnK3N1ZmZpeCsnICcrc2VwYXJhdG9yKTtcblxuICAgICAgfTtcblxuICAgICAgVGltZUFnby4kc3RhdGVmdWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIFRpbWVBZ287XG4gICAgfSk7XG5cbiAgICBhcHAuZmlsdGVyKCdwYXJzZVVybCcsIGZ1bmN0aW9uKCRzY2UpIHtcblx0ICAgIHZhciB1cmxzID0gLyhcXGIoaHR0cHM/fGZ0cCk6XFwvXFwvW0EtWjAtOSsmQCNcXC8lPz1+X3whOiwuOy1dKlstQS1aMC05KyZAI1xcLyU9fl98XSkvZ2ltO1xuXHQgICAgdmFyIGVtYWlscyA9IC8oXFx3K0BbYS16QS1aX10rP1xcLlthLXpBLVpdezIsNn0pL2dpbTtcbiAgXHQgXHR2YXIgaW1ncyA9IC8oaHR0cHM/OlxcL1xcLy4qXFwuKD86cG5nfGpwZ3xqcGVnfGdpZikpL2dpbTtcbiAgXHRcdHZhciB5b3V0dWJlID0gL14uKigoeW91dHUuYmVcXC8pfCh2XFwvKXwoXFwvdVxcL1xcd1xcLyl8KGVtYmVkXFwvKXwod2F0Y2hcXD8pKVxcPz92Pz0/KFteI1xcJlxcP10qKS4qLztcbiAgXHRcdHZhciB5b3V0dWJlaWQgPSAvKD86KD86eW91dHViZS5jb21cXC93YXRjaFxcP3Y9KXwoPzp5b3V0dS5iZVxcLykpKFtBLVphLXowLTlcXF9cXC1dKykvaTtcblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHR1LCBzdWJwYXJ0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBcdGdmbTogdHJ1ZSxcblx0XHRcdCAgICB0YWJsZXM6IHRydWUsXG4gICAgICAgICAgc21hcnRMaXN0czogdHJ1ZSxcblx0XHRcdCAgICBicmVha3M6IHRydWUsXG5cdFx0XHQgICAgcGVkYW50aWM6IGZhbHNlLFxuXHRcdFx0ICAgIHNhbml0aXplOiBmYWxzZSxcblx0XHRcdCAgICBzbWFydExpc3RzOiB0cnVlLFxuXHRcdFx0ICAgIHNtYXJ0eXBhbnRzOiBmYWxzZVxuXHRcdFx0ICB9O1xuICAgICAgICBpZiAodGV4dHUpIHtcbiAgICAgICAgICB2YXIgdGV4dHUgPSBtYXJrZWQodGV4dHUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChzdWJwYXJ0KSB7XG4gICAgICAgICAgICB2YXIgcyA9ICRzY2UudHJ1c3RBc0h0bWwodGV4dHUpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHMuc3Vic3RyaW5nKHMuaW5kZXhPZihcIjxwPlwiKSwgcy5pbmRleE9mKFwiPC9wPlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwodGV4dHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXHQgICAgfTtcblx0fSk7XG5cbiAgICBhcHAuZmlsdGVyKCdtZXRhZGF0YScsIGZ1bmN0aW9uKCRzY2UpIHtcbiAgICAgICAgdmFyIHVybHMgPSAvKFxcYihodHRwcz98ZnRwKTpcXC9cXC9bQS1aMC05KyZAI1xcLyU/PX5ffCE6LC47LV0qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW07XG4gICAgICAgIHZhciB1c2VycyA9IC8oXnxcXHMpKEBbYS16XVstXFwuYS16XFxkXStbYS16XFxkXSkvZ2ltO1xuICAgICAgICB2YXIgaW1ncyA9IC8oaHR0cHM/OlxcL1xcLy4qXFwuKD86cG5nfGpwZ3xqcGVnfGdpZikpL2dpbTtcbiAgICAgICAgdmFyIHlvdXR1YmUgPSAvXi4qKCh5b3V0dS5iZVxcLyl8KHZcXC8pfChcXC91XFwvXFx3XFwvKXwoZW1iZWRcXC8pfCh3YXRjaFxcPykpXFw/P3Y/PT8oW14jXFwmXFw/XSopLiovO1xuICAgICAgICB2YXIgeW91dHViZWlkID0gLyg/Oig/OnlvdXR1YmUuY29tXFwvd2F0Y2hcXD92PSl8KD86eW91dHUuYmVcXC8pKShbQS1aYS16MC05XFxfXFwtXSspL2k7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHR1KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgICAgICB2YXIgbXVybHMgPSB0ZXh0dS5tYXRjaCh1cmxzKTtcbiAgICAgICAgICAgIHZhciBtdXNlcnMgPSB0ZXh0dS5tYXRjaCh1c2Vycyk7XG4gICAgICAgICAgICB2YXIgbWltZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBtbGlua3MgPSBbXTtcbiAgICAgICAgICAgIGlmIChtdXJscykge1xuICAgICAgICAgICAgICB2YXIgX2xlbiA9IG11cmxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9sZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kID0gbXVybHNbaV0ubWF0Y2goaW1ncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWdzLnB1c2gobXVybHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWxpbmtzLnB1c2gobXVybHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtbGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5tZXJnZShvdXQsIHtsaW5rczogbWxpbmtzfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaW1ncykge1xuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLm1lcmdlKG91dCwge2ltYWdlOiBtaW1nc30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXNlcnMpIHtcbiAgICAgICAgICAgICAgdmFyIF9sZW4gPSBtdXNlcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG11c2Vyc1tpXSA9IG11c2Vyc1tpXS50cmltKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobXVzZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXIubWVyZ2Uob3V0LCB7dXNlcnM6IG11c2Vyc30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBhcHAuZmlsdGVyKCdtZXRhZGF0YVVzZXJzJywgZnVuY3Rpb24oJHNjZSkge1xuICAgICAgICB2YXIgdXNlcnMgPSAvKF58XFxzKShAW2Etel1bLVxcLmEtelxcZF0rW2EtelxcZF0pL2dpbTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHR1KSB7XG4gICAgICAgICAgaWYgKHRleHR1KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgICAgICB2YXIgbXVzZXJzID0gdGV4dHUubWF0Y2godXNlcnMpO1xuXG4gICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhhbmd1bGFyLnRvSnNvbihtdXNlcnMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRleHR1O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ2xkb3RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0KycuLi4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGFwcC5maWx0ZXIoJ3JlZ2V4JywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGZpZWxkLCByZWdleCkge1xuICAgICAgICAgIHZhciBwYXR0ID0gbmV3IFJlZ0V4cChyZWdleCk7ICAgICAgXG4gICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwYXR0LnRlc3QoaW5wdXRbaV1bZmllbGRdKSk7XG4gICAgICAgICAgICBpZighcGF0dC50ZXN0KGlucHV0W2ldW2ZpZWxkXSkpXG4gICAgICAgICAgICAgIG91dC5wdXNoKGlucHV0W2ldKTtcbiAgICAgICAgICB9ICAgICAgXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIGFwcC5maWx0ZXIoJ2RldHJhbnNsaXRlcmF0ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAvLyBjb3B5cGFzdGUgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS90YW1yLzVmYjAwYTFjNjIxNGY1Y2FiNGY2XG4gICAgICAvLyAoaXQgaGF2ZSBiZWVuIG1vZGlmaWVkOiDQuNC5ID4gaXkgYW5kIHNvIG9uKVxuICAgICAgLy8gdGhpcyBoYXZlIGJlZW4gZG9uZSBiZWVjYXVzZSB3ZSBjYW5ub3QgdXNlIHNwZWNpYWwgc3ltYm9scyBpbiB1cmwgKGBgIGFuZCAnJylcbiAgICAgIC8vIGFuZCB1cmwgc2VlbXMgdG8gYmUgdGhlIG9ubHkgc291cmNlIG9mIHRocnV0aFxuICAgICAgdmFyIGQgPSAvXFxzKy9nLFxuICAgICAgLy9ydXMgPSBcItGJICDRiCDRhyDRhiDRjiDRjiDRjyDRjyAg0YvQtSDQuNC5ICDRkSDRkSDQtiDRiiDRjSDRiyDQsCDQsSDQsiDQsyDQtCDQtSDQtyDQuCDQuSDQuiDQuyDQvCDQvSDQviDQvyDRgCDRgSDRgiDRgyDRhCDRhSDRhSAgINGMXCIuc3BsaXQoZCksXG4gICAgICAvL2VuZyA9IFwic2NoICBzaCAgY2ggIGN6ICB5dSAganUgIHlhICBxICB5aWUgIGl5ICB5byAgam8gIHpoICB3IHllICB5IGEgYiB2IGcgZCBlIHogaSB5aSAgayBsIG0gbiBvIHAgciBzIHQgdSBmIHggaCBqXCIuc3BsaXQoZCk7XG5cbiAgICAgIHJ1cyA9IFwi0YkgICAg0YggINGHICDRhiAg0LkgINGRICDRjSAg0Y4gINGPICDRhSAg0LYgINCwINCxINCyINCzINC0INC1INC3INC4INC6INC7INC8INC9INC+INC/INGAINGBINGCINGDINGEINGKICDRiyDRjFwiLnNwbGl0KGQpLFxuICAgICAgZW5nID0gXCJzaGNoIHNoIGNoIGN6IGlqIHlvIHllIHl1IHlhIGtoIHpoIGEgYiB2IGcgZCBlIHogaSBrIGwgbSBuIG8gcCByIHMgdCB1IGYgeHggeSB4XCIuc3BsaXQoZCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgcmV2ZXJzZSkge1xuICAgICAgICBpZiAoIXN0cikgcmV0dXJuIHN0cjtcbiAgICAgICAgaWYgKCFyZXZlcnNlICYmIHN0ci5zdWJzdHJpbmcoMCwgNCkgIT09ICdydS0tJykgcmV0dXJuIHN0cjtcbiAgICAgICAgaWYgKCFyZXZlcnNlKSBzdHIgPSBzdHIuc3Vic3RyaW5nKDQpXG5cbiAgICAgICAgLy8gVE9ETyByZXdvcmsgdGhpc1xuICAgICAgICAvLyAoZGlkbnQgcGxhY2VkIHRoaXMgZWFybGllciBiZWNhdXNlIHNvbWV0aGluZyBpcyBicmVha2luZyBhbmQgaSBhbSB0b28gbGF6eSB0byBmaWd1cmUgaXQgb3V0IDsoIClcbiAgICAgICAgaWYoIXJldmVyc2UpIHtcbiAgICAgICAgLy8gICAgc3RyID0gc3RyLnJlcGxhY2UoL2ovZywgJ9GMJylcbiAgICAgICAgLy8gICAgc3RyID0gc3RyLnJlcGxhY2UoL3cvZywgJ9GKJylcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC95aWUvZywgJ9GL0LUnKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAvLyAgICBzdHIgPSBzdHIucmVwbGFjZSgv0YwvZywgJ2onKVxuICAgICAgICAvLyAgICBzdHIgPSBzdHIucmVwbGFjZSgv0YovZywgJ3cnKVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL9GL0LUvZywgJ3lpZScpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHMgPSAvW15bXFxdXSsoPz1dKS9nLCBvcmlnID0gc3RyLm1hdGNoKHMpLFxuICAgICAgICAgICAgdCA9IC88KC58XFxuKSo/Pi9nLCB0YWdzID0gc3RyLm1hdGNoKHQpO1xuXG4gICAgICAgIGlmKHJldmVyc2UpIHtcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IHJ1cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdChydXNbaV0pLmpvaW4oZW5nW2ldKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQocnVzW2ldLnRvVXBwZXJDYXNlKCkpLmpvaW4oZW5nW2ldLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcnVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KGVuZ1tpXSkuam9pbihydXNbaV0pO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdChlbmdbaV0udG9VcHBlckNhc2UoKSkuam9pbihydXNbaV0udG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihvcmlnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdG9yZU9yaWcgPSBzdHIubWF0Y2gocyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN0b3JlT3JpZy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShyZXN0b3JlT3JpZ1tpXSwgb3JpZ1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0YWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdG9yZVRhZ3MgPSBzdHIubWF0Y2godCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN0b3JlVGFncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShyZXN0b3JlVGFnc1tpXSwgdGFnc1tpXSk7XG5cbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXFsvZywgJycpLnJlcGxhY2UoL1xcXS9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0pXG4gICAgIGFwcC5maWx0ZXIoJ2dldEN1cnJlbmN5U3ltYm9sJywgZnVuY3Rpb24oJGZpbHRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHRleHQuc3BsaXQoJy0nKVsxXSk7XG4gICAgICAgICAgICAvL3ZhciB4ID0gdGV4dC5zcGxpdCgnLScpWzFdO1xuICAgICAgICAgICAgLy92YXIgdHQgPSAkZmlsdGVyKCd1cHBlcmNhc2UnKSh4KTtcbiAgICAgICAgICAgIHZhciB0ZXh0dSA9IHdpbmRvdy5nZXRTeW1ib2wodGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dHU9PVwiP1wiP3RleHQ6dGV4dHU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gIGZ1bmN0aW9uIGFuc2lXb3JkQm91bmQoYykge1xuICAgIHJldHVybiAoXG4gICAgICAoJyAnID09PSBjKSB8fFxuICAgICAgKCdcXG4nID09PSBjKSB8fFxuICAgICAgKCdcXHInID09PSBjKSB8fFxuICAgICAgKCdcXHQnID09PSBjKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRpbmdUaW1lKHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgd29yZHMgPSAwLCBzdGFydCA9IDAsIGVuZCA9IHRleHQubGVuZ3RoIC0gMSwgd29yZEJvdW5kLCBpXG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgLy8gdXNlIGRlZmF1bHQgdmFsdWVzIGlmIG5lY2Vzc2FyeVxuICAgIG9wdGlvbnMud29yZHNQZXJNaW51dGUgPSBvcHRpb25zLndvcmRzUGVyTWludXRlIHx8IDIwMFxuXG4gICAgLy8gdXNlIHByb3ZpZGVkIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgIHdvcmRCb3VuZCA9IG9wdGlvbnMud29yZEJvdW5kIHx8IGFuc2lXb3JkQm91bmRcblxuICAgIC8vIGZldGNoIGJvdW5kc1xuICAgIHdoaWxlICh3b3JkQm91bmQodGV4dFtzdGFydF0pKSBzdGFydCsrXG4gICAgd2hpbGUgKHdvcmRCb3VuZCh0ZXh0W2VuZF0pKSBlbmQtLVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygd29yZHNcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8PSBlbmQ7KSB7XG4gICAgICBmb3IgKDsgaSA8PSBlbmQgJiYgIXdvcmRCb3VuZCh0ZXh0W2ldKTsgaSsrKSA7XG4gICAgICB3b3JkcysrXG4gICAgICBmb3IgKDsgaSA8PSBlbmQgJiYgd29yZEJvdW5kKHRleHRbaV0pOyBpKyspIDtcbiAgICB9XG5cbiAgICAvLyByZWFkaW5nIHRpbWUgc3RhdHNcbiAgICB2YXIgbWludXRlcyA9IHdvcmRzIC8gb3B0aW9ucy53b3Jkc1Blck1pbnV0ZVxuICAgIHZhciB0aW1lID0gbWludXRlcyAqIDYwICogMTAwMFxuICAgIHZhciBkaXNwbGF5ZWQgPSBNYXRoLmNlaWwobWludXRlcy50b0ZpeGVkKDIpKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IGRpc3BsYXllZCArICcgbWluIHJlYWQnLFxuICAgICAgbWludXRlczogTWF0aC5jZWlsKG1pbnV0ZXMudG9GaXhlZCgyKSksXG4gICAgICB0aW1lOiB0aW1lLFxuICAgICAgd29yZHM6IHdvcmRzXG4gICAgfVxuICB9XG5cbiAgYXBwLmZpbHRlcigncmVhZGluZ3RpbWUnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHJldHVybiByZWFkaW5nVGltZSh0ZXh0KS5taW51dGVzO1xuICAgICAgICB9XG4gICAgICB9O1xuICB9KVxuXG5cdGFwcC5maWx0ZXIoJ3NwJywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkvMWU2KiRyb290U2NvcGUuJHN0b3JhZ2Uuc3RlZW1fcGVyX212ZXN0cykudG9GaXhlZCgzKTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcignc2QnLCBmdW5jdGlvbigkc2NlLCAkcm9vdFNjb3BlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24odGV4dCwgYmFsYW5jZSwgc2JkKSB7XG5cdCAgICBcdGlmICh0ZXh0KSB7XG5cdCAgICBcdFx0cmV0dXJuICgoTnVtYmVyKHRleHQuc3BsaXQoXCIgXCIpWzBdKS8xZTYqJHJvb3RTY29wZS4kc3RvcmFnZS5zdGVlbV9wZXJfbXZlc3RzKiRyb290U2NvcGUuJHN0b3JhZ2UuYmFzZSArIE51bWJlcihiYWxhbmNlLnNwbGl0KFwiIFwiKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5iYXNlICsgTnVtYmVyKHNiZC5zcGxpdChcIiBcIilbMF0pKS50b0ZpeGVkKDMpKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZTtcblx0ICAgIFx0fVxuXHQgICAgfTtcblx0fSlcblx0YXBwLmZpbHRlcignc2JkJywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkudG9GaXhlZCgzKSk7XG5cdCAgICBcdH1cblx0ICAgIH07XG5cdH0pXG5cdGFwcC5maWx0ZXIoJ3N0JywgZnVuY3Rpb24oJHNjZSwgJHJvb3RTY29wZSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgIFx0aWYgKHRleHQpIHtcblx0ICAgIFx0XHRyZXR1cm4gKE51bWJlcih0ZXh0LnNwbGl0KFwiIFwiKVswXSkudG9GaXhlZCgzKSk7XG5cdCAgICBcdH1cblx0ICAgIH07XG5cdH0pXG5cdGFwcC5maWx0ZXIoJ3JlcHV0YXRpb24nLCBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSwgYm9vbCkge1xuXHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IDE7XG5cdFx0XHRuZWcgPSBmYWxzZTtcblxuXHRcdFx0aWYgKHZhbHVlIDwgMClcblx0XHRcdFx0bmVnID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHZhbHVlICE9IDApIHtcblx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IE1hdGgubG9nMTAoTWF0aC5hYnModmFsdWUpKTtcblx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IE1hdGgubWF4KHJlcHV0YXRpb25fbGV2ZWwgLSA5LCAwKTtcblxuXHRcdFx0XHRpZiAocmVwdXRhdGlvbl9sZXZlbCA8IDApXG5cdFx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCA9IDA7XG5cdFx0XHRcdGlmIChuZWcpXG5cdFx0XHRcdFx0cmVwdXRhdGlvbl9sZXZlbCAqPSAtMTtcblxuXHRcdFx0XHRyZXB1dGF0aW9uX2xldmVsID0gKHJlcHV0YXRpb25fbGV2ZWwqOSkgKyAyNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYm9vbD9yZXB1dGF0aW9uX2xldmVsOk1hdGguZmxvb3IocmVwdXRhdGlvbl9sZXZlbCk7XG5cdFx0fVxuXHR9KVxuXG4gIGFwcC5maWx0ZXIoXCJzdW1Qb3N0VG90YWxcIiwgZnVuY3Rpb24oJHJvb3RTY29wZSl7XG4gICAgZnVuY3Rpb24gU3VtUG9zdFRvdGFsKHZhbHVlLCByYXRlKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKHZhbHVlLCByYXRlKTtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5wZW5kaW5nX3BheW91dF92YWx1ZSkge1xuICAgICAgICAvL3ZhbHVlLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pK3BhcnNlRmxvYXQodmFsdWUudG90YWxfcGVuZGluZ19wYXlvdXRfdmFsdWUuc3BsaXQoXCIgXCIpWzBdKVxuICAgICAgICAvL3JldHVybiAocGFyc2VGbG9hdCh2YWx1ZS5wZW5kaW5nX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pKnJhdGUpO1xuICAgICAgICByZXR1cm4gKChwYXJzZUZsb2F0KHZhbHVlLnRvdGFsX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pKSsocGFyc2VGbG9hdCh2YWx1ZS5wZW5kaW5nX3BheW91dF92YWx1ZS5zcGxpdChcIiBcIilbMF0pKSpyYXRlKS50b0ZpeGVkKDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvL1N1bVBvc3RUb3RhbC4kc3RhdGVmdWwgPSB0cnVlO1xuXG4gICAgcmV0dXJuIFN1bVBvc3RUb3RhbDtcbiAgfSk7XG5cbiAgYXBwLmZpbHRlcihcInJhdGVcIiwgZnVuY3Rpb24oJHJvb3RTY29wZSl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KHZhbHVlKSokcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgIFxuXG4gIGFwcC5maWx0ZXIoJ2hyZWZUb0pTJywgZnVuY3Rpb24gKCRzY2UsICRzYW5pdGl6ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgdmFyIHJlZ2V4ID0gL2hyZWY9XCIoW1xcU10rKVwiL2c7XG4gICAgICAgICAgdmFyIG5ld1N0cmluZyA9ICRzYW5pdGl6ZSh0ZXh0KS5yZXBsYWNlKHJlZ2V4LCBcImhyZWYgb25DbGljaz1cXFwid2luZG93Lm9wZW4oJyQxJywgJ19zeXN0ZW0nLCAnbG9jYXRpb249eWVzJyk7cmV0dXJuIGZhbHNlO1xcXCJcIik7XG4gICAgICAgICAgcmV0dXJuICRzY2UudHJ1c3RBc0h0bWwobmV3U3RyaW5nKTtcbiAgICAgIH1cbiAgfSk7XG5cbiAgYXBwLmRpcmVjdGl2ZSgnYXV0b2ZvY3VzJywgWyckdGltZW91dCcsXG4gICAgZnVuY3Rpb24gKCR0aW1lb3V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICBsaW5rOiBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCkge1xuICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pO1xuXG4gIGFwcC5kaXJlY3RpdmUoJ3NlbGVjdElucHV0JywgWyckaW9uaWNQb3B1cCcsICckcm9vdFNjb3BlJywgZnVuY3Rpb24oJGlvbmljUG9wdXAsICRyb290U2NvcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpYzogJ0UnLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgY3VycmVudElucHV0OiAnPW5nTW9kZWwnLFxuICAgICAgICBzZWxlY3RPcHRpb25zOiAnPSdcbiAgICAgIH0sXG4gICAgICByZXF1aXJlOiAnP15uZ01vZGVsJyxcbiAgICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cIml0ZW0taW5wdXQgaXRlbS1pY29uLXJpZ2h0XCIgc3R5bGU9XCJ3aWR0aDoxMDAlO1wiPjxpbnB1dCBuZy1tb2RlbD1cImN1cnJlbnRJbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgbmctY2hhbmdlPVwic29ja2V0Q2hhbmdlKGN1cnJlbnRJbnB1dClcIj48aSBjbGFzcz1cImljb24gaW9uLWFuZHJvaWQtYXJyb3ctZHJvcGRvd25cIiBuZy1jbGljaz1cInNob3dPcHRpb25zKClcIj48L2k+PC9kaXY+JyxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBzY29wZS5vcHRpb25zID0ge1xuICAgICAgICAgIHNlbGVjdGVkOiAnJ1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLnNvY2tldENoYW5nZSA9IGZ1bmN0aW9uKHh4KXtcbiAgICAgICAgICBjb25zb2xlLmxvZyh4eCk7XG4gICAgICAgICAgJHJvb3RTY29wZS4kc3RvcmFnZVtcInNvY2tldFwiKyRyb290U2NvcGUuJHN0b3JhZ2UuY2hhaW5dID0geHg7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNvY2tldFVybCA9IHh4O1xuICAgICAgICAgIHNjb3BlLnJlc3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLnNob3dPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJGlvbmljUG9wdXAuc2hvdyh7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxpb24tcmFkaW8gbmctcmVwZWF0PVwiaXRlbSBpbiBzZWxlY3RPcHRpb25zXCIgY2xhc3M9XCJpdGVtLXRleHQtd3JhcFwiIG5nLW1vZGVsPVwib3B0aW9ucy5zZWxlY3RlZFwiIG5nLXZhbHVlPVwiaXRlbVwiPnt7aXRlbX19PC9pb24tcmFkaW8+JyxcbiAgICAgICAgICAgIHRpdGxlOiAnU2VydmVyJyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnbXktY3VzdG9tLXBvcHVwJyxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFt7XG4gICAgICAgICAgICAgIHRleHQ6ICdDYW5jZWwnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHRleHQ6ICc8Yj5Db25maXJtPC9iPicsXG4gICAgICAgICAgICAgIHR5cGU6ICdidXR0b24tcG9zaXRpdmUnLFxuICAgICAgICAgICAgICBvblRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmN1cnJlbnRJbnB1dCA9IHNjb3BlLm9wdGlvbnMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKVxuXG5cdGFwcC5kaXJlY3RpdmUoJ3FyY29kZScsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0ICAgIHJlc3RyaWN0OiAnRScsXG5cdFx0ICAgIGxpbms6IGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycykge1xuXG5cdFx0ICAgICAgdmFyIG9wdGlvbnMgPSB7XG5cdFx0ICAgICAgICB0ZXh0OiAnJyxcblx0XHQgICAgICAgIHdpZHRoOiAxMjgsXG5cdFx0ICAgICAgICBoZWlnaHQ6IDEyOCxcblx0XHQgICAgICAgIGNvbG9yRGFyazogJyMwMDAwMDAnLFxuXHRcdCAgICAgICAgY29sb3JMaWdodDogJyNmZmZmZmYnLFxuXHRcdCAgICAgICAgY29ycmVjdExldmVsOiAnSCdcblx0XHQgICAgICB9O1xuXG5cdFx0ICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHQgICAgICAgIG9wdGlvbnNba2V5XSA9ICRpbnRlcnBvbGF0ZSgkYXR0cnNba2V5XSB8fCAnJykoJHNjb3BlKSB8fCBvcHRpb25zW2tleV07XG5cdFx0ICAgICAgfSk7XG5cblx0XHQgICAgICBvcHRpb25zLmNvcnJlY3RMZXZlbCA9IFFSQ29kZS5Db3JyZWN0TGV2ZWxbb3B0aW9ucy5jb3JyZWN0TGV2ZWxdO1xuXG5cdFx0ICAgICAgbmV3IFFSQ29kZSgkZWxlbWVudFswXSwgb3B0aW9ucyk7XG5cblx0XHQgICAgfVxuXHRcdH1cblx0fSk7XG5cblxuICAgIGFwcC5kaXJlY3RpdmUoJ2lvbkNvbW1lbnQnLCBpb25Db21tZW50KVxuICAgIGFwcC5kaXJlY3RpdmUoJ2lvblRocmVhZCcsIGlvblRocmVhZCk7XG5cbiAgICBmdW5jdGlvbiBpb25Db21tZW50KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgY29tbWVudDogJz0nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8aW9uLWl0ZW0gbmctaWY9XCJjb21tZW50LmF1dGhvclwiIGNsYXNzPVwiaW9uLWNvbW1lbnQgaXRlbVwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLWF1dGhvclwiPjxpbWcgY2xhc3M9XCJyb3VuZC1hdmF0YXJcIiBzcmM9XCJpbWcvdXNlcl9wcm9maWxlLnBuZ1wiIG5nLXNyYz1cInt7JHJvb3QuJHN0b3JhZ2UucGFjY291bnRzW2NvbW1lbnQuYXV0aG9yXS51c2VyX2ltYWdlfHwkcm9vdC4kc3RvcmFnZS5wYWNjb3VudHNbY29tbWVudC5hdXRob3JdLnByb2ZpbGUucHJvZmlsZV9pbWFnZX19XCIgb25lcnJvcj1cInRoaXMuc3JjPVxcJ2ltZy91c2VyX3Byb2ZpbGUucG5nXFwnXCIgb25hYm9ydD1cInRoaXMuc3JjPVxcJ2ltZy91c2VyX3Byb2ZpbGUucG5nXFwnXCIgLz48Yj48YSBocmVmPVwiIy9hcHAvcHJvZmlsZS97e2NvbW1lbnQuYXV0aG9yfX1cIj57e2NvbW1lbnQuYXV0aG9yfX08L2E+PC9iPiZuYnNwOzxkaXYgY2xhc3M9XCJyZXB1dGF0aW9uXCI+e3tjb21tZW50LmF1dGhvcl9yZXB1dGF0aW9ufHJlcHV0YXRpb258bnVtYmVyOjB9fTwvZGl2PiZtaWRkb3Q7e3tjb21tZW50LmNyZWF0ZWR8dGltZWFnb319PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpb24tY29tbWVudC0tc2NvcmVcIj48c3BhbiBvbi10YXA9XCJvcGVuVG9vbHRpcCgkZXZlbnQsY29tbWVudClcIj48Yj57eyRyb290LiRzdG9yYWdlLmN1cnJlbmN5fGdldEN1cnJlbmN5U3ltYm9sfX08L2I+IDxzcGFuIG5nLWlmPVwiY29tbWVudC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KFxcJyBcXCcpWzBdID09PSBcXCcwLjAwMFxcJ1wiPjxkZWw+e3tjb21tZW50IHwgc3VtUG9zdFRvdGFsOiRyb290LiRzdG9yYWdlLmN1cnJlbmN5UmF0ZSB8IG51bWJlcn19PC9kZWw+PC9zcGFuPjxzcGFuIG5nLWlmPVwiY29tbWVudC5tYXhfYWNjZXB0ZWRfcGF5b3V0LnNwbGl0KFxcJyBcXCcpWzBdICE9PSBcXCcwLjAwMFxcJ1wiPnt7Y29tbWVudCB8IHN1bVBvc3RUb3RhbDokcm9vdC4kc3RvcmFnZS5jdXJyZW5jeVJhdGUgfCBudW1iZXJ9fTwvc3Bhbj4gPC9zcGFuPiB8IDxzcGFuIG9uLXRhcD1cImRvd252b3RlUG9zdChjb21tZW50KVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtZmxhZ1wiIG5nLWNsYXNzPVwie1xcJ2Fzc2VydGl2ZVxcJzpjb21tZW50LmRvd252b3RlZH1cIj48L3NwYW4+PC9zcGFuPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLXRleHQgYm9keXRleHQgc2VsZWN0YWJsZVwiIG5nLWJpbmQtaHRtbD1cImNvbW1lbnQuYm9keSB8IHBhcnNlVXJsIFwiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaW9uLWNvbW1lbnQtLXJlcGxpZXNcIj48aW9uLXNwaW5uZXIgbmctaWY9XCJjb21tZW50Lmludm90aW5nXCI+PC9pb24tc3Bpbm5lcj48c3BhbiBvbi10YXA9XCJ1cHZvdGVQb3N0KGNvbW1lbnQpXCIgb24taG9sZD1cIm9wZW5TbGlkZXJyKCRldmVudCwgY29tbWVudClcIj48c3BhbiBjbGFzcz1cImZhIGZhLWNoZXZyb24tY2lyY2xlLXVwXCIgbmctY2xhc3M9XCJ7XFwncG9zaXRpdmVcXCc6Y29tbWVudC51cHZvdGVkfVwiPjwvc3Bhbj4ge3tcIlVQVk9URVwifHRyYW5zbGF0ZX19PC9zcGFuPiB8IDxzcGFuIG9uLXRhcD1cIiRyb290Lm9wZW5JbmZvKGNvbW1lbnQpXCI+e3tjb21tZW50Lm5ldF92b3RlcyB8fCAwfX0ge3tcIlZPVEVTXCJ8dHJhbnNsYXRlfX08L3NwYW4+IHwgPHNwYW4gb24tdGFwPVwidG9nZ2xlQ29tbWVudChjb21tZW50KVwiPnt7Y29tbWVudC5jaGlsZHJlbiB8fCAwfX0ge3tcIlJFUExJRVNcInx0cmFuc2xhdGV9fTwvc3Bhbj4gfCA8c3BhbiBvbi10YXA9XCJyZXBseVRvQ29tbWVudChjb21tZW50KVwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtcmVwbHlcIj48L3NwYW4+IHt7XCJSRVBMWVwifHRyYW5zbGF0ZX19PC9zcGFuPiA8c3BhbiBuZy1pZj1cImNvbW1lbnQuYXV0aG9yID09ICRyb290LiRzdG9yYWdlLnVzZXIudXNlcm5hbWUgJiYgY29tcGF0ZURhdGUoY29tbWVudClcIiBvbi10YXA9XCJlZGl0Q29tbWVudChjb21tZW50KVwiPiB8IDxzcGFuIGNsYXNzPVwiaW9uLWlvcy1jb21wb3NlLW91dGxpbmVcIj48L3NwYW4+IHt7XFwnRURJVFxcJ3x0cmFuc2xhdGV9fTwvc3Bhbj4gPHNwYW4gbmctaWY9XCJjb21tZW50LmF1dGhvciA9PSAkcm9vdC4kc3RvcmFnZS51c2VyLnVzZXJuYW1lICYmIGNvbW1lbnQuYWJzX3JzaGFyZXMgPT0gMFwiIG9uLXRhcD1cImRlbGV0ZUNvbW1lbnQoY29tbWVudClcIj4gfCA8c3BhbiBjbGFzcz1cImlvbi1pb3MtdHJhc2gtb3V0bGluZVwiPjwvc3Bhbj4ge3tcXCdSRU1PVkVcXCd8dHJhbnNsYXRlfX08L3NwYW4+PC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgPC9pb24taXRlbT4nLFxuICAgICAgICAgICAgY29udHJvbGxlcjogZnVuY3Rpb24oJHNjb3BlLCAkcm9vdFNjb3BlLCAkc3RhdGUsICRpb25pY01vZGFsLCAkaW9uaWNQb3BvdmVyLCAkaW9uaWNQb3B1cCwgJGlvbmljQWN0aW9uU2hlZXQsICRjb3Jkb3ZhQ2FtZXJhLCAkZmlsdGVyLCBJbWFnZVVwbG9hZFNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICRpb25pY1BvcG92ZXIuZnJvbVRlbXBsYXRlVXJsKCdwb3BvdmVyVHIuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJHNjb3BlXG4gICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihwb3BvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXAgPSBwb3BvdmVyO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAkaW9uaWNQb3BvdmVyLmZyb21UZW1wbGF0ZVVybCgncG9wb3ZlclNsaWRlcnIuaHRtbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzY29wZTogJHNjb3BlXG4gICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHBvcG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFNsaWRlcnIgPSBwb3BvdmVyO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuU2xpZGVyciA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudm90aW5nUG9zdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5yYW5nZVZhbHVlID0gJHJvb3RTY29wZS4kc3RvcmFnZS52b3RlV2VpZ2h0LzEwMDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyLnNob3coJGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAkc2NvcGUudm90ZVBvc3RTID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwU2xpZGVyci5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS51cHZvdGVQb3N0KCRzY29wZS52b3RpbmdQb3N0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICRzY29wZS5kcmFnID0gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHYpO1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnZvdGVXZWlnaHQgPSB2KjEwMDtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZVNsaWRlcnIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXBTbGlkZXJyLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuVG9vbHRpcCA9IGZ1bmN0aW9uKCRldmVudCwgZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHBwdiA9IE51bWJlcihkLnBlbmRpbmdfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE51bWJlcihkLnByb21vdGVkLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHB2ID0gTnVtYmVyKGQudG90YWxfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXIgPSBOdW1iZXIoZC50b3RhbF9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXS1kLmN1cmF0b3JfcGF5b3V0X3ZhbHVlLnNwbGl0KCcgJylbMF0pKiRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3lSYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JwID0gTnVtYmVyKGQuY3VyYXRvcl9wYXlvdXRfdmFsdWUuc3BsaXQoJyAnKVswXSkqJHJvb3RTY29wZS4kc3RvcmFnZS5jdXJyZW5jeVJhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0aCA9IFwiPGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQT1RFTlRJQUxfUEFZT1VUJykrXCI8L2I+PC9kaXY+PGRpdiBjbGFzcz0nY29sJz5cIiskZmlsdGVyKCdnZXRDdXJyZW5jeVN5bWJvbCcpKCRyb290U2NvcGUuJHN0b3JhZ2UuY3VycmVuY3kpKyRmaWx0ZXIoJ251bWJlcicpKHRwcHYsIDMpK1wiPC9kaXY+PC9kaXY+PGRpdiBjbGFzcz0ncm93Jz48ZGl2IGNsYXNzPSdjb2wnPjxiPlwiKyRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdQQVNUX1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcignZ2V0Q3VycmVuY3lTeW1ib2wnKSgkcm9vdFNjb3BlLiRzdG9yYWdlLmN1cnJlbmN5KSskZmlsdGVyKCdudW1iZXInKSh0cHYsMykrXCI8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPSdyb3cnPjxkaXYgY2xhc3M9J2NvbCc+PGI+XCIrJGZpbHRlcigndHJhbnNsYXRlJykoJ1BBWU9VVCcpK1wiPC9iPjwvZGl2PjxkaXYgY2xhc3M9J2NvbCc+XCIrJGZpbHRlcigndGltZWFnbycpKGQuY2FzaG91dF90aW1lLCB0cnVlKStcIjwvZGl2PjwvZGl2PlwiO1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUudG9vbHRpcFRleHQgPSB0ZXh0aDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXAuc2hvdygkZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlVG9vbHRpcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICRzY29wZS50b29sdGlwLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgIC8vQ2xlYW51cCB0aGUgcG9wb3ZlciB3aGVuIHdlJ3JlIGRvbmUgd2l0aCBpdCFcbiAgICAgICAgICAgICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnRvb2x0aXAucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuY29tcGF0ZURhdGUgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50Lmxhc3RfcGF5b3V0ID09IFwiMTk3MC0wMS0wMVQwMDowMDowMFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5tb2RlID09IFwiZmlyc3RfcGF5b3V0XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAkc2NvcGUudG9nZ2xlQ29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygndG9nZ2xlQ29tbWVudCAnK2NvbW1lbnQuc2hvd0NoaWxkcmVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50LnNob3dDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5zaG93Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29tbWVudC5hdXRob3IsIGNvbW1lbnQucGVybWxpbmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5zaG93Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQuZGVwdGggJSA1ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RlcHRoNScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ29wZW5Db21tZW50cycsIHsgZGF0YTogY29tbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5BcGkuaW5pdFByb21pc2UudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuQXBpLmRhdGFiYXNlX2FwaSgpLmV4ZWMoXCJnZXRfY29udGVudF9yZXBsaWVzXCIsIFtjb21tZW50LmF1dGhvciwgY29tbWVudC5wZXJtbGlua10pLnRoZW4oZnVuY3Rpb24oZGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuY29tbWVudHMgPSBkZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBkZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cy5pbmRleE9mKHYuYXV0aG9yKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50cy5wdXNoKHYuYXV0aG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3Bvc3RBY2NvdW50cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJHNjb3BlLiQkcGhhc2Upe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS4kYnJvYWRjYXN0KCd1cGRhdGU6Y29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbigncG9zdEFjY291bnRzJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLnBhY2NvdW50cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzKVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuQXBpLmluaXRQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LkFwaS5kYXRhYmFzZV9hcGkoKS5leGVjKFwiZ2V0X2FjY291bnRzXCIsIFskcm9vdFNjb3BlLiRzdG9yYWdlLnBvc3RBY2NvdW50c10pLnRoZW4oZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHJlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygdi5qc29uX21ldGFkYXRhID09PSAnc3RyaW5nJyB8fCB2Lmpzb25fbWV0YWRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYuanNvbl9tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2Lmpzb25fbWV0YWRhdGEuaW5kZXhPZihcImNyZWF0ZWRfYXRcIik+LTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuanNvbl9tZXRhZGF0YSA9IGFuZ3VsYXIuZnJvbUpzb24oYW5ndWxhci50b0pzb24odi5qc29uX21ldGFkYXRhKSk7ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5qc29uX21ldGFkYXRhID0gYW5ndWxhci5mcm9tSnNvbih2Lmpzb25fbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJHN0b3JhZ2UucGFjY291bnRzW2tleV0gPSB2Lmpzb25fbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuJCRwaGFzZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICRzY29wZS51cHZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1cHZvdGUnLCAndXBkYXRlOmNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5kb3dudm90ZVBvc3QgPSBmdW5jdGlvbihwb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0FSRV9ZT1VfU1VSRScpLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRE9XTlZPVEVfRkxBRycpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25maXJtUG9wdXAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIHN1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUudm90ZVBvc3QocG9zdCwgJ2Rvd252b3RlJywgJ3VwZGF0ZTpjb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdZb3UgYXJlIG5vdCBzdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS51bnZvdGVQb3N0ID0gZnVuY3Rpb24ocG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnZvdGVQb3N0KHBvc3QsICd1bnZvdGUnLCAndXBkYXRlOmNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YT17fTtcbiAgICAgICAgICAgICAgICAgICRpb25pY01vZGFsLmZyb21UZW1wbGF0ZVVybCgndGVtcGxhdGVzL3JlcGx5Lmh0bWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlOiAkc2NvcGUgIH0pLnRoZW4oZnVuY3Rpb24obW9kYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmNtb2RhbCA9IG1vZGFsO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuTW9kYWwgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbW9kYWwuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmNsb3NlTW9kYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLnJlcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5jbW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzcmVwbHlpbmcgPSBmdW5jdGlvbihjaG8sIHh4KSB7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseWluZyA9IHh4O1xuICAgICAgICAgICAgICAgICAgICAkc2NvcGUucG9zdCA9IGNobztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdGMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5lZGl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUub3Blbk1vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZWRpdGMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmVkaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9ICRzY29wZS5wb3N0LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucGF0Y2hib2R5ID0gJHNjb3BlLnBvc3QuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5vcGVuTW9kYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgJHNjb3BlLnNob3dJbWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgaGlkZVNoZWV0ID0gJGlvbmljQWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBUFRVUkVfUElDVFVSRScpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgIHsgdGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ1NFTEVDVF9QSUNUVVJFJykgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgeyB0ZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX0NVU1RPTV9VUkwnKSB9LFxuICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgIHRpdGxlVGV4dDogJGZpbHRlcigndHJhbnNsYXRlJykoJ0lOU0VSVF9QSUNUVVJFJyksXG4gICAgICAgICAgICAgICAgICAgICBjYW5jZWxUZXh0OiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ0FOQ0VMJyksXG4gICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNhbmNlbCBjb2RlLi5cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2tlZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5pbnNlcnRJbWFnZUMoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAkc2NvcGUuaW5zZXJ0SW1hZ2VDID0gZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAwIHx8IHR5cGUgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uVHlwZTogQ2FtZXJhLkRlc3RpbmF0aW9uVHlwZS5GSUxFX1VSSSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICh0eXBlPT09MCk/Q2FtZXJhLlBpY3R1cmVTb3VyY2VUeXBlLkNBTUVSQTpDYW1lcmEuUGljdHVyZVNvdXJjZVR5cGUuUEhPVE9MSUJSQVJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dFZGl0OiAodHlwZT09PTApP3RydWU6ZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZ1R5cGU6IENhbWVyYS5FbmNvZGluZ1R5cGUuSlBFRyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcG92ZXJPcHRpb25zOiBDYW1lcmFQb3BvdmVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb1Bob3RvQWxidW06IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvcnJlY3RPcmllbnRhdGlvbjp0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAkY29yZG92YUNhbWVyYS5nZXRQaWN0dXJlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBJbWFnZVVwbG9hZFNlcnZpY2UudXBsb2FkSW1hZ2UoaW1hZ2VEYXRhKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIHVybCA9IHJlc3VsdC5zZWN1cmVfdXJsIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSByZXN1bHQuaW1hZ2VVcmwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsID0gXCIgIVtpbWFnZV0oXCIgKyB1cmwgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZyhmaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgKz0gZmluYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBmaW5hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURfRVJST1InKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCAhaW9uaWMuUGxhdGZvcm0uaXNXaW5kb3dzUGhvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNvcmRvdmFDYW1lcmEuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0NBTUVSQV9DQU5DRUxMRUQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgJGlvbmljUG9wdXAucHJvbXB0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU0VUX1VSTCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdESVJFQ1RfTElOS19QSUNUVVJFJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0UGxhY2Vob2xkZXI6ICdodHRwOi8vZXhhbXBsZS5jb20vaW1hZ2UuanBnJ1xuICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmxvZygnWW91ciB1cmwgaXMnICsgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHJlcy50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbCA9IFwiICFbaW1hZ2VdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKGZpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzY29wZS5kYXRhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ICs9IGZpbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5kYXRhLmNvbW1lbnQgPSBmaW5hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZG1wID0gbmV3IHdpbmRvdy5kaWZmX21hdGNoX3BhdGNoKCk7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVQYXRjaCh0ZXh0MSwgdGV4dDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQxICYmIHRleHQxID09PSAnJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hlcyA9IGRtcC5wYXRjaF9tYWtlKHRleHQxLCB0ZXh0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGNoID0gZG1wLnBhdGNoX3RvVGV4dChwYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2g7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAkc2NvcGUucmVwbHkgPSBmdW5jdGlvbiAoeHgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LkFwaS5pbml0UHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCEkc2NvcGUuZWRpdGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lZm9ybWF0ID0gdC5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkrKHQuZ2V0TW9udGgoKSsxKS50b1N0cmluZygpK3QuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkrXCJ0XCIrdC5nZXRIb3VycygpLnRvU3RyaW5nKCkrdC5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSt0LmdldFNlY29uZHMoKS50b1N0cmluZygpK3QuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKStcInpcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSB7dGFnczogYW5ndWxhci5mcm9tSnNvbigkc2NvcGUucG9zdC5qc29uX21ldGFkYXRhKS50YWdzWzBdIHx8IFwiXCIsIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfYXV0aG9yOiAkc2NvcGUucG9zdC5hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF9wZXJtbGluazogJHNjb3BlLnBvc3QucGVybWxpbmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtbGluazogXCJyZS1cIiskc2NvcGUucG9zdC5hdXRob3IrXCItXCIrJHNjb3BlLnBvc3QucGVybWxpbmsrXCItXCIrdGltZWZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICRzY29wZS5kYXRhLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6IGFuZ3VsYXIudG9Kc29uKGpzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRfb3B0aW9uc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X2N1cmF0aW9uX3Jld2FyZHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93X3ZvdGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3I6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWxpbms6IFwicmUtXCIrJHNjb3BlLnBvc3QuYXV0aG9yK1wiLVwiKyRzY29wZS5wb3N0LnBlcm1saW5rK1wiLVwiK3RpbWVmb3JtYXQsICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4X2FjY2VwdGVkX3BheW91dDogXCIxMDAwMDAwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogMTAwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHsgXCJiZW5lZmljaWFyaWVzXCI6IHsgXCJhY2NvdW50XCI6XCJlc3RlZW1hcHBcIiwgXCJ3ZWlnaHRcIjoxMDAgfSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5yZXBseWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5lcnJvciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmRhdGEuY29tbWVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnU1VDQ0VTUycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQ09NTUVOVF9TVUJNSVRURUQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KFwidXBkYXRlOmNvbnRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93TWVzc2FnZSgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnRVJST1InKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX0ZBSUwnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoKCRzY29wZS5wYXRjaGJvZHksICRzY29wZS5kYXRhLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dHRpbmcgYm9keSBpbnRvIGJ1ZmZlciB3aWxsIGV4cGFuZCBVbmljb2RlIGNoYXJhY3RlcnMgaW50byB0aGVpciB0cnVlIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2ggJiYgcGF0Y2gubGVuZ3RoIDwgbmV3IEJ1ZmZlcigkc2NvcGUuZGF0YS5jb21tZW50LCAndXRmLTgnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50MiA9IHBhdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cocGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdzaG93OmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5teWxvZ2luID0gbmV3IHdpbmRvdy5lanMuTG9naW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUubXlsb2dpbi5zZXRSb2xlcyhbXCJwb3N0aW5nXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudE5hbWU6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdGluZzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnBvc3Rpbmcua2V5X2F1dGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBuZXcgd2luZG93LmVqcy5UcmFuc2FjdGlvbkJ1aWxkZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpzb24gPSB7dGFnczogYW5ndWxhci5mcm9tSnNvbigkc2NvcGUucG9zdC5qc29uX21ldGFkYXRhKS50YWdzWzBdIHx8IFwiXCIsIGFwcDogJ2VzdGVlbS8nKyRyb290U2NvcGUuJHN0b3JhZ2UuYXBwdmVyc2lvbiwgZm9ybWF0OiAnbWFya2Rvd24raHRtbCcgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImNvbW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfYXV0aG9yOiAkc2NvcGUucG9zdC5wYXJlbnRfYXV0aG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfcGVybWxpbms6ICRzY29wZS5wb3N0LnBhcmVudF9wZXJtbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yOiAkc2NvcGUucG9zdC5hdXRob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiAkc2NvcGUucG9zdC5wZXJtbGluayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICRzY29wZS5kYXRhLmNvbW1lbnQyIHx8ICRzY29wZS5kYXRhLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25fbWV0YWRhdGE6ICRzY29wZS5wb3N0Lmpzb25fbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkX3R5cGVfb3BlcmF0aW9uKFwiY29tbWVudF9vcHRpb25zXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfY3VyYXRpb25fcmV3YXJkczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dfdm90ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcjogJHNjb3BlLnBvc3QuYXV0aG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJtbGluazogJHNjb3BlLnBvc3QucGVybWxpbmssICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4X2FjY2VwdGVkX3BheW91dDogXCIxMDAwMDAwLjAwMCBcIiskcm9vdFNjb3BlLiRzdG9yYWdlLnBsYXRmb3JtZHVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRfc3RlZW1fZG9sbGFyczogMTAwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IHsgXCJiZW5lZmljaWFyaWVzXCI6IHsgXCJhY2NvdW50XCI6XCJlc3RlZW1hcHBcIiwgXCJ3ZWlnaHRcIjoxMDAgfSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5sb2cobXlfcHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIucHJvY2Vzc190cmFuc2FjdGlvbigkc2NvcGUubXlsb2dpbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS5jbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUucmVwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuc2hvd0FsZXJ0KCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQlJPQURDQVNUX0VSUk9SJykrXCIgXCIrbG9jYWxTdG9yYWdlLmVycm9ybWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2NvcGUuZGF0YS5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdDT01NRU5UX1NVQk1JVFRFRCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJ1cGRhdGU6Y29udGVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnaGlkZTpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdFUlJPUicpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fRkFJTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dBbGVydCgkZmlsdGVyKCd0cmFuc2xhdGUnKSgnV0FSTklORycpLCAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnTE9HSU5fVE9fWCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkc2NvcGUucmVwbHlUb0NvbW1lbnQgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdyZXBseSB0byBjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLiRzdG9yYWdlLnNpdGVtID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLmlzcmVwbHlpbmcoY29tbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRzY29wZS5lZGl0Q29tbWVudCA9IGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ2VkaXQgdG8gY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgIC8vJHJvb3RTY29wZS4kc3RvcmFnZS5zaXRlbSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICRzY29wZS5pc3JlcGx5aW5nKGNvbW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHNjb3BlLmRlbGV0ZUNvbW1lbnQgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUubG9nKCdkZWxldGUgdG8gY29tbWVudCAnKyBhbmd1bGFyLnRvSnNvbihjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtUG9wdXAgPSAkaW9uaWNQb3B1cC5jb25maXJtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnQVJFX1lPVV9TVVJFJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJGZpbHRlcigndHJhbnNsYXRlJykoJ0RFTEVURV9DT01NRU5UJylcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1Qb3B1cC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgc3VyZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnc2hvdzpsb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290U2NvcGUuJHN0b3JhZ2UudXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4gPSBuZXcgd2luZG93LmVqcy5Mb2dpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLm15bG9naW4uc2V0Um9sZXMoW1wicG9zdGluZ1wiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9naW5TdWNjZXNzID0gJHNjb3BlLm15bG9naW4uY2hlY2tLZXlzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50TmFtZTogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0aW5nOiAkcm9vdFNjb3BlLiRzdG9yYWdlLnVzZXIucG9zdGluZy5rZXlfYXV0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6ICRyb290U2NvcGUuJHN0b3JhZ2UudXNlci5wcml2YXRlUG9zdGluZ0tleSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9naW5TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ciA9IG5ldyB3aW5kb3cuZWpzLlRyYW5zYWN0aW9uQnVpbGRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZF90eXBlX29wZXJhdGlvbihcImRlbGV0ZV9jb21tZW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3I6IGNvbW1lbnQuYXV0aG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcm1saW5rOiBjb21tZW50LnBlcm1saW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUubG9nKG15X3B1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UuZXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5wcm9jZXNzX3RyYW5zYWN0aW9uKCRzY29wZS5teWxvZ2luLCBudWxsLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZXJyb3IgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ0VSUk9SJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdCUk9BRENBU1RfRVJST1InKStcIiBcIitsb2NhbFN0b3JhZ2UuZXJyb3JtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLnNob3dNZXNzYWdlKCRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdTVUNDRVNTJyksICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdERUxFVEVEX0NPTU1FTlQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoXCJ1cGRhdGU6Y29udGVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdoaWRlOmxvYWRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2hpZGU6bG9hZGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5zaG93QWxlcnQoJGZpbHRlcigndHJhbnNsYXRlJykoJ1dBUk5JTkcnKSwgJGZpbHRlcigndHJhbnNsYXRlJykoJ0xPR0lOX1RPX1gnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5sb2coJ1lvdSBhcmUgbm90IHN1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW9uVGhyZWFkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgY29tbWVudHM6ICc9J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vUmVwbGFjZSBuZy1pZj1cIiFjb21tZW50LnNob3dDaGlsZHJlblwiIHdpdGggbmctaWY9XCJjb21tZW50LnNob3dDaGlsZHJlblwiIHRvIGhpZGUgYWxsIGNoaWxkIGNvbW1lbnRzIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIC8vUmVwbGFjZSBjb21tZW50LmRhdGEucmVwbGllcy5kYXRhLmNoaWxkcmVuIGFjY29yZGluZyB0byB0aGUgQVBJIHlvdSBhcmUgdXNpbmcgfCBvcmRlckJ5OlxcJy1uZXRfdm90ZXNcXCdcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPHNjcmlwdCB0eXBlPVwidGV4dC9uZy10ZW1wbGF0ZVwiIGlkPVwibm9kZS5odG1sXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW9uLWNvbW1lbnQgY29tbWVudD1cImNvbW1lbnRcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaW9uLWNvbW1lbnQ+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicmVkZGl0LXBvc3QtLWNvbW1lbnQtLWNvbnRhaW5lclwiPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgbmctaWY9XCJjb21tZW50LnNob3dDaGlsZHJlblwiIGNsYXNzPVwiYW5pbWF0ZS1pZiBpb24tY29tbWVudC0tY2hpbGRyZW5cIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbW1lbnQgaW4gY29tbWVudC5jb21tZW50cyB8IG9yZGVyQnk6XFwnLXBlbmRpbmdfcGF5b3V0X3ZhbHVlXFwnIHRyYWNrIGJ5ICRpbmRleCBcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1pbmNsdWRlIHNyYz1cIlxcJ25vZGUuaHRtbFxcJ1wiLz5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvc2NyaXB0PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW9uLWxpc3QgbmctaWY9XCJjb21tZW50cyAmJiBjb21tZW50cy5sZW5ndGggPiAwXCI+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIG5nLXJlcGVhdD1cImNvbW1lbnQgaW4gY29tbWVudHMgfCBvcmRlckJ5OlxcJy1wZW5kaW5nX3BheW91dF92YWx1ZVxcJyB0cmFjayBieSAkaW5kZXhcIj5cXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctaW5jbHVkZSBzcmM9XCJcXCdub2RlLmh0bWxcXCdcIi8+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaW9uLWxpc3Q+JyxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IGZ1bmN0aW9uKCRzY29wZSwgJHJvb3RTY29wZSkge1xuICAgICAgICAgICAgICAgIC8qJHNjb3BlLnRvZ2dsZUNvbW1lbnQgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyRyb290U2NvcGUubG9nKCd0b2dnbGVDb21tZW50Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5zaG93Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnNob3dDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTsqL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXVzKCRxLCAkaW9uaWNMb2FkaW5nLCAkY29yZG92YUZpbGVUcmFuc2ZlciwgJGlvbmljUGxhdGZvcm0sICRmaWx0ZXIsICRyb290U2NvcGUsIEFQSV9FTkRfUE9JTlQpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSB7fTtcbiAgICAgICAgc2VydmljZS51cGxvYWRJbWFnZSA9IHVwbG9hZEltYWdlO1xuICAgICAgICByZXR1cm4gc2VydmljZTtcbiAgICAgICAgZnVuY3Rpb24gdXBsb2FkSW1hZ2UoaW1hZ2VVUkkpIHtcbiAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgIHZhciBmaWxlU2l6ZTtcbiAgICAgICAgICB2YXIgcGVyY2VudGFnZTtcbiAgICAgICAgICAvKmlmIChpb25pYy5QbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgaWYgKGltYWdlVVJJLmluZGV4T2YoJ2ZpbGU6Ly8nKT09PS0xKSB7XG4gICAgICAgICAgICAgIGltYWdlVVJJPVwiZmlsZTovL1wiK2ltYWdlVVJJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0qL1xuICAgICAgICAgIC8vIEZpbmQgb3V0IGhvdyBiaWcgdGhlIG9yaWdpbmFsIGZpbGUgaXNcbiAgICAgICAgICB3aW5kb3cucmVzb2x2ZUxvY2FsRmlsZVN5c3RlbVVSTChpbWFnZVVSSSwgZnVuY3Rpb24oZmlsZUVudHJ5KSB7XG4gICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbihmaWxlT2JqKSB7XG4gICAgICAgICAgICAgIGZpbGVTaXplID0gZmlsZU9iai5zaXplO1xuICAgICAgICAgICAgICAvLyBEaXNwbGF5IGEgbG9hZGluZyBpbmRpY2F0b3IgcmVwb3J0aW5nIHRoZSBzdGFydCBvZiB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7dGVtcGxhdGUgOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FESU5HX1BJQ1RVUkUnKSArIDAgKyAnJSd9KTtcbiAgICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgdXBsb2FkXG4gICAgICAgICAgICAgIHVwbG9hZEZpbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZ1bmN0aW9uIHVwbG9hZEZpbGUoKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIENsb3VkaW5hcnkgXCJ1cGxvYWQgcHJlc2V0XCIgbmFtZSB0byB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgLy8gXCJodHRwczovL2FwaS5jbG91ZGluYXJ5LmNvbS92MV8xL2VzdGVlbS9pbWFnZS91cGxvYWRcIlxuICAgICAgICAgICAgdmFyIHVwbG9hZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgIHBhcmFtcyA6IHsgJ3VzZXJuYW1lJzogJHJvb3RTY29wZS4kc3RvcmFnZS51c2VyLnVzZXJuYW1lfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICRpb25pY1BsYXRmb3JtLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICRjb3Jkb3ZhRmlsZVRyYW5zZmVyLnVwbG9hZChBUElfRU5EX1BPSU5UK1wiL2FwaS91cGxvYWRcIiwgaW1hZ2VVUkksIHVwbG9hZE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExldCB0aGUgdXNlciBrbm93IHRoZSB1cGxvYWQgaXMgY29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7dGVtcGxhdGUgOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FEX0NPTVBMRVRFRCcpLCBkdXJhdGlvbjogMTAwMH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN1bHQgaGFzIGEgXCJyZXNwb25zZVwiIHByb3BlcnR5IHRoYXQgaXMgZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBGWUk6IFRoZSByZXN1bHQgd2lsbCBhbHNvIGhhdmUgVVJMcyBmb3IgYW55IG5ldyBpbWFnZXMgZ2VuZXJhdGVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gZWFnZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdC5yZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVaCBvaCFcbiAgICAgICAgICAgICAgICAgICAgJGlvbmljTG9hZGluZy5zaG93KHt0ZW1wbGF0ZSA6ICRmaWx0ZXIoJ3RyYW5zbGF0ZScpKCdVUExPQURfRkFJTEVEJyksIGR1cmF0aW9uOiAyMDAwfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1cGxvYWQgcGx1Z2luIGdpdmVzIHlvdSBpbmZvcm1hdGlvbiBhYm91dCBob3cgbXVjaCBkYXRhIGhhcyBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHNvbWUgaW50ZXJ2YWwuICBVc2UgdGhpcyB3aXRoIHRoZSBvcmlnaW5hbCBmaWxlIHNpemUgdG8gc2hvdyBhIHByb2dyZXNzIGluZGljYXRvci5cbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZSA9IE1hdGguZmxvb3IoKHByb2dyZXNzLmxvYWRlZCAvIGZpbGVTaXplKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICRpb25pY0xvYWRpbmcuc2hvdyh7dGVtcGxhdGUgOiAkZmlsdGVyKCd0cmFuc2xhdGUnKSgnVVBMT0FESU5HX1BJQ1RVUkUnKSArIHBlcmNlbnRhZ2UgKyAnJSd9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwLmZhY3RvcnkoJ0ltYWdlVXBsb2FkU2VydmljZScsIGl1cyk7XG5cbiAgICBhcHAuY29uc3RhbnQoJ2RlZmF1bHRTZXR0aW5ncycsIHtcbiAgICAgICAgYWxwaGFiZXRjb2xvcnM6IFtcIiM1QTg3NzBcIiwgXCIjQjJCN0JCXCIsIFwiIzZGQTlBQlwiLCBcIiNGNUFGMjlcIiwgXCIjMDA4OEI5XCIsIFwiI0YxODYzNlwiLCBcIiNEOTNBMzdcIiwgXCIjQTZCMTJFXCIsIFwiIzVDOUJCQ1wiLCBcIiNGNTg4OERcIiwgXCIjOUE4OUI1XCIsIFwiIzQwNzg4N1wiLCBcIiM5QTg5QjVcIiwgXCIjNUE4NzcwXCIsIFwiI0QzM0YzM1wiLCBcIiNBMkIwMUZcIiwgXCIjRjBCMTI2XCIsIFwiIzAwODdCRlwiLCBcIiNGMTg2MzZcIiwgXCIjMDA4N0JGXCIsIFwiI0IyQjdCQlwiLCBcIiM3MkFDQUVcIiwgXCIjOUM4QUI0XCIsIFwiIzVBODc3MFwiLCBcIiNFRUI0MjRcIiwgXCIjNDA3ODg3XCJdLFxuICAgICAgICB0ZXh0Q29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgZGVmYXVsdEJvcmRlcjogJ2JvcmRlcjo1cHggc29saWQgd2hpdGUnLFxuICAgICAgICB0cmlhbmdsZXVwOiAnd2lkdGg6IDA7aGVpZ2h0OiAwO2JvcmRlci1sZWZ0OiA1MHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDogNTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOiAxMDBweCBzb2xpZDsnLFxuICAgICAgICBmb250c2l6ZTogMzAsIC8vIHVuaXQgaW4gcGl4ZWxzXG4gICAgICAgIGhlaWdodDogNTAsIC8vIHVuaXQgaW4gcGl4ZWxzXG4gICAgICAgIHdpZHRoOiA1MCwgLy8gdW5pdCBpbiBwaXhlbHNcbiAgICAgICAgZm9udFdlaWdodDogNDAwLCAvL1xuICAgICAgICBjaGFyQ291bnQ6IDEsXG4gICAgICAgIGZvbnRGYW1pbHk6ICdIZWx2ZXRpY2FOZXVlLUxpZ2h0LEhlbHZldGljYSBOZXVlIExpZ2h0LEhlbHZldGljYSBOZXVlLEhlbHZldGljYSwgQXJpYWwsTHVjaWRhIEdyYW5kZSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGJhc2U6ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCcsXG4gICAgICAgIHJhZGl1czogJ2JvcmRlci1yYWRpdXM6NTAlOycsXG4gICAgICAgIGN1c3RvbWJnY29sb3I6ICcnLFxuICAgICAgICBkeW5hbWljOiAnZmFsc2UnLFxuICAgICAgICByb3RhdGVkZWc6ICcwJ1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogZGlyZWN0aXZlIHRvIGNyZWF0ZSB0aGUgYXZhdGFyXG4gICAgICogQHBhcmFtIHt0eXBlfSBwYXJhbTFcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHBhcmFtMlxuICAgICAqL1xuICAgIGFwcC5kaXJlY3RpdmUoJ25nTGV0dGVyQXZhdGFyJywgWydkZWZhdWx0U2V0dGluZ3MnLCBmdW5jdGlvbiAoZGVmYXVsdFNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0FFJyxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIGFscGhhYmV0Y29sb3JzOiAnPWFscGhhYmV0Y29sb3JzJyxcbiAgICAgICAgICAgICAgICBkYXRhOiAnQCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbiAoc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQb3B1bGF0ZSB0aGUgYXR0cmlidXRlIHZhbHVlcyB0byBwYXJhbXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgICogQHR5cGUgdHlwZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudDogYXR0cnMuY2hhcmNvdW50IHx8IGRlZmF1bHRTZXR0aW5ncy5jaGFyQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGF0dHJzLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogZGVmYXVsdFNldHRpbmdzLnRleHRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBhdHRycy5oZWlnaHQgfHwgZGVmYXVsdFNldHRpbmdzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGF0dHJzLndpZHRoIHx8IGRlZmF1bHRTZXR0aW5ncy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZm9udHNpemU6IGF0dHJzLmZvbnRzaXplIHx8IGRlZmF1bHRTZXR0aW5ncy5mb250c2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogYXR0cnMuZm9udHdlaWdodCB8fCBkZWZhdWx0U2V0dGluZ3MuZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogYXR0cnMuZm9udGZhbWlseSB8fCBkZWZhdWx0U2V0dGluZ3MuZm9udEZhbWlseSxcbiAgICAgICAgICAgICAgICAgICAgYXZhdGFyQm9yZGVyU3R5bGU6IGF0dHJzLmF2YXRhcmN1c3RvbWJvcmRlcixcbiAgICAgICAgICAgICAgICAgICAgYXZhdGFyZGVmYXVsdEJvcmRlcjogYXR0cnMuYXZhdGFyYm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0Qm9yZGVyOiBkZWZhdWx0U2V0dGluZ3MuZGVmYXVsdEJvcmRlcixcbiAgICAgICAgICAgICAgICAgICAgc2hhcGU6IGF0dHJzLnNoYXBlLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYWJldGNvbG9yczogc2NvcGUuYWxwaGFiZXRjb2xvcnMgfHwgZGVmYXVsdFNldHRpbmdzLmFscGhhYmV0Y29sb3JzLFxuICAgICAgICAgICAgICAgICAgICBhdmF0YXJDdXN0b21CR0NvbG9yOiBhdHRycy5hdmF0YXJjdXN0b21iZ2NvbG9yIHx8IGRlZmF1bHRTZXR0aW5ncy5jdXN0b21iZ2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljOiBhdHRycy5keW5hbWljIHx8IGRlZmF1bHRTZXR0aW5ncy5keW5hbWljLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGVkZWc6IGF0dHJzLnJvdGF0ZWRlZyB8fCBkZWZhdWx0U2V0dGluZ3Mucm90YXRlZGVnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHRvIGdlbmVyYXRlIHRoZSBhdmF0YXIgZHluYW1pY2FsbHkgb24gZGF0YSBjaGFuZ2UsIGVuYWJsZSB0aGUgYmVsb3cgZnVuY3Rpb24gdG8gd2F0Y2ggdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dlbmVyYXRlTGV0dGVyQXZhdGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9nZW5lcmF0ZUxldHRlckF2YXRhcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9nZW5lcmF0ZUxldHRlckF2YXRhcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5jaGFyQ291bnQgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kYXRhID0gZ2V0Rmlyc3RBbmRMYXN0TmFtZShzY29wZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IF9kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gc2NvcGUuZGF0YS5zdWJzdHIoMCwgcGFyYW1zLmNoYXJDb3VudCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzY29wZS5kYXRhLnN1YnN0cigwLCBwYXJhbXMuY2hhckNvdW50KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2JqID0gZ2V0Q2hhcmFjdGVyT2JqZWN0KGMsIHBhcmFtcy50ZXh0Q29sb3IsIHBhcmFtcy5mb250RmFtaWx5LCBwYXJhbXMuZm9udFdlaWdodCwgcGFyYW1zLmZvbnRzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9ySW5kZXggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFBvcHVsYXRlIHRoZSBjb2xvcnMgYWNjb3JkaW5nIHRvIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmNoYXJDb2RlQXQoMCkgPCA2NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBnZXRSYW5kb21Db2xvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBNYXRoLmZsb29yKChjLmNoYXJDb2RlQXQoMCkgLSA2NSkgJSBwYXJhbXMuYWxwaGFiZXRjb2xvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gcGFyYW1zLmFscGhhYmV0Y29sb3JzW2NvbG9ySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5hdmF0YXJDdXN0b21CR0NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IHBhcmFtcy5hdmF0YXJDdXN0b21CR0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN2ZyA9IGdldEltZ1RhZyhwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZChjb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGx2Y29tcG9uZW50ID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2PicpLmFwcGVuZChzdmcuY2xvbmUoKSkuaHRtbCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnSHRtbCA9IHdpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChsdmNvbXBvbmVudCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBkZWZhdWx0U2V0dGluZ3MuYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdHlsZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmF2YXRhckJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3R5bGUgPSBwYXJhbXMuYXZhdGFyQm9yZGVyU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmF2YXRhcmRlZmF1bHRCb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHlsZSA9IHBhcmFtcy5kZWZhdWx0Qm9yZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yb3RhdGVkZWcgIT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3R5bGUgPSAnLW1zLXRyYW5zZm9ybTogcm90YXRlKCcgKyBwYXJhbXMucm90YXRlZGVnICsgJ2RlZyk7IC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoJyArIHBhcmFtcy5yb3RhdGVkZWcgKyAnZGVnKTsgdHJhbnNmb3JtOiByb3RhdGUoJyArIHBhcmFtcy5yb3RhdGVkZWcgKyAnZGVnKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLnNoYXBlID09PSAncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdW5kX3N0eWxlID0gZGVmYXVsdFNldHRpbmdzLnJhZGl1cyArIF9zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuZGF0YS5pbmRleE9mKCdodHRwJykgPiAtMSB8fCBzY29wZS5kYXRhLmluZGV4T2YoJ2RhdGE6aW1hZ2UnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWdfc2l6ZSA9ICd3aWR0aDonICsgcGFyYW1zLndpZHRoICsgJ3B4O2hlaWdodDonICsgcGFyYW1zLmhlaWdodCArICdweDsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBcIjxpbWcgc3JjPVwiICsgc2NvcGUuZGF0YSArIFwiIHN0eWxlPSdcIiArIGltZ19zaXplICsgcm91bmRfc3R5bGUgKyBcIicgIC8+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50ID0gXCI8aW1nIHNyYz1cIiArIGJhc2UgKyBzdmdIdG1sICsgXCIgc3R5bGU9J1wiICsgcm91bmRfc3R5bGUgKyBcIicgdGl0bGU9J1wiICsgc2NvcGUuZGF0YSArIFwiJyAvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5kYXRhLmluZGV4T2YoJ2h0dHAnKSA+IC0xIHx8IHNjb3BlLmRhdGEuaW5kZXhPZignZGF0YTppbWFnZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nX3NpemUgPSAnd2lkdGg6JyArIHBhcmFtcy53aWR0aCArICdweDtoZWlnaHQ6JyArIHBhcmFtcy5oZWlnaHQgKyAncHg7JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBcIjxpbWcgc3JjPVwiICsgc2NvcGUuZGF0YSArIFwiIHN0eWxlPSdcIiArIGltZ19zaXplICsgX3N0eWxlICsgXCInICAvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBcIjxpbWcgc3JjPVwiICsgYmFzZSArIHN2Z0h0bWwgKyBcIiBzdHlsZT0nXCIgKyBfc3R5bGUgKyBcIicgdGl0bGU9J1wiICsgc2NvcGUuZGF0YSArIFwiJyAvPlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5keW5hbWljID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlcGxhY2VXaXRoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfV0pO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmFuZG9tIGNvbG9yc1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmFuZG9tQ29sb3JzKCkge1xuICAgICAgICB2YXIgbGV0dGVycyA9ICcwMTIzNDU2Nzg5QUJDREVGJy5zcGxpdCgnJyk7XG4gICAgICAgIHZhciBfY29sb3IgPSAnIyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBfY29sb3IgKz0gbGV0dGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNildO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY29sb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lIGZpcnN0IGxldHRlcnMgYW5kIGNvbWJpbmVkIGFuZCBmb3JtIHRoZSBsZXR0ZXIgYXZhdGFyXG4gICAgICogQHBhcmFtIHt0eXBlfSBkYXRhXG4gICAgICogQHJldHVybnMge3VucmVzb2x2ZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RBbmRMYXN0TmFtZShkYXRhKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IGRhdGEuc3BsaXQoXCIgXCIpO1xuICAgICAgICBpZiAobmFtZXMgJiYgbmFtZXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE5hbWUgPSBuYW1lc1swXTtcbiAgICAgICAgICAgIHZhciBsYXN0TmFtZSA9IG5hbWVzWzFdO1xuICAgICAgICAgICAgaWYgKGZpcnN0TmFtZSAmJiBsYXN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmlyc3ROYW1lLnN1YnN0cigwLCAxKSArIGxhc3ROYW1lLnN1YnN0cigwLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuc3Vic3RyKDAsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIHN2ZyB0YWcgd2hpY2ggd2lsbCB1c2VkIGZvciB0aGUgYXZhdGFyIGdlbmVyYXRpb25cbiAgICAgKiBAcGFyYW0ge3R5cGV9IHdpZHRoXG4gICAgICogQHBhcmFtIHt0eXBlfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGNvbG9yXG4gICAgICogQHJldHVybnMge3VucmVzb2x2ZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW1nVGFnKHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XG5cbiAgICAgICAgdmFyIHN2Z1RhZyA9IGFuZ3VsYXIuZWxlbWVudCgnPHN2Zz48L3N2Zz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IGhlaWdodFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6IGhlaWdodCArICdweCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc3ZnVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBHZW5lcmF0ZSB0aGUgTGV0dGVyIHRhZyBieSB1c2luZyB0aGUgc3ZnIHRleHQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHt0eXBlfSB0ZXh0Q29sb3JcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGZvbnRXZWlnaHRcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGZvbnRzaXplXG4gICAgICogQHJldHVybnMge3VucmVzb2x2ZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyT2JqZWN0KGNoYXJhY3RlciwgdGV4dENvbG9yLCBmb250RmFtaWx5LCBmb250V2VpZ2h0LCBmb250c2l6ZSkge1xuICAgICAgICB2YXIgdGV4dFRhZyA9IGFuZ3VsYXIuZWxlbWVudCgnPHRleHQgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj48L3RleHQ+JylcbiAgICAgICAgICAgICAgICAuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgICd5JzogJzUwJScsXG4gICAgICAgICAgICAgICAgICAgICd4JzogJzUwJScsXG4gICAgICAgICAgICAgICAgICAgICdkeSc6ICcwLjM1ZW0nLFxuICAgICAgICAgICAgICAgICAgICAvLydzdHJva2UnOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwnOiB0ZXh0Q29sb3IsXG4gICAgICAgICAgICAgICAgICAgICdmb250LWZhbWlseSc6IGZvbnRGYW1pbHlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5odG1sKGNoYXJhY3RlcilcbiAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRzaXplICsgJ3B4JyxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGV4dFRhZztcbiAgICB9XG5cbn1cblxuXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwicEJHdkFwXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvcG9zdHMvc2VydmljZXMuanNcIixcIi9wb3N0c1wiKSJdfQ==
